diff -Nurb linux-2.6.22-510/include/linux/netfilter/xt_MARK.h linux-2.6.22-520/include/linux/netfilter/xt_MARK.h
--- linux-2.6.22-510/include/linux/netfilter/xt_MARK.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-520/include/linux/netfilter/xt_MARK.h	2008-02-20 04:13:12.000000000 -0500
@@ -11,6 +11,7 @@
 	XT_MARK_SET=0,
 	XT_MARK_AND,
 	XT_MARK_OR,
+	XT_MARK_COPYXID,
 };
 
 struct xt_mark_target_info_v1 {
diff -Nurb linux-2.6.22-510/include/linux/netfilter/xt_SETXID.h linux-2.6.22-520/include/linux/netfilter/xt_SETXID.h
--- linux-2.6.22-510/include/linux/netfilter/xt_SETXID.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-520/include/linux/netfilter/xt_SETXID.h	2008-02-20 04:13:12.000000000 -0500
@@ -0,0 +1,14 @@
+#ifndef _XT_SETXID_H_target
+#define _XT_SETXID_H_target
+
+/* Version 1 */
+enum {
+	XT_SET_PACKET_XID=0
+};
+
+struct xt_setxid_target_info_v1 {
+	unsigned long mark;
+	u_int8_t mode;
+};
+
+#endif /*_XT_SETXID_H_target*/
diff -Nurb linux-2.6.22-510/include/linux/netfilter_ipv4/ipt_MARK.h linux-2.6.22-520/include/linux/netfilter_ipv4/ipt_MARK.h
--- linux-2.6.22-510/include/linux/netfilter_ipv4/ipt_MARK.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-520/include/linux/netfilter_ipv4/ipt_MARK.h	2008-02-20 04:13:12.000000000 -0500
@@ -12,6 +12,7 @@
 #define IPT_MARK_SET	XT_MARK_SET
 #define IPT_MARK_AND	XT_MARK_AND
 #define	IPT_MARK_OR	XT_MARK_OR
+#define IPT_MARK_COPYXID	XT_MARK_COPYXID
 
 #define ipt_mark_target_info_v1 xt_mark_target_info_v1
 
diff -Nurb linux-2.6.22-510/include/linux/netfilter_ipv4/ipt_SETXID.h linux-2.6.22-520/include/linux/netfilter_ipv4/ipt_SETXID.h
--- linux-2.6.22-510/include/linux/netfilter_ipv4/ipt_SETXID.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-520/include/linux/netfilter_ipv4/ipt_SETXID.h	2008-02-20 04:13:12.000000000 -0500
@@ -0,0 +1,13 @@
+#ifndef _IPT_SETXID_H_target
+#define _IPT_SETXID_H_target
+
+/* Backwards compatibility for old userspace */
+
+#include <linux/netfilter/xt_SETXID.h>
+
+/* Version 1 */
+#define IPT_SET_PACKET_XID	XT_SET_PACKET_XID
+
+#define ipt_setxid_target_info_v1 xt_setxid_target_info_v1
+
+#endif /*_IPT_SETXID_H_target*/
diff -Nurb linux-2.6.22-510/include/linux/skbuff.h linux-2.6.22-520/include/linux/skbuff.h
--- linux-2.6.22-510/include/linux/skbuff.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-520/include/linux/skbuff.h	2008-02-20 04:13:12.000000000 -0500
@@ -302,6 +302,7 @@
 #endif
 
 	__u32			mark;
+#define skb_tag			mark
 
 	sk_buff_data_t		transport_header;
 	sk_buff_data_t		network_header;
diff -Nurb linux-2.6.22-510/include/linux/socket.h linux-2.6.22-520/include/linux/socket.h
--- linux-2.6.22-510/include/linux/socket.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-520/include/linux/socket.h	2008-02-20 04:13:12.000000000 -0500
@@ -288,6 +288,8 @@
 #define SOL_TIPC	271
 #define SOL_RXRPC	272
 
+#define SO_SETXID	SO_PEERCRED
+
 /* IPX options */
 #define IPX_TYPE	1
 
diff -Nurb linux-2.6.22-510/include/linux/vserver/network.h linux-2.6.22-520/include/linux/vserver/network.h
--- linux-2.6.22-510/include/linux/vserver/network.h	2008-02-20 04:13:10.000000000 -0500
+++ linux-2.6.22-520/include/linux/vserver/network.h	2008-02-20 04:13:12.000000000 -0500
@@ -45,6 +45,8 @@
 /* network caps */
 
 #define NXC_RAW_ICMP		0x00000100
+#define NXC_RAW_SOCKET		0x00000200
+#define NXC_RAW_SEND		0x00000400
 
 
 /* address types */
diff -Nurb linux-2.6.22-510/include/linux/vserver/network.h.orig linux-2.6.22-520/include/linux/vserver/network.h.orig
--- linux-2.6.22-510/include/linux/vserver/network.h.orig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-520/include/linux/vserver/network.h.orig	2008-02-20 04:13:12.000000000 -0500
@@ -0,0 +1,144 @@
+#ifndef _VX_NETWORK_H
+#define _VX_NETWORK_H
+
+#include <linux/types.h>
+
+
+#define MAX_N_CONTEXT	65535	/* Arbitrary limit */
+
+
+/* network flags */
+
+#define NXF_INFO_PRIVATE	0x00000008
+
+#define NXF_SINGLE_IP		0x00000100
+#define NXF_LBACK_REMAP		0x00000200
+#define NXF_LBACK_ALLOW		0x00000400
+
+#define NXF_HIDE_NETIF		0x02000000
+#define NXF_HIDE_LBACK		0x04000000
+
+#define NXF_STATE_SETUP		(1ULL << 32)
+#define NXF_STATE_ADMIN		(1ULL << 34)
+
+#define NXF_SC_HELPER		(1ULL << 36)
+#define NXF_PERSISTENT		(1ULL << 38)
+
+#define NXF_ONE_TIME		(0x0005ULL << 32)
+
+
+#define	NXF_INIT_SET		(__nxf_init_set())
+
+static inline uint64_t __nxf_init_set(void) {
+	return	  NXF_STATE_ADMIN
+#ifdef	CONFIG_VSERVER_AUTO_LBACK
+		| NXF_LBACK_REMAP
+		| NXF_HIDE_LBACK
+#endif
+#ifdef	CONFIG_VSERVER_AUTO_SINGLE
+		| NXF_SINGLE_IP
+#endif
+		| NXF_HIDE_NETIF;
+}
+
+
+/* network caps */
+
+#define NXC_RAW_ICMP		0x00000100
+
+
+/* address types */
+
+#define NXA_TYPE_IPV4		0x0001
+#define NXA_TYPE_IPV6		0x0002
+
+#define NXA_TYPE_NONE		0x0000
+#define NXA_TYPE_ANY		0x00FF
+
+#define NXA_TYPE_ADDR		0x0010
+#define NXA_TYPE_MASK		0x0020
+#define NXA_TYPE_RANGE		0x0040
+
+#define NXA_MASK_ALL		(NXA_TYPE_ADDR | NXA_TYPE_MASK | NXA_TYPE_RANGE)
+
+#define NXA_MOD_BCAST		0x0100
+#define NXA_MOD_LBACK		0x0200
+
+#define NXA_LOOPBACK		0x1000
+
+#define NXA_MASK_BIND		(NXA_MASK_ALL | NXA_MOD_BCAST | NXA_MOD_LBACK)
+#define NXA_MASK_SHOW		(NXA_MASK_ALL | NXA_LOOPBACK)
+
+#ifdef	__KERNEL__
+
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/rcupdate.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+#include <asm/atomic.h>
+
+struct nx_addr_v4 {
+	struct nx_addr_v4 *next;
+	struct in_addr ip[2];
+	struct in_addr mask;
+	uint16_t type;
+	uint16_t flags;
+};
+
+struct nx_addr_v6 {
+	struct nx_addr_v6 *next;
+	struct in6_addr ip;
+	struct in6_addr mask;
+	uint32_t prefix;
+	uint16_t type;
+	uint16_t flags;
+};
+
+struct nx_info {
+	struct hlist_node nx_hlist;	/* linked list of nxinfos */
+	nid_t nx_id;			/* vnet id */
+	atomic_t nx_usecnt;		/* usage count */
+	atomic_t nx_tasks;		/* tasks count */
+	int nx_state;			/* context state */
+
+	uint64_t nx_flags;		/* network flag word */
+	uint64_t nx_ncaps;		/* network capabilities */
+
+	struct in_addr v4_lback;	/* Loopback address */
+	struct in_addr v4_bcast;	/* Broadcast address */
+	struct nx_addr_v4 v4;		/* First/Single ipv4 address */
+#ifdef	CONFIG_IPV6
+	struct nx_addr_v6 v6;		/* First/Single ipv6 address */
+#endif
+	char nx_name[65];		/* network context name */
+};
+
+
+/* status flags */
+
+#define NXS_HASHED      0x0001
+#define NXS_SHUTDOWN    0x0100
+#define NXS_RELEASED    0x8000
+
+extern struct nx_info *lookup_nx_info(int);
+
+extern int get_nid_list(int, unsigned int *, int);
+extern int nid_is_hashed(nid_t);
+
+extern int nx_migrate_task(struct task_struct *, struct nx_info *);
+
+extern long vs_net_change(struct nx_info *, unsigned int);
+
+struct sock;
+
+
+#define NX_IPV4(n)	((n)->v4.type != NXA_TYPE_NONE)
+#ifdef  CONFIG_IPV6
+#define NX_IPV6(n)	((n)->v6.type != NXA_TYPE_NONE)
+#else
+#define NX_IPV6(n)	(0)
+#endif
+
+#endif	/* __KERNEL__ */
+#endif	/* _VX_NETWORK_H */
diff -Nurb linux-2.6.22-510/include/net/netfilter/nf_conntrack.h linux-2.6.22-520/include/net/netfilter/nf_conntrack.h
--- linux-2.6.22-510/include/net/netfilter/nf_conntrack.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-520/include/net/netfilter/nf_conntrack.h	2008-02-20 04:13:12.000000000 -0500
@@ -131,6 +131,9 @@
 	/* Storage reserved for other modules: */
 	union nf_conntrack_proto proto;
 
+	/* PLANETLAB. VNET-specific */
+	xid_t xid[IP_CT_DIR_MAX];
+
 	/* features dynamically at the end: helper, nat (both optional) */
 	char data[0];
 };
diff -Nurb linux-2.6.22-510/include/net/raw.h linux-2.6.22-520/include/net/raw.h
--- linux-2.6.22-510/include/net/raw.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-520/include/net/raw.h	2008-02-20 04:13:12.000000000 -0500
@@ -36,7 +36,7 @@
 
 extern struct sock *__raw_v4_lookup(struct sock *sk, unsigned short num,
 				    __be32 raddr, __be32 laddr,
-				    int dif);
+				    int dif, int tag);
 
 extern int raw_v4_input(struct sk_buff *skb, struct iphdr *iph, int hash);
 
diff -Nurb linux-2.6.22-510/net/core/skbuff.c linux-2.6.22-520/net/core/skbuff.c
--- linux-2.6.22-510/net/core/skbuff.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-520/net/core/skbuff.c	2008-02-20 04:13:12.000000000 -0500
@@ -56,6 +56,7 @@
 #include <linux/rtnetlink.h>
 #include <linux/init.h>
 #include <linux/scatterlist.h>
+#include <linux/vs_network.h>
 
 #include <net/protocol.h>
 #include <net/dst.h>
@@ -174,6 +175,7 @@
 	skb->data = data;
 	skb_reset_tail_pointer(skb);
 	skb->end = skb->tail + size;
+	skb->skb_tag = nx_current_nid();
 	/* make sure we initialize shinfo sequentially */
 	shinfo = skb_shinfo(skb);
 	atomic_set(&shinfo->dataref, 1);
@@ -443,6 +445,8 @@
 	C(tail);
 	C(end);
 
+	/* Sapan: Cloned skbs aren't owned by anyone. Let the cloner decide who it belongs to. */
+
 	atomic_inc(&(skb_shinfo(skb)->dataref));
 	skb->cloned = 1;
 
@@ -492,6 +496,7 @@
 	new->tc_index	= old->tc_index;
 #endif
 	skb_copy_secmark(new, old);
+	new->skb_tag = old->skb_tag;
 	atomic_set(&new->users, 1);
 	skb_shinfo(new)->gso_size = skb_shinfo(old)->gso_size;
 	skb_shinfo(new)->gso_segs = skb_shinfo(old)->gso_segs;
diff -Nurb linux-2.6.22-510/net/core/sock.c linux-2.6.22-520/net/core/sock.c
--- linux-2.6.22-510/net/core/sock.c	2008-02-20 04:13:09.000000000 -0500
+++ linux-2.6.22-520/net/core/sock.c	2008-02-20 04:13:12.000000000 -0500
@@ -444,6 +444,19 @@
 		}
 		goto set_sndbuf;
 
+	case SO_SETXID:
+		if (current_vx_info()) {
+			ret = -EPERM;
+			break;
+		}
+		if (val < 0 || val > MAX_S_CONTEXT) {
+			ret = -EINVAL;
+			break;
+		}
+		sk->sk_xid = val;
+		sk->sk_nid = val;
+		break;
+
 	case SO_RCVBUF:
 		/* Don't error on this BSD doesn't and if you think
 		   about it this is right. Otherwise apps have to
@@ -573,7 +586,7 @@
 		char devname[IFNAMSIZ];
 
 		/* Sorry... */
-		if (!capable(CAP_NET_RAW)) {
+		if (!nx_capable(CAP_NET_RAW, NXC_RAW_SOCKET)) {
 			ret = -EPERM;
 			break;
 		}
diff -Nurb linux-2.6.22-510/net/ipv4/af_inet.c linux-2.6.22-520/net/ipv4/af_inet.c
--- linux-2.6.22-510/net/ipv4/af_inet.c	2008-02-20 04:13:09.000000000 -0500
+++ linux-2.6.22-520/net/ipv4/af_inet.c	2008-02-20 04:13:12.000000000 -0500
@@ -178,6 +178,8 @@
 			return -EAGAIN;
 		}
 		inet->sport = htons(inet->num);
+		sk->sk_xid = vx_current_xid();
+		sk->sk_nid = nx_current_nid();
 	}
 	release_sock(sk);
 	return 0;
@@ -312,6 +314,9 @@
 	if ((protocol == IPPROTO_ICMP) &&
 		nx_capable(answer->capability, NXC_RAW_ICMP))
 		goto override;
+	if (sock->type == SOCK_RAW &&
+		nx_capable(answer->capability, NXC_RAW_SOCKET))
+		goto override;
 	if (answer->capability > 0 && !capable(answer->capability))
 		goto out_rcu_unlock;
 override:
diff -Nurb linux-2.6.22-510/net/ipv4/icmp.c linux-2.6.22-520/net/ipv4/icmp.c
--- linux-2.6.22-510/net/ipv4/icmp.c	2008-02-20 04:13:12.000000000 -0500
+++ linux-2.6.22-520/net/ipv4/icmp.c	2008-02-20 04:13:12.000000000 -0500
@@ -709,7 +709,7 @@
 	if ((raw_sk = sk_head(&raw_v4_htable[hash])) != NULL) {
 		while ((raw_sk = __raw_v4_lookup(raw_sk, protocol, iph->daddr,
 						 iph->saddr,
-						 skb->dev->ifindex)) != NULL) {
+						 skb->dev->ifindex, skb->skb_tag)) != NULL) {
 			raw_err(raw_sk, skb, info);
 			raw_sk = sk_next(raw_sk);
 			iph = (struct iphdr *)skb->data;
diff -Nurb linux-2.6.22-510/net/ipv4/ip_options.c linux-2.6.22-520/net/ipv4/ip_options.c
--- linux-2.6.22-510/net/ipv4/ip_options.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-520/net/ipv4/ip_options.c	2008-02-20 04:13:12.000000000 -0500
@@ -409,7 +409,7 @@
 					optptr[2] += 8;
 					break;
 				      default:
-					if (!skb && !capable(CAP_NET_RAW)) {
+					if (!skb && !nx_capable(CAP_NET_RAW, NXC_RAW_SOCKET)) {
 						pp_ptr = optptr + 3;
 						goto error;
 					}
@@ -445,7 +445,7 @@
 				opt->router_alert = optptr - iph;
 			break;
 		      case IPOPT_CIPSO:
-			if ((!skb && !capable(CAP_NET_RAW)) || opt->cipso) {
+			if ((!skb && !nx_capable(CAP_NET_RAW, NXC_RAW_SOCKET)) || opt->cipso) {
 				pp_ptr = optptr;
 				goto error;
 			}
@@ -458,7 +458,7 @@
 		      case IPOPT_SEC:
 		      case IPOPT_SID:
 		      default:
-			if (!skb && !capable(CAP_NET_RAW)) {
+			if (!skb && !nx_capable(CAP_NET_RAW, NXC_RAW_SOCKET)) {
 				pp_ptr = optptr;
 				goto error;
 			}
diff -Nurb linux-2.6.22-510/net/ipv4/netfilter/ipt_LOG.c linux-2.6.22-520/net/ipv4/netfilter/ipt_LOG.c
--- linux-2.6.22-510/net/ipv4/netfilter/ipt_LOG.c	2008-02-20 04:13:05.000000000 -0500
+++ linux-2.6.22-520/net/ipv4/netfilter/ipt_LOG.c	2008-02-20 04:13:12.000000000 -0500
@@ -49,6 +49,8 @@
 	else
 		logflags = NF_LOG_MASK;
 
+	printk("TAG=%d ", skb->skb_tag);
+
 	ih = skb_header_pointer(skb, iphoff, sizeof(_iph), &_iph);
 	if (ih == NULL) {
 		printk("TRUNCATED");
diff -Nurb linux-2.6.22-510/net/ipv4/raw.c linux-2.6.22-520/net/ipv4/raw.c
--- linux-2.6.22-510/net/ipv4/raw.c	2008-02-20 04:13:09.000000000 -0500
+++ linux-2.6.22-520/net/ipv4/raw.c	2008-02-20 04:13:12.000000000 -0500
@@ -103,7 +103,7 @@
 
 struct sock *__raw_v4_lookup(struct sock *sk, unsigned short num,
 			     __be32 raddr, __be32 laddr,
-			     int dif)
+			     int dif, int tag)
 {
 	struct hlist_node *node;
 
@@ -112,6 +112,7 @@
 
 		if (inet->num == num 					&&
 		    !(inet->daddr && inet->daddr != raddr) 		&&
+		    (!sk->sk_nx_info || tag == 1 || sk->sk_nid == tag)	&&
 		    v4_sock_addr_match(sk->sk_nx_info, inet, laddr)	&&
 		    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))
 			goto found; /* gotcha */
@@ -161,7 +162,7 @@
 		goto out;
 	sk = __raw_v4_lookup(__sk_head(head), iph->protocol,
 			     iph->saddr, iph->daddr,
-			     skb->dev->ifindex);
+			     skb->dev->ifindex, skb->skb_tag);
 
 	while (sk) {
 		delivered = 1;
@@ -174,7 +175,7 @@
 		}
 		sk = __raw_v4_lookup(sk_next(sk), iph->protocol,
 				     iph->saddr, iph->daddr,
-				     skb->dev->ifindex);
+				     skb->dev->ifindex, skb->skb_tag);
 	}
 out:
 	read_unlock(&raw_v4_lock);
@@ -315,7 +316,7 @@
 	}
 
 	err = -EPERM;
-	if (!nx_check(0, VS_ADMIN) && !capable(CAP_NET_RAW) &&
+	if (!nx_check(0, VS_ADMIN) && !nx_capable(CAP_NET_RAW, NXC_RAW_SOCKET) &&
 		sk->sk_nx_info &&
 		!v4_addr_in_nx_info(sk->sk_nx_info, iph->saddr, NXA_MASK_BIND))
 		goto error_free;
diff -Nurb linux-2.6.22-510/net/netfilter/Kconfig linux-2.6.22-520/net/netfilter/Kconfig
--- linux-2.6.22-510/net/netfilter/Kconfig	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-520/net/netfilter/Kconfig	2008-02-20 04:13:12.000000000 -0500
@@ -389,6 +389,13 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_TARGET_SETXID
+	tristate '"SETXID" target support'
+	depends on NETFILTER_XTABLES
+	help
+	  This option adds a `SETXID' target, which allows you to alter the
+	  xid of a socket.
+
 config NETFILTER_XT_MATCH_COMMENT
 	tristate  '"comment" match support'
 	depends on NETFILTER_XTABLES
diff -Nurb linux-2.6.22-510/net/netfilter/Makefile linux-2.6.22-520/net/netfilter/Makefile
--- linux-2.6.22-510/net/netfilter/Makefile	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-520/net/netfilter/Makefile	2008-02-20 04:13:12.000000000 -0500
@@ -37,6 +37,7 @@
 obj-$(CONFIG_NETFILTER_XTABLES) += x_tables.o xt_tcpudp.o
 
 # targets
+obj-$(CONFIG_NETFILTER_XT_TARGET_SETXID) += xt_SETXID.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_CLASSIFY) += xt_CLASSIFY.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_CONNMARK) += xt_CONNMARK.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_DSCP) += xt_DSCP.o
diff -Nurb linux-2.6.22-510/net/netfilter/nf_conntrack_core.c linux-2.6.22-520/net/netfilter/nf_conntrack_core.c
--- linux-2.6.22-510/net/netfilter/nf_conntrack_core.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-520/net/netfilter/nf_conntrack_core.c	2008-02-20 04:13:12.000000000 -0500
@@ -726,6 +726,8 @@
 
 	/* Overload tuple linked list to put us in unconfirmed list. */
 	list_add(&conntrack->tuplehash[IP_CT_DIR_ORIGINAL].list, &unconfirmed);
+	conntrack->xid[IP_CT_DIR_ORIGINAL] = -1;
+	conntrack->xid[IP_CT_DIR_REPLY] = -1;
 
 	write_unlock_bh(&nf_conntrack_lock);
 
diff -Nurb linux-2.6.22-510/net/netfilter/xt_MARK.c linux-2.6.22-520/net/netfilter/xt_MARK.c
--- linux-2.6.22-510/net/netfilter/xt_MARK.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-520/net/netfilter/xt_MARK.c	2008-02-20 06:56:29.000000000 -0500
@@ -5,13 +5,18 @@
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
+ *
  */
 
 #include <linux/module.h>
+#include <linux/version.h>
 #include <linux/skbuff.h>
 #include <linux/ip.h>
 #include <net/checksum.h>
+#include <net/route.h>
+#include <net/inet_hashtables.h>
 
+#include <net/netfilter/nf_conntrack.h>
 #include <linux/netfilter/x_tables.h>
 #include <linux/netfilter/xt_MARK.h>
 
@@ -21,6 +26,48 @@
 MODULE_ALIAS("ipt_MARK");
 MODULE_ALIAS("ip6t_MARK");
 
+static inline u_int16_t
+get_dst_port(struct nf_conntrack_tuple *tuple)
+{
+	switch (tuple->dst.protonum) {
+	case IPPROTO_GRE:
+		/* XXX Truncate 32-bit GRE key to 16 bits */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+		return tuple->dst.u.gre.key;
+#else
+		return htons(ntohl(tuple->dst.u.gre.key));
+#endif  
+	case IPPROTO_ICMP:
+		/* Bind on ICMP echo ID */
+		return tuple->src.u.icmp.id;
+	case IPPROTO_TCP:
+		return tuple->dst.u.tcp.port;
+	case IPPROTO_UDP:
+		return tuple->dst.u.udp.port;
+	default:
+		return tuple->dst.u.all;
+	}
+}
+
+static inline u_int16_t
+get_src_port(struct nf_conntrack_tuple *tuple)
+{
+	switch (tuple->dst.protonum) {
+	case IPPROTO_GRE:
+		/* XXX Truncate 32-bit GRE key to 16 bits */
+		return htons(ntohl(tuple->src.u.gre.key));
+	case IPPROTO_ICMP:
+		/* Bind on ICMP echo ID */
+		return tuple->src.u.icmp.id;
+	case IPPROTO_TCP:
+		return tuple->src.u.tcp.port;
+	case IPPROTO_UDP:
+		return tuple->src.u.udp.port;
+	default:
+		return tuple->src.u.all;
+	}
+}
+
 static unsigned int
 target_v0(struct sk_buff **pskb,
 	  const struct net_device *in,
@@ -44,7 +91,7 @@
 	  const void *targinfo)
 {
 	const struct xt_mark_target_info_v1 *markinfo = targinfo;
-	int mark = 0;
+	int mark = -1;
 
 	switch (markinfo->mode) {
 	case XT_MARK_SET:
@@ -58,8 +105,58 @@
 	case XT_MARK_OR:
 		mark = (*pskb)->mark | markinfo->mark;
 		break;
+
+	case XT_MARK_COPYXID: {
+		enum ip_conntrack_info ctinfo;
+		struct sock *connection_sk;
+		int dif;
+
+		struct nf_conn *ct = nf_ct_get((*pskb), &ctinfo);
+		extern struct inet_hashinfo tcp_hashinfo;
+		enum ip_conntrack_dir dir;
+		if (!ct) 
+			break;
+
+		dir = CTINFO2DIR(ctinfo);
+		u_int32_t src_ip = ct->tuplehash[dir].tuple.src.u3.ip;
+		u_int16_t src_port = get_src_port(&ct->tuplehash[dir].tuple);
+		u_int16_t proto = ct->tuplehash[dir].tuple.dst.protonum;
+
+		u_int32_t ip;
+		u_int16_t port;
+
+		dif = ((struct rtable *)(*pskb)->dst)->rt_iif;
+		ip = ct->tuplehash[dir].tuple.dst.u3.ip;
+		port = get_dst_port(&ct->tuplehash[dir].tuple);
+
+		if (proto == 1 || proto == 17) {
+			if (((*pskb)->mark!=-1) && (*pskb)->mark)
+				ct->xid[0]=(*pskb)->mark;
+			if (ct->xid[0]) 
+				mark = ct->xid[0];
+
+		}
+		else if (proto == 6) { 
+				if ((*pskb)->sk) 
+					connection_sk = (*pskb)->sk;
+				else {
+					connection_sk = inet_lookup(&tcp_hashinfo, src_ip, src_port, ip, port, dif);
+				}
+
+				if (connection_sk) {
+					connection_sk->sk_peercred.gid = connection_sk->sk_peercred.uid = ct->xid[dir];
+					ct->xid[!dir]=connection_sk->sk_xid;
+					if (connection_sk->sk_xid != 0) 
+						mark = connection_sk->sk_xid;
+					if (connection_sk != (*pskb)->sk)
+						sock_put(connection_sk);
+				}
+				break;
+				}
+			      }
 	}
 
+	if (mark != -1)
 	(*pskb)->mark = mark;
 	return XT_CONTINUE;
 }
@@ -92,7 +189,8 @@
 
 	if (markinfo->mode != XT_MARK_SET
 	    && markinfo->mode != XT_MARK_AND
-	    && markinfo->mode != XT_MARK_OR) {
+	    && markinfo->mode != XT_MARK_OR
+	    && markinfo->mode != XT_MARK_COPYXID) {
 		printk(KERN_WARNING "MARK: unknown mode %u\n",
 		       markinfo->mode);
 		return 0;
diff -Nurb linux-2.6.22-510/net/netfilter/xt_MARK.c.orig linux-2.6.22-520/net/netfilter/xt_MARK.c.orig
--- linux-2.6.22-510/net/netfilter/xt_MARK.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-520/net/netfilter/xt_MARK.c.orig	2008-02-20 06:54:56.000000000 -0500
@@ -0,0 +1,284 @@
+/* This is a module which is used for setting the NFMARK field of an skb. */
+
+/* (C) 1999-2001 Marc Boucher <marc@mbsi.ca>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <net/checksum.h>
+#include <net/route.h>
+#include <net/inet_hashtables.h>
+
+#include <net/netfilter/nf_conntrack.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_MARK.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Marc Boucher <marc@mbsi.ca>");
+MODULE_DESCRIPTION("ip[6]tables MARK modification module");
+MODULE_ALIAS("ipt_MARK");
+MODULE_ALIAS("ip6t_MARK");
+
+static inline u_int16_t
+get_dst_port(struct nf_conntrack_tuple *tuple)
+{
+	switch (tuple->dst.protonum) {
+	case IPPROTO_GRE:
+		/* XXX Truncate 32-bit GRE key to 16 bits */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+		return tuple->dst.u.gre.key;
+#else
+		return htons(ntohl(tuple->dst.u.gre.key));
+#endif  
+	case IPPROTO_ICMP:
+		/* Bind on ICMP echo ID */
+		return tuple->src.u.icmp.id;
+	case IPPROTO_TCP:
+		return tuple->dst.u.tcp.port;
+	case IPPROTO_UDP:
+		return tuple->dst.u.udp.port;
+	default:
+		return tuple->dst.u.all;
+	}
+}
+
+static inline u_int16_t
+get_src_port(struct nf_conntrack_tuple *tuple)
+{
+	switch (tuple->dst.protonum) {
+	case IPPROTO_GRE:
+		/* XXX Truncate 32-bit GRE key to 16 bits */
+		return htons(ntohl(tuple->src.u.gre.key));
+	case IPPROTO_ICMP:
+		/* Bind on ICMP echo ID */
+		return tuple->src.u.icmp.id;
+	case IPPROTO_TCP:
+		return tuple->src.u.tcp.port;
+	case IPPROTO_UDP:
+		return tuple->src.u.udp.port;
+	default:
+		return tuple->src.u.all;
+	}
+}
+
+static unsigned int
+target_v0(struct sk_buff **pskb,
+	  const struct net_device *in,
+	  const struct net_device *out,
+	  unsigned int hooknum,
+	  const struct xt_target *target,
+	  const void *targinfo)
+{
+	const struct xt_mark_target_info *markinfo = targinfo;
+
+	(*pskb)->mark = markinfo->mark;
+	return XT_CONTINUE;
+}
+
+static unsigned int
+target_v1(struct sk_buff **pskb,
+	  const struct net_device *in,
+	  const struct net_device *out,
+	  unsigned int hooknum,
+	  const struct xt_target *target,
+	  const void *targinfo)
+{
+	const struct xt_mark_target_info_v1 *markinfo = targinfo;
+	int mark = -1;
+
+	switch (markinfo->mode) {
+	case XT_MARK_SET:
+		mark = markinfo->mark;
+		break;
+
+	case XT_MARK_AND:
+		mark = (*pskb)->mark & markinfo->mark;
+		break;
+
+	case XT_MARK_OR:
+		mark = (*pskb)->mark | markinfo->mark;
+		break;
+
+	case XT_MARK_COPYXID: {
+		enum ip_conntrack_info ctinfo;
+		struct sock *connection_sk;
+		int dif;
+
+		struct nf_conn *ct = nf_ct_get((*pskb), &ctinfo);
+		extern struct inet_hashinfo tcp_hashinfo;
+		enum ip_conntrack_dir dir;
+		if (!ct) 
+			break;
+
+		dir = CTINFO2DIR(ctinfo);
+		u_int32_t src_ip = ct->tuplehash[dir].tuple.src.u3.ip;
+		u_int16_t src_port = get_src_port(&ct->tuplehash[dir].tuple);
+		u_int16_t proto = ct->tuplehash[dir].tuple.dst.protonum;
+
+		u_int32_t ip;
+		u_int16_t port;
+
+		dif = ((struct rtable *)(*pskb)->dst)->rt_iif;
+		ip = ct->tuplehash[dir].tuple.dst.u3.ip;
+		port = get_dst_port(&ct->tuplehash[dir].tuple);
+
+		if (proto == 1) {
+			if (((*pskb)->mark!=-1) && (*pskb)->mark)
+				ct->xid[0]=(*pskb)->mark;
+			if (ct->xid[0]) 
+				mark = ct->xid[0];
+			printk(KERN_CRIT "%d %d\n",ct->xid[0],(*pskb)->mark);
+
+		}
+		else if (proto == 6) {
+				if ((*pskb)->sk) 
+					connection_sk = (*pskb)->sk;
+				else {
+					connection_sk = inet_lookup(&tcp_hashinfo, src_ip, src_port, ip, port, dif);
+				}
+
+				if (connection_sk) {
+					connection_sk->sk_peercred.gid = connection_sk->sk_peercred.uid = ct->xid[dir];
+					ct->xid[!dir]=connection_sk->sk_xid;
+					if (connection_sk->sk_xid != 0) 
+						mark = connection_sk->sk_xid;
+					if (connection_sk != (*pskb)->sk)
+						sock_put(connection_sk);
+				}
+				break;
+				}
+			      }
+	}
+
+	if (mark != -1)
+	(*pskb)->mark = mark;
+	return XT_CONTINUE;
+}
+
+
+static int
+checkentry_v0(const char *tablename,
+	      const void *entry,
+	      const struct xt_target *target,
+	      void *targinfo,
+	      unsigned int hook_mask)
+{
+	struct xt_mark_target_info *markinfo = targinfo;
+
+	if (markinfo->mark > 0xffffffff) {
+		printk(KERN_WARNING "MARK: Only supports 32bit wide mark\n");
+		return 0;
+	}
+	return 1;
+}
+
+static int
+checkentry_v1(const char *tablename,
+	      const void *entry,
+	      const struct xt_target *target,
+	      void *targinfo,
+	      unsigned int hook_mask)
+{
+	struct xt_mark_target_info_v1 *markinfo = targinfo;
+
+	if (markinfo->mode != XT_MARK_SET
+	    && markinfo->mode != XT_MARK_AND
+	    && markinfo->mode != XT_MARK_OR
+	    && markinfo->mode != XT_MARK_COPYXID) {
+		printk(KERN_WARNING "MARK: unknown mode %u\n",
+		       markinfo->mode);
+		return 0;
+	}
+	if (markinfo->mark > 0xffffffff) {
+		printk(KERN_WARNING "MARK: Only supports 32bit wide mark\n");
+		return 0;
+	}
+	return 1;
+}
+
+#ifdef CONFIG_COMPAT
+struct compat_xt_mark_target_info_v1 {
+	compat_ulong_t	mark;
+	u_int8_t	mode;
+	u_int8_t	__pad1;
+	u_int16_t	__pad2;
+};
+
+static void compat_from_user_v1(void *dst, void *src)
+{
+	struct compat_xt_mark_target_info_v1 *cm = src;
+	struct xt_mark_target_info_v1 m = {
+		.mark	= cm->mark,
+		.mode	= cm->mode,
+	};
+	memcpy(dst, &m, sizeof(m));
+}
+
+static int compat_to_user_v1(void __user *dst, void *src)
+{
+	struct xt_mark_target_info_v1 *m = src;
+	struct compat_xt_mark_target_info_v1 cm = {
+		.mark	= m->mark,
+		.mode	= m->mode,
+	};
+	return copy_to_user(dst, &cm, sizeof(cm)) ? -EFAULT : 0;
+}
+#endif /* CONFIG_COMPAT */
+
+static struct xt_target xt_mark_target[] = {
+	{
+		.name		= "MARK",
+		.family		= AF_INET,
+		.revision	= 0,
+		.checkentry	= checkentry_v0,
+		.target		= target_v0,
+		.targetsize	= sizeof(struct xt_mark_target_info),
+		.table		= "mangle",
+		.me		= THIS_MODULE,
+	},
+	{
+		.name		= "MARK",
+		.family		= AF_INET,
+		.revision	= 1,
+		.checkentry	= checkentry_v1,
+		.target		= target_v1,
+		.targetsize	= sizeof(struct xt_mark_target_info_v1),
+#ifdef CONFIG_COMPAT
+		.compatsize	= sizeof(struct compat_xt_mark_target_info_v1),
+		.compat_from_user = compat_from_user_v1,
+		.compat_to_user	= compat_to_user_v1,
+#endif
+		.table		= "mangle",
+		.me		= THIS_MODULE,
+	},
+	{
+		.name		= "MARK",
+		.family		= AF_INET6,
+		.revision	= 0,
+		.checkentry	= checkentry_v0,
+		.target		= target_v0,
+		.targetsize	= sizeof(struct xt_mark_target_info),
+		.table		= "mangle",
+		.me		= THIS_MODULE,
+	},
+};
+
+static int __init xt_mark_init(void)
+{
+	return xt_register_targets(xt_mark_target, ARRAY_SIZE(xt_mark_target));
+}
+
+static void __exit xt_mark_fini(void)
+{
+	xt_unregister_targets(xt_mark_target, ARRAY_SIZE(xt_mark_target));
+}
+
+module_init(xt_mark_init);
+module_exit(xt_mark_fini);
diff -Nurb linux-2.6.22-510/net/netfilter/xt_SETXID.c linux-2.6.22-520/net/netfilter/xt_SETXID.c
--- linux-2.6.22-510/net/netfilter/xt_SETXID.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-520/net/netfilter/xt_SETXID.c	2008-02-20 04:13:13.000000000 -0500
@@ -0,0 +1,79 @@
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <net/checksum.h>
+#include <linux/vs_network.h>
+
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_SETXID.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("");
+MODULE_DESCRIPTION("");
+MODULE_ALIAS("ipt_SETXID");
+
+static unsigned int
+target_v1(struct sk_buff **pskb,
+	  const struct net_device *in,
+	  const struct net_device *out,
+	  unsigned int hooknum,
+	  const struct xt_target *target,
+	  const void *targinfo)
+{
+	const struct xt_setxid_target_info_v1 *setxidinfo = targinfo;
+
+	switch (setxidinfo->mode) {
+	case XT_SET_PACKET_XID:
+		 (*pskb)->skb_tag = setxidinfo->mark;
+		break;
+	}
+	return XT_CONTINUE;
+}
+
+
+static int
+checkentry_v1(const char *tablename,
+	      const void *entry,
+	      const struct xt_target *target,
+	      void *targinfo,
+	      unsigned int hook_mask)
+{
+	struct xt_setxid_target_info_v1 *setxidinfo = targinfo;
+
+	if (setxidinfo->mode != XT_SET_PACKET_XID) {
+		printk(KERN_WARNING "SETXID: unknown mode %u\n",
+		       setxidinfo->mode);
+		return 0;
+	}
+
+	return 1;
+}
+
+static struct xt_target xt_setxid_target[] = {
+	{
+		.name		= "SETXID",
+		.family		= AF_INET,
+		.revision	= 1,
+		.checkentry	= checkentry_v1,
+		.target		= target_v1,
+		.targetsize	= sizeof(struct xt_setxid_target_info_v1),
+		.table		= "mangle",
+		.me		= THIS_MODULE,
+	}
+};
+
+static int __init init(void)
+{
+	int err;
+
+	err = xt_register_targets(xt_setxid_target, ARRAY_SIZE(xt_setxid_target));
+	return err;
+}
+
+static void __exit fini(void)
+{
+	xt_unregister_targets(xt_setxid_target, ARRAY_SIZE(xt_setxid_target));
+}
+
+module_init(init);
+module_exit(fini);
diff -Nurb linux-2.6.22-510/net/packet/af_packet.c linux-2.6.22-520/net/packet/af_packet.c
--- linux-2.6.22-510/net/packet/af_packet.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-520/net/packet/af_packet.c	2008-02-20 04:13:13.000000000 -0500
@@ -78,6 +78,7 @@
 #include <linux/poll.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/vs_network.h>
 
 #ifdef CONFIG_INET
 #include <net/inet_common.h>
@@ -324,6 +325,9 @@
 	__be16 proto=0;
 	int err;
 
+	if (!nx_capable(CAP_NET_RAW, NXC_RAW_SEND))
+		return -EPERM;
+
 	/*
 	 *	Get and verify the address.
 	 */
@@ -420,6 +424,10 @@
 				      unsigned int res)
 {
 	struct sk_filter *filter;
+	int tag = skb->skb_tag;
+
+	if (sk->sk_nx_info && !(tag == 1 || sk->sk_nid == tag))
+		return 0;
 
 	rcu_read_lock_bh();
 	filter = rcu_dereference(sk->sk_filter);
@@ -711,6 +719,9 @@
 	unsigned char *addr;
 	int ifindex, err, reserve = 0;
 
+	if (!nx_capable(CAP_NET_RAW, NXC_RAW_SEND))
+		return -EPERM;
+
 	/*
 	 *	Get and verify the address.
 	 */
@@ -984,7 +995,7 @@
 	__be16 proto = (__force __be16)protocol; /* weird, but documented */
 	int err;
 
-	if (!capable(CAP_NET_RAW))
+	if (!nx_capable(CAP_NET_RAW, NXC_RAW_SOCKET))
 		return -EPERM;
 	if (sock->type != SOCK_DGRAM && sock->type != SOCK_RAW &&
 	    sock->type != SOCK_PACKET)
