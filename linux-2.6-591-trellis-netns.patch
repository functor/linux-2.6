diff -Nurb linux-2.6.22-590/Documentation/sysfs-rules.txt linux-2.6.22-try2-netns/Documentation/sysfs-rules.txt
--- linux-2.6.22-590/Documentation/sysfs-rules.txt	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/Documentation/sysfs-rules.txt	2007-12-21 14:25:48.000000000 -0500
@@ -0,0 +1,166 @@
+Rules on how to access information in the Linux kernel sysfs
+
+The kernel exported sysfs exports internal kernel implementation-details
+and depends on internal kernel structures and layout. It is agreed upon
+by the kernel developers that the Linux kernel does not provide a stable
+internal API. As sysfs is a direct export of kernel internal
+structures, the sysfs interface can not provide a stable interface eighter,
+it may always change along with internal kernel changes.
+
+To minimize the risk of breaking users of sysfs, which are in most cases
+low-level userspace applications, with a new kernel release, the users
+of sysfs must follow some rules to use an as abstract-as-possible way to
+access this filesystem. The current udev and HAL programs already
+implement this and users are encouraged to plug, if possible, into the
+abstractions these programs provide instead of accessing sysfs
+directly.
+
+But if you really do want or need to access sysfs directly, please follow
+the following rules and then your programs should work with future
+versions of the sysfs interface.
+
+- Do not use libsysfs
+  It makes assumptions about sysfs which are not true. Its API does not
+  offer any abstraction, it exposes all the kernel driver-core
+  implementation details in its own API. Therefore it is not better than
+  reading directories and opening the files yourself.
+  Also, it is not actively maintained, in the sense of reflecting the
+  current kernel-development. The goal of providing a stable interface
+  to sysfs has failed, it causes more problems, than it solves. It
+  violates many of the rules in this document.
+
+- sysfs is always at /sys
+  Parsing /proc/mounts is a waste of time. Other mount points are a
+  system configuration bug you should not try to solve. For test cases,
+  possibly support a SYSFS_PATH environment variable to overwrite the
+  applications behavior, but never try to search for sysfs. Never try
+  to mount it, if you are not an early boot script.
+
+- devices are only "devices"
+  There is no such thing like class-, bus-, physical devices,
+  interfaces, and such that you can rely on in userspace. Everything is
+  just simply a "device". Class-, bus-, physical, ... types are just
+  kernel implementation details, which should not be expected by
+  applications that look for devices in sysfs.
+
+  The properties of a device are:
+    o devpath (/devices/pci0000:00/0000:00:1d.1/usb2/2-2/2-2:1.0)
+      - identical to the DEVPATH value in the event sent from the kernel
+        at device creation and removal
+      - the unique key to the device at that point in time
+      - the kernels path to the device-directory without the leading
+        /sys, and always starting with with a slash
+      - all elements of a devpath must be real directories. Symlinks
+        pointing to /sys/devices must always be resolved to their real
+        target, and the target path must be used to access the device.
+        That way the devpath to the device matches the devpath of the
+        kernel used at event time.
+      - using or exposing symlink values as elements in a devpath string
+        is a bug in the application
+
+    o kernel name (sda, tty, 0000:00:1f.2, ...)
+      - a directory name, identical to the last element of the devpath
+      - applications need to handle spaces and characters like '!' in
+        the name
+
+    o subsystem (block, tty, pci, ...)
+      - simple string, never a path or a link
+      - retrieved by reading the "subsystem"-link and using only the
+        last element of the target path
+
+    o driver (tg3, ata_piix, uhci_hcd)
+      - a simple string, which may contain spaces, never a path or a
+        link
+      - it is retrieved by reading the "driver"-link and using only the
+        last element of the target path
+      - devices which do not have "driver"-link, just do not have a
+        driver; copying the driver value in a child device context, is a
+        bug in the application
+
+    o attributes
+      - the files in the device directory or files below a subdirectories
+        of the same device directory
+      - accessing attributes reached by a symlink pointing to another device,
+        like the "device"-link, is a bug in the application
+
+  Everything else is just a kernel driver-core implementation detail,
+  that should not be assumed to be stable across kernel releases.
+
+- Properties of parent devices never belong into a child device.
+  Always look at the parent devices themselves for determining device
+  context properties. If the device 'eth0' or 'sda' does not have a
+  "driver"-link, then this device does not have a driver. Its value is empty.
+  Never copy any property of the parent-device into a child-device. Parent
+  device-properties may change dynamically without any notice to the
+  child device.
+
+- Hierarchy in a single device-tree
+  There is only one valid place in sysfs where hierarchy can be examined
+  and this is below: /sys/devices.
+  It is planned, that all device directories will end up in the tree
+  below this directory.
+
+- Classification by subsystem
+  There are currently three places for classification of devices:
+  /sys/block, /sys/class and /sys/bus. It is planned that these will
+  not contain any device-directories themselves, but only flat lists of
+  symlinks pointing to the unified /sys/devices tree.
+  All three places have completely different rules on how to access
+  device information. It is planned to merge all three
+  classification-directories into one place at /sys/subsystem,
+  following the layout of the bus-directories. All buses and
+  classes, including the converted block-subsystem, will show up
+  there.
+  The devices belonging to a subsystem will create a symlink in the
+  "devices" directory at /sys/subsystem/<name>/devices.
+
+  If /sys/subsystem exists, /sys/bus, /sys/class and /sys/block can be
+  ignored. If it does not exist, you have always to scan all three
+  places, as the kernel is free to move a subsystem from one place to
+  the other, as long as the devices are still reachable by the same
+  subsystem name.
+
+  Assuming /sys/class/<subsystem> and /sys/bus/<subsystem>, or
+  /sys/block and /sys/class/block are not interchangeable, is a bug in
+  the application.
+
+- Block
+  The converted block-subsystem at /sys/class/block, or
+  /sys/subsystem/block will contain the links for disks and partitions
+  at the same level, never in a hierarchy. Assuming the block-subsytem to
+  contain only disks and not partition-devices in the same flat list is
+  a bug in the application.
+
+- "device"-link and <subsystem>:<kernel name>-links
+  Never depend on the "device"-link. The "device"-link is a workaround
+  for the old layout, where class-devices are not created in
+  /sys/devices/ like the bus-devices. If the link-resolving of a
+  device-directory does not end in /sys/devices/, you can use the
+  "device"-link to find the parent devices in /sys/devices/. That is the
+  single valid use of the "device"-link, it must never appear in any
+  path as an element. Assuming the existence of the "device"-link for
+  a device in /sys/devices/ is a bug in the application.
+  Accessing /sys/class/net/eth0/device is a bug in the application.
+
+  Never depend on the class-specific links back to the /sys/class
+  directory.  These links are also a workaround for the design mistake
+  that class-devices are not created in /sys/devices. If a device
+  directory does not contain directories for child devices, these links
+  may be used to find the child devices in /sys/class. That is the single
+  valid use of these links, they must never appear in any path as an
+  element. Assuming the existence of these links for devices which are
+  real child device directories in the /sys/devices tree, is a bug in
+  the application.
+
+  It is planned to remove all these links when when all class-device
+  directories live in /sys/devices.
+
+- Position of devices along device chain can change.
+  Never depend on a specific parent device position in the devpath,
+  or the chain of parent devices. The kernel is free to insert devices into
+  the chain. You must always request the parent device you are looking for
+  by its subsystem value. You need to walk up the chain until you find
+  the device that matches the expected subsystem. Depending on a specific
+  position of a parent device, or exposing relative paths, using "../" to
+  access the chain of parents, is a bug in the application.
+
diff -Nurb linux-2.6.22-590/Makefile linux-2.6.22-try2-netns/Makefile
--- linux-2.6.22-590/Makefile	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/Makefile	2007-12-19 15:29:23.000000000 -0500
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 22
-EXTRAVERSION = .14-vs2.3.0.29
+EXTRAVERSION = -prep
 NAME = Holy Dancing Manatees, Batman!
 
 # *DOCUMENTATION*
diff -Nurb linux-2.6.22-590/Makefile.orig linux-2.6.22-try2-netns/Makefile.orig
--- linux-2.6.22-590/Makefile.orig	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/Makefile.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,1493 +0,0 @@
-VERSION = 2
-PATCHLEVEL = 6
-SUBLEVEL = 22
-EXTRAVERSION = .14
-NAME = Holy Dancing Manatees, Batman!
-
-# *DOCUMENTATION*
-# To see a list of typical targets execute "make help"
-# More info can be located in ./README
-# Comments in this file are targeted only to the developer, do not
-# expect to learn how to build the kernel reading this file.
-
-# Do not:
-# o  use make's built-in rules and variables
-#    (this increases performance and avoid hard-to-debug behavour);
-# o  print "Entering directory ...";
-MAKEFLAGS += -rR --no-print-directory
-
-# We are using a recursive build, so we need to do a little thinking
-# to get the ordering right.
-#
-# Most importantly: sub-Makefiles should only ever modify files in
-# their own directory. If in some directory we have a dependency on
-# a file in another dir (which doesn't happen often, but it's often
-# unavoidable when linking the built-in.o targets which finally
-# turn into vmlinux), we will call a sub make in that other dir, and
-# after that we are sure that everything which is in that other dir
-# is now up to date.
-#
-# The only cases where we need to modify files which have global
-# effects are thus separated out and done before the recursive
-# descending is started. They are now explicitly listed as the
-# prepare rule.
-
-# To put more focus on warnings, be less verbose as default
-# Use 'make V=1' to see the full commands
-
-ifdef V
-  ifeq ("$(origin V)", "command line")
-    KBUILD_VERBOSE = $(V)
-  endif
-endif
-ifndef KBUILD_VERBOSE
-  KBUILD_VERBOSE = 0
-endif
-
-# Call a source code checker (by default, "sparse") as part of the
-# C compilation.
-#
-# Use 'make C=1' to enable checking of only re-compiled files.
-# Use 'make C=2' to enable checking of *all* source files, regardless
-# of whether they are re-compiled or not.
-#
-# See the file "Documentation/sparse.txt" for more details, including
-# where to get the "sparse" utility.
-
-ifdef C
-  ifeq ("$(origin C)", "command line")
-    KBUILD_CHECKSRC = $(C)
-  endif
-endif
-ifndef KBUILD_CHECKSRC
-  KBUILD_CHECKSRC = 0
-endif
-
-# Use make M=dir to specify directory of external module to build
-# Old syntax make ... SUBDIRS=$PWD is still supported
-# Setting the environment variable KBUILD_EXTMOD take precedence
-ifdef SUBDIRS
-  KBUILD_EXTMOD ?= $(SUBDIRS)
-endif
-ifdef M
-  ifeq ("$(origin M)", "command line")
-    KBUILD_EXTMOD := $(M)
-  endif
-endif
-
-
-# kbuild supports saving output files in a separate directory.
-# To locate output files in a separate directory two syntaxes are supported.
-# In both cases the working directory must be the root of the kernel src.
-# 1) O=
-# Use "make O=dir/to/store/output/files/"
-#
-# 2) Set KBUILD_OUTPUT
-# Set the environment variable KBUILD_OUTPUT to point to the directory
-# where the output files shall be placed.
-# export KBUILD_OUTPUT=dir/to/store/output/files/
-# make
-#
-# The O= assignment takes precedence over the KBUILD_OUTPUT environment
-# variable.
-
-
-# KBUILD_SRC is set on invocation of make in OBJ directory
-# KBUILD_SRC is not intended to be used by the regular user (for now)
-ifeq ($(KBUILD_SRC),)
-
-# OK, Make called in directory where kernel src resides
-# Do we want to locate output files in a separate directory?
-ifdef O
-  ifeq ("$(origin O)", "command line")
-    KBUILD_OUTPUT := $(O)
-  endif
-endif
-
-# That's our default target when none is given on the command line
-PHONY := _all
-_all:
-
-ifneq ($(KBUILD_OUTPUT),)
-# Invoke a second make in the output directory, passing relevant variables
-# check that the output directory actually exists
-saved-output := $(KBUILD_OUTPUT)
-KBUILD_OUTPUT := $(shell cd $(KBUILD_OUTPUT) && /bin/pwd)
-$(if $(KBUILD_OUTPUT),, \
-     $(error output directory "$(saved-output)" does not exist))
-
-PHONY += $(MAKECMDGOALS)
-
-$(filter-out _all,$(MAKECMDGOALS)) _all:
-	$(if $(KBUILD_VERBOSE:1=),@)$(MAKE) -C $(KBUILD_OUTPUT) \
-	KBUILD_SRC=$(CURDIR) \
-	KBUILD_EXTMOD="$(KBUILD_EXTMOD)" -f $(CURDIR)/Makefile $@
-
-# Leave processing to above invocation of make
-skip-makefile := 1
-endif # ifneq ($(KBUILD_OUTPUT),)
-endif # ifeq ($(KBUILD_SRC),)
-
-# We process the rest of the Makefile if this is the final invocation of make
-ifeq ($(skip-makefile),)
-
-# If building an external module we do not care about the all: rule
-# but instead _all depend on modules
-PHONY += all
-ifeq ($(KBUILD_EXTMOD),)
-_all: all
-else
-_all: modules
-endif
-
-srctree		:= $(if $(KBUILD_SRC),$(KBUILD_SRC),$(CURDIR))
-TOPDIR		:= $(srctree)
-# FIXME - TOPDIR is obsolete, use srctree/objtree
-objtree		:= $(CURDIR)
-src		:= $(srctree)
-obj		:= $(objtree)
-
-VPATH		:= $(srctree)$(if $(KBUILD_EXTMOD),:$(KBUILD_EXTMOD))
-
-export srctree objtree VPATH TOPDIR
-
-
-# SUBARCH tells the usermode build what the underlying arch is.  That is set
-# first, and if a usermode build is happening, the "ARCH=um" on the command
-# line overrides the setting of ARCH below.  If a native build is happening,
-# then ARCH is assigned, getting whatever value it gets normally, and 
-# SUBARCH is subsequently ignored.
-
-SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
-				  -e s/arm.*/arm/ -e s/sa110/arm/ \
-				  -e s/s390x/s390/ -e s/parisc64/parisc/ \
-				  -e s/ppc.*/powerpc/ -e s/mips.*/mips/ )
-
-# Cross compiling and selecting different set of gcc/bin-utils
-# ---------------------------------------------------------------------------
-#
-# When performing cross compilation for other architectures ARCH shall be set
-# to the target architecture. (See arch/* for the possibilities).
-# ARCH can be set during invocation of make:
-# make ARCH=ia64
-# Another way is to have ARCH set in the environment.
-# The default ARCH is the host where make is executed.
-
-# CROSS_COMPILE specify the prefix used for all executables used
-# during compilation. Only gcc and related bin-utils executables
-# are prefixed with $(CROSS_COMPILE).
-# CROSS_COMPILE can be set on the command line
-# make CROSS_COMPILE=ia64-linux-
-# Alternatively CROSS_COMPILE can be set in the environment.
-# Default value for CROSS_COMPILE is not to prefix executables
-# Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
-
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
-
-# Architecture as present in compile.h
-UTS_MACHINE := $(ARCH)
-
-KCONFIG_CONFIG	?= .config
-
-# SHELL used by kbuild
-CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
-	  else if [ -x /bin/bash ]; then echo /bin/bash; \
-	  else echo sh; fi ; fi)
-
-HOSTCC       = gcc
-HOSTCXX      = g++
-HOSTCFLAGS   = -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
-HOSTCXXFLAGS = -O2
-
-# Decide whether to build built-in, modular, or both.
-# Normally, just do built-in.
-
-KBUILD_MODULES :=
-KBUILD_BUILTIN := 1
-
-#	If we have only "make modules", don't compile built-in objects.
-#	When we're building modules with modversions, we need to consider
-#	the built-in objects during the descend as well, in order to
-#	make sure the checksums are up to date before we record them.
-
-ifeq ($(MAKECMDGOALS),modules)
-  KBUILD_BUILTIN := $(if $(CONFIG_MODVERSIONS),1)
-endif
-
-#	If we have "make <whatever> modules", compile modules
-#	in addition to whatever we do anyway.
-#	Just "make" or "make all" shall build modules as well
-
-ifneq ($(filter all _all modules,$(MAKECMDGOALS)),)
-  KBUILD_MODULES := 1
-endif
-
-ifeq ($(MAKECMDGOALS),)
-  KBUILD_MODULES := 1
-endif
-
-export KBUILD_MODULES KBUILD_BUILTIN
-export KBUILD_CHECKSRC KBUILD_SRC KBUILD_EXTMOD
-
-# Beautify output
-# ---------------------------------------------------------------------------
-#
-# Normally, we echo the whole command before executing it. By making
-# that echo $($(quiet)$(cmd)), we now have the possibility to set
-# $(quiet) to choose other forms of output instead, e.g.
-#
-#         quiet_cmd_cc_o_c = Compiling $(RELDIR)/$@
-#         cmd_cc_o_c       = $(CC) $(c_flags) -c -o $@ $<
-#
-# If $(quiet) is empty, the whole command will be printed.
-# If it is set to "quiet_", only the short version will be printed. 
-# If it is set to "silent_", nothing will be printed at all, since
-# the variable $(silent_cmd_cc_o_c) doesn't exist.
-#
-# A simple variant is to prefix commands with $(Q) - that's useful
-# for commands that shall be hidden in non-verbose mode.
-#
-#	$(Q)ln $@ :<
-#
-# If KBUILD_VERBOSE equals 0 then the above command will be hidden.
-# If KBUILD_VERBOSE equals 1 then the above command is displayed.
-
-ifeq ($(KBUILD_VERBOSE),1)
-  quiet =
-  Q =
-else
-  quiet=quiet_
-  Q = @
-endif
-
-# If the user is running make -s (silent mode), suppress echoing of
-# commands
-
-ifneq ($(findstring s,$(MAKEFLAGS)),)
-  quiet=silent_
-endif
-
-export quiet Q KBUILD_VERBOSE
-
-
-# Look for make include files relative to root of kernel src
-MAKEFLAGS += --include-dir=$(srctree)
-
-# We need some generic definitions.
-include $(srctree)/scripts/Kbuild.include
-
-# Make variables (CC, etc...)
-
-AS		= $(CROSS_COMPILE)as
-LD		= $(CROSS_COMPILE)ld
-CC		= $(CROSS_COMPILE)gcc
-CPP		= $(CC) -E
-AR		= $(CROSS_COMPILE)ar
-NM		= $(CROSS_COMPILE)nm
-STRIP		= $(CROSS_COMPILE)strip
-OBJCOPY		= $(CROSS_COMPILE)objcopy
-OBJDUMP		= $(CROSS_COMPILE)objdump
-AWK		= awk
-GENKSYMS	= scripts/genksyms/genksyms
-DEPMOD		= /sbin/depmod
-KALLSYMS	= scripts/kallsyms
-PERL		= perl
-CHECK		= sparse
-
-CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise $(CF)
-MODFLAGS	= -DMODULE
-CFLAGS_MODULE   = $(MODFLAGS)
-AFLAGS_MODULE   = $(MODFLAGS)
-LDFLAGS_MODULE  = -r
-CFLAGS_KERNEL	=
-AFLAGS_KERNEL	=
-
-
-# Use LINUXINCLUDE when you must reference the include/ directory.
-# Needed to be compatible with the O= option
-LINUXINCLUDE    := -Iinclude \
-                   $(if $(KBUILD_SRC),-Iinclude2 -I$(srctree)/include) \
-		   -include include/linux/autoconf.h
-
-CPPFLAGS        := -D__KERNEL__ $(LINUXINCLUDE)
-
-CFLAGS          := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
-                   -fno-strict-aliasing -fno-common
-AFLAGS          := -D__ASSEMBLY__
-
-# Read KERNELRELEASE from include/config/kernel.release (if it exists)
-KERNELRELEASE = $(shell cat include/config/kernel.release 2> /dev/null)
-KERNELVERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
-
-export VERSION PATCHLEVEL SUBLEVEL KERNELRELEASE KERNELVERSION
-export ARCH CONFIG_SHELL HOSTCC HOSTCFLAGS CROSS_COMPILE AS LD CC
-export CPP AR NM STRIP OBJCOPY OBJDUMP MAKE AWK GENKSYMS PERL UTS_MACHINE
-export HOSTCXX HOSTCXXFLAGS LDFLAGS_MODULE CHECK CHECKFLAGS
-
-export CPPFLAGS NOSTDINC_FLAGS LINUXINCLUDE OBJCOPYFLAGS LDFLAGS
-export CFLAGS CFLAGS_KERNEL CFLAGS_MODULE
-export AFLAGS AFLAGS_KERNEL AFLAGS_MODULE
-
-# When compiling out-of-tree modules, put MODVERDIR in the module
-# tree rather than in the kernel tree. The kernel tree might
-# even be read-only.
-export MODVERDIR := $(if $(KBUILD_EXTMOD),$(firstword $(KBUILD_EXTMOD))/).tmp_versions
-
-# Files to ignore in find ... statements
-
-RCS_FIND_IGNORE := \( -name SCCS -o -name BitKeeper -o -name .svn -o -name CVS -o -name .pc -o -name .hg -o -name .git \) -prune -o
-export RCS_TAR_IGNORE := --exclude SCCS --exclude BitKeeper --exclude .svn --exclude CVS --exclude .pc --exclude .hg --exclude .git
-
-# ===========================================================================
-# Rules shared between *config targets and build targets
-
-# Basic helpers built in scripts/
-PHONY += scripts_basic
-scripts_basic:
-	$(Q)$(MAKE) $(build)=scripts/basic
-
-# To avoid any implicit rule to kick in, define an empty command.
-scripts/basic/%: scripts_basic ;
-
-PHONY += outputmakefile
-# outputmakefile generates a Makefile in the output directory, if using a
-# separate output directory. This allows convenient use of make in the
-# output directory.
-outputmakefile:
-ifneq ($(KBUILD_SRC),)
-	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkmakefile \
-	    $(srctree) $(objtree) $(VERSION) $(PATCHLEVEL)
-endif
-
-# To make sure we do not include .config for any of the *config targets
-# catch them early, and hand them over to scripts/kconfig/Makefile
-# It is allowed to specify more targets when calling make, including
-# mixing *config targets and build targets.
-# For example 'make oldconfig all'.
-# Detect when mixed targets is specified, and make a second invocation
-# of make so .config is not included in this case either (for *config).
-
-no-dot-config-targets := clean mrproper distclean \
-			 cscope TAGS tags help %docs check% \
-			 include/linux/version.h headers_% \
-			 kernelrelease kernelversion
-
-config-targets := 0
-mixed-targets  := 0
-dot-config     := 1
-
-ifneq ($(filter $(no-dot-config-targets), $(MAKECMDGOALS)),)
-	ifeq ($(filter-out $(no-dot-config-targets), $(MAKECMDGOALS)),)
-		dot-config := 0
-	endif
-endif
-
-ifeq ($(KBUILD_EXTMOD),)
-        ifneq ($(filter config %config,$(MAKECMDGOALS)),)
-                config-targets := 1
-                ifneq ($(filter-out config %config,$(MAKECMDGOALS)),)
-                        mixed-targets := 1
-                endif
-        endif
-endif
-
-ifeq ($(mixed-targets),1)
-# ===========================================================================
-# We're called with mixed targets (*config and build targets).
-# Handle them one by one.
-
-%:: FORCE
-	$(Q)$(MAKE) -C $(srctree) KBUILD_SRC= $@
-
-else
-ifeq ($(config-targets),1)
-# ===========================================================================
-# *config targets only - make sure prerequisites are updated, and descend
-# in scripts/kconfig to make the *config target
-
-# Read arch specific Makefile to set KBUILD_DEFCONFIG as needed.
-# KBUILD_DEFCONFIG may point out an alternative default configuration
-# used for 'make defconfig'
-include $(srctree)/arch/$(ARCH)/Makefile
-export KBUILD_DEFCONFIG
-
-config %config: scripts_basic outputmakefile FORCE
-	$(Q)mkdir -p include/linux include/config
-	$(Q)$(MAKE) $(build)=scripts/kconfig $@
-
-else
-# ===========================================================================
-# Build targets only - this includes vmlinux, arch specific targets, clean
-# targets and others. In general all targets except *config targets.
-
-ifeq ($(KBUILD_EXTMOD),)
-# Additional helpers built in scripts/
-# Carefully list dependencies so we do not try to build scripts twice
-# in parallel
-PHONY += scripts
-scripts: scripts_basic include/config/auto.conf
-	$(Q)$(MAKE) $(build)=$(@)
-
-# Objects we will link into vmlinux / subdirs we need to visit
-init-y		:= init/
-drivers-y	:= drivers/ sound/
-net-y		:= net/
-libs-y		:= lib/
-core-y		:= usr/
-endif # KBUILD_EXTMOD
-
-ifeq ($(dot-config),1)
-# Read in config
--include include/config/auto.conf
-
-ifeq ($(KBUILD_EXTMOD),)
-# Read in dependencies to all Kconfig* files, make sure to run
-# oldconfig if changes are detected.
--include include/config/auto.conf.cmd
-
-# To avoid any implicit rule to kick in, define an empty command
-$(KCONFIG_CONFIG) include/config/auto.conf.cmd: ;
-
-# If .config is newer than include/config/auto.conf, someone tinkered
-# with it and forgot to run make oldconfig.
-# if auto.conf.cmd is missing then we are probably in a cleaned tree so
-# we execute the config step to be sure to catch updated Kconfig files
-include/config/auto.conf: $(KCONFIG_CONFIG) include/config/auto.conf.cmd
-	$(Q)$(MAKE) -f $(srctree)/Makefile silentoldconfig
-else
-# external modules needs include/linux/autoconf.h and include/config/auto.conf
-# but do not care if they are up-to-date. Use auto.conf to trigger the test
-PHONY += include/config/auto.conf
-
-include/config/auto.conf:
-	$(Q)test -e include/linux/autoconf.h -a -e $@ || (		\
-	echo;								\
-	echo "  ERROR: Kernel configuration is invalid.";		\
-	echo "         include/linux/autoconf.h or $@ are missing.";	\
-	echo "         Run 'make oldconfig && make prepare' on kernel src to fix it.";	\
-	echo;								\
-	/bin/false)
-
-endif # KBUILD_EXTMOD
-
-else
-# Dummy target needed, because used as prerequisite
-include/config/auto.conf: ;
-endif # $(dot-config)
-
-# The all: target is the default when no target is given on the
-# command line.
-# This allow a user to issue only 'make' to build a kernel including modules
-# Defaults vmlinux but it is usually overridden in the arch makefile
-all: vmlinux
-
-ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
-CFLAGS		+= -Os
-else
-CFLAGS		+= -O2
-endif
-
-include $(srctree)/arch/$(ARCH)/Makefile
-
-ifdef CONFIG_FRAME_POINTER
-CFLAGS		+= -fno-omit-frame-pointer $(call cc-option,-fno-optimize-sibling-calls,)
-else
-CFLAGS		+= -fomit-frame-pointer
-endif
-
-ifdef CONFIG_DEBUG_INFO
-CFLAGS		+= -g
-endif
-
-# Force gcc to behave correct even for buggy distributions
-CFLAGS          += $(call cc-option, -fno-stack-protector)
-
-# arch Makefile may override CC so keep this after arch Makefile is included
-NOSTDINC_FLAGS += -nostdinc -isystem $(shell $(CC) -print-file-name=include)
-CHECKFLAGS     += $(NOSTDINC_FLAGS)
-
-# warn about C99 declaration after statement
-CFLAGS += $(call cc-option,-Wdeclaration-after-statement,)
-
-# disable pointer signed / unsigned warnings in gcc 4.0
-CFLAGS += $(call cc-option,-Wno-pointer-sign,)
-
-# Default kernel image to build when no specific target is given.
-# KBUILD_IMAGE may be overruled on the command line or
-# set in the environment
-# Also any assignments in arch/$(ARCH)/Makefile take precedence over
-# this default value
-export KBUILD_IMAGE ?= vmlinux
-
-#
-# INSTALL_PATH specifies where to place the updated kernel and system map
-# images. Default is /boot, but you can set it to other values
-export	INSTALL_PATH ?= /boot
-
-#
-# INSTALL_MOD_PATH specifies a prefix to MODLIB for module directory
-# relocations required by build roots.  This is not defined in the
-# makefile but the argument can be passed to make if needed.
-#
-
-MODLIB	= $(INSTALL_MOD_PATH)/lib/modules/$(KERNELRELEASE)
-export MODLIB
-
-#
-#  INSTALL_MOD_STRIP, if defined, will cause modules to be
-#  stripped after they are installed.  If INSTALL_MOD_STRIP is '1', then
-#  the default option --strip-debug will be used.  Otherwise,
-#  INSTALL_MOD_STRIP will used as the options to the strip command.
-
-ifdef INSTALL_MOD_STRIP
-ifeq ($(INSTALL_MOD_STRIP),1)
-mod_strip_cmd = $(STRIP) --strip-debug
-else
-mod_strip_cmd = $(STRIP) $(INSTALL_MOD_STRIP)
-endif # INSTALL_MOD_STRIP=1
-else
-mod_strip_cmd = true
-endif # INSTALL_MOD_STRIP
-export mod_strip_cmd
-
-
-ifeq ($(KBUILD_EXTMOD),)
-core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/
-
-vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
-		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
-		     $(net-y) $(net-m) $(libs-y) $(libs-m)))
-
-vmlinux-alldirs	:= $(sort $(vmlinux-dirs) $(patsubst %/,%,$(filter %/, \
-		     $(init-n) $(init-) \
-		     $(core-n) $(core-) $(drivers-n) $(drivers-) \
-		     $(net-n)  $(net-)  $(libs-n)    $(libs-))))
-
-init-y		:= $(patsubst %/, %/built-in.o, $(init-y))
-core-y		:= $(patsubst %/, %/built-in.o, $(core-y))
-drivers-y	:= $(patsubst %/, %/built-in.o, $(drivers-y))
-net-y		:= $(patsubst %/, %/built-in.o, $(net-y))
-libs-y1		:= $(patsubst %/, %/lib.a, $(libs-y))
-libs-y2		:= $(patsubst %/, %/built-in.o, $(libs-y))
-libs-y		:= $(libs-y1) $(libs-y2)
-
-# Build vmlinux
-# ---------------------------------------------------------------------------
-# vmlinux is built from the objects selected by $(vmlinux-init) and
-# $(vmlinux-main). Most are built-in.o files from top-level directories
-# in the kernel tree, others are specified in arch/$(ARCH)/Makefile.
-# Ordering when linking is important, and $(vmlinux-init) must be first.
-#
-# vmlinux
-#   ^
-#   |
-#   +-< $(vmlinux-init)
-#   |   +--< init/version.o + more
-#   |
-#   +--< $(vmlinux-main)
-#   |    +--< driver/built-in.o mm/built-in.o + more
-#   |
-#   +-< kallsyms.o (see description in CONFIG_KALLSYMS section)
-#
-# vmlinux version (uname -v) cannot be updated during normal
-# descending-into-subdirs phase since we do not yet know if we need to
-# update vmlinux.
-# Therefore this step is delayed until just before final link of vmlinux -
-# except in the kallsyms case where it is done just before adding the
-# symbols to the kernel.
-#
-# System.map is generated to document addresses of all kernel symbols
-
-vmlinux-init := $(head-y) $(init-y)
-vmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y)
-vmlinux-all  := $(vmlinux-init) $(vmlinux-main)
-vmlinux-lds  := arch/$(ARCH)/kernel/vmlinux.lds
-export KBUILD_VMLINUX_OBJS := $(vmlinux-all)
-
-# Rule to link vmlinux - also used during CONFIG_KALLSYMS
-# May be overridden by arch/$(ARCH)/Makefile
-quiet_cmd_vmlinux__ ?= LD      $@
-      cmd_vmlinux__ ?= $(LD) $(LDFLAGS) $(LDFLAGS_vmlinux) -o $@ \
-      -T $(vmlinux-lds) $(vmlinux-init)                          \
-      --start-group $(vmlinux-main) --end-group                  \
-      $(filter-out $(vmlinux-lds) $(vmlinux-init) $(vmlinux-main) FORCE ,$^)
-
-# Generate new vmlinux version
-quiet_cmd_vmlinux_version = GEN     .version
-      cmd_vmlinux_version = set -e;                     \
-	if [ ! -r .version ]; then			\
-	  rm -f .version;				\
-	  echo 1 >.version;				\
-	else						\
-	  mv .version .old_version;			\
-	  expr 0$$(cat .old_version) + 1 >.version;	\
-	fi;						\
-	$(MAKE) $(build)=init
-
-# Generate System.map
-quiet_cmd_sysmap = SYSMAP
-      cmd_sysmap = $(CONFIG_SHELL) $(srctree)/scripts/mksysmap
-
-# Link of vmlinux
-# If CONFIG_KALLSYMS is set .version is already updated
-# Generate System.map and verify that the content is consistent
-# Use + in front of the vmlinux_version rule to silent warning with make -j2
-# First command is ':' to allow us to use + in front of the rule
-define rule_vmlinux__
-	:
-	$(if $(CONFIG_KALLSYMS),,+$(call cmd,vmlinux_version))
-
-	$(call cmd,vmlinux__)
-	$(Q)echo 'cmd_$@ := $(cmd_vmlinux__)' > $(@D)/.$(@F).cmd
-
-	$(Q)$(if $($(quiet)cmd_sysmap),                                      \
-	  echo '  $($(quiet)cmd_sysmap)  System.map' &&)                     \
-	$(cmd_sysmap) $@ System.map;                                         \
-	if [ $$? -ne 0 ]; then                                               \
-		rm -f $@;                                                    \
-		/bin/false;                                                  \
-	fi;
-	$(verify_kallsyms)
-endef
-
-
-ifdef CONFIG_KALLSYMS
-# Generate section listing all symbols and add it into vmlinux $(kallsyms.o)
-# It's a three stage process:
-# o .tmp_vmlinux1 has all symbols and sections, but __kallsyms is
-#   empty
-#   Running kallsyms on that gives us .tmp_kallsyms1.o with
-#   the right size - vmlinux version (uname -v) is updated during this step
-# o .tmp_vmlinux2 now has a __kallsyms section of the right size,
-#   but due to the added section, some addresses have shifted.
-#   From here, we generate a correct .tmp_kallsyms2.o
-# o The correct .tmp_kallsyms2.o is linked into the final vmlinux.
-# o Verify that the System.map from vmlinux matches the map from
-#   .tmp_vmlinux2, just in case we did not generate kallsyms correctly.
-# o If CONFIG_KALLSYMS_EXTRA_PASS is set, do an extra pass using
-#   .tmp_vmlinux3 and .tmp_kallsyms3.o.  This is only meant as a
-#   temporary bypass to allow the kernel to be built while the
-#   maintainers work out what went wrong with kallsyms.
-
-ifdef CONFIG_KALLSYMS_EXTRA_PASS
-last_kallsyms := 3
-else
-last_kallsyms := 2
-endif
-
-kallsyms.o := .tmp_kallsyms$(last_kallsyms).o
-
-define verify_kallsyms
-	$(Q)$(if $($(quiet)cmd_sysmap),                                      \
-	  echo '  $($(quiet)cmd_sysmap)  .tmp_System.map' &&)                \
-	  $(cmd_sysmap) .tmp_vmlinux$(last_kallsyms) .tmp_System.map
-	$(Q)cmp -s System.map .tmp_System.map ||                             \
-		(echo Inconsistent kallsyms data;                            \
-		 echo Try setting CONFIG_KALLSYMS_EXTRA_PASS;                \
-		 rm .tmp_kallsyms* ; /bin/false )
-endef
-
-# Update vmlinux version before link
-# Use + in front of this rule to silent warning about make -j1
-# First command is ':' to allow us to use + in front of this rule
-cmd_ksym_ld = $(cmd_vmlinux__)
-define rule_ksym_ld
-	: 
-	+$(call cmd,vmlinux_version)
-	$(call cmd,vmlinux__)
-	$(Q)echo 'cmd_$@ := $(cmd_vmlinux__)' > $(@D)/.$(@F).cmd
-endef
-
-# Generate .S file with all kernel symbols
-quiet_cmd_kallsyms = KSYM    $@
-      cmd_kallsyms = $(NM) -n $< | $(KALLSYMS) \
-                     $(if $(CONFIG_KALLSYMS_ALL),--all-symbols) > $@
-
-.tmp_kallsyms1.o .tmp_kallsyms2.o .tmp_kallsyms3.o: %.o: %.S scripts FORCE
-	$(call if_changed_dep,as_o_S)
-
-.tmp_kallsyms%.S: .tmp_vmlinux% $(KALLSYMS)
-	$(call cmd,kallsyms)
-
-# .tmp_vmlinux1 must be complete except kallsyms, so update vmlinux version
-.tmp_vmlinux1: $(vmlinux-lds) $(vmlinux-all) FORCE
-	$(call if_changed_rule,ksym_ld)
-
-.tmp_vmlinux2: $(vmlinux-lds) $(vmlinux-all) .tmp_kallsyms1.o FORCE
-	$(call if_changed,vmlinux__)
-
-.tmp_vmlinux3: $(vmlinux-lds) $(vmlinux-all) .tmp_kallsyms2.o FORCE
-	$(call if_changed,vmlinux__)
-
-# Needs to visit scripts/ before $(KALLSYMS) can be used.
-$(KALLSYMS): scripts ;
-
-# Generate some data for debugging strange kallsyms problems
-debug_kallsyms: .tmp_map$(last_kallsyms)
-
-.tmp_map%: .tmp_vmlinux% FORCE
-	($(OBJDUMP) -h $< | $(AWK) '/^ +[0-9]/{print $$4 " 0 " $$2}'; $(NM) $<) | sort > $@
-
-.tmp_map3: .tmp_map2
-
-.tmp_map2: .tmp_map1
-
-endif # ifdef CONFIG_KALLSYMS
-
-# vmlinux image - including updated kernel symbols
-vmlinux: $(vmlinux-lds) $(vmlinux-init) $(vmlinux-main) $(kallsyms.o) FORCE
-ifdef CONFIG_HEADERS_CHECK
-	$(Q)$(MAKE) -f $(srctree)/Makefile headers_check
-endif
-	$(call if_changed_rule,vmlinux__)
-	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost $@
-	$(Q)rm -f .old_version
-
-# The actual objects are generated when descending, 
-# make sure no implicit rule kicks in
-$(sort $(vmlinux-init) $(vmlinux-main)) $(vmlinux-lds): $(vmlinux-dirs) ;
-
-# Handle descending into subdirectories listed in $(vmlinux-dirs)
-# Preset locale variables to speed up the build process. Limit locale
-# tweaks to this spot to avoid wrong language settings when running
-# make menuconfig etc.
-# Error messages still appears in the original language
-
-PHONY += $(vmlinux-dirs)
-$(vmlinux-dirs): prepare scripts
-	$(Q)$(MAKE) $(build)=$@
-
-# Build the kernel release string
-#
-# The KERNELRELEASE value built here is stored in the file
-# include/config/kernel.release, and is used when executing several
-# make targets, such as "make install" or "make modules_install."
-#
-# The eventual kernel release string consists of the following fields,
-# shown in a hierarchical format to show how smaller parts are concatenated
-# to form the larger and final value, with values coming from places like
-# the Makefile, kernel config options, make command line options and/or
-# SCM tag information.
-#
-#	$(KERNELVERSION)
-#	  $(VERSION)			eg, 2
-#	  $(PATCHLEVEL)			eg, 6
-#	  $(SUBLEVEL)			eg, 18
-#	  $(EXTRAVERSION)		eg, -rc6
-#	$(localver-full)
-#	  $(localver)
-#	    localversion*		(files without backups, containing '~')
-#	    $(CONFIG_LOCALVERSION)	(from kernel config setting)
-#	  $(localver-auto)		(only if CONFIG_LOCALVERSION_AUTO is set)
-#	    ./scripts/setlocalversion	(SCM tag, if one exists)
-#	    $(LOCALVERSION)		(from make command line if provided)
-#
-#  Note how the final $(localver-auto) string is included *only* if the
-# kernel config option CONFIG_LOCALVERSION_AUTO is selected.  Also, at the
-# moment, only git is supported but other SCMs can edit the script
-# scripts/setlocalversion and add the appropriate checks as needed.
-
-pattern = ".*/localversion[^~]*"
-string  = $(shell cat /dev/null \
-	   `find $(objtree) $(srctree) -maxdepth 1 -regex $(pattern) | sort -u`)
-
-localver = $(subst $(space),, $(string) \
-			      $(patsubst "%",%,$(CONFIG_LOCALVERSION)))
-
-# If CONFIG_LOCALVERSION_AUTO is set scripts/setlocalversion is called
-# and if the SCM is know a tag from the SCM is appended.
-# The appended tag is determined by the SCM used.
-#
-# Currently, only git is supported.
-# Other SCMs can edit scripts/setlocalversion and add the appropriate
-# checks as needed.
-ifdef CONFIG_LOCALVERSION_AUTO
-	_localver-auto = $(shell $(CONFIG_SHELL) \
-	                  $(srctree)/scripts/setlocalversion $(srctree))
-	localver-auto  = $(LOCALVERSION)$(_localver-auto)
-endif
-
-localver-full = $(localver)$(localver-auto)
-
-# Store (new) KERNELRELASE string in include/config/kernel.release
-kernelrelease = $(KERNELVERSION)$(localver-full)
-include/config/kernel.release: include/config/auto.conf FORCE
-	$(Q)rm -f $@
-	$(Q)echo $(kernelrelease) > $@
-
-
-# Things we need to do before we recursively start building the kernel
-# or the modules are listed in "prepare".
-# A multi level approach is used. prepareN is processed before prepareN-1.
-# archprepare is used in arch Makefiles and when processed asm symlink,
-# version.h and scripts_basic is processed / created.
-
-# Listed in dependency order
-PHONY += prepare archprepare prepare0 prepare1 prepare2 prepare3
-
-# prepare3 is used to check if we are building in a separate output directory,
-# and if so do:
-# 1) Check that make has not been executed in the kernel src $(srctree)
-# 2) Create the include2 directory, used for the second asm symlink
-prepare3: include/config/kernel.release
-ifneq ($(KBUILD_SRC),)
-	@echo '  Using $(srctree) as source for kernel'
-	$(Q)if [ -f $(srctree)/.config -o -d $(srctree)/include/config ]; then \
-		echo "  $(srctree) is not clean, please run 'make mrproper'";\
-		echo "  in the '$(srctree)' directory.";\
-		/bin/false; \
-	fi;
-	$(Q)if [ ! -d include2 ]; then mkdir -p include2; fi;
-	$(Q)ln -fsn $(srctree)/include/asm-$(ARCH) include2/asm
-endif
-
-# prepare2 creates a makefile if using a separate output directory
-prepare2: prepare3 outputmakefile
-
-prepare1: prepare2 include/linux/version.h include/linux/utsrelease.h \
-                   include/asm include/config/auto.conf
-ifneq ($(KBUILD_MODULES),)
-	$(Q)mkdir -p $(MODVERDIR)
-	$(Q)rm -f $(MODVERDIR)/*
-endif
-
-archprepare: prepare1 scripts_basic
-
-prepare0: archprepare FORCE
-	$(Q)$(MAKE) $(build)=.
-	$(Q)$(MAKE) $(build)=. missing-syscalls
-
-# All the preparing..
-prepare: prepare0
-
-# Leave this as default for preprocessing vmlinux.lds.S, which is now
-# done in arch/$(ARCH)/kernel/Makefile
-
-export CPPFLAGS_vmlinux.lds += -P -C -U$(ARCH)
-
-# FIXME: The asm symlink changes when $(ARCH) changes. That's
-# hard to detect, but I suppose "make mrproper" is a good idea
-# before switching between archs anyway.
-
-include/asm:
-	@echo '  SYMLINK $@ -> include/asm-$(ARCH)'
-	$(Q)if [ ! -d include ]; then mkdir -p include; fi;
-	@ln -fsn asm-$(ARCH) $@
-
-# Generate some files
-# ---------------------------------------------------------------------------
-
-# KERNELRELEASE can change from a few different places, meaning version.h
-# needs to be updated, so this check is forced on all builds
-
-uts_len := 64
-define filechk_utsrelease.h
-	if [ `echo -n "$(KERNELRELEASE)" | wc -c ` -gt $(uts_len) ]; then \
-	  echo '"$(KERNELRELEASE)" exceeds $(uts_len) characters' >&2;    \
-	  exit 1;                                                         \
-	fi;                                                               \
-	(echo \#define UTS_RELEASE \"$(KERNELRELEASE)\";)
-endef
-
-define filechk_version.h
-	(echo \#define LINUX_VERSION_CODE $(shell                             \
-	expr $(VERSION) \* 65536 + $(PATCHLEVEL) \* 256 + $(SUBLEVEL));     \
-	echo '#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))';)
-endef
-
-include/linux/version.h: $(srctree)/Makefile FORCE
-	$(call filechk,version.h)
-
-include/linux/utsrelease.h: include/config/kernel.release FORCE
-	$(call filechk,utsrelease.h)
-
-# ---------------------------------------------------------------------------
-
-PHONY += depend dep
-depend dep:
-	@echo '*** Warning: make $@ is unnecessary now.'
-
-# ---------------------------------------------------------------------------
-# Kernel headers
-INSTALL_HDR_PATH=$(objtree)/usr
-export INSTALL_HDR_PATH
-
-HDRARCHES=$(filter-out generic,$(patsubst $(srctree)/include/asm-%/Kbuild,%,$(wildcard $(srctree)/include/asm-*/Kbuild)))
-
-PHONY += headers_install_all
-headers_install_all: include/linux/version.h scripts_basic FORCE
-	$(Q)$(MAKE) $(build)=scripts scripts/unifdef
-	$(Q)for arch in $(HDRARCHES); do \
-	 $(MAKE) ARCH=$$arch -f $(srctree)/scripts/Makefile.headersinst obj=include BIASMDIR=-bi-$$arch ;\
-	 done
-
-PHONY += headers_install
-headers_install: include/linux/version.h scripts_basic FORCE
-	@if [ ! -r $(srctree)/include/asm-$(ARCH)/Kbuild ]; then \
-	  echo '*** Error: Headers not exportable for this architecture ($(ARCH))'; \
-	  exit 1 ; fi
-	$(Q)$(MAKE) $(build)=scripts scripts/unifdef
-	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.headersinst obj=include
-
-PHONY += headers_check_all
-headers_check_all: headers_install_all
-	$(Q)for arch in $(HDRARCHES); do \
-	 $(MAKE) ARCH=$$arch -f $(srctree)/scripts/Makefile.headersinst obj=include BIASMDIR=-bi-$$arch HDRCHECK=1 ;\
-	 done
-
-PHONY += headers_check
-headers_check: headers_install
-	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.headersinst obj=include HDRCHECK=1
-
-# ---------------------------------------------------------------------------
-# Modules
-
-ifdef CONFIG_MODULES
-
-# By default, build modules as well
-
-all: modules
-
-#	Build modules
-
-PHONY += modules
-modules: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux)
-	@echo '  Building modules, stage 2.';
-	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
-
-
-# Target to prepare building external modules
-PHONY += modules_prepare
-modules_prepare: prepare scripts
-
-# Target to install modules
-PHONY += modules_install
-modules_install: _modinst_ _modinst_post
-
-PHONY += _modinst_
-_modinst_:
-	@if [ -z "`$(DEPMOD) -V 2>/dev/null | grep module-init-tools`" ]; then \
-		echo "Warning: you may need to install module-init-tools"; \
-		echo "See http://www.codemonkey.org.uk/docs/post-halloween-2.6.txt";\
-		sleep 1; \
-	fi
-	@rm -rf $(MODLIB)/kernel
-	@rm -f $(MODLIB)/source
-	@mkdir -p $(MODLIB)/kernel
-	@ln -s $(srctree) $(MODLIB)/source
-	@if [ ! $(objtree) -ef  $(MODLIB)/build ]; then \
-		rm -f $(MODLIB)/build ; \
-		ln -s $(objtree) $(MODLIB)/build ; \
-	fi
-	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modinst
-
-# If System.map exists, run depmod.  This deliberately does not have a
-# dependency on System.map since that would run the dependency tree on
-# vmlinux.  This depmod is only for convenience to give the initial
-# boot a modules.dep even before / is mounted read-write.  However the
-# boot script depmod is the master version.
-ifeq "$(strip $(INSTALL_MOD_PATH))" ""
-depmod_opts	:=
-else
-depmod_opts	:= -b $(INSTALL_MOD_PATH) -r
-endif
-PHONY += _modinst_post
-_modinst_post: _modinst_
-	if [ -r System.map -a -x $(DEPMOD) ]; then $(DEPMOD) -ae -F System.map $(depmod_opts) $(KERNELRELEASE); fi
-
-else # CONFIG_MODULES
-
-# Modules not configured
-# ---------------------------------------------------------------------------
-
-modules modules_install: FORCE
-	@echo
-	@echo "The present kernel configuration has modules disabled."
-	@echo "Type 'make config' and enable loadable module support."
-	@echo "Then build a kernel with module support enabled."
-	@echo
-	@exit 1
-
-endif # CONFIG_MODULES
-
-###
-# Cleaning is done on three levels.
-# make clean     Delete most generated files
-#                Leave enough to build external modules
-# make mrproper  Delete the current configuration, and all generated files
-# make distclean Remove editor backup files, patch leftover files and the like
-
-# Directories & files removed with 'make clean'
-CLEAN_DIRS  += $(MODVERDIR)
-CLEAN_FILES +=	vmlinux System.map \
-                .tmp_kallsyms* .tmp_version .tmp_vmlinux* .tmp_System.map
-
-# Directories & files removed with 'make mrproper'
-MRPROPER_DIRS  += include/config include2 usr/include
-MRPROPER_FILES += .config .config.old include/asm .version .old_version \
-                  include/linux/autoconf.h include/linux/version.h      \
-                  include/linux/utsrelease.h                            \
-		  Module.symvers tags TAGS cscope*
-
-# clean - Delete most, but leave enough to build external modules
-#
-clean: rm-dirs  := $(CLEAN_DIRS)
-clean: rm-files := $(CLEAN_FILES)
-clean-dirs      := $(addprefix _clean_,$(srctree) $(vmlinux-alldirs))
-
-PHONY += $(clean-dirs) clean archclean
-$(clean-dirs):
-	$(Q)$(MAKE) $(clean)=$(patsubst _clean_%,%,$@)
-
-clean: archclean $(clean-dirs)
-	$(call cmd,rmdirs)
-	$(call cmd,rmfiles)
-	@find . $(RCS_FIND_IGNORE) \
-		\( -name '*.[oas]' -o -name '*.ko' -o -name '.*.cmd' \
-		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \
-		-o -name '*.symtypes' \) \
-		-type f -print | xargs rm -f
-
-# mrproper - Delete all generated files, including .config
-#
-mrproper: rm-dirs  := $(wildcard $(MRPROPER_DIRS))
-mrproper: rm-files := $(wildcard $(MRPROPER_FILES))
-mrproper-dirs      := $(addprefix _mrproper_,Documentation/DocBook scripts)
-
-PHONY += $(mrproper-dirs) mrproper archmrproper
-$(mrproper-dirs):
-	$(Q)$(MAKE) $(clean)=$(patsubst _mrproper_%,%,$@)
-
-mrproper: clean archmrproper $(mrproper-dirs)
-	$(call cmd,rmdirs)
-	$(call cmd,rmfiles)
-
-# distclean
-#
-PHONY += distclean
-
-distclean: mrproper
-	@find $(srctree) $(RCS_FIND_IGNORE) \
-		\( -name '*.orig' -o -name '*.rej' -o -name '*~' \
-		-o -name '*.bak' -o -name '#*#' -o -name '.*.orig' \
-		-o -name '.*.rej' -o -size 0 \
-		-o -name '*%' -o -name '.*.cmd' -o -name 'core' \) \
-		-type f -print | xargs rm -f
-
-
-# Packaging of the kernel to various formats
-# ---------------------------------------------------------------------------
-# rpm target kept for backward compatibility
-package-dir	:= $(srctree)/scripts/package
-
-%pkg: include/config/kernel.release FORCE
-	$(Q)$(MAKE) $(build)=$(package-dir) $@
-rpm: include/config/kernel.release FORCE
-	$(Q)$(MAKE) $(build)=$(package-dir) $@
-
-
-# Brief documentation of the typical targets used
-# ---------------------------------------------------------------------------
-
-boards := $(wildcard $(srctree)/arch/$(ARCH)/configs/*_defconfig)
-boards := $(notdir $(boards))
-
-help:
-	@echo  'Cleaning targets:'
-	@echo  '  clean		  - Remove most generated files but keep the config and'
-	@echo  '                    enough build support to build external modules'
-	@echo  '  mrproper	  - Remove all generated files + config + various backup files'
-	@echo  '  distclean	  - mrproper + remove editor backup and patch files'
-	@echo  ''
-	@echo  'Configuration targets:'
-	@$(MAKE) -f $(srctree)/scripts/kconfig/Makefile help
-	@echo  ''
-	@echo  'Other generic targets:'
-	@echo  '  all		  - Build all targets marked with [*]'
-	@echo  '* vmlinux	  - Build the bare kernel'
-	@echo  '* modules	  - Build all modules'
-	@echo  '  modules_install - Install all modules to INSTALL_MOD_PATH (default: /)'
-	@echo  '  dir/            - Build all files in dir and below'
-	@echo  '  dir/file.[ois]  - Build specified target only'
-	@echo  '  dir/file.ko     - Build module including final link'
-	@echo  '  rpm		  - Build a kernel as an RPM package'
-	@echo  '  tags/TAGS	  - Generate tags file for editors'
-	@echo  '  cscope	  - Generate cscope index'
-	@echo  '  kernelrelease	  - Output the release version string'
-	@echo  '  kernelversion	  - Output the version stored in Makefile'
-	@if [ -r $(srctree)/include/asm-$(ARCH)/Kbuild ]; then \
-	 echo  '  headers_install - Install sanitised kernel headers to INSTALL_HDR_PATH'; \
-	 echo  '                    (default: $(INSTALL_HDR_PATH))'; \
-	 fi
-	@echo  ''
-	@echo  'Static analysers'
-	@echo  '  checkstack      - Generate a list of stack hogs'
-	@echo  '  namespacecheck  - Name space analysis on compiled kernel'
-	@if [ -r $(srctree)/include/asm-$(ARCH)/Kbuild ]; then \
-	 echo  '  headers_check   - Sanity check on exported headers'; \
-	 fi
-	@echo  ''
-	@echo  'Kernel packaging:'
-	@$(MAKE) $(build)=$(package-dir) help
-	@echo  ''
-	@echo  'Documentation targets:'
-	@$(MAKE) -f $(srctree)/Documentation/DocBook/Makefile dochelp
-	@echo  ''
-	@echo  'Architecture specific targets ($(ARCH)):'
-	@$(if $(archhelp),$(archhelp),\
-		echo '  No architecture specific help defined for $(ARCH)')
-	@echo  ''
-	@$(if $(boards), \
-		$(foreach b, $(boards), \
-		printf "  %-24s - Build for %s\\n" $(b) $(subst _defconfig,,$(b));) \
-		echo '')
-
-	@echo  '  make V=0|1 [targets] 0 => quiet build (default), 1 => verbose build'
-	@echo  '  make V=2   [targets] 2 => give reason for rebuild of target'
-	@echo  '  make O=dir [targets] Locate all output files in "dir", including .config'
-	@echo  '  make C=1   [targets] Check all c source with $$CHECK (sparse by default)'
-	@echo  '  make C=2   [targets] Force check of all c source with $$CHECK'
-	@echo  ''
-	@echo  'Execute "make" or "make all" to build all targets marked with [*] '
-	@echo  'For further info see the ./README file'
-
-
-# Documentation targets
-# ---------------------------------------------------------------------------
-%docs: scripts_basic FORCE
-	$(Q)$(MAKE) $(build)=Documentation/DocBook $@
-
-else # KBUILD_EXTMOD
-
-###
-# External module support.
-# When building external modules the kernel used as basis is considered
-# read-only, and no consistency checks are made and the make
-# system is not used on the basis kernel. If updates are required
-# in the basis kernel ordinary make commands (without M=...) must
-# be used.
-#
-# The following are the only valid targets when building external
-# modules.
-# make M=dir clean     Delete all automatically generated files
-# make M=dir modules   Make all modules in specified dir
-# make M=dir	       Same as 'make M=dir modules'
-# make M=dir modules_install
-#                      Install the modules built in the module directory
-#                      Assumes install directory is already created
-
-# We are always building modules
-KBUILD_MODULES := 1
-PHONY += crmodverdir
-crmodverdir:
-	$(Q)mkdir -p $(MODVERDIR)
-	$(Q)rm -f $(MODVERDIR)/*
-
-PHONY += $(objtree)/Module.symvers
-$(objtree)/Module.symvers:
-	@test -e $(objtree)/Module.symvers || ( \
-	echo; \
-	echo "  WARNING: Symbol version dump $(objtree)/Module.symvers"; \
-	echo "           is missing; modules will have no dependencies and modversions."; \
-	echo )
-
-module-dirs := $(addprefix _module_,$(KBUILD_EXTMOD))
-PHONY += $(module-dirs) modules
-$(module-dirs): crmodverdir $(objtree)/Module.symvers
-	$(Q)$(MAKE) $(build)=$(patsubst _module_%,%,$@)
-
-modules: $(module-dirs)
-	@echo '  Building modules, stage 2.';
-	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
-
-PHONY += modules_install
-modules_install: _emodinst_ _emodinst_post
-
-install-dir := $(if $(INSTALL_MOD_DIR),$(INSTALL_MOD_DIR),extra)
-PHONY += _emodinst_
-_emodinst_:
-	$(Q)mkdir -p $(MODLIB)/$(install-dir)
-	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modinst
-
-# Run depmod only is we have System.map and depmod is executable
-quiet_cmd_depmod = DEPMOD  $(KERNELRELEASE)
-      cmd_depmod = if [ -r System.map -a -x $(DEPMOD) ]; then \
-                      $(DEPMOD) -ae -F System.map             \
-                      $(if $(strip $(INSTALL_MOD_PATH)),      \
-		      -b $(INSTALL_MOD_PATH) -r)              \
-		      $(KERNELRELEASE);                       \
-                   fi
-
-PHONY += _emodinst_post
-_emodinst_post: _emodinst_
-	$(call cmd,depmod)
-
-clean-dirs := $(addprefix _clean_,$(KBUILD_EXTMOD))
-
-PHONY += $(clean-dirs) clean
-$(clean-dirs):
-	$(Q)$(MAKE) $(clean)=$(patsubst _clean_%,%,$@)
-
-clean:	rm-dirs := $(MODVERDIR)
-clean: $(clean-dirs)
-	$(call cmd,rmdirs)
-	@find $(KBUILD_EXTMOD) $(RCS_FIND_IGNORE) \
-		\( -name '*.[oas]' -o -name '*.ko' -o -name '.*.cmd' \
-		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \) \
-		-type f -print | xargs rm -f
-
-help:
-	@echo  '  Building external modules.'
-	@echo  '  Syntax: make -C path/to/kernel/src M=$$PWD target'
-	@echo  ''
-	@echo  '  modules         - default target, build the module(s)'
-	@echo  '  modules_install - install the module'
-	@echo  '  clean           - remove generated files in module directory only'
-	@echo  ''
-
-# Dummies...
-PHONY += prepare scripts
-prepare: ;
-scripts: ;
-endif # KBUILD_EXTMOD
-
-# Generate tags for editors
-# ---------------------------------------------------------------------------
-
-#We want __srctree to totally vanish out when KBUILD_OUTPUT is not set
-#(which is the most common case IMHO) to avoid unneeded clutter in the big tags file.
-#Adding $(srctree) adds about 20M on i386 to the size of the output file!
-
-ifeq ($(src),$(obj))
-__srctree =
-else
-__srctree = $(srctree)/
-endif
-
-ifeq ($(ALLSOURCE_ARCHS),)
-ifeq ($(ARCH),um)
-ALLINCLUDE_ARCHS := $(ARCH) $(SUBARCH)
-else
-ALLINCLUDE_ARCHS := $(ARCH)
-endif
-else
-#Allow user to specify only ALLSOURCE_PATHS on the command line, keeping existing behavour.
-ALLINCLUDE_ARCHS := $(ALLSOURCE_ARCHS)
-endif
-
-ALLSOURCE_ARCHS := $(ARCH)
-
-define find-sources
-        ( for ARCH in $(ALLSOURCE_ARCHS) ; do \
-	       find $(__srctree)arch/$${ARCH} $(RCS_FIND_IGNORE) \
-	            -name $1 -print; \
-	  done ; \
-	  find $(__srctree)security/selinux/include $(RCS_FIND_IGNORE) \
-	       -name $1 -print; \
-	  find $(__srctree)include $(RCS_FIND_IGNORE) \
-	       \( -name config -o -name 'asm-*' \) -prune \
-	       -o -name $1 -print; \
-	  for ARCH in $(ALLINCLUDE_ARCHS) ; do \
-	       find $(__srctree)include/asm-$${ARCH} $(RCS_FIND_IGNORE) \
-	            -name $1 -print; \
-	  done ; \
-	  find $(__srctree)include/asm-generic $(RCS_FIND_IGNORE) \
-	       -name $1 -print; \
-	  find $(__srctree) $(RCS_FIND_IGNORE) \
-	       \( -name include -o -name arch \) -prune -o \
-	       -name $1 -print; \
-	  )
-endef
-
-define all-sources
-	$(call find-sources,'*.[chS]')
-endef
-define all-kconfigs
-	$(call find-sources,'Kconfig*')
-endef
-define all-defconfigs
-	$(call find-sources,'defconfig')
-endef
-
-define xtags
-	if $1 --version 2>&1 | grep -iq exuberant; then \
-	    $(all-sources) | xargs $1 -a \
-		-I __initdata,__exitdata,__acquires,__releases \
-		-I EXPORT_SYMBOL,EXPORT_SYMBOL_GPL \
-		--extra=+f --c-kinds=+px \
-		--regex-asm='/ENTRY\(([^)]*)\).*/\1/'; \
-	    $(all-kconfigs) | xargs $1 -a \
-		--langdef=kconfig \
-		--language-force=kconfig \
-		--regex-kconfig='/^[[:blank:]]*config[[:blank:]]+([[:alnum:]_]+)/\1/'; \
-	    $(all-defconfigs) | xargs -r $1 -a \
-		--langdef=dotconfig \
-		--language-force=dotconfig \
-		--regex-dotconfig='/^#?[[:blank:]]*(CONFIG_[[:alnum:]_]+)/\1/'; \
-	elif $1 --version 2>&1 | grep -iq emacs; then \
-	    $(all-sources) | xargs $1 -a; \
-	    $(all-kconfigs) | xargs $1 -a \
-		--regex='/^[ \t]*config[ \t]+\([a-zA-Z0-9_]+\)/\1/'; \
-	    $(all-defconfigs) | xargs -r $1 -a \
-		--regex='/^#?[ \t]?\(CONFIG_[a-zA-Z0-9_]+\)/\1/'; \
-	else \
-	    $(all-sources) | xargs $1 -a; \
-	fi
-endef
-
-quiet_cmd_cscope-file = FILELST cscope.files
-      cmd_cscope-file = (echo \-k; echo \-q; $(all-sources)) > cscope.files
-
-quiet_cmd_cscope = MAKE    cscope.out
-      cmd_cscope = cscope -b
-
-cscope: FORCE
-	$(call cmd,cscope-file)
-	$(call cmd,cscope)
-
-quiet_cmd_TAGS = MAKE   $@
-define cmd_TAGS
-	rm -f $@; \
-	$(call xtags,etags)
-endef
-
-TAGS: FORCE
-	$(call cmd,TAGS)
-
-quiet_cmd_tags = MAKE   $@
-define cmd_tags
-	rm -f $@; \
-	$(call xtags,ctags)
-endef
-
-tags: FORCE
-	$(call cmd,tags)
-
-
-# Scripts to check various things for consistency
-# ---------------------------------------------------------------------------
-
-includecheck:
-	find * $(RCS_FIND_IGNORE) \
-		-name '*.[hcS]' -type f -print | sort \
-		| xargs $(PERL) -w scripts/checkincludes.pl
-
-versioncheck:
-	find * $(RCS_FIND_IGNORE) \
-		-name '*.[hcS]' -type f -print | sort \
-		| xargs $(PERL) -w scripts/checkversion.pl
-
-namespacecheck:
-	$(PERL) $(srctree)/scripts/namespace.pl
-
-endif #ifeq ($(config-targets),1)
-endif #ifeq ($(mixed-targets),1)
-
-PHONY += checkstack kernelrelease kernelversion
-
-# UML needs a little special treatment here.  It wants to use the host
-# toolchain, so needs $(SUBARCH) passed to checkstack.pl.  Everyone
-# else wants $(ARCH), including people doing cross-builds, which means
-# that $(SUBARCH) doesn't work here.
-ifeq ($(ARCH), um)
-CHECKSTACK_ARCH := $(SUBARCH)
-else
-CHECKSTACK_ARCH := $(ARCH)
-endif
-checkstack:
-	$(OBJDUMP) -d vmlinux $$(find . -name '*.ko') | \
-	$(PERL) $(src)/scripts/checkstack.pl $(CHECKSTACK_ARCH)
-
-kernelrelease:
-	$(if $(wildcard include/config/kernel.release), $(Q)echo $(KERNELRELEASE), \
-	$(error kernelrelease not valid - run 'make prepare' to update it))
-kernelversion:
-	@echo $(KERNELVERSION)
-
-# Single targets
-# ---------------------------------------------------------------------------
-# Single targets are compatible with:
-# - build whith mixed source and output
-# - build with separate output dir 'make O=...'
-# - external modules
-#
-#  target-dir => where to store outputfile
-#  build-dir  => directory in kernel source tree to use
-
-ifeq ($(KBUILD_EXTMOD),)
-        build-dir  = $(patsubst %/,%,$(dir $@))
-        target-dir = $(dir $@)
-else
-        zap-slash=$(filter-out .,$(patsubst %/,%,$(dir $@)))
-        build-dir  = $(KBUILD_EXTMOD)$(if $(zap-slash),/$(zap-slash))
-        target-dir = $(if $(KBUILD_EXTMOD),$(dir $<),$(dir $@))
-endif
-
-%.s: %.c prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.i: %.c prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.o: %.c prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.lst: %.c prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.s: %.S prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.o: %.S prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-%.symtypes: %.c prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
-
-# Modules
-/ %/: prepare scripts FORCE
-	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
-	$(build)=$(build-dir)
-%.ko: prepare scripts FORCE
-	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1)   \
-	$(build)=$(build-dir) $(@:.ko=.o)
-	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
-
-# FIXME Should go into a make.lib or something 
-# ===========================================================================
-
-quiet_cmd_rmdirs = $(if $(wildcard $(rm-dirs)),CLEAN   $(wildcard $(rm-dirs)))
-      cmd_rmdirs = rm -rf $(rm-dirs)
-
-quiet_cmd_rmfiles = $(if $(wildcard $(rm-files)),CLEAN   $(wildcard $(rm-files)))
-      cmd_rmfiles = rm -f $(rm-files)
-
-
-a_flags = -Wp,-MD,$(depfile) $(AFLAGS) $(AFLAGS_KERNEL) \
-	  $(NOSTDINC_FLAGS) $(CPPFLAGS) \
-	  $(modkern_aflags) $(EXTRA_AFLAGS) $(AFLAGS_$(basetarget).o)
-
-quiet_cmd_as_o_S = AS      $@
-cmd_as_o_S       = $(CC) $(a_flags) -c -o $@ $<
-
-# read all saved command lines
-
-targets := $(wildcard $(sort $(targets)))
-cmd_files := $(wildcard .*.cmd $(foreach f,$(targets),$(dir $(f)).$(notdir $(f)).cmd))
-
-ifneq ($(cmd_files),)
-  $(cmd_files): ;	# Do not try to update included dependency files
-  include $(cmd_files)
-endif
-
-# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.clean obj=dir
-# Usage:
-# $(Q)$(MAKE) $(clean)=dir
-clean := -f $(if $(KBUILD_SRC),$(srctree)/)scripts/Makefile.clean obj
-
-endif	# skip-makefile
-
-PHONY += FORCE
-FORCE:
-
-# Cancel implicit rules on top Makefile, `-rR' will apply to sub-makes.
-Makefile: ;
-
-# Declare the contents of the .PHONY variable as phony.  We keep that
-# information in a variable se we can use it in if_changed and friends.
-.PHONY: $(PHONY)
Files linux-2.6.22-590/arch/arm/boot/compressed/.head.S.rej.swp and linux-2.6.22-try2-netns/arch/arm/boot/compressed/.head.S.rej.swp differ
diff -Nurb linux-2.6.22-590/arch/ia64/hp/sim/simeth.c linux-2.6.22-try2-netns/arch/ia64/hp/sim/simeth.c
--- linux-2.6.22-590/arch/ia64/hp/sim/simeth.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/arch/ia64/hp/sim/simeth.c	2007-12-19 22:49:13.000000000 -0500
@@ -300,6 +300,9 @@
 		return NOTIFY_DONE;
 	}
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if ( event != NETDEV_UP && event != NETDEV_DOWN ) return NOTIFY_DONE;
 
 	/*
diff -Nurb linux-2.6.22-590/arch/s390/appldata/appldata_net_sum.c linux-2.6.22-try2-netns/arch/s390/appldata/appldata_net_sum.c
--- linux-2.6.22-590/arch/s390/appldata/appldata_net_sum.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/arch/s390/appldata/appldata_net_sum.c	2007-12-19 22:49:13.000000000 -0500
@@ -16,6 +16,7 @@
 #include <linux/errno.h>
 #include <linux/kernel_stat.h>
 #include <linux/netdevice.h>
+#include <net/net_namespace.h>
 
 #include "appldata.h"
 
@@ -107,7 +108,7 @@
 	tx_dropped = 0;
 	collisions = 0;
 	read_lock(&dev_base_lock);
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		stats = dev->get_stats(dev);
 		rx_packets += stats->rx_packets;
 		tx_packets += stats->tx_packets;
diff -Nurb linux-2.6.22-590/arch/sparc64/solaris/ioctl.c linux-2.6.22-try2-netns/arch/sparc64/solaris/ioctl.c
--- linux-2.6.22-590/arch/sparc64/solaris/ioctl.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/arch/sparc64/solaris/ioctl.c	2007-12-19 22:49:13.000000000 -0500
@@ -28,6 +28,7 @@
 #include <linux/compat.h>
 
 #include <net/sock.h>
+#include <net/net_namespace.h>
 
 #include <asm/uaccess.h>
 #include <asm/termios.h>
@@ -686,7 +687,7 @@
 			int i = 0;
 			
 			read_lock_bh(&dev_base_lock);
-			for_each_netdev(d)
+			for_each_netdev(&init_net, d)
 				i++;
 			read_unlock_bh(&dev_base_lock);
 
diff -Nurb linux-2.6.22-590/drivers/acpi/video.c linux-2.6.22-try2-netns/drivers/acpi/video.c
--- linux-2.6.22-590/drivers/acpi/video.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/drivers/acpi/video.c	2007-12-21 14:25:48.000000000 -0500
@@ -559,7 +559,6 @@
 
 static void acpi_video_device_find_cap(struct acpi_video_device *device)
 {
-	acpi_integer status;
 	acpi_handle h_dummy1;
 	int i;
 	u32 max_level = 0;
@@ -593,9 +592,9 @@
 		device->cap._DSS = 1;
 	}
 
-	status = acpi_video_device_lcd_query_levels(device, &obj);
+	if (ACPI_SUCCESS(acpi_video_device_lcd_query_levels(device, &obj))) {
 
-	if (obj && obj->type == ACPI_TYPE_PACKAGE && obj->package.count >= 2) {
+		if (obj->package.count >= 2) {
 		int count = 0;
 		union acpi_object *o;
 
@@ -616,6 +615,7 @@
 					continue;
 				}
 				br->levels[count] = (u32) o->integer.value;
+
 				if (br->levels[count] > max_level)
 					max_level = br->levels[count];
 				count++;
@@ -634,9 +634,13 @@
 		}
 	}
 
+	} else {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Could not query available LCD brightness level\n"));
+	}
+
 	kfree(obj);
 
-	if (device->cap._BCL && device->cap._BCM && device->cap._BQC){
+	if (device->cap._BCL && device->cap._BCM && device->cap._BQC && max_level > 0){
 		unsigned long tmp;
 		static int count = 0;
 		char *name;
diff -Nurb linux-2.6.22-590/drivers/atm/idt77252.c linux-2.6.22-try2-netns/drivers/atm/idt77252.c
--- linux-2.6.22-590/drivers/atm/idt77252.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/atm/idt77252.c	2007-12-19 22:49:13.000000000 -0500
@@ -3576,7 +3576,7 @@
 	 * XXX: <hack>
 	 */
 	sprintf(tname, "eth%d", card->index);
-	tmp = dev_get_by_name(tname);	/* jhs: was "tmp = dev_get(tname);" */
+	tmp = dev_get_by_name(&init_net, tname);	/* jhs: was "tmp = dev_get(tname);" */
 	if (tmp) {
 		memcpy(card->atmdev->esi, tmp->dev_addr, 6);
 
diff -Nurb linux-2.6.22-590/drivers/base/class.c linux-2.6.22-try2-netns/drivers/base/class.c
--- linux-2.6.22-590/drivers/base/class.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/drivers/base/class.c	2007-12-21 14:26:25.000000000 -0500
@@ -134,6 +134,17 @@
 	}
 }
 
+static int class_setup_shadowing(struct class *cls)
+{
+	const struct shadow_dir_operations *shadow_ops;
+
+	shadow_ops = cls->shadow_ops;
+	if (!shadow_ops)
+		return 0;
+
+	return sysfs_enable_shadowing(&cls->subsys.kobj, shadow_ops);
+}
+
 int class_register(struct class * cls)
 {
 	int error;
@@ -152,11 +163,22 @@
 	subsys_set_kset(cls, class_subsys);
 
 	error = subsystem_register(&cls->subsys);
-	if (!error) {
-		error = add_class_attrs(class_get(cls));
-		class_put(cls);
-	}
+	if (error)
+		goto out;
+
+	error = class_setup_shadowing(cls);
+	if (error)
+		goto out_unregister;
+
+	error = add_class_attrs(cls);
+	if (error)
+		goto out_unregister;
+
+out:
 	return error;
+out_unregister:
+	subsystem_unregister(&cls->subsys);
+	goto out;
 }
 
 void class_unregister(struct class * cls)
diff -Nurb linux-2.6.22-590/drivers/base/core.c linux-2.6.22-try2-netns/drivers/base/core.c
--- linux-2.6.22-590/drivers/base/core.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/drivers/base/core.c	2007-12-21 14:27:08.000000000 -0500
@@ -622,8 +622,14 @@
 			return kobj;
 
 		/* or create a new class-directory at the parent device */
-		return kobject_kset_add_dir(&dev->class->class_dirs,
+		kobj = kobject_kset_add_dir(&dev->class->class_dirs,
 					    parent_kobj, dev->class->name);
+
+		/* If we created a new class-directory setup shadowing */
+		if (kobj && dev->class->shadow_ops)
+			sysfs_enable_shadowing(kobj, dev->class->shadow_ops);
+
+		return kobj;
 	}
 
 	if (parent)
@@ -657,12 +663,12 @@
 	 * If this is not a "fake" compatible device, then create the
 	 * symlink from the class to the device.
 	 */
-	if (dev->kobj.parent == &dev->class->subsys.kobj)
-		return 0;
+	if (dev->kobj.parent != &dev->class->subsys.kobj) {
 	error = sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
 				  dev->bus_id);
 	if (error)
 		goto out_subsys;
+	}
 	/* only bus-device parents get a "device"-link */
 	if (dev->parent && dev->parent->bus) {
 		error = sysfs_create_link(&dev->kobj, &dev->parent->kobj,
@@ -690,6 +696,7 @@
 		sysfs_remove_link(&dev->kobj, "device");
 #endif
 out_busid:
+	if (dev->kobj.parent != &dev->class->subsys.kobj)
 	sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
 out_subsys:
 	sysfs_remove_link(&dev->kobj, "subsystem");
@@ -713,6 +720,7 @@
 #endif
 		sysfs_remove_link(&dev->kobj, "device");
 	}
+	if (dev->kobj.parent != &dev->class->subsys.kobj)
 	sysfs_remove_link(&dev->class->subsys.kobj, dev->bus_id);
 	sysfs_remove_link(&dev->kobj, "subsystem");
 }
@@ -913,8 +921,8 @@
 		/* If this is not a "fake" compatible device, remove the
 		 * symlink from the class to the device. */
 		if (dev->kobj.parent != &dev->class->subsys.kobj)
-			sysfs_remove_link(&dev->class->subsys.kobj,
-					  dev->bus_id);
+			sysfs_delete_link(&dev->class->subsys.kobj,
+					  &dev->kobj, dev->bus_id);
 		if (parent) {
 #ifdef CONFIG_SYSFS_DEPRECATED
 			char *class_name = make_class_name(dev->class->name,
@@ -1212,6 +1220,13 @@
 	strlcpy(old_device_name, dev->bus_id, BUS_ID_SIZE);
 	strlcpy(dev->bus_id, new_name, BUS_ID_SIZE);
 
+	if (dev->class && (dev->kobj.parent != &dev->class->subsys.kobj)) {
+		error = sysfs_rename_link(&dev->class->subsys.kobj,
+			&dev->kobj, old_device_name, new_name);
+		if (error)
+			goto out;
+	}
+
 	error = kobject_rename(&dev->kobj, new_name);
 	if (error) {
 		strlcpy(dev->bus_id, old_device_name, BUS_ID_SIZE);
@@ -1220,27 +1235,17 @@
 
 #ifdef CONFIG_SYSFS_DEPRECATED
 	if (old_class_name) {
+		error = -ENOMEM;
 		new_class_name = make_class_name(dev->class->name, &dev->kobj);
-		if (new_class_name) {
-			error = sysfs_create_link(&dev->parent->kobj,
-						  &dev->kobj, new_class_name);
+		if (!new_class_name)
+			goto out;
+
+		error = sysfs_rename_link(&dev->parent->kobj, &dev->kobj,
+					  old_class_name, new_class_name);
 			if (error)
 				goto out;
-			sysfs_remove_link(&dev->parent->kobj, old_class_name);
-		}
 	}
 #endif
-
-	if (dev->class) {
-		sysfs_remove_link(&dev->class->subsys.kobj, old_device_name);
-		error = sysfs_create_link(&dev->class->subsys.kobj, &dev->kobj,
-				  dev->bus_id);
-		if (error) {
-			/* Uh... how to unravel this if restoring can fail? */
-			dev_err(dev, "%s: sysfs_create_symlink failed (%d)\n",
-				__FUNCTION__, error);
-	}
-	}
 out:
 	put_device(dev);
 
diff -Nurb linux-2.6.22-590/drivers/block/aoe/aoecmd.c linux-2.6.22-try2-netns/drivers/block/aoe/aoecmd.c
--- linux-2.6.22-590/drivers/block/aoe/aoecmd.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/block/aoe/aoecmd.c	2007-12-19 22:49:13.000000000 -0500
@@ -9,6 +9,7 @@
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
 #include <linux/genhd.h>
+#include <net/net_namespace.h>
 #include <asm/unaligned.h>
 #include "aoe.h"
 
@@ -194,7 +195,7 @@
 	sl = sl_tail = NULL;
 
 	read_lock(&dev_base_lock);
-	for_each_netdev(ifp) {
+	for_each_netdev(&init_net, ifp) {
 		dev_hold(ifp);
 		if (!is_aoe_netif(ifp))
 			goto cont;
diff -Nurb linux-2.6.22-590/drivers/block/aoe/aoenet.c linux-2.6.22-try2-netns/drivers/block/aoe/aoenet.c
--- linux-2.6.22-590/drivers/block/aoe/aoenet.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/block/aoe/aoenet.c	2007-12-19 22:49:13.000000000 -0500
@@ -8,6 +8,7 @@
 #include <linux/blkdev.h>
 #include <linux/netdevice.h>
 #include <linux/moduleparam.h>
+#include <net/net_namespace.h>
 #include <asm/unaligned.h>
 #include "aoe.h"
 
@@ -114,6 +115,9 @@
 	struct aoe_hdr *h;
 	u32 n;
 
+	if (ifp->nd_net != &init_net)
+		goto exit;
+
 	skb = skb_share_check(skb, GFP_ATOMIC);
 	if (skb == NULL)
 		return 0;
diff -Nurb linux-2.6.22-590/drivers/connector/connector.c linux-2.6.22-try2-netns/drivers/connector/connector.c
--- linux-2.6.22-590/drivers/connector/connector.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/connector/connector.c	2007-12-19 22:49:13.000000000 -0500
@@ -446,7 +446,7 @@
 	dev->id.idx = cn_idx;
 	dev->id.val = cn_val;
 
-	dev->nls = netlink_kernel_create(NETLINK_CONNECTOR,
+	dev->nls = netlink_kernel_create(&init_net, NETLINK_CONNECTOR,
 					 CN_NETLINK_USERS + 0xf,
 					 dev->input, NULL, THIS_MODULE);
 	if (!dev->nls)
diff -Nurb linux-2.6.22-590/drivers/cpuidle/cpuidle.c linux-2.6.22-try2-netns/drivers/cpuidle/cpuidle.c
--- linux-2.6.22-590/drivers/cpuidle/cpuidle.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/drivers/cpuidle/cpuidle.c	2007-12-21 14:25:48.000000000 -0500
@@ -25,7 +25,6 @@
 LIST_HEAD(cpuidle_detected_devices);
 static void (*pm_idle_old)(void);
 
-
 /**
  * cpuidle_idle_call - the main idle loop
  *
diff -Nurb linux-2.6.22-590/drivers/cpuidle/sysfs.c linux-2.6.22-try2-netns/drivers/cpuidle/sysfs.c
--- linux-2.6.22-590/drivers/cpuidle/sysfs.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/drivers/cpuidle/sysfs.c	2007-12-21 14:25:48.000000000 -0500
@@ -13,6 +13,14 @@
 
 #include "cpuidle.h"
 
+static unsigned int sysfs_switch;
+static int __init cpuidle_sysfs_setup(char *unused)
+{
+	sysfs_switch = 1;
+	return 1;
+}
+__setup("cpuidle_sysfs_switch", cpuidle_sysfs_setup);
+
 static ssize_t show_available_drivers(struct sys_device *dev, char *buf)
 {
 	ssize_t i = 0;
@@ -127,6 +135,15 @@
 	return count;
 }
 
+static SYSDEV_ATTR(current_driver_ro, 0444, show_current_driver, NULL);
+static SYSDEV_ATTR(current_governor_ro, 0444, show_current_governor, NULL);
+
+static struct attribute *cpuclass_default_attrs[] = {
+	&attr_current_driver_ro.attr,
+	&attr_current_governor_ro.attr,
+	NULL
+};
+
 static SYSDEV_ATTR(available_drivers, 0444, show_available_drivers, NULL);
 static SYSDEV_ATTR(available_governors, 0444, show_available_governors, NULL);
 static SYSDEV_ATTR(current_driver, 0644, show_current_driver,
@@ -134,7 +151,7 @@
 static SYSDEV_ATTR(current_governor, 0644, show_current_governor,
 	store_current_governor);
 
-static struct attribute *cpuclass_default_attrs[] = {
+static struct attribute *cpuclass_switch_attrs[] = {
 	&attr_available_drivers.attr,
 	&attr_available_governors.attr,
 	&attr_current_driver.attr,
@@ -152,6 +169,9 @@
  */
 int cpuidle_add_class_sysfs(struct sysdev_class *cls)
 {
+	if (sysfs_switch)
+		cpuclass_attr_group.attrs = cpuclass_switch_attrs;
+
 	return sysfs_create_group(&cls->kset.kobj, &cpuclass_attr_group);
 }
 
@@ -301,7 +321,7 @@
  */
 int cpuidle_add_driver_sysfs(struct cpuidle_device *device)
 {
-	int i, ret;
+	int i, ret = -ENOMEM;
 	struct cpuidle_state_kobj *kobj;
 
 	/* state statistics */
diff -Nurb linux-2.6.22-590/drivers/infiniband/core/addr.c linux-2.6.22-try2-netns/drivers/infiniband/core/addr.c
--- linux-2.6.22-590/drivers/infiniband/core/addr.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/infiniband/core/addr.c	2007-12-19 22:49:13.000000000 -0500
@@ -110,7 +110,7 @@
 	__be32 ip = ((struct sockaddr_in *) addr)->sin_addr.s_addr;
 	int ret;
 
-	dev = ip_dev_find(ip);
+	dev = ip_dev_find(&init_net, ip);
 	if (!dev)
 		return -EADDRNOTAVAIL;
 
@@ -157,6 +157,7 @@
 	u32 dst_ip = dst_in->sin_addr.s_addr;
 
 	memset(&fl, 0, sizeof fl);
+	fl.fl_net = &init_net;
 	fl.nl_u.ip4_u.daddr = dst_ip;
 	if (ip_route_output_key(&rt, &fl))
 		return;
@@ -178,6 +179,7 @@
 	int ret;
 
 	memset(&fl, 0, sizeof fl);
+	fl.fl_net = &init_net;
 	fl.nl_u.ip4_u.daddr = dst_ip;
 	fl.nl_u.ip4_u.saddr = src_ip;
 	ret = ip_route_output_key(&rt, &fl);
@@ -262,7 +264,7 @@
 	__be32 dst_ip = dst_in->sin_addr.s_addr;
 	int ret;
 
-	dev = ip_dev_find(dst_ip);
+	dev = ip_dev_find(&init_net, dst_ip);
 	if (!dev)
 		return -EADDRNOTAVAIL;
 
diff -Nurb linux-2.6.22-590/drivers/infiniband/core/cma.c linux-2.6.22-try2-netns/drivers/infiniband/core/cma.c
--- linux-2.6.22-590/drivers/infiniband/core/cma.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/infiniband/core/cma.c	2007-12-19 22:49:13.000000000 -0500
@@ -1267,7 +1267,7 @@
 	atomic_inc(&conn_id->dev_remove);
 	conn_id->state = CMA_CONNECT;
 
-	dev = ip_dev_find(iw_event->local_addr.sin_addr.s_addr);
+	dev = ip_dev_find(&init_net, iw_event->local_addr.sin_addr.s_addr);
 	if (!dev) {
 		ret = -EADDRNOTAVAIL;
 		cma_enable_remove(conn_id);
@@ -1880,18 +1880,18 @@
 	if (ret)
 		goto err1;
 
-	if (port > sysctl_local_port_range[1]) {
-		if (next_port != sysctl_local_port_range[0]) {
+	if (port > init_net.sysctl_local_port_range[1]) {
+		if (next_port != init_net.sysctl_local_port_range[0]) {
 			idr_remove(ps, port);
-			next_port = sysctl_local_port_range[0];
+			next_port = init_net.sysctl_local_port_range[0];
 			goto retry;
 		}
 		ret = -EADDRNOTAVAIL;
 		goto err2;
 	}
 
-	if (port == sysctl_local_port_range[1])
-		next_port = sysctl_local_port_range[0];
+	if (port == init_net.sysctl_local_port_range[1])
+		next_port = init_net.sysctl_local_port_range[0];
 	else
 		next_port = port + 1;
 
@@ -2774,8 +2774,9 @@
 
 	get_random_bytes(&next_port, sizeof next_port);
 	next_port = ((unsigned int) next_port %
-		    (sysctl_local_port_range[1] - sysctl_local_port_range[0])) +
-		    sysctl_local_port_range[0];
+		     (init_net.sysctl_local_port_range[1] - 
+		      init_net.sysctl_local_port_range[0])) +
+		    init_net.sysctl_local_port_range[0];
 	cma_wq = create_singlethread_workqueue("rdma_cm");
 	if (!cma_wq)
 		return -ENOMEM;
diff -Nurb linux-2.6.22-590/drivers/isdn/divert/divert_procfs.c linux-2.6.22-try2-netns/drivers/isdn/divert/divert_procfs.c
--- linux-2.6.22-590/drivers/isdn/divert/divert_procfs.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/isdn/divert/divert_procfs.c	2007-12-19 22:49:13.000000000 -0500
@@ -17,6 +17,7 @@
 #include <linux/fs.h>
 #endif
 #include <linux/isdnif.h>
+#include <net/net_namespace.h>
 #include "isdn_divert.h"
 
 
@@ -284,12 +285,12 @@
 	init_waitqueue_head(&rd_queue);
 
 #ifdef CONFIG_PROC_FS
-	isdn_proc_entry = proc_mkdir("net/isdn", NULL);
+	isdn_proc_entry = proc_mkdir("isdn", init_net.proc_net);
 	if (!isdn_proc_entry)
 		return (-1);
 	isdn_divert_entry = create_proc_entry("divert", S_IFREG | S_IRUGO, isdn_proc_entry);
 	if (!isdn_divert_entry) {
-		remove_proc_entry("net/isdn", NULL);
+		remove_proc_entry("isdn", init_net.proc_net);
 		return (-1);
 	}
 	isdn_divert_entry->proc_fops = &isdn_fops; 
@@ -309,7 +310,7 @@
 
 #ifdef CONFIG_PROC_FS
 	remove_proc_entry("divert", isdn_proc_entry);
-	remove_proc_entry("net/isdn", NULL);
+	remove_proc_entry("isdn", init_net.proc_net);
 #endif	/* CONFIG_PROC_FS */
 
 	return (0);
diff -Nurb linux-2.6.22-590/drivers/isdn/hardware/eicon/diva_didd.c linux-2.6.22-try2-netns/drivers/isdn/hardware/eicon/diva_didd.c
--- linux-2.6.22-590/drivers/isdn/hardware/eicon/diva_didd.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/isdn/hardware/eicon/diva_didd.c	2007-12-19 22:49:13.000000000 -0500
@@ -15,6 +15,7 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/proc_fs.h>
+#include <net/net_namespace.h>
 
 #include "platform.h"
 #include "di_defs.h"
@@ -86,7 +87,7 @@
 
 static int DIVA_INIT_FUNCTION create_proc(void)
 {
-	proc_net_eicon = proc_mkdir("net/eicon", NULL);
+	proc_net_eicon = proc_mkdir("eicon", init_net.proc_net);
 
 	if (proc_net_eicon) {
 		if ((proc_didd =
@@ -102,7 +103,7 @@
 static void remove_proc(void)
 {
 	remove_proc_entry(DRIVERLNAME, proc_net_eicon);
-	remove_proc_entry("net/eicon", NULL);
+	remove_proc_entry("eicon", init_net.proc_net);
 }
 
 static int DIVA_INIT_FUNCTION divadidd_init(void)
diff -Nurb linux-2.6.22-590/drivers/isdn/hysdn/hysdn_procconf.c linux-2.6.22-try2-netns/drivers/isdn/hysdn/hysdn_procconf.c
--- linux-2.6.22-590/drivers/isdn/hysdn/hysdn_procconf.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/isdn/hysdn/hysdn_procconf.c	2007-12-19 22:49:13.000000000 -0500
@@ -392,7 +392,7 @@
 	hysdn_card *card;
 	unsigned char conf_name[20];
 
-	hysdn_proc_entry = proc_mkdir(PROC_SUBDIR_NAME, proc_net);
+	hysdn_proc_entry = proc_mkdir(PROC_SUBDIR_NAME, init_net.proc_net);
 	if (!hysdn_proc_entry) {
 		printk(KERN_ERR "HYSDN: unable to create hysdn subdir\n");
 		return (-1);
@@ -437,5 +437,5 @@
 		card = card->next;	/* point to next card */
 	}
 
-	remove_proc_entry(PROC_SUBDIR_NAME, proc_net);
+	remove_proc_entry(PROC_SUBDIR_NAME, init_net.proc_net);
 }
diff -Nurb linux-2.6.22-590/drivers/net/Kconfig linux-2.6.22-try2-netns/drivers/net/Kconfig
--- linux-2.6.22-590/drivers/net/Kconfig	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/drivers/net/Kconfig	2007-12-19 22:49:13.000000000 -0500
@@ -119,6 +119,20 @@
 
 	  If you don't know what to use this for, you don't need it.
 
+config ETUN
+	tristate "Ethernet tunnel device driver support"
+	depends on SYSFS
+	---help---
+	  ETUN provices a pair of network devices that can be used for
+	  configuring interesting topolgies.  What one devices transmits
+	  the other receives and vice versa.  The link level framing
+	  is ethernet for wide compatibility with network stacks.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called etun.
+
+	  If you don't know what to use this for, you don't need it.
+
 config NET_SB1000
 	tristate "General Instruments Surfboard 1000"
 	depends on PNP
diff -Nurb linux-2.6.22-590/drivers/net/Makefile linux-2.6.22-try2-netns/drivers/net/Makefile
--- linux-2.6.22-590/drivers/net/Makefile	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/drivers/net/Makefile	2007-12-19 22:49:13.000000000 -0500
@@ -186,6 +186,7 @@
 obj-$(CONFIG_MACMACE) += macmace.o
 obj-$(CONFIG_MAC89x0) += mac89x0.o
 obj-$(CONFIG_TUN) += tun.o
+obj-$(CONFIG_ETUN) += etun.o
 obj-$(CONFIG_NET_NETX) += netx-eth.o
 obj-$(CONFIG_DL2K) += dl2k.o
 obj-$(CONFIG_R8169) += r8169.o
diff -Nurb linux-2.6.22-590/drivers/net/bonding/bond_3ad.c linux-2.6.22-try2-netns/drivers/net/bonding/bond_3ad.c
--- linux-2.6.22-590/drivers/net/bonding/bond_3ad.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/bonding/bond_3ad.c	2007-12-19 22:49:13.000000000 -0500
@@ -29,6 +29,7 @@
 #include <linux/ethtool.h>
 #include <linux/if_bonding.h>
 #include <linux/pkt_sched.h>
+#include <net/net_namespace.h>
 #include "bonding.h"
 #include "bond_3ad.h"
 
@@ -2448,6 +2449,9 @@
 	struct slave *slave = NULL;
 	int ret = NET_RX_DROP;
 
+	if (dev->nd_net != &init_net)
+		goto out;
+
 	if (!(dev->flags & IFF_MASTER))
 		goto out;
 
diff -Nurb linux-2.6.22-590/drivers/net/bonding/bond_alb.c linux-2.6.22-try2-netns/drivers/net/bonding/bond_alb.c
--- linux-2.6.22-590/drivers/net/bonding/bond_alb.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/bonding/bond_alb.c	2007-12-19 22:49:13.000000000 -0500
@@ -345,6 +345,9 @@
 	struct arp_pkt *arp = (struct arp_pkt *)skb->data;
 	int res = NET_RX_DROP;
 
+	if (bond_dev->nd_net != &init_net)
+		goto out;
+
 	if (!(bond_dev->flags & IFF_MASTER))
 		goto out;
 
diff -Nurb linux-2.6.22-590/drivers/net/bonding/bond_main.c linux-2.6.22-try2-netns/drivers/net/bonding/bond_main.c
--- linux-2.6.22-590/drivers/net/bonding/bond_main.c	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/drivers/net/bonding/bond_main.c	2007-12-19 22:49:13.000000000 -0500
@@ -75,6 +75,7 @@
 #include <linux/if_vlan.h>
 #include <linux/if_bonding.h>
 #include <net/route.h>
+#include <net/net_namespace.h>
 #include "bonding.h"
 #include "bond_3ad.h"
 #include "bond_alb.h"
@@ -2376,6 +2377,7 @@
 		 * can tag the ARP with the proper VLAN tag.
 		 */
 		memset(&fl, 0, sizeof(fl));
+		fl.fl_net = &init_net;
 		fl.fl4_dst = targets[i];
 		fl.fl4_tos = RTO_ONLINK;
 
@@ -2485,6 +2487,9 @@
 	unsigned char *arp_ptr;
 	u32 sip, tip;
 
+	if (dev->nd_net != &init_net)
+		goto out;
+
 	if (!(dev->priv_flags & IFF_BONDING) || !(dev->flags & IFF_MASTER))
 		goto out;
 
@@ -3172,7 +3177,7 @@
 {
 	int len = strlen(DRV_NAME);
 
-	for (bond_proc_dir = proc_net->subdir; bond_proc_dir;
+	for (bond_proc_dir = init_net.proc_net->subdir; bond_proc_dir;
 	     bond_proc_dir = bond_proc_dir->next) {
 		if ((bond_proc_dir->namelen == len) &&
 		    !memcmp(bond_proc_dir->name, DRV_NAME, len)) {
@@ -3181,7 +3186,7 @@
 	}
 
 	if (!bond_proc_dir) {
-		bond_proc_dir = proc_mkdir(DRV_NAME, proc_net);
+		bond_proc_dir = proc_mkdir(DRV_NAME, init_net.proc_net);
 		if (bond_proc_dir) {
 			bond_proc_dir->owner = THIS_MODULE;
 		} else {
@@ -3216,7 +3221,7 @@
 			bond_proc_dir->owner = NULL;
 		}
 	} else {
-		remove_proc_entry(DRV_NAME, proc_net);
+		remove_proc_entry(DRV_NAME, init_net.proc_net);
 		bond_proc_dir = NULL;
 	}
 }
@@ -3323,6 +3328,9 @@
 {
 	struct net_device *event_dev = (struct net_device *)ptr;
 
+	if (event_dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	dprintk("event_dev: %s, event: %lx\n",
 		(event_dev ? event_dev->name : "None"),
 		event);
@@ -3740,7 +3748,7 @@
 	}
 
 	down_write(&(bonding_rwsem));
-	slave_dev = dev_get_by_name(ifr->ifr_slave);
+	slave_dev = dev_get_by_name(&init_net, ifr->ifr_slave);
 
 	dprintk("slave_dev=%p: \n", slave_dev);
 
diff -Nurb linux-2.6.22-590/drivers/net/bonding/bond_sysfs.c linux-2.6.22-try2-netns/drivers/net/bonding/bond_sysfs.c
--- linux-2.6.22-590/drivers/net/bonding/bond_sysfs.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/bonding/bond_sysfs.c	2007-12-19 22:49:13.000000000 -0500
@@ -35,6 +35,7 @@
 #include <linux/ctype.h>
 #include <linux/inet.h>
 #include <linux/rtnetlink.h>
+#include <net/net_namespace.h>
 
 /* #define BONDING_DEBUG 1 */
 #include "bonding.h"
@@ -299,7 +300,7 @@
 		read_unlock_bh(&bond->lock);
 		printk(KERN_INFO DRV_NAME ": %s: Adding slave %s.\n",
 		       bond->dev->name, ifname);
-		dev = dev_get_by_name(ifname);
+		dev = dev_get_by_name(&init_net, ifname);
 		if (!dev) {
 			printk(KERN_INFO DRV_NAME
 			       ": %s: Interface %s does not exist!\n",
diff -Nurb linux-2.6.22-590/drivers/net/eql.c linux-2.6.22-try2-netns/drivers/net/eql.c
--- linux-2.6.22-590/drivers/net/eql.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/eql.c	2007-12-19 22:49:13.000000000 -0500
@@ -116,6 +116,7 @@
 #include <linux/init.h>
 #include <linux/timer.h>
 #include <linux/netdevice.h>
+#include <net/net_namespace.h>
 
 #include <linux/if.h>
 #include <linux/if_arp.h>
@@ -412,7 +413,7 @@
 	if (copy_from_user(&srq, srqp, sizeof (slaving_request_t)))
 		return -EFAULT;
 
-	slave_dev  = dev_get_by_name(srq.slave_name);
+	slave_dev  = dev_get_by_name(&init_net, srq.slave_name);
 	if (slave_dev) {
 		if ((master_dev->flags & IFF_UP) == IFF_UP) {
 			/* slave is not a master & not already a slave: */
@@ -460,7 +461,7 @@
 	if (copy_from_user(&srq, srqp, sizeof (slaving_request_t)))
 		return -EFAULT;
 
-	slave_dev = dev_get_by_name(srq.slave_name);
+	slave_dev = dev_get_by_name(&init_net, srq.slave_name);
 	ret = -EINVAL;
 	if (slave_dev) {
 		spin_lock_bh(&eql->queue.lock);
@@ -493,7 +494,7 @@
 	if (copy_from_user(&sc, scp, sizeof (slave_config_t)))
 		return -EFAULT;
 
-	slave_dev = dev_get_by_name(sc.slave_name);
+	slave_dev = dev_get_by_name(&init_net, sc.slave_name);
 	if (!slave_dev)
 		return -ENODEV;
 
@@ -528,7 +529,7 @@
 	if (copy_from_user(&sc, scp, sizeof (slave_config_t)))
 		return -EFAULT;
 
-	slave_dev = dev_get_by_name(sc.slave_name);
+	slave_dev = dev_get_by_name(&init_net, sc.slave_name);
 	if (!slave_dev)
 		return -ENODEV;
 
diff -Nurb linux-2.6.22-590/drivers/net/etun.c linux-2.6.22-try2-netns/drivers/net/etun.c
--- linux-2.6.22-590/drivers/net/etun.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/drivers/net/etun.c	2007-12-19 22:49:13.000000000 -0500
@@ -0,0 +1,489 @@
+/*
+ *  ETUN - Universal ETUN device driver.
+ *  Copyright (C) 2006 Linux Networx
+ *
+ */
+
+#define DRV_NAME	"etun"
+#define DRV_VERSION	"1.0"
+#define DRV_DESCRIPTION	"Ethernet pseudo tunnel device driver"
+#define DRV_COPYRIGHT	"(C) 2007 Linux Networx"
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/rtnetlink.h>
+#include <linux/if.h>
+#include <linux/if_ether.h>
+#include <linux/ctype.h>
+#include <linux/nsproxy.h>
+#include <net/net_namespace.h>
+#include <net/dst.h>
+
+
+/* Device cheksum strategy.
+ *
+ * etun is designed to a be a pair of virutal devices
+ * connecting two network stack instances.
+ *
+ * Typically it will either be used with ethernet bridging or
+ * it will be used to route packets between the two stacks.
+ *
+ * The only checksum offloading I can do is to completely
+ * skip the checksumming step all together.
+ *
+ * When used for ethernet bridging I don't believe any
+ * checksum off loading is safe.
+ * - If my source is an external interface the checksum may be
+ *   invalid so I don't want to report I have already checked it.
+ * - If my destination is an external interface I don't want to put
+ *   a packet on the wire with someone computing the checksum.
+ *
+ * When used for routing between two stacks checksums should
+ * be as unnecessary as they are on the loopback device.
+ *
+ * So by default I am safe and disable checksumming and
+ * other advanced features like SG and TSO.
+ *
+ * However because I think these features could be useful
+ * I provide the ethtool functions to and enable/disable
+ * them at runtime.
+ *
+ * If you think you can correctly enable these go ahead.
+ * For checksums both the transmitter and the receiver must
+ * agree before the are actually disabled.
+ */
+
+#define ETUN_NUM_STATS 1
+static struct {
+	const char string[ETH_GSTRING_LEN];
+} ethtool_stats_keys[ETUN_NUM_STATS] = {
+	{ "partner_ifindex" },
+};
+
+struct etun_info {
+	struct net_device	*rx_dev;
+	unsigned		ip_summed;
+	struct net_device_stats	stats;
+	struct list_head	list;
+	struct net_device	*dev;
+};
+
+/*
+ * I have to hold the rtnl_lock during device delete.
+ * So I use the rtnl_lock to protect my list manipulations
+ * as well.  Crude but simple.
+ */
+static LIST_HEAD(etun_list);
+
+/*
+ * The higher levels take care of making this non-reentrant (it's
+ * called with bh's disabled).
+ */
+static int etun_xmit(struct sk_buff *skb, struct net_device *tx_dev)
+{
+	struct etun_info *tx_info = tx_dev->priv;
+	struct net_device *rx_dev = tx_info->rx_dev;
+	struct etun_info *rx_info = rx_dev->priv;
+
+	tx_info->stats.tx_packets++;
+	tx_info->stats.tx_bytes += skb->len;
+
+	/* Drop the skb state that was needed to get here */
+	skb_orphan(skb);
+	if (skb->dst)
+		skb->dst = dst_pop(skb->dst);	/* Allow for smart routing */
+
+	/* Switch to the receiving device */
+	skb->pkt_type = PACKET_HOST;
+	skb->protocol = eth_type_trans(skb, rx_dev);
+	skb->dev = rx_dev;
+	skb->ip_summed = CHECKSUM_NONE;
+
+	/* If both halves agree no checksum is needed */
+	if (tx_dev->features & NETIF_F_NO_CSUM)
+		skb->ip_summed = rx_info->ip_summed;
+
+	rx_dev->last_rx = jiffies;
+	rx_info->stats.rx_packets++;
+	rx_info->stats.rx_bytes += skb->len;
+	netif_rx(skb);
+
+	return 0;
+}
+
+static struct net_device_stats *etun_get_stats(struct net_device *dev)
+{
+	struct etun_info *info = dev->priv;
+	return &info->stats;
+}
+
+/* ethtool interface */
+static int etun_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	cmd->supported		= 0;
+	cmd->advertising	= 0;
+	cmd->speed		= SPEED_10000; /* Memory is fast! */
+	cmd->duplex		= DUPLEX_FULL;
+	cmd->port		= PORT_TP;
+	cmd->phy_address	= 0;
+	cmd->transceiver	= XCVR_INTERNAL;
+	cmd->autoneg		= AUTONEG_DISABLE;
+	cmd->maxtxpkt		= 0;
+	cmd->maxrxpkt		= 0;
+	return 0;
+}
+
+static void etun_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, DRV_NAME);
+	strcpy(info->version, DRV_VERSION);
+	strcpy(info->fw_version, "N/A");
+}
+
+static void etun_get_strings(struct net_device *dev, u32 stringset, u8 *buf)
+{
+	switch(stringset) {
+	case ETH_SS_STATS:
+		memcpy(buf, &ethtool_stats_keys, sizeof(ethtool_stats_keys));
+		break;
+	case ETH_SS_TEST:
+	default:
+		break;
+	}
+}
+
+static int etun_get_stats_count(struct net_device *dev)
+{
+	return ETUN_NUM_STATS;
+}
+
+static void etun_get_ethtool_stats(struct net_device *dev,
+	struct ethtool_stats *stats, u64 *data)
+{
+	struct etun_info *info = dev->priv;
+
+	data[0] = info->rx_dev->ifindex;
+}
+
+static u32 etun_get_rx_csum(struct net_device *dev)
+{
+	struct etun_info *info = dev->priv;
+	return info->ip_summed == CHECKSUM_UNNECESSARY;
+}
+
+static int etun_set_rx_csum(struct net_device *dev, u32 data)
+{
+	struct etun_info *info = dev->priv;
+
+	info->ip_summed = data ? CHECKSUM_UNNECESSARY : CHECKSUM_NONE;
+
+	return 0;
+}
+
+static u32 etun_get_tx_csum(struct net_device *dev)
+{
+	return (dev->features & NETIF_F_NO_CSUM) != 0;
+}
+
+static int etun_set_tx_csum(struct net_device *dev, u32 data)
+{
+	dev->features &= ~NETIF_F_NO_CSUM;
+	if (data)
+		dev->features |= NETIF_F_NO_CSUM;
+
+	return 0;
+}
+
+static struct ethtool_ops etun_ethtool_ops = {
+	.get_settings		= etun_get_settings,
+	.get_drvinfo		= etun_get_drvinfo,
+	.get_link		= ethtool_op_get_link,
+	.get_rx_csum		= etun_get_rx_csum,
+	.set_rx_csum		= etun_set_rx_csum,
+	.get_tx_csum		= etun_get_tx_csum,
+	.set_tx_csum		= etun_set_tx_csum,
+	.get_sg			= ethtool_op_get_sg,
+	.set_sg			= ethtool_op_set_sg,
+#if 0 /* Does just setting the bit successfuly emulate tso? */
+	.get_tso		= ethtool_op_get_tso,
+	.set_tso		= ethtool_op_set_tso,
+#endif
+	.get_strings		= etun_get_strings,
+	.get_stats_count	= etun_get_stats_count,
+	.get_ethtool_stats	= etun_get_ethtool_stats,
+	.get_perm_addr		= ethtool_op_get_perm_addr,
+};
+
+static int etun_open(struct net_device *tx_dev)
+{
+	struct etun_info *tx_info = tx_dev->priv;
+	struct net_device *rx_dev = tx_info->rx_dev;
+	/* If we attempt to bring up etun in the small window before
+	 * it is connected to it's partner error.
+	 */
+	if (!rx_dev)
+		return -ENOTCONN;
+	if (rx_dev->flags & IFF_UP) {
+		netif_carrier_on(tx_dev);
+		netif_carrier_on(rx_dev);
+	}
+	netif_start_queue(tx_dev);
+	return 0;
+}
+
+static int etun_stop(struct net_device *tx_dev)
+{
+	struct etun_info *tx_info = tx_dev->priv;
+	struct net_device *rx_dev = tx_info->rx_dev;
+	netif_stop_queue(tx_dev);
+	if (netif_carrier_ok(tx_dev)) {
+		netif_carrier_off(tx_dev);
+		netif_carrier_off(rx_dev);
+	}
+	return 0;
+}
+
+static int etun_change_mtu(struct net_device *dev, int new_mtu)
+{
+	/* Don't allow ridiculously small mtus */
+	if (new_mtu < (ETH_ZLEN - ETH_HLEN))
+		return -EINVAL;
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+static void etun_set_multicast_list(struct net_device *dev)
+{
+	/* Nothing sane I can do here */
+	return;
+}
+
+static int etun_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	return -EOPNOTSUPP;
+}
+
+/* Only allow letters and numbers in an etun device name */
+static int is_valid_name(const char *name)
+{
+	const char *ptr;
+	for (ptr = name; *ptr; ptr++) {
+		if (!isalnum(*ptr))
+			return 0;
+	}
+	return 1;
+}
+
+static struct net_device *etun_alloc(struct net *net, const char *name)
+{
+	struct net_device *dev;
+	struct etun_info *info;
+	int err;
+
+	if (!name || !is_valid_name(name))
+		return ERR_PTR(-EINVAL);
+
+	dev = alloc_netdev(sizeof(struct etun_info), name, ether_setup);
+	if (!dev)
+		return ERR_PTR(-ENOMEM);
+
+	info = dev->priv;
+	info->dev = dev;
+	dev->nd_net = net;
+
+	random_ether_addr(dev->dev_addr);
+	dev->tx_queue_len	= 0; /* A queue is silly for a loopback device */
+	dev->hard_start_xmit	= etun_xmit;
+	dev->get_stats		= etun_get_stats;
+	dev->open		= etun_open;
+	dev->stop		= etun_stop;
+	dev->set_multicast_list	= etun_set_multicast_list;
+	dev->do_ioctl		= etun_ioctl;
+	dev->features		= NETIF_F_FRAGLIST
+				  | NETIF_F_HIGHDMA
+				  | NETIF_F_LLTX;
+	dev->flags		= IFF_BROADCAST | IFF_MULTICAST |IFF_PROMISC;
+	dev->ethtool_ops	= &etun_ethtool_ops;
+	dev->destructor		= free_netdev;
+	dev->change_mtu		= etun_change_mtu;
+	err = register_netdev(dev);
+	if (err) {
+		free_netdev(dev);
+		dev = ERR_PTR(err);
+		goto out;
+	}
+	netif_carrier_off(dev);
+out:
+	return dev;
+}
+
+static int etun_alloc_pair(struct net *net, const char *name0, const char *name1)
+{
+	struct net_device *dev0, *dev1;
+	struct etun_info *info0, *info1;
+
+	dev0 = etun_alloc(net, name0);
+	if (IS_ERR(dev0)) {
+		return PTR_ERR(dev0);
+	}
+	info0 = dev0->priv;
+
+	dev1 = etun_alloc(net, name1);
+	if (IS_ERR(dev1)) {
+		unregister_netdev(dev0);
+		return PTR_ERR(dev1);
+	}
+	info1 = dev1->priv;
+
+	dev_hold(dev0);
+	dev_hold(dev1);
+	info0->rx_dev = dev1;
+	info1->rx_dev = dev0;
+
+	/* Only place one member of the pair on the list
+	 * so I don't confuse list_for_each_entry_safe,
+	 * by deleting two list entries at once.
+	 */
+	rtnl_lock();
+	list_add(&info0->list, &etun_list);
+	INIT_LIST_HEAD(&info1->list);
+	rtnl_unlock();
+
+	return 0;
+}
+
+static int etun_unregister_pair(struct net_device *dev0)
+{
+	struct etun_info *info0, *info1;
+	struct net_device *dev1;
+
+	ASSERT_RTNL();
+
+	if (!dev0)
+		return -ENODEV;
+
+	/* Ensure my network devices are not passing packets */
+	dev_close(dev0);
+	info0 = dev0->priv;
+	dev1  = info0->rx_dev;
+	info1 = dev1->priv;
+	dev_close(dev1);
+
+	/* Drop the cross device references */
+	dev_put(dev0);
+	dev_put(dev1);
+
+	/* Remove from the etun list */
+	if (!list_empty(&info0->list))
+		list_del_init(&info0->list);
+	if (!list_empty(&info1->list))
+		list_del_init(&info1->list);
+
+	unregister_netdevice(dev0);
+	unregister_netdevice(dev1);
+	return 0;
+}
+
+static int etun_noget(char *buffer, struct kernel_param *kp)
+{
+	return 0;
+}
+
+static int etun_newif(const char *val, struct kernel_param *kp)
+{
+	char name0[IFNAMSIZ], name1[IFNAMSIZ];
+	const char *mid;
+	int len, len0, len1;
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Avoid frustration by removing trailing whitespace */
+	len = strlen(val);
+	while (isspace(val[len - 1]))
+		len--;
+
+	/* Split the string into 2 names */
+	mid = memchr(val, ',', len);
+	if (!mid)
+		return -EINVAL;
+
+	/* Get the first device name */
+	len0 = mid - val;
+	if (len0 > sizeof(name0) - 1)
+		len = sizeof(name0) - 1;
+	strncpy(name0, val, len0);
+	name0[len0] = '\0';
+
+	/* And the second device name */
+	len1 = len - (len0 + 1);
+	if (len1 > sizeof(name1) - 1)
+		len1 = sizeof(name1) - 1;
+	strncpy(name1, mid + 1, len1);
+	name1[len1] = '\0';
+
+	return etun_alloc_pair(current->nsproxy->net_ns, name0, name1);
+}
+
+static int etun_delif(const char *val, struct kernel_param *kp)
+{
+	char name[IFNAMSIZ];
+	int len;
+	struct net_device *dev;
+	int err;
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Avoid frustration by removing trailing whitespace */
+	len = strlen(val);
+	while (isspace(val[len - 1]))
+		len--;
+
+	/* Get the device name */
+	if (len > sizeof(name) - 1)
+		return -EINVAL;
+	strncpy(name, val, len);
+	name[len] = '\0';
+
+	/* Double check I don't have strange characters in my device name */
+	if (!is_valid_name(name))
+		return -EINVAL;
+
+	rtnl_lock();
+	err = -ENODEV;
+	dev = __dev_get_by_name(current->nsproxy->net_ns, name);
+	err = etun_unregister_pair(dev);
+	rtnl_unlock();
+	return err;
+}
+
+static int __init etun_init(void)
+{
+	printk(KERN_INFO "etun: %s, %s\n", DRV_DESCRIPTION, DRV_VERSION);
+	printk(KERN_INFO "etun: %s\n", DRV_COPYRIGHT);
+
+	return 0;
+}
+
+static void etun_cleanup(void)
+{
+	struct etun_info *info, *tmp;
+	rtnl_lock();
+	list_for_each_entry_safe(info, tmp, &etun_list, list) {
+		etun_unregister_pair(info->dev);
+	}
+	rtnl_unlock();
+}
+
+module_param_call(newif, etun_newif, etun_noget, NULL, S_IWUSR);
+module_param_call(delif, etun_delif, etun_noget, NULL, S_IWUSR);
+module_init(etun_init);
+module_exit(etun_cleanup);
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_AUTHOR("Eric Biederman <ebiederm@xmission.com>");
+MODULE_LICENSE("GPL");
diff -Nurb linux-2.6.22-590/drivers/net/hamradio/bpqether.c linux-2.6.22-try2-netns/drivers/net/hamradio/bpqether.c
--- linux-2.6.22-590/drivers/net/hamradio/bpqether.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/hamradio/bpqether.c	2007-12-19 22:49:13.000000000 -0500
@@ -83,6 +83,7 @@
 
 #include <net/ip.h>
 #include <net/arp.h>
+#include <net/net_namespace.h>
 
 #include <linux/bpqether.h>
 
@@ -172,6 +173,9 @@
 	struct ethhdr *eth;
 	struct bpqdev *bpq;
 
+	if (dev->nd_net != &init_net)
+		goto drop;
+
 	if ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)
 		return NET_RX_DROP;
 
@@ -559,6 +563,9 @@
 {
 	struct net_device *dev = (struct net_device *)ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (!dev_is_ethdev(dev))
 		return NOTIFY_DONE;
 
@@ -594,7 +601,7 @@
 static int __init bpq_init_driver(void)
 {
 #ifdef CONFIG_PROC_FS
-	if (!proc_net_fops_create("bpqether", S_IRUGO, &bpq_info_fops)) {
+	if (!proc_net_fops_create(&init_net, "bpqether", S_IRUGO, &bpq_info_fops)) {
 		printk(KERN_ERR
 			"bpq: cannot create /proc/net/bpqether entry.\n");
 		return -ENOENT;
@@ -618,7 +625,7 @@
 
 	unregister_netdevice_notifier(&bpq_dev_notifier);
 
-	proc_net_remove("bpqether");
+	proc_net_remove(&init_net, "bpqether");
 
 	rtnl_lock();
 	while (!list_empty(&bpq_devices)) {
diff -Nurb linux-2.6.22-590/drivers/net/hamradio/scc.c linux-2.6.22-try2-netns/drivers/net/hamradio/scc.c
--- linux-2.6.22-590/drivers/net/hamradio/scc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/hamradio/scc.c	2007-12-19 22:49:13.000000000 -0500
@@ -174,6 +174,7 @@
 #include <linux/seq_file.h>
 #include <linux/bitops.h>
 
+#include <net/net_namespace.h>
 #include <net/ax25.h>
 
 #include <asm/irq.h>
@@ -2114,7 +2115,7 @@
 	}
 	rtnl_unlock();
 
-	proc_net_fops_create("z8530drv", 0, &scc_net_seq_fops);
+	proc_net_fops_create(&init_net, "z8530drv", 0, &scc_net_seq_fops);
 
 	return 0;
 }
@@ -2169,7 +2170,7 @@
 	if (Vector_Latch)
 		release_region(Vector_Latch, 1);
 
-	proc_net_remove("z8530drv");
+	proc_net_remove(&init_net, "z8530drv");
 }
 
 MODULE_AUTHOR("Joerg Reuter <jreuter@yaina.de>");
diff -Nurb linux-2.6.22-590/drivers/net/hamradio/yam.c linux-2.6.22-try2-netns/drivers/net/hamradio/yam.c
--- linux-2.6.22-590/drivers/net/hamradio/yam.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/hamradio/yam.c	2007-12-19 22:49:13.000000000 -0500
@@ -61,6 +61,7 @@
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
 #include <net/ax25.h>
+#include <net/net_namespace.h>
 
 #include <linux/kernel.h>
 #include <linux/proc_fs.h>
@@ -1142,7 +1143,7 @@
 	yam_timer.expires = jiffies + HZ / 100;
 	add_timer(&yam_timer);
 
-	proc_net_fops_create("yam", S_IRUGO, &yam_info_fops);
+	proc_net_fops_create(&init_net, "yam", S_IRUGO, &yam_info_fops);
 	return 0;
  error:
 	while (--i >= 0) {
@@ -1174,7 +1175,7 @@
 		kfree(p);
 	}
 
-	proc_net_remove("yam");
+	proc_net_remove(&init_net, "yam");
 }
 
 /* --------------------------------------------------------------------- */
diff -Nurb linux-2.6.22-590/drivers/net/ibmveth.c linux-2.6.22-try2-netns/drivers/net/ibmveth.c
--- linux-2.6.22-590/drivers/net/ibmveth.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/drivers/net/ibmveth.c	2007-12-19 22:49:13.000000000 -0500
@@ -47,6 +47,7 @@
 #include <linux/mm.h>
 #include <linux/ethtool.h>
 #include <linux/proc_fs.h>
+#include <net/net_namespace.h>
 #include <asm/semaphore.h>
 #include <asm/hvcall.h>
 #include <asm/atomic.h>
@@ -97,7 +98,7 @@
 static struct kobj_type ktype_veth_pool;
 
 #ifdef CONFIG_PROC_FS
-#define IBMVETH_PROC_DIR "net/ibmveth"
+#define IBMVETH_PROC_DIR "ibmveth"
 static struct proc_dir_entry *ibmveth_proc_dir;
 #endif
 
@@ -1093,7 +1094,7 @@
 #ifdef CONFIG_PROC_FS
 static void ibmveth_proc_register_driver(void)
 {
-	ibmveth_proc_dir = proc_mkdir(IBMVETH_PROC_DIR, NULL);
+	ibmveth_proc_dir = proc_mkdir(IBMVETH_PROC_DIR, init_net.proc_net);
 	if (ibmveth_proc_dir) {
 		SET_MODULE_OWNER(ibmveth_proc_dir);
 	}
@@ -1101,7 +1102,7 @@
 
 static void ibmveth_proc_unregister_driver(void)
 {
-	remove_proc_entry(IBMVETH_PROC_DIR, NULL);
+	remove_proc_entry(IBMVETH_PROC_DIR, init_net.proc_net);
 }
 
 static void *ibmveth_seq_start(struct seq_file *seq, loff_t *pos)
diff -Nurb linux-2.6.22-590/drivers/net/loopback.c linux-2.6.22-try2-netns/drivers/net/loopback.c
--- linux-2.6.22-590/drivers/net/loopback.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/loopback.c	2007-12-19 22:49:13.000000000 -0500
@@ -57,6 +57,7 @@
 #include <linux/ip.h>
 #include <linux/tcp.h>
 #include <linux/percpu.h>
+#include <net/net_namespace.h>
 
 struct pcpu_lstats {
 	unsigned long packets;
@@ -199,39 +200,52 @@
 	.get_rx_csum		= always_on,
 };
 
+static int loopback_net_init(struct net *net)
+{
+	struct net_device *lo = &net->loopback_dev;
 /*
  * The loopback device is special. There is only one instance and
  * it is statically allocated. Don't do this for other devices.
  */
-struct net_device loopback_dev = {
-	.name	 		= "lo",
-	.get_stats		= &get_stats,
-	.mtu			= (16 * 1024) + 20 + 20 + 12,
-	.hard_start_xmit	= loopback_xmit,
-	.hard_header		= eth_header,
-	.hard_header_cache	= eth_header_cache,
-	.header_cache_update	= eth_header_cache_update,
-	.hard_header_len	= ETH_HLEN,	/* 14	*/
-	.addr_len		= ETH_ALEN,	/* 6	*/
-	.tx_queue_len		= 0,
-	.type			= ARPHRD_LOOPBACK,	/* 0x0001*/
-	.rebuild_header		= eth_rebuild_header,
-	.flags			= IFF_LOOPBACK,
-	.features 		= NETIF_F_SG | NETIF_F_FRAGLIST
+	strcpy(lo->name, "lo");
+	lo->get_stats		= &get_stats,
+	lo->mtu			= (16 * 1024) + 20 + 20 + 12,
+	lo->hard_start_xmit	= loopback_xmit,
+	lo->hard_header		= eth_header,
+	lo->hard_header_cache	= eth_header_cache,
+	lo->header_cache_update	= eth_header_cache_update,
+	lo->hard_header_len	= ETH_HLEN,	/* 14	*/
+	lo->addr_len		= ETH_ALEN,	/* 6	*/
+	lo->tx_queue_len	= 0,
+	lo->type		= ARPHRD_LOOPBACK,	/* 0x0001*/
+	lo->rebuild_header	= eth_rebuild_header,
+	lo->flags		= IFF_LOOPBACK,
+	lo->features 		= NETIF_F_SG | NETIF_F_FRAGLIST
 #ifdef LOOPBACK_TSO
 				  | NETIF_F_TSO
 #endif
 				  | NETIF_F_NO_CSUM | NETIF_F_HIGHDMA
-				  | NETIF_F_LLTX,
-	.ethtool_ops		= &loopback_ethtool_ops,
+				  | NETIF_F_LLTX
+				  | NETIF_F_NETNS_LOCAL,
+	lo->ethtool_ops		= &loopback_ethtool_ops,
+	lo->nd_net = net;
+	return register_netdev(lo);
+}
+
+static void loopback_net_exit(struct net *net)
+{
+	unregister_netdev(&net->loopback_dev);
+}
+
+static struct pernet_operations loopback_net_ops = {
+	.init = loopback_net_init,
+	.exit = loopback_net_exit,
 };
 
 /* Setup and register the loopback device. */
 static int __init loopback_init(void)
 {
-	return register_netdev(&loopback_dev);
+	return register_pernet_device(&loopback_net_ops);
 };
 
 module_init(loopback_init);
-
-EXPORT_SYMBOL(loopback_dev);
diff -Nurb linux-2.6.22-590/drivers/net/pppoe.c linux-2.6.22-try2-netns/drivers/net/pppoe.c
--- linux-2.6.22-590/drivers/net/pppoe.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/pppoe.c	2007-12-19 22:49:13.000000000 -0500
@@ -78,6 +78,7 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 
+#include <net/net_namespace.h>
 #include <net/sock.h>
 
 #include <asm/uaccess.h>
@@ -210,7 +211,7 @@
 	struct net_device *dev;
 	int ifindex;
 
-	dev = dev_get_by_name(sp->sa_addr.pppoe.dev);
+	dev = dev_get_by_name(&init_net, sp->sa_addr.pppoe.dev);
 	if(!dev)
 		return NULL;
 	ifindex = dev->ifindex;
@@ -295,6 +296,9 @@
 {
 	struct net_device *dev = (struct net_device *) ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	/* Only look at sockets that are using this specific device. */
 	switch (event) {
 	case NETDEV_CHANGEMTU:
@@ -380,6 +384,9 @@
 	struct pppoe_hdr *ph;
 	struct pppox_sock *po;
 
+	if (dev->nd_net != &init_net)
+		goto drop;
+
 	if (!pskb_may_pull(skb, sizeof(struct pppoe_hdr)))
 		goto drop;
 
@@ -412,6 +419,9 @@
 	struct pppoe_hdr *ph;
 	struct pppox_sock *po;
 
+	if (dev->nd_net != &init_net)
+		goto abort;
+
 	if (!pskb_may_pull(skb, sizeof(struct pppoe_hdr)))
 		goto abort;
 
@@ -471,12 +481,12 @@
  * Initialize a new struct sock.
  *
  **********************************************************************/
-static int pppoe_create(struct socket *sock)
+static int pppoe_create(struct net *net, struct socket *sock)
 {
 	int error = -ENOMEM;
 	struct sock *sk;
 
-	sk = sk_alloc(PF_PPPOX, GFP_KERNEL, &pppoe_sk_proto, 1);
+	sk = sk_alloc(net, PF_PPPOX, GFP_KERNEL, &pppoe_sk_proto, 1);
 	if (!sk)
 		goto out;
 
@@ -588,7 +598,7 @@
 
 	/* Don't re-bind if sid==0 */
 	if (sp->sa_addr.pppoe.sid != 0) {
-		dev = dev_get_by_name(sp->sa_addr.pppoe.dev);
+		dev = dev_get_by_name(&init_net, sp->sa_addr.pppoe.dev);
 
 		error = -ENODEV;
 		if (!dev)
@@ -1064,7 +1074,7 @@
 {
 	struct proc_dir_entry *p;
 
-	p = create_proc_entry("net/pppoe", S_IRUGO, NULL);
+	p = create_proc_entry("pppoe", S_IRUGO, init_net.proc_net);
 	if (!p)
 		return -ENOMEM;
 
@@ -1135,7 +1145,7 @@
 	dev_remove_pack(&pppoes_ptype);
 	dev_remove_pack(&pppoed_ptype);
 	unregister_netdevice_notifier(&pppoe_notifier);
-	remove_proc_entry("net/pppoe", NULL);
+	remove_proc_entry("pppoe", init_net.proc_net);
 	proto_unregister(&pppoe_sk_proto);
 }
 
diff -Nurb linux-2.6.22-590/drivers/net/pppox.c linux-2.6.22-try2-netns/drivers/net/pppox.c
--- linux-2.6.22-590/drivers/net/pppox.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/pppox.c	2007-12-19 22:49:13.000000000 -0500
@@ -107,10 +107,13 @@
 
 EXPORT_SYMBOL(pppox_ioctl);
 
-static int pppox_create(struct socket *sock, int protocol)
+static int pppox_create(struct net *net, struct socket *sock, int protocol)
 {
 	int rc = -EPROTOTYPE;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	if (protocol < 0 || protocol > PX_MAX_PROTO)
 		goto out;
 
@@ -126,7 +129,7 @@
 	    !try_module_get(pppox_protos[protocol]->owner))
 		goto out;
 
-	rc = pppox_protos[protocol]->create(sock);
+	rc = pppox_protos[protocol]->create(net, sock);
 
 	module_put(pppox_protos[protocol]->owner);
 out:
diff -Nurb linux-2.6.22-590/drivers/net/shaper.c linux-2.6.22-try2-netns/drivers/net/shaper.c
--- linux-2.6.22-590/drivers/net/shaper.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/shaper.c	2007-12-19 22:49:13.000000000 -0500
@@ -86,6 +86,7 @@
 
 #include <net/dst.h>
 #include <net/arp.h>
+#include <net/net_namespace.h>
 
 struct shaper_cb {
 	unsigned long	shapeclock;		/* Time it should go out */
@@ -488,7 +489,7 @@
 	{
 		case SHAPER_SET_DEV:
 		{
-			struct net_device *them=__dev_get_by_name(ss->ss_name);
+			struct net_device *them=__dev_get_by_name(&init_net, ss->ss_name);
 			if(them==NULL)
 				return -ENODEV;
 			if(sh->dev)
diff -Nurb linux-2.6.22-590/drivers/net/tokenring/lanstreamer.c linux-2.6.22-try2-netns/drivers/net/tokenring/lanstreamer.c
--- linux-2.6.22-590/drivers/net/tokenring/lanstreamer.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/tokenring/lanstreamer.c	2007-12-19 22:49:13.000000000 -0500
@@ -250,7 +250,7 @@
 #if STREAMER_NETWORK_MONITOR
 #ifdef CONFIG_PROC_FS
 	if (!dev_streamer)
-		create_proc_read_entry("net/streamer_tr", 0, 0,
+		create_proc_read_entry("streamer_tr", 0, init_net.proc_net,
 					streamer_proc_info, NULL); 
 	streamer_priv->next = dev_streamer;
 	dev_streamer = streamer_priv;
@@ -423,7 +423,7 @@
 			}
 		}
 		if (!dev_streamer)
-			remove_proc_entry("net/streamer_tr", NULL);
+			remove_proc_entry("streamer_tr", init_net.proc_net);
 	}
 #endif
 #endif
diff -Nurb linux-2.6.22-590/drivers/net/tokenring/olympic.c linux-2.6.22-try2-netns/drivers/net/tokenring/olympic.c
--- linux-2.6.22-590/drivers/net/tokenring/olympic.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/tokenring/olympic.c	2007-12-19 22:49:13.000000000 -0500
@@ -101,6 +101,7 @@
 #include <linux/bitops.h>
 #include <linux/jiffies.h>
 
+#include <net/net_namespace.h>
 #include <net/checksum.h>
 
 #include <asm/io.h>
@@ -268,9 +269,9 @@
 	printk("Olympic: %s registered as: %s\n",olympic_priv->olympic_card_name,dev->name);
 	if (olympic_priv->olympic_network_monitor) { /* Must go after register_netdev as we need the device name */ 
 		char proc_name[20] ; 
-		strcpy(proc_name,"net/olympic_") ; 
+		strcpy(proc_name,"olympic_") ; 
 		strcat(proc_name,dev->name) ; 
-		create_proc_read_entry(proc_name,0,NULL,olympic_proc_info,(void *)dev) ; 
+		create_proc_read_entry(proc_name,0,init_net.proc_net,olympic_proc_info,(void *)dev) ; 
 		printk("Olympic: Network Monitor information: /proc/%s\n",proc_name); 
 	}
 	return  0 ;
@@ -1752,9 +1753,9 @@
 
 	if (olympic_priv->olympic_network_monitor) { 
 		char proc_name[20] ; 
-		strcpy(proc_name,"net/olympic_") ; 
+		strcpy(proc_name,"olympic_") ; 
 		strcat(proc_name,dev->name) ;
-		remove_proc_entry(proc_name,NULL); 
+		remove_proc_entry(proc_name,init_net.proc_net);
 	}
 	unregister_netdev(dev) ; 
 	iounmap(olympic_priv->olympic_mmio) ; 
diff -Nurb linux-2.6.22-590/drivers/net/tun.c linux-2.6.22-try2-netns/drivers/net/tun.c
--- linux-2.6.22-590/drivers/net/tun.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/drivers/net/tun.c	2007-12-19 22:49:13.000000000 -0500
@@ -62,6 +62,7 @@
 #include <linux/if_ether.h>
 #include <linux/if_tun.h>
 #include <linux/crc32.h>
+#include <net/net_namespace.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -475,7 +476,7 @@
 		     !capable(CAP_NET_ADMIN))
 			return -EPERM;
 	}
-	else if (__dev_get_by_name(ifr->ifr_name))
+	else if (__dev_get_by_name(&init_net, ifr->ifr_name))
 		return -EINVAL;
 	else {
 		char *name;
diff -Nurb linux-2.6.22-590/drivers/net/wan/dlci.c linux-2.6.22-try2-netns/drivers/net/wan/dlci.c
--- linux-2.6.22-590/drivers/net/wan/dlci.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/wan/dlci.c	2007-12-19 22:49:13.000000000 -0500
@@ -361,7 +361,7 @@
 
 
 	/* validate slave device */
-	slave = dev_get_by_name(dlci->devname);
+	slave = dev_get_by_name(&init_net, dlci->devname);
 	if (!slave)
 		return -ENODEV;
 
@@ -427,7 +427,7 @@
 	int			err;
 
 	/* validate slave device */
-	master = __dev_get_by_name(dlci->devname);
+	master = __dev_get_by_name(&init_net, dlci->devname);
 	if (!master)
 		return(-ENODEV);
 
@@ -513,6 +513,9 @@
 {
 	struct net_device *dev = (struct net_device *) ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (event == NETDEV_UNREGISTER) {
 		struct dlci_local *dlp;
 
diff -Nurb linux-2.6.22-590/drivers/net/wan/hdlc.c linux-2.6.22-try2-netns/drivers/net/wan/hdlc.c
--- linux-2.6.22-590/drivers/net/wan/hdlc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/wan/hdlc.c	2007-12-19 22:49:13.000000000 -0500
@@ -36,6 +36,7 @@
 #include <linux/rtnetlink.h>
 #include <linux/notifier.h>
 #include <linux/hdlc.h>
+#include <net/net_namespace.h>
 
 
 static const char* version = "HDLC support module revision 1.21";
@@ -66,6 +67,12 @@
 		    struct packet_type *p, struct net_device *orig_dev)
 {
 	struct hdlc_device_desc *desc = dev_to_desc(dev);
+
+	if (dev->nd_net != &init_net) {
+		kfree_skb(skb);
+		return 0;
+	}
+
 	if (desc->netif_rx)
 		return desc->netif_rx(skb);
 
@@ -102,6 +109,9 @@
 	unsigned long flags;
 	int on;
  
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (dev->get_stats != hdlc_get_stats)
 		return NOTIFY_DONE; /* not an HDLC device */
  
diff -Nurb linux-2.6.22-590/drivers/net/wan/lapbether.c linux-2.6.22-try2-netns/drivers/net/wan/lapbether.c
--- linux-2.6.22-590/drivers/net/wan/lapbether.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/wan/lapbether.c	2007-12-19 22:49:13.000000000 -0500
@@ -91,6 +91,9 @@
 	int len, err;
 	struct lapbethdev *lapbeth;
 
+	if (dev->nd_net != &init_net)
+		goto drop;
+
 	if ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)
 		return NET_RX_DROP;
 
@@ -391,6 +394,9 @@
 	struct lapbethdev *lapbeth;
 	struct net_device *dev = ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (!dev_is_ethdev(dev))
 		return NOTIFY_DONE;
 
diff -Nurb linux-2.6.22-590/drivers/net/wan/sbni.c linux-2.6.22-try2-netns/drivers/net/wan/sbni.c
--- linux-2.6.22-590/drivers/net/wan/sbni.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/wan/sbni.c	2007-12-19 22:49:13.000000000 -0500
@@ -54,6 +54,7 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 
+#include <net/net_namespace.h>
 #include <net/arp.h>
 
 #include <asm/io.h>
@@ -1362,7 +1363,7 @@
 
 		if (copy_from_user( slave_name, ifr->ifr_data, sizeof slave_name ))
 			return -EFAULT;
-		slave_dev = dev_get_by_name( slave_name );
+		slave_dev = dev_get_by_name(&init_net, slave_name );
 		if( !slave_dev  ||  !(slave_dev->flags & IFF_UP) ) {
 			printk( KERN_ERR "%s: trying to enslave non-active "
 				"device %s\n", dev->name, slave_name );
diff -Nurb linux-2.6.22-590/drivers/net/wan/syncppp.c linux-2.6.22-try2-netns/drivers/net/wan/syncppp.c
--- linux-2.6.22-590/drivers/net/wan/syncppp.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/wan/syncppp.c	2007-12-19 22:49:13.000000000 -0500
@@ -51,6 +51,7 @@
 #include <linux/spinlock.h>
 #include <linux/rcupdate.h>
 
+#include <net/net_namespace.h>
 #include <net/syncppp.h>
 
 #include <asm/byteorder.h>
@@ -1445,6 +1446,11 @@
 
 static int sppp_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *p, struct net_device *orig_dev)
 {
+	if (dev->nd_net != &init_net) {
+		kfree_skb(skb);
+		return 0;
+	}
+
 	if ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)
 		return NET_RX_DROP;
 	sppp_input(dev,skb);
diff -Nurb linux-2.6.22-590/drivers/net/wireless/hostap/hostap_main.c linux-2.6.22-try2-netns/drivers/net/wireless/hostap/hostap_main.c
--- linux-2.6.22-590/drivers/net/wireless/hostap/hostap_main.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/wireless/hostap/hostap_main.c	2007-12-19 22:49:13.000000000 -0500
@@ -24,6 +24,7 @@
 #include <linux/rtnetlink.h>
 #include <linux/wireless.h>
 #include <linux/etherdevice.h>
+#include <net/net_namespace.h>
 #include <net/iw_handler.h>
 #include <net/ieee80211.h>
 #include <net/ieee80211_crypt.h>
@@ -1094,8 +1095,8 @@
 
 static int __init hostap_init(void)
 {
-	if (proc_net != NULL) {
-		hostap_proc = proc_mkdir("hostap", proc_net);
+	if (init_net.proc_net != NULL) {
+		hostap_proc = proc_mkdir("hostap", init_net.proc_net);
 		if (!hostap_proc)
 			printk(KERN_WARNING "Failed to mkdir "
 			       "/proc/net/hostap\n");
@@ -1110,7 +1111,7 @@
 {
 	if (hostap_proc != NULL) {
 		hostap_proc = NULL;
-		remove_proc_entry("hostap", proc_net);
+		remove_proc_entry("hostap", init_net.proc_net);
 	}
 }
 
diff -Nurb linux-2.6.22-590/drivers/net/wireless/strip.c linux-2.6.22-try2-netns/drivers/net/wireless/strip.c
--- linux-2.6.22-590/drivers/net/wireless/strip.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/net/wireless/strip.c	2007-12-19 22:49:13.000000000 -0500
@@ -107,6 +107,7 @@
 #include <linux/serialP.h>
 #include <linux/rcupdate.h>
 #include <net/arp.h>
+#include <net/net_namespace.h>
 
 #include <linux/ip.h>
 #include <linux/tcp.h>
@@ -1971,7 +1972,7 @@
 		      sizeof(zero_address))) {
 		struct net_device *dev;
 		read_lock_bh(&dev_base_lock);
-		for_each_netdev(dev) {
+		for_each_netdev(&init_net, dev) {
 			if (dev->type == strip_info->dev->type &&
 			    !memcmp(dev->dev_addr,
 				    &strip_info->true_dev_addr,
@@ -2787,7 +2788,7 @@
 	/*
 	 * Register the status file with /proc
 	 */
-	proc_net_fops_create("strip", S_IFREG | S_IRUGO, &strip_seq_fops);
+	proc_net_fops_create(&init_net, "strip", S_IFREG | S_IRUGO, &strip_seq_fops);
 
 	return status;
 }
@@ -2809,7 +2810,7 @@
 	}
 
 	/* Unregister with the /proc/net file here. */
-	proc_net_remove("strip");
+	proc_net_remove(&init_net, "strip");
 
 	if ((i = tty_unregister_ldisc(N_STRIP)))
 		printk(KERN_ERR "STRIP: can't unregister line discipline (err = %d)\n", i);
diff -Nurb linux-2.6.22-590/drivers/parisc/led.c linux-2.6.22-try2-netns/drivers/parisc/led.c
--- linux-2.6.22-590/drivers/parisc/led.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/parisc/led.c	2007-12-19 22:49:13.000000000 -0500
@@ -359,7 +359,7 @@
 	 * for reading should be OK */
 	read_lock(&dev_base_lock);
 	rcu_read_lock();
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 	    struct net_device_stats *stats;
 	    struct in_device *in_dev = __in_dev_get_rcu(dev);
 	    if (!in_dev || !in_dev->ifa_list)
diff -Nurb linux-2.6.22-590/drivers/s390/net/qeth_main.c linux-2.6.22-try2-netns/drivers/s390/net/qeth_main.c
--- linux-2.6.22-590/drivers/s390/net/qeth_main.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/s390/net/qeth_main.c	2007-12-19 22:49:13.000000000 -0500
@@ -8127,7 +8127,7 @@
 	neigh->parms = neigh_parms_clone(parms);
 	rcu_read_unlock();
 
-	neigh->type = inet_addr_type(*(__be32 *) neigh->primary_key);
+	neigh->type = inet_addr_type(&init_net, *(__be32 *) neigh->primary_key);
 	neigh->nud_state = NUD_NOARP;
 	neigh->ops = arp_direct_ops;
 	neigh->output = neigh->ops->queue_xmit;
diff -Nurb linux-2.6.22-590/drivers/scsi/lpfc/lpfc_init.c linux-2.6.22-try2-netns/drivers/scsi/lpfc/lpfc_init.c
--- linux-2.6.22-590/drivers/scsi/lpfc/lpfc_init.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/drivers/scsi/lpfc/lpfc_init.c	2007-12-21 14:27:08.000000000 -0500
@@ -1570,9 +1570,6 @@
 	if (error)
 		goto out_put_shost;
 
-	if (!shost->shost_classdev.kobj.dentry)
-		goto out_put_shost;
-
 	list_add_tail(&vport->listentry, &phba->port_list);
 	return vport;
 
diff -Nurb linux-2.6.22-590/drivers/scsi/scsi_netlink.c linux-2.6.22-try2-netns/drivers/scsi/scsi_netlink.c
--- linux-2.6.22-590/drivers/scsi/scsi_netlink.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/scsi/scsi_netlink.c	2007-12-19 22:49:13.000000000 -0500
@@ -167,7 +167,7 @@
 		return;
 	}
 
-	scsi_nl_sock = netlink_kernel_create(NETLINK_SCSITRANSPORT,
+	scsi_nl_sock = netlink_kernel_create(&init_net, NETLINK_SCSITRANSPORT,
 				SCSI_NL_GRP_CNT, scsi_nl_rcv, NULL,
 				THIS_MODULE);
 	if (!scsi_nl_sock) {
diff -Nurb linux-2.6.22-590/drivers/scsi/scsi_transport_iscsi.c linux-2.6.22-try2-netns/drivers/scsi/scsi_transport_iscsi.c
--- linux-2.6.22-590/drivers/scsi/scsi_transport_iscsi.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/drivers/scsi/scsi_transport_iscsi.c	2007-12-19 22:49:13.000000000 -0500
@@ -1523,7 +1523,7 @@
 	if (err)
 		goto unregister_conn_class;
 
-	nls = netlink_kernel_create(NETLINK_ISCSI, 1, iscsi_if_rx, NULL,
+	nls = netlink_kernel_create(&init_net, NETLINK_ISCSI, 1, iscsi_if_rx, NULL,
 			THIS_MODULE);
 	if (!nls) {
 		err = -ENOBUFS;
diff -Nurb linux-2.6.22-590/drivers/usb/atm/cxacru.c linux-2.6.22-try2-netns/drivers/usb/atm/cxacru.c
--- linux-2.6.22-590/drivers/usb/atm/cxacru.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/usb/atm/cxacru.c	2007-12-21 14:27:08.000000000 -0500
@@ -171,7 +171,7 @@
 	struct delayed_work poll_work;
 	u32 card_info[CXINF_MAX];
 	struct mutex poll_state_serialize;
-	int poll_state;
+	enum cxacru_poll_state poll_state;
 
 	/* contol handles */
 	struct mutex cm_serialize;
@@ -226,58 +226,48 @@
 
 static ssize_t cxacru_sysfs_showattr_dB(s16 value, char *buf)
 {
-	if (unlikely(value < 0)) {
 		return snprintf(buf, PAGE_SIZE, "%d.%02u\n",
-						value / 100, -value % 100);
-	} else {
-		return snprintf(buf, PAGE_SIZE, "%d.%02u\n",
-						value / 100, value % 100);
-	}
+					value / 100, abs(value) % 100);
 }
 
 static ssize_t cxacru_sysfs_showattr_bool(u32 value, char *buf)
 {
-	switch (value) {
-	case 0: return snprintf(buf, PAGE_SIZE, "no\n");
-	case 1: return snprintf(buf, PAGE_SIZE, "yes\n");
-	default: return 0;
-	}
+	static char *str[] = { "no", "yes" };
+	if (unlikely(value >= ARRAY_SIZE(str)))
+		return snprintf(buf, PAGE_SIZE, "%u\n", value);
+	return snprintf(buf, PAGE_SIZE, "%s\n", str[value]);
 }
 
 static ssize_t cxacru_sysfs_showattr_LINK(u32 value, char *buf)
 {
-	switch (value) {
-	case 1: return snprintf(buf, PAGE_SIZE, "not connected\n");
-	case 2: return snprintf(buf, PAGE_SIZE, "connected\n");
-	case 3: return snprintf(buf, PAGE_SIZE, "lost\n");
-	default: return snprintf(buf, PAGE_SIZE, "unknown (%u)\n", value);
-	}
+	static char *str[] = { NULL, "not connected", "connected", "lost" };
+	if (unlikely(value >= ARRAY_SIZE(str) || str[value] == NULL))
+		return snprintf(buf, PAGE_SIZE, "%u\n", value);
+	return snprintf(buf, PAGE_SIZE, "%s\n", str[value]);
 }
 
 static ssize_t cxacru_sysfs_showattr_LINE(u32 value, char *buf)
 {
-	switch (value) {
-	case 0: return snprintf(buf, PAGE_SIZE, "down\n");
-	case 1: return snprintf(buf, PAGE_SIZE, "attempting to activate\n");
-	case 2: return snprintf(buf, PAGE_SIZE, "training\n");
-	case 3: return snprintf(buf, PAGE_SIZE, "channel analysis\n");
-	case 4: return snprintf(buf, PAGE_SIZE, "exchange\n");
-	case 5: return snprintf(buf, PAGE_SIZE, "up\n");
-	case 6: return snprintf(buf, PAGE_SIZE, "waiting\n");
-	case 7: return snprintf(buf, PAGE_SIZE, "initialising\n");
-	default: return snprintf(buf, PAGE_SIZE, "unknown (%u)\n", value);
-	}
+	static char *str[] = { "down", "attempting to activate",
+		"training", "channel analysis", "exchange", "up",
+		"waiting", "initialising"
+	};
+	if (unlikely(value >= ARRAY_SIZE(str)))
+		return snprintf(buf, PAGE_SIZE, "%u\n", value);
+	return snprintf(buf, PAGE_SIZE, "%s\n", str[value]);
 }
 
 static ssize_t cxacru_sysfs_showattr_MODU(u32 value, char *buf)
 {
-	switch (value) {
-	case 0: return 0;
-	case 1: return snprintf(buf, PAGE_SIZE, "ANSI T1.413\n");
-	case 2: return snprintf(buf, PAGE_SIZE, "ITU-T G.992.1 (G.DMT)\n");
-	case 3: return snprintf(buf, PAGE_SIZE, "ITU-T G.992.2 (G.LITE)\n");
-	default: return snprintf(buf, PAGE_SIZE, "unknown (%u)\n", value);
-	}
+	static char *str[] = {
+			NULL,
+			"ANSI T1.413",
+			"ITU-T G.992.1 (G.DMT)",
+			"ITU-T G.992.2 (G.LITE)"
+	};
+	if (unlikely(value >= ARRAY_SIZE(str) || str[value] == NULL))
+		return snprintf(buf, PAGE_SIZE, "%u\n", value);
+	return snprintf(buf, PAGE_SIZE, "%s\n", str[value]);
 }
 
 /*
@@ -308,11 +298,10 @@
 	struct cxacru_data *instance = usbatm_instance->driver_data;
 	u32 value = instance->card_info[CXINF_LINE_STARTABLE];
 
-	switch (value) {
-	case 0: return snprintf(buf, PAGE_SIZE, "running\n");
-	case 1: return snprintf(buf, PAGE_SIZE, "stopped\n");
-	default: return snprintf(buf, PAGE_SIZE, "unknown (%u)\n", value);
-	}
+	static char *str[] = { "running", "stopped" };
+	if (unlikely(value >= ARRAY_SIZE(str)))
+		return snprintf(buf, PAGE_SIZE, "%u\n", value);
+	return snprintf(buf, PAGE_SIZE, "%s\n", str[value]);
 }
 
 static ssize_t cxacru_sysfs_store_adsl_state(struct device *dev,
diff -Nurb linux-2.6.22-590/drivers/usb/core/config.c linux-2.6.22-try2-netns/drivers/usb/core/config.c
--- linux-2.6.22-590/drivers/usb/core/config.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/usb/core/config.c	2007-12-21 14:27:08.000000000 -0500
@@ -274,6 +274,7 @@
 	struct usb_descriptor_header *header;
 	int len, retval;
 	u8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES];
+	unsigned iad_num = 0;
 
 	memcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE);
 	if (config->desc.bDescriptorType != USB_DT_CONFIG ||
@@ -351,6 +352,20 @@
 				++n;
 			}
 
+		} else if (header->bDescriptorType ==
+				USB_DT_INTERFACE_ASSOCIATION) {
+			if (iad_num == USB_MAXIADS) {
+				dev_warn(ddev, "found more Interface "
+					       "Association Descriptors "
+					       "than allocated for in "
+					       "configuration %d\n", cfgno);
+			} else {
+				config->intf_assoc[iad_num] =
+					(struct usb_interface_assoc_descriptor
+					*)header;
+				iad_num++;
+			}
+
 		} else if (header->bDescriptorType == USB_DT_DEVICE ||
 			    header->bDescriptorType == USB_DT_CONFIG)
 			dev_warn(ddev, "config %d contains an unexpected "
diff -Nurb linux-2.6.22-590/drivers/usb/core/devices.c linux-2.6.22-try2-netns/drivers/usb/core/devices.c
--- linux-2.6.22-590/drivers/usb/core/devices.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/usb/core/devices.c	2007-12-21 14:27:08.000000000 -0500
@@ -102,6 +102,10 @@
 /* C:  #Ifs=dd Cfg#=dd Atr=xx MPwr=dddmA */
   "C:%c #Ifs=%2d Cfg#=%2d Atr=%02x MxPwr=%3dmA\n";
   
+static const char *format_iad =
+/* A:  FirstIf#=dd IfCount=dd Cls=xx(sssss) Sub=xx Prot=xx */
+  "A:  FirstIf#=%2d IfCount=%2d Cls=%02x(%-5s) Sub=%02x Prot=%02x\n";
+
 static const char *format_iface =
 /* I:  If#=dd Alt=dd #EPs=dd Cls=xx(sssss) Sub=xx Prot=xx Driver=xxxx*/
   "I:%c If#=%2d Alt=%2d #EPs=%2d Cls=%02x(%-5s) Sub=%02x Prot=%02x Driver=%s\n";
@@ -146,6 +150,7 @@
 	{USB_CLASS_STILL_IMAGE,		"still"},
 	{USB_CLASS_CSCID,		"scard"},
 	{USB_CLASS_CONTENT_SEC,		"c-sec"},
+	{USB_CLASS_VIDEO,		"video"},
 	{-1,				"unk."}		/* leave as last */
 };
 
@@ -286,6 +291,21 @@
 	return start;
 }
 
+static char *usb_dump_iad_descriptor(char *start, char *end,
+	const struct usb_interface_assoc_descriptor *iad)
+{
+	if (start > end)
+		return start;
+	start += sprintf(start, format_iad,
+			 iad->bFirstInterface,
+			 iad->bInterfaceCount,
+			 iad->bFunctionClass,
+			 class_decode(iad->bFunctionClass),
+			 iad->bFunctionSubClass,
+			 iad->bFunctionProtocol);
+	return start;
+}
+
 /* TBD:
  * 0. TBDs
  * 1. marking active interface altsettings (code lists all, but should mark
@@ -322,6 +342,12 @@
 	if (!config)		/* getting these some in 2.3.7; none in 2.3.6 */
 		return start + sprintf(start, "(null Cfg. desc.)\n");
 	start = usb_dump_config_descriptor(start, end, &config->desc, active);
+	for (i = 0; i < USB_MAXIADS; i++) {
+		if (config->intf_assoc[i] == NULL)
+			break;
+		start = usb_dump_iad_descriptor(start, end,
+					config->intf_assoc[i]);
+	}
 	for (i = 0; i < config->desc.bNumInterfaces; i++) {
 		intfc = config->intf_cache[i];
 		interface = config->interface[i];
diff -Nurb linux-2.6.22-590/drivers/usb/core/message.c linux-2.6.22-try2-netns/drivers/usb/core/message.c
--- linux-2.6.22-590/drivers/usb/core/message.c	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/drivers/usb/core/message.c	2007-12-21 14:27:08.000000000 -0500
@@ -1409,6 +1409,36 @@
 	.uevent =	usb_if_uevent,
 };
 
+static struct usb_interface_assoc_descriptor *find_iad(struct usb_device *dev,
+						       struct usb_host_config *config,
+						       u8 inum)
+{
+	struct usb_interface_assoc_descriptor *retval = NULL;
+	struct usb_interface_assoc_descriptor *intf_assoc;
+	int first_intf;
+	int last_intf;
+	int i;
+
+	for (i = 0; (i < USB_MAXIADS && config->intf_assoc[i]); i++) {
+		intf_assoc = config->intf_assoc[i];
+		if (intf_assoc->bInterfaceCount == 0)
+			continue;
+
+		first_intf = intf_assoc->bFirstInterface;
+		last_intf = first_intf + (intf_assoc->bInterfaceCount - 1);
+		if (inum >= first_intf && inum <= last_intf) {
+			if (!retval)
+				retval = intf_assoc;
+			else
+				dev_err(&dev->dev, "Interface #%d referenced"
+					" by multiple IADs\n", inum);
+		}
+	}
+
+	return retval;
+}
+
+
 /*
  * usb_set_configuration - Makes a particular device setting be current
  * @dev: the device whose configuration is being updated
@@ -1555,6 +1585,7 @@
 		intfc = cp->intf_cache[i];
 		intf->altsetting = intfc->altsetting;
 		intf->num_altsetting = intfc->num_altsetting;
+		intf->intf_assoc = find_iad(dev, cp, i);
 		kref_get(&intfc->ref);
 
 		alt = usb_altnum_to_altsetting(intf, 0);
diff -Nurb linux-2.6.22-590/drivers/usb/core/sysfs.c linux-2.6.22-try2-netns/drivers/usb/core/sysfs.c
--- linux-2.6.22-590/drivers/usb/core/sysfs.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/drivers/usb/core/sysfs.c	2007-12-21 14:27:08.000000000 -0500
@@ -424,6 +424,25 @@
 	sysfs_remove_group(&dev->kobj, &dev_attr_grp);
 }
 
+/* Interface Accociation Descriptor fields */
+#define usb_intf_assoc_attr(field, format_string)			\
+static ssize_t								\
+show_iad_##field (struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
+{									\
+	struct usb_interface *intf = to_usb_interface (dev);		\
+									\
+	return sprintf (buf, format_string,				\
+			intf->intf_assoc->field); 		\
+}									\
+static DEVICE_ATTR(iad_##field, S_IRUGO, show_iad_##field, NULL);
+
+usb_intf_assoc_attr (bFirstInterface, "%02x\n")
+usb_intf_assoc_attr (bInterfaceCount, "%02d\n")
+usb_intf_assoc_attr (bFunctionClass, "%02x\n")
+usb_intf_assoc_attr (bFunctionSubClass, "%02x\n")
+usb_intf_assoc_attr (bFunctionProtocol, "%02x\n")
+
 /* Interface fields */
 #define usb_intf_attr(field, format_string)				\
 static ssize_t								\
@@ -487,6 +506,18 @@
 }
 static DEVICE_ATTR(modalias, S_IRUGO, show_modalias, NULL);
 
+static struct attribute *intf_assoc_attrs[] = {
+	&dev_attr_iad_bFirstInterface.attr,
+	&dev_attr_iad_bInterfaceCount.attr,
+	&dev_attr_iad_bFunctionClass.attr,
+	&dev_attr_iad_bFunctionSubClass.attr,
+	&dev_attr_iad_bFunctionProtocol.attr,
+	NULL,
+};
+static struct attribute_group intf_assoc_attr_grp = {
+	.attrs = intf_assoc_attrs,
+};
+
 static struct attribute *intf_attrs[] = {
 	&dev_attr_bInterfaceNumber.attr,
 	&dev_attr_bAlternateSetting.attr,
@@ -538,6 +569,8 @@
 		alt->string = usb_cache_string(udev, alt->desc.iInterface);
 	if (alt->string)
 		retval = device_create_file(dev, &dev_attr_interface);
+	if (intf->intf_assoc)
+		retval = sysfs_create_group(&dev->kobj, &intf_assoc_attr_grp);
 	usb_create_intf_ep_files(intf, udev);
 	return 0;
 }
@@ -549,4 +582,5 @@
 	usb_remove_intf_ep_files(intf);
 	device_remove_file(dev, &dev_attr_interface);
 	sysfs_remove_group(&dev->kobj, &intf_attr_grp);
+	sysfs_remove_group(&intf->dev.kobj, &intf_assoc_attr_grp);
 }
diff -Nurb linux-2.6.22-590/ed linux-2.6.22-try2-netns/ed
--- linux-2.6.22-590/ed	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/ed	2007-12-20 01:24:51.000000000 -0500
@@ -0,0 +1,6 @@
+vi -o ./fs/proc/proc_misc.c ./fs/proc/proc_misc.c.rej
+vi -o ./fs/proc/array.c ./fs/proc/array.c.rej
+vi -o ./include/linux/sched.h ./include/linux/sched.h.rej
+vi -o ./kernel/time/timekeeping.c ./kernel/time/timekeeping.c.rej
+vi -o ./kernel/timer.c ./kernel/timer.c.rej
+vi -o ./kernel/fork.c ./kernel/fork.c.rej
diff -Nurb linux-2.6.22-590/edit linux-2.6.22-try2-netns/edit
--- linux-2.6.22-590/edit	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/edit	2007-12-19 22:57:06.000000000 -0500
@@ -0,0 +1,19 @@
+vi -o ./fs/proc/root.c ./fs/proc/root.c.rej
+vi -o ./include/linux/nsproxy.h ./include/linux/nsproxy.h.rej
+vi -o ./include/linux/sched.h ./include/linux/sched.h.rej
+vi -o ./include/net/inet_timewait_sock.h ./include/net/inet_timewait_sock.h.rej
+vi -o ./include/net/route.h ./include/net/route.h.rej
+vi -o ./include/net/sock.h ./include/net/sock.h.rej
+vi -o ./kernel/nsproxy.c ./kernel/nsproxy.c.rej
+vi -o ./lib/Makefile ./lib/Makefile.rej
+vi -o ./net/core/dev.c ./net/core/dev.c.rej
+vi -o ./net/core/rtnetlink.c ./net/core/rtnetlink.c.rej
+vi -o ./net/core/sock.c ./net/core/sock.c.rej
+vi -o ./net/ipv4/af_inet.c ./net/ipv4/af_inet.c.rej
+vi -o ./net/ipv4/inet_connection_sock.c ./net/ipv4/inet_connection_sock.c.rej
+vi -o ./net/ipv4/inet_hashtables.c ./net/ipv4/inet_hashtables.c.rej
+vi -o ./net/ipv4/raw.c ./net/ipv4/raw.c.rej
+vi -o ./net/ipv4/tcp_ipv4.c ./net/ipv4/tcp_ipv4.c.rej
+vi -o ./net/ipv4/udp.c ./net/ipv4/udp.c.rej
+vi -o ./net/ipv6/addrconf.c ./net/ipv6/addrconf.c.rej
+vi -o ./net/unix/af_unix.c ./net/unix/af_unix.c.rej
diff -Nurb linux-2.6.22-590/fs/afs/netdevices.c linux-2.6.22-try2-netns/fs/afs/netdevices.c
--- linux-2.6.22-590/fs/afs/netdevices.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/fs/afs/netdevices.c	2007-12-19 22:49:13.000000000 -0500
@@ -8,6 +8,7 @@
 #include <linux/inetdevice.h>
 #include <linux/netdevice.h>
 #include <linux/if_arp.h>
+#include <net/net_namespace.h>
 #include "internal.h"
 
 /*
@@ -23,7 +24,7 @@
 		BUG();
 
 	rtnl_lock();
-	dev = __dev_getfirstbyhwtype(ARPHRD_ETHER);
+	dev = __dev_getfirstbyhwtype(&init_net, ARPHRD_ETHER);
 	if (dev) {
 		memcpy(mac, dev->dev_addr, maclen);
 		ret = 0;
@@ -47,7 +48,7 @@
 	ASSERT(maxbufs > 0);
 
 	rtnl_lock();
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if (dev->type == ARPHRD_LOOPBACK && !wantloopback)
 			continue;
 		idev = __in_dev_get_rtnl(dev);
diff -Nurb linux-2.6.22-590/fs/compat_ioctl.c linux-2.6.22-try2-netns/fs/compat_ioctl.c
--- linux-2.6.22-590/fs/compat_ioctl.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/fs/compat_ioctl.c	2007-12-19 22:49:13.000000000 -0500
@@ -319,22 +319,21 @@
 
 static int dev_ifname32(unsigned int fd, unsigned int cmd, unsigned long arg)
 {
-	struct net_device *dev;
-	struct ifreq32 ifr32;
+	struct ifreq __user *uifr;
 	int err;
 
-	if (copy_from_user(&ifr32, compat_ptr(arg), sizeof(ifr32)))
+	uifr = compat_alloc_user_space(sizeof(struct ifreq));
+	if (copy_in_user(uifr, compat_ptr(arg), sizeof(struct ifreq32)));
 		return -EFAULT;
 
-	dev = dev_get_by_index(ifr32.ifr_ifindex);
-	if (!dev)
-		return -ENODEV;
+	err = sys_ioctl(fd, SIOCGIFNAME, (unsigned long)uifr);
+	if (err)
+		return err;
 
-	strlcpy(ifr32.ifr_name, dev->name, sizeof(ifr32.ifr_name));
-	dev_put(dev);
+	if (copy_in_user(compat_ptr(arg), uifr, sizeof(struct ifreq32)))
+		return -EFAULT;
 	
-	err = copy_to_user(compat_ptr(arg), &ifr32, sizeof(ifr32));
-	return (err ? -EFAULT : 0);
+	return 0;
 }
 
 static int dev_ifconf(unsigned int fd, unsigned int cmd, unsigned long arg)
diff -Nurb linux-2.6.22-590/fs/exec.c linux-2.6.22-try2-netns/fs/exec.c
--- linux-2.6.22-590/fs/exec.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/exec.c	2007-12-20 00:39:13.000000000 -0500
@@ -889,7 +889,7 @@
 
 	if (bprm->e_uid != current->euid || bprm->e_gid != current->egid) {
 		suid_keys(current);
-		current->mm->dumpable = suid_dumpable;
+		set_dumpable(current->mm, suid_dumpable);
 		current->pdeath_signal = 0;
 	} else if (file_permission(bprm->file, MAY_READ) ||
 			(bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP)) {
diff -Nurb linux-2.6.22-590/fs/proc/Makefile linux-2.6.22-try2-netns/fs/proc/Makefile
--- linux-2.6.22-590/fs/proc/Makefile	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/fs/proc/Makefile	2007-12-19 22:49:13.000000000 -0500
@@ -11,6 +11,7 @@
 		proc_tty.o proc_misc.o
 
 proc-$(CONFIG_PROC_SYSCTL)	+= proc_sysctl.o
+proc-$(CONFIG_NET)		+= proc_net.o
 proc-$(CONFIG_PROC_KCORE)	+= kcore.o
 proc-$(CONFIG_PROC_VMCORE)	+= vmcore.o
 proc-$(CONFIG_PROC_DEVICETREE)	+= proc_devtree.o
diff -Nurb linux-2.6.22-590/fs/proc/internal.h linux-2.6.22-try2-netns/fs/proc/internal.h
--- linux-2.6.22-590/fs/proc/internal.h	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/proc/internal.h	2007-12-19 22:49:13.000000000 -0500
@@ -17,6 +17,11 @@
 #else
 static inline void proc_sys_init(void) { }
 #endif
+#ifdef CONFIG_NET
+extern int proc_net_init(void);
+#else
+static inline int proc_net_init(void) { return 0; }
+#endif
 
 struct vmalloc_info {
 	unsigned long	used;
diff -Nurb linux-2.6.22-590/fs/proc/proc_misc.c linux-2.6.22-try2-netns/fs/proc/proc_misc.c
--- linux-2.6.22-590/fs/proc/proc_misc.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/proc/proc_misc.c	2007-12-20 01:23:58.000000000 -0500
@@ -122,6 +122,7 @@
 	cputime_t idletime = cputime_add(init_task.utime, init_task.stime);
 
 	do_posix_clock_monotonic_gettime(&uptime);
+	monotonic_to_bootbased(&uptime);
 	cputime_to_timespec(idletime, &idle);
 	if (vx_flags(VXF_VIRT_UPTIME, 0))
 		vx_vsi_uptime(&uptime, &idle);
diff -Nurb linux-2.6.22-590/fs/proc/proc_net.c linux-2.6.22-try2-netns/fs/proc/proc_net.c
--- linux-2.6.22-590/fs/proc/proc_net.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/proc/proc_net.c	2007-12-19 22:49:13.000000000 -0500
@@ -0,0 +1,154 @@
+/*
+ *  linux/fs/proc/net.c
+ *
+ *  Copyright (C) 2007
+ *
+ *  Author: Eric Biederman <ebiederm@xmission.com>
+ *
+ *  proc net directory handling functions
+ */
+
+#include <asm/uaccess.h>
+
+#include <linux/errno.h>
+#include <linux/time.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/bitops.h>
+#include <linux/smp_lock.h>
+#include <linux/mount.h>
+#include <linux/nsproxy.h>
+#include <net/net_namespace.h>
+
+#include "internal.h"
+
+static struct proc_dir_entry *proc_net_shadow;
+
+static struct dentry *proc_net_shadow_dentry(struct dentry *parent,
+						struct proc_dir_entry *de)
+{
+	struct dentry *shadow = NULL;
+	struct inode *inode;
+	if (!de)
+		goto out;
+	de_get(de);
+	inode = proc_get_inode(parent->d_inode->i_sb, de->low_ino, de);
+	if (!inode)
+		goto out_de_put;
+	shadow = d_alloc_name(parent, de->name);
+	if (!shadow)
+		goto out_iput;
+	shadow->d_op = parent->d_op; /* proc_dentry_operations */
+	d_instantiate(shadow, inode);
+out:
+	return shadow;
+out_iput:
+	iput(inode);
+out_de_put:
+	de_put(de);
+	goto out;
+}
+
+static void *proc_net_follow_link(struct dentry *parent, struct nameidata *nd)
+{
+	struct net *net = current->nsproxy->net_ns;
+	struct dentry *shadow;
+	shadow = proc_net_shadow_dentry(parent, net->proc_net);
+	if (!shadow)
+		return ERR_PTR(-ENOENT);
+
+	dput(nd->dentry);
+	/* My dentry count is 1 and that should be enough as the 
+	 * shadow dentry is thrown away immediately.
+	 */
+	nd->dentry = shadow;
+	return NULL;
+}
+
+static struct dentry *proc_net_lookup(struct inode *dir, struct dentry *dentry,
+				      struct nameidata *nd)
+{
+	struct net *net = current->nsproxy->net_ns;
+	struct dentry *shadow;
+	
+	shadow = proc_net_shadow_dentry(nd->dentry, net->proc_net);
+	if (!shadow)
+		return ERR_PTR(-ENOENT);
+
+	dput(nd->dentry);
+	nd->dentry = shadow;
+	
+	return shadow->d_inode->i_op->lookup(shadow->d_inode, dentry, nd);
+}
+
+static int proc_net_setattr(struct dentry *dentry, struct iattr *iattr)
+{
+	struct net *net = current->nsproxy->net_ns;
+	struct dentry *shadow;
+	int ret;
+
+	shadow = proc_net_shadow_dentry(dentry->d_parent, net->proc_net);
+	if (!shadow)
+		return -ENOENT;
+	ret = shadow->d_inode->i_op->setattr(shadow, iattr);
+	dput(shadow);
+	return ret;
+}
+
+static const struct file_operations proc_net_dir_operations = {
+	.read			= generic_read_dir,
+};
+
+static struct inode_operations proc_net_dir_inode_operations = {
+	.follow_link	= proc_net_follow_link,
+	.lookup		= proc_net_lookup,
+	.setattr	= proc_net_setattr,
+};
+
+
+static int proc_net_ns_init(struct net *net)
+{
+	struct proc_dir_entry *netd, *net_statd;
+
+	netd = proc_mkdir("net", &net->proc_net_root);
+	if (!netd)
+		return -EEXIST;
+
+	net_statd = proc_mkdir("stat", netd);
+	if (!net_statd) {
+		remove_proc_entry("net", &net->proc_net_root);
+		return -EEXIST;
+	}
+
+	netd->data = net;
+	net_statd->data = net;
+	net->proc_net_root.data = net;
+	net->proc_net = netd;
+	net->proc_net_stat = net_statd;
+
+	return 0;
+}
+
+static void proc_net_ns_exit(struct net *net)
+{
+	remove_proc_entry("stat", net->proc_net);
+	remove_proc_entry("net", &net->proc_net_root);
+
+}
+
+struct pernet_operations proc_net_ns_ops = {
+	.init = proc_net_ns_init,
+	.exit = proc_net_ns_exit,
+};
+
+int proc_net_init(void)
+{
+	proc_net_shadow = proc_mkdir("net", NULL);
+	proc_net_shadow->proc_iops = &proc_net_dir_inode_operations;
+	proc_net_shadow->proc_fops = &proc_net_dir_operations;
+
+	return register_pernet_subsys(&proc_net_ns_ops);
+}
diff -Nurb linux-2.6.22-590/fs/proc/root.c linux-2.6.22-try2-netns/fs/proc/root.c
--- linux-2.6.22-590/fs/proc/root.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/proc/root.c	2007-12-19 22:57:39.000000000 -0500
@@ -21,11 +21,11 @@
 
 #include "internal.h"
 
-struct proc_dir_entry *proc_net, *proc_net_stat, *proc_bus, *proc_root_fs, *proc_root_driver;
 struct proc_dir_entry *proc_virtual;
 
 extern void proc_vx_init(void);
 
+struct proc_dir_entry *proc_bus, *proc_root_fs, *proc_root_driver;
 static int proc_get_sb(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
 {
@@ -64,8 +64,8 @@
 		return;
 	}
 	proc_misc_init();
-	proc_net = proc_mkdir("net", NULL);
-	proc_net_stat = proc_mkdir("net/stat", NULL);
+
+	proc_net_init();
 
 #ifdef CONFIG_SYSVIPC
 	proc_mkdir("sysvipc", NULL);
@@ -163,7 +163,5 @@
 EXPORT_SYMBOL(remove_proc_entry);
 EXPORT_SYMBOL(proc_root);
 EXPORT_SYMBOL(proc_root_fs);
-EXPORT_SYMBOL(proc_net);
-EXPORT_SYMBOL(proc_net_stat);
 EXPORT_SYMBOL(proc_bus);
 EXPORT_SYMBOL(proc_root_driver);
diff -Nurb linux-2.6.22-590/fs/splice.c linux-2.6.22-try2-netns/fs/splice.c
--- linux-2.6.22-590/fs/splice.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/splice.c	2007-12-20 00:40:52.000000000 -0500
@@ -959,21 +959,10 @@
 	if (unlikely(ret < 0))
 		return ret;
 
-<<<<<<< HEAD/fs/splice.c
-=======
 	ret = security_file_permission(in, MAY_READ);
 	if (unlikely(ret < 0))
 		return ret;
 
-	isize = i_size_read(in->f_mapping->host);
-	if (unlikely(*ppos >= isize))
-		return 0;
-	
-	left = isize - *ppos;
-	if (unlikely(left < len))
-		len = left;
-
->>>>>>> /fs/splice.c
 	return in->f_op->splice_read(in, ppos, pipe, len, flags);
 }
 
diff -Nurb linux-2.6.22-590/fs/sync.c linux-2.6.22-try2-netns/fs/sync.c
--- linux-2.6.22-590/fs/sync.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/sync.c	2007-12-20 00:41:22.000000000 -0500
@@ -176,11 +176,6 @@
  */
 /* It would be nice if people remember that not all the world's an i386
    when they introduce new system calls */
-asmlinkage long sys_sync_file_range2(int fd, unsigned int flags,
-				     loff_t offset, loff_t nbytes)
-{
- 	return sys_sync_file_range(fd, offset, nbytes, flags);
-}
 
 asmlinkage long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes,
 					unsigned int flags)
diff -Nurb linux-2.6.22-590/fs/sysfs/bin.c linux-2.6.22-try2-netns/fs/sysfs/bin.c
--- linux-2.6.22-590/fs/sysfs/bin.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/sysfs/bin.c	2007-12-21 14:26:07.000000000 -0500
@@ -26,6 +26,12 @@
 	int		mmapped;
 };
 
+struct bin_buffer {
+	struct mutex	mutex;
+	void		*buffer;
+	int		mmapped;
+};
+
 static int
 fill_read(struct dentry *dentry, char *buffer, loff_t off, size_t count)
 {
@@ -248,7 +254,7 @@
 
 void sysfs_remove_bin_file(struct kobject * kobj, struct bin_attribute * attr)
 {
-	if (sysfs_hash_and_remove(kobj->sd, attr->attr.name) < 0) {
+	if (sysfs_hash_and_remove(kobj, kobj->sd, attr->attr.name) < 0) {
 		printk(KERN_ERR "%s: "
 			"bad dentry or inode or no such file: \"%s\"\n",
 			__FUNCTION__, attr->attr.name);
diff -Nurb linux-2.6.22-590/fs/sysfs/dir.c linux-2.6.22-try2-netns/fs/sysfs/dir.c
--- linux-2.6.22-590/fs/sysfs/dir.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/sysfs/dir.c	2007-12-21 14:27:08.000000000 -0500
@@ -14,12 +14,33 @@
 #include <asm/semaphore.h>
 #include "sysfs.h"
 
+static void sysfs_prune_shadow_sd(struct sysfs_dirent *sd);
+
 DEFINE_MUTEX(sysfs_mutex);
 spinlock_t sysfs_assoc_lock = SPIN_LOCK_UNLOCKED;
 
 static spinlock_t sysfs_ino_lock = SPIN_LOCK_UNLOCKED;
 static DEFINE_IDA(sysfs_ino_ida);
 
+static struct sysfs_dirent *find_shadow_sd(struct sysfs_dirent *parent_sd, const void *target)
+{
+	/* Find the shadow directory for the specified tag */
+	struct sysfs_dirent *sd;
+
+	for (sd = parent_sd->s_children; sd; sd = sd->s_sibling) {
+		if (sd->s_name != target)
+			continue;
+		break;
+	}
+	return sd;
+}
+
+static const void *find_shadow_tag(struct kobject *kobj)
+{
+	/* Find the tag the current kobj is cached with */
+	return kobj->sd->s_parent->s_name;
+}
+
 /**
  *	sysfs_link_sibling - link sysfs_dirent into sibling list
  *	@sd: sysfs_dirent of interest
@@ -161,6 +182,146 @@
 }
 
 /**
+ *	sysfs_link_sibling - link sysfs_dirent into sibling list
+ *	@sd: sysfs_dirent of interest
+ *
+ *	Link @sd into its sibling list which starts from
+ *	sd->s_parent->s_children.
+ *
+ *	Locking:
+ *	mutex_lock(sd->s_parent->dentry->d_inode->i_mutex)
+ */
+static void sysfs_link_sibling(struct sysfs_dirent *sd)
+{
+	struct sysfs_dirent *parent_sd = sd->s_parent;
+
+	BUG_ON(sd->s_sibling);
+	sd->s_sibling = parent_sd->s_children;
+	parent_sd->s_children = sd;
+}
+
+/**
+ *	sysfs_unlink_sibling - unlink sysfs_dirent from sibling list
+ *	@sd: sysfs_dirent of interest
+ *
+ *	Unlink @sd from its sibling list which starts from
+ *	sd->s_parent->s_children.
+ *
+ *	Locking:
+ *	mutex_lock(sd->s_parent->dentry->d_inode->i_mutex)
+ */
+static void sysfs_unlink_sibling(struct sysfs_dirent *sd)
+{
+	struct sysfs_dirent **pos;
+
+	for (pos = &sd->s_parent->s_children; *pos; pos = &(*pos)->s_sibling) {
+		if (*pos == sd) {
+			*pos = sd->s_sibling;
+			sd->s_sibling = NULL;
+			break;
+		}
+	}
+}
+
+/**
+ *	sysfs_get_dentry - get dentry for the given sysfs_dirent
+ *	@sd: sysfs_dirent of interest
+ *
+ *	Get dentry for @sd.  Dentry is looked up if currently not
+ *	present.  This function climbs sysfs_dirent tree till it
+ *	reaches a sysfs_dirent with valid dentry attached and descends
+ *	down from there looking up dentry for each step.
+ *
+ *	LOCKING:
+ *	Kernel thread context (may sleep)
+ *
+ *	RETURNS:
+ *	Pointer to found dentry on success, ERR_PTR() value on error.
+ */
+struct dentry *sysfs_get_dentry(struct sysfs_dirent *sd)
+{
+	struct sysfs_dirent *cur;
+	struct dentry *parent_dentry, *dentry;
+	int i, depth;
+
+	/* Find the first parent which has valid s_dentry and get the
+	 * dentry.
+	 */
+	mutex_lock(&sysfs_mutex);
+ restart0:
+	spin_lock(&sysfs_assoc_lock);
+ restart1:
+	spin_lock(&dcache_lock);
+
+	dentry = NULL;
+	depth = 0;
+	cur = sd;
+	while (!cur->s_dentry || !cur->s_dentry->d_inode) {
+		if (cur->s_flags & SYSFS_FLAG_REMOVED) {
+			dentry = ERR_PTR(-ENOENT);
+			depth = 0;
+			break;
+		}
+		cur = cur->s_parent;
+		depth++;
+	}
+	if (!IS_ERR(dentry))
+		dentry = dget_locked(cur->s_dentry);
+
+	spin_unlock(&dcache_lock);
+	spin_unlock(&sysfs_assoc_lock);
+
+	/* from the found dentry, look up depth times */
+	while (depth--) {
+		/* find and get depth'th ancestor */
+		for (cur = sd, i = 0; cur && i < depth; i++)
+			cur = cur->s_parent;
+
+		/* This can happen if tree structure was modified due
+		 * to move/rename.  Restart.
+		 */
+		if (i != depth) {
+			dput(dentry);
+			goto restart0;
+		}
+
+		sysfs_get(cur);
+
+		mutex_unlock(&sysfs_mutex);
+
+		/* look it up */
+		parent_dentry = dentry;
+		dentry = lookup_one_len_kern(cur->s_name, parent_dentry,
+					     strlen(cur->s_name));
+		dput(parent_dentry);
+
+		if (IS_ERR(dentry)) {
+			sysfs_put(cur);
+			return dentry;
+		}
+
+		mutex_lock(&sysfs_mutex);
+		spin_lock(&sysfs_assoc_lock);
+
+		/* This, again, can happen if tree structure has
+		 * changed and we looked up the wrong thing.  Restart.
+		 */
+		if (cur->s_dentry != dentry) {
+			dput(dentry);
+			sysfs_put(cur);
+			goto restart1;
+		}
+
+		spin_unlock(&sysfs_assoc_lock);
+
+		sysfs_put(cur);
+	}
+
+	mutex_unlock(&sysfs_mutex);
+	return dentry;
+}
+
+/**
  *	sysfs_get_active - get an active reference to sysfs_dirent
  *	@sd: sysfs_dirent to get an active reference to
  *
@@ -282,6 +443,94 @@
 	sd->s_sibling = NULL;
 }
 
+/**
+ *	sysfs_get_active - get an active reference to sysfs_dirent
+ *	@sd: sysfs_dirent to get an active reference to
+ *
+ *	Get an active reference of @sd.  This function is noop if @sd
+ *	is NULL.
+ *
+ *	RETURNS:
+ *	Pointer to @sd on success, NULL on failure.
+ */
+struct sysfs_dirent *sysfs_get_active(struct sysfs_dirent *sd)
+{
+	if (sd) {
+		if (unlikely(!down_read_trylock(&sd->s_active)))
+			sd = NULL;
+	}
+	return sd;
+}
+
+/**
+ *	sysfs_put_active - put an active reference to sysfs_dirent
+ *	@sd: sysfs_dirent to put an active reference to
+ *
+ *	Put an active reference to @sd.  This function is noop if @sd
+ *	is NULL.
+ */
+void sysfs_put_active(struct sysfs_dirent *sd)
+{
+	if (sd)
+		up_read(&sd->s_active);
+}
+
+/**
+ *	sysfs_get_active_two - get active references to sysfs_dirent and parent
+ *	@sd: sysfs_dirent of interest
+ *
+ *	Get active reference to @sd and its parent.  Parent's active
+ *	reference is grabbed first.  This function is noop if @sd is
+ *	NULL.
+ *
+ *	RETURNS:
+ *	Pointer to @sd on success, NULL on failure.
+ */
+struct sysfs_dirent *sysfs_get_active_two(struct sysfs_dirent *sd)
+{
+	if (sd) {
+		if (sd->s_parent && unlikely(!sysfs_get_active(sd->s_parent)))
+			return NULL;
+		if (unlikely(!sysfs_get_active(sd))) {
+			sysfs_put_active(sd->s_parent);
+			return NULL;
+		}
+	}
+	return sd;
+}
+
+/**
+ *	sysfs_put_active_two - put active references to sysfs_dirent and parent
+ *	@sd: sysfs_dirent of interest
+ *
+ *	Put active references to @sd and its parent.  This function is
+ *	noop if @sd is NULL.
+ */
+void sysfs_put_active_two(struct sysfs_dirent *sd)
+{
+	if (sd) {
+		sysfs_put_active(sd);
+		sysfs_put_active(sd->s_parent);
+	}
+}
+
+/**
+ *	sysfs_deactivate - deactivate sysfs_dirent
+ *	@sd: sysfs_dirent to deactivate
+ *
+ *	Deny new active references and drain existing ones.  s_active
+ *	will be unlocked when the sysfs_dirent is released.
+ */
+void sysfs_deactivate(struct sysfs_dirent *sd)
+{
+	down_write_nested(&sd->s_active, SYSFS_S_ACTIVE_DEACTIVATE);
+
+	/* s_active will be unlocked by the thread doing the final put
+	 * on @sd.  Lie to lockdep.
+	 */
+	rwsem_release(&sd->s_active.dep_map, 1, _RET_IP_);
+}
+
 static int sysfs_alloc_ino(ino_t *pino)
 {
 	int ino, rc;
@@ -323,6 +572,40 @@
 	if (sysfs_type(sd) & SYSFS_COPY_NAME)
 		kfree(sd->s_name);
 	kfree(sd->s_iattr);
+	if (sysfs_type(sd) != SYSFS_SHADOW_DIR)
+		sysfs_free_ino(sd->s_ino);
+	kmem_cache_free(sysfs_dir_cachep, sd);
+
+	sd = parent_sd;
+	if (sd && atomic_dec_and_test(&sd->s_count))
+		goto repeat;
+}
+
+void release_sysfs_dirent(struct sysfs_dirent * sd)
+{
+	struct sysfs_dirent *parent_sd;
+
+ repeat:
+	parent_sd = sd->s_parent;
+
+	/* If @sd is being released after deletion, s_active is write
+	 * locked.  If @sd is cursor for directory walk or being
+	 * released prematurely, s_active has no reader or writer.
+	 *
+	 * sysfs_deactivate() lies to lockdep that s_active is
+	 * unlocked immediately.  Lie one more time to cover the
+	 * previous lie.
+	 */
+	if (!down_write_trylock(&sd->s_active))
+		rwsem_acquire(&sd->s_active.dep_map,
+			      SYSFS_S_ACTIVE_DEACTIVATE, 0, _RET_IP_);
+	up_write(&sd->s_active);
+
+	if (sd->s_type & SYSFS_KOBJ_LINK)
+		sysfs_put(sd->s_elem.symlink.target_sd);
+	if (sd->s_type & SYSFS_COPY_NAME)
+		kfree(sd->s_name);
+	kfree(sd->s_iattr);
 	sysfs_free_ino(sd->s_ino);
 	kmem_cache_free(sysfs_dir_cachep, sd);
 
@@ -413,6 +696,7 @@
 	sd->s_dentry = dentry;
 	spin_unlock(&sysfs_assoc_lock);
 
+	if (dentry->d_flags & DCACHE_UNHASHED)
 	d_rehash(dentry);
 }
 
@@ -568,6 +852,63 @@
 	spin_unlock(&dcache_lock);
 	spin_unlock(&sysfs_assoc_lock);
 
+	/* dentries for shadowed directories are pinned, unpin */
+	if ((sysfs_type(sd) == SYSFS_SHADOW_DIR) ||
+	    (sd->s_flags & SYSFS_FLAG_SHADOWED))
+		dput(dentry);
+	dput(dentry);
+
+	/* adjust nlink and update timestamp */
+	inode = ilookup(sysfs_sb, sd->s_ino);
+	if (inode) {
+		mutex_lock(&inode->i_mutex);
+
+		inode->i_ctime = CURRENT_TIME;
+		drop_nlink(inode);
+		if (sysfs_type(sd) == SYSFS_DIR)
+			drop_nlink(inode);
+
+		mutex_unlock(&inode->i_mutex);
+		iput(inode);
+	}
+}
+
+/**
+ *	sysfs_drop_dentry - drop dentry for the specified sysfs_dirent
+ *	@sd: target sysfs_dirent
+ *
+ *	Drop dentry for @sd.  @sd must have been unlinked from its
+ *	parent on entry to this function such that it can't be looked
+ *	up anymore.
+ *
+ *	@sd->s_dentry which is protected with sysfs_assoc_lock points
+ *	to the currently associated dentry but we're not holding a
+ *	reference to it and racing with dput().  Grab dcache_lock and
+ *	verify dentry before dropping it.  If @sd->s_dentry is NULL or
+ *	dput() beats us, no need to bother.
+ */
+static void sysfs_drop_dentry(struct sysfs_dirent *sd)
+{
+	struct dentry *dentry = NULL;
+	struct inode *inode;
+
+	/* We're not holding a reference to ->s_dentry dentry but the
+	 * field will stay valid as long as sysfs_assoc_lock is held.
+	 */
+	spin_lock(&sysfs_assoc_lock);
+	spin_lock(&dcache_lock);
+
+	/* drop dentry if it's there and dput() didn't kill it yet */
+	if (sd->s_dentry && sd->s_dentry->d_inode) {
+		dentry = dget_locked(sd->s_dentry);
+		spin_lock(&dentry->d_lock);
+		__d_drop(dentry);
+		spin_unlock(&dentry->d_lock);
+	}
+
+	spin_unlock(&dcache_lock);
+	spin_unlock(&sysfs_assoc_lock);
+
 	/* dentries for shadowed inodes are pinned, unpin */
 	if (dentry && sysfs_is_shadowed_inode(dentry->d_inode))
 		dput(dentry);
@@ -624,6 +965,7 @@
 		acxt->removed = sd->s_sibling;
 		sd->s_sibling = NULL;
 
+		sysfs_prune_shadow_sd(sd->s_parent);
 		sysfs_drop_dentry(sd);
 		sysfs_deactivate(sd);
 		sysfs_put(sd);
@@ -689,6 +1031,7 @@
 	umode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;
 	struct sysfs_addrm_cxt acxt;
 	struct sysfs_dirent *sd;
+	int err;
 
 	/* allocate */
 	sd = sysfs_new_dirent(name, mode, SYSFS_DIR);
@@ -698,17 +1041,24 @@
 
 	/* link in */
 	sysfs_addrm_start(&acxt, parent_sd);
-	if (!sysfs_find_dirent(parent_sd, name)) {
+	err = -ENOENT;
+	if (!sysfs_resolve_for_create(kobj, &acxt.parent_sd))
+		goto addrm_finish;
+
+	err = -EEXIST;
+	if (!sysfs_find_dirent(acxt.parent_sd, name)) {
 		sysfs_add_one(&acxt, sd);
 		sysfs_link_sibling(sd);
+		err = 0;
 			}
+addrm_finish:
 	if (sysfs_addrm_finish(&acxt)) {
 		*p_sd = sd;
 		return 0;
 		}
 
 				sysfs_put(sd);
-	return -EEXIST;
+	return err;
 }
 
 int sysfs_create_subdir(struct kobject *kobj, const char *name,
@@ -720,19 +1070,15 @@
 /**
  *	sysfs_create_dir - create a directory for an object.
  *	@kobj:		object we're creating directory for. 
- *	@shadow_parent:	parent object.
  */
-int sysfs_create_dir(struct kobject *kobj,
-		     struct sysfs_dirent *shadow_parent_sd)
+int sysfs_create_dir(struct kobject * kobj)
 {
 	struct sysfs_dirent *parent_sd, *sd;
 	int error = 0;
 
 	BUG_ON(!kobj);
 
-	if (shadow_parent_sd)
-		parent_sd = shadow_parent_sd;
-	else if (kobj->parent)
+	if (kobj->parent)
 		parent_sd = kobj->parent->sd;
 	else if (sysfs_mount && sysfs_mount->mnt_sb)
 		parent_sd = sysfs_mount->mnt_sb->s_root->d_fsdata;
@@ -756,6 +1102,17 @@
 	return nr + 2;
 }
 
+static int sysfs_count_nlink(struct sysfs_dirent *sd)
+{
+	struct sysfs_dirent *child;
+	int nr = 0;
+
+	for (child = sd->s_children; child; child = child->s_sibling)
+		if (sysfs_type(child) == SYSFS_DIR)
+			nr++;
+	return nr + 2;
+}
+
 static struct dentry * sysfs_lookup(struct inode *dir, struct dentry *dentry,
 				struct nameidata *nd)
 {
@@ -817,18 +1174,56 @@
 	return NULL;
 }
 
+static void *sysfs_shadow_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	struct sysfs_dirent *sd;
+	struct dentry *dest;
+
+	sd = dentry->d_fsdata;
+	dest = NULL;
+	if (sd->s_flags & SYSFS_FLAG_SHADOWED) {
+		const struct shadow_dir_operations *shadow_ops;
+		const void *tag;
+
+		mutex_lock(&sysfs_mutex);
+
+		shadow_ops = dentry->d_inode->i_private;
+		tag = shadow_ops->current_tag();
+
+		sd = find_shadow_sd(sd, tag);
+		if (sd)
+			dest = sd->s_dentry;
+		dget(dest);
+
+		mutex_unlock(&sysfs_mutex);
+	}
+	if (!dest)
+		dest = dget(dentry);
+	dput(nd->dentry);
+	nd->dentry = dest;
+
+	return NULL;
+}
+
+
 const struct inode_operations sysfs_dir_inode_operations = {
 	.lookup		= sysfs_lookup,
 	.setattr	= sysfs_setattr,
+	.follow_link	= sysfs_shadow_follow_link,
 };
 
+static void __remove_dir(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd)
+{
+	sysfs_unlink_sibling(sd);
+	sysfs_remove_one(acxt, sd);
+}
+
 static void remove_dir(struct sysfs_dirent *sd)
 {
 	struct sysfs_addrm_cxt acxt;
 
 	sysfs_addrm_start(&acxt, sd->s_parent);
-	sysfs_unlink_sibling(sd);
-	sysfs_remove_one(&acxt, sd);
+	__remove_dir(&acxt, sd);
 	sysfs_addrm_finish(&acxt);
 }
 
@@ -837,17 +1232,11 @@
 	remove_dir(sd);
 }
 
-
-static void __sysfs_remove_dir(struct sysfs_dirent *dir_sd)
+static void sysfs_empty_dir(struct sysfs_addrm_cxt *acxt,
+			    struct sysfs_dirent *dir_sd)
 {
-	struct sysfs_addrm_cxt acxt;
 	struct sysfs_dirent **pos;
 
-	if (!dir_sd)
-		return;
-
-	pr_debug("sysfs %s: removing dir\n", dir_sd->s_name);
-	sysfs_addrm_start(&acxt, dir_sd);
 	pos = &dir_sd->s_children;
 	while (*pos) {
 		struct sysfs_dirent *sd = *pos;
@@ -855,10 +1244,39 @@
 		if (sysfs_type(sd) && sysfs_type(sd) != SYSFS_DIR) {
 			*pos = sd->s_sibling;
 			sd->s_sibling = NULL;
-			sysfs_remove_one(&acxt, sd);
+			sysfs_remove_one(acxt, sd);
 		} else
 			pos = &(*pos)->s_sibling;
 	}
+}
+
+static void sysfs_remove_shadows(struct sysfs_addrm_cxt * acxt,
+					struct sysfs_dirent *dir_sd)
+{
+	struct sysfs_dirent **pos;
+
+	pos = &dir_sd->s_children;
+	while (*pos) {
+		struct sysfs_dirent *sd = *pos;
+
+		sysfs_empty_dir(acxt, sd);
+		__remove_dir(acxt, sd);
+	}
+}
+
+static void __sysfs_remove_dir(struct sysfs_dirent *dir_sd)
+{
+	struct sysfs_addrm_cxt acxt;
+
+	if (!dir_sd)
+		return;
+
+	pr_debug("sysfs %s: removing dir\n", dir_sd->s_name);
+	sysfs_addrm_start(&acxt, dir_sd);
+	if (sysfs_type(dir_sd) == SYSFS_DIR)
+		sysfs_empty_dir(&acxt, dir_sd);
+	else
+		sysfs_remove_shadows(&acxt, dir_sd);
 	sysfs_addrm_finish(&acxt);
 
 	remove_dir(dir_sd);
@@ -884,89 +1302,77 @@
 	__sysfs_remove_dir(sd);
 }
 
-int sysfs_rename_dir(struct kobject *kobj, struct sysfs_dirent *new_parent_sd,
-		     const char *new_name)
+int sysfs_rename_dir(struct kobject * kobj, const char *new_name)
 {
-	struct sysfs_dirent *sd = kobj->sd;
-	struct dentry *new_parent = NULL;
-	struct dentry *old_dentry = NULL, *new_dentry = NULL;
-	const char *dup_name = NULL;
+	struct dentry *old_dentry, *new_dentry, *parent;
+	struct sysfs_addrm_cxt acxt;
+	struct sysfs_dirent *sd;
+	const char *dup_name;
 	int error;
 
-	/* get dentries */
-	old_dentry = sysfs_get_dentry(sd);
-	if (IS_ERR(old_dentry)) {
-		error = PTR_ERR(old_dentry);
-		goto out_dput;
-	}
+	dup_name = NULL;
+	new_dentry = NULL;
 
-	new_parent = sysfs_get_dentry(new_parent_sd);
-	if (IS_ERR(new_parent)) {
-		error = PTR_ERR(new_parent);
-		goto out_dput;
-	}
+	sd = kobj->sd;
+	sysfs_addrm_start(&acxt, sd->s_parent);
+	error = -ENOENT;
+	if (!sysfs_resolve_for_create(kobj, &acxt.parent_sd))
+		goto addrm_finish;
 
-	/* lock new_parent and get dentry for new name */
-	mutex_lock(&new_parent->d_inode->i_mutex);
+	error = -EEXIST;
+	if (sysfs_find_dirent(acxt.parent_sd, new_name))
+		goto addrm_finish;
 
-	new_dentry = lookup_one_len(new_name, new_parent, strlen(new_name));
+	error = -EINVAL;
+	if ((sd->s_parent == acxt.parent_sd) &&
+	    (strcmp(new_name, sd->s_name) == 0))
+		goto addrm_finish;
+
+	old_dentry = sd->s_dentry;
+	parent = acxt.parent_sd->s_dentry;
+	if (old_dentry) {
+		old_dentry = sd->s_dentry;
+		parent = acxt.parent_sd->s_dentry;
+		new_dentry = lookup_one_len(new_name, parent, strlen(new_name));
 	if (IS_ERR(new_dentry)) {
 		error = PTR_ERR(new_dentry);
-		goto out_unlock;
+			goto addrm_finish;
 	}
 
-	/* By allowing two different directories with the same
-	 * d_parent we allow this routine to move between different
-	 * shadows of the same directory
-		 */
 			error = -EINVAL;
-	if (old_dentry->d_parent->d_inode != new_parent->d_inode ||
-	    new_dentry->d_parent->d_inode != new_parent->d_inode ||
-	    old_dentry == new_dentry)
-		goto out_unlock;
-
-	error = -EEXIST;
-	if (new_dentry->d_inode)
-		goto out_unlock;
+		if (old_dentry == new_dentry)
+			goto addrm_finish;
+	}
 
 	/* rename kobject and sysfs_dirent */
 	error = -ENOMEM;
 	new_name = dup_name = kstrdup(new_name, GFP_KERNEL);
 	if (!new_name)
-		goto out_drop;
+		goto addrm_finish;
 
 			error = kobject_set_name(kobj, "%s", new_name);
 	if (error)
-		goto out_drop;
+		goto addrm_finish;
 
 	dup_name = sd->s_name;
 	sd->s_name = new_name;
 
 	/* move under the new parent */
-				d_add(new_dentry, NULL);
-	d_move(sd->s_dentry, new_dentry);
-
-	mutex_lock(&sysfs_mutex);
-
 	sysfs_unlink_sibling(sd);
-	sysfs_get(new_parent_sd);
+	sysfs_get(acxt.parent_sd);
 	sysfs_put(sd->s_parent);
-	sd->s_parent = new_parent_sd;
+	sd->s_parent = acxt.parent_sd;
 	sysfs_link_sibling(sd);
 
-	mutex_unlock(&sysfs_mutex);
-
+	if (new_dentry) {
+		d_add(new_dentry, NULL);
+		d_move(old_dentry, new_dentry);
+	}
 	error = 0;
-	goto out_unlock;
+addrm_finish:
+	sysfs_addrm_finish(&acxt);
 
- out_drop:
-				d_drop(new_dentry);
- out_unlock:
-	mutex_unlock(&new_parent->d_inode->i_mutex);
- out_dput:
 	kfree(dup_name);
-	dput(new_parent);
-	dput(old_dentry);
 	dput(new_dentry);
 	return error;
 }
@@ -1103,8 +1509,11 @@
 			i++;
 			/* fallthrough */
 		default:
-			mutex_lock(&sysfs_mutex);
+			/* If I am the shadow master return nothing. */
+			if (parent_sd->s_flags & SYSFS_FLAG_SHADOWED)
+				return 0;
 
+			mutex_lock(&sysfs_mutex);
 			pos = &parent_sd->s_children;
 			while (*pos != cursor)
 				pos = &(*pos)->s_sibling;
@@ -1186,125 +1595,192 @@
 	return offset;
 }
 
+const struct file_operations sysfs_dir_operations = {
+	.open		= sysfs_dir_open,
+	.release	= sysfs_dir_close,
+	.llseek		= sysfs_dir_lseek,
+	.read		= generic_read_dir,
+	.readdir	= sysfs_readdir,
+};
 
-/**
- *	sysfs_make_shadowed_dir - Setup so a directory can be shadowed
- *	@kobj:	object we're creating shadow of.
- */
 
-int sysfs_make_shadowed_dir(struct kobject *kobj,
-	void * (*follow_link)(struct dentry *, struct nameidata *))
+static void sysfs_prune_shadow_sd(struct sysfs_dirent *sd)
 {
-	struct dentry *dentry;
-	struct inode *inode;
-	struct inode_operations *i_op;
+	struct sysfs_addrm_cxt acxt;
 
-	/* get dentry for @kobj->sd, dentry of a shadowed dir is pinned */
-	dentry = sysfs_get_dentry(kobj->sd);
-	if (IS_ERR(dentry))
-		return PTR_ERR(dentry);
+	/* If a shadow directory goes empty remove it. */
+	if (sysfs_type(sd) != SYSFS_SHADOW_DIR)
+		return;
 
-	inode = dentry->d_inode;
-	if (inode->i_op != &sysfs_dir_inode_operations) {
-		dput(dentry);
-		return -EINVAL;
-	}
+	if (sd->s_children)
+		return;
 
-	i_op = kmalloc(sizeof(*i_op), GFP_KERNEL);
-	if (!i_op)
-		return -ENOMEM;
+	sysfs_addrm_start(&acxt, sd->s_parent);
 
-	memcpy(i_op, &sysfs_dir_inode_operations, sizeof(*i_op));
-	i_op->follow_link = follow_link;
+	if (sd->s_flags & SYSFS_FLAG_REMOVED)
+		goto addrm_finish;
 
-	/* Locking of inode->i_op?
-	 * Since setting i_op is a single word write and they
-	 * are atomic we should be ok here.
-	 */
-	inode->i_op = i_op;
-	return 0;
-}
+	if (sd->s_children)
+		goto addrm_finish;
 
-/**
- *	sysfs_create_shadow_dir - create a shadow directory for an object.
- *	@kobj:	object we're creating directory for.
- *
- *	sysfs_make_shadowed_dir must already have been called on this
- *	directory.
- */
+	__remove_dir(&acxt, sd);
+addrm_finish:
+	sysfs_addrm_finish(&acxt);
+}
 
-struct sysfs_dirent *sysfs_create_shadow_dir(struct kobject *kobj)
+static struct sysfs_dirent *add_shadow_sd(struct sysfs_dirent *parent_sd, const void *tag)
 {
-	struct sysfs_dirent *parent_sd = kobj->sd->s_parent;
-	struct dentry *dir, *parent, *shadow;
+	struct sysfs_dirent *sd = NULL;
+	struct dentry *dir, *shadow;
 	struct inode *inode;
-	struct sysfs_dirent *sd;
-	struct sysfs_addrm_cxt acxt;
-
-	dir = sysfs_get_dentry(kobj->sd);
-	if (IS_ERR(dir)) {
-		sd = (void *)dir;
-		goto out;
-	}
-	parent = dir->d_parent;
 
+	dir = parent_sd->s_dentry;
 	inode = dir->d_inode;
-	sd = ERR_PTR(-EINVAL);
-	if (!sysfs_is_shadowed_inode(inode))
-		goto out_dput;
 
-	shadow = d_alloc(parent, &dir->d_name);
+	shadow = d_alloc(dir->d_parent, &dir->d_name);
 	if (!shadow)
-		goto nomem;
+		goto out;
+
+	/* Since the shadow directory is reachable make it look
+	 * like it is actually hashed.
+	 */
+	shadow->d_hash.pprev = &shadow->d_hash.next;
+	shadow->d_hash.next = NULL;
+	shadow->d_flags &= ~DCACHE_UNHASHED;
 
-	sd = sysfs_new_dirent("_SHADOW_", inode->i_mode, SYSFS_DIR);
+	sd = sysfs_new_dirent(tag, parent_sd->s_mode, SYSFS_SHADOW_DIR);
 	if (!sd)
-		goto nomem;
-	sd->s_elem.dir.kobj = kobj;
+		goto error;
 
-	sysfs_addrm_start(&acxt, parent_sd);
+	sd->s_elem.dir.kobj = parent_sd->s_elem.dir.kobj;
+	sd->s_parent = sysfs_get(parent_sd);
 
-	/* add but don't link into children list */
-	sysfs_add_one(&acxt, sd);
+	/* Use the inode number of the parent we are shadowing */
+	sysfs_free_ino(sd->s_ino);
+	sd->s_ino = parent_sd->s_ino;
 
-	/* attach and instantiate dentry */
+	inc_nlink(inode);
+	inc_nlink(dir->d_parent->d_inode);
+
+	sysfs_link_sibling(sd);
+	__iget(inode);
+	sysfs_instantiate(shadow, inode);
 	sysfs_attach_dentry(sd, shadow);
-	d_instantiate(shadow, igrab(inode));
-	inc_nlink(inode);	/* tj: synchronization? */
+out:
+	return sd;
+error:
+	dput(shadow);
+	goto out;
+}
 
-	sysfs_addrm_finish(&acxt);
+int sysfs_resolve_for_create(struct kobject *kobj,
+				struct sysfs_dirent **parent_sd)
+{
+	const struct shadow_dir_operations *shadow_ops;
+	struct sysfs_dirent *sd, *shadow_sd;
 
-	dget(shadow);		/* Extra count - pin the dentry in core */
+	sd = *parent_sd;
+	if (sysfs_type(sd) == SYSFS_SHADOW_DIR)
+		sd = sd->s_parent;
+
+	if (sd->s_flags & SYSFS_FLAG_SHADOWED) {
+		const void *tag;
+
+		shadow_ops = sd->s_dentry->d_inode->i_private;
+		tag = shadow_ops->kobject_tag(kobj);
+
+		shadow_sd = find_shadow_sd(sd, tag);
+		if (!shadow_sd)
+			shadow_sd = add_shadow_sd(sd, tag);
+		sd = shadow_sd;
+	}
+	if (sd) {
+		*parent_sd = sd;
+		return 1;
+	}
+	return 0;
+}
 
-	goto out_dput;
+int sysfs_resolve_for_remove(struct kobject *kobj,
+				struct sysfs_dirent **parent_sd)
+{
+	struct sysfs_dirent *sd;
+	/* If dentry is a shadow directory find the shadow that is
+	 * stored under the same tag as kobj.  This allows removal
+	 * of dirents to function properly even if the value of
+	 * kobject_tag() has changed since we initially created
+	 * the dirents assoctated with kobj.
+	 */
 
- nomem:
-	dput(shadow);
-	sd = ERR_PTR(-ENOMEM);
- out_dput:
-	dput(dir);
- out:
-	return sd;
+	sd = *parent_sd;
+	if (sysfs_type(sd) == SYSFS_SHADOW_DIR)
+		sd = sd->s_parent;
+	if (sd->s_flags & SYSFS_FLAG_SHADOWED) {
+		const void *tag;
+
+		tag = find_shadow_tag(kobj);
+		sd = find_shadow_sd(sd, tag);
+	}
+	if (sd) {
+		*parent_sd = sd;
+		return 1;
+	}
+	return 0;
 }
 
 /**
- *	sysfs_remove_shadow_dir - remove an object's directory.
- *	@shadow_sd: sysfs_dirent of shadow directory
+ *	sysfs_enable_shadowing - Automatically create shadows of a directory
+ *	@kobj:	object to automatically shadow
  *
- *	The only thing special about this is that we remove any files in
- *	the directory before we remove the directory, and we've inlined
- *	what used to be sysfs_rmdir() below, instead of calling separately.
+ *	Once shadowing has been enabled on a directory the contents
+ *	of the directory become dependent upon context.
+ *
+ *	shadow_ops->current_tag() returns the context for the current
+ *	process.
+ *
+ *	shadow_ops->kobject_tag() returns the context that a given kobj
+ *	resides in.
+ *
+ *	Using those methods the sysfs code on shadowed directories
+ *	carefully stores the files so that when we lookup files
+ *	we get the proper answer for our context.
+ *
+ *	If the context of a kobject is changed it is expected that
+ *	the kobject will be renamed so the appopriate sysfs data structures
+ *	can be updated.
  */
-
-void sysfs_remove_shadow_dir(struct sysfs_dirent *shadow_sd)
+int sysfs_enable_shadowing(struct kobject *kobj,
+	const struct shadow_dir_operations *shadow_ops)
 {
-	__sysfs_remove_dir(shadow_sd);
+	struct sysfs_dirent *sd;
+	struct dentry *dentry;
+	int err;
+
+	/* Find the dentry for the shadowed directory and
+	 * increase it's count.
+	 */
+	err = -ENOENT;
+	sd = kobj->sd;
+	dentry = sysfs_get_dentry(sd);
+	if (!dentry)
+		goto out;
+
+	mutex_lock(&sysfs_mutex);
+	err = -EINVAL;
+	/* We can only enable shadowing on empty directories
+	 * where shadowing is not already enabled.
+	 */
+	if (!sd->s_children && (sysfs_type(sd) == SYSFS_DIR) &&
+	    !(sd->s_flags & SYSFS_FLAG_REMOVED) &&
+	    !(sd->s_flags & SYSFS_FLAG_SHADOWED)) {
+		sd->s_flags |= SYSFS_FLAG_SHADOWED;
+		dentry->d_inode->i_private = (void *)shadow_ops;
+		err = 0;
+	}
+	mutex_unlock(&sysfs_mutex);
+out:
+	if (err)
+		dput(dentry);
+	return err;
 }
 
-const struct file_operations sysfs_dir_operations = {
-	.open		= sysfs_dir_open,
-	.release	= sysfs_dir_close,
-	.llseek		= sysfs_dir_lseek,
-	.read		= generic_read_dir,
-	.readdir	= sysfs_readdir,
-};
diff -Nurb linux-2.6.22-590/fs/sysfs/file.c linux-2.6.22-try2-netns/fs/sysfs/file.c
--- linux-2.6.22-590/fs/sysfs/file.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/sysfs/file.c	2007-12-21 14:27:04.000000000 -0500
@@ -243,10 +243,13 @@
 	struct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;
 	struct kobject *kobj = attr_sd->s_parent->s_elem.dir.kobj;
 	struct sysfs_buffer * buffer;
+
 	struct sysfs_ops * ops = NULL;
 	int error;
 
-	/* need attr_sd for attr and ops, its parent for kobj */
+
+	/* need attr_sr for attr and ops, its parent for kobj */
+
 	if (!sysfs_get_active_two(attr_sd))
 		return -ENODEV;
 
@@ -266,19 +269,6 @@
 	if (!ops)
 		goto err_out;
 
-	/* make sure we have a collection to add our buffers to */
-	mutex_lock(&inode->i_mutex);
-	if (!(set = inode->i_private)) {
-		if (!(set = inode->i_private = kmalloc(sizeof(struct sysfs_buffer_collection), GFP_KERNEL))) {
-			mutex_unlock(&inode->i_mutex);
-			error = -ENOMEM;
-			goto Done;
-		} else {
-			INIT_LIST_HEAD(&set->associates);
-		}
-	}
-	mutex_unlock(&inode->i_mutex);
-
 	/* File needs write support.
 	 * The inode's perms must say it's ok, 
 	 * and we must have a store method.
@@ -556,7 +546,7 @@
 
 void sysfs_remove_file(struct kobject * kobj, const struct attribute * attr)
 {
-	sysfs_hash_and_remove(kobj->sd, attr->name);
+	sysfs_hash_and_remove(kobj, kobj->sd, attr->name);
 }
 
 
@@ -573,7 +563,7 @@
 
 	dir_sd = sysfs_get_dirent(kobj->sd, group);
 	if (dir_sd) {
-		sysfs_hash_and_remove(dir_sd, attr->name);
+		sysfs_hash_and_remove(kobj, dir_sd, attr->name);
 		sysfs_put(dir_sd);
 	}
 }
diff -Nurb linux-2.6.22-590/fs/sysfs/group.c linux-2.6.22-try2-netns/fs/sysfs/group.c
--- linux-2.6.22-590/fs/sysfs/group.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/sysfs/group.c	2007-12-21 14:26:58.000000000 -0500
@@ -13,21 +13,20 @@
 #include <linux/dcache.h>
 #include <linux/namei.h>
 #include <linux/err.h>
-#include <linux/fs.h>
 #include <asm/semaphore.h>
 #include "sysfs.h"
 
 
-static void remove_files(struct sysfs_dirent *dir_sd,
+static void remove_files(struct kobject *kobj, struct sysfs_dirent *dir_sd,
 			 const struct attribute_group *grp)
 {
 	struct attribute *const* attr;
 
 	for (attr = grp->attrs; *attr; attr++)
-		sysfs_hash_and_remove(dir_sd, (*attr)->name);
+		sysfs_hash_and_remove(kobj, dir_sd, (*attr)->name);
 }
 
-static int create_files(struct sysfs_dirent *dir_sd,
+static int create_files(struct kobject *kobj, struct sysfs_dirent *dir_sd,
 			const struct attribute_group *grp)
 {
 	struct attribute *const* attr;
@@ -36,7 +35,7 @@
 	for (attr = grp->attrs; *attr && !error; attr++)
 		error = sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);
 	if (error)
-		remove_files(dir_sd, grp);
+		remove_files(kobj, dir_sd, grp);
 	return error;
 }
 
@@ -56,7 +55,7 @@
 	} else
 		sd = kobj->sd;
 	sysfs_get(sd);
-	error = create_files(sd, grp);
+	error = create_files(kobj, sd, grp);
 	if (error) {
 		if (grp->name)
 			sysfs_remove_subdir(sd);
@@ -77,7 +76,7 @@
 	} else
 		sd = sysfs_get(dir_sd);
 
-	remove_files(sd, grp);
+	remove_files(kobj, sd, grp);
 	if (grp->name)
 		sysfs_remove_subdir(sd);
 
diff -Nurb linux-2.6.22-590/fs/sysfs/inode.c linux-2.6.22-try2-netns/fs/sysfs/inode.c
--- linux-2.6.22-590/fs/sysfs/inode.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/sysfs/inode.c	2007-12-21 14:27:07.000000000 -0500
@@ -34,16 +34,6 @@
 	.setattr	= sysfs_setattr,
 };
 
-void sysfs_delete_inode(struct inode *inode)
-{
-	/* Free the shadowed directory inode operations */
-	if (sysfs_is_shadowed_inode(inode)) {
-		kfree(inode->i_op);
-		inode->i_op = NULL;
-	}
-	return generic_delete_inode(inode);
-}
-
 int sysfs_setattr(struct dentry * dentry, struct iattr * iattr)
 {
 	struct inode * inode = dentry->d_inode;
@@ -197,29 +187,29 @@
 	d_instantiate(dentry, inode);
 }
 
-int sysfs_hash_and_remove(struct sysfs_dirent *dir_sd, const char *name)
+int sysfs_hash_and_remove(struct kobject *kobj, struct sysfs_dirent *dir_sd, const char *name)
 {
 	struct sysfs_addrm_cxt acxt;
 	struct sysfs_dirent **pos, *sd;
 
-	if (!dir_sd)
-		return -ENOENT;
-
 	sysfs_addrm_start(&acxt, dir_sd);
+	if (!sysfs_resolve_for_remove(kobj, &acxt.parent_sd))
+		goto addrm_finish;
 
-	for (pos = &dir_sd->s_children; *pos; pos = &(*pos)->s_sibling) {
+	for (pos = &acxt.parent_sd->s_children; *pos; pos = &(*pos)->s_sibling) {
 		sd = *pos;
 
 		if (!sysfs_type(sd))
 			continue;
 		if (!strcmp(sd->s_name, name)) {
+			sd->s_flags |= SYSFS_FLAG_REMOVED;
 			*pos = sd->s_sibling;
 			sd->s_sibling = NULL;
 			sysfs_remove_one(&acxt, sd);
 			break;
 		}
 	}
-
+addrm_finish:
 	if (sysfs_addrm_finish(&acxt))
 		return 0;
 	return -ENOENT;
diff -Nurb linux-2.6.22-590/fs/sysfs/mount.c linux-2.6.22-try2-netns/fs/sysfs/mount.c
--- linux-2.6.22-590/fs/sysfs/mount.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/sysfs/mount.c	2007-12-21 14:26:54.000000000 -0500
@@ -19,7 +19,7 @@
 
 static const struct super_operations sysfs_ops = {
 	.statfs		= simple_statfs,
-	.drop_inode	= sysfs_delete_inode,
+	.drop_inode	= generic_delete_inode,
 };
 
 struct sysfs_dirent sysfs_root = {
@@ -60,6 +60,7 @@
 		iput(inode);
 		return -ENOMEM;
 	}
+	sysfs_root.s_dentry = root;
 	root->d_fsdata = &sysfs_root;
 	sb->s_root = root;
 	return 0;
diff -Nurb linux-2.6.22-590/fs/sysfs/symlink.c linux-2.6.22-try2-netns/fs/sysfs/symlink.c
--- linux-2.6.22-590/fs/sysfs/symlink.c	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/sysfs/symlink.c	2007-12-21 14:26:57.000000000 -0500
@@ -15,8 +15,11 @@
 {
 	int depth = 0;
 
-	for (; sd->s_parent; sd = sd->s_parent)
+	for (; sd->s_parent; sd = sd->s_parent) {
+		if (sysfs_type(sd) == SYSFS_SHADOW_DIR)
+			continue;
 		depth++;
+	}
 
 	return depth;
 }
@@ -25,17 +28,24 @@
 {
 	int length = 1;
 
-	for (; sd->s_parent; sd = sd->s_parent)
+	for (; sd->s_parent; sd = sd->s_parent) {
+		if (sysfs_type(sd) == SYSFS_SHADOW_DIR)
+			continue;
 		length += strlen(sd->s_name) + 1;
+	}
 
 	return length;
 }
 
 static void fill_object_path(struct sysfs_dirent *sd, char *buffer, int length)
 {
+	int cur;
 	--length;
 	for (; sd->s_parent; sd = sd->s_parent) {
-		int cur = strlen(sd->s_name);
+		if (sysfs_type(sd) == SYSFS_SHADOW_DIR)
+			continue;
+
+		cur = strlen(sd->s_name);
 
 		/* back up enough to print this bus id with '/' */
 		length -= cur;
@@ -89,12 +99,15 @@
 	sd->s_elem.symlink.target_sd = target_sd;
 
 	sysfs_addrm_start(&acxt, parent_sd);
+	if (!sysfs_resolve_for_create(target, &acxt.parent_sd))
+		goto addrm_finish;
 
-	if (!sysfs_find_dirent(parent_sd, name)) {
+	if (!sysfs_find_dirent(acxt.parent_sd, name)) {
 		sysfs_add_one(&acxt, sd);
 		sysfs_link_sibling(sd);
 	}
 
+addrm_finish:
 	if (sysfs_addrm_finish(&acxt))
 		return 0;
 
@@ -108,6 +121,21 @@
 
 
 /**
+ *	sysfs_delete_link - remove symlink in object's directory.
+ *	@kobj:	object we're acting for.
+ *	@targ:	object we're pointing to.
+ *	@name:	name of the symlink to remove.
+ *
+ *	Unlike sysfs_remove_link sysfs_delete_link has enough information
+ *	to successfully delete symlinks in shadow directories.
+ */
+void sysfs_delete_link(struct kobject *kobj, struct kobject *targ,
+			const char *name)
+{
+	sysfs_hash_and_remove(targ, kobj->sd, name);
+}
+
+/**
  *	sysfs_remove_link - remove symlink in object's directory.
  *	@kobj:	object we're acting for.
  *	@name:	name of the symlink to remove.
@@ -115,7 +143,23 @@
 
 void sysfs_remove_link(struct kobject * kobj, const char * name)
 {
-	sysfs_hash_and_remove(kobj->sd, name);
+	sysfs_hash_and_remove(kobj, kobj->sd, name);
+}
+
+/**
+ *	sysfs_rename_link - rename symlink in object's directory.
+ *	@kobj:	object we're acting for.
+ *	@targ:	object we're pointing to.
+ *	@old:	previous name of the symlink.
+ *	@new:	new name of the symlink.
+ *
+ *	A helper function for the common rename symlink idiom.
+ */
+int sysfs_rename_link(struct kobject *kobj, struct kobject *targ,
+			const char *old, const char *new)
+{
+	sysfs_delete_link(kobj, targ, old);
+	return sysfs_create_link(kobj, targ, new);
 }
 
 static int sysfs_get_target_path(struct sysfs_dirent * parent_sd,
diff -Nurb linux-2.6.22-590/fs/sysfs/sysfs.h linux-2.6.22-try2-netns/fs/sysfs/sysfs.h
--- linux-2.6.22-590/fs/sysfs/sysfs.h	2007-12-21 15:33:54.000000000 -0500
+++ linux-2.6.22-try2-netns/fs/sysfs/sysfs.h	2007-12-21 14:27:01.000000000 -0500
@@ -51,6 +51,17 @@
 	int			cnt;
 };
 
+/*
+ * A sysfs file which deletes another file when written to need to
+ * write lock the s_active of the victim while its s_active is read
+ * locked for the write operation.  Tell lockdep that this is okay.
+ */
+enum sysfs_s_active_class
+{
+	SYSFS_S_ACTIVE_NORMAL,		/* file r/w access, etc - default */
+	SYSFS_S_ACTIVE_DEACTIVATE,	/* file deactivation */
+};
+
 extern struct vfsmount * sysfs_mount;
 extern struct sysfs_dirent sysfs_root;
 extern struct kmem_cache *sysfs_dir_cachep;
@@ -58,6 +69,12 @@
 extern struct dentry *sysfs_get_dentry(struct sysfs_dirent *sd);
 extern void sysfs_link_sibling(struct sysfs_dirent *sd);
 extern void sysfs_unlink_sibling(struct sysfs_dirent *sd);
+
+extern int sysfs_resolve_for_create(struct kobject *kobj,
+				    struct sysfs_dirent **parent_sd);
+extern int sysfs_resolve_for_remove(struct kobject *kobj,
+				    struct sysfs_dirent **parent_sd);
+
 extern struct sysfs_dirent *sysfs_get_active(struct sysfs_dirent *sd);
 extern void sysfs_put_active(struct sysfs_dirent *sd);
 extern struct sysfs_dirent *sysfs_get_active_two(struct sysfs_dirent *sd);
@@ -70,7 +87,6 @@
 			     struct sysfs_dirent *sd);
 extern int sysfs_addrm_finish(struct sysfs_addrm_cxt *acxt);
 
-extern void sysfs_delete_inode(struct inode *inode);
 extern void sysfs_init_inode(struct sysfs_dirent *sd, struct inode *inode);
 extern struct inode * sysfs_get_inode(struct sysfs_dirent *sd);
 extern void sysfs_instantiate(struct dentry *dentry, struct inode *inode);
@@ -85,7 +101,8 @@
 
 extern int sysfs_add_file(struct sysfs_dirent *dir_sd,
 			  const struct attribute *attr, int type);
-extern int sysfs_hash_and_remove(struct sysfs_dirent *dir_sd, const char *name);
+extern int sysfs_hash_and_remove(struct kobject *kobj,
+				 struct sysfs_dirent *dir_sd, const char *name);
 extern struct sysfs_dirent *sysfs_find(struct sysfs_dirent *dir, const char * name);
 
 extern int sysfs_create_subdir(struct kobject *kobj, const char *name,
@@ -122,8 +139,3 @@
 	if (sd && atomic_dec_and_test(&sd->s_count))
 		release_sysfs_dirent(sd);
 }
-
-static inline int sysfs_is_shadowed_inode(struct inode *inode)
-{
-	return S_ISDIR(inode->i_mode) && inode->i_op->follow_link;
-}
diff -Nurb linux-2.6.22-590/include/linux/device.h linux-2.6.22-try2-netns/include/linux/device.h
--- linux-2.6.22-590/include/linux/device.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/device.h	2007-12-19 22:49:13.000000000 -0500
@@ -200,6 +200,8 @@
 
 	int	(*suspend)(struct device *, pm_message_t state);
 	int	(*resume)(struct device *);
+
+	const struct shadow_dir_operations *shadow_ops;
 };
 
 extern int __must_check class_register(struct class *);
diff -Nurb linux-2.6.22-590/include/linux/idr.h linux-2.6.22-try2-netns/include/linux/idr.h
--- linux-2.6.22-590/include/linux/idr.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/linux/idr.h	2007-12-20 01:14:06.000000000 -0500
@@ -83,4 +83,33 @@
 void idr_destroy(struct idr *idp);
 void idr_init(struct idr *idp);
 
+
+/*
+ * IDA - IDR based id allocator, use when translation from id to
+ * pointer isn't necessary.
+ */
+#define IDA_CHUNK_SIZE		128	/* 128 bytes per chunk */
+#define IDA_BITMAP_LONGS	(128 / sizeof(long) - 1)
+#define IDA_BITMAP_BITS		(IDA_BITMAP_LONGS * sizeof(long) * 8)
+
+struct ida_bitmap {
+	long			nr_busy;
+	unsigned long		bitmap[IDA_BITMAP_LONGS];
+};
+
+struct ida {
+	struct idr		idr;
+	struct ida_bitmap	*free_bitmap;
+};
+
+#define IDA_INIT(name)		{ .idr = IDR_INIT(name), .free_bitmap = NULL, }
+#define DEFINE_IDA(name)	struct ida name = IDA_INIT(name)
+
+int ida_pre_get(struct ida *ida, gfp_t gfp_mask);
+int ida_get_new_above(struct ida *ida, int starting_id, int *p_id);
+int ida_get_new(struct ida *ida, int *p_id);
+void ida_remove(struct ida *ida, int id);
+void ida_destroy(struct ida *ida);
+void ida_init(struct ida *ida);
+
 #endif /* __IDR_H__ */
diff -Nurb linux-2.6.22-590/include/linux/if_bridge.h linux-2.6.22-try2-netns/include/linux/if_bridge.h
--- linux-2.6.22-590/include/linux/if_bridge.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/linux/if_bridge.h	2007-12-19 22:49:13.000000000 -0500
@@ -104,7 +104,7 @@
 
 #include <linux/netdevice.h>
 
-extern void brioctl_set(int (*ioctl_hook)(unsigned int, void __user *));
+extern void brioctl_set(int (*ioctl_hook)(struct net *, unsigned int, void __user *));
 extern struct sk_buff *(*br_handle_frame_hook)(struct net_bridge_port *p,
 					       struct sk_buff *skb);
 extern int (*br_should_route_hook)(struct sk_buff **pskb);
diff -Nurb linux-2.6.22-590/include/linux/if_pppox.h linux-2.6.22-try2-netns/include/linux/if_pppox.h
--- linux-2.6.22-590/include/linux/if_pppox.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/linux/if_pppox.h	2007-12-19 22:49:13.000000000 -0500
@@ -160,7 +160,7 @@
 struct module;
 
 struct pppox_proto {
-	int		(*create)(struct socket *sock);
+	int		(*create)(struct net *net, struct socket *sock);
 	int		(*ioctl)(struct socket *sock, unsigned int cmd,
 				 unsigned long arg);
 	struct module	*owner;
diff -Nurb linux-2.6.22-590/include/linux/if_vlan.h linux-2.6.22-try2-netns/include/linux/if_vlan.h
--- linux-2.6.22-590/include/linux/if_vlan.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/if_vlan.h	2007-12-19 22:49:13.000000000 -0500
@@ -62,7 +62,7 @@
 #define VLAN_VID_MASK	0xfff
 
 /* found in socket.c */
-extern void vlan_ioctl_set(int (*hook)(void __user *));
+extern void vlan_ioctl_set(int (*hook)(struct net *, void __user *));
 
 #define VLAN_NAME "vlan"
 
diff -Nurb linux-2.6.22-590/include/linux/inetdevice.h linux-2.6.22-try2-netns/include/linux/inetdevice.h
--- linux-2.6.22-590/include/linux/inetdevice.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/linux/inetdevice.h	2007-12-19 22:49:13.000000000 -0500
@@ -17,8 +17,6 @@
 	DECLARE_BITMAP(state, __NET_IPV4_CONF_MAX - 1);
 };
 
-extern struct ipv4_devconf ipv4_devconf;
-
 struct in_device
 {
 	struct net_device	*dev;
@@ -44,7 +42,7 @@
 };
 
 #define IPV4_DEVCONF(cnf, attr) ((cnf).data[NET_IPV4_CONF_ ## attr - 1])
-#define IPV4_DEVCONF_ALL(attr) IPV4_DEVCONF(ipv4_devconf, attr)
+#define IPV4_DEVCONF_ALL(net, attr) IPV4_DEVCONF(*((net)->ipv4_devconf), attr)
 
 static inline int ipv4_devconf_get(struct in_device *in_dev, int index)
 {
@@ -71,14 +69,14 @@
 	ipv4_devconf_set((in_dev), NET_IPV4_CONF_ ## attr, (val))
 
 #define IN_DEV_ANDCONF(in_dev, attr) \
-	(IPV4_DEVCONF_ALL(attr) && IN_DEV_CONF_GET((in_dev), attr))
+	(IPV4_DEVCONF_ALL((in_dev)->dev->nd_net, attr) && IN_DEV_CONF_GET((in_dev), attr))
 #define IN_DEV_ORCONF(in_dev, attr) \
-	(IPV4_DEVCONF_ALL(attr) || IN_DEV_CONF_GET((in_dev), attr))
+	(IPV4_DEVCONF_ALL((in_dev)->dev->nd_net, attr) || IN_DEV_CONF_GET((in_dev), attr))
 #define IN_DEV_MAXCONF(in_dev, attr) \
-	(max(IPV4_DEVCONF_ALL(attr), IN_DEV_CONF_GET((in_dev), attr)))
+	(max(IPV4_DEVCONF_ALL((in_dev)->dev->nd_net, attr), IN_DEV_CONF_GET((in_dev), attr)))
 
 #define IN_DEV_FORWARD(in_dev)		IN_DEV_CONF_GET((in_dev), FORWARDING)
-#define IN_DEV_MFORWARD(in_dev)		(IPV4_DEVCONF_ALL(MC_FORWARDING) && \
+#define IN_DEV_MFORWARD(in_dev)		(IPV4_DEVCONF_ALL((in_dev)->dev->nd_net, MC_FORWARDING) && \
 					 IPV4_DEVCONF((in_dev)->cnf, \
 						      MC_FORWARDING))
 #define IN_DEV_RPFILTER(in_dev)		IN_DEV_ANDCONF((in_dev), RP_FILTER)
@@ -127,15 +125,15 @@
 extern int register_inetaddr_notifier(struct notifier_block *nb);
 extern int unregister_inetaddr_notifier(struct notifier_block *nb);
 
-extern struct net_device 	*ip_dev_find(__be32 addr);
+extern struct net_device 	*ip_dev_find(struct net *net, __be32 addr);
 extern int		inet_addr_onlink(struct in_device *in_dev, __be32 a, __be32 b);
-extern int		devinet_ioctl(unsigned int cmd, void __user *);
+extern int		devinet_ioctl(struct net *net, unsigned int cmd, void __user *);
 extern void		devinet_init(void);
-extern struct in_device	*inetdev_by_index(int);
+extern struct in_device	*inetdev_by_index(struct net *, int);
 extern __be32		inet_select_addr(const struct net_device *dev, __be32 dst, int scope);
-extern __be32		inet_confirm_addr(const struct net_device *dev, __be32 dst, __be32 local, int scope);
+extern __be32		inet_confirm_addr(struct net *net, const struct net_device *dev, __be32 dst, __be32 local, int scope);
 extern struct in_ifaddr *inet_ifa_byprefix(struct in_device *in_dev, __be32 prefix, __be32 mask);
-extern void		inet_forward_change(void);
+extern void		inet_forward_change(struct net *net);
 
 static __inline__ int inet_ifa_match(__be32 addr, struct in_ifaddr *ifa)
 {
diff -Nurb linux-2.6.22-590/include/linux/init_task.h linux-2.6.22-try2-netns/include/linux/init_task.h
--- linux-2.6.22-590/include/linux/init_task.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/init_task.h	2007-12-19 22:49:13.000000000 -0500
@@ -9,6 +9,7 @@
 #include <linux/ipc.h>
 #include <linux/pid_namespace.h>
 #include <linux/user_namespace.h>
+#include <net/net_namespace.h>
 
 #define INIT_FDTABLE \
 {							\
@@ -78,6 +79,7 @@
 	.nslock		= __SPIN_LOCK_UNLOCKED(nsproxy.nslock),		\
 	.uts_ns		= &init_uts_ns,					\
 	.mnt_ns		= NULL,						\
+	.net_ns		= &init_net,					\
 	INIT_IPC_NS(ipc_ns)						\
 	.user_ns	= &init_user_ns,				\
 }
diff -Nurb linux-2.6.22-590/include/linux/kobject.h linux-2.6.22-try2-netns/include/linux/kobject.h
--- linux-2.6.22-590/include/linux/kobject.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/kobject.h	2007-12-19 22:49:13.000000000 -0500
@@ -71,14 +71,9 @@
 extern void kobject_cleanup(struct kobject *);
 
 extern int __must_check kobject_add(struct kobject *);
-extern int __must_check kobject_shadow_add(struct kobject *kobj,
-					   struct sysfs_dirent *shadow_parent);
 extern void kobject_del(struct kobject *);
 
 extern int __must_check kobject_rename(struct kobject *, const char *new_name);
-extern int __must_check kobject_shadow_rename(struct kobject *kobj,
-					      struct sysfs_dirent *new_parent,
-						const char *new_name);
 extern int __must_check kobject_move(struct kobject *, struct kobject *);
 
 extern int __must_check kobject_register(struct kobject *);
diff -Nurb linux-2.6.22-590/include/linux/mm.h linux-2.6.22-try2-netns/include/linux/mm.h
--- linux-2.6.22-590/include/linux/mm.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/mm.h	2007-12-20 00:51:04.000000000 -0500
@@ -42,6 +42,8 @@
 
 #define nth_page(page,n) pfn_to_page(page_to_pfn((page)) + (n))
 
+#define VM_REVOKED     0x20000000      /* Mapping has been revoked */
+
 /*
  * Linux kernel virtual memory manager primitives.
  * The idea being to have a "virtual" mm in the same way
diff -Nurb linux-2.6.22-590/include/linux/net.h linux-2.6.22-try2-netns/include/linux/net.h
--- linux-2.6.22-590/include/linux/net.h	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/net.h	2007-12-19 22:49:13.000000000 -0500
@@ -23,6 +23,7 @@
 
 struct poll_table_struct;
 struct inode;
+struct net;
 
 #define NPROTO		34		/* should be enough for now..	*/
 
@@ -170,7 +171,7 @@
 
 struct net_proto_family {
 	int		family;
-	int		(*create)(struct socket *sock, int protocol);
+	int		(*create)(struct net *net, struct socket *sock, int protocol);
 	struct module	*owner;
 };
 
diff -Nurb linux-2.6.22-590/include/linux/netdevice.h linux-2.6.22-try2-netns/include/linux/netdevice.h
--- linux-2.6.22-590/include/linux/netdevice.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/netdevice.h	2007-12-19 22:49:13.000000000 -0500
@@ -39,6 +39,7 @@
 #include <linux/percpu.h>
 #include <linux/dmaengine.h>
 
+struct net;
 struct vlan_group;
 struct ethtool_ops;
 struct netpoll_info;
@@ -326,6 +327,7 @@
 #define NETIF_F_VLAN_CHALLENGED	1024	/* Device cannot handle VLAN packets */
 #define NETIF_F_GSO		2048	/* Enable software GSO. */
 #define NETIF_F_LLTX		4096	/* LockLess TX */
+#define NETIF_F_NETNS_LOCAL	8192	/* Does not change network namespaces */
 
 	/* Segmentation offload features */
 #define NETIF_F_GSO_SHIFT	16
@@ -537,6 +539,9 @@
 	void                    (*poll_controller)(struct net_device *dev);
 #endif
 
+	/* Network namespace this network device is inside */
+	struct net		*nd_net;
+
 	/* bridge stuff */
 	struct net_bridge_port	*br_port;
 
@@ -583,45 +588,48 @@
 #include <linux/interrupt.h>
 #include <linux/notifier.h>
 
-extern struct net_device		loopback_dev;		/* The loopback */
-extern struct list_head			dev_base_head;		/* All devices */
 extern rwlock_t				dev_base_lock;		/* Device list lock */
 
-#define for_each_netdev(d)		\
-		list_for_each_entry(d, &dev_base_head, dev_list)
-#define for_each_netdev_safe(d, n)	\
-		list_for_each_entry_safe(d, n, &dev_base_head, dev_list)
-#define for_each_netdev_continue(d)		\
-		list_for_each_entry_continue(d, &dev_base_head, dev_list)
-#define net_device_entry(lh)	list_entry(lh, struct net_device, dev_list)
-
-static inline struct net_device *next_net_device(struct net_device *dev)
-{
-	struct list_head *lh;
 
-	lh = dev->dev_list.next;
-	return lh == &dev_base_head ? NULL : net_device_entry(lh);
-}
+#define for_each_netdev(net, d)		\
+		list_for_each_entry(d, &(net)->dev_base_head, dev_list)
+#define for_each_netdev_safe(net, d, n)	\
+		list_for_each_entry_safe(d, n, &(net)->dev_base_head, dev_list)
+#define for_each_netdev_continue(net, d)		\
+		list_for_each_entry_continue(d, &(net)->dev_base_head, dev_list)
+#define net_device_entry(lh)	list_entry(lh, struct net_device, dev_list)
 
-static inline struct net_device *first_net_device(void)
-{
-	return list_empty(&dev_base_head) ? NULL :
-		net_device_entry(dev_base_head.next);
-}
+#define next_net_device(d) 						\
+({									\
+	struct net_device *dev = d;					\
+	struct list_head *lh;						\
+	struct net *net;						\
+									\
+	net = dev->nd_net;						\
+	lh = dev->dev_list.next;					\
+	lh == &net->dev_base_head ? NULL : net_device_entry(lh);	\
+})
+
+#define first_net_device(N)					\
+({								\
+	struct net *NET = (N);					\
+	list_empty(&NET->dev_base_head) ? NULL :		\
+		net_device_entry(NET->dev_base_head.next);	\
+})
 
 extern int 			netdev_boot_setup_check(struct net_device *dev);
 extern unsigned long		netdev_boot_base(const char *prefix, int unit);
-extern struct net_device    *dev_getbyhwaddr(unsigned short type, char *hwaddr);
-extern struct net_device *dev_getfirstbyhwtype(unsigned short type);
-extern struct net_device *__dev_getfirstbyhwtype(unsigned short type);
+extern struct net_device    *dev_getbyhwaddr(struct net *net, unsigned short type, char *hwaddr);
+extern struct net_device *dev_getfirstbyhwtype(struct net *net, unsigned short type);
+extern struct net_device *__dev_getfirstbyhwtype(struct net *net, unsigned short type);
 extern void		dev_add_pack(struct packet_type *pt);
 extern void		dev_remove_pack(struct packet_type *pt);
 extern void		__dev_remove_pack(struct packet_type *pt);
 
-extern struct net_device	*dev_get_by_flags(unsigned short flags,
+extern struct net_device	*dev_get_by_flags(struct net *net, unsigned short flags,
 						  unsigned short mask);
-extern struct net_device	*dev_get_by_name(const char *name);
-extern struct net_device	*__dev_get_by_name(const char *name);
+extern struct net_device	*dev_get_by_name(struct net *net, const char *name);
+extern struct net_device	*__dev_get_by_name(struct net *net, const char *name);
 extern int		dev_alloc_name(struct net_device *dev, const char *name);
 extern int		dev_open(struct net_device *dev);
 extern int		dev_close(struct net_device *dev);
@@ -632,9 +640,9 @@
 extern void		synchronize_net(void);
 extern int 		register_netdevice_notifier(struct notifier_block *nb);
 extern int		unregister_netdevice_notifier(struct notifier_block *nb);
-extern int		call_netdevice_notifiers(unsigned long val, void *v);
-extern struct net_device	*dev_get_by_index(int ifindex);
-extern struct net_device	*__dev_get_by_index(int ifindex);
+extern int call_netdevice_notifiers(unsigned long val, struct net_device *dev);
+extern struct net_device	*dev_get_by_index(struct net *net, int ifindex);
+extern struct net_device	*__dev_get_by_index(struct net *net, int ifindex);
 extern int		dev_restart(struct net_device *dev);
 #ifdef CONFIG_NETPOLL_TRAP
 extern int		netpoll_trap(void);
@@ -739,11 +747,13 @@
 #define HAVE_NETIF_RECEIVE_SKB 1
 extern int		netif_receive_skb(struct sk_buff *skb);
 extern int		dev_valid_name(const char *name);
-extern int		dev_ioctl(unsigned int cmd, void __user *);
-extern int		dev_ethtool(struct ifreq *);
+extern int		dev_ioctl(struct net *net, unsigned int cmd, void __user *);
+extern int		dev_ethtool(struct net *net, struct ifreq *);
 extern unsigned		dev_get_flags(const struct net_device *);
 extern int		dev_change_flags(struct net_device *, unsigned);
 extern int		dev_change_name(struct net_device *, char *);
+extern int		dev_change_net_namespace(struct net_device *,
+						 struct net *, const char *);
 extern int		dev_set_mtu(struct net_device *, int);
 extern int		dev_set_mac_address(struct net_device *,
 					    struct sockaddr *);
@@ -1013,7 +1023,7 @@
 extern void		netdev_state_change(struct net_device *dev);
 extern void		netdev_features_change(struct net_device *dev);
 /* Load a device via the kmod */
-extern void		dev_load(const char *name);
+extern void		dev_load(struct net *net, const char *name);
 extern void		dev_mcast_init(void);
 extern int		netdev_max_backlog;
 extern int		weight_p;
diff -Nurb linux-2.6.22-590/include/linux/netfilter/x_tables.h linux-2.6.22-try2-netns/include/linux/netfilter/x_tables.h
--- linux-2.6.22-590/include/linux/netfilter/x_tables.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/linux/netfilter/x_tables.h	2007-12-19 22:49:13.000000000 -0500
@@ -289,7 +289,7 @@
 			   unsigned int size, const char *table, unsigned int hook,
 			   unsigned short proto, int inv_proto);
 
-extern int xt_register_table(struct xt_table *table,
+extern int xt_register_table(struct net *net, struct xt_table *table,
 			     struct xt_table_info *bootstrap,
 			     struct xt_table_info *newinfo);
 extern void *xt_unregister_table(struct xt_table *table);
@@ -306,7 +306,7 @@
 extern int xt_find_revision(int af, const char *name, u8 revision, int target,
 			    int *err);
 
-extern struct xt_table *xt_find_table_lock(int af, const char *name);
+extern struct xt_table *xt_find_table_lock(struct net *net, int af, const char *name);
 extern void xt_table_unlock(struct xt_table *t);
 
 extern int xt_proto_init(int af);
diff -Nurb linux-2.6.22-590/include/linux/netfilter.h linux-2.6.22-try2-netns/include/linux/netfilter.h
--- linux-2.6.22-590/include/linux/netfilter.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/linux/netfilter.h	2007-12-19 22:49:13.000000000 -0500
@@ -362,11 +362,6 @@
 #endif
 }
 
-#ifdef CONFIG_PROC_FS
-#include <linux/proc_fs.h>
-extern struct proc_dir_entry *proc_net_netfilter;
-#endif
-
 #else /* !CONFIG_NETFILTER */
 #define NF_HOOK(pf, hook, skb, indev, outdev, okfn) (okfn)(skb)
 #define NF_HOOK_COND(pf, hook, skb, indev, outdev, okfn, cond) (okfn)(skb)
diff -Nurb linux-2.6.22-590/include/linux/netfilter_ipv4/ip_tables.h linux-2.6.22-try2-netns/include/linux/netfilter_ipv4/ip_tables.h
--- linux-2.6.22-590/include/linux/netfilter_ipv4/ip_tables.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/linux/netfilter_ipv4/ip_tables.h	2007-12-19 22:49:13.000000000 -0500
@@ -292,7 +292,7 @@
 #include <linux/init.h>
 extern void ipt_init(void) __init;
 
-extern int ipt_register_table(struct xt_table *table,
+extern int ipt_register_table(struct net *net, struct xt_table *table,
 			      const struct ipt_replace *repl);
 extern void ipt_unregister_table(struct xt_table *table);
 
diff -Nurb linux-2.6.22-590/include/linux/netfilter_ipv4.h linux-2.6.22-try2-netns/include/linux/netfilter_ipv4.h
--- linux-2.6.22-590/include/linux/netfilter_ipv4.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/linux/netfilter_ipv4.h	2007-12-19 22:49:13.000000000 -0500
@@ -75,7 +75,7 @@
 #define SO_ORIGINAL_DST 80
 
 #ifdef __KERNEL__
-extern int ip_route_me_harder(struct sk_buff **pskb, unsigned addr_type);
+extern int ip_route_me_harder(struct net *net, struct sk_buff **pskb, unsigned addr_type);
 extern int ip_xfrm_me_harder(struct sk_buff **pskb);
 extern __sum16 nf_ip_checksum(struct sk_buff *skb, unsigned int hook,
 				   unsigned int dataoff, u_int8_t protocol);
diff -Nurb linux-2.6.22-590/include/linux/netlink.h linux-2.6.22-try2-netns/include/linux/netlink.h
--- linux-2.6.22-590/include/linux/netlink.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/netlink.h	2007-12-19 22:49:13.000000000 -0500
@@ -27,6 +27,8 @@
 
 #define MAX_LINKS 32		
 
+struct net;
+
 struct sockaddr_nl
 {
 	sa_family_t	nl_family;	/* AF_NETLINK	*/
@@ -157,7 +159,8 @@
 #define NETLINK_CREDS(skb)	(&NETLINK_CB((skb)).creds)
 
 
-extern struct sock *netlink_kernel_create(int unit, unsigned int groups,
+extern struct sock *netlink_kernel_create(struct net *net,
+					  int unit,unsigned int groups,
 					  void (*input)(struct sock *sk, int len),
 					  struct mutex *cb_mutex,
 					  struct module *module);
@@ -204,6 +207,7 @@
 
 struct netlink_notify
 {
+	struct net *net;
 	int pid;
 	int protocol;
 };
diff -Nurb linux-2.6.22-590/include/linux/nsproxy.h linux-2.6.22-try2-netns/include/linux/nsproxy.h
--- linux-2.6.22-590/include/linux/nsproxy.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/nsproxy.h	2007-12-20 00:23:50.000000000 -0500
@@ -36,10 +36,11 @@
 	struct mnt_namespace *mnt_ns;
 	struct pid_namespace *pid_ns;
 	struct user_namespace *user_ns;
+ 	struct net 	     *net_ns;
 };
 extern struct nsproxy init_nsproxy;
 
-int copy_namespaces(int flags, struct task_struct *tsk);
+int copy_namespaces(unsigned long flags, struct task_struct *tsk);
 struct nsproxy *copy_nsproxy(struct nsproxy *orig);
 void get_task_namespaces(struct task_struct *tsk);
 void free_nsproxy(struct nsproxy *ns);
diff -Nurb linux-2.6.22-590/include/linux/proc_fs.h linux-2.6.22-try2-netns/include/linux/proc_fs.h
--- linux-2.6.22-590/include/linux/proc_fs.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/proc_fs.h	2007-12-19 22:49:13.000000000 -0500
@@ -86,8 +86,6 @@
 
 extern struct proc_dir_entry proc_root;
 extern struct proc_dir_entry *proc_root_fs;
-extern struct proc_dir_entry *proc_net;
-extern struct proc_dir_entry *proc_net_stat;
 extern struct proc_dir_entry *proc_bus;
 extern struct proc_dir_entry *proc_root_driver;
 extern struct proc_dir_entry *proc_root_kcore;
@@ -112,6 +110,10 @@
 extern struct proc_dir_entry *create_proc_entry(const char *name, mode_t mode,
 						struct proc_dir_entry *parent);
 extern void remove_proc_entry(const char *name, struct proc_dir_entry *parent);
+static inline void remove_proc_pde(struct proc_dir_entry *pde)
+{
+	return remove_proc_entry(pde->name, pde->parent);
+}
 
 extern struct vfsmount *proc_mnt;
 extern int proc_fill_super(struct super_block *,void *,int);
@@ -181,42 +183,18 @@
 	return res;
 }
  
-static inline struct proc_dir_entry *proc_net_create(const char *name,
-	mode_t mode, get_info_t *get_info)
-{
-	return create_proc_info_entry(name,mode,proc_net,get_info);
-}
-
-static inline struct proc_dir_entry *proc_net_fops_create(const char *name,
-	mode_t mode, const struct file_operations *fops)
-{
-	struct proc_dir_entry *res = create_proc_entry(name, mode, proc_net);
-	if (res)
-		res->proc_fops = fops;
-	return res;
-}
-
-static inline void proc_net_remove(const char *name)
-{
-	remove_proc_entry(name,proc_net);
-}
-
 #else
 
 #define proc_root_driver NULL
-#define proc_net NULL
 #define proc_bus NULL
 
-#define proc_net_fops_create(name, mode, fops)  ({ (void)(mode), NULL; })
-#define proc_net_create(name, mode, info)	({ (void)(mode), NULL; })
-static inline void proc_net_remove(const char *name) {}
-
 static inline void proc_flush_task(struct task_struct *task) { }
 
 static inline struct proc_dir_entry *create_proc_entry(const char *name,
 	mode_t mode, struct proc_dir_entry *parent) { return NULL; }
 
 #define remove_proc_entry(name, parent) do {} while (0)
+#define remove_proc_pde(PDE) do {} while (0)
 
 static inline struct proc_dir_entry *proc_symlink(const char *name,
 		struct proc_dir_entry *parent,const char *dest) {return NULL;}
diff -Nurb linux-2.6.22-590/include/linux/rtnetlink.h linux-2.6.22-try2-netns/include/linux/rtnetlink.h
--- linux-2.6.22-590/include/linux/rtnetlink.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/rtnetlink.h	2007-12-19 22:49:13.000000000 -0500
@@ -580,11 +580,11 @@
 ({	data = RTA_PAYLOAD(rta) >= len ? RTA_DATA(rta) : NULL; \
 	__rtattr_parse_nested_compat(tb, max, rta, len); })
 
-extern int rtnetlink_send(struct sk_buff *skb, u32 pid, u32 group, int echo);
-extern int rtnl_unicast(struct sk_buff *skb, u32 pid);
-extern int rtnl_notify(struct sk_buff *skb, u32 pid, u32 group,
+extern int rtnetlink_send(struct sk_buff *skb, struct net *net, u32 pid, u32 group, int echo);
+extern int rtnl_unicast(struct sk_buff *skb, struct net *net, u32 pid);
+extern int rtnl_notify(struct sk_buff *skb, struct net *net, u32 pid, u32 group,
 		       struct nlmsghdr *nlh, gfp_t flags);
-extern void rtnl_set_sk_err(u32 group, int error);
+extern void rtnl_set_sk_err(struct net *net, u32 group, int error);
 extern int rtnetlink_put_metrics(struct sk_buff *skb, u32 *metrics);
 extern int rtnl_put_cacheinfo(struct sk_buff *skb, struct dst_entry *dst,
 			      u32 id, u32 ts, u32 tsage, long expires,
diff -Nurb linux-2.6.22-590/include/linux/sched.h linux-2.6.22-try2-netns/include/linux/sched.h
--- linux-2.6.22-590/include/linux/sched.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/sched.h	2007-12-21 13:13:48.000000000 -0500
@@ -26,8 +26,9 @@
 #define CLONE_STOPPED		0x02000000	/* Start in stopped state */
 #define CLONE_NEWUTS		0x04000000	/* New utsname group? */
 #define CLONE_NEWIPC		0x08000000	/* New ipcs */
-#define CLONE_NEWUSER		0x10000000	/* New user namespace */
+#define CLONE_NEWUSER		0x20000000	/* New user namespace */
 #define CLONE_KTHREAD		0x10000000	/* clone a kernel thread */
+#define CLONE_NEWNET		0x40000000	/* New network namespace */
 
 /*
  * Scheduling policies
diff -Nurb linux-2.6.22-590/include/linux/socket.h linux-2.6.22-try2-netns/include/linux/socket.h
--- linux-2.6.22-590/include/linux/socket.h	2007-12-21 15:33:47.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/socket.h	2007-12-19 22:49:13.000000000 -0500
@@ -24,7 +24,6 @@
 #include <linux/types.h>		/* pid_t			*/
 #include <linux/compiler.h>		/* __user			*/
 
-extern int sysctl_somaxconn;
 #ifdef CONFIG_PROC_FS
 struct seq_file;
 extern void socket_seq_show(struct seq_file *seq);
diff -Nurb linux-2.6.22-590/include/linux/sysctl.h linux-2.6.22-try2-netns/include/linux/sysctl.h
--- linux-2.6.22-590/include/linux/sysctl.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/sysctl.h	2007-12-19 22:49:13.000000000 -0500
@@ -31,6 +31,7 @@
 
 struct file;
 struct completion;
+struct net;
 
 #define CTL_MAXNAME 10		/* how many path components do we allow in a
 				   call to sysctl?   In other words, what is
@@ -985,6 +986,7 @@
 			       void __user *oldval, size_t __user *oldlenp,
 			       void __user *newval, size_t newlen);
 
+extern ctl_handler sysctl_data;
 extern ctl_handler sysctl_string;
 extern ctl_handler sysctl_intvec;
 extern ctl_handler sysctl_jiffies;
@@ -1061,6 +1063,12 @@
 
 void unregister_sysctl_table(struct ctl_table_header * table);
 
+#ifdef CONFIG_NET
+extern struct ctl_table_header *register_net_sysctl_table(struct net *net, struct ctl_table *table);
+extern void unregister_net_sysctl_table(struct ctl_table_header *header);
+extern ctl_table net_root_table[];
+#endif
+
 #else /* __KERNEL__ */
 
 #endif /* __KERNEL__ */
diff -Nurb linux-2.6.22-590/include/linux/sysfs.h linux-2.6.22-try2-netns/include/linux/sysfs.h
--- linux-2.6.22-590/include/linux/sysfs.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/sysfs.h	2007-12-21 14:26:58.000000000 -0500
@@ -19,9 +19,6 @@
 
 struct kobject;
 struct module;
-struct nameidata;
-struct dentry;
-struct sysfs_dirent;
 
 /* FIXME
  * The *owner field is no longer used, but leave around
@@ -79,16 +76,23 @@
 	ssize_t	(*store)(struct kobject *,struct attribute *,const char *, size_t);
 };
 
+struct shadow_dir_operations {
+	const void *(*current_tag)(void);
+	const void *(*kobject_tag)(struct kobject *kobj);
+};
+
 #define SYSFS_TYPE_MASK		0x00ff
 #define SYSFS_ROOT		0x0001
 #define SYSFS_DIR		0x0002
 #define SYSFS_KOBJ_ATTR 	0x0004
 #define SYSFS_KOBJ_BIN_ATTR	0x0008
 #define SYSFS_KOBJ_LINK 	0x0020
+#define SYSFS_SHADOW_DIR	0x0040
 #define SYSFS_COPY_NAME		(SYSFS_DIR | SYSFS_KOBJ_LINK)
 
 #define SYSFS_FLAG_MASK		~SYSFS_TYPE_MASK
 #define SYSFS_FLAG_REMOVED	0x0100
+#define SYSFS_FLAG_SHADOWED	0x0200
 
 #ifdef CONFIG_SYSFS
 
@@ -96,14 +100,13 @@
 		void (*func)(void *), void *data, struct module *owner);
 
 extern int __must_check
-sysfs_create_dir(struct kobject *kobj, struct sysfs_dirent *shadow_parent_sd);
+sysfs_create_dir(struct kobject *);
 
 extern void
 sysfs_remove_dir(struct kobject *);
 
 extern int __must_check
-sysfs_rename_dir(struct kobject *kobj, struct sysfs_dirent *new_parent_sd,
-		 const char *new_name);
+sysfs_rename_dir(struct kobject *kobj, const char *new_name);
 
 extern int __must_check
 sysfs_move_dir(struct kobject *, struct kobject *);
@@ -126,6 +129,13 @@
 extern void
 sysfs_remove_link(struct kobject *, const char * name);
 
+extern int
+sysfs_rename_link(struct kobject *kobj, struct kobject *target,
+			const char *old_name, const char *new_name);
+
+extern void
+sysfs_delete_link(struct kobject *dir, struct kobject *targ, const char *name);
+
 int __must_check sysfs_create_bin_file(struct kobject *kobj,
 					struct bin_attribute *attr);
 void sysfs_remove_bin_file(struct kobject *kobj, struct bin_attribute *attr);
@@ -140,11 +150,7 @@
 
 void sysfs_notify(struct kobject * k, char *dir, char *attr);
 
-
-extern int sysfs_make_shadowed_dir(struct kobject *kobj,
-	void * (*follow_link)(struct dentry *, struct nameidata *));
-extern struct sysfs_dirent *sysfs_create_shadow_dir(struct kobject *kobj);
-extern void sysfs_remove_shadow_dir(struct sysfs_dirent *shadow_sd);
+int sysfs_enable_shadowing(struct kobject *, const struct shadow_dir_operations *);
 
 extern int __must_check sysfs_init(void);
 
@@ -156,8 +162,7 @@
 	return -ENOSYS;
 }
 
-static inline int sysfs_create_dir(struct kobject *kobj,
-				   struct sysfs_dirent *shadow_parent_sd)
+static inline int sysfs_create_dir(struct kobject * kobj)
 {
 	return 0;
 }
@@ -167,9 +172,7 @@
 	;
 }
 
-static inline int sysfs_rename_dir(struct kobject *kobj,
-				   struct sysfs_dirent *new_parent_sd,
-					const char *new_name)
+static inline int sysfs_rename_dir(struct kobject * kobj, const char *new_name)
 {
 	return 0;
 }
@@ -208,6 +211,17 @@
 	;
 }
 
+static inline int
+sysfs_rename_link(struct kobject * k, struct kobject *t,
+			const char *old_name, const char * new_name)
+{
+	return 0;
+}
+
+static inline void
+sysfs_delete_link(struct kobject *k, struct kobject *t, const char *name)
+{
+}
 
 static inline int sysfs_create_bin_file(struct kobject * k, struct bin_attribute * a)
 {
@@ -244,8 +258,8 @@
 {
 }
 
-static inline int sysfs_make_shadowed_dir(struct kobject *kobj,
-	void * (*follow_link)(struct dentry *, struct nameidata *))
+static inline int sysfs_enable_shadowing(struct kobject *kobj,
+				const struct shadow_dir_operations *shadow_ops)
 {
 	return 0;
 }
diff -Nurb linux-2.6.22-590/include/linux/time.h linux-2.6.22-try2-netns/include/linux/time.h
--- linux-2.6.22-590/include/linux/time.h	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/include/linux/time.h	2007-12-20 01:36:06.000000000 -0500
@@ -116,6 +116,8 @@
 extern unsigned int alarm_setitimer(unsigned int seconds);
 extern int do_getitimer(int which, struct itimerval *value);
 extern void getnstimeofday(struct timespec *tv);
+extern void getboottime(struct timespec *ts);
+extern void monotonic_to_bootbased(struct timespec *ts);
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_is_continuous(void);
diff -Nurb linux-2.6.22-590/include/linux/usb.h linux-2.6.22-try2-netns/include/linux/usb.h
--- linux-2.6.22-590/include/linux/usb.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/linux/usb.h	2007-12-21 14:27:08.000000000 -0500
@@ -146,6 +146,10 @@
 					 * active alternate setting */
 	unsigned num_altsetting;	/* number of alternate settings */
 
+	/* If there is an interface association descriptor then it will list
+	 * the associated interfaces */
+	struct usb_interface_assoc_descriptor *intf_assoc;
+
 	int minor;			/* minor number this interface is
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
@@ -175,6 +179,7 @@
 
 /* this maximum is arbitrary */
 #define USB_MAXINTERFACES	32
+#define USB_MAXIADS		USB_MAXINTERFACES/2
 
 /**
  * struct usb_interface_cache - long-term representation of a device interface
@@ -245,6 +250,11 @@
 	struct usb_config_descriptor	desc;
 
 	char *string;		/* iConfiguration string, if present */
+
+	/* List of any Interface Association Descriptors in this
+	 * configuration. */
+	struct usb_interface_assoc_descriptor *intf_assoc[USB_MAXIADS];
+
 	/* the interfaces associated with this configuration,
 	 * stored in no particular order */
 	struct usb_interface *interface[USB_MAXINTERFACES];
diff -Nurb linux-2.6.22-590/include/net/af_unix.h linux-2.6.22-try2-netns/include/net/af_unix.h
--- linux-2.6.22-590/include/net/af_unix.h	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/include/net/af_unix.h	2007-12-19 22:49:13.000000000 -0500
@@ -91,12 +91,11 @@
 #define unix_sk(__sk) ((struct unix_sock *)__sk)
 
 #ifdef CONFIG_SYSCTL
-extern int sysctl_unix_max_dgram_qlen;
-extern void unix_sysctl_register(void);
-extern void unix_sysctl_unregister(void);
+extern void unix_sysctl_register(struct net *net);
+extern void unix_sysctl_unregister(struct net *net);
 #else
-static inline void unix_sysctl_register(void) {}
-static inline void unix_sysctl_unregister(void) {}
+static inline void unix_sysctl_register(struct net *net) {}
+static inline void unix_sysctl_unregister(struct net *net) {}
 #endif
 #endif
 #endif
diff -Nurb linux-2.6.22-590/include/net/arp.h linux-2.6.22-try2-netns/include/net/arp.h
--- linux-2.6.22-590/include/net/arp.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/net/arp.h	2007-12-19 22:49:13.000000000 -0500
@@ -11,7 +11,7 @@
 
 extern void	arp_init(void);
 extern int	arp_find(unsigned char *haddr, struct sk_buff *skb);
-extern int	arp_ioctl(unsigned int cmd, void __user *arg);
+extern int	arp_ioctl(struct net *net, unsigned int cmd, void __user *arg);
 extern void     arp_send(int type, int ptype, __be32 dest_ip,
 			 struct net_device *dev, __be32 src_ip,
 			 unsigned char *dest_hw, unsigned char *src_hw, unsigned char *th);
diff -Nurb linux-2.6.22-590/include/net/fib_rules.h linux-2.6.22-try2-netns/include/net/fib_rules.h
--- linux-2.6.22-590/include/net/fib_rules.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/net/fib_rules.h	2007-12-19 22:49:13.000000000 -0500
@@ -56,12 +56,12 @@
 	int			(*fill)(struct fib_rule *, struct sk_buff *,
 					struct nlmsghdr *,
 					struct fib_rule_hdr *);
-	u32			(*default_pref)(void);
+	u32			(*default_pref)(struct fib_rules_ops *ops);
 	size_t			(*nlmsg_payload)(struct fib_rule *);
 
 	/* Called after modifications to the rules set, must flush
 	 * the route cache if one exists. */
-	void			(*flush_cache)(void);
+	void			(*flush_cache)(struct fib_rules_ops *ops);
 
 	int			nlgroup;
 	const struct nla_policy	*policy;
@@ -101,8 +101,8 @@
 	return frh->table;
 }
 
-extern int			fib_rules_register(struct fib_rules_ops *);
-extern int			fib_rules_unregister(struct fib_rules_ops *);
+extern int			fib_rules_register(struct net *net, struct fib_rules_ops *);
+extern int			fib_rules_unregister(struct net *net, struct fib_rules_ops *);
 
 extern int			fib_rules_lookup(struct fib_rules_ops *,
 						 struct flowi *, int flags,
diff -Nurb linux-2.6.22-590/include/net/flow.h linux-2.6.22-try2-netns/include/net/flow.h
--- linux-2.6.22-590/include/net/flow.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/net/flow.h	2007-12-19 22:49:13.000000000 -0500
@@ -8,9 +8,11 @@
 #define _NET_FLOW_H
 
 #include <linux/in6.h>
+#include <net/net_namespace.h>
 #include <asm/atomic.h>
 
 struct flowi {
+	struct net *fl_net;
 	int	oif;
 	int	iif;
 	__u32	mark;
diff -Nurb linux-2.6.22-590/include/net/inet6_hashtables.h linux-2.6.22-try2-netns/include/net/inet6_hashtables.h
--- linux-2.6.22-590/include/net/inet6_hashtables.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/net/inet6_hashtables.h	2007-12-19 22:49:13.000000000 -0500
@@ -62,31 +62,31 @@
 					   const __be16 sport,
 					   const struct in6_addr *daddr,
 					   const u16 hnum,
-					   const int dif);
+					   const int dif, struct net *net);
 
 extern struct sock *inet6_lookup_listener(struct inet_hashinfo *hashinfo,
 					  const struct in6_addr *daddr,
 					  const unsigned short hnum,
-					  const int dif);
+					  const int dif, struct net *net);
 
 static inline struct sock *__inet6_lookup(struct inet_hashinfo *hashinfo,
 					  const struct in6_addr *saddr,
 					  const __be16 sport,
 					  const struct in6_addr *daddr,
 					  const u16 hnum,
-					  const int dif)
+					  const int dif, struct net *net)
 {
 	struct sock *sk = __inet6_lookup_established(hashinfo, saddr, sport,
-						     daddr, hnum, dif);
+						     daddr, hnum, dif, net);
 	if (sk)
 		return sk;
 
-	return inet6_lookup_listener(hashinfo, daddr, hnum, dif);
+	return inet6_lookup_listener(hashinfo, daddr, hnum, dif, net);
 }
 
 extern struct sock *inet6_lookup(struct inet_hashinfo *hashinfo,
 				 const struct in6_addr *saddr, const __be16 sport,
 				 const struct in6_addr *daddr, const __be16 dport,
-				 const int dif);
+				 const int dif, struct net *net);
 #endif /* defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE) */
 #endif /* _INET6_HASHTABLES_H */
diff -Nurb linux-2.6.22-590/include/net/inet_hashtables.h linux-2.6.22-try2-netns/include/net/inet_hashtables.h
--- linux-2.6.22-590/include/net/inet_hashtables.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/net/inet_hashtables.h	2007-12-19 22:49:13.000000000 -0500
@@ -75,6 +75,7 @@
  * ports are created in O(1) time?  I thought so. ;-)	-DaveM
  */
 struct inet_bind_bucket {
+	struct net		*net;
 	unsigned short		port;
 	signed short		fastreuse;
 	struct hlist_node	node;
@@ -138,34 +139,35 @@
 extern struct inet_bind_bucket *
 		    inet_bind_bucket_create(struct kmem_cache *cachep,
 					    struct inet_bind_hashbucket *head,
+					    struct net *net,
 					    const unsigned short snum);
 extern void inet_bind_bucket_destroy(struct kmem_cache *cachep,
 				     struct inet_bind_bucket *tb);
 
-static inline int inet_bhashfn(const __u16 lport, const int bhash_size)
+static inline int inet_bhashfn(struct net *net, const __u16 lport, const int bhash_size)
 {
-	return lport & (bhash_size - 1);
+	return (((unsigned long)net) ^ lport) & (bhash_size - 1);
 }
 
 extern void inet_bind_hash(struct sock *sk, struct inet_bind_bucket *tb,
 			   const unsigned short snum);
 
 /* These can have wildcards, don't try too hard. */
-static inline int inet_lhashfn(const unsigned short num)
+static inline int inet_lhashfn(struct net *net, const unsigned short num)
 {
-	return num & (INET_LHTABLE_SIZE - 1);
+	return (((unsigned long)net) ^ num) & (INET_LHTABLE_SIZE - 1);
 }
 
 static inline int inet_sk_listen_hashfn(const struct sock *sk)
 {
-	return inet_lhashfn(inet_sk(sk)->num);
+	return inet_lhashfn(sk->sk_net, inet_sk(sk)->num);
 }
 
 /* Caller must disable local BH processing. */
 static inline void __inet_inherit_port(struct inet_hashinfo *table,
 				       struct sock *sk, struct sock *child)
 {
-	const int bhash = inet_bhashfn(inet_sk(child)->num, table->bhash_size);
+	const int bhash = inet_bhashfn(sk->sk_net, inet_sk(child)->num, table->bhash_size);
 	struct inet_bind_hashbucket *head = &table->bhash[bhash];
 	struct inet_bind_bucket *tb;
 
@@ -274,12 +276,13 @@
 extern struct sock *__inet_lookup_listener(struct inet_hashinfo *hashinfo,
 					   const __be32 daddr,
 					   const unsigned short hnum,
-					   const int dif);
+					   const int dif, struct net *net);
 
 static inline struct sock *inet_lookup_listener(struct inet_hashinfo *hashinfo,
-						__be32 daddr, __be16 dport, int dif)
+						__be32 daddr, __be16 dport,
+						int dif, struct net *net)
 {
-	return __inet_lookup_listener(hashinfo, daddr, ntohs(dport), dif);
+	return __inet_lookup_listener(hashinfo, daddr, ntohs(dport), dif, net);
 }
 
 /* Socket demux engine toys. */
@@ -313,30 +316,34 @@
 				   (((__force __u64)(__be32)(__daddr)) << 32) | \
 				   ((__force __u64)(__be32)(__saddr)));
 #endif /* __BIG_ENDIAN */
-#define INET_MATCH(__sk, __hash, __cookie, __saddr, __daddr, __ports, __dif)\
+#define INET_MATCH(__sk, __hash, __cookie, __saddr, __daddr, __ports, __dif, __net)\
 	(((__sk)->sk_hash == (__hash))				&&	\
 	 ((*((__addrpair *)&(inet_sk(__sk)->daddr))) == (__cookie))	&&	\
 	 ((*((__portpair *)&(inet_sk(__sk)->dport))) == (__ports))	&&	\
-	 (!((__sk)->sk_bound_dev_if) || ((__sk)->sk_bound_dev_if == (__dif))))
-#define INET_TW_MATCH(__sk, __hash, __cookie, __saddr, __daddr, __ports, __dif)\
+	 (!((__sk)->sk_bound_dev_if) || ((__sk)->sk_bound_dev_if == (__dif))) && \
+	 ((__sk)->sk_net == __net))
+#define INET_TW_MATCH(__sk, __hash, __cookie, __saddr, __daddr, __ports, __dif, __net)\
 	(((__sk)->sk_hash == (__hash))				&&	\
 	 ((*((__addrpair *)&(inet_twsk(__sk)->tw_daddr))) == (__cookie)) &&	\
 	 ((*((__portpair *)&(inet_twsk(__sk)->tw_dport))) == (__ports)) &&	\
-	 (!((__sk)->sk_bound_dev_if) || ((__sk)->sk_bound_dev_if == (__dif))))
+	 (!((__sk)->sk_bound_dev_if) || ((__sk)->sk_bound_dev_if == (__dif))) && \
+	 ((__sk)->sk_net == __net))
 #else /* 32-bit arch */
 #define INET_ADDR_COOKIE(__name, __saddr, __daddr)
-#define INET_MATCH(__sk, __hash, __cookie, __saddr, __daddr, __ports, __dif)	\
+#define INET_MATCH(__sk, __hash, __cookie, __saddr, __daddr, __ports, __dif, __net) \
 	(((__sk)->sk_hash == (__hash))				&&	\
 	 (inet_sk(__sk)->daddr		== (__saddr))		&&	\
 	 (inet_sk(__sk)->rcv_saddr	== (__daddr))		&&	\
 	 ((*((__portpair *)&(inet_sk(__sk)->dport))) == (__ports))	&&	\
-	 (!((__sk)->sk_bound_dev_if) || ((__sk)->sk_bound_dev_if == (__dif))))
-#define INET_TW_MATCH(__sk, __hash,__cookie, __saddr, __daddr, __ports, __dif)	\
+	 (!((__sk)->sk_bound_dev_if) || ((__sk)->sk_bound_dev_if == (__dif))) && \
+	 ((__sk)->sk_net == __net))
+#define INET_TW_MATCH(__sk, __hash,__cookie, __saddr, __daddr, __ports, __dif, __net) \
 	(((__sk)->sk_hash == (__hash))				&&	\
 	 (inet_twsk(__sk)->tw_daddr	== (__saddr))		&&	\
 	 (inet_twsk(__sk)->tw_rcv_saddr	== (__daddr))		&&	\
 	 ((*((__portpair *)&(inet_twsk(__sk)->tw_dport))) == (__ports)) &&	\
-	 (!((__sk)->sk_bound_dev_if) || ((__sk)->sk_bound_dev_if == (__dif))))
+	 (!((__sk)->sk_bound_dev_if) || ((__sk)->sk_bound_dev_if == (__dif))) && \
+	 ((__sk)->sk_net == __net))
 #endif /* 64-bit arch */
 
 /*
@@ -349,7 +356,7 @@
 	__inet_lookup_established(struct inet_hashinfo *hashinfo,
 				  const __be32 saddr, const __be16 sport,
 				  const __be32 daddr, const u16 hnum,
-				  const int dif)
+				  const int dif, struct net *net)
 {
 	INET_ADDR_COOKIE(acookie, saddr, daddr)
 	const __portpair ports = INET_COMBINED_PORTS(sport, hnum);
@@ -358,19 +365,19 @@
 	/* Optimize here for direct hit, only listening connections can
 	 * have wildcards anyways.
 	 */
-	unsigned int hash = inet_ehashfn(daddr, hnum, saddr, sport);
+	unsigned int hash = inet_ehashfn(net, daddr, hnum, saddr, sport);
 	struct inet_ehash_bucket *head = inet_ehash_bucket(hashinfo, hash);
 
 	prefetch(head->chain.first);
 	read_lock(&head->lock);
 	sk_for_each(sk, node, &head->chain) {
-		if (INET_MATCH(sk, hash, acookie, saddr, daddr, ports, dif))
+		if (INET_MATCH(sk, hash, acookie, saddr, daddr, ports, dif, net))
 			goto hit; /* You sunk my battleship! */
 	}
 
 	/* Must check for a TIME_WAIT'er before going to listener hash. */
 	sk_for_each(sk, node, &head->twchain) {
-		if (INET_TW_MATCH(sk, hash, acookie, saddr, daddr, ports, dif))
+		if (INET_TW_MATCH(sk, hash, acookie, saddr, daddr, ports, dif, net))
 			goto hit;
 	}
 	sk = NULL;
@@ -386,32 +393,32 @@
 	inet_lookup_established(struct inet_hashinfo *hashinfo,
 				const __be32 saddr, const __be16 sport,
 				const __be32 daddr, const __be16 dport,
-				const int dif)
+				const int dif, struct net *net)
 {
 	return __inet_lookup_established(hashinfo, saddr, sport, daddr,
-					 ntohs(dport), dif);
+					 ntohs(dport), dif, net);
 }
 
 static inline struct sock *__inet_lookup(struct inet_hashinfo *hashinfo,
 					 const __be32 saddr, const __be16 sport,
 					 const __be32 daddr, const __be16 dport,
-					 const int dif)
+					 const int dif, struct net *net)
 {
 	u16 hnum = ntohs(dport);
 	struct sock *sk = __inet_lookup_established(hashinfo, saddr, sport, daddr,
-						    hnum, dif);
-	return sk ? : __inet_lookup_listener(hashinfo, daddr, hnum, dif);
+						    hnum, dif, net);
+	return sk ? : __inet_lookup_listener(hashinfo, daddr, hnum, dif, net);
 }
 
 static inline struct sock *inet_lookup(struct inet_hashinfo *hashinfo,
 				       const __be32 saddr, const __be16 sport,
 				       const __be32 daddr, const __be16 dport,
-				       const int dif)
+				       const int dif, struct net *net)
 {
 	struct sock *sk;
 
 	local_bh_disable();
-	sk = __inet_lookup(hashinfo, saddr, sport, daddr, dport, dif);
+	sk = __inet_lookup(hashinfo, saddr, sport, daddr, dport, dif, net);
 	local_bh_enable();
 
 	return sk;
diff -Nurb linux-2.6.22-590/include/net/inet_sock.h linux-2.6.22-try2-netns/include/net/inet_sock.h
--- linux-2.6.22-590/include/net/inet_sock.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/net/inet_sock.h	2007-12-19 22:49:13.000000000 -0500
@@ -171,10 +171,12 @@
 extern u32 inet_ehash_secret;
 extern void build_ehash_secret(void);
 
-static inline unsigned int inet_ehashfn(const __be32 laddr, const __u16 lport,
+static inline unsigned int inet_ehashfn(struct net *net,
+					const __be32 laddr, const __u16 lport,
 					const __be32 faddr, const __be16 fport)
 {
-	return jhash_2words((__force __u32) laddr ^ (__force __u32) faddr,
+	return jhash_2words((__force __u32) laddr ^ (__force __u32) faddr ^
+			    (__force __u32) ((unsigned long)net),
 			    ((__u32) lport) << 16 | (__force __u32)fport,
 			    inet_ehash_secret);
 }
@@ -187,7 +189,7 @@
 	const __be32 faddr = inet->daddr;
 	const __be16 fport = inet->dport;
 
-	return inet_ehashfn(laddr, lport, faddr, fport);
+	return inet_ehashfn(sk->sk_net, laddr, lport, faddr, fport);
 }
 
 #endif	/* _INET_SOCK_H */
diff -Nurb linux-2.6.22-590/include/net/inet_timewait_sock.h linux-2.6.22-try2-netns/include/net/inet_timewait_sock.h
--- linux-2.6.22-590/include/net/inet_timewait_sock.h	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/include/net/inet_timewait_sock.h	2007-12-19 22:58:33.000000000 -0500
@@ -115,6 +115,7 @@
 #define tw_refcnt		__tw_common.skc_refcnt
 #define tw_hash			__tw_common.skc_hash
 #define tw_prot			__tw_common.skc_prot
+#define tw_net			__tw_common.skc_net
 #define tw_xid		__tw_common.skc_xid
 #define tw_vx_info		__tw_common.skc_vx_info
 #define tw_nid		__tw_common.skc_nid
diff -Nurb linux-2.6.22-590/include/net/inetpeer.h linux-2.6.22-try2-netns/include/net/inetpeer.h
--- linux-2.6.22-590/include/net/inetpeer.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/net/inetpeer.h	2007-12-19 22:49:13.000000000 -0500
@@ -15,6 +15,8 @@
 #include <linux/spinlock.h>
 #include <asm/atomic.h>
 
+struct net;
+
 struct inet_peer
 {
 	/* group together avl_left,avl_right,v4daddr to speedup lookups */
@@ -22,7 +24,11 @@
 	__be32			v4daddr;	/* peer's address */
 	__u16			avl_height;
 	__u16			ip_id_count;	/* IP ID for the next packet */
-	struct inet_peer	*unused_next, **unused_prevp;
+	union {
+		struct inet_peer	*unused_next;
+		struct net 		*net;
+	} u;
+	struct inet_peer	**unused_prevp;
 	__u32			dtime;		/* the time of last use of not
 						 * referenced entries */
 	atomic_t		refcnt;
@@ -34,7 +40,7 @@
 void			inet_initpeers(void) __init;
 
 /* can be called with or without local BH being disabled */
-struct inet_peer	*inet_getpeer(__be32 daddr, int create);
+struct inet_peer	*inet_getpeer(struct net *net, __be32 daddr, int create);
 
 /* can be called from BH context or outside */
 extern void inet_putpeer(struct inet_peer *p);
diff -Nurb linux-2.6.22-590/include/net/ip.h linux-2.6.22-try2-netns/include/net/ip.h
--- linux-2.6.22-590/include/net/ip.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/net/ip.h	2007-12-19 22:49:13.000000000 -0500
@@ -149,13 +149,6 @@
 void ip_send_reply(struct sock *sk, struct sk_buff *skb, struct ip_reply_arg *arg,
 		   unsigned int len); 
 
-struct ipv4_config
-{
-	int	log_martians;
-	int	no_pmtu_disc;
-};
-
-extern struct ipv4_config ipv4_config;
 DECLARE_SNMP_STAT(struct ipstats_mib, ip_statistics);
 #define IP_INC_STATS(field)		SNMP_INC_STATS(ip_statistics, field)
 #define IP_INC_STATS_BH(field)		SNMP_INC_STATS_BH(ip_statistics, field)
@@ -171,27 +164,6 @@
 extern int snmp_mib_init(void *ptr[2], size_t mibsize, size_t mibalign);
 extern void snmp_mib_free(void *ptr[2]);
 
-extern int sysctl_local_port_range[2];
-extern int sysctl_ip_default_ttl;
-extern int sysctl_ip_nonlocal_bind;
-
-/* From ip_fragment.c */
-extern int sysctl_ipfrag_high_thresh; 
-extern int sysctl_ipfrag_low_thresh;
-extern int sysctl_ipfrag_time;
-extern int sysctl_ipfrag_secret_interval;
-extern int sysctl_ipfrag_max_dist;
-
-/* From inetpeer.c */
-extern int inet_peer_threshold;
-extern int inet_peer_minttl;
-extern int inet_peer_maxttl;
-extern int inet_peer_gc_mintime;
-extern int inet_peer_gc_maxtime;
-
-/* From ip_output.c */
-extern int sysctl_ip_dynaddr;
-
 extern void ipfrag_init(void);
 
 #ifdef CONFIG_INET
@@ -332,8 +304,6 @@
 };
 
 struct sk_buff *ip_defrag(struct sk_buff *skb, u32 user);
-extern int ip_frag_nqueues;
-extern atomic_t ip_frag_mem;
 
 /*
  *	Functions provided by ip_forward.c
@@ -392,5 +362,6 @@
 #endif
 
 extern struct ctl_table ipv4_table[];
+extern struct ctl_table multi_ipv4_table[];
 
 #endif	/* _IP_H */
diff -Nurb linux-2.6.22-590/include/net/ip_fib.h linux-2.6.22-try2-netns/include/net/ip_fib.h
--- linux-2.6.22-590/include/net/ip_fib.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/net/ip_fib.h	2007-12-19 22:49:13.000000000 -0500
@@ -85,6 +85,10 @@
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
 	int			fib_power;
 #endif
+#ifdef CONFIG_IP_ROUTE_MULTIPATH_CACHED
+	u32			fib_mp_alg;
+#endif
+	struct net *		fib_net;
 	struct fib_nh		fib_nh[0];
 #define fib_dev		fib_nh[0].nh_dev
 };
@@ -155,43 +159,43 @@
 
 #ifndef CONFIG_IP_MULTIPLE_TABLES
 
-extern struct fib_table *ip_fib_local_table;
-extern struct fib_table *ip_fib_main_table;
-
-static inline struct fib_table *fib_get_table(u32 id)
+static inline struct fib_table *fib_get_table(struct net *net, u32 id)
 {
 	if (id != RT_TABLE_LOCAL)
-		return ip_fib_main_table;
-	return ip_fib_local_table;
+		return net->ip_fib_main_table;
+	return net->ip_fib_local_table;
 }
 
-static inline struct fib_table *fib_new_table(u32 id)
+static inline struct fib_table *fib_new_table(struct net *net, u32 id)
 {
-	return fib_get_table(id);
+	return fib_get_table(net, id);
 }
 
 static inline int fib_lookup(const struct flowi *flp, struct fib_result *res)
 {
-	if (ip_fib_local_table->tb_lookup(ip_fib_local_table, flp, res) &&
-	    ip_fib_main_table->tb_lookup(ip_fib_main_table, flp, res))
+	struct net *net = flp->fl_net;
+	struct fib_table *local_table = net->ip_fib_local_table;
+	struct fib_table *main_table = net->ip_fib_main_table;
+	if (local_table->tb_lookup(local_table, flp, res) &&
+	    main_table->tb_lookup(main_table, flp, res))
 		return -ENETUNREACH;
 	return 0;
 }
 
 static inline void fib_select_default(const struct flowi *flp, struct fib_result *res)
 {
+	struct net *net = flp->fl_net;
+	struct fib_table *main_table = net->ip_fib_main_table;
 	if (FIB_RES_GW(*res) && FIB_RES_NH(*res).nh_scope == RT_SCOPE_LINK)
-		ip_fib_main_table->tb_select_default(ip_fib_main_table, flp, res);
+		main_table->tb_select_default(main_table, flp, res);
 }
 
 #else /* CONFIG_IP_MULTIPLE_TABLES */
-#define ip_fib_local_table fib_get_table(RT_TABLE_LOCAL)
-#define ip_fib_main_table fib_get_table(RT_TABLE_MAIN)
 
 extern int fib_lookup(struct flowi *flp, struct fib_result *res);
 
-extern struct fib_table *fib_new_table(u32 id);
-extern struct fib_table *fib_get_table(u32 id);
+extern struct fib_table *fib_new_table(struct net *net, u32 id);
+extern struct fib_table *fib_get_table(struct net *net, u32 id);
 extern void fib_select_default(const struct flowi *flp, struct fib_result *res);
 
 #endif /* CONFIG_IP_MULTIPLE_TABLES */
@@ -207,15 +211,17 @@
 
 /* Exported by fib_semantics.c */
 extern int ip_fib_check_default(__be32 gw, struct net_device *dev);
-extern int fib_sync_down(__be32 local, struct net_device *dev, int force);
+extern int fib_sync_down(struct net *net, __be32 local, struct net_device *dev, int force);
 extern int fib_sync_up(struct net_device *dev);
 extern __be32  __fib_res_prefsrc(struct fib_result *res);
 
 /* Exported by fib_hash.c */
 extern struct fib_table *fib_hash_init(u32 id);
+extern void fib_hash_exit(struct fib_table *tb);
 
 #ifdef CONFIG_IP_MULTIPLE_TABLES
-extern void __init fib4_rules_init(void);
+extern void fib4_rules_init(struct net * net);
+extern void fib4_rules_exit(struct net * net);
 
 #ifdef CONFIG_NET_CLS_ROUTE
 extern u32 fib_rules_tclass(struct fib_result *res);
@@ -258,8 +264,11 @@
 }
 
 #ifdef CONFIG_PROC_FS
-extern int  fib_proc_init(void);
-extern void fib_proc_exit(void);
+extern int  fib_proc_init(struct net * net);
+extern void fib_proc_exit(struct net * net);
 #endif
 
+extern int  fib_info_init(struct net *net);
+extern void fib_info_exit(struct net *net);
+
 #endif  /* _NET_FIB_H */
diff -Nurb linux-2.6.22-590/include/net/llc_conn.h linux-2.6.22-try2-netns/include/net/llc_conn.h
--- linux-2.6.22-590/include/net/llc_conn.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/net/llc_conn.h	2007-12-19 22:49:13.000000000 -0500
@@ -93,7 +93,7 @@
 	return skb->cb[sizeof(skb->cb) - 1];
 }
 
-extern struct sock *llc_sk_alloc(int family, gfp_t priority,
+extern struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority,
 				 struct proto *prot);
 extern void llc_sk_free(struct sock *sk);
 
diff -Nurb linux-2.6.22-590/include/net/neighbour.h linux-2.6.22-try2-netns/include/net/neighbour.h
--- linux-2.6.22-590/include/net/neighbour.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/net/neighbour.h	2007-12-19 22:49:13.000000000 -0500
@@ -34,6 +34,7 @@
 
 struct neigh_parms
 {
+	struct net *net;
 	struct net_device *dev;
 	struct neigh_parms *next;
 	int	(*neigh_setup)(struct neighbour *);
@@ -126,6 +127,7 @@
 struct pneigh_entry
 {
 	struct pneigh_entry	*next;
+	struct net		*net;
 	struct net_device		*dev;
 	u8			flags;
 	u8			key[0];
@@ -187,6 +189,7 @@
 					     const void *pkey,
 					     struct net_device *dev);
 extern struct neighbour *	neigh_lookup_nodev(struct neigh_table *tbl,
+						   struct net *net,
 						   const void *pkey);
 extern struct neighbour *	neigh_create(struct neigh_table *tbl,
 					     const void *pkey,
@@ -205,21 +208,24 @@
 						struct net_device *dev);
 
 extern struct neigh_parms	*neigh_parms_alloc(struct net_device *dev, struct neigh_table *tbl);
+extern struct neigh_parms	*neigh_parms_alloc_default(struct neigh_table *tbl, struct net *net);
 extern void			neigh_parms_release(struct neigh_table *tbl, struct neigh_parms *parms);
 extern void			neigh_parms_destroy(struct neigh_parms *parms);
 extern unsigned long		neigh_rand_reach_time(unsigned long base);
 
 extern void			pneigh_enqueue(struct neigh_table *tbl, struct neigh_parms *p,
 					       struct sk_buff *skb);
-extern struct pneigh_entry	*pneigh_lookup(struct neigh_table *tbl, const void *key, struct net_device *dev, int creat);
-extern int			pneigh_delete(struct neigh_table *tbl, const void *key, struct net_device *dev);
+extern struct pneigh_entry	*pneigh_lookup(struct neigh_table *tbl, struct net *net, const void *key, struct net_device *dev, int creat);
+extern int			pneigh_delete(struct neigh_table *tbl, struct net *net, const void *key, struct net_device *dev);
 
 extern void neigh_app_ns(struct neighbour *n);
 extern void neigh_for_each(struct neigh_table *tbl, void (*cb)(struct neighbour *, void *), void *cookie);
 extern void __neigh_for_each_release(struct neigh_table *tbl, int (*cb)(struct neighbour *));
 extern void pneigh_for_each(struct neigh_table *tbl, void (*cb)(struct pneigh_entry *));
 
-struct neigh_seq_state {
+struct neigh_seq_state
+{
+	struct net *net;
 	struct neigh_table *tbl;
 	void *(*neigh_sub_iter)(struct neigh_seq_state *state,
 				struct neighbour *n, loff_t *pos);
diff -Nurb linux-2.6.22-590/include/net/net_namespace.h linux-2.6.22-try2-netns/include/net/net_namespace.h
--- linux-2.6.22-590/include/net/net_namespace.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/include/net/net_namespace.h	2007-12-19 22:49:13.000000000 -0500
@@ -0,0 +1,236 @@
+/*
+ * Operations on the network namespace
+ */
+#ifndef __NET_NET_NAMESPACE_H
+#define __NET_NET_NAMESPACE_H
+
+#include <asm/atomic.h>
+#include <linux/workqueue.h>
+#include <linux/list.h>
+#include <linux/proc_fs.h>
+#include <linux/sysctl.h>
+#include <linux/netdevice.h>
+#include <linux/timer.h>
+
+struct sock;
+struct xt_af_pernet;
+struct ipv4_devconf;
+struct neigh_parms;
+struct inet_peer;
+struct xt_table;
+struct net {
+	atomic_t count;		/* To decided when the network namespace
+				 * should go
+				 */
+	atomic_t use_count;	/* For references we destroy on demand */
+	struct list_head list;	/* list of network namespace structures */
+	struct work_struct work;	/* work struct for freeing */
+
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *proc_net;
+	struct proc_dir_entry *proc_net_stat;
+	struct proc_dir_entry proc_net_root;
+# ifdef CONFIG_NETFILTER
+	struct proc_dir_entry *proc_net_netfilter;
+# endif
+#endif
+#ifdef CONFIG_SYSCTL
+	struct ctl_table_header net_table_header;
+#endif
+	struct net_device	loopback_dev;		/* The loopback */
+	struct list_head	dev_base_head;		/* All devices */
+
+	struct hlist_head 	*dev_name_head;
+	struct hlist_head	*dev_index_head;
+
+	struct sock *		rtnl;	/* rtnetlink socket */
+
+
+	/* core netfilter */
+	struct xt_af_pernet *	xtn;
+
+	/* core fib_rules */
+	struct list_head	rules_ops;
+	spinlock_t		rules_mod_lock;
+
+#ifdef CONFIG_XFRM
+	u32			sysctl_xfrm_aevent_etime;
+	u32			sysctl_xfrm_aevent_rseqth;
+	int			sysctl_xfrm_larval_drop;
+	u32			sysctl_xfrm_acq_expires;
+#endif /* CONFIG_XFRM */
+
+	int			sysctl_somaxconn;
+
+#ifdef CONFIG_PACKET
+	/* List of all packet sockets. */
+	rwlock_t		packet_sklist_lock;
+	struct hlist_head	packet_sklist;
+#endif /* CONFIG_PACKET */
+#ifdef CONFIG_UNIX
+	int			sysctl_unix_max_dgram_qlen;
+	void *			unix_sysctl;
+#endif /* CONFIG_UNIX */
+#ifdef CONFIG_IP_MULTIPLE_TABLES
+	void *			fib4_table;
+#endif /* CONFIG_IP_MULTIPLE_TABLES */
+#ifdef CONFIG_IP_FIB_HASH
+	int			fn_hash_last_dflt;
+#endif
+#ifdef CONFIG_IP_FIB_TRIE
+	int			trie_last_dflt;
+#endif
+#ifndef CONFIG_IP_MULTIPLE_TABLES
+	struct fib_table	*ip_fib_local_table;
+	struct fib_table	*ip_fib_main_table;
+#endif
+	struct hlist_head	*ip_fib_table_hash;
+	struct sock		*nlfl;
+
+	/* fib_semantics */
+	struct hlist_head	*fib_info_hash;
+	struct hlist_head	*fib_info_laddrhash;
+	unsigned int		fib_info_hash_size;
+	unsigned int		fib_info_cnt;
+	struct hlist_head	*fib_info_devhash;
+
+	/* af_inet.c */
+	int			sysctl_ip_nonlocal_bind; /* __read_mostly */
+	int			sysctl_ip_default_ttl;	/* __read_mostly */
+	int			sysctl_ipfrag_high_thresh;
+	int			sysctl_ipfrag_low_thresh;
+	int			sysctl_ipfrag_time;
+	int			sysctl_ipfrag_secret_interval;
+	int			sysctl_ipfrag_max_dist;
+	int			sysctl_ipv4_no_pmtu_disc;
+	int			sysctl_local_port_range[2];
+	int			sysctl_ip_dynaddr;
+	int			sysctl_tcp_timestamps;	/* __read_mostly */
+	int			sysctl_tcp_window_scaling; /* __read_mostly */
+	/* inetpeer.c */
+	int			inet_peer_threshold;
+	int			inet_peer_minttl;
+	int			inet_peer_maxttl;
+	int			inet_peer_gc_mintime;
+	int			inet_peer_gc_maxtime;
+
+	/* devinet */
+	struct ipv4_devconf	*ipv4_devconf;
+	struct ipv4_devconf	*ipv4_devconf_dflt;
+
+	/* arp.c */
+	struct neigh_parms	*arp_neigh_parms_default;
+
+	/* icmp.c */
+	struct socket 		**__icmp_socket;
+
+	/* inetpeer.c */
+	struct inet_peer	*peer_root;
+	int			peer_total;
+	struct inet_peer	*inet_peer_unused_head;
+	struct inet_peer	**inet_peer_unused_tailp;
+	struct timer_list	peer_periodic_timer;
+
+	/* ip_fragment.c */
+	struct hlist_head	*ipq_hash;
+	u32			ipfrag_hash_rnd;
+	struct list_head	ipq_lru_list;
+	int			ip_frag_nqueues;
+	atomic_t		ip_frag_mem;
+	struct timer_list	ipfrag_secret_timer;
+
+	/* udp.c */
+	int			udp_port_rover;
+
+	/* iptable_filter.c */
+	struct xt_table		*ip_packet_filter;
+};
+
+extern struct net init_net;
+extern struct list_head net_namespace_list;
+
+extern struct net *copy_net_ns(unsigned long flags, struct net *net_ns);
+extern void __put_net(struct net *net);
+
+static inline struct net *get_net(struct net *net)
+{
+	atomic_inc(&net->count);
+	return net;
+}
+
+static inline void put_net(struct net *net)
+{
+	if (atomic_dec_and_test(&net->count))
+		__put_net(net);
+}
+
+static inline struct net *hold_net(struct net *net)
+{
+	atomic_inc(&net->use_count);
+	return net;
+}
+
+static inline void release_net(struct net *net)
+{
+	atomic_dec(&net->use_count);
+}
+
+extern void net_lock(void);
+extern void net_unlock(void);
+
+#define for_each_net(VAR)				\
+	list_for_each_entry(VAR, &net_namespace_list, list)
+
+
+struct pernet_operations {
+	struct list_head list;
+	int (*init)(struct net *net);
+	void (*exit)(struct net *net);
+};
+
+extern int register_pernet_subsys(struct pernet_operations *);
+extern void unregister_pernet_subsys(struct pernet_operations *);
+extern int register_pernet_device(struct pernet_operations *);
+extern void unregister_pernet_device(struct pernet_operations *);
+
+#ifdef CONFIG_PROC_FS
+static inline struct net *PDE_NET(struct proc_dir_entry *pde)
+{
+	return pde->parent->data;
+}
+
+static inline struct net *PROC_NET(const struct inode *inode)
+{
+	return PDE_NET(PDE(inode));
+}
+
+static inline struct proc_dir_entry *proc_net_create(struct net *net,
+	const char *name, mode_t mode, get_info_t *get_info)
+{
+	return create_proc_info_entry(name,mode, net->proc_net, get_info);
+}
+
+static inline struct proc_dir_entry *proc_net_fops_create(struct net *net,
+	const char *name, mode_t mode, const struct file_operations *fops)
+{
+	struct proc_dir_entry *res = 
+		create_proc_entry(name, mode, net->proc_net);
+	if (res)
+		res->proc_fops = fops;
+	return res;
+}
+
+static inline void proc_net_remove(struct net *net, const char *name)
+{
+	remove_proc_entry(name, net->proc_net);
+}
+
+#else
+
+#define proc_net_fops_create(net, name, mode, fops)  ({ (void)(mode), NULL; })
+#define proc_net_create(net, name, mode, info)	({ (void)(mode), NULL; })
+static inline void proc_net_remove(struct net *net, const char *name) {}
+
+#endif /* CONFIG_PROC_FS */
+
+#endif /* __NET_NET_NAMESPACE_H */
diff -Nurb linux-2.6.22-590/include/net/netlink.h linux-2.6.22-try2-netns/include/net/netlink.h
--- linux-2.6.22-590/include/net/netlink.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/net/netlink.h	2007-12-19 22:49:13.000000000 -0500
@@ -218,6 +218,7 @@
 struct nl_info {
 	struct nlmsghdr		*nlh;
 	u32			pid;
+	struct net 		*net;
 };
 
 extern void		netlink_run_queue(struct sock *sk, unsigned int *qlen,
diff -Nurb linux-2.6.22-590/include/net/pkt_cls.h linux-2.6.22-try2-netns/include/net/pkt_cls.h
--- linux-2.6.22-590/include/net/pkt_cls.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/net/pkt_cls.h	2007-12-19 22:49:13.000000000 -0500
@@ -2,6 +2,7 @@
 #define __NET_PKT_CLS_H
 
 #include <linux/pkt_cls.h>
+#include <net/net_namespace.h>
 #include <net/sch_generic.h>
 #include <net/act_api.h>
 
@@ -357,7 +358,7 @@
 	if (indev[0]) {
 		if  (!skb->iif)
 			return 0;
-		dev = __dev_get_by_index(skb->iif);
+		dev = __dev_get_by_index(&init_net, skb->iif);
 		if (!dev || strcmp(indev, dev->name))
 			return 0;
 	}
diff -Nurb linux-2.6.22-590/include/net/protocol.h linux-2.6.22-try2-netns/include/net/protocol.h
--- linux-2.6.22-590/include/net/protocol.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/net/protocol.h	2007-12-19 22:49:13.000000000 -0500
@@ -86,6 +86,7 @@
 #define INET_PROTOSW_REUSE 0x01	     /* Are ports automatically reusable? */
 #define INET_PROTOSW_PERMANENT 0x02  /* Permanent protocols are unremovable. */
 #define INET_PROTOSW_ICSK      0x04  /* Is this an inet_connection_sock? */
+#define INET_PROTOSW_NETNS     0x08  /* Multiple namespaces support? */
 
 extern struct net_protocol *inet_protocol_base;
 extern struct net_protocol *inet_protos[MAX_INET_PROTOS];
diff -Nurb linux-2.6.22-590/include/net/raw.h linux-2.6.22-try2-netns/include/net/raw.h
--- linux-2.6.22-590/include/net/raw.h	2007-12-21 15:33:47.000000000 -0500
+++ linux-2.6.22-try2-netns/include/net/raw.h	2007-12-19 22:49:13.000000000 -0500
@@ -34,7 +34,7 @@
 extern rwlock_t raw_v4_lock;
 
 
-extern struct sock *__raw_v4_lookup(struct sock *sk, unsigned short num,
+extern struct sock *__raw_v4_lookup(struct net *net, struct sock *sk, unsigned short num,
 				    __be32 raddr, __be32 laddr,
 				    int dif, int tag);
 
diff -Nurb linux-2.6.22-590/include/net/route.h linux-2.6.22-try2-netns/include/net/route.h
--- linux-2.6.22-590/include/net/route.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/net/route.h	2007-12-19 22:58:46.000000000 -0500
@@ -27,6 +27,7 @@
 #include <net/dst.h>
 #include <net/inetpeer.h>
 #include <net/flow.h>
+#include <net/sock.h>
 #include <net/inet_sock.h>
 #include <linux/in_route.h>
 #include <linux/rtnetlink.h>
@@ -122,9 +123,9 @@
 extern unsigned short	ip_rt_frag_needed(struct iphdr *iph, unsigned short new_mtu);
 extern void		ip_rt_send_redirect(struct sk_buff *skb);
 
-extern unsigned		inet_addr_type(__be32 addr);
+extern unsigned		inet_addr_type(struct net *net, __be32 addr);
 extern void		ip_rt_multicast_event(struct in_device *);
-extern int		ip_rt_ioctl(unsigned int cmd, void __user *arg);
+extern int		ip_rt_ioctl(struct net *net, unsigned int cmd, void __user *arg);
 extern void		ip_rt_get_source(u8 *src, struct rtable *rt);
 extern int		ip_rt_dump(struct sk_buff *skb,  struct netlink_callback *cb);
 
@@ -153,7 +154,8 @@
 				   __be16 sport, __be16 dport, struct sock *sk,
 				   int flags)
 {
-	struct flowi fl = { .oif = oif,
+	struct flowi fl = { .fl_net = sk->sk_net,
+			    .oif = oif,
 			    .nl_u = { .ip4_u = { .daddr = dst,
 						 .saddr = src,
 						 .tos   = tos } },
@@ -198,6 +200,7 @@
 		struct flowi fl;
 
 		memcpy(&fl, &(*rp)->fl, sizeof(fl));
+		fl.fl_net = sk->sk_net;
 		fl.fl_ip_sport = sport;
 		fl.fl_ip_dport = dport;
 		fl.proto = protocol;
diff -Nurb linux-2.6.22-590/include/net/sock.h linux-2.6.22-try2-netns/include/net/sock.h
--- linux-2.6.22-590/include/net/sock.h	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/include/net/sock.h	2007-12-19 22:59:14.000000000 -0500
@@ -55,6 +55,7 @@
 #include <asm/atomic.h>
 #include <net/dst.h>
 #include <net/checksum.h>
+#include <net/net_namespace.h>
 
 /*
  * This structure really needs to be cleaned up.
@@ -105,6 +106,7 @@
  *	@skc_refcnt: reference count
  *	@skc_hash: hash value used with various protocol lookup tables
  *	@skc_prot: protocol handlers inside a network family
+ *	@skc_net: reference to the network namespace of this socket
  *
  *	This is the minimal network layer representation of sockets, the header
  *	for struct sock and struct inet_timewait_sock.
@@ -119,6 +121,7 @@
 	atomic_t		skc_refcnt;
 	unsigned int		skc_hash;
 	struct proto		*skc_prot;
+ 	struct net	 	*skc_net;
 	xid_t			skc_xid;
 	struct vx_info		*skc_vx_info;
 	nid_t			skc_nid;
@@ -199,6 +202,7 @@
 #define sk_refcnt		__sk_common.skc_refcnt
 #define sk_hash			__sk_common.skc_hash
 #define sk_prot			__sk_common.skc_prot
+#define sk_net			__sk_common.skc_net
 #define sk_xid			__sk_common.skc_xid
 #define sk_vx_info		__sk_common.skc_vx_info
 #define sk_nid			__sk_common.skc_nid
@@ -781,7 +785,7 @@
 				SINGLE_DEPTH_NESTING)
 #define bh_unlock_sock(__sk)	spin_unlock(&((__sk)->sk_lock.slock))
 
-extern struct sock		*sk_alloc(int family,
+extern struct sock		*sk_alloc(struct net *net, int family,
 					  gfp_t priority,
 					  struct proto *prot, int zero_it);
 extern void			sk_free(struct sock *sk);
@@ -1010,6 +1014,7 @@
 #endif
 
 	memcpy(nsk, osk, osk->sk_prot->obj_size);
+	get_net(nsk->sk_net);
 #ifdef CONFIG_SECURITY_NETWORK
 	nsk->sk_security = sptr;
 	security_sk_clone(osk, nsk);
@@ -1373,6 +1378,7 @@
 
 #ifdef CONFIG_SYSCTL
 extern struct ctl_table core_table[];
+extern struct ctl_table multi_core_table[];
 #endif
 
 extern int sysctl_optmem_max;
diff -Nurb linux-2.6.22-590/include/net/tcp.h linux-2.6.22-try2-netns/include/net/tcp.h
--- linux-2.6.22-590/include/net/tcp.h	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/include/net/tcp.h	2007-12-19 22:49:13.000000000 -0500
@@ -191,8 +191,6 @@
 extern struct inet_timewait_death_row tcp_death_row;
 
 /* sysctl variables for tcp */
-extern int sysctl_tcp_timestamps;
-extern int sysctl_tcp_window_scaling;
 extern int sysctl_tcp_sack;
 extern int sysctl_tcp_fin_timeout;
 extern int sysctl_tcp_keepalive_time;
@@ -1293,6 +1291,7 @@
 };
 
 struct tcp_iter_state {
+	struct net		*net;
 	sa_family_t		family;
 	enum tcp_seq_states	state;
 	struct sock		*syn_wait_sk;
@@ -1300,8 +1299,8 @@
 	struct seq_operations	seq_ops;
 };
 
-extern int tcp_proc_register(struct tcp_seq_afinfo *afinfo);
-extern void tcp_proc_unregister(struct tcp_seq_afinfo *afinfo);
+extern int tcp_proc_register(struct net *net, struct tcp_seq_afinfo *afinfo);
+extern void tcp_proc_unregister(struct net *net, struct tcp_seq_afinfo *afinfo);
 
 extern struct request_sock_ops tcp_request_sock_ops;
 
diff -Nurb linux-2.6.22-590/include/net/udp.h linux-2.6.22-try2-netns/include/net/udp.h
--- linux-2.6.22-590/include/net/udp.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/net/udp.h	2007-12-19 22:49:13.000000000 -0500
@@ -160,6 +160,7 @@
 };
 
 struct udp_iter_state {
+	struct net 		*net;
 	sa_family_t		family;
 	struct hlist_head	*hashtable;
 	int			bucket;
@@ -167,8 +168,8 @@
 };
 
 #ifdef CONFIG_PROC_FS
-extern int udp_proc_register(struct udp_seq_afinfo *afinfo);
-extern void udp_proc_unregister(struct udp_seq_afinfo *afinfo);
+extern int udp_proc_register(struct net *net, struct udp_seq_afinfo *afinfo);
+extern void udp_proc_unregister(struct net *net, struct udp_seq_afinfo *afinfo);
 
 extern int  udp4_proc_init(void);
 extern void udp4_proc_exit(void);
diff -Nurb linux-2.6.22-590/include/net/wext.h linux-2.6.22-try2-netns/include/net/wext.h
--- linux-2.6.22-590/include/net/wext.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/include/net/wext.h	2007-12-19 22:49:13.000000000 -0500
@@ -5,16 +5,23 @@
  * wireless extensions interface to the core code
  */
 
+struct net;
+
 #ifdef CONFIG_WIRELESS_EXT
-extern int wext_proc_init(void);
-extern int wext_handle_ioctl(struct ifreq *ifr, unsigned int cmd,
+extern int wext_proc_init(struct net *net);
+extern void wext_proc_exit(struct net *net);
+extern int wext_handle_ioctl(struct net *net, struct ifreq *ifr, unsigned int cmd,
 			     void __user *arg);
 #else
-static inline int wext_proc_init(void)
+static inline int wext_proc_init(struct net *net)
 {
 	return 0;
 }
-static inline int wext_handle_ioctl(struct ifreq *ifr, unsigned int cmd,
+static inline void wext_proc_exit(struct net *net)
+{
+	return;
+}
+static inline int wext_handle_ioctl(struct net *net, struct ifreq *ifr, unsigned int cmd,
 				    void __user *arg)
 {
 	return -EINVAL;
diff -Nurb linux-2.6.22-590/include/net/xfrm.h linux-2.6.22-try2-netns/include/net/xfrm.h
--- linux-2.6.22-590/include/net/xfrm.h	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/include/net/xfrm.h	2007-12-19 22:49:13.000000000 -0500
@@ -34,8 +34,6 @@
 	MODULE_ALIAS("xfrm-type-" __stringify(family) "-" __stringify(proto))
 
 extern struct sock *xfrm_nl;
-extern u32 sysctl_xfrm_aevent_etime;
-extern u32 sysctl_xfrm_aevent_rseqth;
 
 extern struct mutex xfrm_cfg_mutex;
 
diff -Nurb linux-2.6.22-590/inst/System.map linux-2.6.22-try2-netns/inst/System.map
--- linux-2.6.22-590/inst/System.map	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/System.map	2007-12-21 13:22:23.000000000 -0500
@@ -0,0 +1,24487 @@
+00000400 A __kernel_vsyscall
+00000410 A SYSENTER_RETURN
+00000420 A __kernel_sigreturn
+00000440 A __kernel_rt_sigreturn
+00100000 A phys_startup_32
+c0100000 T _text
+c0100000 T startup_32
+c0101000 T _stext
+c0101000 t run_init_process
+c0101000 T stext
+c0101014 t init_post
+c01010f0 t try_name
+c01012b7 T name_to_dev_t
+c0101524 T calibrate_delay
+c01017c4 T hard_smp_processor_id
+c01017dc t target_cpus
+c01017e2 t check_apicid_used
+c01017e5 t check_apicid_present
+c01017eb t multi_timer_check
+c01017ee t apic_id_registered
+c01017f4 t cpu_to_logical_apicid
+c0101808 t cpu_present_to_apicid
+c010181c t ioapic_phys_id_map
+c0101849 t apicid_to_cpu_present
+c0101875 t setup_portio_remap
+c0101876 t check_phys_apicid_present
+c010187c t enable_apic_mode
+c010187d t get_apic_id
+c0101881 t mpc_oem_bus_info
+c0101882 t mpc_oem_pci_bus
+c0101883 t probe_summit
+c0101886 t send_IPI_mask
+c010188b t mpc_apic_id
+c01018d4 t setup_apic_routing
+c01018ef t phys_pkg_id
+c01018fd t apicid_to_node
+c010190a t mps_oem_check
+c01019be t acpi_madt_oem_check
+c0101a4a t init_apic_ldr
+c0101ace t cpu_mask_to_apicid
+c0101b76 t send_IPI_allbutself
+c0101b9e t send_IPI_all
+c0101bac t apic_id_registered
+c0101bb2 t check_apicid_used
+c0101bb5 t check_apicid_present
+c0101bbb t multi_timer_check
+c0101bbe t apicid_to_node
+c0101bc1 t cpu_present_to_apicid
+c0101bd5 t apicid_to_cpu_present
+c0101c00 t cpu_to_logical_apicid
+c0101c14 t ioapic_phys_id_map
+c0101c41 t setup_portio_remap
+c0101c42 t enable_apic_mode
+c0101c43 t check_phys_apicid_present
+c0101c49 t phys_pkg_id
+c0101c4e t get_apic_id
+c0101c52 t mpc_oem_bus_info
+c0101c53 t mpc_oem_pci_bus
+c0101c54 t mps_oem_check
+c0101c57 t acpi_madt_oem_check
+c0101c5a t send_IPI_mask
+c0101c5f t hp_ht_bigsmp
+c0101c84 t mpc_apic_id
+c0101ccd t setup_apic_routing
+c0101cf1 t target_cpus
+c0101d29 t probe_bigsmp
+c0101d4e t init_apic_ldr
+c0101d8a t cpu_mask_to_apicid
+c0101dac t send_IPI_allbutself
+c0101dd4 t send_IPI_all
+c0101de0 t get_apic_id
+c0101de4 t apic_id_registered
+c0101dea t target_cpus
+c0101df9 t check_apicid_used
+c0101dfc t multi_timer_check
+c0101dff t apicid_to_node
+c0101e02 t cpu_present_to_apicid
+c0101e20 t apicid_to_cpu_present
+c0101e6e t cpu_to_logical_apicid
+c0101e82 t ioapic_phys_id_map
+c0101eaf t setup_portio_remap
+c0101eb0 t phys_pkg_id
+c0101eb5 t mpc_oem_bus_info
+c0101eb6 t mpc_oem_pci_bus
+c0101eb7 t probe_es7000
+c0101eba t send_IPI_mask
+c0101ebf t mpc_apic_id
+c0101f08 t check_apicid_present
+c0101f12 t init_apic_ldr
+c0101f42 t check_phys_apicid_present
+c0101f5c t setup_apic_routing
+c0101faa t cpu_mask_to_apicid
+c0102047 t send_IPI_allbutself
+c010206f t send_IPI_all
+c010207c t get_apic_id
+c0102083 t target_cpus
+c0102089 t ioapic_phys_id_map
+c010209e t multi_timer_check
+c01020a1 t apicid_to_node
+c01020a4 t cpu_to_logical_apicid
+c01020ae t apicid_to_cpu_present
+c01020d9 t setup_portio_remap
+c01020da t cpu_mask_to_apicid
+c01020db t enable_apic_mode
+c01020dc t phys_pkg_id
+c01020e1 t mpc_oem_bus_info
+c01020e2 t mpc_oem_pci_bus
+c01020e3 t mps_oem_check
+c01020e6 t acpi_madt_oem_check
+c01020e9 t probe_default
+c01020ef t send_IPI_all
+c0102113 t send_IPI_allbutself
+c0102166 t send_IPI_mask
+c010216b t mpc_apic_id
+c01021b4 t setup_apic_routing
+c01021d8 t cpu_present_to_apicid
+c01021ee t check_apicid_used
+c01021fa t check_apicid_present
+c0102204 t check_phys_apicid_present
+c010220e t apic_id_registered
+c010222a t init_apic_ldr
+c0102264 t es7000_rename_gsi
+c01022ab T es7000_start_cpu
+c01022d8 T es7000_stop_cpu
+c0103000 T thread_saved_pc
+c010300a T disable_hlt
+c0103011 T enable_hlt
+c0103018 t poll_idle
+c010301b T dump_task_regs
+c0103106 T select_idle_routine
+c010313d T arch_align_stack
+c010316b T sys_vfork
+c010319b T sys_clone
+c01031d6 T sys_fork
+c0103206 T mwait_idle_with_hints
+c0103246 t mwait_idle
+c0103250 T release_thread
+c0103262 T kernel_thread
+c01032f4 T cpu_idle
+c0103363 T cpu_idle_wait
+c0103432 T exit_thread
+c01034d3 T flush_thread
+c010352b T dump_thread
+c010364c T sys_execve
+c01036ca T get_wchan
+c0103732 T sys_set_thread_area
+c01038d7 T sys_get_thread_area
+c0103a00 T show_regs
+c0103b8f T prepare_to_copy
+c0103bd0 T default_idle
+c0103c0f T copy_thread
+c0103dce t __switch_to_xtra
+c0103e30 T __switch_to
+c0103f5c t setup_sigcontext
+c01040e5 T sys_sigaltstack
+c01040f7 t restore_sigcontext
+c0104259 T sys_sigaction
+c0104335 T do_notify_resume
+c0104946 T sys_rt_sigreturn
+c0104a36 T sys_sigsuspend
+c0104acb T sys_sigreturn
+c0104c2c T ret_from_fork
+c0104c48 t ret_from_exception
+c0104c48 t ret_from_intr
+c0104c4f t check_userspace
+c0104c68 T resume_userspace
+c0104c80 T sysenter_entry
+c0104c87 t sysenter_past_esp
+c0104d0c T system_call
+c0104d47 t syscall_call
+c0104d52 t syscall_exit
+c0104d61 t no_singlestep
+c0104d6f t restore_all
+c0104d87 t restore_nocheck
+c0104d87 t restore_nocheck_notrace
+c0104d96 t ldt_ss
+c0104dbc t work_pending
+c0104dc1 t work_resched
+c0104dd7 t work_notifysig
+c0104df0 t work_notifysig_v86
+c0104e08 t syscall_trace_entry
+c0104e38 t syscall_exit_work
+c0104e53 t syscall_fault
+c0104e84 t syscall_badsys
+c0104e94 T irq_entries_start
+c01056d4 t common_interrupt
+c01056fc T reschedule_interrupt
+c010572c T invalidate_interrupt
+c010575c T call_function_interrupt
+c010578c T apic_timer_interrupt
+c01057bc T error_interrupt
+c01057ec T spurious_interrupt
+c010581c T thermal_interrupt
+c010584c T coprocessor_error
+c0105858 T simd_coprocessor_error
+c0105864 T device_not_available
+c0105896 t device_not_available_emulate
+c01058a8 T overflow
+c01058b4 T bounds
+c01058c0 T invalid_op
+c01058cc T coprocessor_segment_overrun
+c01058d8 T invalid_TSS
+c01058e4 T segment_not_present
+c01058f0 T stack_segment
+c01058fc T alignment_check
+c0105908 T divide_error
+c0105914 T machine_check
+c0105924 T spurious_interrupt_bug
+c0105930 T kernel_thread_helper
+c0105940 t print_trace_stack
+c0105943 T do_spurious_interrupt_bug
+c0105944 T patch_espfix_desc
+c0105a0f T set_intr_gate
+c0105a2e t print_trace_warning
+c0105a49 T math_state_restore
+c0105a78 T math_error
+c0105b66 T do_coprocessor_error
+c0105b75 t print_trace_address
+c0105b9f T dump_trace
+c0105c32 t show_trace_log_lvl
+c0105c5e t show_stack_log_lvl
+c0105d03 T show_registers
+c0105f94 T die
+c01061bc T do_iret_error
+c0106247 T do_alignment_check
+c01062d2 T do_stack_segment
+c0106337 T do_segment_not_present
+c010639c T do_invalid_TSS
+c0106401 T do_coprocessor_segment_overrun
+c0106466 T do_invalid_op
+c01064f0 T do_bounds
+c0106555 T do_overflow
+c01065ba T do_divide_error
+c0106641 T show_stack
+c010666c T show_trace
+c010667d T is_valid_bugaddr
+c01066ba T dump_stack
+c01066ce T do_simd_coprocessor_error
+c0106836 T math_emulate
+c0106878 t print_trace_warning_symbol
+c01068a4 T irq_ctx_exit
+c01068b0 T show_interrupts
+c0106b34 T irq_ctx_init
+c0106bc2 T ack_bad_irq
+c0106bf2 T do_softirq
+c0106c9b T do_IRQ
+c0106d6c t putreg
+c0106de5 t getreg
+c0106e30 t clear_singlestep
+c0106e56 T send_sigtrap
+c0106ebe T ptrace_disable
+c0106eda T arch_ptrace
+c01075d2 T do_syscall_trace
+c01076ac T rtc_cmos_read
+c01076f3 T rtc_cmos_write
+c0107742 T notify_arch_cmos_timer
+c010775d t sync_cmos_clock
+c0107954 T read_persistent_clock
+c0107a7b T timer_interrupt
+c0107aaf T profile_pc
+c0107afc T sys_iopl
+c0107b6e T sys_ioperm
+c0107cf4 T destroy_context
+c0107d40 t alloc_ldt
+c0107ee5 t write_ldt
+c010809d T sys_modify_ldt
+c01081bb t flush_ldt
+c0108241 T init_new_context
+c0108314 t i8259A_suspend
+c010832e t math_error_irq
+c010835b T init_8259A
+c01083ea t i8259A_resume
+c010840e T make_8259A_irq
+c0108449 T disable_8259A_irq
+c010848b T enable_8259A_irq
+c01084cd t i8259A_shutdown
+c01084d6 T i8259A_irq_pending
+c0108518 t mask_and_ack_8259A
+c01085e4 T kernel_execve
+c01085fc T old_select
+c010864e T sys_mmap2
+c0108705 T old_mmap
+c010876b T sys_pipe
+c010879e T sys_ipc
+c0108959 T sys_uname
+c01089a3 T sys_olduname
+c0108b48 t check_iommu
+c0108b78 t via_no_dac
+c0108ba9 T dma_release_declared_memory
+c0108bd7 T dma_free_coherent
+c0108c2a T dma_alloc_coherent
+c0108d08 T dma_mark_declared_memory_occupied
+c0108d55 T dma_declare_coherent_memory
+c0108e30 T dump_task_extended_fpu
+c0108eaa t convert_fxsr_from_user
+c0108f90 t convert_fxsr_to_user
+c01090d4 T get_fpu_cwd
+c01090f2 T get_fpu_swd
+c0109110 T get_fpu_mxcsr
+c010912d T get_fpregs
+c010916d T set_fpregs
+c01091af T get_fpxregs
+c01091f6 T set_fpxregs
+c0109248 T init_fpu
+c01092bf T mxcsr_feature_mask_init
+c0109313 T save_i387
+c010945e T restore_i387
+c010952f T kernel_fpu_begin
+c0109566 T dump_task_fpu
+c0109616 T dump_fpu
+c01096c4 T e820_any_mapped
+c0109734 t quirk_intel_irqbalance
+c0109808 t i8237A_suspend
+c010980b t i8237A_resume
+c01098ac T arch_register_cpu
+c01098bc t nop_out
+c010991d t alternatives_smp_unlock
+c0109956 T apply_alternatives
+c01099e7 T alternatives_smp_switch
+c0109afc T alternatives_smp_module_del
+c0109ba8 T alternatives_smp_module_add
+c0109cd0 t init_pit_timer
+c0109d47 t pit_next_event
+c0109d76 t pit_read
+c0109e04 T native_calculate_cpu_khz
+c0109ec9 T recalibrate_cpu_khz
+c0109ecf t read_tsc
+c0109ed2 T mark_tsc_unstable
+c0109f26 T sched_clock
+c0109f74 T idle_regs
+c0109f91 T switch_to_new_gdt
+c0109fc0 t c_start
+c0109fdd t c_next
+c0109fe8 t c_stop
+c0109fe9 t show_cpuinfo
+c010a344 t vide
+c010a348 t show
+c010a36f t store
+c010a372 t show_type
+c010a3ba t show_size
+c010a3db t show_number_of_sets
+c010a3fa t show_ways_of_associativity
+c010a41d t show_physical_line_partition
+c010a444 t show_coherency_line_size
+c010a468 t show_level
+c010a48b t show_shared_cpu_map
+c010a4c6 t free_cache_attributes
+c010a4e2 t cpuid4_cache_sysfs_exit
+c010a518 t unexpected_machine_check
+c010a534 T mcheck_init
+c010a590 t k7_machine_check
+c010a706 T amd_mcheck_init
+c010a7b8 t unexpected_thermal_interrupt
+c010a7dd T smp_thermal_interrupt
+c010a7f3 t intel_thermal_interrupt
+c010a812 t intel_machine_check
+c010aa92 T intel_p4_mcheck_init
+c010ac64 t pentium_machine_check
+c010acc0 T intel_p5_mcheck_init
+c010ad1c t intel_machine_check
+c010aeaf T intel_p6_mcheck_init
+c010af60 T winchip_mcheck_init
+c010afb6 t winchip_machine_check
+c010afd0 t therm_throt_sysdev_show_count
+c010b012 T therm_throt_process
+c010b0d4 T set_mtrr_ops
+c010b0e8 t set_mtrr
+c010b1cc t mtrr_restore
+c010b212 t mtrr_save
+c010b26e T mtrr_save_state
+c010b2a2 t mtrr_check
+c010b2ea T mtrr_del_page
+c010b43d T mtrr_del
+c010b470 T mtrr_add_page
+c010b7bb T mtrr_add
+c010b802 T mtrr_ap_init
+c010b821 t ipi_handler
+c010b878 T mtrr_attrib_to_str
+c010b88c t mtrr_close
+c010b8eb t mtrr_open
+c010b916 t mtrr_file_del
+c010b96e t mtrr_file_add
+c010ba03 t mtrr_ioctl
+c010bd45 t mtrr_write
+c010bfa5 t mtrr_seq_show
+c010c08c t get_fixed_ranges
+c010c0e1 T mtrr_save_fixed_ranges
+c010c0f3 T generic_get_free_region
+c010c143 t generic_have_wrcomb
+c010c150 T positive_have_wrcomb
+c010c156 T generic_validate_add_page
+c010c207 T mtrr_wrmsr
+c010c275 t post_set
+c010c2b8 t prepare_set
+c010c314 t print_fixed
+c010c371 T get_mtrr_state
+c010c5b7 t generic_get_mtrr
+c010c652 t generic_set_mtrr
+c010c723 t generic_set_all
+c010c974 T set_mtrr_prepare_save
+c010c9e4 T set_mtrr_cache_disable
+c010ca21 T set_mtrr_done
+c010ca88 t amd_set_mtrr
+c010cafc t amd_validate_add_page
+c010cb23 t amd_get_mtrr
+c010cb94 t cyrix_get_arr
+c010cc87 t cyrix_get_free_region
+c010cd5b t prepare_set
+c010cda1 t post_set
+c010cdce t cyrix_set_arr
+c010ceb2 t cyrix_set_all
+c010cf1c t centaur_get_free_region
+c010cf7f T mtrr_centaur_report_mcr
+c010cf8e t centaur_get_mcr
+c010cffa t centaur_set_mcr
+c010d062 t centaur_validate_add_page
+c010d0a0 t adjust_for_32bit_ctr
+c010d117 t write_watchdog_counter
+c010d162 t write_watchdog_counter32
+c010d1a2 t single_msr_rearm
+c010d1ae T lapic_watchdog_stop
+c010d1bb T lapic_adjust_nmi_hz
+c010d1e1 T lapic_wd_event
+c010d21f T lapic_watchdog_ok
+c010d22c T lapic_watchdog_init
+c010d310 T release_evntsel_nmi
+c010d366 T reserve_evntsel_nmi
+c010d3c6 T release_perfctr_nmi
+c010d41c t p4_unreserve
+c010d443 t single_msr_unreserve
+c010d45d T reserve_perfctr_nmi
+c010d4bd t p4_reserve
+c010d518 t single_msr_reserve
+c010d553 T disable_lapic_nmi_watchdog
+c010d598 T enable_lapic_nmi_watchdog
+c010d5eb T avail_to_resrv_perfctr_nmi
+c010d64a T avail_to_resrv_perfctr_nmi_bit
+c010d665 t single_msr_stop_watchdog
+c010d67c t stop_p4_watchdog
+c010d69e t setup_intel_arch_watchdog
+c010d76d t setup_k7_watchdog
+c010d7e5 t setup_p6_watchdog
+c010d86c t p6_rearm
+c010d88a t setup_p4_watchdog
+c010d966 t p4_rearm
+c010d9ac T acpi_gsi_to_irq
+c010d9b1 T acpi_register_ioapic
+c010d9b7 T acpi_unregister_ioapic
+c010d9bd T __acpi_release_global_lock
+c010d9da T __acpi_map_table
+c010da68 T __acpi_acquire_global_lock
+c010da8e T acpi_register_gsi
+c010dac8 W mach_reboot_fixups
+c010dac9 t native_machine_halt
+c010daca T machine_power_off
+c010dad1 T machine_shutdown
+c010dad8 t native_machine_power_off
+c010daed T machine_emergency_restart
+c010daf4 t native_machine_restart
+c010dafe T machine_restart
+c010db05 T machine_halt
+c010db0c T machine_real_restart
+c010dbaf t native_machine_shutdown
+c010dc04 t native_machine_emergency_restart
+c010dd18 T safe_smp_processor_id
+c010dd60 t native_smp_send_reschedule
+c010dd7b t stop_this_cpu
+c010dda6 T unlock_ipi_call_lock
+c010ddb0 T lock_ipi_call_lock
+c010ddba T flush_tlb_all
+c010ddd7 T native_flush_tlb_others
+c010de6a T __send_IPI_shortcut
+c010de9c T send_IPI_self
+c010dea8 t do_flush_tlb_all
+c010deff t native_smp_send_stop
+c010df87 T send_IPI_mask_sequence
+c010e001 t native_smp_call_function_mask
+c010e100 T smp_call_function_interrupt
+c010e154 T smp_reschedule_interrupt
+c010e165 T smp_invalidate_interrupt
+c010e1d5 T flush_tlb_page
+c010e249 T flush_tlb_current_task
+c010e287 T flush_tlb_mm
+c010e2fb T send_IPI_mask_bitmask
+c010e38c T cpu_coregroup_map
+c010e3b0 t map_cpu_to_logical_apicid
+c010e3d9 T __cpu_disable
+c010e3df T __cpu_die
+c010e3e3 T initialize_secondary
+c010e3f8 T smp_call_function_single
+c010e45f T smp_call_function
+c010e480 t mp_find_ioapic
+c010e4c1 T mp_register_gsi
+c010e634 t modern_apic
+c010e666 T apic_wait_icr_idle
+c010e67c T get_physical_broadcast
+c010e68e T lapic_get_maxlvt
+c010e6ac t __setup_APIC_LVTT
+c010e71f t lapic_timer_setup
+c010e768 t lapic_timer_broadcast
+c010e77a T setup_profiling_timer
+c010e780 T clear_local_APIC
+c010e8df T disable_local_APIC
+c010e928 T setup_local_APIC
+c010ebb7 t setup_APIC_timer
+c010ebff T setup_secondary_APIC_clock
+c010ec01 T lapic_shutdown
+c010ec26 t lapic_next_event
+c010ec37 T safe_apic_wait_icr_idle
+c010ec6b T smp_error_interrupt
+c010eccc t lapic_suspend
+c010ed91 t lapic_resume
+c010ef63 T smp_spurious_interrupt
+c010efa8 T disconnect_bsp_APIC
+c010f034 T smp_apic_timer_interrupt
+c010f0b4 T enable_NMI_through_LVT0
+c010f0dc t __acpi_nmi_disable
+c010f0ed T __trigger_all_cpu_backtrace
+c010f119 T proc_nmi_enabled
+c010f1d6 T do_nmi_callback
+c010f214 T touch_nmi_watchdog
+c010f248 T stop_apic_nmi_watchdog
+c010f288 t lapic_nmi_suspend
+c010f2a9 T setup_apic_nmi_watchdog
+c010f31c t lapic_nmi_resume
+c010f334 T acpi_nmi_disable
+c010f360 T acpi_nmi_enable
+c010f38c t __acpi_nmi_enable
+c010f3a0 t io_apic_base
+c010f3bf t __ioapic_write_entry
+c010f3e8 t __modify_IO_APIC_irq
+c010f442 t __unmask_IO_APIC_irq
+c010f44b t find_irq_entry
+c010f498 t ack_apic
+c010f4a9 t unmask_lapic_irq
+c010f4bf t pin_2_irq
+c010f5a7 t MPBIOS_trigger
+c010f662 T IO_APIC_get_PCI_irq_vector
+c010f770 t unmask_IO_APIC_irq
+c010f795 t mask_IO_APIC_irq
+c010f7c1 t ioapic_write_entry
+c010f807 t ioapic_read_entry
+c010f868 t ioapic_suspend
+c010f890 t clear_IO_APIC_pin
+c010f8e8 t clear_IO_APIC
+c010f911 t add_pin_to_irq
+c010f967 t __assign_irq_vector
+c010f9f0 t assign_irq_vector
+c010fa1a t ioapic_register_intr
+c010fad0 T io_apic_set_pci_routing
+c010fc36 t ioapic_retrigger_irq
+c010fc48 t set_ioapic_affinity_irq
+c010fce0 t startup_ioapic_irq
+c010fd28 T arch_setup_ht_irq
+c010fdd4 T destroy_irq
+c010fdfa T arch_teardown_msi_irq
+c010fdff T create_irq
+c010fe71 T arch_setup_msi_irq
+c010ff40 t setup_nmi
+c010ff87 T disable_IO_APIC
+c0110010 t mask_lapic_irq
+c0110026 t ack_ioapic_irq
+c011003c t ack_ioapic_quirk_irq
+c01100c2 t ioapic_resume
+c011015a t set_msi_irq_affinity
+c01101d5 t set_ht_irq_affinity
+c011023c T machine_kexec_prepare
+c011023f T machine_kexec_cleanup
+c0110240 T machine_kexec
+c0111000 T relocate_kernel
+c0111064 t relocate_new_kernel
+c011108f t identity_mapped
+c0111118 T machine_crash_shutdown
+c01111b5 t crash_nmi_callback
+c0111234 T copy_oldmem_page
+c01112d8 T module_frob_arch_sections
+c01112db T module_arch_cleanup
+c01112eb T apply_relocate_add
+c011130d T apply_relocate
+c01113a2 T module_free
+c01113a9 T module_alloc
+c01113b5 T module_finalize
+c01114fc W arch_vma_name
+c0111517 T get_gate_vma
+c011153d T in_gate_area
+c011155d T in_gate_area_no_task
+c0111560 T enable_sep_cpu
+c01115b2 T arch_setup_additional_pages
+c01116d4 T is_available_memory
+c01116ff t virt_efi_get_time
+c0111718 t virt_efi_set_time
+c011172c t virt_efi_get_wakeup_time
+c011174c t virt_efi_set_wakeup_time
+c011176b t virt_efi_get_variable
+c011179d t virt_efi_get_next_variable
+c01117bd t virt_efi_set_variable
+c01117ef t virt_efi_get_next_high_mono_count
+c0111803 t virt_efi_reset_system
+c011182d T efi_mem_type
+c0111897 T efi_mem_attributes
+c0111906 t efi_call_phys_prelog
+c0111980 T efi_set_rtc_mmss
+c01119bf t efi_call_phys_epilog
+c0111a17 T efi_get_time
+c0111aa1 T efi_memmap_walk
+c0111bb4 T efi_call_phys
+c0111c20 t doublefault_fn
+c0111d04 T release_vm86_irqs
+c0111d58 t irq_handler
+c0111dce t copy_vm86_regs_from_user
+c0111dff t do_sys_vm86
+c0111fba T save_v86_state
+c01120f4 t do_int
+c011229a T handle_vm86_trap
+c0112380 T sys_vm86old
+c01123f5 T sys_vm86
+c0112611 T handle_vm86_fault
+c0112d10 t early_serial_putc
+c0112d42 t early_serial_write
+c0112d70 t simnow
+c0112d8c t simnow_write
+c0112da6 T early_printk
+c0112dee t early_vga_write
+c0112ef8 T is_hpet_enabled
+c0112f1a t hpet_start_counter
+c0112f44 t hpet_enable_int
+c0112f5f t read_hpet
+c0112f6e T hpet_rtc_timer_init
+c011300c T hpet_mask_rtc_irq_bit
+c0113028 T hpet_set_rtc_irq_bit
+c011305a T hpet_set_alarm_time
+c0113096 T hpet_set_periodic_freq
+c011310c T hpet_rtc_dropped_irq
+c0113111 t hpet_resume
+c011312f T hpet_rtc_interrupt
+c011327b t hpet_suspend
+c011328e t hpet_set_mode
+c0113339 t hpet_next_event
+c0113368 T free_init_pages
+c01133ed T free_initrd_mem
+c01133fb T free_initmem
+c011340f T mark_rodata_ro
+c0113463 t do_test_wp_bit
+c011347d T zap_low_mappings
+c0113497 T page_is_ram
+c0113574 T __set_fixmap
+c01135e3 T check_pgt_cache
+c0113600 T pgd_free
+c0113618 T pte_alloc_one_kernel
+c0113624 T pgd_alloc
+c0113666 T pgd_dtor
+c01136a1 T pgd_ctor
+c0113713 T pte_alloc_one
+c0113724 T reserve_top_address
+c0113763 T set_pmd_pfn
+c01137a4 T pmd_ctor
+c01137ab T show_mem
+c01139b0 T vmalloc_sync_all
+c0113aa0 t __is_prefetch
+c0113cc8 t force_sig_info_fault
+c0113cf0 T unregister_page_fault_notifier
+c0113cfc T register_page_fault_notifier
+c0113d14 T iounmap
+c0113def T __ioremap
+c0113ed1 T ioremap_nocache
+c0113f48 T fixup_exception
+c0113f68 T lookup_address
+c0113faf t flush_kernel_map
+c0113fe3 T global_flush_tlb
+c011407a t set_pmd_pte
+c01140bf T change_page_attr
+c0114344 T arch_pick_mmap_layout
+c01143e0 T kmap_atomic_pfn
+c011441d T kmap_atomic_to_page
+c0114477 T kmap_atomic_prot
+c01144fd T kmap_atomic
+c0114508 T kunmap
+c0114546 T kunmap_atomic
+c01145a9 T kmap
+c01145fd t static_prio_timeslice
+c011462c T task_curr
+c011464d T weighted_cpuload
+c0114662 t __wake_up_common
+c01146b7 T __wake_up_locked
+c01146d8 T task_prio
+c01146e3 T task_nice
+c01146ee T idle_cpu
+c011470d T idle_task
+c0114722 T sys_sched_get_priority_max
+c011474b T sys_sched_get_priority_min
+c0114774 t touch_cache
+c0114817 t cpu_to_cpu_group
+c0114832 t sched_smt_power_savings_show
+c0114853 t sched_mc_power_savings_show
+c0114874 t sd_degenerate
+c01148ac t schedstat_open
+c0114922 t init_sched_build_groups
+c01149f0 t find_busiest_queue
+c0114a5b t find_busiest_group
+c0114f93 T nr_iowait
+c0114fd2 T nr_context_switches
+c0115018 T nr_running
+c0115054 T nr_onhold
+c0115093 t show_schedstat
+c0115307 T nr_active
+c0115356 T nr_uninterruptible
+c011539c t resched_task
+c01153f5 t effective_prio
+c01154c2 t recalc_task_prio
+c0115555 t set_load_weight
+c01155e3 T complete_all
+c011562c T complete
+c0115674 T __wake_up_sync
+c01156c5 T __wake_up
+c0115708 t double_rq_lock
+c011573e t task_rq_lock
+c0115796 t double_rq_unlock
+c01157b6 t dequeue_task
+c01157e6 t __deactivate_task
+c0115809 t __setscheduler
+c01158fe t requeue_task
+c0115931 t enqueue_task
+c0115974 T set_user_nice
+c0115a45 T rt_mutex_setprio
+c0115ad3 t task_running_tick
+c0115d55 t __activate_task
+c0115d7e T __might_sleep
+c0115e2f t domain_distance
+c0115ed7 t double_lock_balance
+c0115f1f t move_tasks
+c0116255 T in_sched_functions
+c0116283 t cpu_to_phys_group
+c01162bf t cpu_to_core_group
+c01162f9 t init_sched_groups_power
+c01163b2 t cpu_attach_domain
+c0116461 T sched_create_sysfs_power_savings_entries
+c011649e t sched_balance_self
+c01166d3 t migrate_task
+c011673a T sched_getaffinity
+c01167b2 T sys_sched_getaffinity
+c01167f3 T sys_sched_rr_get_interval
+c0116880 T can_nice
+c01168b2 T sched_setscheduler
+c0116af3 t do_sched_setscheduler
+c0116b55 T sys_sched_setparam
+c0116b64 T sys_sched_setscheduler
+c0116b81 t try_to_wake_up
+c0116fb6 T default_wake_function
+c0116fc2 T wake_up_state
+c0116fcd T wake_up_process
+c0116fdd t run_rebalance_domains
+c0117394 t __cond_resched
+c01173d0 T sys_sched_yield
+c011746e T set_cpus_allowed
+c01174fe t measure_one
+c0117663 t arch_init_sched_domains
+c01182e0 T arch_reinit_sched_domains
+c0118336 t sched_power_savings_store
+c0118380 t sched_smt_power_savings_store
+c011838f t sched_mc_power_savings_store
+c011839b T sched_setaffinity
+c011846b T sys_sched_setaffinity
+c01184ac T account_steal_time
+c0118518 T account_user_time
+c011859a T current_sched_time
+c01185de T account_system_time
+c01186aa T schedule_tail
+c0118739 T sched_exec
+c01187d1 T scheduler_tick
+c01188be T sys_nice
+c011895a t migration_thread
+c0118bc3 T sched_fork
+c0118c6f T show_state_filter
+c0118dcd T normalize_rt_tasks
+c0118f0c T kick_process
+c0118f3f T cond_resched_lock
+c0118f7b T wait_task_inactive
+c0118fd7 T sched_exit
+c0119050 T wake_up_new_task
+c0119236 T sys_sched_getscheduler
+c0119282 T sys_sched_getparam
+c011931a T __cleanup_signal
+c0119326 T __cleanup_sighand
+c011933d T copy_fs_struct
+c0119419 t sighand_ctor
+c0119442 t dup_fd
+c01196d7 t copy_files
+c0119728 t mm_init
+c011981f T mm_release
+c01198a6 T __mmdrop
+c01198ee T mmput
+c0119963 T free_task
+c01199b9 t copy_process
+c011ad2e T nr_processes
+c011ad65 T __put_task_struct
+c011ae43 T mm_alloc
+c011ae7f T unshare_files
+c011aebe T sys_set_tid_address
+c011aedc T do_fork
+c011b13c T sys_unshare
+c011b46d T get_task_mm
+c011b4a4 T get_exec_domain_list
+c011b520 T __set_personality
+c011b693 T unregister_exec_domain
+c011b6df T register_exec_domain
+c011b738 t default_handler
+c011b78a T sys_personality
+c011b7c8 t no_blink
+c011b7cb T add_taint
+c011b7dc T oops_may_print
+c011b7e9 t spin_msec
+c011b808 t do_oops_enter_exit
+c011b8b9 T oops_exit
+c011b8be T oops_enter
+c011b8c8 T print_tainted
+c011b9b6 T panic
+c011baa4 t __call_console_drivers
+c011baff t _call_console_drivers
+c011bb58 t emit_log_char
+c011bbb8 T is_console_locked
+c011bbbe T tty_write_message
+c011bbe8 T printk_timed_ratelimit
+c011bc18 T wake_up_klogd
+c011bc4d T release_console_sem
+c011bdea T resume_console
+c011bdf9 T acquire_console_sem
+c011be72 T unregister_console
+c011bedf T console_start
+c011bef7 T console_stop
+c011bf0f T console_device
+c011bf48 T console_unblank
+c011bfad W printk_clock
+c011bfb2 T vprintk
+c011c287 T printk
+c011c2a6 T __printk_ratelimit
+c011c346 T printk_ratelimit
+c011c356 T register_console
+c011c56e T console_print
+c011c584 T suspend_console
+c011c5a4 T do_syslog
+c011c8e1 T sys_syslog
+c011c8f2 T try_acquire_console_sem
+c011c928 T register_timer_hook
+c011c940 t __profile_flip_buffers
+c011c960 T profile_hits
+c011ca50 T create_prof_cpu_mask
+c011ca7b t write_profile
+c011cb6a t read_profile
+c011ccd9 t prof_cpu_mask_write_proc
+c011cd0b t prof_cpu_mask_read_proc
+c011cd51 T profile_tick
+c011cdaf T unregister_timer_hook
+c011cdf5 T profile_event_unregister
+c011ce15 T profile_event_register
+c011ce35 T task_handoff_unregister
+c011ce41 T task_handoff_register
+c011ce4d T profile_munmap
+c011ce5b T profile_task_exit
+c011ce69 T profile_handoff_task
+c011ce80 t will_become_orphaned_pgrp
+c011ceee t has_stopped_jobs
+c011cf14 t eligible_child
+c011cfb3 t wait_noreap_copyout
+c011d064 t delayed_put_task_struct
+c011d080 t exit_mm
+c011d157 T exit_fs
+c011d201 T put_fs_struct
+c011d279 t reparent_thread
+c011d3e0 T put_files_struct
+c011d4a3 T exit_files
+c011d4de T reset_files_struct
+c011d511 T __set_special_pids
+c011d5a1 T session_of_pgrp
+c011d5d1 T release_task
+c011d868 t do_wait
+c011e255 T sys_wait4
+c011e289 T sys_waitpid
+c011e2b4 T sys_waitid
+c011e315 T do_exit
+c011eb9c T do_group_exit
+c011ec09 T sys_exit_group
+c011ec16 T sys_exit
+c011ec23 T complete_and_exit
+c011ec36 T is_current_pgrp_orphaned
+c011ec6a T disallow_signal
+c011ecc9 T daemonize
+c011ef10 T allow_signal
+c011ef88 T get_files_struct
+c011efb4 t itimer_get_remtime
+c011efe0 T do_setitimer
+c011f2d3 T sys_setitimer
+c011f352 T alarm_setitimer
+c011f3b0 T do_getitimer
+c011f51c T sys_getitimer
+c011f55b T it_real_fn
+c011f570 T current_kernel_time
+c011f5a7 T jiffies_to_msecs
+c011f5a8 T jiffies_to_usecs
+c011f5af T timespec_trunc
+c011f5dc T mktime
+c011f65a T set_normalized_timespec
+c011f67e T msecs_to_jiffies
+c011f68b T timespec_to_jiffies
+c011f6e2 T timeval_to_jiffies
+c011f73a T jiffies_to_timeval
+c011f76b T jiffies_to_clock_t
+c011f79f T clock_t_to_jiffies
+c011f7af T jiffies_64_to_clock_t
+c011f7f2 T nsec_to_clock_t
+c011f81f T get_jiffies_64
+c011f852 T ns_to_timespec
+c011f8bd T ns_to_timeval
+c011f8e9 T sys_adjtimex
+c011f934 T sys_stime
+c011f975 T do_sys_settimeofday
+c011fa1c T sys_settimeofday
+c011fa8d T sys_gettimeofday
+c011fae0 T sys_time
+c011fb0e T jiffies_to_timespec
+c011fb2c T current_fs_time
+c011fb74 T usecs_to_jiffies
+c011fb98 T open_softirq
+c011fba7 T tasklet_init
+c011fbc2 T on_each_cpu
+c011fbe9 T raise_softirq_irqoff
+c011fc38 T tasklet_kill
+c011fc86 T _local_bh_enable
+c011fd2a T __local_bh_enable
+c011fddd T local_bh_enable
+c011fe66 T local_bh_enable_ip
+c011fea6 T irq_exit
+c011fedc t ksoftirqd
+c011ff63 T __do_softirq
+c0120024 T irq_enter
+c0120033 t tasklet_action
+c01200c3 t tasklet_hi_action
+c0120153 T local_bh_disable
+c0120162 T raise_softirq
+c01201b8 T __tasklet_schedule
+c0120221 T __tasklet_hi_schedule
+c012028c t r_next
+c01202a9 t __request_resource
+c0120323 t devm_region_match
+c012035e t iomem_open
+c0120384 t ioports_open
+c01203aa t r_show
+c012043d t r_stop
+c0120447 t r_start
+c0120499 T adjust_resource
+c012055a T insert_resource
+c01206a9 T allocate_resource
+c012083b T release_resource
+c0120880 T request_resource
+c01208b2 T __release_region
+c01209b1 T __devm_release_region
+c0120a37 t devm_region_release
+c0120a5d T __request_region
+c0120aed T __devm_request_region
+c0120b7e T __check_region
+c0120bc0 t sysctl_set_parent
+c0120bea t fixup_table_addr
+c0120c0a t table_fixup
+c0120c7c t count_table_entries
+c0120ca7 t copy_table_entries
+c0120cf6 t do_proc_dointvec_conv
+c0120d25 t do_proc_dointvec_bset_conv
+c0120d74 t do_proc_dointvec_minmax_conv
+c0120dcb t do_proc_dointvec_jiffies_conv
+c0120e2c T sysctl_intvec
+c0120eab T sysctl_jiffies
+c0120f44 T sysctl_string
+c012101f T sysctl_data
+c01210bb t do_proc_doulongvec_minmax
+c0121373 T proc_doulongvec_ms_jiffies_minmax
+c01213a8 T proc_doulongvec_minmax
+c01213dd t __do_proc_dointvec
+c012168c t proc_do_cad_pid
+c0121710 t do_proc_dointvec
+c0121756 T proc_dointvec_ms_jiffies
+c012178b T proc_dointvec_userhz_jiffies
+c01217c0 T proc_dointvec_jiffies
+c01217f5 T proc_dointvec_minmax
+c012183a T proc_dointvec
+c012186f T proc_dostring
+c0121984 t proc_dointvec_taint
+c01219ea T proc_dointvec_bset
+c0121a5f T sysctl_ms_jiffies
+c0121af0 t do_proc_dointvec_ms_jiffies_conv
+c0121b35 t do_proc_dointvec_userhz_jiffies_conv
+c0121b8c t sysctl_net_init
+c0121be3 t __register_sysctl_table
+c0121c4c T register_net_sysctl_table
+c0121c87 T register_sysctl_table
+c0121c93 T unregister_sysctl_table
+c0121d12 T unregister_net_sysctl_table
+c0121d17 T sysctl_perm
+c0121d57 T do_sysctl_strategy
+c0121e0f t unuse_table
+c0121e29 T sysctl_head_next
+c0121eae T sysctl_head_finish
+c0121ed3 T do_sysctl
+c0121fdc T sys_sysctl
+c0122038 T __capable
+c0122053 T capable
+c0122060 T sys_capget
+c0122168 T sys_capset
+c0122430 T ptrace_get_task_struct
+c0122479 T ptrace_traceme
+c01224c9 T ptrace_request
+c01226b9 T ptrace_writedata
+c0122751 T ptrace_readdata
+c01227eb t may_attach
+c01228f4 T ptrace_may_attach
+c012291f T ptrace_check_attach
+c01229bf T ptrace_untrace
+c0122a0a T __ptrace_unlink
+c0122a87 T ptrace_detach
+c0122ada T __ptrace_link
+c0122b3d T ptrace_attach
+c0122c22 T sys_ptrace
+c0122cd8 T __round_jiffies
+c0122d1e T __round_jiffies_relative
+c0122d34 T round_jiffies
+c0122d40 T round_jiffies_relative
+c0122d4c T init_timer
+c0122d65 T init_timer_deferrable
+c0122d73 t internal_add_timer
+c0122e00 t cascade
+c0122e4f t run_timer_softirq
+c0122fac T do_sysinfo
+c01230dd T sys_sysinfo
+c0123107 t process_timeout
+c012310c T sys_alarm
+c0123115 T do_timer
+c01231ba T run_local_timers
+c01231c9 t lock_timer_base
+c01231fe T try_to_del_timer_sync
+c0123248 T del_timer_sync
+c012325c T __mod_timer
+c01232f8 T msleep
+c012330a T msleep_interruptible
+c0123338 T update_process_times
+c0123396 T sys_getppid
+c01233d7 T sys_getuid
+c01233e4 T sys_geteuid
+c01233f1 T sys_getgid
+c01233fe T sys_getegid
+c012340b T sys_gettid
+c0123418 T mod_timer
+c0123437 T del_timer
+c012347e T add_timer_on
+c01234ca T sys_getpid
+c0123504 T free_uid
+c0123544 T switch_uid
+c012358d T find_user
+c01235ff T alloc_uid
+c012372c T next_signal
+c012375b T unhandled_signal
+c0123787 T do_no_restart_syscall
+c0123790 T do_sigpending
+c0123825 T sys_sigpending
+c0123833 T sys_rt_sigpending
+c0123840 t recalc_sigpending_tsk
+c01238a0 T recalc_sigpending
+c01238bd T sigprocmask
+c012397a t sig_ignored
+c01239c6 t __sigqueue_free
+c01239f5 t rm_from_queue
+c0123a50 t rm_from_queue_full
+c0123ab6 t __dequeue_signal
+c0123bd2 T flush_sigqueue
+c0123c01 t check_kill_permission
+c0123cc3 T lock_task_sighand
+c0123cff T flush_signals
+c0123d4b T ignore_signals
+c0123d72 t __sigqueue_alloc
+c0123dcb t send_signal
+c0123ec3 T copy_siginfo_to_user
+c0124045 T signal_wake_up
+c0124071 t __group_complete_signal
+c012428e T __group_send_sig_info
+c012430d t do_notify_parent_cldstop
+c012440b t finish_stop
+c012446f t ptrace_stop
+c01245b7 t handle_stop_signal
+c0124736 T send_group_sigqueue
+c0124805 T do_notify_parent
+c0124965 T group_send_sig_info
+c01249bb T send_group_sig_info
+c01249eb T kill_pid_info
+c0124a67 T kill_pid
+c0124a7b T kill_proc_info
+c0124ad4 T sys_rt_sigqueueinfo
+c0124b22 T kill_proc
+c0124b36 T __kill_pgrp_info
+c0124b85 T kill_pgrp_info
+c0124bb5 T kill_pgrp
+c0124bc9 t specific_send_sig_info
+c0124c5a t do_tkill
+c0124d24 T sys_tkill
+c0124d3d T sys_tgkill
+c0124d5c T send_sig_info
+c0124dc4 T send_sig
+c0124dd6 T recalc_sigpending_and_wake
+c0124dee T do_sigaction
+c0124f3b T sys_signal
+c0124f78 T sys_rt_sigaction
+c0124fef T force_sig_info
+c0125072 T force_sig
+c012507e T force_sigsegv
+c01250c8 T force_sig_specific
+c01250d4 T dequeue_signal
+c01251f3 T sys_restart_syscall
+c0125202 T block_all_signals
+c0125260 T unblock_all_signals
+c01252b7 T sigqueue_alloc
+c01252d2 T sigqueue_free
+c0125322 T ptrace_notify
+c01253b0 T get_signal_to_deliver
+c0125794 T sys_kill
+c01258c0 T do_sigaltstack
+c01259b9 T sys_sgetmask
+c01259c6 T sys_ssetmask
+c0125a24 T sys_pause
+c0125a3b T sys_rt_sigsuspend
+c0125b03 T flush_signal_handlers
+c0125b3e T sys_rt_sigprocmask
+c0125bf7 T sys_sigprocmask
+c0125cfe T sys_rt_sigtimedwait
+c0125f63 T kill_pid_info_as_uid
+c0126024 T zap_other_threads
+c012608a T send_sigqueue
+c012614c t notifier_chain_register
+c012616b t notifier_chain_unregister
+c012618a T raw_notifier_chain_register
+c012618c T raw_notifier_chain_unregister
+c012618e T __raw_notifier_call_chain
+c0126195 T raw_notifier_call_chain
+c01261af T groups_search
+c0126205 T sys_getcpu
+c012627a t argv_cleanup
+c012627f T getrusage
+c01263fa T __blocking_notifier_call_chain
+c0126441 T blocking_notifier_call_chain
+c012645b T groups_free
+c012648e T set_current_groups
+c01265d4 T groups_alloc
+c012668b t set_user
+c012670f T ctrl_alt_del
+c0126736 T blocking_notifier_chain_unregister
+c0126770 T unregister_reboot_notifier
+c012677c T blocking_notifier_chain_register
+c01267b6 T register_reboot_notifier
+c01267c2 T kernel_shutdown_prepare
+c01267e8 t kernel_restart_prepare
+c0126808 T kernel_power_off
+c0126827 T orderly_poweroff
+c01268cc T kernel_halt
+c01268eb T kernel_restart
+c0126922 t deferred_cad
+c0126929 T emergency_restart
+c012692e t set_one_prio
+c01269d0 T srcu_init_notifier_head
+c01269fb T __srcu_notifier_call_chain
+c0126a4a T srcu_notifier_call_chain
+c0126a64 T srcu_notifier_chain_register
+c0126a9e T srcu_notifier_chain_unregister
+c0126ae0 T atomic_notifier_chain_register
+c0126b09 T atomic_notifier_chain_unregister
+c0126b37 T sys_setgroups
+c0126c11 T sys_reboot
+c0126de4 T sys_getresuid
+c0126e21 T sys_getresgid
+c0126e5e T sys_setfsgid
+c0126ec6 T sys_times
+c0126f9b T sys_setsid
+c0127046 T sys_getgroups
+c01270ed T in_group_p
+c012710e T in_egroup_p
+c012712f T sys_setrlimit
+c0127332 T sys_getrusage
+c0127353 T sys_umask
+c012736d T sys_prctl
+c0127492 T sys_getpgrp
+c01274a5 T sys_getsid
+c01274f8 T sys_newuname
+c012753b T sys_sethostname
+c0127603 T sys_gethostname
+c0127672 T sys_setdomainname
+c0127740 T sys_setregid
+c012782b T sys_setgid
+c01278d2 T sys_setresgid
+c01279d0 T sys_setfsuid
+c0127a50 T sys_setpgid
+c0127c13 T sys_getpgid
+c0127cd9 T sys_getrlimit
+c0127d51 T sys_old_getrlimit
+c0127ded T sys_setreuid
+c0127f32 T sys_setuid
+c0127ff7 T sys_setresuid
+c0128156 T sys_setpriority
+c0128317 T sys_getpriority
+c01284c4 T call_usermodehelper_setkeys
+c01284c8 T call_usermodehelper_setcleanup
+c01284cc T call_usermodehelper_stdinpipe
+c0128505 T call_usermodehelper_setup
+c0128548 t __call_usermodehelper
+c0128593 T call_usermodehelper_freeinfo
+c01285ad T call_usermodehelper_exec
+c012863a T call_usermodehelper_pipe
+c012867a t wait_for_helper
+c01286ef T request_module
+c01287d9 t ____call_usermodehelper
+c01288f8 T keventd_up
+c0128905 T current_is_keventd
+c0128931 t wq_per_cpu
+c0128944 t try_to_grab_pending
+c01289a7 t run_workqueue
+c0128aa4 t insert_work
+c0128af7 t insert_wq_barrier
+c0128b37 t flush_cpu_workqueue
+c0128b99 T destroy_workqueue
+c0128c1a t wq_barrier_func
+c0128c22 t init_cpu_workqueue
+c0128c53 t create_workqueue_thread
+c0128c9f t start_workqueue_thread
+c0128cbc T __create_workqueue
+c0128dd5 t __queue_work
+c0128dfd T delayed_work_timer_fn
+c0128e19 T queue_work
+c0128e55 T schedule_work
+c0128e61 T execute_in_process_context
+c0128e99 t wait_on_work
+c0128f37 T cancel_rearming_delayed_work
+c0128f63 T flush_workqueue
+c0128fb1 T flush_scheduled_work
+c0128fbb T queue_delayed_work_on
+c0129055 T schedule_delayed_work_on
+c012906a T queue_delayed_work
+c0129088 T schedule_delayed_work
+c0129096 T cancel_work_sync
+c01290b6 T schedule_on_each_cpu
+c012913f t worker_thread
+c0129204 T find_pid
+c012923d T attach_pid
+c0129263 T transfer_pid
+c01292ae T pid_task
+c01292d6 T get_pid_task
+c01292e4 T find_get_pid
+c01292f1 T free_pid_ns
+c01292f6 T copy_pid_ns
+c012930c T find_ge_pid
+c012937f T put_pid
+c012939f t delayed_put_pid
+c01293a7 T free_pid
+c012940b T detach_pid
+c0129453 T find_task_by_pid_type
+c01294e0 T alloc_pid
+c0129712 T get_task_pid
+c0129724 T rcu_batches_completed
+c012972a T rcu_batches_completed_bh
+c0129730 t __rcu_pending
+c0129764 T rcu_pending
+c01297a2 T rcu_needs_cpu
+c01297dc t rcu_init_percpu_data
+c012982e t wakeme_after_rcu
+c0129836 t rcu_barrier_callback
+c012984f t rcu_start_batch
+c0129888 t __rcu_process_callbacks
+c01299fa t rcu_process_callbacks
+c0129a28 t force_quiescent_state
+c0129a7d T call_rcu
+c0129ac7 T synchronize_rcu
+c0129af6 t rcu_barrier_func
+c0129b1d T call_rcu_bh
+c0129b67 T rcu_check_callbacks
+c0129bec T rcu_barrier
+c0129c58 T core_kernel_text
+c0129c81 T kernel_text_address
+c0129ca4 T __kernel_text_address
+c0129cc7 T search_exception_tables
+c0129cec T param_set_bool
+c0129d32 T param_set_invbool
+c0129d75 T param_array_get
+c0129dd7 t param_attr_show
+c0129e0d t param_attr_store
+c0129e2a t module_attr_show
+c0129e48 t module_attr_store
+c0129e71 t uevent_filter
+c0129e8d T param_set_copystring
+c0129ef8 t param_sysfs_setup
+c0129fc0 T module_param_sysfs_setup
+c0129fe7 T module_param_sysfs_remove
+c012a013 T param_get_string
+c012a020 T param_array_set
+c012a0ff T param_get_bool
+c012a128 T param_get_invbool
+c012a162 T param_get_charp
+c012a182 T param_get_ulong
+c012a1a2 T param_get_long
+c012a1c2 T param_get_uint
+c012a1e2 T param_get_int
+c012a202 T param_get_ushort
+c012a223 T param_get_short
+c012a244 T param_get_byte
+c012a265 T param_set_ulong
+c012a294 T param_set_uint
+c012a2c3 T param_set_ushort
+c012a2f8 T param_set_byte
+c012a32e T param_set_long
+c012a35d T param_set_int
+c012a38c T param_set_short
+c012a3c1 T param_set_charp
+c012a41e T parse_args
+c012a618 T do_posix_clock_nosettime
+c012a61e T do_posix_clock_nonanosleep
+c012a624 t posix_ktime_get_ts
+c012a62e T clock_nanosleep_restart
+c012a657 T sys_clock_nanosleep
+c012a714 t release_posix_timer
+c012a776 T exit_itimers
+c012a830 t lock_timer
+c012a8ab t common_timer_get
+c012a9a5 T register_posix_clock
+c012a9d4 T posix_timer_event
+c012ab05 T sys_timer_create
+c012adee T sys_clock_settime
+c012ae6b T sys_clock_gettime
+c012aee9 T sys_clock_getres
+c012af69 T do_schedule_next_timer
+c012b012 t posix_timer_fn
+c012b0a4 T sys_timer_gettime
+c012b11b T sys_timer_getoverrun
+c012b148 T sys_timer_settime
+c012b397 T sys_timer_delete
+c012b480 T kthread_should_stop
+c012b493 T kthread_stop
+c012b4ff T kthread_bind
+c012b55c T kthreadd
+c012b661 T kthread_create
+c012b705 t kthread
+c012b764 T bit_waitqueue
+c012b7ac T __wake_up_bit
+c012b7df T wake_up_bit
+c012b7f5 T autoremove_wake_function
+c012b82a T wake_bit_function
+c012b866 T finish_wait
+c012b8ae T prepare_to_wait_exclusive
+c012b8f0 T add_wait_queue_exclusive
+c012b91b T prepare_to_wait
+c012b95a T add_wait_queue
+c012b982 T remove_wait_queue
+c012b9a4 T init_waitqueue_head
+c012b9c4 T kfifo_free
+c012b9d6 T kfifo_init
+c012ba29 T kfifo_alloc
+c012ba9c T __kfifo_put
+c012bb0f T __kfifo_get
+c012bb88 W compat_sys_futex
+c012bb88 W compat_sys_get_mempolicy
+c012bb88 W compat_sys_get_robust_list
+c012bb88 W compat_sys_ipc
+c012bb88 W compat_sys_kexec_load
+c012bb88 W compat_sys_keyctl
+c012bb88 W compat_sys_mbind
+c012bb88 W compat_sys_migrate_pages
+c012bb88 W compat_sys_move_pages
+c012bb88 W compat_sys_mq_getsetattr
+c012bb88 W compat_sys_mq_notify
+c012bb88 W compat_sys_mq_open
+c012bb88 W compat_sys_mq_timedreceive
+c012bb88 W compat_sys_mq_timedsend
+c012bb88 W compat_sys_set_mempolicy
+c012bb88 W compat_sys_set_robust_list
+c012bb88 W compat_sys_signalfd
+c012bb88 W compat_sys_socketcall
+c012bb88 W compat_sys_sysctl
+c012bb88 W compat_sys_timerfd
+c012bb88 W ppc_rtas
+c012bb88 W sys32_ipc
+c012bb88 W sys32_sysctl
+c012bb88 W sys_add_key
+c012bb88 W sys_get_mempolicy
+c012bb88 W sys_keyctl
+c012bb88 W sys_mbind
+c012bb88 W sys_migrate_pages
+c012bb88 W sys_move_pages
+c012bb88 W sys_nfsservctl
+c012bb88 T sys_ni_syscall
+c012bb88 W sys_pciconfig_iobase
+c012bb88 W sys_pciconfig_read
+c012bb88 W sys_pciconfig_write
+c012bb88 W sys_request_key
+c012bb88 W sys_set_mempolicy
+c012bb88 W sys_spu_create
+c012bb88 W sys_spu_run
+c012bb88 W sys_timerfd
+c012bb90 t bump_cpu_timer
+c012bcc0 t cleanup_timers
+c012bd8b T posix_cpu_timers_exit
+c012bdbd T posix_cpu_timers_exit_group
+c012be0d t process_cpu_nsleep_restart
+c012be13 t thread_cpu_nsleep
+c012be19 t thread_cpu_nsleep_restart
+c012be1f t process_timer_rebalance
+c012bfa0 t sample_to_timespec
+c012bfd3 t cpu_clock_sample_group_locked
+c012c0bf T set_process_cpu_timer
+c012c173 t cpu_clock_sample
+c012c1c8 t clear_dead_task
+c012c210 t cpu_clock_sample_group
+c012c255 t arm_timer
+c012c485 T posix_cpu_timer_schedule
+c012c587 t cpu_timer_fire
+c012c5d7 T run_posix_cpu_timers
+c012ccc4 T posix_cpu_timer_set
+c012d07a T posix_cpu_timer_create
+c012d160 t thread_cpu_timer_create
+c012d16c t process_cpu_timer_create
+c012d178 t do_cpu_nanosleep
+c012d2b7 T posix_cpu_nsleep_restart
+c012d33e T posix_cpu_nsleep
+c012d3f0 t process_cpu_nsleep
+c012d3fa T posix_cpu_clock_get
+c012d4de t thread_cpu_clock_get
+c012d4e8 t process_cpu_clock_get
+c012d4f2 t check_clock
+c012d564 T posix_cpu_clock_set
+c012d574 T posix_cpu_clock_getres
+c012d5a2 t thread_cpu_clock_getres
+c012d5ac t process_cpu_clock_getres
+c012d5b6 T posix_cpu_timer_get
+c012d79c T posix_cpu_timer_del
+c012d83c t __mutex_trylock_slowpath
+c012d871 T __mutex_init
+c012d898 T ktime_divns
+c012d90d T hrtimer_init
+c012d94a T hrtimer_init_sleeper
+c012d955 T hrtimer_get_res
+c012d97f T hrtimer_forward
+c012da4d t hrtimer_wakeup
+c012da65 t __remove_hrtimer
+c012da8c t enqueue_hrtimer
+c012dafe T hrtimer_run_queues
+c012dc49 t lock_hrtimer_base
+c012dc78 T hrtimer_get_remaining
+c012dcac T hrtimer_try_to_cancel
+c012dd0d T hrtimer_cancel
+c012dd21 T hrtimer_start
+c012ddff T hrtimer_nanosleep
+c012dedb T sys_nanosleep
+c012df34 T ktime_get_real
+c012df55 T ktime_get_ts
+c012df9b T ktime_get
+c012dfbc T down_read_trylock
+c012dfd9 T down_write_trylock
+c012dff4 T up_read
+c012e003 T up_write
+c012e014 T downgrade_write
+c012e023 T down_write
+c012e04b T down_read
+c012e06c T system_latency_constraint
+c012e072 T unregister_latency_notifier
+c012e07e T register_latency_notifier
+c012e08a T synchronize_acceptable_latency
+c012e09c T remove_acceptable_latency
+c012e141 T set_acceptable_latency
+c012e234 T modify_acceptable_latency
+c012e2a0 t create_new_namespaces
+c012e3e3 T free_nsproxy
+c012e448 T copy_nsproxy
+c012e4a1 T unshare_nsproxy_namespaces
+c012e51d T get_task_namespaces
+c012e52b T copy_namespaces
+c012e5b4 T srcu_read_lock
+c012e5ce T srcu_read_unlock
+c012e5e1 T srcu_batches_completed
+c012e5e4 t srcu_readers_active_idx
+c012e61f T synchronize_srcu
+c012e673 T srcu_readers_active
+c012e693 T cleanup_srcu_struct
+c012e6e1 T init_srcu_struct
+c012e720 T unregister_die_notifier
+c012e72c T register_die_notifier
+c012e741 T notify_die
+c012e778 T free_uts_ns
+c012e784 T copy_utsname
+c012e7e8 T sys_vserver
+c012f51c T vx_mask_cap_bset
+c012f538 T vx_set_init
+c012f557 T vx_exit_init
+c012f565 T vx_set_persistent
+c012f572 t do_get_caps
+c012f59b t do_set_caps
+c012f5fe T vc_set_badness
+c012f62e T vc_set_bcaps
+c012f692 T vc_set_ccaps
+c012f6f2 T vc_get_badness
+c012f721 T vc_get_bcaps
+c012f769 T vc_get_ccaps
+c012f7b1 T vc_get_cflags
+c012f7f8 T vc_ctx_stat
+c012f827 T vc_vx_info
+c012f856 T xid_is_hashed
+c012f8a7 t __dealloc_vx_info
+c012fa08 T vx_set_reaper
+c012fa36 T vx_migrate_user
+c012fa97 T free_vx_info
+c012fb0f T unhash_vx_info
+c012fc1b T vx_clear_persistent
+c012fc58 T vx_update_persistent
+c012fc7f T vx_migrate_task
+c012fed1 T get_xid_list
+c012ff6c T vc_task_xid
+c012ffb4 T vc_ctx_migrate
+c0130039 T vc_set_cflags
+c0130160 T lookup_vx_info
+c01301d5 T exit_vx_info
+c0130222 T exit_vx_info_early
+c013025c T vc_ctx_create
+c0130838 T vc_get_space_mask
+c0130854 T vs_mix_nsproxy
+c013091f T vx_set_space
+c0130a87 T vc_set_space
+c0130ac7 T vx_enter_space
+c0130c43 T vc_enter_space
+c0130c84 T vx_update_sched_param
+c0130d00 t do_set_sched
+c0130f15 T vc_set_sched
+c0130f44 T vc_set_sched_v4
+c0130fc2 T vx_tokens_recalc
+c013110f T vc_get_sched
+c013121e T vc_sched_info
+c01312d4 T nx_set_persistent
+c01312e1 T vc_set_ncaps
+c0131334 T vc_get_ncaps
+c0131374 T vc_get_nflags
+c01313bb T vc_nx_info
+c01313e2 T vc_net_remove_ipv6
+c013143e T do_add_v6_addr
+c01314e1 T vc_net_add_ipv6
+c0131546 T do_add_v4_addr
+c01315e6 T vc_net_add_ipv4
+c0131675 T vc_net_add
+c013171b T nid_is_hashed
+c013176c T unhash_nx_info
+c01317d2 T __nx_set_lback
+c01317e5 t __dealloc_nx_info
+c0131839 T free_nx_info
+c013185c T nx_clear_persistent
+c0131899 T nx_update_persistent
+c01318c0 T vc_set_nflags
+c013197c T nx_migrate_task
+c0131a97 T vc_net_migrate
+c0131aa4 T vc_net_remove_ipv4
+c0131b00 T get_nid_list
+c0131b9c T vc_task_nid
+c0131be4 T lookup_nx_info
+c0131c59 T vc_net_remove
+c0131cb5 T vc_net_create
+c0131ee0 t __vc_get_iattr
+c0131fe5 t __dx_parse_remove
+c0132015 T dx_parse_tag
+c01320f9 T vc_fget_iattr
+c013218a t __vc_set_iattr
+c0132360 T vc_fset_iattr
+c01323f1 T vc_set_iattr
+c0132480 T vc_get_iattr
+c0132518 T vc_reset_minmax
+c0132537 T vx_badness
+c01325cc T vc_set_rlimit
+c0132665 T vc_rlimit_stat
+c013279d T vc_get_rlimit_mask
+c01327b9 T vc_get_rlimit
+c0132839 T vx_vsi_meminfo
+c01328e2 T vx_vsi_swapinfo
+c01329a8 T vx_idle_jiffies
+c01329b6 t vx_vhi_name
+c01329fe T vc_virt_stat
+c0132ad1 T vc_get_vhi_name
+c0132b30 T vc_set_vhi_name
+c0132b77 T vx_vsi_uptime
+c0132bbf T vx_do_syslog
+c0132c98 T vx_update_load
+c0132e84 T vc_sock_stat
+c0132f1c T vc_wait_exit
+c0132fdf T vx_info_kill
+c01330c9 T vc_ctx_kill
+c0133124 t do_vshelper
+c013318d T vs_net_change
+c0133274 T vs_state_change
+c013335b T vs_reboot_helper
+c0133527 T vs_reboot
+c013359c T locate_dl_info
+c01335df T vx_vsi_statfs
+c01337c7 T vc_get_dlimit
+c01338fb T vc_set_dlimit
+c0133ab2 t __dealloc_dl_info
+c0133adf t do_addrem_dlimit
+c0133ce8 T vc_rem_dlimit
+c0133d24 T vc_add_dlimit
+c0133d60 T rcu_free_dl_info
+c0133da4 T dx_migrate_task
+c0133dd3 T vc_tag_migrate
+c0133de4 T vc_task_tag
+c0133e2c T nx_v4_addr_conflict
+c0133ebf T nx_v6_addr_conflict
+c0133f56 T v6_dev_in_nx_info
+c0134021 T v4_dev_in_nx_info
+c0134102 T dev_in_nx_info
+c0134145 T ip_v4_find_src
+c01343e4 T proc_nxi_status
+c0134427 t proc_virtnet_status
+c0134452 T proc_vxi_status
+c01344aa T proc_vxi_info
+c01344e3 t proc_virtual_status
+c0134540 t proc_vci
+c0134577 t proc_virtnet_info
+c0134579 t proc_virtual_info
+c013457b T proc_vxi_limit
+c0134b54 T proc_vxi_cacct
+c0134cd2 T proc_pid_vx_info
+c0134dc5 T proc_vx_init
+c0134e0c t proc_virtnet_getattr
+c0134e28 t proc_virtual_getattr
+c0134e44 t proc_fill_cache
+c0134f4e t vs_proc_instantiate
+c0135005 t proc_nid_instantiate
+c0135013 t proc_virtnet_lookup
+c01350a2 t proc_xid_instantiate
+c01350b0 T proc_virtnet_readdir
+c0135282 T proc_vxi_cvirt
+c013538e T proc_vxi_sched
+c013555b T proc_vxi_nsproxy
+c0135700 T proc_nxi_info
+c0135a72 T proc_pid_nx_info
+c0135ef5 t proc_nid_revalidate
+c0135f63 t proc_vs_info_read
+c0136009 t proc_xid_lookup
+c0136052 t proc_nid_lookup
+c013609b t proc_virtual_lookup
+c013612a t proc_xid_readdir
+c013625a t proc_nid_readdir
+c013638a T proc_virtual_readdir
+c013655c t proc_xid_revalidate
+c01365ca t proc_nx_info_read
+c013669c t proc_vx_info_read
+c0136770 T timekeeping_is_continuous
+c01367a2 T monotonic_to_bootbased
+c01367ab T getboottime
+c01367c6 T do_gettimeofday
+c013689c T update_wall_time
+c0136f4d t timekeeping_suspend
+c0136f97 T do_settimeofday
+c0137087 t timekeeping_resume
+c0137129 T getnstimeofday
+c01371e8 t ntp_update_frequency
+c0137295 T ntp_clear
+c01372ea T current_tick_length
+c01372f7 T do_adjtimex
+c01377e9 T second_overflow
+c01379fc t select_clocksource
+c0137a23 T clocksource_get_next
+c0137a62 t sysfs_show_available_clocksources
+c0137acd t sysfs_show_current_clocksources
+c0137b21 t clocksource_enqueue
+c0137bae T clocksource_change_rating
+c0137bec T clocksource_register
+c0137d69 T clocksource_resume
+c0137daf t sysfs_override_clocksource
+c0137e9b t clocksource_watchdog
+c0138108 t jiffies_read
+c0138110 t timer_list_open
+c013811e t print_name_offset
+c013818f t print_tickdevice
+c0138429 t timer_list_show
+c01388d5 T sysrq_timer_list_show
+c01388e0 T clockevent_delta2ns
+c013894e T clockevents_set_mode
+c0138966 T clockevents_program_event
+c0138a09 t clockevents_handle_noop
+c0138a0a t clockevents_do_notify
+c0138a18 T clockevents_notify
+c0138a55 t clockevents_notify_released
+c0138a89 T clockevents_exchange_device
+c0138adb T clockevents_release_device
+c0138b01 T clockevents_request_device
+c0138b67 T clockevents_register_device
+c0138ba4 T clockevents_unregister_notifier
+c0138bc8 T clockevents_register_notifier
+c0138bf4 T tick_get_device
+c0138c03 T tick_is_oneshot_available
+c0138c26 T tick_setup_periodic
+c0138cb6 t tick_notify
+c0138f3f t tick_periodic
+c0138fac T tick_handle_periodic
+c0139014 T tick_get_broadcast_device
+c013901a T tick_get_broadcast_mask
+c0139020 T tick_is_broadcast_device
+c0139034 T tick_set_periodic_handler
+c0139047 t tick_broadcast_start_periodic
+c013905c T tick_resume_broadcast
+c01390af T tick_device_uses_broadcast
+c01390fb T tick_suspend_broadcast
+c0139131 t tick_do_broadcast_on_off
+c0139209 T tick_do_broadcast
+c013926a t tick_do_periodic_broadcast
+c013928e t tick_handle_periodic_broadcast
+c01392e9 T tick_broadcast_on_off
+c013934a T tick_check_broadcast_device
+c013938c T tick_shutdown_broadcast
+c01393d8 t hash_futex
+c0139462 T get_futex_key_refs
+c013948e t futex_poll
+c01394bd t futexfs_get_sb
+c01394d1 t wake_futex
+c0139516 t futex_handle_fault
+c01395b3 T drop_futex_key_refs
+c01395e9 t unqueue_me
+c013966d t futex_close
+c0139686 T get_futex_key
+c01397a8 t futex_lock_pi
+c013a0c5 t futex_wait
+c013a379 t futex_requeue
+c013a5ad t futex_wake
+c013a660 T do_futex
+c013b026 T sys_futex
+c013b0fa T handle_futex_death
+c013b180 T exit_pi_state_list
+c013b28e t futex_wait_restart
+c013b2c9 T sys_set_robust_list
+c013b2e9 T sys_get_robust_list
+c013b371 T exit_robust_list
+c013b428 t rt_mutex_set_owner
+c013b43e t fixup_rt_mutex_waiters
+c013b44d T rt_mutex_proxy_unlock
+c013b453 T rt_mutex_getprio
+c013b478 T rt_mutex_next_owner
+c013b499 T __rt_mutex_init
+c013b4c6 T rt_mutex_init_proxy_locked
+c013b4e0 T rt_mutex_destroy
+c013b519 t __rt_mutex_adjust_prio
+c013b532 t try_to_take_rt_mutex
+c013b65c t rt_mutex_adjust_prio
+c013b683 T rt_mutex_timed_lock
+c013b6d0 t rt_mutex_adjust_prio_chain
+c013b95f T rt_mutex_adjust_pi
+c013b9b7 t rt_mutex_slowtrylock
+c013b9f0 t proc_dma_open
+c013b9fe t proc_dma_show
+c013ba3e T free_dma
+c013ba75 T request_dma
+c013baa4 T in_lock_functions
+c013babc T sys_setfsgid16
+c013bad8 T sys_setfsuid16
+c013baf4 T sys_setresgid16
+c013bb34 T sys_setresuid16
+c013bb74 T sys_setuid16
+c013bb90 T sys_setreuid16
+c013bbbd T sys_setgid16
+c013bbd9 T sys_setregid16
+c013bc06 T sys_fchown16
+c013bc3c T sys_lchown16
+c013bc72 T sys_chown16
+c013bca8 T sys_setgroups16
+c013bd74 T sys_getresuid16
+c013bdfe T sys_getresgid16
+c013be88 T sys_getgroups16
+c013bf52 T sys_getuid16
+c013bf74 T sys_geteuid16
+c013bf96 T sys_getgid16
+c013bfb8 T sys_getegid16
+c013bfdc t find_sec
+c013c023 t lookup_symbol
+c013c052 t find_module
+c013c093 t modinfo_version_exists
+c013c0a1 t modinfo_srcversion_exists
+c013c0af T module_refcount
+c013c0c8 t get_offset
+c013c0ee t get_modinfo
+c013c172 t get_ksymbol
+c013c34c t mod_find_symname
+c013c3a3 t m_next
+c013c3b8 t taint_flags
+c013c3e6 T __module_text_address
+c013c442 t m_show
+c013c5ae t m_stop
+c013c5b8 T print_modules
+c013c61c t printk_unused_warning
+c013c64a t __find_symbol
+c013c834 t percpu_modinit
+c013c899 t free_sect_attrs
+c013c8bf t free_modinfo_srcversion
+c013c8d9 t free_modinfo_version
+c013c8f3 t make_driver_name
+c013c957 T module_remove_driver
+c013c9b0 t module_sect_show
+c013c9ce t show_initstate
+c013ca18 t show_modinfo_srcversion
+c013ca39 t show_modinfo_version
+c013ca5a T module_add_driver
+c013cae2 T module_text_address
+c013cb0c T __symbol_get
+c013cb77 t percpu_modfree
+c013cc2a t setup_modinfo_srcversion
+c013cc41 t setup_modinfo_version
+c013cc58 t __link_module
+c013cc68 t __unlink_module
+c013cc73 T mod_sysfs_init
+c013cce3 T module_remove_modinfo_attrs
+c013cd1d T module_add_modinfo_attrs
+c013cd95 T mod_sysfs_setup
+c013ce23 T module_put
+c013ce4a T __symbol_put
+c013ce96 t module_unload_free
+c013cf00 t free_module
+c013cfaa T sys_init_module
+c013e617 T symbol_put_addr
+c013e63a T __module_put_and_exit
+c013e649 T unregister_module_notifier
+c013e655 T register_module_notifier
+c013e661 T module_get_kallsym
+c013e738 T module_kallsyms_lookup_name
+c013e7ae t m_start
+c013e7ea T search_module_extables
+c013e852 T is_module_address
+c013e8bb T module_address_lookup
+c013e942 T lookup_module_symbol_name
+c013e9eb T lookup_module_symbol_attrs
+c013eacb t __try_stop_module
+c013eb0a t show_refcnt
+c013eb41 T sys_delete_module
+c013ed7c t kallsyms_expand_symbol
+c013edf4 t get_symbol_offset
+c013ee24 t get_symbol_pos
+c013eee8 t reset_iter
+c013ef08 t s_stop
+c013ef09 t s_show
+c013efc2 t update_iter
+c013f07c t s_start
+c013f099 t s_next
+c013f0c6 t kallsyms_open
+c013f118 t is_ksym_addr
+c013f131 T lookup_symbol_attrs
+c013f19b T lookup_symbol_name
+c013f1d8 T kallsyms_lookup
+c013f259 T sprint_symbol
+c013f306 T __print_symbol
+c013f330 T kallsyms_lookup_size_offset
+c013f371 T kallsyms_lookup_name
+c013f3c4 T pm_valid_only_mem
+c013f3ce W arch_suspend_disable_irqs
+c013f3d0 W arch_suspend_enable_irqs
+c013f3d2 t state_show
+c013f435 T suspend_enter
+c013f492 t enter_state
+c013f601 T pm_suspend
+c013f618 T pm_set_ops
+c013f636 t state_store
+c013f71c t thaw_tasks
+c013f7ff T thaw_processes
+c013f832 t cancel_freezing
+c013f879 t try_to_freeze_tasks
+c013fafa T freeze_processes
+c013fb51 T refrigerator
+c013fc18 T pm_restore_console
+c013fc37 T pm_prepare_console
+c013fca0 t pm_send
+c013fcfb T pm_send_all
+c013fd8b T pm_register
+c013fddc t pm_sysrq_init
+c013fdee t handle_poweroff
+c013fdf8 t do_poweroff
+c013fe00 t acct_timeout
+c013fe0b t encode_comp_t
+c013fe3d T acct_init_pacct
+c013fe5f t do_acct_process
+c0140426 T acct_process
+c014046e t acct_file_reopen
+c014053a T acct_auto_close
+c014056a T acct_auto_close_mnt
+c0140597 T sys_acct
+c014068e T acct_collect
+c01407cc T kexec_should_crash
+c01407fe t kimage_is_destination_range
+c0140839 T crash_save_cpu
+c01409d0 t do_kimage_alloc
+c0140b18 t kimage_alloc_pages
+c0140b76 t kimage_alloc_page
+c0140d04 t kimage_add_entry
+c0140d72 t kimage_free_pages
+c0140d9c t kimage_free_entry
+c0140daa t kimage_free_page_list
+c0140dd0 t kimage_free
+c0140e6e T kimage_alloc_control_pages
+c0140fc4 T sys_kexec_load
+c01414d4 T crash_kexec
+c0141584 T container_is_removed
+c014158a T container_is_releasable
+c0141599 T notify_on_release
+c01415a2 t container_file_release
+c01415ba t container_advance_iter
+c01415e9 T container_iter_next
+c014161d t cmppid
+c0141622 t container_read_releasable
+c014162b T container_fork_callbacks
+c0141655 t containerstats_open
+c0141663 t container_open
+c0141676 T container_lock
+c0141680 T container_set_release_agent_path
+c01416aa T container_unlock
+c01416b4 t container_tasks_release
+c01416d3 t get_first_subsys
+c014170f T container_is_descendant
+c014175b t init_container_root
+c01417ac t check_for_release
+c0141827 t pid_array_to_buf
+c014187d t container_get_dentry
+c01418bd t allocate_cg_links
+c014190f t unlink_css_group
+c014195d t rebind_subsystems
+c0141abf t attach_task
+c0141e06 T container_exit
+c0141e8c t parse_containerfs_options
+c0141f4f t container_tasks_read
+c0141f79 t container_common_file_read
+c014202a t container_clear_directory
+c01420ac t container_rename
+c01420f3 t container_new_inode
+c0142164 t container_create_file
+c0142201 T container_add_file
+c0142256 T container_add_files
+c0142280 t container_populate_dir
+c01422ee t container_remount
+c0142360 t container_mkdir
+c0142523 T container_iter_start
+c0142543 t container_init_subsys
+c0142646 T container_iter_end
+c0142650 T container_task_count
+c0142682 T container_path
+c01426f0 t container_release_agent
+c01427ca t container_fill_super
+c014285e t container_show_options
+c01428ab t proc_containerstats_show
+c0142a02 t container_put_super
+c0142abe t container_rmdir
+c0142c3e t container_get_sb
+c0142e4f t container_diput
+c0142e80 t release_css_group
+c0142ec9 t release_css_group_taskexit
+c0142f22 t container_read_notify_on_release
+c0142f2c T css_put
+c0142f6c t container_file_write
+c0142fb2 t container_file_read
+c0143042 t container_file_open
+c0143078 t container_common_file_write
+c0143232 t container_tasks_open
+c0143395 t proc_container_show
+c01434f2 T container_fork
+c0143537 T container_clone
+c0143794 t cpuacct_populate
+c01437a5 t cpuusage_update
+c0143892 t load_read
+c01438f6 t cpuacct_create
+c0143992 T cpuacct_charge
+c01439e1 t cpuacct_destroy
+c01439e9 t cpuusage_read
+c0143a48 t ns_can_attach
+c0143a95 t ns_destroy
+c0143a9d t ns_create
+c0143af9 T ns_container_clone
+c0143b04 t stopmachine_set_state
+c0143b25 T __stop_machine_run
+c0143bcc T stop_machine_run
+c0143bde t stopmachine
+c0143c6a t do_stop
+c0143d78 t write_enabled_file_bool
+c0143eb5 t read_enabled_file_bool
+c0143ef8 t kexec_crash_loaded_show
+c0143f1f t kexec_loaded_show
+c0143f46 t uevent_helper_show
+c0143f65 t uevent_seqnum_show
+c0143f92 t uevent_helper_store
+c0143fe4 t softlock_panic
+c0143ff1 t get_timestamp
+c0143ffe T touch_softlockup_watchdog
+c0144017 T softlockup_tick
+c01440e7 T touch_all_softlockup_watchdogs
+c014411a t watchdog
+c0144164 t noop
+c0144165 t noop_ret
+c0144168 T no_action
+c014416b t ack_bad
+c014435a T handle_IRQ_event
+c0144399 T __do_IRQ
+c014444c T handle_bad_irq
+c014463c T synchronize_irq
+c0144658 T irq_can_set_affinity
+c0144671 T can_request_irq
+c01446b0 T compat_irq_chip_set_default_handler
+c01446bf T set_irq_wake
+c014477f T disable_irq_nosync
+c01447cc T disable_irq
+c01447f3 T free_irq
+c01448ef T setup_irq
+c0144a78 T request_irq
+c0144b10 T enable_irq
+c0144bb2 T irq_set_affinity
+c0144bdc T noirqdebug_setup
+c0144bfc t __report_bad_irq
+c0144c71 T note_interrupt
+c0144e50 T check_irq_resend
+c0144e90 t default_enable
+c0144eab t default_disable
+c0144eac t default_startup
+c0144ebd T irq_chip_set_defaults
+c0144f0b T __set_irq_handler
+c0145044 T set_irq_chip_data
+c0145099 T set_irq_msi
+c01450f3 T set_irq_data
+c0145140 T set_irq_type
+c01451b9 T handle_percpu_irq
+c014520e T handle_edge_irq
+c014530d T handle_fasteoi_irq
+c01453b8 T handle_simple_irq
+c0145458 T set_irq_chip
+c01454e6 T set_irq_chip_and_handler_name
+c0145508 T set_irq_chip_and_handler
+c014552c T dynamic_irq_cleanup
+c01455f6 T dynamic_irq_init
+c01456b6 T handle_level_irq
+c0145774 t devm_irq_match
+c014578c t devm_irq_release
+c0145798 T devm_free_irq
+c01457f9 T devm_request_irq
+c0145870 T probe_irq_off
+c01458e6 T probe_irq_mask
+c0145956 T probe_irq_on
+c0145a6c T unregister_handler_proc
+c0145a85 T register_irq_proc
+c0145b25 T init_irq_proc
+c0145b4f t irq_affinity_write_proc
+c0145bc8 t irq_affinity_read_proc
+c0145c17 T register_handler_proc
+c0145d00 T move_masked_irq
+c0145d5f T move_native_irq
+c0145d95 T set_pending_irq
+c0145dcc t relay_file_mmap_close
+c0145de0 T relay_mmap_buf
+c0145e24 T relay_buf_empty
+c0145e31 T relay_buf_full
+c0145e44 t buf_mapped_default_callback
+c0145e45 t buf_unmapped_default_callback
+c0145e46 t create_buf_file_default_callback
+c0145e49 t remove_buf_file_default_callback
+c0145e4f T relay_subbufs_consumed
+c0145e73 t relay_file_mmap
+c0145e7e t relay_file_read_consume
+c0145f1b t subbuf_send_actor
+c0145f9c t relay_file_read_subbufs
+c01461ca t relay_file_sendfile
+c0146206 t relay_file_read
+c0146242 t relay_file_release
+c0146258 t relay_file_open
+c0146275 t subbuf_read_actor
+c01462a9 t relay_close_buf
+c01462cb T relay_close
+c014636c T relay_switch_subbuf
+c0146452 T relay_flush
+c01464b7 T relay_destroy_channel
+c01464bf t __relay_reset
+c014654d T relay_reset
+c01465b2 t wakeup_readers
+c01465d0 T relay_destroy_buf
+c0146629 T relay_remove_buf
+c0146643 T relay_create_buf
+c01467dd T relay_open
+c0146a43 t relay_buf_nopage
+c0146a96 t relay_file_poll
+c0146ad0 t subbuf_start_default_callback
+c0146ae4 t get_uts
+c0146b06 t put_uts
+c0146b1e t sysctl_uts_string
+c0146bab t proc_do_uts_string
+c0146c14 t page_waitqueue
+c0146c42 t shrink_readahead_size_eio
+c0146c50 T file_send_actor
+c0146ca3 T generic_segment_checks
+c0146d32 T __filemap_copy_from_user_iovec_inatomic
+c0146d85 T generic_write_checks
+c0146f59 T __remove_suid
+c0146f6d T should_remove_suid
+c0146fb4 T remove_suid
+c0146fce T generic_file_mmap
+c014700c T generic_file_readonly_mmap
+c0147026 T sys_readahead
+c01470be T file_read_actor
+c0147199 T find_get_pages_tag
+c0147219 T find_get_page
+c0147260 T __lock_page_nosync
+c01472be T __lock_page
+c014731c t __sleep_on_page_lock
+c0147324 t sync_page
+c0147365 T unlock_page
+c0147388 T find_lock_page
+c014740b T end_page_writeback
+c0147447 T wait_on_page_bit
+c01474ad T add_to_page_cache
+c0147523 T add_to_page_cache_lru
+c014754b T read_cache_page_async
+c0147687 t page_cache_read
+c0147727 T filemap_populate
+c014798e T filemap_fault
+c0147c2d T filemap_nopage
+c0147c65 T do_generic_mapping_read
+c01480f1 T generic_file_sendfile
+c0148151 T grab_cache_page_nowait
+c01481cd T wait_on_page_writeback_range
+c01482c5 T filemap_fdatawait
+c014830f T __filemap_fdatawrite_range
+c014837f T filemap_write_and_wait_range
+c01483f0 t filemap_fdatawrite_range
+c0148417 T sync_page_range_nolock
+c01484b3 T sync_page_range
+c0148582 T filemap_fdatawrite
+c01485a9 T filemap_write_and_wait
+c01485d2 t generic_file_direct_IO
+c01486e8 T generic_file_direct_write
+c0148821 T generic_file_buffered_write
+c0148dee t __generic_file_aio_write_nolock
+c01492d1 T generic_file_aio_write
+c0149387 T generic_file_aio_write_nolock
+c0149419 T filemap_flush
+c0149440 T __remove_from_page_cache
+c014946a T remove_from_page_cache
+c0149495 T read_cache_page
+c01494d4 T try_to_release_page
+c0149516 T find_get_pages
+c0149576 T find_get_pages_contig
+c01495e6 T find_or_create_page
+c014966c T generic_file_aio_read
+c0149804 T mempool_free_pages
+c0149809 t remove_element
+c0149821 t add_element
+c014983e T mempool_alloc_pages
+c014986f T mempool_kfree
+c0149874 t free_pool
+c014989c T mempool_destroy
+c01498ae T mempool_kzalloc
+c01498b9 T mempool_alloc_slab
+c01498c4 T mempool_kmalloc
+c01498cf T mempool_free_slab
+c01498da T mempool_free
+c0149946 T mempool_alloc
+c0149a17 T mempool_create_node
+c0149ad6 T mempool_create
+c0149af2 T mempool_resize
+c0149c44 T out_of_memory
+c0149c92 T badness
+c0149e10 T sys_fadvise64_64
+c0149fa7 T sys_fadvise64
+c0149fe4 T split_page
+c014a00c T zone_watermark_ok
+c014a0b2 t nr_free_zone_pages
+c014a0e4 T nr_free_buffer_pages
+c014a0eb T nr_free_pagecache_pages
+c014a0f2 T zone_init_free_lists
+c014a11c T setup_pageset
+c014a18f T set_pageblock_flags_group
+c014a1eb t calculate_totalreserve_pages
+c014a258 t setup_per_zone_lowmem_reserve
+c014a303 T lowmem_reserve_ratio_sysctl_handler
+c014a32f T percpu_pagelist_fraction_sysctl_handler
+c014a3d9 T setup_per_zone_pages_min
+c014a4d6 T min_free_kbytes_sysctl_handler
+c014a50a T mark_free_pages
+c014a58b t bad_page
+c014a619 t destroy_compound_page
+c014a698 t __rmqueue
+c014a75d t __free_pages_ok
+c014a9a7 t free_compound_page
+c014a9c3 t free_pages_bulk
+c014ab46 t free_hot_cold_page
+c014ac74 T __pagevec_free
+c014ac96 T free_cold_page
+c014aca0 T free_hot_page
+c014aca7 T __free_pages
+c014acc7 T free_pages
+c014ace2 t get_page_from_freelist
+c014afae T __alloc_pages
+c014b245 T __get_free_pages
+c014b27f T get_zeroed_page
+c014b2b9 T drain_local_pages
+c014b33d T si_meminfo
+c014b3ad T show_free_areas
+c014b6d4 T get_pageblock_flags_group
+c014b73c t __writepage
+c014b75d T mapping_tagged
+c014b78f T set_page_dirty
+c014b7e1 T clear_page_dirty_for_io
+c014b846 T set_page_dirty_lock
+c014b880 T __set_page_dirty_nobuffers
+c014b93b T redirty_page_for_writepage
+c014b945 T write_cache_pages
+c014bbd0 T generic_writepages
+c014bbf6 T do_writepages
+c014bc26 T laptop_io_completion
+c014bc3c t laptop_timer_fn
+c014bc48 t wb_timer_fn
+c014bc6f T writeback_set_ratelimit
+c014bcc4 T laptop_sync_completion
+c014bcce t laptop_flush
+c014bcd3 T dirty_writeback_centisecs_handler
+c014bd21 t get_dirty_limits
+c014be3b T balance_dirty_pages_ratelimited_nr
+c014bfc9 T __set_page_dirty_no_writeback
+c014bfd9 T throttle_vm_writeout
+c014c052 t background_writeout
+c014c0ed T wakeup_pdflush
+c014c117 t wb_kupdate
+c014c1f6 T test_set_page_writeback
+c014c2b0 T set_page_dirty_balance
+c014c2ea T test_clear_page_writeback
+c014c382 T write_one_page
+c014c440 t start_one_pdflush_thread
+c014c472 t pdflush
+c014c611 T pdflush_operation
+c014c698 T default_unplug_io_fn
+c014c699 T file_ra_state_init
+c014c6a9 T handle_ra_miss
+c014c6bd t __do_page_cache_readahead
+c014c88b t blockable_page_cache_readahead
+c014c92a t make_ahead_window
+c014c9c3 T page_cache_readahead
+c014cb67 T do_page_cache_readahead
+c014cbb0 T force_page_cache_readahead
+c014cc1b T read_cache_pages
+c014ccbe T max_sane_readahead
+c014cce4 T vm_acct_memory
+c014cd10 T pagevec_lookup_tag
+c014cd3b t put_compound_page
+c014cd5f T release_pages
+c014ce79 T __pagevec_lru_add_active
+c014cf0a T __pagevec_lru_add
+c014cf96 T lru_add_drain
+c014cfcd T lru_add_drain_all
+c014cfd5 T activate_page
+c014d054 T put_page
+c014d0db T put_pages_list
+c014d0fd T rotate_reclaimable_page
+c014d1a1 T mark_page_accessed
+c014d1d1 T __pagevec_release
+c014d1ee T __pagevec_release_nonlru
+c014d23d T pagevec_strip
+c014d27c T pagevec_lookup
+c014d29e T lru_cache_add_active
+c014d2df T lru_cache_add
+c014d320 T do_invalidatepage
+c014d338 T invalidate_inode_pages2_range
+c014d559 T invalidate_inode_pages2
+c014d563 T cancel_dirty_page
+c014d58d t truncate_complete_page
+c014d5cc T truncate_inode_pages_range
+c014d8ac T truncate_inode_pages
+c014d8c6 T invalidate_mapping_pages
+c014d998 t count_lru_pages
+c014d9b2 T kswapd_run
+c014da28 T raise_kswapd_order
+c014da50 t isolate_lru_pages
+c014dadb t shrink_active_list
+c014de4c T wakeup_kswapd
+c014debc T remove_mapping
+c014df71 t shrink_inactive_list
+c014e666 t shrink_zone
+c014e758 T shrink_slab
+c014e890 T remove_shrinker
+c014e8b7 T set_shrinker
+c014e90c T shrink_all_memory
+c014eb93 T try_to_free_pages
+c014ed7d t kswapd
+c014f18c T vma_prio_tree_add
+c014f207 T vma_prio_tree_insert
+c014f231 T vma_prio_tree_next
+c014f271 T vma_prio_tree_remove
+c014f338 T kmemdup
+c014f36b T __kzalloc
+c014f39f T kstrdup
+c014f3e1 T kstrndup
+c014f429 T strndup_user
+c014f480 T first_online_pgdat
+c014f486 T next_online_pgdat
+c014f489 T next_zone
+c014f4a8 T vm_events_fold_cpu
+c014f4da t frag_stop
+c014f4db t vmstat_next
+c014f506 t vmstat_show
+c014f532 t vmstat_stop
+c014f546 T all_vm_events
+c014f5ac t vmstat_start
+c014f612 t frag_next
+c014f620 t frag_start
+c014f646 T refresh_cpu_vm_stats
+c014f6b6 t __refresh_cpu_vm_stats
+c014f6c1 t refresh_zone_stat_thresholds
+c014f747 t start_cpu_timer
+c014f786 t vmstat_update
+c014f7aa T refresh_vm_stats
+c014f7c4 T __dec_zone_state
+c014f82a T __dec_zone_page_state
+c014f83f T __inc_zone_state
+c014f89e T __mod_zone_page_state
+c014f8ed T dec_zone_page_state
+c014f8fa T mod_zone_page_state
+c014f907 T inc_zone_state
+c014f914 T inc_zone_page_state
+c014f931 t frag_show
+c014f9e7 T __inc_zone_page_state
+c014f9fc t zoneinfo_show
+c014fc7c T set_bdi_congested
+c014fc8a T congestion_end
+c014fcba T congestion_wait
+c014fd1e T congestion_wait_interruptible
+c014fd9a T clear_bdi_congested
+c014fdd8 t zap_pte
+c014fe4f T install_file_pte
+c014fee4 T sys_remap_file_pages
+c015012b T install_page
+c01502e8 t page_slot
+c01502fa T page_address
+c0150386 T set_page_address
+c01504a4 T kunmap_high
+c0150534 t flush_all_zero_pkmaps
+c0150593 T kmap_high
+c01506ee T kmap_flush_unused
+c0150707 T nr_free_highpages
+c0150734 T sys_madvise
+c0150bb0 T vmalloc_to_page
+c0150c0a T vmalloc_to_pfn
+c0150c1f T pmd_clear_bad
+c0150c52 T pud_clear_bad
+c0150c7b T pgd_clear_bad
+c0150ca4 T print_bad_pte
+c0150cfc T vm_normal_page
+c0150d4d t __do_fault
+c015108a t do_wp_page
+c015149c T swapin_readahead
+c01514f4 T follow_page
+c015163e T unmap_vmas
+c0151b23 T zap_page_range
+c0151bed t unmap_mapping_range_vma
+c0151c83 T unmap_mapping_range
+c0151e8c T vmtruncate_range
+c0151f8a T __pte_alloc_kernel
+c0151fd4 T __pte_alloc
+c015205a T apply_to_page_range
+c01521d6 T get_locked_pte
+c015223f T vm_insert_page
+c0152328 T zeromap_page_range
+c01524a9 T copy_page_range
+c015289c T free_pgd_range
+c0152a31 t do_no_pfn
+c0152b01 T __handle_mm_fault
+c015336e T get_user_pages
+c01535f5 T access_process_vm
+c015371d T make_pages_present
+c01537ad T vmtruncate
+c01538f5 T free_pgtables
+c0153971 T vm_insert_pfn
+c01539d7 T remap_pfn_range
+c0153b40 t mincore_page
+c0153b64 T sys_mincore
+c0153e34 T user_shm_unlock
+c0153e63 T user_shm_lock
+c0153ed7 T can_do_mlock
+c0153f05 t mlock_fixup
+c015400b t do_mlockall
+c0154090 t do_mlock
+c0154158 T sys_munlock
+c01541b2 T sys_mlockall
+c01542ca T sys_munlockall
+c0154300 T sys_mlock
+c0154424 T vm_get_page_prot
+c015442f t find_vma_prepare
+c0154498 t can_vma_merge_before
+c01544de t can_vma_merge_after
+c015452d T vm_stat_account
+c015456d T arch_unmap_area
+c0154585 T arch_unmap_area_topdown
+c0154599 T find_vma
+c01545ec T arch_get_unmapped_area
+c01546d3 T find_vma_prev
+c0154728 T may_expand_vm
+c01547b6 t special_mapping_close
+c01547b7 T get_unmapped_area
+c0154829 t special_mapping_nopage
+c0154881 t unmap_region
+c015497a t remove_vma
+c01549bf T expand_stack
+c0154adf T find_extend_vma
+c0154b28 t __remove_shared_vm_struct
+c0154b6f T unlink_file_vma
+c0154ba7 T __unlink_file_vma
+c0154bb5 T __vma_link_rb
+c0154bdd t __vma_link
+c0154c2c T vma_adjust
+c0154fcf T split_vma
+c0155084 T do_munmap
+c015525a T sys_munmap
+c0155298 T vma_merge
+c0155410 t vma_link
+c01554d7 T copy_vma
+c01555f0 T insert_vm_struct
+c01556f6 T install_special_mapping
+c0155791 T do_brk
+c0155a75 T sys_brk
+c0155b42 T arch_get_unmapped_area_topdown
+c0155c69 T find_mergeable_anon_vma
+c0155d19 T exit_mmap
+c0155e77 T __vm_enough_memory
+c0155f46 T do_mmap_pgoff
+c01565c4 T sys_mprotect
+c0156a3c t move_page_tables
+c0156ca1 T do_mremap
+c0157258 T sys_mremap
+c01572ac T sys_msync
+c0157404 t page_lock_anon_vma
+c0157425 t page_unlock_anon_vma
+c015742a T page_check_address
+c01574c9 t page_referenced_one
+c015758a t page_referenced_file
+c0157622 T page_remove_rmap
+c015772c t try_to_unmap_one
+c01578c4 T try_to_unmap
+c0157ce0 T page_add_file_rmap
+c0157cfa t __page_set_anon_rmap
+c0157d25 T page_add_new_anon_rmap
+c0157d49 t anon_vma_ctor
+c0157d66 T __anon_vma_merge
+c0157d7a T anon_vma_unlink
+c0157db9 T anon_vma_link
+c0157de5 T page_add_anon_rmap
+c0157dfd T page_address_in_vma
+c0157e5d T page_referenced
+c0157f26 T page_mkclean
+c015807f T anon_vma_prepare
+c0158132 T __anon_vma_link
+c0158149 T vwrite
+c01581c8 T vread
+c0158243 t __get_vm_area_node
+c01583b9 T get_vm_area_node
+c015840a T __get_vm_area
+c015842f T get_vm_area
+c015846e T map_vm_area
+c0158594 T unmap_kernel_range
+c015866a T remove_vm_area
+c01586b4 t __vunmap
+c0158785 T vunmap
+c01587a4 T vmap
+c01587e1 T vfree
+c0158803 T __vmalloc_area_node
+c0158917 t __vmalloc_node
+c0158971 T vmalloc_node
+c0158989 T __vmalloc
+c015899a T vmalloc_32_user
+c01589df T vmalloc_32
+c01589ef T vmalloc_exec
+c01589ff T vmalloc
+c0158a0f T __vmalloc_area
+c0158a20 T vmalloc_user
+c0158a65 T remap_vmalloc_range
+c0158b2c T init_emergency_isa_pool
+c0158b79 t mempool_alloc_pages_isa
+c0158b81 T blk_queue_bounce
+c0158e0e t bounce_end_io
+c0158e8e t __bounce_end_io_read
+c0158f53 t bounce_end_io_read_isa
+c0158f6e t bounce_end_io_read
+c0158f89 t bounce_end_io_write_isa
+c0158fa4 t bounce_end_io_write
+c0158fc0 t get_swap_bio
+c015903d T swap_readpage
+c015909a T end_swap_bio_read
+c0159115 t end_swap_bio_write
+c0159190 T swap_writepage
+c0159220 T lookup_swap_cache
+c0159245 t __add_to_swap_cache
+c01592d8 T read_swap_cache_async
+c0159384 T free_pages_and_swap_cache
+c0159408 T move_to_swap_cache
+c0159462 T __delete_from_swap_cache
+c01594c8 T delete_from_swap_cache
+c01594fa T move_from_swap_cache
+c0159534 T show_swap_cache_info
+c01595ad T add_to_swap
+c0159613 T free_page_and_swap_cache
+c0159644 t swap_entry_free
+c01596a4 t swap_next
+c01596e2 T get_swap_info_struct
+c01596eb t swaps_open
+c01596f7 t swap_show
+c01597b1 t swap_stop
+c01597bb t swap_start
+c015980c T valid_swaphandles
+c0159887 T swap_duplicate
+c0159937 t swap_info_get
+c01599d2 T swap_free
+c01599f8 T map_swap_page
+c0159a3b t add_swap_extent
+c0159acd t destroy_swap_extents
+c0159aef t unuse_mm
+c0159d29 T can_share_swap_page
+c0159d85 T si_swapinfo
+c0159e0e T get_swap_page_of_type
+c0159fe7 T free_swap_and_cache
+c015a0a7 T swap_unplug_io_fn
+c015a13f T remove_exclusive_swap_page
+c015a22e T sys_swapoff
+c015a9d2 T sys_swapon
+c015b394 T get_swap_page
+c015b5e0 T __put_swap_token
+c015b60c T grab_swap_token
+c015b710 t shmem_match
+c015b764 t shmem_get_sb
+c015b775 t shmem_free_blocks
+c015b7ba t shmem_recalc_inode
+c015b7f5 t shmem_free_swp
+c015b851 t shmem_swp_map
+c015b85b t shmem_dir_map
+c015b865 t shmem_swp_entry
+c015b972 t shmem_truncate_range
+c015c00b t shmem_truncate
+c015c02b t shmem_alloc_inode
+c015c046 t shmem_parse_options
+c015c300 t shmem_remount_fs
+c015c3e7 t shmem_get_inode
+c015c586 t shmem_mknod
+c015c614 t shmem_create
+c015c624 t shmem_swp_set
+c015c64f t shmem_swp_alloc
+c015c847 t shmem_getpage
+c015cdd8 t shmem_prepare_write
+c015ce05 t shmem_fault
+c015ceb0 t shmem_unlink
+c015cf33 t do_shmem_file_read
+c015d10d t shmem_file_sendfile
+c015d158 t shmem_file_read
+c015d1d2 t shmem_mmap
+c015d1f8 t shmem_put_super
+c015d212 t init_once
+c015d21a T shmem_file_setup
+c015d38b T shmem_zero_setup
+c015d3d8 t shmem_file_write
+c015d675 t shmem_encode_fh
+c015d6dd t shmem_fill_super
+c015d877 t shmem_mkdir
+c015d896 t shmem_rmdir
+c015d8c3 t shmem_rename
+c015d95e t shmem_follow_link
+c015d9aa t shmem_get_parent
+c015d9b0 t shmem_get_dentry
+c015d9f7 t shmem_decode_fh
+c015da26 t shmem_notify_change
+c015dade T shmem_lock
+c015db47 t shmem_symlink
+c015dcc6 t shmem_follow_link_inline
+c015dcd6 t shmem_destroy_inode
+c015dce3 t shmem_delete_inode
+c015ddbb t shmem_statfs
+c015de33 t shmem_put_link
+c015de5b t shmem_link
+c015defc t shmem_writepage
+c015e034 T shmem_unuse
+c015e2a0 T slab_is_available
+c015e2ad t slab_mgmt_size
+c015e2b6 t cache_estimate
+c015e338 T kmem_cache_size
+c015e33c T kmem_cache_name
+c015e340 t s_next
+c015e35b t s_stop
+c015e365 t s_start
+c015e3e6 t start_cpu_timer
+c015e444 T ksize
+c015e490 T kmem_ptr_validate
+c015e4ef t kmem_freepages
+c015e58b t kmem_list3_init
+c015e5dc t cache_flusharray
+c015e67c T kfree
+c015e738 T kmem_cache_free
+c015e7f3 t __kmem_cache_destroy
+c015e84e t slab_destroy
+c015e88e t free_block
+c015e971 t drain_array
+c015ea26 t drain_freelist
+c015ea9e t __cache_shrink
+c015eb28 t kmem_rcu_free
+c015eb4e T kmem_cache_destroy
+c015ebe6 T kmem_cache_alloc
+c015ec37 t cache_alloc_refill
+c015f068 T __kmalloc
+c015f0e0 T krealloc
+c015f1a6 T kmem_cache_zalloc
+c015f21a t init_list
+c015f2e4 t alloc_arraycache
+c015f32d t do_tune_cpucache
+c015f560 T slabinfo_write
+c015f6ae t enable_cpucache
+c015f752 t cache_reap
+c015f840 t s_show
+c015fa5c T kmem_cache_shrink
+c015fa98 t do_drain
+c015fae1 t do_ccupdate_local
+c015fb04 T kmem_cache_create
+c015fe88 t __xip_unmap
+c015ffa0 t do_xip_mapping_read
+c0160145 T xip_file_sendfile
+c01601a5 T xip_file_mmap
+c01601e0 T xip_file_read
+c016025a T xip_file_write
+c01605e5 T xip_truncate_page
+c01606b2 t xip_file_fault
+c016081c T percpu_depopulate
+c0160836 T __percpu_depopulate_mask
+c0160863 T percpu_free
+c0160880 T percpu_populate
+c01608c8 T __percpu_populate_mask
+c016092d T __percpu_alloc_mask
+c0160984 T quicklist_total_size
+c01609cb T quicklist_trim
+c0160a64 t __put_unused_fd
+c0160a95 T generic_file_open
+c0160ae2 T nonseekable_open
+c0160aef T sys_vhangup
+c0160b1c T put_unused_fd
+c0160b4d T fd_install
+c0160b96 T filp_close
+c0160bee T get_unused_fd
+c0160cc2 t __dentry_open
+c0160e3a T dentry_open
+c0160e90 T nameidata_to_filp
+c0160ec3 t do_filp_open
+c0160efc T do_sys_open
+c0160fbf T sys_openat
+c0160fdc T sys_open
+c0160ffa T sys_creat
+c016101d T filp_open
+c0161033 T sys_fallocate
+c016112e t chown_common
+c0161229 T sys_fchown
+c0161267 T sys_fchmod
+c016131f T sys_fchmodat
+c01614aa T sys_chmod
+c01614ce T sys_lchown
+c01615f9 T sys_faccessat
+c0161739 T sys_access
+c016175c T do_truncate
+c01617d5 t do_sys_ftruncate
+c0161919 T sys_ftruncate64
+c0161936 T sys_ftruncate
+c0161951 t do_sys_truncate
+c0161b07 T sys_truncate64
+c0161b18 T sys_truncate
+c0161b2a T vfs_statfs
+c0161ba3 t vfs_statfs64
+c0161bc4 T sys_fstatfs64
+c0161c24 T sys_statfs64
+c0161ca4 t vfs_statfs_native
+c0161d6e T sys_fstatfs
+c0161dc2 T sys_statfs
+c0161e33 T sys_chdir
+c0161e87 T sys_fchdir
+c0161ef1 T sys_chroot
+c0161f5d T sys_close
+c0161ff6 T lookup_instantiate_filp
+c016205c T sys_chown
+c016218a T sys_fchownat
+c01622d0 T no_llseek
+c01622d9 T vfs_llseek
+c0162313 T iov_shorten
+c0162340 T do_loop_readv_writev
+c016238c T rw_copy_check_uvector
+c0162436 t wait_on_retry_sync_kiocb
+c0162466 T do_sync_readv_writev
+c0162564 T do_sync_write
+c016266e T do_sync_read
+c0162778 T rw_verify_area
+c016280c t do_sendfile
+c01629ea T sys_sendfile64
+c0162a7f T sys_sendfile
+c0162b13 t do_readv_writev
+c0162c77 T vfs_writev
+c0162cbf T vfs_readv
+c0162d04 T vfs_write
+c0162e10 T vfs_read
+c0162f1a T default_llseek
+c0162fb7 T generic_file_llseek
+c0163057 T sys_writev
+c01630be T remote_llseek
+c0163178 T sys_lseek
+c01631de T sys_llseek
+c0163263 T sys_read
+c01632ca T sys_write
+c0163331 T sys_pread64
+c0163390 T sys_pwrite64
+c01633ef T sys_readv
+c0163458 T get_max_files
+c016345e T fs_may_remount_ro
+c01634c6 T file_kill
+c01634f3 T file_move
+c0163529 t file_free_rcu
+c0163535 T __fput
+c01636bc T fput
+c01636d1 T put_filp
+c016372c T fget_light
+c0163796 T fget
+c01637df T proc_nr_files
+c016382f T get_empty_filp
+c016399c t set_bdev_super
+c01639aa t test_bdev_super
+c01639b7 t compare_single
+c01639bd T set_anon_super
+c0163a58 T emergency_remount
+c0163a64 T lock_super
+c0163a7a T unlock_super
+c0163a90 T __put_super
+c0163abb t put_super
+c0163ada T drop_super
+c0163aea T __put_super_and_need_restart
+c0163b10 T user_get_super
+c0163b87 T sys_ustat
+c0163c12 T sget
+c0163ed6 T __fsync_super
+c0163f37 T fsync_super
+c0163f4b T do_remount_sb
+c016404d t do_emergency_remount
+c01640e6 T generic_shutdown_super
+c016419f T kill_block_super
+c01641ba T kill_anon_super
+c01641ea T kill_litter_super
+c0164201 T deactivate_super
+c016426b T vfs_kern_mount
+c01643b0 T kern_mount
+c01643c5 T do_kern_mount
+c016448c T sync_supers
+c016451d T sync_filesystems
+c01645f3 T get_super
+c0164673 T get_sb_bdev
+c016478c T get_sb_nodev
+c0164810 T get_sb_single
+c01648b0 t exact_match
+c01648b3 t base_probe
+c01648f0 T cdev_init
+c016492d t cdev_purge
+c0164981 t cdev_default_release
+c0164983 T cd_forget
+c01649c2 t cdev_dynamic_release
+c01649d2 T cdev_alloc
+c0164a03 T cdev_del
+c0164a1e T cdev_add
+c0164a50 T cdev_put
+c0164a67 t cdev_get
+c0164a9f t exact_lock
+c0164aac T chrdev_open
+c0164be3 t __unregister_chrdev_region
+c0164c3e T unregister_chrdev
+c0164c68 T unregister_chrdev_region
+c0164ca0 t __register_chrdev_region
+c0164dc2 T chrdev_show
+c0164e1f T register_chrdev
+c0164ef8 T register_chrdev_region
+c0164f80 T alloc_chrdev_region
+c0164fb0 T generic_fillattr
+c016505d T vfs_getattr
+c016508d T inode_set_bytes
+c01650ad T inode_get_bytes
+c01650e4 T inode_sub_bytes
+c0165188 T inode_add_bytes
+c01651e2 t cp_new_stat64
+c01652f0 t cp_new_stat
+c0165455 T sys_readlinkat
+c01654ce T sys_readlink
+c01654f9 T vfs_lstat_fd
+c0165536 T sys_newlstat
+c016555e T vfs_lstat
+c016556c T sys_lstat64
+c016558f T vfs_stat_fd
+c01655cf T sys_fstatat64
+c0165617 T sys_newstat
+c016563f T vfs_stat
+c016564d T sys_stat64
+c0165670 t cp_old_stat
+c01657a9 T sys_lstat
+c01657d1 T sys_stat
+c01657f9 T vfs_fstat
+c016582a T sys_fstat64
+c016584d T sys_newfstat
+c0165870 T sys_fstat
+c0165894 T set_dumpable
+c01658d3 T get_dumpable
+c01658e8 t zap_process
+c016594b t count
+c016598c t copy_strings
+c0165b4a T copy_strings_kernel
+c0165b71 T search_binary_handler
+c0165d34 T remove_arg_zero
+c0165dd0 T set_task_comm
+c0165e02 T kernel_read
+c0165e4a T prepare_binprm
+c0165f10 T open_exec
+c0165fb5 T install_arg_page
+c016607e T unregister_binfmt
+c01660c7 T register_binfmt
+c0166123 T setup_arg_pages
+c01662cf T flush_old_exec
+c0166aa4 T compute_creds
+c0166b30 T set_binfmt
+c0166b83 T sys_uselib
+c0166caa T do_execve
+c0166e59 T get_task_comm
+c0166e8f T do_coredump
+c0167488 t iov_fault_in_pages_read
+c01674e4 T generic_pipe_buf_pin
+c01674e7 t bad_pipe_r
+c01674ed t bad_pipe_w
+c01674f3 t pipe_poll
+c0167570 t pipefs_delete_dentry
+c0167577 t pipefs_get_sb
+c016758b T generic_pipe_buf_get
+c01675a3 t pipe_rdwr_open
+c01675e2 t pipe_write_open
+c0167608 t pipe_read_open
+c016762e t pipe_rdwr_fasync
+c01676aa t pipe_write_fasync
+c01676fc t pipe_read_fasync
+c016774e t pipe_ioctl
+c01677a5 T generic_pipe_buf_map
+c01677c2 T generic_pipe_buf_unmap
+c01677e2 t pipe_iov_copy_from_user
+c016783d T create_read_pipe
+c01678b8 t pipefs_dname
+c01678e3 T __free_pipe_info
+c016791c T free_pipe_info
+c0167936 T free_write_pipe
+c0167967 t pipe_release
+c01679f5 t pipe_rdwr_release
+c0167a1c t pipe_write_release
+c0167a38 t pipe_read_release
+c0167a54 T alloc_pipe_info
+c0167a88 T create_write_pipe
+c0167be2 T generic_pipe_buf_steal
+c0167c2c T pipe_wait
+c0167c9f t pipe_write
+c0168094 t anon_pipe_buf_release
+c01680c5 t pipe_read
+c01683e6 T do_pipe
+c0168480 T __page_symlink
+c01685d1 T page_symlink
+c01685ef T page_put_link
+c0168607 t page_getlink
+c016863d T page_follow_link_light
+c016865e T unlock_rename
+c016869a T lock_rename
+c016872c T path_release_on_umount
+c016873f T path_release
+c016875f T vfs_readlink
+c01687a2 T page_readlink
+c01687ed T generic_readlink
+c016885b t cached_lookup
+c01688c1 T dentry_unhash
+c016892e T deny_write_access
+c016896a T get_write_access
+c01689a2 t follow_mount
+c01689f4 t __follow_mount
+c0168a54 T generic_permission
+c0168b11 t do_lookup
+c0168de8 T permission
+c0169031 T vfs_link
+c0169192 T vfs_symlink
+c0169262 T vfs_mkdir
+c0169338 T vfs_mknod
+c0169436 T vfs_create
+c0169521 t may_delete
+c0169620 T vfs_rename
+c01699db T vfs_unlink
+c0169a93 T vfs_rmdir
+c0169b68 t lookup_hash
+c0169bf9 T lookup_create
+c0169c63 T file_permission
+c0169c70 T vfs_permission
+c0169c7c T may_open
+c0169ed9 T release_open_intent
+c0169eec T getname
+c0169f7b T lookup_one_len_kern
+c016a036 T lookup_one_len_nd
+c016a110 T follow_up
+c016a189 T follow_down
+c016a1da t __link_path_walk
+c016adb8 T link_path_walk
+c016ae6b T path_walk
+c016ae81 t __emul_lookup_dentry
+c016af91 t do_path_lookup
+c016b10e T sys_renameat
+c016b2e2 T sys_rename
+c016b30d T sys_symlinkat
+c016b3d5 T sys_symlink
+c016b3f8 t do_unlinkat
+c016b52c T sys_unlink
+c016b53a t do_rmdir
+c016b5fb T sys_unlinkat
+c016b624 T sys_rmdir
+c016b632 T sys_mkdirat
+c016b6fc T sys_mkdir
+c016b71f T sys_mknodat
+c016b8a5 T sys_mknod
+c016b8d0 T __user_walk_fd
+c016b915 T sys_linkat
+c016ba1a T sys_link
+c016ba4d T __user_walk
+c016ba63 t __path_lookup_intent_open
+c016bad8 T __user_path_lookup_open
+c016bb2c T path_lookup_open
+c016bb51 T path_lookup
+c016bb67 T cow_break_link
+c016bf78 T set_fs_altroot
+c016bfd3 T open_namei
+c016c582 T vfs_follow_link
+c016c690 T f_getown
+c016c6c3 T fasync_helper
+c016c782 T send_sigurg
+c016c816 T send_sigio
+c016c930 T __kill_fasync
+c016c97b T kill_fasync
+c016c9af T set_close_on_exec
+c016c9ed t dupfd
+c016cb66 T sys_dup
+c016cb80 t f_modown
+c016cbea T f_delown
+c016cc11 T __f_setown
+c016cc45 T f_setown
+c016cc75 t do_fcntl
+c016cebe T sys_fcntl64
+c016cf2b T sys_dup2
+c016d041 T sys_fcntl
+c016d080 t do_ioctl
+c016d11f T vfs_ioctl
+c016d36a T sys_ioctl
+c016d3b4 t filldir64
+c016d47c t filldir
+c016d535 T vfs_readdir
+c016d5ac T sys_getdents64
+c016d652 T old_readdir
+c016d6a0 t fillonedir
+c016d777 T sys_getdents
+c016d814 T poll_initwait
+c016d830 t free_poll_entry
+c016d846 T poll_freewait
+c016d892 T do_sys_poll
+c016dbb9 T sys_poll
+c016dbf0 T do_select
+c016dfb9 t core_sys_select
+c016e2a1 T sys_pselect7
+c016e4b0 T sys_pselect6
+c016e52b t __pollwait
+c016e5d7 T sys_select
+c016e75f T sys_ppoll
+c016e964 t wake_up_partner
+c016e985 t wait_for_partner
+c016e9b3 t fifo_open
+c016eb5c t locks_release_private
+c016eb93 t locks_copy_private
+c016ebce t __locks_copy_lock
+c016ec16 T locks_copy_lock
+c016ec4d t flock_to_posix_lock
+c016ed5b t flock64_to_posix_lock
+c016ee9c t lease_mylease_callback
+c016eea9 t lease_init
+c016ef1b t posix_same_owner
+c016ef4d t __locks_delete_block
+c016ef7e t posix_locks_conflict
+c016efd2 T vfs_cancel_lock
+c016eff0 T lock_may_write
+c016f05f T lock_may_read
+c016f0d5 T posix_unblock_lock
+c016f0fb T posix_test_lock
+c016f152 T vfs_test_lock
+c016f175 t locks_delete_block
+c016f18a t lock_get_status
+c016f3c2 t move_lock_status
+c016f41c t locks_wake_up_blocks
+c016f46b t locks_free_lock
+c016f4c9 t locks_delete_lock
+c016f540 T lease_modify
+c016f56f t time_out_leases
+c016f5b4 T fcntl_getlease
+c016f5fd t locks_alloc_lock
+c016f671 T fcntl_getlk64
+c016f782 T fcntl_getlk
+c016f8b7 t locks_insert_lock
+c016f8e4 t __setlease
+c016fa58 t locks_insert_block
+c016fa8f t __posix_lock_file
+c016ff66 T posix_lock_file
+c016ff80 T vfs_lock_file
+c016ffb1 T flock_lock_file_wait
+c0170202 t lease_break_callback
+c0170214 t lease_release_private_callback
+c017022f T lease_get_mtime
+c0170267 T locks_init_lock
+c01702e1 t init_once
+c01702e6 T get_locks_status
+c01703f9 T locks_mandatory_locked
+c017043f T __break_lease
+c0170718 T fcntl_setlk64
+c0170912 T locks_remove_posix
+c01709ac T locks_remove_flock
+c0170a81 T setlease
+c0170aee T fcntl_setlease
+c0170bee T sys_flock
+c0170d25 T posix_lock_file_wait
+c0170ddc T locks_mandatory_area
+c0170f48 T fcntl_setlk
+c0171144 T dget_locked
+c0171189 t __d_find_alias
+c0171269 t __d_rehash
+c0171286 t _d_rehash
+c01712be T is_subdir
+c0171304 T d_rehash
+c0171336 T d_find_alias
+c0171368 t dentry_iput
+c017140c t __d_free
+c017142d t d_free
+c017145b t d_kill
+c017148d t d_callback
+c0171495 t __d_path
+c01715eb t switch_names
+c017165b T dynamic_dname
+c01716b8 t shrink_dcache_for_umount_subtree
+c017189b t d_move_locked
+c01719fc T d_move
+c0171a21 T __d_lookup
+c0171b2c T d_lookup
+c0171b69 T d_hash_and_lookup
+c0171bc4 t __d_instantiate_unique
+c0171c61 T d_instantiate
+c0171ca5 T d_validate
+c0171d7b T d_alloc
+c0171f76 T d_alloc_root
+c0171fac T d_alloc_name
+c0171ffe T dput
+c0172110 T find_inode_number
+c017212f T d_alloc_anon
+c0172203 t prune_one_dentry
+c01722bd T shrink_dcache_sb
+c017237b t prune_dcache
+c01724b2 t shrink_dcache_memory
+c01724e6 T shrink_dcache_parent
+c01725c5 T shrink_dcache_for_umount
+c01725fb T d_genocide
+c0172652 T d_invalidate
+c0172707 T have_submounts
+c017276c T d_instantiate_unique
+c01727b7 T d_prune_aliases
+c0172891 T d_materialise_unique
+c0172afa T d_path
+c0172bdb T sys_getcwd
+c0172d90 T d_splice_alias
+c0172e41 T d_delete
+c0172f18 t hash
+c0172f3f T bmap
+c0172f66 T inode_needs_sync
+c0172fac T init_special_inode
+c0173029 T inode_double_lock
+c0173076 T remove_inode_hash
+c01730ad T __insert_inode_hash
+c01730ef T inode_double_unlock
+c017311c T __iget
+c0173155 T igrab
+c0173184 T wake_up_inode
+c0173199 T unlock_new_inode
+c01731a5 T inode_wait
+c01731ad T iput
+c017320f t __wait_on_freeing_inode
+c017329a t find_inode_fast
+c01732dc T iunique
+c017333e t find_inode
+c0173394 t ifind_fast
+c0173414 T ilookup
+c0173437 t ifind
+c01734c5 T ilookup5
+c01734fd T ilookup5_nowait
+c0173535 T destroy_inode
+c0173568 t alloc_inode
+c017369d T iget_locked
+c01737a9 T iget5_locked
+c01738e8 T new_inode
+c0173954 T clear_inode
+c0173a64 T generic_delete_inode
+c0173b58 T generic_drop_inode
+c0173c79 t dispose_list
+c0173d30 t shrink_icache_memory
+c0173ed1 T invalidate_inodes
+c0173f96 T inode_init_once
+c01740f9 t init_once
+c01740fe T file_update_time
+c0174168 T touch_atime
+c0174224 T inode_setattr
+c017436e T inode_change_ok
+c01745aa T notify_change
+c0174838 t bad_file_llseek
+c0174841 t bad_file_read
+c0174847 t bad_file_write
+c017484d t bad_file_aio_read
+c0174853 t bad_file_aio_write
+c0174859 t bad_file_readdir
+c017485f t bad_file_poll
+c0174865 t bad_file_ioctl
+c017486b t bad_file_unlocked_ioctl
+c0174871 t bad_file_compat_ioctl
+c0174877 t bad_file_mmap
+c017487d t bad_file_open
+c0174883 t bad_file_flush
+c0174889 t bad_file_release
+c017488f t bad_file_fsync
+c0174895 t bad_file_aio_fsync
+c017489b t bad_file_fasync
+c01748a1 t bad_file_lock
+c01748a7 t bad_file_sendfile
+c01748ad t bad_file_sendpage
+c01748b3 t bad_file_get_unmapped_area
+c01748b9 t bad_file_check_flags
+c01748bf t bad_file_dir_notify
+c01748c5 t bad_file_flock
+c01748cb t bad_file_splice_write
+c01748d1 t bad_file_splice_read
+c01748d7 t bad_inode_create
+c01748dd t bad_inode_lookup
+c01748e3 t bad_inode_link
+c01748e9 t bad_inode_unlink
+c01748ef t bad_inode_symlink
+c01748f5 t bad_inode_mkdir
+c01748fb t bad_inode_rmdir
+c0174901 t bad_inode_mknod
+c0174907 t bad_inode_rename
+c017490d t bad_inode_readlink
+c0174913 t bad_inode_permission
+c0174919 t bad_inode_getattr
+c017491f t bad_inode_setattr
+c0174925 t bad_inode_setxattr
+c017492b t bad_inode_getxattr
+c0174931 t bad_inode_listxattr
+c0174937 t bad_inode_removexattr
+c017493d T is_bad_inode
+c017494e T make_bad_inode
+c0174998 t free_fdtable_work
+c01749eb T expand_files
+c0174cbf T free_fdtable_rcu
+c0174d34 t find_filesystem
+c0174d85 T get_filesystem_list
+c0174df3 T unregister_filesystem
+c0174e3f T put_filesystem
+c0174e47 T sys_sysfs
+c0174f8e T get_filesystem
+c0174fb7 T register_filesystem
+c017502e T get_fs_type
+c0175128 T __lookup_mnt
+c017517b t detach_mnt
+c01751bc t next_mnt
+c01751e0 t m_next
+c01751fc T may_umount_tree
+c0175239 t mnt_is_reachable
+c01752a8 T mnt_unpin
+c01752cd T mnt_pin
+c01752e8 T mnt_set_mountpoint
+c017530a t m_stop
+c0175314 t m_start
+c0175358 t attach_mnt
+c01753b6 t touch_mnt_namespace
+c01753e8 t commit_tree
+c01754ae T copy_mount_options
+c01755b7 T free_vfsmnt
+c01755cf t attach_recursive_mnt
+c01756bc t graft_tree
+c0175751 T may_umount
+c017577f T umount_tree
+c0175862 T mntput_no_expire
+c01758c5 T set_fs_pwd
+c017593c T set_fs_root
+c01759b3 T do_add_mount
+c0175aac T release_mounts
+c0175b1e T __put_mnt_ns
+c0175b8f t expire_mount_list
+c0175cb0 T shrink_submounts
+c0175d5d T sys_umount
+c0175f8b T sys_oldumount
+c0175fa5 T alloc_vfsmnt
+c0176059 t clone_mnt
+c017613a T copy_tree
+c01762b6 T copy_mnt_ns
+c017648b T do_mount
+c0176be7 T sys_mount
+c0176c9a T lookup_mnt
+c0176cd1 T mark_mounts_for_expiry
+c0176d48 T sys_pivot_root
+c0177121 T simple_set_mnt
+c017713d t show_vfsmnt
+c017730b t show_vfsstat
+c0177464 t aio_fdsync
+c0177484 t aio_fsync
+c01774a1 t aio_setup_single_vector
+c01774c4 t aio_rw_vect_retry
+c01775c4 t aio_cancel_all
+c0177632 t aio_queue_work
+c017765b t __aio_put_req
+c0177765 T aio_put_req
+c017778f t timeout_func
+c017779e t aio_read_evt
+c017785b t __aio_get_req
+c0177941 t aio_setup_vectored_rw
+c017798b t wait_for_all_aios
+c0177a14 t aio_free_ring
+c0177a81 T aio_complete
+c0177c1a t aio_run_iocb
+c0177d22 t __aio_run_iocbs
+c0177d83 T kick_iocb
+c0177e09 t aio_wake_function
+c0177e2d T lookup_ioctx
+c0177e80 T __put_ioctx
+c0177f1c T sys_io_getevents
+c01781c3 t io_destroy
+c017825c t aio_fput_routine
+c0178349 T io_submit_one
+c01785df T sys_io_setup
+c0178945 T sys_io_destroy
+c0178961 t aio_kick_handler
+c0178b8c T exit_aio
+c0178c11 T sys_io_submit
+c0178ce3 T sys_io_cancel
+c0178e01 T wait_on_sync_kiocb
+c0178e38 t single_start
+c0178e44 t single_next
+c0178e4e t single_stop
+c0178e4f T seq_putc
+c0178e6c T seq_puts
+c0178eb1 T seq_release
+c0178eca T seq_release_private
+c0178ef2 T single_release
+c0178f10 T seq_path
+c0178fcb T seq_printf
+c0179016 T seq_lseek
+c01792b4 T seq_open
+c0179325 T single_open
+c0179390 T seq_escape
+c0179434 T seq_read
+c01796b4 T vfs_listxattr
+c01796d7 t xattr_resolve_name
+c017971b T generic_getxattr
+c0179762 T generic_listxattr
+c0179808 T generic_setxattr
+c0179864 T generic_removexattr
+c01798b0 t listxattr
+c0179937 T sys_flistxattr
+c017996b T sys_llistxattr
+c01799af T sys_listxattr
+c01799f6 t xattr_permission
+c0179b4e T vfs_getxattr
+c0179bb8 t getxattr
+c0179c79 T sys_fgetxattr
+c0179cb8 T sys_lgetxattr
+c0179d03 T sys_getxattr
+c0179d51 T vfs_removexattr
+c0179e23 t removexattr
+c0179e72 T sys_fremovexattr
+c0179ea5 T sys_lremovexattr
+c0179ee9 T sys_removexattr
+c0179f30 T vfs_setxattr
+c017a039 t setxattr
+c017a123 T sys_fsetxattr
+c017a173 T sys_lsetxattr
+c017a1ce T sys_setxattr
+c017a22c T simple_statfs
+c017a245 t simple_delete_dentry
+c017a24b T simple_sync_file
+c017a24e T generic_read_dir
+c017a254 T simple_attr_write
+c017a2dc T simple_attr_close
+c017a2ea T simple_attr_open
+c017a364 T simple_transaction_release
+c017a374 T simple_empty
+c017a3c6 T simple_read_from_buffer
+c017a453 T simple_attr_read
+c017a4e8 T simple_transaction_read
+c017a51b T simple_release_fs
+c017a560 T simple_unlink
+c017a597 T dcache_dir_close
+c017a5a5 T simple_fill_super
+c017a760 T simple_commit_write
+c017a7b4 T dcache_dir_open
+c017a7d4 T dcache_readdir_filter
+c017a9cd T dcache_dir_lseek
+c017aac8 T simple_getattr
+c017aaf3 T simple_readpage
+c017ab33 T simple_prepare_write
+c017abb3 T simple_link
+c017ac00 T simple_rmdir
+c017ac2f T simple_rename
+c017acba T simple_transaction_get
+c017ad42 T simple_pin_fs
+c017adcc T get_sb_pseudo
+c017af01 T simple_lookup
+c017af2d T dcache_readdir
+c017b110 T writeback_acquire
+c017b120 T writeback_in_progress
+c017b127 T writeback_release
+c017b13f t set_sb_syncing
+c017b16b t __writeback_single_inode
+c017b443 T sync_inode
+c017b46d T write_inode_now
+c017b531 T generic_osync_inode
+c017b606 t sync_sb_inodes
+c017b82a T sync_inodes_sb
+c017b8be t __sync_inodes
+c017b94c T sync_inodes
+c017b975 T __mark_inode_dirty
+c017bad1 T writeback_inodes
+c017bb90 t propagation_next
+c017bbd6 T propagate_umount
+c017bc49 T change_mnt_propagation
+c017bdae T propagate_mount_busy
+c017be1a T propagate_mnt
+c017bf7c T drop_slab
+c017bf96 T drop_pagecache_sb
+c017bfeb T drop_pagecache
+c017c05b T drop_caches_sysctl_handler
+c017c0a8 t pipe_to_sendpage
+c017c109 t do_splice_to
+c017c16d t do_splice_from
+c017c1d0 t user_page_pipe_buf_steal
+c017c1e9 t page_cache_pipe_buf_release
+c017c1f9 T __splice_from_pipe
+c017c3b9 T splice_from_pipe
+c017c410 T generic_splice_sendpage
+c017c435 t splice_to_pipe
+c017c619 T generic_file_splice_write
+c017c717 t pipe_to_file
+c017c97b T generic_file_splice_write_nolock
+c017ca1f t page_cache_pipe_buf_pin
+c017ca79 T do_splice_direct
+c017cbd8 T generic_file_splice_read
+c017d054 T sys_vmsplice
+c017d2d6 T sys_splice
+c017d4da T sys_tee
+c017d838 t page_cache_pipe_buf_steal
+c017d904 T do_sync_mapping_range
+c017d9c1 T sys_sync_file_range
+c017dadb T sys_sync_file_range2
+c017db0c T do_fsync
+c017db95 t __do_fsync
+c017dbc0 T sys_fdatasync
+c017dbcb T sys_fsync
+c017dbd3 T file_fsync
+c017dc1a T emergency_sync
+c017dc26 t do_sync
+c017dc81 T sys_sync
+c017dc90 T do_utimes
+c017df21 T sys_futimesat
+c017dfa9 T sys_utimes
+c017dfcc T sys_utimensat
+c017e052 T sys_utime
+c017e0b8 T fsstack_copy_inode_size
+c017e0fd T fsstack_copy_attr_all
+c017e168 T init_buffer
+c017e16f T mark_buffer_async_write
+c017e17c T inode_has_buffers
+c017e18f T generic_block_bmap
+c017e1e7 t init_page_buffers
+c017e24e T block_sync_page
+c017e286 t recalc_bh_state
+c017e2f8 T free_buffer_head
+c017e324 T alloc_buffer_head
+c017e374 T sys_bdflush
+c017e3d0 T __brelse
+c017e419 T __bforget
+c017e464 t invalidate_bh_lru
+c017e498 t drop_buffers
+c017e570 T try_to_free_buffers
+c017e5ef T submit_bh
+c017e6e4 t __generic_cont_expand
+c017e7d2 T generic_cont_expand_simple
+c017e804 T generic_cont_expand
+c017e83f t buffer_io_error
+c017e874 t __find_get_block_slow
+c017e998 T set_bh_page
+c017e9e5 T invalidate_bh_lrus
+c017ea02 t free_more_memory
+c017ea41 T alloc_page_buffers
+c017eafc T create_empty_buffers
+c017eb82 T __find_get_block
+c017eccb T __getblk
+c017ef62 T mark_buffer_dirty
+c017ef7e t __block_commit_write
+c017f008 T generic_commit_write
+c017f07f T block_commit_write
+c017f099 T invalidate_bdev
+c017f0bd T thaw_bdev
+c017f123 T sync_blockdev
+c017f138 T freeze_bdev
+c017f1aa T fsync_bdev
+c017f1d5 T __wait_on_buffer
+c017f1fc T unmap_underlying_metadata
+c017f25f t sync_buffer
+c017f293 T unlock_buffer
+c017f2a2 t end_buffer_async_read
+c017f37b T __lock_buffer
+c017f3a7 T ll_rw_block
+c017f44b t __block_prepare_write
+c017f8a1 T block_prepare_write
+c017f8d1 t __block_write_full_page
+c017fbe2 T block_write_full_page
+c017fcba T sync_dirty_buffer
+c017fd8c T nobh_commit_write
+c017fde4 t end_bio_bh_io_sync
+c017fe1d T block_invalidatepage
+c017fed4 T sync_mapping_buffers
+c0180109 T mark_buffer_dirty_inode
+c0180173 T nobh_writepage
+c018024d t end_buffer_read_nobh
+c0180262 T __bread
+c01802f8 T write_boundary_block
+c018033b T end_buffer_read_sync
+c018035b T end_buffer_write_sync
+c01803b9 T __set_page_dirty_buffers
+c0180491 T __breadahead
+c01804cd t end_buffer_async_write
+c01805b7 T cont_prepare_write
+c01807fc T nobh_truncate_page
+c01808f1 T block_truncate_page
+c0180b0d T block_read_full_page
+c0180e05 T nobh_prepare_write
+c0181179 T invalidate_inode_buffers
+c0181214 T remove_inode_buffers
+c01812c8 T bio_init
+c018132e T bioset_free
+c018135d T bioset_create
+c01813e7 t bio_free_map_data
+c01813f9 T bio_put
+c018141d t bio_map_kern_endio
+c0181432 T bio_split
+c01815bf T bio_alloc_bioset
+c01816b2 T bio_alloc
+c01816c9 T bio_free
+c01816f5 t bio_fs_destructor
+c0181700 T bio_endio
+c0181763 T bio_pair_release
+c0181795 t bio_pair_end_2
+c01817b9 t bio_pair_end_1
+c01817d8 T bio_release_pages
+c01817ff T bio_set_pages_dirty
+c018182f t bio_dirty_fn
+c018187a T bio_unmap_user
+c01818b7 T bio_uncopy_user
+c0181969 t __bio_add_page
+c0181adc T bio_add_pc_page
+c0181b04 T bio_map_kern
+c0181bd9 T bio_map_user_iov
+c0181e58 T bio_map_user
+c0181e85 T __bio_clone
+c0181f0f T bio_clone
+c0181f3c T bio_hw_segments
+c0181f50 T bio_phys_segments
+c0181f64 T zero_fill_bio
+c0182000 T bio_check_pages_dirty
+c018207c T bio_copy_user
+c018228b T bio_get_nr_vecs
+c01822bc T bio_add_page
+c01822f4 T I_BDEV
+c01822fa t max_block
+c018236f t bdev_set
+c018237a T bd_set_size
+c01823df T bd_release
+c018241e T bd_claim
+c0182479 T nr_blockdev_pages
+c01824b6 t block_llseek
+c0182573 t kill_bdev
+c018259f T set_blocksize
+c0182615 T sb_set_blocksize
+c0182649 T sb_min_blocksize
+c0182677 t block_ioctl
+c0182692 t blkdev_commit_write
+c018269f t blkdev_prepare_write
+c01826b4 t blkdev_readpage
+c01826c0 t blkdev_writepage
+c01826cc T __invalidate_device
+c0182700 T check_disk_change
+c018275c t del_symlink
+c018276c t free_bd_holder
+c0182771 T bd_release_from_disk
+c0182827 t add_symlink
+c0182839 T bd_claim_by_disk
+c01829b4 T bd_forget
+c0182a51 T bdput
+c0182a59 t __blkdev_put
+c0182b5c T blkdev_put
+c0182b63 T close_bdev_excl
+c0182b73 T bdget
+c0182c61 t do_open
+c0182eb6 t __blkdev_get
+c0182f1c T blkdev_get
+c0182f30 t bd_acquire
+c0182fc0 T lookup_bdev
+c0183031 t blkdev_open
+c018307e t bd_get_sb
+c0183095 t bdev_alloc_inode
+c01830b3 T ioctl_by_bdev
+c01830ea t init_once
+c018315b T open_by_devnum
+c0183193 T open_bdev_excl
+c01831f5 t bdev_destroy_inode
+c018320f t bdev_test
+c018321e t blkdev_get_block
+c0183264 t blkdev_get_blocks
+c0183319 t blkdev_direct_IO
+c0183375 t block_fsync
+c0183387 t blkdev_close
+c01833aa t bdev_clear_inode
+c0183410 t dio_complete
+c01834cc t dio_get_page
+c0183625 t dio_cleanup
+c0183646 t dio_bio_complete
+c01836d2 t dio_new_bio
+c01837d0 t dio_bio_end_io
+c0183831 t dio_bio_end_aio
+c01838d9 t dio_bio_add_page
+c0183959 t dio_bio_submit
+c01839b0 t dio_send_cur_page
+c0183a42 t submit_page_section
+c0183b3a t dio_zero_block
+c0183bb8 T __blockdev_direct_IO
+c01847a8 t mpage_alloc
+c0184821 t mpage_bio_submit
+c018483e t __mpage_writepage
+c0184e4e T mpage_writepage
+c0184e9a T mpage_writepages
+c0184eff t do_mpage_readpage
+c01854fd T mpage_readpage
+c018555b t mpage_end_io_read
+c01855bf t mpage_end_io_write
+c0185624 T mpage_readpages
+c0185734 T ioprio_best
+c0185768 t set_task_ioprio
+c01857cd T sys_ioprio_set
+c01859b4 T sys_ioprio_get
+c0185b4c t revokefs_get_sb
+c0185b63 t revokefs_destroy_inode
+c0185b70 t revokefs_alloc_inode
+c0185b8b t revokefs_init_inode
+c0185b99 T generic_file_revoke
+c0185bc8 t free_fset
+c0185bfd t inode_fds
+c0185cb6 t revoke_mm
+c0185d9e t do_revoke
+c01864c5 T sys_frevoke
+c01864f6 T sys_revokeat
+c0186538 t revoked_file_llseek
+c0186541 t revoked_file_read
+c0186547 t revoked_special_file_read
+c018654a t revoked_file_write
+c0186550 t revoked_file_aio_read
+c0186556 t revoked_file_aio_write
+c018655c t revoked_file_readdir
+c0186562 t revoked_file_poll
+c0186568 t revoked_file_ioctl
+c018656e t revoked_file_unlocked_ioctl
+c0186574 t revoked_file_compat_ioctl
+c018657a t revoked_file_mmap
+c0186580 t revoked_file_open
+c0186586 t revoked_file_release
+c018658c t revoked_file_fsync
+c0186592 t revoked_file_aio_fsync
+c0186598 t revoked_file_fasync
+c018659e t revoked_file_lock
+c01865a4 t revoked_file_sendfile
+c01865aa t revoked_file_sendpage
+c01865b0 t revoked_file_get_unmapped_area
+c01865b6 t revoked_file_check_flags
+c01865bc t revoked_file_dir_notify
+c01865c2 t revoked_file_flock
+c01865c8 t revoked_file_splice_write
+c01865ce t revoked_file_splice_read
+c01865d4 t revoked_inode_create
+c01865da t revoked_inode_lookup
+c01865e0 t revoked_inode_link
+c01865e6 t revoked_inode_unlink
+c01865ec t revoked_inode_symlink
+c01865f2 t revoked_inode_mkdir
+c01865f8 t revoked_inode_rmdir
+c01865fe t revoked_inode_mknod
+c0186604 t revoked_inode_rename
+c018660a t revoked_inode_readlink
+c0186610 t revoked_inode_permission
+c0186616 t revoked_inode_getattr
+c018661c t revoked_inode_setattr
+c0186622 t revoked_inode_setxattr
+c0186628 t revoked_inode_getxattr
+c018662e t revoked_inode_listxattr
+c0186634 t revoked_inode_removexattr
+c018663a t revoked_readpage
+c0186640 t revoked_writepage
+c0186646 t revoked_prepare_write
+c018664c t revoked_commit_write
+c0186652 t revoked_direct_IO
+c0186658 T make_revoked_inode
+c01866dd t revoked_file_flush
+c01866e4 T get_inotify_watch
+c01866e9 t inode_find_handle
+c018671f T inotify_get_cookie
+c018672e T inotify_find_update_watch
+c01867b0 t set_dentry_child_flags
+c01868dc T inotify_add_watch
+c01869c7 t remove_watch_no_event
+c0186a02 T inotify_inode_queue_event
+c0186ad2 T inotify_remove_watch_locked
+c0186b10 T inotify_inode_is_dead
+c0186b7c T inotify_unmount_inodes
+c0186d01 T put_inotify_watch
+c0186d41 T inotify_rm_wd
+c0186dcb T inotify_rm_watch
+c0186dd3 T inotify_init
+c0186e2d T inotify_d_instantiate
+c0186e9f T inotify_d_move
+c0186eba T inotify_dentry_parent_queue_event
+c0186f4b T inotify_init_watch
+c0186f65 T inotify_find_watch
+c0186fbe T inotify_destroy
+c018705c t inotify_ioctl
+c018707e t inotify_get_sb
+c0187092 t remove_kevent
+c01870c5 t free_inotify_user_watch
+c0187107 t inotify_release
+c0187167 T sys_inotify_rm_watch
+c01871b9 t kernel_event
+c01872e5 t inotify_poll
+c0187328 t inotify_read
+c018747a t inotify_dev_queue_event
+c018758f T sys_inotify_init
+c01876f2 T sys_inotify_add_watch
+c018783c t ep_poll_safewake
+c01878dd t ep_unregister_pollwait
+c018791f t ep_remove
+c01879b0 T eventpoll_release_file
+c0187a0f t ep_free
+c0187a7f t ep_eventpoll_release
+c0187a91 T sys_epoll_wait
+c0187e3c T sys_epoll_pwait
+c0187f1f T sys_epoll_ctl
+c01882b3 t ep_ptable_queue_proc
+c0188318 T sys_epoll_create
+c01883dc t ep_eventpoll_poll
+c018841d t ep_poll_callback
+c01884ac t anon_inodefs_delete_dentry
+c01884b6 t anon_inodefs_get_sb
+c01884ca T anon_inode_getfd
+c0188614 T signalfd_deliver
+c0188692 t signalfd_unlock
+c01886a7 t signalfd_lock
+c0188704 t signalfd_read
+c0188a2b t signalfd_cleanup
+c0188a57 t signalfd_release
+c0188a65 t signalfd_poll
+c0188adf T sys_signalfd
+c0188c58 t eventfd_release
+c0188c66 t eventfd_poll
+c0188ccd T sys_eventfd
+c0188d40 t eventfd_write
+c0188eaa T eventfd_signal
+c0188f45 T eventfd_fget
+c0188f68 t eventfd_read
+c01890b4 t scanarg
+c01890f0 t unquote
+c0189181 t bm_get_sb
+c0189192 t bm_fill_super
+c01891b1 t bm_clear_inode
+c01891bc t parse_command
+c0189227 t kill_node
+c01892d3 t bm_status_write
+c0189363 t bm_status_read
+c01893b9 t bm_entry_read
+c018961b t load_misc_binary
+c0189936 t bm_entry_write
+c01899b8 t bm_register_write
+c0189f00 t load_script
+c018a0bc t dump_write
+c018a0dd t maydump
+c018a11b t notesize
+c018a143 t alignfile
+c018a1db t writenote
+c018a27e t fill_prstatus
+c018a352 t dump_seek
+c018a3e8 t set_brk
+c018a462 t elf_map
+c018a50a t padzero
+c018a52e t load_elf_library
+c018a73d t load_elf_binary
+c018bb95 t elf_core_dump
+c018c6b4 t __mb_cache_entry_unhash
+c018c6db t __mb_cache_entry_forget
+c018c722 t __mb_cache_entry_release_unlock
+c018c7a6 t __mb_cache_entry_find
+c018c8b7 T mb_cache_entry_find_next
+c018c920 T mb_cache_entry_free
+c018c93c T mb_cache_entry_release
+c018c951 T mb_cache_entry_alloc
+c018c98c T mb_cache_entry_insert
+c018ca6b T mb_cache_entry_get
+c018cba4 T mb_cache_entry_find_first
+c018cbff T mb_cache_destroy
+c018ccd9 t mb_cache_shrink_fn
+c018cd94 T mb_cache_shrink
+c018ce11 T mb_cache_create
+c018cf80 T posix_acl_valid
+c018d03d T posix_acl_equiv_mode
+c018d0d9 T posix_acl_create_masq
+c018d1e8 T posix_acl_chmod_masq
+c018d277 T posix_acl_clone
+c018d29a T posix_acl_alloc
+c018d2b8 T posix_acl_from_mode
+c018d31f T posix_acl_permission
+c018d418 T posix_acl_to_xattr
+c018d46c T posix_acl_from_xattr
+c018d540 T mark_info_dirty
+c018d551 T unregister_quota_format
+c018d582 T register_quota_format
+c018d5ab t shrink_dqcache_memory
+c018d655 T vfs_get_dqinfo
+c018d6ed T dquot_commit_info
+c018d726 t dqput
+c018d89f t dqget
+c018dade T vfs_set_dqblk
+c018dc9a T vfs_get_dqblk
+c018dd72 T dquot_drop
+c018ddbe T dquot_initialize
+c018de45 t put_quota_format
+c018de4d t vfs_quota_on_inode
+c018e225 T vfs_quota_on_mount
+c018e285 T dquot_mark_dquot_dirty
+c018e2c4 T vfs_quota_off
+c018e6b3 t check_bdq
+c018e85c t check_idq
+c018e98a t print_warning
+c018eab4 T dquot_transfer
+c018edf0 T dquot_acquire
+c018eea9 T dquot_release
+c018ef33 T vfs_quota_sync
+c018f068 T vfs_quota_on
+c018f0bb T dquot_commit
+c018f16b T dquot_free_inode
+c018f276 T dquot_free_space
+c018f3ff T dquot_alloc_space
+c018f545 T dquot_alloc_inode
+c018f64c T vfs_set_dqinfo
+c018f6fc t v2_read_file_info
+c018f784 t v2_check_quota_file
+c018f7f4 t getdqbuf
+c018f81e t put_free_dqblk
+c018f890 t remove_free_dqentry
+c018fa71 t remove_tree
+c018ff09 t v2_release_dquot
+c018ff49 t get_free_dqblk
+c0190042 t find_tree_dqentry
+c019024c t do_insert_tree
+c0190619 t v2_write_file_info
+c01906c1 t v2_write_dquot
+c019080f t v2_read_dquot
+c01909d4 t quota_sync_sb
+c0190a80 T sync_dquots
+c0190b7c T sys_quotactl
+c0191224 t redo_inode_mask
+c0191249 T __inode_dir_notify
+c01912cd T dnotify_parent
+c019132a T dnotify_flush
+c019139e T fcntl_dirnotify
+c0191504 T get_vmalloc_info
+c01915f8 T task_vsize
+c01915ff t vma_stop
+c019161d t m_next
+c0191653 t add_to_pagemap
+c01916be t pagemap_fill
+c01916e0 t pagemap_pte_range
+c0191789 t pad_len_spaces
+c01917bd t show_map
+c01919e9 t m_start
+c0191aeb t do_maps_open
+c0191b45 t smaps_open
+c0191b4c t maps_open
+c0191b53 t clear_refs_pte_range
+c0191be4 T task_mem
+c0191cba T task_statm
+c0191d06 t smaps_pte_range
+c0191df0 t show_smap
+c0191ea2 t pagemap_read
+c0192173 T proc_exe_link
+c01922b4 t m_stop
+c01922db t clear_refs_write
+c0192478 T de_get
+c0192481 t proc_remount
+c019248a t proc_read_inode
+c01924ac t proc_destroy_inode
+c01924b9 t proc_alloc_inode
+c019250e T proc_get_inode
+c01925e0 t init_once
+c01925e8 T de_put
+c0192649 t proc_delete_inode
+c019268a T proc_fill_super
+c019271c t proc_root_readdir
+c0192775 t proc_root_getattr
+c0192799 t proc_root_lookup
+c01927bf t proc_get_sb
+c0192818 T mem_lseek
+c0192850 t name_to_int
+c0192891 t proc_pid_schedstat
+c01928bd t proc_fill_cache
+c01929c7 t mounts_poll
+c0192a0d t get_fs_struct
+c0192a37 t proc_base_instantiate
+c0192b2e t mounts_release
+c0192b61 t proc_pid_auxv
+c0192bba t proc_pid_environ
+c0192c25 t task_dumpable
+c0192c64 t proc_pid_make_inode
+c0192cee t get_nr_threads
+c0192d23 t proc_oom_score
+c0192d70 t proc_pid_wchan
+c0192dbd t proc_setattr
+c0192de5 t next_tgid
+c0192e1e t proc_pident_readdir
+c0193037 t proc_tid_base_readdir
+c0193051 t proc_tgid_base_readdir
+c019306b t proc_readfd_common
+c01932ae t proc_readfdinfo
+c01932bf t proc_readfd
+c01932d0 t proc_lookupfd_common
+c01933b8 t proc_lookupfdinfo
+c01933c2 t proc_lookupfd
+c01933cc t tid_fd_revalidate
+c019354f t proc_fd_info
+c01936e9 t proc_fd_link
+c01936fa t pid_revalidate
+c01938a7 t proc_task_instantiate
+c0193912 t proc_pid_instantiate
+c019397d t proc_pident_instantiate
+c0193a01 t proc_pident_lookup
+c0193b76 t proc_tid_base_lookup
+c0193b8c t proc_tgid_base_lookup
+c0193ba2 t proc_fd_access_allowed
+c0193c4d t proc_task_getattr
+c0193d19 t proc_fdinfo_read
+c0193d64 t proc_pid_cmdline
+c0193e45 t mem_open
+c0193e5a t proc_fd_permission
+c0193e85 t proc_fdinfo_instantiate
+c0193ee3 t proc_pid_follow_link
+c0193f19 t proc_pid_readlink
+c0193ff5 t proc_self_readlink
+c0194067 t proc_self_follow_link
+c01940ca t pid_getattr
+c0194122 t pid_delete_dentry
+c0194133 T proc_flush_task
+c0194311 t proc_fd_instantiate
+c0194426 t proc_cwd_link
+c0194525 t proc_root_link
+c0194624 t mounts_open
+c019477e t mountstats_open
+c01948a7 t proc_info_read
+c01949ca t mem_read
+c0194c4a t oom_adjust_read
+c0194d45 t oom_adjust_write
+c0194eb9 t proc_coredump_filter_read
+c0194fed t proc_coredump_filter_write
+c0195146 t proc_base_revalidate
+c019524e T proc_pid_lookup
+c01953ad T proc_pid_readdir
+c01955b3 t proc_task_lookup
+c0195780 t proc_task_readdir
+c0195acc t proc_file_lseek
+c0195b02 t proc_delete_dentry
+c0195b08 t proc_match
+c0195b2e t xlate_proc_name
+c0195bc4 T free_proc_entry
+c0195c24 T remove_proc_entry
+c0195da2 t proc_getattr
+c0195dc1 t proc_create
+c0195eab t proc_register
+c0195fab T create_proc_entry
+c019604b T proc_mkdir_mode
+c019609f T proc_mkdir
+c01960ab T proc_readdir
+c01962ec T proc_symlink
+c019637a t proc_file_read
+c01965b1 t proc_file_write
+c01965e5 t proc_notify_change
+c0196626 t proc_follow_link
+c0196639 T proc_lookup
+c019677c T proc_pid_statm
+c0196823 t collect_sigign_sigcatch
+c0196854 t render_sigset_t
+c0196925 t do_task_stat
+c01973a8 T proc_tgid_stat
+c01973b2 T proc_tid_stat
+c01973b9 T proc_pid_status
+c0197a40 t t_next
+c0197a5e T proc_tty_register_driver
+c0197ab9 t tty_drivers_open
+c0197ac5 t show_tty_range
+c0197c59 t show_tty_driver
+c0197e1d t t_stop
+c0197e27 t t_start
+c0197e6a t tty_ldiscs_read_proc
+c0197f18 T proc_tty_unregister_driver
+c0197f40 t proc_calc_metrics
+c0197f77 t devinfo_start
+c0197f8c t devinfo_next
+c0197faf t devinfo_stop
+c0197fb0 t int_seq_start
+c0197fc5 t int_seq_next
+c0197fe8 t int_seq_stop
+c0197fe9 T create_seq_entry
+c0197fff t execdomains_read_proc
+c0198037 t locks_read_proc
+c019805c t cmdline_read_proc
+c01980ac t filesystems_read_proc
+c01980e4 t write_sysrq_trigger
+c019810d t interrupts_open
+c0198119 t slabinfo_open
+c0198125 t modules_open
+c0198131 t diskstats_open
+c019813d t partitions_open
+c0198149 t vmstat_open
+c0198155 t devinfo_open
+c0198161 t cpuinfo_open
+c019816d t zoneinfo_open
+c0198179 t fragmentation_open
+c0198185 t stat_open
+c01981fc t show_stat
+c019886e t devinfo_show
+c01988c6 t loadavg_read_proc
+c0198a05 t uptime_read_proc
+c0198ad4 t meminfo_read_proc
+c0198ea6 t version_read_proc
+c0198f30 t proc_sys_refresh_inode
+c0198f71 T proc_sys_init
+c0198f99 t proc_sys_lookup_table_one
+c0198fdb t proc_sys_lookup_table
+c0199024 t do_proc_sys_lookup
+c0199061 t proc_sys_revalidate
+c0199094 t proc_sys_make_inode
+c01990fd t proc_sys_readdir
+c01993f9 t proc_sys_write
+c0199485 t proc_sys_read
+c019950e t proc_sys_setattr
+c0199536 t proc_sys_permission
+c01995cb t proc_sys_lookup
+c0199624 t proc_net_ns_exit
+c0199642 t proc_net_ns_init
+c0199699 T proc_net_init
+c01996c2 t proc_net_shadow_dentry
+c0199727 t proc_net_setattr
+c0199771 t proc_net_lookup
+c01997b9 t proc_net_follow_link
+c01997f0 t notesize
+c0199818 t open_kcore
+c0199828 t storenote
+c01998a7 T kclist_add
+c01998d2 t read_kcore
+c0199efc t open_vmcore
+c0199eff t read_from_oldmem
+c0199f8e t read_vmcore
+c019a1e8 t kmsg_poll
+c019a212 t kmsg_read
+c019a248 t kmsg_release
+c019a256 t kmsg_open
+c019a264 t part_attr_show
+c019a27d t part_attr_store
+c019a29c t part_stat_read
+c019a2df t part_size_read
+c019a306 t part_start_read
+c019a32c t part_dev_read
+c019a36a t part_uevent_store
+c019a37e t part_release
+c019a386 t make_block_name
+c019a405 T read_dev_sector
+c019a474 T delete_partition
+c019a4ff T del_gendisk
+c019a600 T disk_name
+c019a688 T bdevname
+c019a6a1 T add_partition
+c019a7dd T __bdevname
+c019a815 T register_disk
+c019a9f0 T rescan_partitions
+c019ac58 t parse_solaris_x86
+c019ac59 t parse_freebsd
+c019ac5a t parse_netbsd
+c019ac5b t parse_openbsd
+c019ac5c t parse_unixware
+c019ac5d t parse_minix
+c019ac5e T msdos_partition
+c019b1e0 T sysfs_hash_and_remove
+c019b264 T sysfs_instantiate
+c019b293 T sysfs_init_inode
+c019b347 T sysfs_get_inode
+c019b375 T sysfs_setattr
+c019b4f0 t subsys_attr_store
+c019b518 t sysfs_poll
+c019b57f t sysfs_open_file
+c019b695 t sysfs_write_file
+c019b792 T sysfs_schedule_callback
+c019b822 t sysfs_schedule_callback_work
+c019b848 T sysfs_remove_file_from_group
+c019b882 T sysfs_remove_file
+c019b890 T sysfs_add_file
+c019b914 T sysfs_create_file
+c019b941 T sysfs_notify
+c019b9b1 t subsys_attr_show
+c019b9d3 t sysfs_release
+c019ba12 T sysfs_add_file_to_group
+c019ba51 T sysfs_chmod_file
+c019baff T sysfs_update_file
+c019bbee t sysfs_read_file
+c019bce4 T sysfs_unlink_sibling
+c019bd07 t sysfs_ilookup_test
+c019bd14 T sysfs_find_dirent
+c019bd46 T sysfs_remove_one
+c019bd7c t sysfs_empty_dir
+c019bdb5 t __remove_dir
+c019bdcd T sysfs_get_active
+c019bdf7 T sysfs_link_sibling
+c019be10 T sysfs_add_one
+c019be6e t sysfs_attach_dentry
+c019bee5 t sysfs_free_ino
+c019bf09 T sysfs_addrm_start
+c019bf8d T release_sysfs_dirent
+c019bff5 t sysfs_dir_close
+c019c022 T sysfs_addrm_finish
+c019c224 t remove_dir
+c019c24b T sysfs_remove_dir
+c019c2bd T sysfs_remove_subdir
+c019c2c2 T sysfs_new_dirent
+c019c3a8 T sysfs_resolve_for_create
+c019c4de t sysfs_dir_open
+c019c573 t create_dir
+c019c61b T sysfs_create_dir
+c019c675 T sysfs_create_subdir
+c019c68b T sysfs_put_active
+c019c6a9 T sysfs_put_active_two
+c019c6c0 T sysfs_get_active_two
+c019c6f0 T sysfs_get_dentry
+c019c87f T sysfs_enable_shadowing
+c019c8ea t sysfs_lookup
+c019ca14 t sysfs_readdir
+c019cb99 t sysfs_dir_lseek
+c019cc59 T sysfs_resolve_for_remove
+c019cc8f T sysfs_get_dirent
+c019ccf4 T sysfs_move_dir
+c019cebc t sysfs_d_iput
+c019cf05 T sysfs_rename_dir
+c019d101 t sysfs_shadow_follow_link
+c019d180 t sysfs_put_link
+c019d196 t sysfs_follow_link
+c019d2b7 T sysfs_remove_link
+c019d2c1 T sysfs_delete_link
+c019d2cf T sysfs_create_link
+c019d433 T sysfs_rename_link
+c019d454 t sysfs_get_sb
+c019d465 t sysfs_fill_super
+c019d510 t release
+c019d554 t open
+c019d646 t mmap
+c019d6c3 t write
+c019d804 t read
+c019d94a T sysfs_remove_bin_file
+c019d986 T sysfs_create_bin_file
+c019d9b4 t remove_files
+c019d9d8 T sysfs_remove_group
+c019da71 T sysfs_create_group
+c019db58 t devpts_get_sb
+c019db69 t devpts_readdir
+c019db7a t devpts_remount
+c019dc77 t get_node
+c019dcc1 t devpts_filter
+c019dcf5 t devpts_fill_super
+c019ddd6 t devpts_permission
+c019de0e T devpts_pty_new
+c019df74 T devpts_get_tty
+c019dfab T devpts_pty_kill
+c019dfec T dcookie_unregister
+c019e0b3 T get_dcookie
+c019e14b T dcookie_register
+c019e232 T sys_lookup_dcookie
+c019e324 t goal_in_my_reservation
+c019e371 t ext3_group_sparse
+c019e3bf T ext3_get_group_desc
+c019e465 t ext3_has_free_blocks
+c019e605 t read_block_bitmap
+c019e666 t ext3_test_allocatable
+c019e6c2 t bitmap_search_next_usable_block
+c019e742 t ext3_try_to_allocate
+c019e9cb t rsv_window_remove
+c019e9f5 t __rsv_window_dump
+c019eae6 T ext3_free_blocks_sb
+c019ee71 T ext3_free_blocks
+c019ef98 T ext3_rsv_window_add
+c019effe t ext3_try_to_allocate_with_rsv
+c019f433 T ext3_new_blocks
+c019fbe5 T ext3_new_block
+c019fc0a T ext3_should_retry_alloc
+c019fc3d T ext3_count_free_blocks
+c019fc79 T ext3_bg_has_super
+c019fc9e T ext3_bg_num_gdb
+c019fd11 T ext3_init_block_alloc_info
+c019fd74 T ext3_discard_reservation
+c019fdc8 t get_dtype
+c019fde7 T ext3_check_dir_entry
+c019fe9e t free_rb_tree_fname
+c019ff0b T ext3_htree_free_dir_info
+c019ff1b t ext3_release_dir
+c019ff2d t call_filldir
+c019fff6 T ext3_htree_store_dirent
+c01a00c4 t ext3_readdir
+c01a06c8 t ext3_file_write
+c01a0757 t ext3_release_file
+c01a07b8 T ext3_sync_file
+c01a0874 T ext3_count_dirs
+c01a08a6 t read_inode_bitmap
+c01a0909 T ext3_count_free_inodes
+c01a0940 T ext3_orphan_get
+c01a0afe T ext3_new_inode
+c01a15aa T ext3_free_inode
+c01a18e4 t ext3_inode_is_fast_symlink
+c01a1922 t blocks_for_truncate
+c01a1979 t verify_chain
+c01a1999 t walk_page_buffers
+c01a19fd t bget_one
+c01a1a04 t bput_one
+c01a1a0b T ext3_set_aops
+c01a1a8d T ext3_set_inode_flags
+c01a1b07 T ext3_get_inode_flags
+c01a1b4f t start_transaction
+c01a1b89 T ext3_mark_iloc_dirty
+c01a1ecd t __ext3_get_inode_loc
+c01a21c9 T ext3_get_inode_loc
+c01a21da T ext3_reserve_inode_write
+c01a2237 T ext3_mark_inode_dirty
+c01a2271 t try_to_extend_transaction
+c01a2297 t ext3_journal_test_restart
+c01a22ab t ext3_block_to_path
+c01a23c9 t ext3_get_branch
+c01a2494 t ext3_journalled_set_page_dirty
+c01a249e t ext3_writepage_trans_blocks
+c01a2521 t ext3_readpages
+c01a2536 t ext3_readpage
+c01a2542 T ext3_journal_dirty_data
+c01a2574 t journal_dirty_data_fn
+c01a2586 T ext3_get_blocks_handle
+c01a2db4 T ext3_getblk
+c01a3009 t ext3_get_block
+c01a30d9 T ext3_forget
+c01a3196 t ext3_clear_blocks
+c01a3284 t ext3_free_data
+c01a3355 t ext3_free_branches
+c01a3503 T ext3_truncate
+c01a3d65 t commit_write_fn
+c01a3d8f T ext3_bread
+c01a3e0f t do_journal_get_write_access
+c01a3e34 t ext3_invalidatepage
+c01a3e61 t ext3_releasepage
+c01a3ed3 t ext3_bmap
+c01a3f43 T ext3_change_inode_journal_flag
+c01a3ffc t ext3_ordered_commit_write
+c01a40cf t ext3_journalled_commit_write
+c01a41d6 T ext3_write_inode
+c01a4209 t ext3_writeback_commit_write
+c01a42f4 T ext3_delete_inode
+c01a43ae t ext3_prepare_write
+c01a44ff t ext3_ordered_writepage
+c01a4688 t ext3_writeback_writepage
+c01a4757 t ext3_journalled_writepage
+c01a4896 t ext3_direct_IO
+c01a4a30 T ext3_sync_flags
+c01a4b10 T ext3_setattr
+c01a4d16 T ext3_dirty_inode
+c01a4d83 T ext3_read_inode
+c01a509c T ext3_ioctl
+c01a5630 t ext3_update_dx_flag
+c01a564f t ext3_append
+c01a56d0 t ext3_delete_entry
+c01a577b t dx_insert_block
+c01a582e t empty_dir
+c01a5aa4 t add_dirent_to_buf
+c01a5cf3 t do_split
+c01a6121 t ext3_htree_next_block
+c01a61e1 t dx_release
+c01a620f t dx_probe
+c01a64ca t ext3_add_entry
+c01a6c46 t ext3_find_entry
+c01a71dc t ext3_add_nondir
+c01a7216 T ext3_orphan_add
+c01a7369 t htree_dirblock_to_tree
+c01a748d T ext3_htree_fill_tree
+c01a7647 t ext3_create
+c01a7729 t ext3_mknod
+c01a7809 t ext3_symlink
+c01a79a3 t ext3_link
+c01a7a74 T ext3_get_parent
+c01a7b5e t ext3_mkdir
+c01a7db5 T ext3_orphan_del
+c01a7f09 t ext3_rmdir
+c01a80ab t ext3_unlink
+c01a8233 t ext3_rename
+c01a865a t ext3_lookup
+c01a8720 t ext3_get_sb
+c01a8745 t ext3_init_journal_params
+c01a878a t ext3_decode_error
+c01a87fd T ext3_journal_abort_handle
+c01a885b t ext3_commit_super
+c01a88a9 t ext3_mark_recovery_complete
+c01a8902 t ext3_write_super
+c01a891b t ext3_alloc_inode
+c01a8958 t parse_options
+c01a8eb3 t ext3_blkdev_put
+c01a8ec3 t ext3_blkdev_remove
+c01a8eea t ext3_get_journal
+c01a8fb8 t destroy_inodecache
+c01a8fc2 T ext3_warning
+c01a9012 t ext3_clear_journal_err
+c01a90ab T ext3_update_dynamic_rev
+c01a90f9 t ext3_setup_super
+c01a9268 t ext3_handle_error
+c01a930c T __ext3_std_error
+c01a9367 T ext3_error
+c01a93c1 T __ext3_journal_stop
+c01a93f5 t init_once
+c01a943c T ext3_abort
+c01a94fc T ext3_journal_start_sb
+c01a9543 t ext3_write_dquot
+c01a95a4 t ext3_write_info
+c01a95f0 t ext3_show_options
+c01a96cd T ext3_force_commit
+c01a96ed t ext3_sync_fs
+c01a972f t ext3_write_super_lockfs
+c01a977e t ext3_unlockfs
+c01a97c9 t ext3_remount
+c01a9a46 t ext3_statfs
+c01a9b68 t ext3_mark_dquot_dirty
+c01a9b9d t ext3_quota_on
+c01a9c52 t ext3_destroy_inode
+c01a9c62 t ext3_clear_inode
+c01a9cd8 t ext3_get_dentry
+c01a9d6d t ext3_put_super
+c01a9f24 t ext3_fill_super
+c01ab38f t ext3_quota_read
+c01ab4f7 t ext3_quota_write
+c01ab72d t ext3_dquot_initialize
+c01ab787 t ext3_dquot_drop
+c01ab7db t ext3_acquire_dquot
+c01ab83c t ext3_release_dquot
+c01ab8a0 t ext3_follow_link
+c01ab8b4 t str2hashbuf
+c01ab949 T ext3fs_dirhash
+c01abb10 t ext3_list_backups
+c01abb5d t verify_reserved_gdb
+c01abc0e t mark_bitmap_end
+c01abc57 t update_backups
+c01abe7f t bclean
+c01abf1c T ext3_group_extend
+c01ac21d T ext3_group_add
+c01ad544 T __ext3_journal_dirty_metadata
+c01ad57e T __ext3_journal_get_create_access
+c01ad5b8 T __ext3_journal_revoke
+c01ad5f6 T __ext3_journal_forget
+c01ad630 T __ext3_journal_get_write_access
+c01ad66a T __ext3_journal_get_undo_access
+c01ad6a4 t ext3_xattr_check_names
+c01ad6c5 t ext3_xattr_list_entries
+c01ad73a t ext3_xattr_rehash
+c01ad7b9 T exit_ext3_xattr
+c01ad7d2 T ext3_xattr_put_super
+c01ad7dd t ext3_xattr_release_block
+c01ad9eb t ext3_xattr_find_entry
+c01ada9a t ext3_xattr_set_entry
+c01add58 t ext3_xattr_ibody_set
+c01addc1 t ext3_xattr_cache_insert
+c01ade1b t ext3_xattr_block_set
+c01ae740 T ext3_xattr_set_handle
+c01aebb9 T ext3_xattr_set
+c01aec5f T ext3_xattr_list
+c01aedf0 T ext3_listxattr
+c01aedf8 T ext3_xattr_get
+c01af02f T ext3_xattr_delete_inode
+c01af104 t ext3_xattr_user_set
+c01af16e t ext3_xattr_user_list
+c01af1c5 t ext3_xattr_user_get
+c01af228 t ext3_xattr_trusted_set
+c01af27c t ext3_xattr_trusted_get
+c01af2c7 t ext3_xattr_trusted_list
+c01af324 t ext3_xattr_list_acl_default
+c01af363 t ext3_set_acl
+c01af5c1 t ext3_xattr_set_acl
+c01af6d1 t ext3_xattr_set_acl_default
+c01af711 t ext3_get_acl
+c01af9e7 t ext3_xattr_get_acl
+c01afa4d T ext3_permission
+c01afa57 t ext3_xattr_get_acl_access
+c01afa97 t ext3_xattr_get_acl_default
+c01afad7 t ext3_xattr_set_acl_access
+c01afb17 t ext3_xattr_list_acl_access
+c01afb55 t ext3_check_acl
+c01afba2 T ext3_init_acl
+c01afcef T ext3_acl_chmod
+c01afe3c t ext3_xattr_security_set
+c01afe90 T ext3_init_security
+c01afe93 t ext3_xattr_security_get
+c01afede t ext3_xattr_security_list
+c01aff1c T journal_release_buffer
+c01aff1d t __journal_temp_unlink_buffer
+c01b009b T __journal_file_buffer
+c01b02a0 T __journal_unfile_buffer
+c01b02b1 T __journal_refile_buffer
+c01b0394 T journal_refile_buffer
+c01b03f3 t __dispose_buffer
+c01b0435 T journal_stop
+c01b060c t do_get_write_access
+c01b0ac8 T journal_get_write_access
+c01b0aee T journal_unlock_updates
+c01b0b66 T journal_lock_updates
+c01b0c2a t start_this_handle
+c01b0f62 T journal_start
+c01b103f T journal_force_commit
+c01b105a T journal_invalidatepage
+c01b13b1 T journal_extend
+c01b143f T journal_restart
+c01b1557 T journal_get_create_access
+c01b16c4 T journal_get_undo_access
+c01b17c0 T journal_dirty_data
+c01b19a9 T journal_dirty_metadata
+c01b1b60 T journal_forget
+c01b1d60 T journal_unfile_buffer
+c01b1db2 T journal_try_to_free_buffers
+c01b1ef5 T journal_file_buffer
+c01b1f54 t inverted_lock
+c01b1f7b t journal_do_submit_data
+c01b1fa6 t journal_end_buffer_io_sync
+c01b1fbb T journal_commit_transaction
+c01b2fc0 t journal_brelse_array
+c01b2fde t jread
+c01b31ce t do_one_pass
+c01b35f1 T journal_skip_recovery
+c01b364f T journal_recover
+c01b36dc T __journal_drop_transaction
+c01b39ab T __journal_remove_checkpoint
+c01b3a35 t journal_clean_one_cp_list
+c01b3b0d t jbd_sync_bh
+c01b3b4e T cleanup_journal_tail
+c01b3c43 t __flush_batch
+c01b3c7a T log_do_checkpoint
+c01b4070 T __journal_insert_checkpoint
+c01b411e T __log_wait_for_space
+c01b41ab T __journal_clean_checkpoint_list
+c01b4218 T journal_switch_revoke_table
+c01b4258 T journal_clear_revoke
+c01b42a2 t find_revoke_record
+c01b431e T journal_test_revoke
+c01b433a t insert_revoke_hash
+c01b43c2 t flush_descriptor
+c01b4400 T journal_revoke
+c01b451a T journal_destroy_revoke_caches
+c01b4543 T journal_destroy_revoke
+c01b4638 T journal_write_revoke_records
+c01b4761 T journal_cancel_revoke
+c01b47fe T journal_set_revoke
+c01b4834 T journal_init_revoke
+c01b4a3c T journal_check_available_features
+c01b4a6f T journal_blocks_per_page
+c01b4a88 t journal_destroy_caches
+c01b4b0f t journal_fail_superblock
+c01b4b27 T journal_check_used_features
+c01b4b76 t journal_free_journal_head
+c01b4b82 T jbd_slab_free
+c01b4b9d t __journal_remove_journal_head
+c01b4d26 T __log_space_left
+c01b4d4a T journal_put_journal_head
+c01b4dd4 T jbd_slab_alloc
+c01b4dee T journal_add_journal_head
+c01b4f2e T __jbd_kmalloc
+c01b4f44 T journal_ack_err
+c01b4f64 T journal_clear_err
+c01b4f93 T journal_errno
+c01b4fbc t journal_get_superblock
+c01b50df t load_superblock
+c01b5128 T journal_update_format
+c01b51b0 T journal_update_superblock
+c01b5253 T journal_wipe
+c01b52ff T __log_start_commit
+c01b5333 T __journal_abort_hard
+c01b53a1 t __journal_abort_soft
+c01b53d1 T journal_abort
+c01b53d3 T journal_start_commit
+c01b542d T log_start_commit
+c01b5456 T log_wait_commit
+c01b553c T journal_flush
+c01b572c T journal_force_commit_nested
+c01b578b T journal_destroy
+c01b595f t journal_reset
+c01b5a59 t commit_timeout
+c01b5a5e t journal_init_common
+c01b5b63 T journal_bmap
+c01b5bd1 T journal_init_inode
+c01b5cf9 T journal_next_log_block
+c01b5d89 T journal_create
+c01b5eef T journal_load
+c01b5fd0 T journal_set_features
+c01b6022 t kjournald
+c01b620e T journal_grab_journal_head
+c01b6251 T journal_remove_journal_head
+c01b6287 T journal_write_metadata_buffer
+c01b653d T journal_init_dev
+c01b6624 T journal_get_descriptor_buffer
+c01b66b4 t ext2_group_sparse
+c01b66fa T ext2_get_group_desc
+c01b678c t release_blocks
+c01b67a7 t group_release_blocks
+c01b6802 t group_reserve_blocks
+c01b684f t read_block_bitmap
+c01b68b0 t grab_block
+c01b6957 T ext2_count_free_blocks
+c01b6989 T ext2_bg_has_super
+c01b69ae T ext2_bg_num_gdb
+c01b69da T ext2_free_blocks
+c01b6cea T ext2_new_block
+c01b7618 t ext2_last_byte
+c01b762f t ext2_get_page
+c01b786e t ext2_commit_chunk
+c01b78c3 T ext2_find_entry
+c01b7a79 T ext2_make_empty
+c01b7bd0 T ext2_dotdot
+c01b7bf9 t ext2_readdir
+c01b7ea6 T ext2_inode_by_name
+c01b7ed1 T ext2_delete_entry
+c01b8024 T ext2_empty_dir
+c01b810f T ext2_set_link
+c01b8207 T ext2_add_link
+c01b84d8 t ext2_release_file
+c01b84e8 T ext2_sync_file
+c01b8524 T ext2_count_dirs
+c01b8556 T ext2_count_free_inodes
+c01b8588 t read_inode_bitmap
+c01b85eb T ext2_free_inode
+c01b8814 T ext2_new_inode
+c01b9394 T ext2_set_inode_flags
+c01b940e T ext2_get_inode_flags
+c01b9456 t ext2_nobh_prepare_write
+c01b946b t ext2_nobh_writepage
+c01b9477 t ext2_direct_IO
+c01b94d9 t ext2_bmap
+c01b94ea t ext2_prepare_write
+c01b94ff t ext2_readpages
+c01b9514 t ext2_writepages
+c01b951e t ext2_readpage
+c01b952a t ext2_writepage
+c01b9536 T ext2_setattr
+c01b95d3 T ext2_sync_inode
+c01b95ff t ext2_get_inode
+c01b970d t ext2_update_inode
+c01b9a25 T ext2_write_inode
+c01b9a2a t ext2_block_to_path
+c01b9b4c T ext2_discard_prealloc
+c01b9ba5 t ext2_get_branch
+c01b9ca6 t ext2_free_branches
+c01b9e0b T ext2_truncate
+c01ba2bc t ext2_alloc_block
+c01ba35e T ext2_put_inode
+c01ba374 T ext2_sync_flags
+c01ba3e9 T ext2_get_block
+c01ba908 T ext2_read_inode
+c01bac98 T ext2_delete_inode
+c01bad08 T ext2_ioctl
+c01baee8 t ext2_unlink
+c01baf33 T ext2_get_parent
+c01bafb9 t ext2_rmdir
+c01bb016 t ext2_link
+c01bb084 t ext2_mkdir
+c01bb179 t ext2_rename
+c01bb3c7 t ext2_create
+c01bb482 t ext2_mknod
+c01bb4f2 t ext2_symlink
+c01bb60c t ext2_lookup
+c01bb670 t ext2_get_sb
+c01bb695 t ext2_sync_super
+c01bb6d8 t ext2_alloc_inode
+c01bb714 t parse_options
+c01bb87f t ext2_quota_write
+c01bba83 t init_once
+c01bbabb t destroy_inodecache
+c01bbac5 T ext2_write_super
+c01bbb38 t ext2_setup_super
+c01bbc42 T ext2_warning
+c01bbc92 T ext2_error
+c01bbd3d T ext2_update_dynamic_rev
+c01bbd8b t ext2_show_options
+c01bbde5 t ext2_remount
+c01bbf9f t ext2_statfs
+c01bc0ac t ext2_destroy_inode
+c01bc0bc t ext2_clear_inode
+c01bc11f t ext2_get_dentry
+c01bc1b4 t ext2_put_super
+c01bc246 t ext2_fill_super
+c01bcd71 t ext2_quota_read
+c01bcf0c t ext2_follow_link
+c01bcf20 T exit_ext2_xattr
+c01bcf2a T ext2_xattr_put_super
+c01bcf35 t ext2_xattr_cache_insert
+c01bcfa1 t ext2_xattr_set2
+c01bd732 T ext2_listxattr
+c01bd88c T ext2_xattr_delete_inode
+c01bdb1f T ext2_xattr_get
+c01bdcde T ext2_xattr_set
+c01be3ac t ext2_xattr_user_set
+c01be416 t ext2_xattr_user_list
+c01be46d t ext2_xattr_user_get
+c01be4d0 t ext2_xattr_trusted_set
+c01be524 t ext2_xattr_trusted_get
+c01be56f t ext2_xattr_trusted_list
+c01be5cc t ext2_xattr_list_acl_default
+c01be60b t ext2_set_acl
+c01be888 t ext2_xattr_set_acl
+c01be92b t ext2_xattr_set_acl_default
+c01be96b t ext2_get_acl
+c01bec57 t ext2_xattr_get_acl
+c01becbd T ext2_permission
+c01becc7 t ext2_xattr_get_acl_access
+c01bed07 t ext2_xattr_get_acl_default
+c01bed47 t ext2_xattr_set_acl_access
+c01bed87 t ext2_xattr_list_acl_access
+c01bedc5 t ext2_check_acl
+c01bee12 T ext2_init_acl
+c01bef51 T ext2_acl_chmod
+c01bf004 t ext2_xattr_security_set
+c01bf058 T ext2_init_security
+c01bf05b t ext2_xattr_security_get
+c01bf0a6 t ext2_xattr_security_list
+c01bf0e4 T ext2_get_xip_page
+c01bf1c2 T ext2_xip_verify_sb
+c01bf211 T ext2_clear_xip_target
+c01bf258 t cramfs_remount
+c01bf25e t cramfs_get_sb
+c01bf283 t cramfs_put_super
+c01bf29d t cramfs_read
+c01bf45d t get_cramfs_inode
+c01bf4b8 t cramfs_iget5_set
+c01bf5da t cramfs_readdir
+c01bf793 t cramfs_readpage
+c01bf8d2 t cramfs_fill_super
+c01bfad3 t cramfs_iget5_test
+c01bfb5a t cramfs_statfs
+c01bfbc6 t cramfs_lookup
+c01bfd0c T cramfs_uncompress_exit
+c01bfd30 T cramfs_uncompress_init
+c01bfd8c T cramfs_uncompress_block
+c01bfe3c t rootfs_get_sb
+c01bfe53 T ramfs_get_sb
+c01bfe64 T ramfs_get_inode
+c01bff64 t ramfs_fill_super
+c01bffd1 t ramfs_mknod
+c01c004f t ramfs_create
+c01c005f t ramfs_mkdir
+c01c007e t ramfs_symlink
+c01c011c T isofs_lookup
+c01c048c t isofs_remount
+c01c0492 t isofs_hash_common
+c01c04dc t isofs_hashi_common
+c01c0543 t isofs_dentry_cmp_common
+c01c05a3 t isofs_hash
+c01c05aa t isofs_hashi
+c01c05b1 t isofs_dentry_cmp
+c01c05c2 t isofs_hash_ms
+c01c05cc t isofs_hashi_ms
+c01c05d6 t isofs_dentry_cmp_ms
+c01c05e7 t isofs_iget5_set
+c01c05f5 t isofs_get_sb
+c01c061a t isofs_dentry_cmpi_common
+c01c066e t isofs_dentry_cmpi_ms
+c01c067f t isofs_dentry_cmpi
+c01c0690 t _isofs_bmap
+c01c06a1 t isofs_readpage
+c01c06ad t isofs_alloc_inode
+c01c06c8 t init_once
+c01c06d0 t destroy_inodecache
+c01c06da T isofs_iget
+c01c0742 T isofs_get_blocks
+c01c09b3 t isofs_get_block
+c01c09f1 t isofs_put_super
+c01c0a22 t isofs_statfs
+c01c0a99 t isofs_destroy_inode
+c01c0aa6 t isofs_iget5_test
+c01c0ac2 T isofs_bread
+c01c0b29 t isofs_fill_super
+c01c1427 t isofs_read_inode
+c01c1a90 T isofs_name_translate
+c01c1afc T get_acorn_filename
+c01c1bcf t isofs_readdir
+c01c2034 T iso_date
+c01c210c t check_sp
+c01c2134 t setup_rock_ridge
+c01c219d t init_rock_state
+c01c21b6 t rock_check_overflow
+c01c22a0 t rock_continue
+c01c23be t parse_rock_ridge_inode_internal
+c01c2859 T parse_rock_ridge_inode
+c01c2895 T get_rock_ridge_filename
+c01c2aa5 t rock_ridge_symlink_readpage
+c01c2de8 t isofs_export_decode_fh
+c01c2e6e t isofs_export_get_dentry
+c01c2ed8 t isofs_export_encode_fh
+c01c2f7c t isofs_export_get_parent
+c01c3050 T get_joliet_filename
+c01c3154 T zisofs_cleanup
+c01c3184 t zisofs_readpage
+c01c3930 T utf8_mbtowc
+c01c3990 T utf8_mbstowcs
+c01c39dc T utf8_wctomb
+c01c3a32 T utf8_wcstombs
+c01c3a77 t uni2char
+c01c3ab0 t char2uni
+c01c3ac8 T unload_nls
+c01c3ad0 T unregister_nls
+c01c3b15 T register_nls
+c01c3b70 t find_nls
+c01c3bf8 T load_nls
+c01c3c42 T load_nls_default
+c01c3c58 t uni2char
+c01c3c91 t char2uni
+c01c3cac t uni2char
+c01c3ce5 t char2uni
+c01c3d00 t debug_get_sb
+c01c3d11 t debug_fill_super
+c01c3d20 T debugfs_remove
+c01c3df2 t debugfs_mknod
+c01c3edf T debugfs_create_file
+c01c40b5 T debugfs_create_symlink
+c01c4103 T debugfs_create_dir
+c01c4124 t default_read_file
+c01c4127 t default_write_file
+c01c412a t default_open
+c01c413d t debugfs_follow_link
+c01c4150 t debugfs_u8_set
+c01c4153 t debugfs_u8_get
+c01c4159 t debugfs_u16_set
+c01c415d t debugfs_u16_get
+c01c4163 t debugfs_u32_set
+c01c4166 t debugfs_u32_get
+c01c416b t debugfs_u64_set
+c01c4171 t debugfs_u64_get
+c01c4177 T debugfs_create_blob
+c01c4196 T debugfs_create_bool
+c01c41b5 T debugfs_create_u64
+c01c41d4 T debugfs_create_u32
+c01c41f3 T debugfs_create_u16
+c01c4212 T debugfs_create_u8
+c01c4231 t read_file_blob
+c01c425e t read_file_bool
+c01c42a2 t write_file_bool
+c01c42ff t fops_u64_open
+c01c431e t fops_u8_open
+c01c433d t fops_u16_open
+c01c435c t fops_u32_open
+c01c437c T ipc_findkey
+c01c43a6 T ipc_rcu_getref
+c01c43aa T kernel_to_ipc64_perm
+c01c43d6 T ipc64_perm_to_ipc_perm
+c01c4453 T ipc_get
+c01c4479 T ipc_buildid
+c01c4480 T ipc_checkid
+c01c449c T ipc_parse_version
+c01c44b1 T ipc_unlock
+c01c44b6 T ipc_lock_by_ptr
+c01c44bb T ipc_lock
+c01c44fe t sysvipc_proc_next
+c01c456b T ipc_rmid
+c01c45be T ipc_rcu_putref
+c01c45e4 t ipc_immediate_free
+c01c45e9 t ipc_schedule_free
+c01c460a t ipc_do_vfree
+c01c460f T ipc_free
+c01c4621 T ipc_rcu_alloc
+c01c4666 t sysvipc_proc_release
+c01c468c t sysvipc_proc_show
+c01c46ac t sysvipc_proc_stop
+c01c46d3 t sysvipc_proc_start
+c01c4755 t sysvipc_proc_open
+c01c47c7 T ipc_init_ids
+c01c484f T free_ipc_ns
+c01c4874 T ipc_addid
+c01c49b7 T ipcperms
+c01c4a29 T ipc_alloc
+c01c4a3f T copy_ipcs
+c01c4adc T free_msg
+c01c4afa T store_msg
+c01c4b66 T load_msg
+c01c4c74 t testmsg
+c01c4cb1 t expunge_all
+c01c4ce6 t ss_wakeup
+c01c4d0f T do_msgrcv
+c01c4f6f T sys_msgrcv
+c01c4fc0 T do_msgsnd
+c01c51fd T sys_msgsnd
+c01c523c t freeque
+c01c529f t newque
+c01c5377 t __msg_init_ns
+c01c539d t sysvipc_msg_proc_show
+c01c5417 T msg_exit_ns
+c01c5477 T msg_init_ns
+c01c54a1 T sys_msgget
+c01c5564 T sys_msgctl
+c01c5a40 t try_atomic_semop
+c01c5b52 t lookup_undo
+c01c5b82 t update_queue
+c01c5bff T exit_sem
+c01c5d49 T copy_semundo
+c01c5dbe T sys_semtimedop
+c01c63e6 T sys_semop
+c01c6411 t copy_semid_to_user
+c01c6466 t freeary
+c01c6502 T sem_exit_ns
+c01c6562 t newary
+c01c6680 t __sem_init_ns
+c01c66b4 T sem_init_ns
+c01c66de t sysvipc_sem_proc_show
+c01c673c T sys_semget
+c01c683d T sys_semctl
+c01c6fe8 t shm_fault
+c01c6ff8 t shm_fsync
+c01c701c T is_file_shm_hugepages
+c01c701f T sys_shmdt
+c01c712b t shm_open
+c01c716c t shm_mmap
+c01c71aa t shm_destroy
+c01c7279 t do_shm_rmid
+c01c729c T shm_exit_ns
+c01c72fa t shm_get_unmapped_area
+c01c730a t shm_release
+c01c7337 T do_shmat
+c01c769f T sys_shmat
+c01c76c5 t newseg
+c01c78f0 t __shm_init_ns
+c01c791d t sysvipc_shm_proc_show
+c01c7997 T shm_init_ns
+c01c79c1 T sys_shmget
+c01c7aa3 t shm_close
+c01c7b15 T sys_shmctl
+c01c8134 t sysctl_ipc_data
+c01c81cf t proc_ipc_doulongvec_minmax
+c01c8222 t proc_ipc_dointvec
+c01c8278 t msg_insert
+c01c82cb t mqueue_get_sb
+c01c82dc t mqueue_alloc_inode
+c01c82f7 t mqueue_unlink
+c01c8336 t remove_notification
+c01c8385 t mqueue_get_inode
+c01c8667 t mqueue_create
+c01c872f t mqueue_fill_super
+c01c8782 t init_once
+c01c878a T sys_mq_getsetattr
+c01c888b t prepare_timeout
+c01c891d t wq_sleep
+c01c8a05 t do_open
+c01c8a90 t mqueue_destroy_inode
+c01c8a9d t mqueue_delete_inode
+c01c8b94 t mqueue_read_file
+c01c8cc6 t mqueue_flush_file
+c01c8d03 t mqueue_poll_file
+c01c8d5c T sys_mq_timedreceive
+c01c8f3c T sys_mq_unlink
+c01c901d T sys_mq_timedsend
+c01c92c5 T sys_mq_notify
+c01c958c T sys_mq_open
+c01c97d8 T cap_netlink_recv
+c01c97ea T cap_capable
+c01c9862 T cap_capget
+c01c9883 T cap_capset_set
+c01c98a0 T cap_task_reparent_to_init
+c01c98c6 T cap_vm_enough_memory
+c01c98e8 T cap_inode_removexattr
+c01c9922 T cap_settime
+c01c9932 T cap_ptrace
+c01c995c T cap_inode_setxattr
+c01c9996 T cap_netlink_send
+c01c99f1 T cap_bprm_set_security
+c01c9a5c T cap_bprm_secureexec
+c01c9a8a T cap_task_post_setuid
+c01c9ba0 T cap_syslog
+c01c9bed T cap_capset_check
+c01c9c2f T cap_bprm_apply_creds
+c01c9d78 T crypto_mod_get
+c01c9da0 t crypto_exit_ops
+c01c9dde T crypto_shoot_alg
+c01c9dfa T __crypto_alloc_tfm
+c01c9f00 T crypto_mod_put
+c01c9f2a T crypto_free_tfm
+c01c9f86 t crypto_larval_wait
+c01c9fc8 t crypto_larval_destroy
+c01c9fec T __crypto_alg_lookup
+c01ca0df t crypto_alg_lookup
+c01ca10f T crypto_alg_mod_lookup
+c01ca2d1 T crypto_has_alg
+c01ca2ec T crypto_alloc_base
+c01ca34c T scatterwalk_map
+c01ca395 T scatterwalk_start
+c01ca3aa t scatterwalk_pagedone
+c01ca3e5 T scatterwalk_copychunks
+c01ca4b1 T scatterwalk_done
+c01ca4c4 t setkey
+c01ca4f9 T crypto_exit_cipher_ops
+c01ca4fa t cipher_crypt_unaligned
+c01ca571 t cipher_encrypt_unaligned
+c01ca5a8 t cipher_decrypt_unaligned
+c01ca5df T crypto_init_cipher_ops
+c01ca624 t init
+c01ca632 t setkey
+c01ca644 T crypto_init_digest_ops
+c01ca6a4 T crypto_exit_digest_ops
+c01ca6a5 t update2
+c01ca7f9 t final
+c01ca84d t digest
+c01ca8db t update
+c01ca944 t nosetkey
+c01ca950 t crypto_compress
+c01ca972 t crypto_decompress
+c01ca994 T crypto_init_compress_ops
+c01ca9a5 T crypto_exit_compress_ops
+c01ca9a8 t elv_iosched_allow_merge
+c01ca9cd T elv_rq_merge_ok
+c01caa15 t elevator_find
+c01caa51 t elevator_init_queue
+c01caa57 t elv_rqhash_del
+c01caa84 T elv_rb_find
+c01caac0 T elv_queue_empty
+c01caade T elv_latter_request
+c01caaf5 T elv_former_request
+c01cab0c T elv_set_request
+c01cab2e T elv_put_request
+c01cab3f T elv_may_queue
+c01cab56 T elv_rb_latter_request
+c01cab6a T elv_rb_former_request
+c01cab7e T elv_iosched_show
+c01cac38 t elv_drain_elevator
+c01cac90 T elv_dequeue_request
+c01cacc8 t elv_rqhash_add
+c01cad11 t elv_rqhash_reposition
+c01cad3f T elv_merge_requests
+c01cad79 T elv_merged_request
+c01cada9 t elevator_get
+c01cadf1 t elevator_put
+c01cadf9 t elevator_release
+c01cae17 t elv_attr_store
+c01cae6b t elv_attr_show
+c01caebb T elevator_exit
+c01caeed t elevator_alloc
+c01cafad T elevator_init
+c01cb086 t __elv_unregister_queue
+c01cb0a0 T elv_unregister_queue
+c01cb0aa T elv_unregister
+c01cb13e T elv_register_queue
+c01cb18f T elv_completed_request
+c01cb1fd T elv_next_request
+c01cb3a8 T elv_insert
+c01cb592 T __elv_add_request
+c01cb614 T elv_add_request
+c01cb657 T elv_requeue_request
+c01cb69c T elv_rb_del
+c01cb6ca T elv_rb_add
+c01cb737 T elv_register
+c01cb7dd T elv_iosched_store
+c01cb96a T elv_dispatch_sort
+c01cba16 T elv_merge
+c01cbbc5 T elv_dispatch_add_tail
+c01cbc0c t blk_queue_congestion_threshold
+c01cbc42 T blk_queue_prep_rq
+c01cbc46 T blk_queue_merge_bvec
+c01cbc4a T blk_queue_softirq_done
+c01cbc4e t rq_init
+c01cbce0 T blk_queue_issue_flush_fn
+c01cbce4 T blk_ordered_cur_seq
+c01cbcfa T blk_queue_hardsect_size
+c01cbd02 T blk_queue_dma_alignment
+c01cbd09 t blk_phys_contig_segment
+c01cbd9f t ioc_set_batching
+c01cbdcf T blkdev_issue_flush
+c01cbdff T disk_round_stats
+c01cbe61 t drive_stat_acct
+c01cbea6 t blk_done_softirq
+c01cbef5 T swap_io_context
+c01cbf00 T blk_unregister_queue
+c01cbf3e T blk_put_queue
+c01cbf48 T blk_register_queue
+c01cbfb2 T blk_recount_segments
+c01cc16d t blk_hw_contig_segment
+c01cc1fe T blk_ordered_req_seq
+c01cc264 T blk_queue_find_tag
+c01cc283 t current_io_context
+c01cc2eb T put_io_context
+c01cc339 T copy_io_context
+c01cc35b T kblockd_flush_work
+c01cc360 T kblockd_schedule_work
+c01cc36c T ll_back_merge_fn
+c01cc4c7 T blk_rq_bio_prep
+c01cc54c t init_request_from_bio
+c01cc623 T blk_dump_rq_flags
+c01cc700 T blk_queue_end_tag
+c01cc79d T blk_queue_segment_boundary
+c01cc7d7 T blk_queue_max_segment_size
+c01cc811 T blk_queue_max_hw_segments
+c01cc84b T blk_queue_max_phys_segments
+c01cc885 T blk_queue_max_sectors
+c01cc8df T blk_queue_ordered
+c01cc942 t ordered_bio_endio
+c01cc9a3 t __end_that_request_first
+c01ccdc0 T end_that_request_chunk
+c01ccdc5 T end_that_request_first
+c01ccdcd t handle_bad_sector
+c01cce68 T generic_make_request
+c01cd1a6 t blk_unplug_timeout
+c01cd220 t __freed_request
+c01cd295 t freed_request
+c01cd2cc T __blk_put_request
+c01cd341 T end_that_request_last
+c01cd3ee T end_request
+c01cd420 T blk_ordered_complete_seq
+c01cd497 t post_flush_end_io
+c01cd4b8 t bar_end_io
+c01cd4d9 t pre_flush_end_io
+c01cd4fa T blk_end_sync_rq
+c01cd51d T blk_put_request
+c01cd553 T blk_rq_map_kern
+c01cd5c9 t __blk_rq_unmap_user
+c01cd5e2 T blk_rq_unmap_user
+c01cd61a T blk_rq_map_user
+c01cd7d4 T blk_requeue_request
+c01cd88a t get_request
+c01cdb3c t attempt_merge
+c01cdce4 T blk_alloc_queue_node
+c01cdd7b T blk_alloc_queue
+c01cdd83 t queue_var_store
+c01cdda5 t queue_max_sectors_store
+c01cde12 t queue_ra_store
+c01cde4a t queue_var_show
+c01cde65 t queue_max_hw_sectors_show
+c01cde6f t queue_max_sectors_show
+c01cde79 t queue_ra_show
+c01cde84 t queue_requests_show
+c01cde8c t queue_attr_store
+c01cdeea t __blk_free_tags
+c01cdf3f T blk_free_tags
+c01cdf4d T blk_cleanup_queue
+c01cdf83 T blk_sync_queue
+c01cdf8d t blk_release_queue
+c01cdfdb T blk_remove_plug
+c01ce039 T __generic_unplug_device
+c01ce058 T blk_execute_rq_nowait
+c01ce0e4 T blk_execute_rq
+c01ce1c9 T blk_start_queueing
+c01ce1e2 T blk_insert_request
+c01ce25f t get_request_wait
+c01ce3cb T blk_get_request
+c01ce428 T generic_unplug_device
+c01ce449 T blk_plug_device
+c01ce4f6 T blk_run_queue
+c01ce559 t init_tag_map
+c01ce5e8 T blk_queue_resize_tags
+c01ce6ac t __blk_queue_init_tags
+c01ce6ff T blk_init_tags
+c01ce705 T blk_queue_bounce_limit
+c01ce741 T blk_queue_make_request
+c01ce817 T blk_init_queue_node
+c01ce96b T blk_init_queue
+c01ce973 t queue_flush
+c01ce9da t flush_dry_bio_endio
+c01cea4a T blk_stop_queue
+c01cea5d T blk_queue_free_tags
+c01cea67 T blk_queue_stack_limits
+c01ceb35 T blk_get_queue
+c01ceb56 t queue_attr_show
+c01cebb0 T blk_complete_request
+c01cebeb T blk_start_queue
+c01cec62 T blk_rq_map_sg
+c01ced9c T blk_queue_init_tags
+c01cee13 T get_io_context
+c01cee20 T blk_queue_invalidate_tags
+c01cee9f T exit_io_context
+c01cef0a T submit_bio
+c01cefc5 T blk_get_backing_dev_info
+c01cefd8 T blk_rq_map_user_iov
+c01cf058 T blk_do_ordered
+c01cf29d T blk_queue_start_tag
+c01cf37c t __make_request
+c01cf86e t blk_backing_dev_unplug
+c01cf8e9 t blk_unplug_work
+c01cf961 t queue_requests_store
+c01cfa9c T compat_blkdev_ioctl
+c01cfae4 T blkdev_driver_ioctl
+c01cfb42 T blkdev_ioctl
+c01d01bc t exact_match
+c01d01c0 t part_next
+c01d01d8 t disk_attr_show
+c01d01f4 t disk_attr_store
+c01d0213 t diskstats_next
+c01d022b T set_device_ro
+c01d0243 T set_disk_ro
+c01d026a T bdev_read_only
+c01d028b t disk_capability_read
+c01d02a9 t disk_size_read
+c01d02d0 t disk_removable_read
+c01d02f1 t disk_range_read
+c01d030f t disk_dev_read
+c01d0340 t disk_stats_read
+c01d0607 t disk_uevent_store
+c01d061b t block_uevent
+c01d07dd t disk_release
+c01d0809 t diskstats_show
+c01d0b98 t diskstats_stop
+c01d0ba2 t part_stop
+c01d0bac t diskstats_start
+c01d0bed T unregister_blkdev
+c01d0c63 T blkdev_show
+c01d0cc0 t base_probe
+c01d0cfd T invalidate_partition
+c01d0d31 T put_disk
+c01d0d3e T get_disk
+c01d0d84 t exact_lock
+c01d0d91 T alloc_disk_node
+c01d0e79 T alloc_disk
+c01d0e81 t media_change_notify_thread
+c01d0ed2 T genhd_media_change_notify
+c01d0eeb T get_gendisk
+c01d0f05 T blk_unregister_region
+c01d0f13 T unlink_gendisk
+c01d0f2c T blk_register_region
+c01d0f60 T add_disk
+c01d0fa1 t part_start
+c01d0fe2 t block_uevent_filter
+c01d100b t show_partition
+c01d1113 T register_blkdev
+c01d11f0 t __blk_send_generic
+c01d1286 t verify_command
+c01d12e8 t sg_io
+c01d15d7 T sg_scsi_ioctl
+c01d1879 T scsi_cmd_ioctl
+c01d1be8 t noop_former_request
+c01d1bf7 t noop_latter_request
+c01d1c05 t noop_exit_queue
+c01d1c15 t noop_init_queue
+c01d1c34 t noop_add_request
+c01d1c48 t noop_merged_requests
+c01d1c58 t noop_dispatch
+c01d1c86 t noop_queue_empty
+c01d1c98 t cfq_queue_empty
+c01d1ca9 t cfq_choose_req
+c01d1eb2 t cfq_activate_request
+c01d1eed t cfq_var_store
+c01d1f0f t cfq_slice_async_rq_store
+c01d1f33 t cfq_slice_async_store
+c01d1f65 t cfq_slice_sync_store
+c01d1f97 t cfq_slice_idle_store
+c01d1fbc t cfq_back_seek_penalty_store
+c01d1fe0 t cfq_back_seek_max_store
+c01d1ffa t cfq_fifo_expire_async_store
+c01d202c t cfq_fifo_expire_sync_store
+c01d205e t cfq_quantum_store
+c01d2082 t cfq_var_show
+c01d209d t cfq_slice_async_rq_show
+c01d20a8 t cfq_slice_async_show
+c01d20be t cfq_slice_sync_show
+c01d20d4 t cfq_slice_idle_show
+c01d20ea t cfq_back_seek_penalty_show
+c01d20f5 t cfq_back_seek_max_show
+c01d2100 t cfq_fifo_expire_async_show
+c01d2119 t cfq_fifo_expire_sync_show
+c01d2132 t cfq_quantum_show
+c01d2140 t cfq_rb_erase
+c01d2161 t cfq_rb_first
+c01d2177 t cfq_free_io_context
+c01d220b t cfq_drop_dead_cic
+c01d227c t cfq_cic_rb_lookup
+c01d22c7 t cfq_deactivate_request
+c01d2308 t cfq_service_tree_add
+c01d24ca t cfq_resort_rr_list
+c01d24d8 t __cfq_slice_expired
+c01d253a t cfq_put_queue
+c01d25ab t cfq_put_request
+c01d25f2 t cfq_exit_cfqq
+c01d261b t __cfq_exit_single_io_context
+c01d2669 t cfq_shutdown_timer_wq
+c01d2684 t cfq_exit_queue
+c01d26ff t cfq_kick_queue
+c01d2727 t cfq_idle_class_timer
+c01d2775 t cfq_init_prio_data
+c01d281c t cfq_get_queue
+c01d2983 t cfq_exit_io_context
+c01d29d0 t cfq_remove_request
+c01d2b07 t cfq_dispatch_insert
+c01d2b39 t cfq_add_rq_rb
+c01d2ba4 t cfq_merged_request
+c01d2bd5 t cfq_insert_request
+c01d2fe1 t cfq_merge
+c01d3050 t cfq_slab_kill
+c01d306d t cfq_init_queue
+c01d3156 t cfq_merged_requests
+c01d3188 t cfq_dispatch_requests
+c01d33ff t cfq_may_queue
+c01d34aa t cfq_allow_merge
+c01d3504 t cfq_completed_request
+c01d376e t cfq_set_request
+c01d3a46 t cfq_idle_slice_timer
+c01d3ab0 t blk_dropped_open
+c01d3abf t blk_check_time
+c01d3b0e t blk_trace_check_cpu_time
+c01d3b2d t trace_note
+c01d3be9 t blk_trace_startstop
+c01d3c79 t blk_remove_buf_file_callback
+c01d3c81 t blk_remove_tree
+c01d3cc7 t blk_trace_remove
+c01d3d12 T blk_trace_shutdown
+c01d3d2c t blk_create_buf_file_callback
+c01d3d42 t blk_subbuf_start_callback
+c01d3d65 t blk_dropped_read
+c01d3dc9 T blk_trace_ioctl
+c01d40bb T __blk_add_trace
+c01d42b8 t skip_sep
+c01d42d2 t skip_arg
+c01d42ec T argv_free
+c01d430b T argv_split
+c01d439c T __bitmap_empty
+c01d43f6 T __bitmap_full
+c01d4453 T __bitmap_equal
+c01d44b9 T __bitmap_complement
+c01d4513 T __bitmap_and
+c01d4549 T __bitmap_or
+c01d457f T __bitmap_xor
+c01d45b5 T __bitmap_andnot
+c01d45ed T __bitmap_intersects
+c01d464e T __bitmap_subset
+c01d46bb t __reg_op
+c01d4782 T bitmap_find_free_region
+c01d47da T bitmap_release_region
+c01d47eb T bitmap_allocate_region
+c01d4827 T __bitmap_weight
+c01d488b T __bitmap_shift_left
+c01d49b1 T __bitmap_parse
+c01d4b6e T __bitmap_shift_right
+c01d4cb3 t bitmap_ord_to_pos
+c01d4d06 t bitmap_pos_to_ord
+c01d4d65 T bitmap_bitremap
+c01d4de4 T bitmap_parse_user
+c01d4e2d T bitmap_scnprintf
+c01d4ef3 T bitmap_scnlistprintf
+c01d4fe5 T bitmap_remap
+c01d50d9 T bitmap_parselist
+c01d51a4 T find_bug
+c01d5204 T report_bug
+c01d52ad T module_bug_cleanup
+c01d52b7 T module_bug_finalize
+c01d535c T memparse
+c01d53ac T get_option
+c01d53f6 T get_options
+c01d5470 T __first_cpu
+c01d548a T __next_cpu
+c01d54ab T __any_online_cpu
+c01d54d8 T _atomic_dec_and_lock
+c01d5520 t cmp_ex
+c01d5530 T search_extable
+c01d5565 T sort_extable
+c01d558c t idr_mark_full
+c01d55b7 T idr_find
+c01d55f3 t free_bitmap
+c01d5628 t free_layer
+c01d5651 t alloc_layer
+c01d5686 T idr_destroy
+c01d56a6 T ida_destroy
+c01d56b7 t idr_get_empty_slot
+c01d588d T ida_get_new_above
+c01d59f1 T ida_get_new
+c01d59fa t idr_get_new_above_int
+c01d5a38 T idr_get_new
+c01d5a5e T idr_get_new_above
+c01d5a84 T idr_pre_get
+c01d5ab3 T ida_pre_get
+c01d5b00 T idr_init
+c01d5b5f T ida_init
+c01d5b79 T idr_remove
+c01d5cbc T ida_remove
+c01d5d7b t idr_cache_ctor
+c01d5d89 T idr_replace
+c01d5df4 T int_sqrt
+c01d5e20 T ioremap_page_range
+c01d5ee8 t dir_release
+c01d5eed T kobject_get_path
+c01d5f6e T kobject_put
+c01d5f80 T kobject_cleanup
+c01d5fd4 t kobject_release
+c01d5fdc t unlink
+c01d6015 T kobject_get
+c01d6028 T subsys_create_file
+c01d6069 T kobject_del
+c01d607f T kobject_unregister
+c01d60a1 T kset_unregister
+c01d60ae T subsystem_unregister
+c01d60b3 T kobject_move
+c01d61ad T kobject_add
+c01d632c T kset_add
+c01d6334 T kobject_init
+c01d6373 T kset_init
+c01d639c T subsystem_init
+c01d63a1 T kset_register
+c01d63bc T subsystem_register
+c01d63c1 T kobject_register
+c01d63f1 T kset_find_obj
+c01d6458 T kobject_set_name
+c01d64ea T kobject_kset_add_dir
+c01d655f T kobject_add_dir
+c01d656a T kobject_rename
+c01d6634 T add_uevent_var
+c01d66aa T kobject_uevent_env
+c01d6acd T kobject_uevent
+c01d6ad4 T kref_init
+c01d6ae1 T kref_put
+c01d6b4e T kref_get
+c01d6b8c T walk_page_range
+c01d6d2c t get_index
+c01d6d5b t prio_tree_parent
+c01d6da1 t prio_tree_right
+c01d6e3d t prio_tree_left
+c01d6ebf T prio_tree_replace
+c01d6f12 T prio_tree_remove
+c01d6fad T prio_tree_insert
+c01d7190 T prio_tree_next
+c01d72a8 T radix_tree_tagged
+c01d72ba t radix_tree_node_ctor
+c01d72c8 T radix_tree_tag_clear
+c01d737b t radix_tree_node_rcu_free
+c01d7388 T radix_tree_preload
+c01d7409 t radix_tree_node_alloc
+c01d7479 T radix_tree_lookup_slot
+c01d74c5 T radix_tree_lookup
+c01d7515 T radix_tree_gang_lookup
+c01d7649 T radix_tree_gang_lookup_tag
+c01d780c T radix_tree_insert
+c01d7965 T radix_tree_tag_set
+c01d79ea T radix_tree_delete
+c01d7b84 t __rb_rotate_left
+c01d7bd4 t __rb_rotate_right
+c01d7c24 T rb_insert_color
+c01d7cd1 T rb_first
+c01d7ce3 T rb_last
+c01d7cf5 T rb_next
+c01d7d27 T rb_prev
+c01d7d59 T rb_erase
+c01d7f88 T rb_replace_node
+c01d7fd8 T reciprocal_value
+c01d8010 T rwsem_downgrade_wake
+c01d80ae t rwsem_down_failed_common
+c01d8203 T __init_rwsem
+c01d8229 T rwsem_wake
+c01d8324 T strnchr
+c01d8342 T strstrip
+c01d8389 T strspn
+c01d83b3 T strcspn
+c01d83db T strpbrk
+c01d8402 T strsep
+c01d8422 T memcmp
+c01d8444 T strlcat
+c01d84b0 T strlcpy
+c01d84f2 T strnicmp
+c01d8568 T strcasecmp
+c01d85ac T strncasecmp
+c01d85f8 T simple_strtoul
+c01d86bf T simple_strtol
+c01d86d2 T simple_strtoull
+c01d87e3 T simple_strtoll
+c01d87fb t skip_atoi
+c01d8827 t number
+c01d8a78 T vsscanf
+c01d8e68 T sscanf
+c01d8e81 T vsnprintf
+c01d930d T kvasprintf
+c01d9355 T kasprintf
+c01d936e T sprintf
+c01d9391 T vsprintf
+c01d93a5 T scnprintf
+c01d93d3 T snprintf
+c01d93f5 T vscnprintf
+c01d9414 T find_next_bit
+c01d947d T find_next_zero_bit
+c01d950c T csum_partial
+c01d962c T csum_partial_copy_generic
+c01d9730 t delay_loop
+c01d9754 T use_tsc_delay
+c01d975f T read_current_timer
+c01d9777 T __delay
+c01d977e T __const_udelay
+c01d979f t delay_tsc
+c01d97b2 T __udelay
+c01d97d6 T __ndelay
+c01d97f8 T __get_user_1
+c01d980c T __get_user_2
+c01d9824 T __get_user_4
+c01d983b t bad_get_user
+c01d9844 T memcpy
+c01d986c T memmove
+c01d988e T memset
+c01d98a4 T __put_user_1
+c01d98b8 T __put_user_2
+c01d98d4 T __put_user_4
+c01d98ec T __put_user_8
+c01d9907 t bad_put_user
+c01d9910 T strstr
+c01d9940 T __copy_to_user_ll
+c01d9a0f T __copy_from_user_ll
+c01d9add T __copy_from_user_ll_nozero
+c01d9bab T __copy_from_user_ll_nocache_nozero
+c01d9c91 T __clear_user
+c01d9cbd T __strncpy_from_user
+c01d9cee T copy_from_user
+c01d9d47 T __copy_from_user_ll_nocache
+c01d9e2d T strncpy_from_user
+c01d9e79 T clear_user
+c01d9ecf T strnlen_user
+c01d9f13 T copy_to_user
+c01d9f58 W __div64_32
+c01da01e T div64_64
+c01da094 t u32_swap
+c01da09f t generic_swap
+c01da0b7 T sort
+c01da204 T match_strcpy
+c01da236 T match_strdup
+c01da25c t match_number
+c01da2df T match_hex
+c01da2e9 T match_octal
+c01da2f3 T match_int
+c01da2fa T match_token
+c01da4e0 T half_md4_transform
+c01da7a8 T debug_locks_off
+c01da7dc t __random32
+c01da837 t __set_random32
+c01da889 T random32
+c01da89c T srandom32
+c01da8b0 W bust_spinlocks
+c01da8d4 T hex_dump_to_buffer
+c01daae6 T print_hex_dump
+c01dac1a T print_hex_dump_bytes
+c01dac58 T ioport_map
+c01dac6a T ioport_unmap
+c01dac6b t bad_io_access
+c01dacc3 T pci_iounmap
+c01dace2 T iowrite32_rep
+c01dad1b T iowrite16_rep
+c01dad57 T iowrite8_rep
+c01dad8f T ioread32_rep
+c01dadc7 T ioread16_rep
+c01dae02 T ioread8_rep
+c01dae38 T iowrite8
+c01dae67 T ioread8
+c01dae91 T ioread16be
+c01daeca T iowrite16be
+c01daf0f T ioread32be
+c01daf36 T iowrite32be
+c01daf63 T iowrite16
+c01daf94 T ioread16
+c01dafc0 T iowrite32
+c01dafeb T ioread32
+c01db00f T pci_iomap
+c01db094 W __iowrite32_copy
+c01db0ac W __iowrite64_copy
+c01db0b4 t devm_ioremap_match
+c01db0bc t devm_ioport_map_match
+c01db0c4 t pcim_iomap_release
+c01db0e6 T pcim_iomap_table
+c01db135 T pcim_iounmap
+c01db19e T pcim_iounmap_regions
+c01db1dc T pcim_iomap
+c01db216 T pcim_iomap_regions
+c01db2f8 t devm_ioport_map_release
+c01db2ff T devm_ioport_unmap
+c01db35b T devm_ioport_map
+c01db3b1 T devm_iounmap
+c01db40d t devm_ioremap_release
+c01db414 T devm_ioremap_nocache
+c01db46a T devm_ioremap
+c01db4c4 T __spin_lock_init
+c01db4e0 T __rwlock_init
+c01db4fc T _raw_spin_trylock
+c01db522 T _raw_read_trylock
+c01db537 T _raw_write_trylock
+c01db569 t rwlock_bug
+c01db5c3 T _raw_write_unlock
+c01db61e T _raw_read_unlock
+c01db639 T _raw_read_lock
+c01db65e t spin_bug
+c01db73d T _raw_spin_unlock
+c01db7a7 T _raw_spin_lock
+c01db883 T _raw_write_lock
+c01db8ec T hweight32
+c01db929 T hweight16
+c01db962 T hweight8
+c01db984 T hweight64
+c01db9a4 T plist_del
+c01db9f6 T plist_add
+c01dba7c T list_del
+c01dbad9 T __list_add
+c01dbb35 T list_add
+c01dbb3c T bitrev32
+c01dbb88 T crc32_le
+c01dbc33 T crc32_be
+c01dbce4 T inflate_fast
+c01dc17c T zlib_inflate_workspacesize
+c01dc182 T zlib_inflateReset
+c01dc210 T zlib_inflateInit2
+c01dc261 T zlib_inflateEnd
+c01dc275 t zlib_updatewindow
+c01dc323 T zlib_inflateIncomp
+c01dc4c3 T zlib_inflate
+c01dd5cc T zlib_inflate_table
+c01ddaa8 T textsearch_find_continuous
+c01ddae2 T textsearch_destroy
+c01ddb08 t get_linear_data
+c01ddb2b T textsearch_unregister
+c01ddb81 T textsearch_register
+c01ddc24 T textsearch_prepare
+c01ddd2c T percpu_counter_sum
+c01ddd81 T percpu_counter_mod
+c01dddc8 t __rdmsr_on_cpu
+c01ddddb t __rdmsr_safe_on_cpu
+c01dddf5 t __wrmsr_on_cpu
+c01dde17 t __wrmsr_safe_on_cpu
+c01dde53 t _wrmsr_on_cpu
+c01ddf06 T wrmsr_safe_on_cpu
+c01ddf22 T wrmsr_on_cpu
+c01ddf3e t _rdmsr_on_cpu
+c01ddfdf T rdmsr_safe_on_cpu
+c01ddffb T rdmsr_on_cpu
+c01de018 T pci_unblock_user_cfg_access
+c01de08d T pci_block_user_cfg_access
+c01de0cd T pci_bus_write_config_dword
+c01de127 T pci_bus_write_config_word
+c01de186 T pci_bus_write_config_byte
+c01de1dd T pci_bus_read_config_dword
+c01de248 T pci_bus_read_config_word
+c01de2b4 T pci_bus_read_config_byte
+c01de315 t pci_wait_ucfg
+c01de385 T pci_user_write_config_dword
+c01de3e4 T pci_user_write_config_word
+c01de444 T pci_user_write_config_byte
+c01de49f T pci_user_read_config_dword
+c01de511 T pci_user_read_config_word
+c01de584 T pci_user_read_config_byte
+c01de5ec T pci_walk_bus
+c01de68b T pci_enable_bridges
+c01de6ca T pci_bus_add_device
+c01de715 T pci_bus_add_devices
+c01de80f T pci_bus_alloc_resource
+c01de8d8 T pci_remove_legacy_files
+c01de8d9 t pci_size
+c01de905 t pci_release_bus_bridge_dev
+c01de90a t pci_release_dev
+c01de912 t release_pcibus_dev
+c01de930 t pci_bus_show_cpuaffinity
+c01de965 t pci_alloc_bus
+c01de994 T pci_add_new_bus
+c01deac0 T pci_create_bus
+c01dec6f t pci_read_irq
+c01decbb t pci_read_bases
+c01df11a T pci_device_add
+c01df18d T alloc_pci_dev
+c01df1be T pci_cfg_space_size
+c01df232 T pci_scan_single_device
+c01df665 T pci_scan_slot
+c01df6a9 t pci_fixup_parent_subordinate_busnr
+c01df6f7 T pci_scan_bridge
+c01dfa92 T pci_scan_child_bus
+c01dfb0a T pci_scan_bus_parented
+c01dfb2d T pci_do_scan_bus
+c01dfb44 T pci_read_bridge_bases
+c01dfdd0 t pci_stop_dev
+c01dfe1b T pci_stop_bus_device
+c01dfe48 T pci_remove_bus
+c01dfea0 T pci_remove_bus_device
+c01dff26 T pci_remove_behind_bridge
+c01dff54 T pci_bus_max_busnr
+c01dff90 T pci_find_parent_resource
+c01e0006 W pcibios_set_pcie_reset_state
+c01e000c T pci_set_pcie_reset_state
+c01e0011 T pci_get_interrupt_pin
+c01e0044 T pci_set_consistent_dma_mask
+c01e0074 T pci_select_bars
+c01e00a1 t pci_init
+c01e00c9 t __pci_bus_find_cap_start
+c01e00fe t find_pci_dr
+c01e0128 T pci_intx
+c01e01a9 T pci_disable_device
+c01e0214 t __pci_find_next_cap_ttl
+c01e028f t __pci_find_next_ht_cap
+c01e0319 T pci_find_ht_capability
+c01e0344 T pci_find_next_ht_capability
+c01e034a t __pci_find_next_cap
+c01e0372 T pci_bus_find_capability
+c01e03bb T pci_find_capability
+c01e03ec T pci_choose_state
+c01e0444 T pci_find_next_capability
+c01e0460 T pci_request_region
+c01e0646 T pci_release_region
+c01e0767 T pci_request_selected_regions
+c01e07b9 T pci_request_regions
+c01e07c5 T pci_release_selected_regions
+c01e07eb T pci_release_regions
+c01e07f5 t pcim_release
+c01e0868 T pcim_pin_device
+c01e08b1 T pci_restore_bars
+c01e08fb T pci_set_power_state
+c01e0ac4 t do_pci_enable_device
+c01e0af8 T pci_enable_device_bars
+c01e0b26 T pci_enable_device
+c01e0b30 T pcim_enable_device
+c01e0bd7 T __pci_reenable_device
+c01e0bed t pci_setup
+c01e0d0f T pci_set_dma_mask
+c01e0d39 T pci_restore_state
+c01e0ea7 T pci_enable_wake
+c01e0fa2 T pci_set_master
+c01e0ff7 T pci_set_mwi
+c01e10ea T pci_clear_mwi
+c01e1134 T pci_msi_off
+c01e11cc T pci_find_ext_capability
+c01e1257 T pci_save_state
+c01e13ec t quirk_mellanox_tavor
+c01e13f4 t quirk_citrine
+c01e13ff t quirk_s3_64M
+c01e1458 t quirk_via_bridge
+c01e14d3 t quirk_dunord
+c01e14fc t quirk_transparent_bridge
+c01e1504 t quirk_pcie_mch
+c01e150f t quirk_intel_pcie_pm
+c01e1521 T pci_fixup_device
+c01e1599 t fixup_rev1_53c810
+c01e15bb t quirk_netmos
+c01e1638 t quirk_natoma
+c01e1659 t quirk_vsfx
+c01e167a t quirk_viaetbf
+c01e169b t quirk_triton
+c01e16bc t quirk_nopcipci
+c01e16dd t quirk_isa_dma_hangs
+c01e1701 t msi_ht_cap_enabled
+c01e1790 t quirk_nvidia_ck804_msi_ht_cap
+c01e17fd t quirk_sis_96x_smbus
+c01e1854 t piix4_mem_quirk
+c01e18c9 t piix4_io_quirk
+c01e193c t quirk_pcie_pxh
+c01e195d t quirk_io_region
+c01e19e4 t quirk_vt82c586_acpi
+c01e1a4a t quirk_ati_exploding_mce
+c01e1aad t quirk_nvidia_ck804_pcie_aer_ext_cap
+c01e1b0b t quirk_disable_msi
+c01e1b45 t quirk_msi_ht_cap
+c01e1b88 t quirk_nopciamd
+c01e1bbf t quirk_amd_ioapic
+c01e1bfb t quirk_via_acpi
+c01e1c35 t quirk_passive_release
+c01e1cae t quirk_vialatency
+c01e1d79 t quirk_via_ioapic
+c01e1dcd t quirk_via_vt8237_bypass_apic_deassert
+c01e1e1e t quirk_amd_8131_ioapic
+c01e1e9b t quirk_via_vlink
+c01e1f46 t quirk_mediagx_master
+c01e1fa1 t quirk_sb600_sata
+c01e203d t quirk_svwks_csb5ide
+c01e2088 t k8t_sound_hostbridge
+c01e2110 t asus_hides_ac97_lpc
+c01e21a2 t quirk_ali7101_acpi
+c01e2219 t quirk_vt8235_acpi
+c01e22a8 t quirk_vt82c598_id
+c01e22de t quirk_sis_503
+c01e2371 t quirk_e100_interrupt
+c01e2498 t quirk_p64h2_1k_io
+c01e2539 t quirk_p64h2_1k_io_fix_iobl
+c01e25d6 t quirk_disable_pxb
+c01e264a t asus_hides_smbus_lpc
+c01e26d4 t quirk_piix4_acpi
+c01e282e t quirk_ich4_lpc_acpi
+c01e28a3 t quirk_ich6_lpc_acpi
+c01e2918 t quirk_vt82c686_acpi
+c01e29a7 t asus_hides_smbus_lpc_ich6
+c01e2a08 t quirk_cardbus_legacy
+c01e2a2d t quirk_amd_ordering
+c01e2abc t quirk_jmicron_ata
+c01e2be8 T pci_match_id
+c01e2c5e t pci_device_shutdown
+c01e2c72 T pci_dev_driver
+c01e2c99 t pci_device_resume
+c01e2cd9 t pci_device_resume_early
+c01e2d03 t pci_device_suspend_late
+c01e2d32 t pci_device_suspend
+c01e2d79 T pci_dev_put
+c01e2d86 t pci_device_remove
+c01e2dbb T pci_dev_get
+c01e2dce T pci_match_device
+c01e2e72 t pci_bus_match
+c01e2e88 t pci_device_probe
+c01e2edf T pci_unregister_driver
+c01e2f2b t pci_driver_attr_store
+c01e2f6b t pci_driver_attr_show
+c01e2fa7 T __pci_register_driver
+c01e3026 t store_new_id
+c01e3160 t pci_do_find_bus
+c01e31a0 T pci_find_present
+c01e3288 T pci_dev_present
+c01e3296 T pci_find_device
+c01e3344 T pci_find_slot
+c01e3376 T pci_find_next_bus
+c01e33e7 T pci_find_bus
+c01e3419 T pci_get_class
+c01e34a8 T pci_get_subsys
+c01e3592 T pci_get_device
+c01e35ab T pci_get_bus_and_slot
+c01e35dd T pci_get_slot
+c01e3662 T pci_get_device_reverse
+c01e3714 t broken_parity_status_store
+c01e374f t pci_write_rom
+c01e378f t msi_bus_store
+c01e382d t msi_bus_show
+c01e385e t is_enabled_show
+c01e387f t modalias_show
+c01e38d6 t broken_parity_status_show
+c01e38fd t irq_show
+c01e391e t class_show
+c01e393c t subsystem_device_show
+c01e395b t subsystem_vendor_show
+c01e397a t device_show
+c01e3999 t vendor_show
+c01e39b8 t is_enabled_store
+c01e3a13 t local_cpus_show
+c01e3a5b t pci_remove_resource_files
+c01e3a8b T pci_remove_sysfs_dev_files
+c01e3b21 t pci_write_config
+c01e3c8f t pci_read_config
+c01e3e42 t pci_mmap_resource
+c01e3ea5 T pci_create_sysfs_dev_files
+c01e411e t pci_read_rom
+c01e41c4 t resource_show
+c01e4240 T pci_cleanup_rom
+c01e4284 t pci_disable_rom
+c01e42c3 T pci_remove_rom
+c01e4323 T pci_unmap_rom
+c01e434c T pci_map_rom
+c01e4520 T pci_map_rom_copy
+c01e45c4 T pdev_sort_resources
+c01e4722 T pci_update_resource
+c01e4859 T pci_claim_resource
+c01e496e T pci_assign_resource
+c01e4afc t pci_seq_next
+c01e4b10 t pci_seq_start
+c01e4b3f t proc_bus_pci_dev_open
+c01e4b4b t pci_seq_stop
+c01e4b57 T pci_proc_detach_bus
+c01e4b6f T pci_proc_detach_device
+c01e4b9f T pci_proc_attach_device
+c01e4c5f t proc_bus_pci_release
+c01e4c7b t proc_bus_pci_open
+c01e4caf t proc_bus_pci_mmap
+c01e4cf9 t proc_bus_pci_lseek
+c01e4d78 t show_device
+c01e4ef5 t proc_bus_pci_read
+c01e505e t proc_bus_pci_write
+c01e5179 t proc_bus_pci_ioctl
+c01e51d4 t pcie_port_shutdown_service
+c01e51d5 t pcie_port_suspend_service
+c01e51f7 t pcie_port_resume_service
+c01e5219 t suspend_iter
+c01e5240 t resume_iter
+c01e5265 t remove_iter
+c01e5299 T pcie_port_service_unregister
+c01e52a1 T pcie_port_service_register
+c01e52e7 t pcie_port_remove_service
+c01e533b t pcie_port_probe_service
+c01e53a1 T pcie_port_bus_unregister
+c01e53ab T pcie_port_bus_register
+c01e53b5 T pcie_port_device_resume
+c01e53c4 T pcie_port_device_suspend
+c01e53db T pcie_port_device_remove
+c01e542b t release_pcie_device
+c01e5454 T pcie_port_device_register
+c01e57e8 T pcie_port_device_probe
+c01e5834 t slot_reset_iter
+c01e5885 t resume_iter
+c01e58b6 t pcie_portdrv_err_resume
+c01e58c5 t pcie_portdrv_mmio_enabled
+c01e58e3 t pcie_portdrv_error_detected
+c01e5907 t pcie_portdrv_restore_config
+c01e5929 t pcie_portdrv_slot_reset
+c01e5956 t pcie_portdrv_resume
+c01e5966 t pcie_portdrv_save_config
+c01e596b t pcie_portdrv_suspend
+c01e597e t pcie_portdrv_remove
+c01e5992 t pcie_portdrv_probe
+c01e5a1f t error_detected_iter
+c01e5a73 t mmio_enabled_iter
+c01e5ac4 t pcie_port_bus_match
+c01e5b15 t pcie_port_bus_suspend
+c01e5b37 t pcie_port_bus_resume
+c01e5b5c T aer_print_error
+c01e5e38 t report_slot_reset
+c01e5e72 t report_resume
+c01e5e91 t find_aer_service_iter
+c01e5ecb T aer_init
+c01e5f1b t get_e_source
+c01e5f75 T pci_find_aer_capability
+c01e5fd2 T aer_delete_rootport
+c01e6035 T pci_cleanup_aer_uncorrect_error_status
+c01e60a6 t broadcast_error_message
+c01e6132 T aer_isr
+c01e64fd t report_error_detected
+c01e657f t report_mmio_enabled
+c01e65b9 t find_device_iter
+c01e6645 T pci_enable_pcie_error_reporting
+c01e66a3 T pci_disable_pcie_error_reporting
+c01e6704 T aer_enable_rootport
+c01e6860 t aer_suspend
+c01e6863 t aer_resume
+c01e6866 t aer_error_detected
+c01e686c t aer_remove
+c01e6912 t aer_probe
+c01e6a56 t aer_error_resume
+c01e6af4 t aer_irq
+c01e6bf0 t aer_root_reset
+c01e6cdc T aer_osc_setup
+c01e6d44 T pci_uevent
+c01e6f2c T pci_no_msi
+c01e6f37 T pci_msi_init_pci_dev
+c01e6f47 W arch_msi_check_device
+c01e6f4e W arch_teardown_msi_irqs
+c01e6f75 t msix_flush_writes
+c01e6fb2 t msi_free_irqs
+c01e7055 t msix_free_all_irqs
+c01e705a T msi_remove_pci_irq_vectors
+c01e7088 t pci_msi_check_device
+c01e70ea t msix_set_enable
+c01e7151 T pci_disable_msix
+c01e718e t msi_set_enable
+c01e71f3 T pci_disable_msi
+c01e7263 t alloc_msi_entry
+c01e7294 T write_msi_msg
+c01e735c t msi_set_mask_bit
+c01e740f T pci_restore_msi_state
+c01e757a T unmask_msi_irq
+c01e758c T mask_msi_irq
+c01e75a1 W arch_setup_msi_irqs
+c01e75d9 T pci_enable_msix
+c01e7886 T pci_enable_msi
+c01e7a64 T read_msi_msg
+c01e7b14 T fetch_ht_irq_msg
+c01e7b29 T ht_destroy_irq
+c01e7b58 T __ht_create_irq
+c01e7c4e T ht_create_irq
+c01e7c55 T write_ht_irq_msg
+c01e7d1e T unmask_ht_irq
+c01e7d46 T mask_ht_irq
+c01e7d70 t find_free_bus_resource
+c01e7daf t pbus_size_mem
+c01e7f6a T pci_setup_cardbus
+c01e80f8 T pci_bus_size_bridges
+c01e84c2 T pci_bus_assign_resources
+c01e8860 t acpi_pci_choose_state
+c01e8866 t acpi_pci_find_root_bridge
+c01e88b7 t acpi_pci_find_device
+c01e88ee t acpi_pci_set_power_state
+c01e890a T pci_osc_control_set
+c01e8a89 t acpi_query_osc
+c01e8bc2 T pci_osc_support_set
+c01e8c34 T fb_notifier_call_chain
+c01e8c42 T fb_unregister_client
+c01e8c4e T fb_register_client
+c01e8c5c t dummycon_startup
+c01e8c62 t dummycon_dummy
+c01e8c65 t dummycon_init
+c01e8c90 t vgacon_scrollback_init
+c01e8cd3 t vgacon_build_attr
+c01e8d8b t vgacon_invert_region
+c01e8dea t vga_set_palette
+c01e8ec9 t vgacon_set_palette
+c01e8ef7 t vgacon_dummy
+c01e8efa t vgacon_save_screen
+c01e8f53 t vgacon_restore_screen
+c01e8fac t vgacon_set_origin
+c01e901e t vgacon_doresize
+c01e91b8 t vgacon_resize
+c01e9206 t vgacon_set_cursor_size
+c01e92d2 t vgacon_cursor
+c01e9475 t vgacon_do_font_op
+c01e9803 t vgacon_font_get
+c01e9853 t vgacon_font_set
+c01e9a20 t vgacon_init
+c01e9ad8 t vgacon_switch
+c01e9b9c t vgacon_blank
+c01ea160 t vgacon_scroll
+c01ea3b1 t vgacon_startup
+c01ea6fc t vgacon_scrolldelta
+c01ea8ca t vgacon_deinit
+c01ea938 T acpi_table_print_madt_entry
+c01eab60 T acpi_os_table_override
+c01eab77 t acpi_irq
+c01eab8b T acpi_os_read_port
+c01eabc9 T acpi_os_write_port
+c01eabfb T acpi_os_delete_lock
+c01eabfc T acpi_os_signal_semaphore
+c01eac25 T acpi_set_cstate_limit
+c01eac36 T acpi_os_validate_address
+c01eac39 T acpi_os_validate_interface
+c01eacae t enable_osi_linux
+c01eace5 t dmi_osi_linux
+c01ead0a T acpi_os_signal
+c01ead21 T acpi_os_get_timer
+c01ead5b T acpi_os_release_object
+c01ead63 T acpi_os_delete_cache
+c01ead6b T acpi_os_purge_cache
+c01ead73 T acpi_os_create_cache
+c01eada9 T acpi_os_release_lock
+c01eadae T acpi_os_acquire_lock
+c01eadb3 T acpi_os_delete_semaphore
+c01eadc6 t acpi_os_execute_notify
+c01eadf1 T acpi_os_create_semaphore
+c01eae49 T acpi_os_create_lock
+c01eae5d T acpi_os_wait_events_complete
+c01eae67 t acpi_os_execute_deferred
+c01eae97 T acpi_os_write_pci_configuration
+c01eaf1f T acpi_os_read_pci_configuration
+c01eafac t acpi_os_derive_pci_id_2
+c01eb0e0 T acpi_os_derive_pci_id
+c01eb10f T acpi_os_unmap_memory
+c01eb11e T acpi_os_write_memory
+c01eb163 T acpi_os_stall
+c01eb18c T acpi_os_sleep
+c01eb196 T acpi_os_remove_interrupt_handler
+c01eb1bb T acpi_os_install_interrupt_handler
+c01eb248 T acpi_os_predefined_override
+c01eb2ab T acpi_os_vprintf
+c01eb2d3 T acpi_os_printf
+c01eb2e8 T acpi_os_terminate
+c01eb313 T acpi_os_initialize1
+c01eb379 T acpi_os_execute
+c01eb406 T acpi_os_wait_semaphore
+c01eb4d2 T acpi_os_map_memory
+c01eb4e7 T acpi_os_read_memory
+c01eb534 T acpi_evaluate_reference
+c01eb625 T acpi_evaluate_integer
+c01eb6d0 T acpi_extract_package
+c01eb944 t acpi_ds_get_field_names
+c01ebad0 T acpi_ds_create_index_field
+c01ebb94 T acpi_ds_create_bank_field
+c01ebcba T acpi_ds_create_field
+c01ebd4d T acpi_ds_init_field_objects
+c01ebe24 T acpi_ds_create_buffer_field
+c01ebf38 T acpi_ds_method_data_init
+c01ebfb2 T acpi_ds_method_data_get_node
+c01ec067 t acpi_ds_method_data_set_value
+c01ec09b T acpi_ds_store_object_to_local
+c01ec1ad T acpi_ds_method_data_init_args
+c01ec1ee T acpi_ds_method_data_get_value
+c01ec336 T acpi_ds_method_data_delete_all
+c01ec388 T acpi_ds_exec_end_control_op
+c01ec58d T acpi_ds_exec_begin_control_op
+c01ec5eb T acpi_ds_eval_data_object_operands
+c01ec6da T acpi_ds_eval_region_operands
+c01ec75e t acpi_ds_init_buffer_field
+c01ec9bf T acpi_ds_eval_buffer_field_operands
+c01eca92 T acpi_ds_initialize_region
+c01eca9e t acpi_ds_execute_arguments
+c01ecbd8 T acpi_ds_get_region_arguments
+c01ecc63 T acpi_ds_get_package_arguments
+c01eccb9 T acpi_ds_get_buffer_arguments
+c01ecd0f T acpi_ds_get_buffer_field_arguments
+c01ecd4c T acpi_ds_exec_begin_op
+c01ece4f T acpi_ds_get_predicate_value
+c01ecfc5 T acpi_ds_exec_end_op
+c01ed394 T acpi_ds_scope_stack_pop
+c01ed3b9 T acpi_ds_scope_stack_clear
+c01ed3d9 T acpi_ds_scope_stack_push
+c01ed46c t acpi_ds_create_method_mutex
+c01ed4bd T acpi_ds_terminate_control_method
+c01ed57f T acpi_ds_restart_control_method
+c01ed5d8 T acpi_ds_begin_method_execution
+c01ed730 T acpi_ds_call_control_method
+c01ed87d T acpi_ds_method_error
+c01ed8dc T acpi_ds_init_object_from_op
+c01edac4 t acpi_ds_build_internal_object
+c01edbb3 T acpi_ds_create_node
+c01edc08 T acpi_ds_build_internal_package_obj
+c01edd08 T acpi_ds_build_internal_buffer_obj
+c01ede20 T acpi_ds_create_operand
+c01edff8 T acpi_ds_create_operands
+c01ee066 T acpi_ds_clear_operands
+c01ee095 T acpi_ds_clear_implicit_return
+c01ee0bc T acpi_ds_resolve_operands
+c01ee0ea T acpi_ds_do_implicit_return
+c01ee13a T acpi_ds_is_result_used
+c01ee232 T acpi_ds_delete_result_if_not_used
+c01ee28c T acpi_ds_init_callbacks
+c01ee2f8 T acpi_ds_load2_end_op
+c01ee5cd T acpi_ds_load2_begin_op
+c01ee86d T acpi_ds_load1_end_op
+c01ee9ac T acpi_ds_load1_begin_op
+c01eebdc T acpi_ds_get_current_walk_state
+c01eebe8 T acpi_ds_push_walk_state
+c01eebf1 T acpi_ds_pop_walk_state
+c01eec02 T acpi_ds_obj_stack_pop
+c01eec66 T acpi_ds_obj_stack_push
+c01eecb8 T acpi_ds_result_push
+c01eed76 T acpi_ds_result_pop_from_bottom
+c01eee3e T acpi_ds_result_pop
+c01eeec3 T acpi_ds_delete_walk_state
+c01eef8d T acpi_ds_init_aml_walk
+c01ef08b T acpi_ds_obj_stack_pop_and_delete
+c01ef109 T acpi_ds_result_stack_pop
+c01ef12b T acpi_ds_result_stack_push
+c01ef151 T acpi_ds_create_walk_state
+c01ef1dc T acpi_ds_initialize_objects
+c01ef273 t acpi_ds_init_one_object
+c01ef308 T acpi_ev_fixed_event_detect
+c01ef3bb T acpi_ev_install_xrupt_handlers
+c01ef41c T acpi_ev_install_fadt_gpes
+c01ef45b T acpi_ev_initialize_events
+c01ef4ec T acpi_ev_execute_reg_methods
+c01ef522 T acpi_ev_install_space_handler
+c01ef704 T acpi_ev_attach_region
+c01ef727 T acpi_ev_initialize_op_regions
+c01ef763 T acpi_ev_install_region_handlers
+c01ef7cc T acpi_ev_address_space_dispatch
+c01ef976 T acpi_ev_execute_reg_method
+c01efa8a t acpi_ev_reg_run
+c01efac8 T acpi_ev_detach_region
+c01efbfa t acpi_ev_install_handler
+c01efc78 T acpi_ev_remove_sci_handler
+c01efc89 T acpi_ev_gpe_xrupt_handler
+c01efc8e t acpi_ev_sci_xrupt_handler
+c01efca7 T acpi_ev_install_sci_handler
+c01efcc0 T acpi_remove_gpe_block
+c01efd26 T acpi_install_gpe_block
+c01efe26 T acpi_clear_gpe
+c01efe7b T acpi_clear_event
+c01efe9a T acpi_disable_event
+c01eff0e T acpi_enable_event
+c01eff85 T acpi_disable_gpe
+c01effda T acpi_enable_gpe
+c01f0034 T acpi_set_gpe_type
+c01f0067 T acpi_disable
+c01f00ab T acpi_enable
+c01f00fc T acpi_ev_is_notify_object
+c01f011e T acpi_ev_terminate
+c01f0203 t acpi_ev_global_lock_handler
+c01f0257 T acpi_ev_release_global_lock
+c01f02f9 T acpi_ev_init_global_lock_handler
+c01f035e t acpi_ev_notify_dispatch
+c01f03b0 T acpi_ev_queue_notify_request
+c01f0463 T acpi_ev_acquire_global_lock
+c01f04ec T acpi_ev_io_space_region_setup
+c01f04fb t acpi_ev_match_pci_root_bridge
+c01f055b T acpi_ev_pci_bar_region_setup
+c01f055e T acpi_ev_cmos_region_setup
+c01f0561 T acpi_ev_default_region_setup
+c01f0570 T acpi_ev_initialize_region
+c01f068f T acpi_ev_pci_config_region_setup
+c01f08b0 T acpi_ev_system_memory_region_setup
+c01f0920 T acpi_release_global_lock
+c01f0936 T acpi_acquire_global_lock
+c01f0976 T acpi_remove_gpe_handler
+c01f0a43 T acpi_install_gpe_handler
+c01f0b49 T acpi_remove_notify_handler
+c01f0d41 T acpi_install_notify_handler
+c01f0f03 T acpi_remove_fixed_event_handler
+c01f0f7c T acpi_install_fixed_event_handler
+c01f102c T acpi_remove_address_space_handler
+c01f10eb T acpi_install_address_space_handler
+c01f1168 T acpi_ev_update_gpe_enable_masks
+c01f11e2 T acpi_ev_disable_gpe
+c01f123b T acpi_ev_gpe_dispatch
+c01f1391 T acpi_ev_set_gpe_type
+c01f13c8 T acpi_ev_enable_gpe
+c01f142e t acpi_ev_asynch_execute_gpe_method
+c01f1534 T acpi_ev_gpe_detect
+c01f160c T acpi_ev_get_gpe_event_info
+c01f1688 T acpi_ev_valid_gpe_event
+c01f16c5 T acpi_ev_initialize_gpe_block
+c01f174a t acpi_ev_match_prw_and_gpe
+c01f1806 T acpi_ev_delete_gpe_handlers
+c01f185a T acpi_ev_walk_gpe_list
+c01f18ae T acpi_ev_create_gpe_block
+c01f1c18 T acpi_ev_gpe_initialize
+c01f1db4 t acpi_ev_save_method_info
+c01f1e31 T acpi_ev_delete_gpe_block
+c01f1f24 T acpi_ex_unload_table
+c01f1f61 t acpi_ex_add_table
+c01f1fca T acpi_ex_load_op
+c01f20a0 T acpi_ex_load_table_op
+c01f223c T acpi_ex_read_data_from_field
+c01f2375 T acpi_ex_write_data_to_field
+c01f259c t acpi_ex_allocate_name_string
+c01f2640 t acpi_ex_name_segment
+c01f270e T acpi_ex_get_name_string
+c01f28d0 t acpi_ex_do_match
+c01f296c T acpi_ex_opcode_6A_0T_1R
+c01f2b60 T acpi_ex_resolve_multiple
+c01f2d67 T acpi_ex_resolve_to_value
+c01f2fac T acpi_ex_store_string_to_string
+c01f3054 T acpi_ex_store_buffer_to_buffer
+c01f3110 t acpi_ex_convert_to_ascii
+c01f3219 T acpi_ex_convert_to_string
+c01f3373 T acpi_ex_convert_to_buffer
+c01f3401 T acpi_ex_convert_to_integer
+c01f3509 T acpi_ex_convert_to_target_type
+c01f35f8 t acpi_ex_register_overflow
+c01f3629 T acpi_ex_access_region
+c01f383f t acpi_ex_field_datum_io
+c01f39e6 T acpi_ex_extract_from_field
+c01f3c1c T acpi_ex_write_with_update_rule
+c01f3d50 T acpi_ex_insert_into_field
+c01f400c T acpi_ex_opcode_1A_0T_1R
+c01f4507 T acpi_ex_opcode_1A_1T_1R
+c01f4a65 T acpi_ex_opcode_1A_1T_0R
+c01f4ab3 T acpi_ex_opcode_1A_0T_0R
+c01f4b4f T acpi_ex_opcode_0A_0T_1R
+c01f4be4 T acpi_ex_prep_common_field_object
+c01f4cb3 T acpi_ex_prep_field_value
+c01f4e68 t acpi_ex_check_object_type
+c01f4ed5 T acpi_ex_resolve_operands
+c01f5430 T acpi_ex_system_reset_event
+c01f545d T acpi_ex_system_signal_event
+c01f5471 T acpi_ex_system_do_suspend
+c01f548f T acpi_ex_system_do_stall
+c01f54cc T acpi_ex_system_wait_mutex
+c01f550b T acpi_ex_system_wait_semaphore
+c01f554a T acpi_ex_system_wait_event
+c01f5560 T acpi_ex_create_method
+c01f5600 T acpi_ex_create_power_resource
+c01f566a T acpi_ex_create_processor
+c01f56db T acpi_ex_create_alias
+c01f5733 T acpi_ex_create_table_region
+c01f581e T acpi_ex_create_region
+c01f58ee T acpi_ex_create_mutex
+c01f5965 T acpi_ex_create_event
+c01f59c8 T acpi_ex_do_math_op
+c01f5aec T acpi_ex_do_logical_numeric_op
+c01f5b3f T acpi_ex_do_logical_op
+c01f5c72 T acpi_ex_get_object_reference
+c01f5d47 T acpi_ex_concat_template
+c01f5e12 T acpi_ex_do_concatenate
+c01f5ff8 T acpi_ex_opcode_2A_0T_1R
+c01f6132 T acpi_ex_opcode_2A_1T_1R
+c01f64b7 T acpi_ex_opcode_2A_2T_1R
+c01f65e0 T acpi_ex_opcode_2A_0T_0R
+c01f6678 T acpi_ex_cmos_space_handler
+c01f667b T acpi_ex_pci_bar_space_handler
+c01f667e T acpi_ex_data_table_space_handler
+c01f66a9 T acpi_ex_pci_config_space_handler
+c01f6705 T acpi_ex_system_io_space_handler
+c01f6746 T acpi_ex_system_memory_space_handler
+c01f6968 T acpi_ex_store_object_to_node
+c01f6a13 t acpi_ex_do_debug_object
+c01f6a8b T acpi_ex_store
+c01f6cc4 T acpi_ex_truncate_for32bit_table
+c01f6ce3 T acpi_ex_unsigned_integer_to_string
+c01f6d7f T acpi_ex_eisa_id_to_string
+c01f6df7 T acpi_ex_release_global_lock
+c01f6e2c T acpi_ex_acquire_global_lock
+c01f6e6f T acpi_ex_exit_interpreter
+c01f6e9e T acpi_ex_relinquish_interpreter
+c01f6ead T acpi_ex_enter_interpreter
+c01f6edc T acpi_ex_reacquire_interpreter
+c01f6eec T acpi_ex_unlink_mutex
+c01f6f17 T acpi_ex_release_all_mutexes
+c01f6f6b T acpi_ex_release_mutex
+c01f70dd T acpi_ex_acquire_mutex
+c01f720c T acpi_ex_opcode_3A_0T_0R
+c01f72a7 T acpi_ex_opcode_3A_1T_1R
+c01f7464 T acpi_ex_resolve_node_to_value
+c01f7680 T acpi_ex_store_object_to_object
+c01f7790 T acpi_ex_resolve_object
+c01f7864 T acpi_hw_get_mode
+c01f7894 T acpi_hw_set_mode
+c01f7988 T acpi_hw_enable_all_wakeup_gpes
+c01f7992 T acpi_hw_enable_all_runtime_gpes
+c01f799c T acpi_hw_disable_all_gpes
+c01f79b0 t acpi_hw_enable_wakeup_gpe_block
+c01f79ea T acpi_hw_enable_runtime_gpe_block
+c01f7a24 T acpi_hw_clear_gpe_block
+c01f7a56 T acpi_hw_disable_gpe_block
+c01f7a88 T acpi_hw_clear_gpe
+c01f7aaf T acpi_hw_write_gpe_enable_reg
+c01f7ad0 T acpi_hw_low_level_write
+c01f7b46 T acpi_hw_get_bit_register_info
+c01f7b7e T acpi_hw_low_level_read
+c01f7bf9 T acpi_hw_register_read
+c01f7d4f T acpi_hw_register_write
+c01f7e9a T acpi_get_register
+c01f7ee5 T acpi_set_register
+c01f804d T acpi_get_sleep_type_data
+c01f820b T acpi_hw_clear_acpi_status
+c01f8274 T acpi_enter_sleep_state_prep
+c01f8390 T acpi_leave_sleep_state
+c01f85d7 T acpi_enter_sleep_state_s4bios
+c01f8649 T acpi_set_firmware_waking_vector
+c01f8686 T acpi_enter_sleep_state
+c01f883c T acpi_ns_lookup
+c01f8b50 T acpi_ns_root_initialize
+c01f8e38 T acpi_ns_load_table
+c01f8eb4 T acpi_ns_search_one_scope
+c01f8eeb T acpi_ns_search_and_enter
+c01f9064 T acpi_get_data
+c01f90bc T acpi_detach_data
+c01f910a T acpi_attach_data
+c01f9162 T acpi_get_devices
+c01f91cd T acpi_walk_namespace
+c01f9241 t acpi_ns_get_device_callback
+c01f9390 T acpi_evaluate_object
+c01f9554 T acpi_ns_install_node
+c01f958d T acpi_ns_delete_children
+c01f9602 T acpi_ns_delete_namespace_subtree
+c01f9659 T acpi_ns_delete_node
+c01f96b2 T acpi_ns_delete_namespace_by_owner
+c01f9773 T acpi_ns_create_node
+c01f97ac T acpi_ns_evaluate
+c01f989c T acpi_ns_get_pathname_length
+c01f98c4 T acpi_ns_build_external_path
+c01f9957 T acpi_ns_handle_to_pathname
+c01f9998 T acpi_ns_valid_root_prefix
+c01f99a1 T acpi_ns_get_internal_name_length
+c01f9a00 T acpi_ns_build_internal_name
+c01f9ad0 T acpi_ns_map_handle_to_node
+c01f9aea T acpi_ns_convert_entry_to_handle
+c01f9aeb T acpi_ns_get_parent_node
+c01f9aff T acpi_ns_get_next_valid_node
+c01f9b0d T acpi_ns_opens_scope
+c01f9b50 T acpi_ns_local
+c01f9b93 T acpi_ns_get_type
+c01f9bc3 T acpi_ns_terminate
+c01f9be6 T acpi_ns_externalize_name
+c01f9dc0 T acpi_ns_internalize_name
+c01f9e37 T acpi_ns_get_node
+c01f9eca T acpi_ns_print_node_pathname
+c01f9f35 T acpi_ns_report_method_error
+c01f9fae T acpi_ns_report_error
+c01fa054 T acpi_get_name
+c01fa0ed T acpi_get_handle
+c01fa19a T acpi_get_object_info
+c01fa330 T acpi_ns_initialize_devices
+c01fa407 t acpi_ns_init_one_device
+c01fa4b4 t acpi_ns_find_ini_methods
+c01fa50d T acpi_ns_initialize_objects
+c01fa576 t acpi_ns_init_one_object
+c01fa6b0 T acpi_ns_get_secondary_object
+c01fa6c9 T acpi_ns_get_attached_data
+c01fa6e7 T acpi_ns_detach_data
+c01fa71c T acpi_ns_detach_object
+c01fa754 T acpi_ns_attach_data
+c01fa7c1 T acpi_ns_get_attached_object
+c01fa804 T acpi_ns_attach_object
+c01fa8e8 T acpi_ns_get_next_node
+c01fa91c T acpi_ns_walk_namespace
+c01faa38 T acpi_get_next_object
+c01faabc T acpi_get_type
+c01fab17 T acpi_get_id
+c01fab60 T acpi_get_parent
+c01fabcc T acpi_ns_one_complete_parse
+c01fac9e T acpi_ns_parse_table
+c01facc0 t acpi_ps_get_next_package_length
+c01fad06 T acpi_ps_get_next_package_end
+c01fad14 T acpi_ps_get_next_namestring
+c01fad65 T acpi_ps_get_next_simple_arg
+c01fae4f T acpi_ps_get_next_namepath
+c01fb002 T acpi_ps_get_next_arg
+c01fb228 T acpi_ps_get_opcode_size
+c01fb233 T acpi_ps_peek_opcode
+c01fb248 T acpi_ps_parse_aml
+c01fb47f T acpi_ps_next_parse_state
+c01fb58c T acpi_ps_complete_this_op
+c01fb6d0 t acpi_ps_complete_op
+c01fb8a9 T acpi_ps_parse_loop
+c01fbfe0 T acpi_ps_get_arg
+c01fc013 T acpi_ps_append_arg
+c01fc088 T acpi_ps_delete_parse_tree
+c01fc0cc T acpi_ps_get_opcode_info
+c01fc10a T acpi_ps_get_opcode_name
+c01fc110 T acpi_ps_get_parent_scope
+c01fc117 T acpi_ps_has_completed_scope
+c01fc134 T acpi_ps_cleanup_scope
+c01fc152 T acpi_ps_pop_scope
+c01fc1a7 T acpi_ps_init_scope
+c01fc1e2 T acpi_ps_push_scope
+c01fc23c T acpi_ps_init_op
+c01fc245 T acpi_ps_is_leading_char
+c01fc25e T acpi_ps_is_prefix_char
+c01fc274 T acpi_ps_set_name
+c01fc27e T acpi_ps_free_op
+c01fc297 T acpi_ps_alloc_op
+c01fc313 T acpi_ps_create_scope_op
+c01fc32c T acpi_debug_trace
+c01fc385 t acpi_ps_update_parameter_list
+c01fc3b5 T acpi_ps_execute_method
+c01fc570 T acpi_rs_set_address_common
+c01fc5ad T acpi_rs_get_address_common
+c01fc5fc T acpi_rs_create_aml_resources
+c01fc636 T acpi_rs_create_pci_routing_table
+c01fc93e T acpi_rs_create_resource_list
+c01fc998 T acpi_rs_convert_resources_to_aml
+c01fca50 T acpi_rs_convert_aml_to_resources
+c01fcae4 T acpi_rs_convert_resource_to_aml
+c01fccce T acpi_rs_convert_aml_to_resource
+c01fcffc t acpi_rs_match_vendor_resource
+c01fd07d T acpi_walk_resources
+c01fd10d T acpi_get_vendor_resource
+c01fd156 t acpi_rs_validate_parameters
+c01fd18f T acpi_set_current_resources
+c01fd1c3 T acpi_get_current_resources
+c01fd1e1 T acpi_get_irq_routing_table
+c01fd1ff T acpi_resource_to_address64
+c01fd338 t acpi_rs_count_set_bits
+c01fd34d t acpi_rs_stream_option_length
+c01fd35f T acpi_rs_get_pci_routing_table_length
+c01fd3ea T acpi_rs_get_list_length
+c01fd4fe T acpi_rs_get_aml_length
+c01fd5ac T acpi_rs_decode_bitmask
+c01fd5d3 T acpi_rs_encode_bitmask
+c01fd604 T acpi_rs_set_resource_source
+c01fd62e T acpi_rs_get_resource_source
+c01fd6c7 T acpi_rs_move_data
+c01fd74a T acpi_rs_set_srs_method_data
+c01fd82e T acpi_rs_get_method_data
+c01fd869 T acpi_rs_get_crs_method_data
+c01fd8a9 T acpi_rs_get_prt_method_data
+c01fd8e9 T acpi_rs_set_resource_length
+c01fd914 T acpi_rs_set_resource_header
+c01fd924 T acpi_get_table
+c01fd9b1 T acpi_get_table_by_index
+c01fda18 T acpi_load_tables
+c01fdb98 T acpi_unload_table_id
+c01fdbe0 T acpi_load_table
+c01fdc37 T acpi_allocate_root_table
+c01fdc48 T acpi_reallocate_root_table
+c01fdcc3 T acpi_get_table_header
+c01fdd58 T acpi_tb_set_table_loaded_flag
+c01fdda3 T acpi_tb_is_table_loaded
+c01fdde5 T acpi_tb_get_owner_id
+c01fde25 T acpi_tb_release_owner_id
+c01fde63 T acpi_tb_allocate_owner_id
+c01fdea0 T acpi_tb_delete_namespace_by_owner
+c01fdedf T acpi_tb_delete_table
+c01fdf14 T acpi_tb_terminate
+c01fdf79 T acpi_tb_resize_root_table_list
+c01fe051 T acpi_tb_store_table
+c01fe0f2 T acpi_tb_verify_table
+c01fe138 T acpi_tb_add_table
+c01fe280 T acpi_tb_tables_loaded
+c01fe28d T acpi_tb_checksum
+c01fe29f T acpi_tb_verify_checksum
+c01fe2eb T acpi_tb_print_table_header
+c01fe3d6 T acpi_tb_install_table
+c01fe4b8 T acpi_tb_find_table
+c01fe584 T acpi_tb_create_local_fadt
+c01fe8a1 T acpi_tb_parse_fadt
+c01fe918 T acpi_ut_validate_buffer
+c01fe935 T acpi_ut_delete_caches
+c01fe99c T acpi_ut_create_caches
+c01fea38 T acpi_ut_initialize_buffer
+c01fead8 T acpi_ut_dump_buffer2
+c01fec31 T acpi_ut_dump_buffer
+c01fec54 T acpi_osi_invalidate
+c01fec92 t acpi_ut_translate_one_cid
+c01fece4 T acpi_ut_evaluate_object
+c01fee6b T acpi_ut_execute_sxds
+c01feec6 T acpi_ut_execute_STA
+c01fef0d T acpi_ut_execute_UID
+c01fef78 T acpi_ut_execute_CID
+c01ff058 T acpi_ut_evaluate_numeric_object
+c01ff097 T acpi_ut_osi_implementation
+c01ff13f T acpi_ut_execute_HID
+c01ff1a8 T acpi_ut_subsystem_shutdown
+c01ff244 T acpi_ut_validate_exception
+c01ff2b8 T acpi_ut_is_aml_table
+c01ff2dd T acpi_ut_dword_byte_swap
+c01ff305 T acpi_ut_set_integer_width
+c01ff335 T acpi_ut_valid_acpi_char
+c01ff362 T acpi_ut_valid_acpi_name
+c01ff390 T acpi_ut_repair_name
+c01ff3c1 T acpi_ut_print_string
+c01ff4fb T acpi_ut_info
+c01ff52a T acpi_ut_warning
+c01ff572 T acpi_ut_error
+c01ff5ba T acpi_ut_exception
+c01ff60f T acpi_ut_walk_package_tree
+c01ff6cb T acpi_ut_create_update_state_and_push
+c01ff6f4 T acpi_ut_strtoul64
+c01ff931 T acpi_ut_release_owner_id
+c01ff9db T acpi_ut_allocate_owner_id
+c01ffaff T acpi_ut_strupr
+c01ffb24 T acpi_purge_cached_objects
+c01ffb4f T acpi_terminate
+c01ffb5e T acpi_initialize_objects
+c01ffb98 T acpi_enable_subsystem
+c01ffc28 t acpi_ut_copy_isimple_to_esimple
+c01ffd0f T acpi_ut_copy_iobject_to_eobject
+c01ffd9f t acpi_ut_copy_ielement_to_eelement
+c01ffe1b T acpi_ut_copy_eobject_to_iobject
+c01fff65 t acpi_ut_copy_simple_object
+c0200057 T acpi_ut_copy_iobject_to_iobject
+c020012b t acpi_ut_copy_ielement_to_ielement
+c02001d0 t acpi_ut_delete_internal_obj
+c0200315 t acpi_ut_update_ref_count
+c02003b5 T acpi_ut_update_object_reference
+c02004d2 T acpi_ut_remove_reference
+c02004f7 T acpi_ut_delete_internal_object_list
+c0200516 T acpi_ut_add_reference
+c0200530 T acpi_ut_hex_to_ascii_char
+c0200549 T acpi_ut_get_region_name
+c0200568 T acpi_ut_get_event_name
+c020057c T acpi_ut_get_type_name
+c0200590 T acpi_ut_get_descriptor_name
+c02005b2 T acpi_ut_valid_object_type
+c02005bc T acpi_ut_init_globals
+c0200740 T acpi_ut_get_node_name
+c0200787 T acpi_format_exception
+c02007c1 T acpi_ut_get_object_type_name
+c02007e4 T acpi_ut_divide
+c0200975 T acpi_ut_short_divide
+c02009e0 T acpi_ut_valid_internal_object
+c02009f4 t acpi_ut_get_simple_object_size
+c0200aca T acpi_ut_get_object_size
+c0200b30 t acpi_ut_get_element_length
+c0200b73 T acpi_ut_delete_object_desc
+c0200bbe T acpi_ut_allocate_object_desc_dbg
+c0200c1e T acpi_ut_create_internal_object_dbg
+c0200c85 T acpi_ut_create_string_object
+c0200d09 T acpi_ut_create_package_object
+c0200d6e T acpi_ut_create_buffer_object
+c0200dfc T acpi_ut_push_generic_state
+c0200e03 T acpi_ut_pop_generic_state
+c0200e12 T acpi_ut_delete_generic_state
+c0200e23 T acpi_ut_create_generic_state
+c0200e5d T acpi_ut_create_control_state
+c0200e71 T acpi_ut_create_pkg_state
+c0200e9d T acpi_ut_create_update_state
+c0200ebb T acpi_ut_create_thread_state
+c0200f08 T acpi_ut_create_pkg_state_and_push
+c0200f2c T acpi_ut_release_mutex
+c0200f8f T acpi_ut_mutex_terminate
+c0200fce T acpi_ut_mutex_initialize
+c0201046 T acpi_ut_acquire_mutex
+c02010c0 T acpi_ut_get_resource_type
+c02010ce T acpi_ut_get_resource_length
+c02010df T acpi_ut_validate_resource
+c0201167 T acpi_ut_get_resource_header_length
+c0201172 T acpi_ut_get_descriptor_length
+c020118c T acpi_ut_walk_aml_resources
+c0201233 T acpi_ut_get_resource_end_tag
+c0201254 t acpi_poweroff_init
+c02012a2 T acpi_power_off
+c02012c9 T acpi_sleep_prepare
+c02012df t acpi_shutdown
+c0201304 T acpi_gpe_sleep_prepare
+c0201340 T acpi_bus_get_status
+c02013c9 t acpi_bus_check_device
+c020142c T acpi_bus_get_device
+c020145a t acpi_bus_notify
+c02014a0 T acpi_bus_get_power
+c020154f T acpi_bus_set_power
+c02016de T acpi_bus_generate_event
+c020179e T acpi_bus_receive_event
+c020188c t acpi_glue_data_handler
+c020188d t acpi_platform_notify
+c020199b T acpi_get_physical_device
+c02019be t acpi_platform_notify_remove
+c0201a1d T acpi_get_child
+c0201a6a t do_acpi_find_child
+c0201ab3 T unregister_acpi_bus_type
+c0201b0b T register_acpi_bus_type
+c0201b74 t acpi_device_suspend
+c0201b93 t acpi_device_resume
+c0201bb2 t acpi_device_shutdown
+c0201bce t acpi_start_single_object
+c0201c09 T acpi_bus_data_handler
+c0201c0a t acpi_device_release
+c0201c23 T acpi_bus_get_ejd
+c0201c90 t acpi_device_path_show
+c0201ce9 t acpi_device_hid_show
+c0201d09 t acpi_device_unregister
+c0201dac t acpi_device_remove
+c0201e0a t acpi_device_probe
+c0201e86 t acpi_device_uevent
+c0201f67 t acpi_bus_remove
+c0201fbd T acpi_bus_trim
+c0202086 t acpi_eject_store
+c02021a7 T acpi_match_ids
+c02021f8 t acpi_add_single_object
+c0202c9a t acpi_bus_scan
+c0202e25 t acpi_bus_match
+c0202e3b T acpi_bus_unregister_driver
+c0202e45 T acpi_bus_register_driver
+c0202e7d T acpi_bus_add
+c0202eba T acpi_bus_start
+c0202eec t acpi_ec_space_setup
+c0202efe t ec_parse_io_ports
+c0202f2c t acpi_ec_stop
+c0202f7d t acpi_ec_gpe_handler
+c0202fde t acpi_ec_wait
+c0203137 t acpi_ec_transaction
+c020332c T ec_transaction
+c0203373 t acpi_ec_write
+c02033af T ec_write
+c02033cb t acpi_ec_read
+c020340d t acpi_ec_space_handler
+c020350b T ec_read
+c020353e T acpi_ec_burst_disable
+c0203570 T ec_burst_disable
+c0203584 T acpi_ec_burst_enable
+c02035b6 T ec_burst_enable
+c02035ca t ec_install_handlers
+c0203648 t acpi_ec_start
+c0203678 t acpi_ec_remove
+c0203726 t make_acpi_ec
+c0203773 t acpi_ec_info_open_fs
+c0203789 t acpi_ec_read_info
+c02037f9 T acpi_ec_add_query_handler
+c0203856 t acpi_ec_register_query_methods
+c02038aa t acpi_ec_add
+c0203a5d T acpi_ec_remove_query_handler
+c0203aab t acpi_ec_gpe_query
+c0203b84 t acpi_pci_bridge_scan
+c0203bcd t acpi_pci_root_start
+c0203bfb t acpi_pci_root_remove
+c0203c17 t get_root_bridge_busnr_callback
+c0203c4f T acpi_pci_register_driver
+c0203c94 T acpi_pci_unregister_driver
+c0203cdc T acpi_get_pci_rootbridge_handle
+c0203d0e t acpi_pci_root_add
+c0203fc8 T acpi_penalize_isa_irq
+c0203fe4 t acpi_pci_link_remove
+c0204020 t acpi_pci_link_check_current
+c020407a t acpi_pci_link_check_possible
+c020416b t acpi_pci_link_get_current
+c0204234 t acpi_pci_link_set
+c02043ef t irqrouter_resume
+c020444e T acpi_pci_link_free_irq
+c02044e2 T acpi_pci_link_allocate_irq
+c02046e7 t acpi_pci_link_add
+c02048c8 W acpi_unregister_gsi
+c02048c9 t acpi_pci_irq_lookup
+c020495b t acpi_pci_irq_derive
+c02049fb T acpi_pci_irq_disable
+c0204aa2 t acpi_pci_free_irq
+c0204ab4 t acpi_pci_allocate_irq
+c0204b01 T acpi_pci_irq_del_prt
+c0204b86 T acpi_pci_irq_enable
+c0204d63 T acpi_pci_irq_add_prt
+c0204f68 t acpi_pci_data_handler
+c0204f69 T acpi_get_pci_id
+c0205019 T acpi_pci_bind
+c0205278 T acpi_pci_unbind
+c020538f T acpi_pci_bind_root
+c02054b0 t acpi_power_get_state
+c0205506 t acpi_power_get_context
+c0205557 T acpi_power_get_inferred_state
+c02055f7 t acpi_power_on
+c0205708 t acpi_power_resume
+c020576f T acpi_enable_wakeup_device_power
+c0205822 t acpi_power_remove
+c02058a8 t acpi_power_off_device
+c0205982 T acpi_power_transition
+c0205a72 T acpi_disable_wakeup_device_power
+c0205b25 t acpi_power_open_fs
+c0205b3b t acpi_power_seq_show
+c0205bda t acpi_power_add
+c0205d84 t acpi_table_show
+c0205e0f t param_get_acpica_version
+c0205e30 t acpi_system_poll_event
+c0205e59 t acpi_system_close_event
+c0205e7a t acpi_system_open_event
+c0205eb4 t acpi_system_read_event
+c0205f94 T acpi_unlock_battery_dir
+c0205fe2 T acpi_unlock_ac_dir
+c0206030 T acpi_lock_battery_dir
+c0206072 T acpi_lock_ac_dir
+c02060b4 T __pnp_remove_device
+c02060e9 T pnp_unregister_protocol
+c0206112 T __pnp_add_device
+c02061ca T pnp_add_device
+c020622e t pnp_release_device
+c0206267 T pnp_alloc
+c02062af T pnp_register_protocol
+c0206364 t card_remove
+c020636f T pnp_add_card_id
+c02063a7 t card_suspend
+c02063c2 t card_resume
+c02063de T pnp_unregister_card_driver
+c0206407 t pnp_release_card
+c020642e T pnp_release_card_device
+c0206455 t card_probe
+c020655c T pnp_register_card_driver
+c02065f8 T pnp_request_card_device
+c02066b1 T pnp_remove_card_device
+c02066e5 T pnp_remove_card
+c0206742 t pnp_show_card_ids
+c020677c t pnp_show_card_name
+c020679c T pnp_add_card
+c02068eb T pnp_add_card_device
+c02069a0 t card_remove_first
+c02069e8 T pnp_add_id
+c0206a20 t pnp_bus_resume
+c0206a66 t pnp_bus_suspend
+c0206acb T pnp_unregister_driver
+c0206ad3 T pnp_register_driver
+c0206ae7 T pnp_device_detach
+c0206b19 t pnp_device_remove
+c0206b46 T pnp_device_attach
+c0206b85 T compare_pnp_id
+c0206c1c t match_device
+c0206c49 t pnp_bus_match
+c0206c5e t pnp_device_probe
+c0206ce0 T pnp_register_dma_resource
+c0206d0b T pnp_register_port_resource
+c0206d36 T pnp_register_mem_resource
+c0206d61 t pnp_test_handler
+c0206d67 T pnp_check_dma
+c0206ea1 T pnp_check_irq
+c0207011 T pnp_check_mem
+c02071a2 T pnp_check_port
+c0207333 T pnp_free_option
+c020739a T pnp_register_irq_resource
+c02073e6 t pnp_build_option
+c0207410 T pnp_register_dependent_option
+c0207448 T pnp_register_independent_option
+c0207480 T pnp_init_resource_table
+c02075fd t pnp_clean_resource_table
+c0207774 T pnp_resource_change
+c0207799 T pnp_stop_dev
+c02077fb T pnp_disable_dev
+c0207870 T pnp_start_dev
+c02078d8 t pnp_assign_port
+c02079f3 t pnp_assign_mem
+c0207b36 t pnp_assign_irq
+c0207c46 t pnp_assign_dma
+c0207d13 t pnp_assign_resources
+c0207f74 T pnp_auto_config_dev
+c0207ff8 T pnp_activate_dev
+c020803a T pnp_manual_config_dev
+c0208188 T pnp_is_active
+c020821c T pnp_interface_attach_device
+c0208271 t pnp_show_current_ids
+c02082ab t pnp_printf
+c02082fd t pnp_show_current_resources
+c020857b t pnp_print_option
+c0208982 t pnp_show_options
+c0208a0d t pnp_set_current_resources
+c0208ef0 t quirk_smc_fir_enabled
+c0208f4e T pnp_fixup_device
+c0208f88 t quirk_sb16audio_resources
+c0208fda t quirk_smc_enable
+c02091cc t quirk_cmi8330_resources
+c0209213 t quirk_awe32_resources
+c02092ac t reserve_range
+c02093ba t system_pnp_probe
+c0209498 t pnpacpi_resume
+c02094a5 t pnpacpi_suspend
+c02094b5 t pnpacpi_disable_resources
+c02094dd t pnpacpi_set_resources
+c020952f t pnpacpi_get_resources
+c020954c t irq_flags
+c020956a t decode_irq_flags
+c02095af t pnpacpi_parse_allocated_ioresource
+c0209658 t pnpacpi_parse_allocated_memresource
+c02096f3 t pnpacpi_type_resources
+c020971b T pnpacpi_encode_resources
+c0209982 t dma_flags
+c02099f6 T pnpacpi_build_resource_template
+c0209aa0 T pnpacpi_parse_resource_option_data
+c0209ae7 t pnpacpi_option_resource
+c0209e9d T pnpacpi_parse_allocated_resource
+c0209ec5 t pnpacpi_parse_allocated_irqresource
+c0209f8b t pnpacpi_allocated_resource
+c020a1dd t pnpacpi_count_resources
+c020a1f8 t read_null
+c020a1fb t write_null
+c020a1fe t pipe_to_null
+c020a201 t write_full
+c020a207 t null_lseek
+c020a21a t memory_open
+c020a2cf t read_oldmem
+c020a3a8 t write_mem
+c020a42f t kmsg_write
+c020a48e t mmap_zero
+c020a4c4 t read_zero
+c020a685 t splice_write_null
+c020a6aa t write_kmem
+c020a82a t read_kmem
+c020a921 t open_port
+c020a931 t mmap_mem
+c020a9b1 t mmap_kmem
+c020a9d9 t memory_lseek
+c020aa4e t read_port
+c020aac1 t write_port
+c020ab50 t read_mem
+c020abd4 t twothirdsMD4Transform
+c020af5b t credit_entropy_store
+c020afa3 t __add_entropy_words
+c020b127 t account
+c020b1f0 t add_timer_randomness
+c020b2fb T add_disk_randomness
+c020b31f T add_interrupt_randomness
+c020b33f T add_input_randomness
+c020b36e t extract_buf
+c020b440 t extract_entropy
+c020b4c9 T get_random_bytes
+c020b4ec t rekey_seq_generator
+c020b535 T generate_random_uuid
+c020b558 t uuid_strategy
+c020b5d7 t proc_do_uuid
+c020b6ea t xfer_secondary_pool
+c020b7bf t extract_entropy_user
+c020b883 t urandom_read
+c020b88d t write_pool
+c020b8ed t init_std_data
+c020b963 t random_ioctl
+c020baa8 t random_write
+c020baf8 T secure_ip_id
+c020bb39 T get_random_int
+c020bb50 T randomize_range
+c020bb82 T rand_initialize_disk
+c020bba0 T secure_ipv6_port_ephemeral
+c020bbe9 t random_poll
+c020bc31 T secure_tcpv6_sequence_number
+c020bc9f T secure_tcp_sequence_number
+c020bd0f T secure_ipv4_port_ephemeral
+c020bd54 t random_read
+c020be61 T rand_initialize_irq
+c020be94 T tty_name
+c020beb4 t tty_ldisc_assign
+c020becd t hung_up_tty_read
+c020bed0 t hung_up_tty_write
+c020bed6 t hung_up_tty_poll
+c020bedc t hung_up_tty_ioctl
+c020bef0 t hung_up_tty_compat_ioctl
+c020bf04 T tty_hung_up_p
+c020bf12 t tty_default_put_char
+c020bf2c T tty_set_operations
+c020c004 T tty_devnum
+c020c016 t tty_set_termios_ldisc
+c020c039 T tty_paranoia_check
+c020c0a0 T put_tty_driver
+c020c0a5 t tty_buffer_free_all
+c020c0f4 t alloc_tty_struct
+c020c103 t release_one_tty
+c020c1d1 t release_tty
+c020c1fe t check_tty_count
+c020c292 T stop_tty
+c020c300 t tty_ldisc_enable
+c020c329 T proc_clear_tty
+c020c35d t session_clear_tty
+c020c380 t __proc_set_tty
+c020c402 T tty_ldisc_deref
+c020c466 t tty_ldisc_try
+c020c499 T tty_ldisc_ref
+c020c4ae T tty_wakeup
+c020c4fe T start_tty
+c020c578 T tty_ldisc_put
+c020c5bf T tty_ldisc_get
+c020c617 t initialize_tty_struct
+c020c7e6 T tty_unregister_ldisc
+c020c828 T tty_register_ldisc
+c020c885 T tty_schedule_flip
+c020c8c1 T get_current_tty
+c020c91f t tty_buffer_free
+c020c98d t flush_to_ldisc
+c020ca95 T tty_flip_buffer_push
+c020cae1 t tty_buffer_flush
+c020cb26 T tty_ldisc_flush
+c020cb4d t tty_line_name
+c020cb72 T tty_register_device
+c020cc38 t init_dev
+c020d0d2 T tty_buffer_request_room
+c020d1e4 T tty_prepare_flip_string_flags
+c020d21b T alloc_tty_driver
+c020d250 T tty_ldisc_ref_wait
+c020d2d6 t tty_poll
+c020d339 t tty_fasync
+c020d3ee t release_dev
+c020d9dd t tty_release
+c020d9f5 t do_tty_hangup
+c020dd24 T tty_vhangup
+c020dd2e t tty_write
+c020defa T tty_register_driver
+c020e0a6 T tty_unregister_device
+c020e0bd T tty_unregister_driver
+c020e19d T do_SAK
+c020e1ac T tty_hangup
+c020e1b6 T __do_SAK
+c020e373 t do_SAK_work
+c020e37d T disassociate_ctty
+c020e55e T no_tty
+c020e584 t send_break
+c020e5f2 T redirected_tty_write
+c020e66b T tty_check_change
+c020e702 t tty_read
+c020e7b1 T tty_insert_flip_string_flags
+c020e83b T tty_insert_flip_string
+c020e8cb T tty_prepare_flip_string
+c020e912 T tty_ioctl
+c020f4c5 t tty_open
+c020f772 t ptmx_open
+c020f938 t n_tty_set_room
+c020f967 t put_tty_queue_nolock
+c020f9a1 t check_unthrottle
+c020f9cd t opost
+c020fb79 t echo_char
+c020fbde t n_tty_set_termios
+c020fdaa t n_tty_write_wakeup
+c020fdd1 T is_ignored
+c020fe04 t n_tty_chars_in_buffer
+c020fe5f t reset_buffer_flags
+c020fed3 t put_tty_queue
+c020ff07 t n_tty_flush_buffer
+c020ff4a t copy_from_read_buf
+c020fff4 t n_tty_close
+c0210019 t n_tty_open
+c02100a1 t write_chan
+c0210330 t n_tty_receive_buf
+c021104a t normal_poll
+c0211164 t read_chan
+c02116a4 T tty_termios_baud_rate
+c02116e2 T tty_termios_input_baud_rate
+c0211730 T tty_termios_encode_baud_rate
+c0211850 T tty_get_baud_rate
+c0211893 t send_prio_char
+c021191d T tty_wait_until_sent
+c02119d2 t set_termios
+c0211cef T n_tty_ioctl
+c0212178 t pty_write
+c02121b1 t pty_write_room
+c02121ce t pty_chars_in_buffer
+c0212201 t pty_set_termios
+c0212216 t pty_unix98_ioctl
+c0212270 t pty_flush_buffer
+c02122bc t pty_close
+c02123da t pty_unthrottle
+c02123f7 t pty_open
+c0212454 t misc_seq_next
+c021246c t misc_seq_stop
+c0212476 t misc_seq_open
+c0212482 t misc_seq_show
+c02124b4 T misc_deregister
+c021251a t misc_seq_start
+c021255b T misc_register
+c0212649 t misc_open
+c02127b4 T reset_vc
+c021282a t complete_change_console
+c02128e6 T change_console
+c0212955 T vc_SAK
+c0212980 T vt_waitactive
+c0212a14 T vt_ioctl
+c0213eac T vcs_make_sysfs
+c0213f1a t vcs_open
+c0213f38 t vcs_size
+c0213f84 t vcs_lseek
+c0214006 T vcs_remove_sysfs
+c0214037 t vcs_read
+c0214375 t vcs_write
+c0214798 T set_translate
+c02147ab T inverse_translate
+c02147e4 T con_get_unimap
+c02148fb T con_protect_unimap
+c021490e T conv_uni_to_pc
+c021498f t con_release_unimap
+c0214a03 T con_free_unimap
+c0214a38 T con_copy_unimap
+c0214a7f T con_clear_unimap
+c0214b29 t con_insert_unipair
+c0214bba t set_inverse_transl
+c0214c37 t update_user_maps
+c0214c8b t con_unify_unimap
+c0214d98 T con_set_default_unimap
+c0214e98 T con_set_unimap
+c0215038 T con_get_trans_new
+c021507c T con_set_trans_old
+c02150cc T con_get_trans_old
+c0215130 T con_set_trans_new
+c0215178 T clear_selection
+c02151be t sel_pos
+c02151db T sel_loadlut
+c02151f8 T paste_selection
+c02152d6 T set_selection
+c02156e8 t fn_caps_toggle
+c02156fb t fn_caps_on
+c021570e t fn_bare_num
+c0215721 t fn_compose
+c021572c t k_ignore
+c021572d t k_spec
+c021575e t k_ascii
+c0215794 t k_lock
+c02157b7 T getledstate
+c02157bf t kbd_bh
+c02158d9 t kd_nosound
+c021594b t kbd_disconnect
+c0215962 T compute_shiftstate
+c0215a10 t fn_null
+c0215a15 t puts_queue
+c0215ab7 t applkey
+c0215ad8 t k_cur
+c0215b01 t put_queue
+c0215b93 t k_meta
+c0215bc8 t to_utf8
+c0215c16 t k_shift
+c0215cde t handle_diacr
+c0215d8b t k_deadunicode
+c0215dac t k_dead
+c0215dbf t k_dead2
+c0215dcb t k_unicode
+c0215e2a t k_brlcommit
+c0215e86 t k_self
+c0215e95 t fn_send_intr
+c0215f28 t k_brl
+c021605f t k_fn
+c021607e t k_lowercase
+c021608f t k_cons
+c021609c t fn_lastcons
+c02160a6 t fn_spawn_con
+c02160eb t fn_inc_console
+c0216126 t fn_dec_console
+c0216161 t fn_SAK
+c0216172 t fn_boot_it
+c0216177 t fn_scroll_back
+c021617e t fn_scroll_forw
+c0216185 t fn_hold
+c02161ac t fn_show_state
+c02161b3 t fn_show_mem
+c02161b8 t fn_show_ptregs
+c02161c8 T setledstate
+c0216202 t kbd_connect
+c0216282 T getkeycode
+c02162d0 T setkeycode
+c0216319 T kd_mksound
+c02163b1 T kbd_rate
+c0216433 t kbd_start
+c02164c7 t fn_enter
+c021652d t fn_num
+c0216555 t k_pad
+c0216665 t k_slock
+c02166af t kbd_event
+c0216ba0 t do_update_region
+c0216cb5 t build_attr
+c0216dc1 t update_attr
+c0216e81 t insert_char
+c0216f4a t add_softcursor
+c0216fef t clear_buffer_attributes
+c021702c T vc_cons_allocated
+c0217045 t gotoxy
+c02170ad t gotoxay
+c02170bb t csi_J
+c02171cd t default_attr
+c02171e6 T mouse_reporting
+c02171ff t save_cur
+c02172cb t vt_console_device
+c02172e3 t con_write_room
+c02172f5 t con_chars_in_buffer
+c02172f8 t con_throttle
+c02172f9 T con_is_bound
+c0217313 T screen_pos
+c021733a T getconsxy
+c0217346 T vcs_scr_readw
+c021735d T vcs_scr_writew
+c0217375 t vtconsole_init_device
+c02173d0 t show_name
+c0217413 t hide_cursor
+c0217470 t set_cursor
+c02174cc T putconsxy
+c02174eb t con_flush_chars
+c021751a t scrdown
+c02175c8 t scrup
+c0217694 t lf
+c02176d1 t blank_screen_t
+c0217704 T schedule_console_callback
+c021770e T set_console
+c021775a T scrollfront
+c021776e T scrollback
+c0217782 T register_con_driver
+c0217895 t visual_init
+c0217967 t reset_terminal
+c0217b02 t restore_cur
+c0217bc5 t set_palette
+c0217c1e T reset_palette
+c0217c5d t set_get_cmap
+c0217da9 T con_get_cmap
+c0217dc5 T con_set_cmap
+c0217de4 t set_origin
+c0217e6f t vc_init
+c0217efc T invert_screen
+c0218059 t set_mode
+c0218260 T update_region
+c02182dc T con_font_op
+c0218653 T do_blank_screen
+c021886b T unregister_con_driver
+c0218913 T give_up_console
+c0218918 t con_unthrottle
+c021893e t respond_string
+c02189d5 T mouse_report
+c0218a22 t con_close
+c0218a7d T vc_allocate
+c0218baf t con_open
+c0218c2b T redraw_screen
+c0218db1 T do_unblank_screen
+c0218ecb T unblank_screen
+c0218ed2 T poke_blanked_console
+c0218f8d t do_con_write
+c021a6f1 t con_put_char
+c021a71b t con_write
+c021a732 T take_over_console
+c021aa15 T vc_resize
+c021ad02 T vc_lock_resize
+c021ad28 t store_bind
+c021ad38 t show_bind
+c021ad6c T complement_pos
+c021ae88 T screen_glyph
+c021aeb4 T vc_deallocate
+c021af53 t con_start
+c021af8f t con_stop
+c021afe1 t vt_console_print
+c021b20f t console_callback
+c021b2d4 T tioclinux
+c021b460 T sysrq_on
+c021b47b t sysrq_handle_unraw
+c021b48e t sysrq_key_table_key2index
+c021b4b8 T __sysrq_get_key_op
+c021b4ce t sysrq_handle_loglevel
+c021b4f9 t __sysrq_swap_key_ops
+c021b54d T unregister_sysrq_key
+c021b553 T register_sysrq_key
+c021b557 T __handle_sysrq
+c021b660 t sysrq_handle_showstate_blocked
+c021b66a t sysrq_handle_showstate
+c021b671 t sysrq_handle_mountro
+c021b676 t sysrq_handle_sync
+c021b67b t sysrq_handle_show_timers
+c021b680 t sysrq_handle_showregs
+c021b690 t sysrq_handle_unrt
+c021b695 t sysrq_handle_showmem
+c021b69a t sysrq_handle_moom
+c021b6a4 t sysrq_handle_SAK
+c021b6b5 t send_sig_all
+c021b6ef t sysrq_handle_kill
+c021b704 t sysrq_handle_term
+c021b719 t moom_callback
+c021b72a t sysrq_handle_reboot
+c021b730 t sysrq_handle_crashdump
+c021b73b T handle_sysrq
+c021b758 t get_rtc_alm_time
+c021b7e1 t rtc_poll
+c021b821 t rtc_open
+c021b863 t rtc_fasync
+c021b874 t mask_rtc_irq_bit_locked
+c021b8b1 t mask_rtc_irq_bit
+c021b8d1 t rtc_release
+c021b975 t rtc_dropped_irq
+c021ba54 T rtc_get_rtc_time
+c021bbd1 t set_rtc_irq_bit_locked
+c021bc0c t rtc_do_ioctl
+c021c2af T rtc_control
+c021c314 t rtc_ioctl
+c021c321 t rtc_proc_open
+c021c32f t rtc_proc_show
+c021c4fe T rtc_unregister
+c021c5aa T rtc_register
+c021c623 T rtc_interrupt
+c021c707 t rtc_read
+c021c7f0 t hpet_acpi_remove
+c021c7f6 t hpet_fasync
+c021c814 t hpet_poll
+c021c854 t hpet_open
+c021c8e3 t hpet_mmap
+c021c971 t hpet_ioctl_common
+c021cdab T hpet_control
+c021ce34 t hpet_ioctl
+c021ce51 T hpet_alloc
+c021d1f7 t hpet_acpi_add
+c021d26f t hpet_read
+c021d353 t hpet_interrupt
+c021d426 T hpet_register
+c021d52f t hpet_release
+c021d5ee T hpet_unregister
+c021d6a2 t hpet_resources
+c021d790 t rng_dev_open
+c021d7a6 t hwrng_attr_current_show
+c021d800 t hwrng_attr_available_show
+c021d911 T hwrng_unregister
+c021d9ba t hwrng_attr_current_store
+c021da67 T hwrng_register
+c021db97 t rng_dev_read
+c021dcdc t intel_rng_data_present
+c021dce6 t intel_rng_data_read
+c021dcf7 t intel_rng_cleanup
+c021dd1f t intel_rng_init
+c021dd50 t hangcheck_fire
+c021de14 t __uart_start
+c021de44 T uart_update_timeout
+c021de98 T uart_get_divisor
+c021dec7 t uart_change_speed
+c021df1e t uart_write_room
+c021df34 t uart_chars_in_buffer
+c021df49 t uart_type
+c021df63 T uart_console_write
+c021df96 t uart_change_pm
+c021dfbe T uart_console_device
+c021dfcb T uart_match_port
+c021e015 T uart_remove_one_port
+c021e0ea t uart_send_xchar
+c021e12e t uart_put_char
+c021e18b t uart_start
+c021e1b5 t uart_flush_chars
+c021e1b7 t uart_stop
+c021e1de T uart_unregister_driver
+c021e205 t uart_tiocmget
+c021e268 t uart_read_proc
+c021e76a t uart_wait_until_sent
+c021e82d t uart_write
+c021e928 t uart_flush_buffer
+c021e99c t uart_tasklet_action
+c021e9a6 t uart_shutdown
+c021ea53 t uart_startup
+c021eb5f t uart_open
+c021eed9 T uart_register_driver
+c021eff6 T uart_resume_port
+c021f0f2 T uart_suspend_port
+c021f196 T uart_get_baud_rate
+c021f234 T uart_write_wakeup
+c021f256 T uart_add_one_port
+c021f4de t uart_break_ctl
+c021f520 t uart_ioctl
+c021fe14 t uart_close
+c021ffb0 t uart_hangup
+c0220050 t uart_throttle
+c02200ad t uart_unthrottle
+c0220116 t uart_tiocmset
+c0220198 t uart_set_termios
+c02202fc t serial_in
+c0220363 t serial_out
+c0220401 t serial_out_sync
+c0220444 t serial_icr_write
+c0220468 t serial_icr_read
+c02204b3 t __enable_rsa
+c02204f6 t autoconfig_read_divisor_id
+c02205a7 t serial8250_stop_tx
+c02205ee t serial8250_stop_rx
+c022060a t serial8250_enable_ms
+c0220636 t serial8250_set_mctrl
+c0220693 t serial8250_pm
+c0220745 t serial8250_verify_port
+c0220774 t serial8250_type
+c022078c t size_fifo
+c0220918 t serial8250_suspend
+c0220951 T serial8250_suspend_port
+c0220967 t serial8250_request_rsa_resource
+c02209c0 t serial8250_release_rsa_resource
+c0220a06 t serial8250_request_std_resource
+c0220ae8 t serial8250_break_ctl
+c0220b28 t serial8250_tx_empty
+c0220b57 t serial8250_release_std_resource
+c0220be2 t serial8250_config_port
+c022155c t serial8250_request_port
+c022158a t serial8250_release_port
+c02215a2 t serial8250_set_termios
+c022186a t serial_do_unlink
+c02218aa t serial8250_shutdown
+c0221a01 t receive_chars
+c0221c34 t check_modem_status
+c0221d2d t serial8250_get_mctrl
+c0221d61 t transmit_chars
+c0221e23 t serial8250_start_tx
+c0221ecd t serial8250_find_match_or_unused
+c0221f52 T serial8250_unregister_port
+c0221fb8 T serial8250_unregister_by_port
+c0221fcd t serial8250_remove
+c0221ffe T serial8250_register_port
+c02220b2 t serial8250_probe
+c02221cf T serial8250_resume_port
+c0222231 t serial8250_resume
+c0222267 t serial8250_console_write
+c0222385 t serial8250_backup_timeout
+c022246e t serial8250_startup
+c0222974 t serial8250_console_putchar
+c02229ea t serial8250_interrupt
+c0222b04 t serial8250_timeout
+c0222b88 t check_resources
+c0222bcb t serial_pnp_resume
+c0222be5 t check_name
+c0222c10 t serial_pnp_probe
+c0222d2d t serial_pnp_remove
+c0222d3e t serial_pnp_suspend
+c0222d58 t pci_hp_diva_init
+c0222db0 t pci_timedia_init
+c0222de1 t pci_netmos_init
+c0222df1 t find_quirk
+c0222e43 t serial_pci_guess_board
+c0222f9a t moan_device
+c0222fdb T pciserial_resume_ports
+c0223007 t pciserial_resume_one
+c0223036 T pciserial_suspend_ports
+c0223054 T pciserial_remove_ports
+c02230a6 t pci_xircom_init
+c02230b3 t setup_port
+c0223196 t pci_default_setup
+c0223285 t titan_400l_800l_setup
+c02232cf t pci_timedia_setup
+c0223322 t pci_siig_setup
+c0223363 t sbs_setup
+c02233b6 t pci_hp_diva_setup
+c022342e t afavlab_setup
+c0223474 t sbs_exit
+c02234d4 t pci_siig_init
+c02235fb t pci_inteli960ni_init
+c0223642 T pciserial_init_ports
+c0223772 t pciserial_remove_one
+c0223792 t pciserial_suspend_one
+c02237c5 t pciserial_init_one
+c02238d0 t pci_plx9050_init
+c022394b t pci_plx9050_exit
+c0223986 t sbs_init
+c0223a0c T dev_driver_string
+c0223a35 t dev_attr_show
+c0223a50 t dev_attr_store
+c0223a7c t dev_uevent_filter
+c0223ac0 t dev_uevent_name
+c0223ae2 t device_release
+c0223b60 T get_device
+c0223b79 t klist_children_get
+c0223b81 t get_device_parent
+c0223c89 t device_move_class_links
+c0223cc4 t next_device
+c0223cd5 T device_find_child
+c0223d20 T device_for_each_child
+c0223d5c T put_device
+c0223d6b T device_move
+c0223e4e t klist_children_put
+c0223e56 t store_uevent
+c0223eab t show_dev
+c0223edb t show_uevent
+c0223fb3 t device_remove_groups
+c0223fd6 t device_add_groups
+c022402a T device_initialize
+c02240bd T device_schedule_callback_owner
+c02240d6 T device_remove_bin_file
+c02240e5 T device_create_bin_file
+c02240f9 T device_remove_file
+c0224121 t device_remove_attributes
+c0224142 t device_remove_attrs
+c0224181 T device_del
+c02243c3 T device_unregister
+c02243d3 T device_destroy
+c022445a T device_create_file
+c0224488 T device_add
+c0224903 T device_register
+c0224913 t dev_uevent
+c0224af6 t device_create_release
+c0224afb T device_rename
+c0224bcc T device_create
+c0224c68 t sysdev_show
+c0224c84 t sysdev_store
+c0224ca6 t sysdev_class_show
+c0224cc2 t sysdev_class_store
+c0224ce4 t __sysdev_resume
+c0224d37 T sysdev_class_remove_file
+c0224d3f T sysdev_remove_file
+c0224d47 T sysdev_class_create_file
+c0224d4f T sysdev_create_file
+c0224d57 T sysdev_class_register
+c0224d72 T sysdev_class_unregister
+c0224d7a T sysdev_shutdown
+c0224e3a T sysdev_suspend
+c0225009 T sysdev_resume
+c0225050 T sysdev_driver_unregister
+c02250d4 T sysdev_register
+c02251b0 T sysdev_unregister
+c0225237 T sysdev_driver_register
+c02252d8 t drv_attr_show
+c02252f4 t drv_attr_store
+c0225316 t driver_release
+c0225317 t bus_attr_show
+c0225330 t bus_attr_store
+c022534f t driver_helper
+c0225374 t store_drivers_autoprobe
+c0225390 T bus_unregister_notifier
+c022539a T bus_register_notifier
+c02253a4 t show_drivers_autoprobe
+c02253ca t bus_rescan_devices_helper
+c0225437 t klist_devices_put
+c022543f t klist_devices_get
+c0225447 T put_bus
+c022544f T get_bus
+c022546c T device_reprobe
+c02254d6 t device_remove_attrs
+c0225505 T bus_attach_device
+c0225578 T bus_for_each_drv
+c02255d0 t next_device
+c02255e1 T bus_find_device
+c022563c t store_drivers_probe
+c0225671 T bus_for_each_dev
+c02256c6 T bus_rescan_devices
+c02256db T bus_remove_file
+c0225700 t remove_probe_files
+c022571c T bus_unregister
+c0225768 T bus_create_file
+c0225796 T bus_add_device
+c022587a T bus_remove_device
+c02258e6 T bus_add_driver
+c0225a56 T bus_remove_driver
+c0225acb T bus_register
+c0225cc7 t driver_unbind
+c0225d72 t driver_bind
+c0225e68 T driver_probe_done
+c0225e77 t driver_sysfs_remove
+c0225ea7 t __device_release_driver
+c0225f35 T driver_attach
+c0225f4d t driver_sysfs_add
+c0225fa9 t driver_bound
+c0226012 T driver_probe_device
+c0226171 t __device_attach
+c0226176 T device_bind_driver
+c0226191 T device_attach
+c0226212 t __driver_attach
+c02262b3 T device_release_driver
+c02262f6 T driver_detach
+c02263c8 T driver_find
+c02263e0 T driver_unregister
+c02263e5 T driver_register
+c022644c T put_driver
+c0226454 T get_driver
+c0226468 T driver_remove_file
+c022648d T driver_create_file
+c02264bb t next_device
+c02264cc T driver_find_device
+c0226525 T driver_for_each_device
+c0226578 t class_attr_show
+c0226594 t class_attr_store
+c02265b6 T class_device_put
+c02265c3 t class_put
+c02265d0 T class_device_get
+c02265e4 t class_get
+c0226601 t store_uevent
+c0226615 t show_dev
+c0226642 t class_device_remove_groups
+c0226668 T class_device_initialize
+c0226681 T class_device_remove_bin_file
+c022668e T class_device_create_bin_file
+c02266a0 T class_device_remove_file
+c02266ad t class_device_remove_attrs
+c02266dd T class_device_del
+c02267d9 T class_device_unregister
+c02267e9 T class_remove_file
+c02267f6 T class_device_create_file
+c0226808 T class_device_add
+c0226af2 T class_device_register
+c0226b02 T class_device_create
+c0226b9b T class_create_file
+c0226bad T class_unregister
+c0226bdf T class_register
+c0226d02 t class_release
+c0226d12 t class_create_release
+c0226d17 t class_device_create_release
+c0226d1c t class_device_create_uevent
+c0226d1f t class_uevent
+c0226f0e T class_interface_unregister
+c0226fcb t class_device_attr_store
+c0226fea t class_dev_release
+c022704e t class_uevent_filter
+c0227072 t class_uevent_name
+c0227078 t class_device_attr_show
+c0227091 T class_destroy
+c02270a2 T class_device_destroy
+c022710b T class_interface_register
+c02271e3 T class_create
+c022723c T platform_get_resource
+c0227293 T platform_get_irq
+c02272ad T platform_get_resource_byname
+c0227310 T platform_get_irq_byname
+c022732a t platform_drv_probe
+c0227337 t platform_drv_probe_fail
+c022733d t platform_drv_remove
+c022734a t platform_drv_shutdown
+c0227357 t platform_drv_suspend
+c0227364 t platform_drv_resume
+c0227371 t platform_match
+c022739b t platform_suspend
+c02273b5 t platform_suspend_late
+c02273cf t platform_resume_early
+c02273e9 t platform_resume
+c0227403 t platform_uevent
+c0227431 t modalias_show
+c0227467 T platform_driver_unregister
+c022746f T platform_driver_register
+c02274cd T platform_driver_probe
+c0227537 T platform_device_del
+c0227574 T platform_device_add
+c0227690 T platform_device_register
+c02276a3 T platform_device_add_resources
+c02276fd T platform_device_add_data
+c0227747 T platform_device_alloc
+c02277aa t platform_device_release
+c02277ce T platform_device_put
+c02277db T platform_device_register_simple
+c0227825 T platform_device_unregister
+c0227835 T platform_add_devices
+c0227873 T dma_get_required_mask
+c02278d4 T get_cpu_sysdev
+c02278e5 T register_cpu
+c022791f t show_crash_notes
+c0227954 T firmware_register
+c0227960 T firmware_unregister
+c0227968 T kobj_map_init
+c02279d7 T kobj_unmap
+c0227a7e T kobj_lookup
+c0227b8c T kobj_map
+c0227c7c t group_open_release
+c0227c7d t group_close_release
+c0227c7e t node_to_group
+c0227c99 t find_dr
+c0227cea t find_group
+c0227d2c t devm_kzalloc_release
+c0227d2d t devm_kzalloc_match
+c0227d35 T devres_remove
+c0227d9e T devres_find
+c0227deb T devres_free
+c0227e03 T devres_destroy
+c0227e28 T devm_kfree
+c0227e71 t release_nodes
+c0227f98 T devres_release_group
+c022801c T devres_release_all
+c0228046 t add_dr
+c0228060 T devres_close_group
+c02280cc T devres_get
+c022812d T devres_add
+c022815d T devm_kzalloc
+c02281ae T devres_open_group
+c0228223 T devres_remove_group
+c02282b1 T devres_alloc
+c02282f4 T attribute_container_classdev_to_container
+c02282f8 T attribute_container_find_class_device
+c022833b T attribute_container_remove_attrs
+c0228360 T attribute_container_class_device_del
+c0228370 T attribute_container_add_attrs
+c022839b T attribute_container_add_class_device
+c02283b1 T attribute_container_add_class_device_adapter
+c02283b8 T attribute_container_trigger
+c02283ff t attribute_container_release
+c0228413 T attribute_container_unregister
+c0228459 t internal_container_klist_put
+c0228461 t internal_container_klist_get
+c0228469 T attribute_container_device_trigger
+c02284f2 T attribute_container_register
+c0228536 T attribute_container_add_device
+c0228640 T attribute_container_remove_device
+c02286e8 t anon_transport_dummy_function
+c02286eb t transport_setup_classdev
+c0228705 t transport_configure
+c022871f T transport_destroy_device
+c0228729 t transport_destroy_classdev
+c0228740 T transport_remove_device
+c022874a T transport_configure_device
+c0228754 T transport_add_device
+c022875e t transport_remove_classdev
+c022879e t transport_add_class_device
+c02287c3 T transport_setup_device
+c02287cd T anon_transport_class_unregister
+c02287d7 T anon_transport_class_register
+c0228809 T transport_class_unregister
+c022880e T transport_class_register
+c0228814 T device_shutdown
+c022886c T device_pm_remove
+c02288d7 T device_pm_set_parent
+c02288f8 T device_pm_add
+c0228974 T __suspend_report_result
+c02289b2 T device_power_down
+c0228a68 T suspend_device
+c0228be4 T device_suspend
+c0228d50 T dpm_power_up
+c0228d9f T device_power_up
+c0228da9 T resume_device
+c0228e9d T dpm_resume
+c0228f64 T device_resume
+c0228fb0 t runtime_resume
+c0228fd1 T dpm_runtime_suspend
+c022903f T dpm_runtime_resume
+c0229084 T dpm_sysfs_remove
+c0229093 t wake_show
+c02290d8 T dpm_sysfs_add
+c02290e7 t wake_store
+c0229180 T dmam_release_declared_memory
+c02291ca t dmam_match
+c022921d t dmam_coherent_decl_release
+c0229222 T dmam_declare_coherent_memory
+c022928b T dmam_free_noncoherent
+c02292f5 T dmam_free_coherent
+c022935f t dmam_noncoherent_release
+c0229376 t dmam_coherent_release
+c022938d T dmam_alloc_noncoherent
+c02293ff T dmam_alloc_coherent
+c0229474 t dmam_pool_match
+c022947c T dma_pool_free
+c02295b4 T dma_pool_destroy
+c02296ac T dmam_pool_destroy
+c0229707 t dmam_pool_release
+c022970e T dma_pool_create
+c0229827 T dmam_pool_create
+c0229892 t show_pools
+c022995b T dma_pool_alloc
+c0229ad4 t firmware_timeout_store
+c0229af6 t firmware_timeout_show
+c0229b16 t fw_dev_release
+c0229b33 T release_firmware
+c0229b4c t fw_load_abort
+c0229b5a t firmware_class_timeout
+c0229b5c t _request_firmware
+c0229dfd t request_firmware_work_func
+c0229e82 T request_firmware
+c0229e93 t firmware_uevent
+c0229f45 t firmware_loading_show
+c0229f6e t firmware_loading_store
+c022a020 t firmware_data_read
+c022a0ba t firmware_data_write
+c022a1f8 T request_firmware_nowait
+c022a2e4 t show_core_id
+c022a30b t show_physical_package_id
+c022a332 t show_core_siblings
+c022a373 t show_thread_siblings
+c022a3b4 t ramdisk_writepages
+c022a3b7 t ramdisk_set_page_dirty
+c022a3c6 t rd_ioctl
+c022a411 t rd_open
+c022a4c4 t ramdisk_commit_write
+c022a4ce t make_page_uptodate
+c022a543 t ramdisk_writepage
+c022a572 t ramdisk_readpage
+c022a58d t ramdisk_prepare_write
+c022a59d t rd_make_request
+c022a7f0 t always_on
+c022a7f6 t loopback_net_exit
+c022a800 t loopback_net_init
+c022a8ac t loopback_xmit
+c022a90d t get_stats
+c022a95c t etun_get_stats
+c022a966 t etun_get_settings
+c022a99f t etun_get_strings
+c022a9b5 t etun_get_stats_count
+c022a9bb t etun_get_ethtool_stats
+c022a9cd t etun_get_rx_csum
+c022a9de t etun_set_rx_csum
+c022a9f1 t etun_get_tx_csum
+c022a9fb t etun_set_tx_csum
+c022aa11 t etun_change_mtu
+c022aa26 t etun_set_multicast_list
+c022aa27 t etun_ioctl
+c022aa2d t is_valid_name
+c022aa4d t etun_noget
+c022aa50 t etun_unregister_pair
+c022ab03 t etun_cleanup
+c022ab33 t etun_delif
+c022abc8 t etun_stop
+c022abf2 t etun_alloc
+c022acfc t etun_open
+c022ad33 t etun_xmit
+c022ae28 t etun_get_drvinfo
+c022ae57 t etun_newif
+c022afbc t pci_bus_clock_list
+c022afd5 t pci_bus_clock_list_ultra
+c022afee t aec62xx_init_one
+c022affe t init_setup_aec62xx
+c022b003 t aec62xx_irq_timeout
+c022b02c t aec62xx_tune_chipset
+c022b286 t aec62xx_tune_drive
+c022b2b0 t aec62xx_config_drive_xfer_rate
+c022b2df t init_setup_aec6x80
+c022b33a t init_hwif_aec62xx
+c022b43d t init_chipset_aec62xx
+c022b56a t init_dma_aec62xx
+c022b648 t alim15x3_init_one
+c022b676 t init_dma_ali15x3
+c022b6a9 t ali15x3_dma_setup
+c022b6d6 t ali_udma_filter
+c022b717 t ali15x3_tune_pio
+c022b8e0 t ali15x3_tune_drive
+c022b8fa t ali15x3_config_drive_for_dma
+c022b91c t init_hwif_ali15x3
+c022bbfd t ali15x3_tune_chipset
+c022bd61 t init_chipset_ali15x3
+c022be9c t ide_find_best_mode
+c022c001 t ide_timing_merge
+c022c0e6 t ide_timing_compute
+c022c344 t init_hwif_amd74xx
+c022c458 t amd74xx_probe
+c022c4c6 t amd_set_drive
+c022c815 t amd74xx_ide_dma_check
+c022c896 t amd74xx_tune_drive
+c022c8c4 t init_chipset_amd74xx
+c022cb18 t atiixp_init_one
+c022cb27 t init_hwif_atiixp
+c022cc43 t atiixp_dma_host_off
+c022ccbf t atiixp_tuneproc
+c022cdd2 t atiixp_speedproc
+c022cfa2 t atiixp_dma_check
+c022d035 t atiixp_dma_host_on
+c022d0c8 t quantize_timing
+c022d0d5 t cmd64x_init_one
+c022d100 t init_setup_cmd64x
+c022d105 t init_setup_cmd646
+c022d143 t init_hwif_cmd64x
+c022d2f9 t program_cycle_times
+c022d3a5 t cmd64x_tune_pio
+c022d4ab t cmd64x_tune_drive
+c022d4cf t cmd64x_config_drive_for_dma
+c022d4fe t cmd648_ide_dma_end
+c022d536 t cmd648_ide_dma_test_irq
+c022d572 t cmd646_1_ide_dma_end
+c022d5c8 t cmd64x_ide_dma_test_irq
+c022d631 t cmd64x_tune_chipset
+c022d7ca t cmd64x_ide_dma_end
+c022d837 t init_chipset_cmd64x
+c022d9e0 t cs5520_dma_on
+c022d9e7 t init_hwif_cs5520
+c022da7f t cs5520_tune_chipset
+c022dbc0 t cs5520_tune_drive
+c022dbea t cs5520_config_drive_xfer_rate
+c022dbf7 t cs5520_init_setup_dma
+c022dc21 t cs5520_init_one
+c022dd0c t cs5530_tunepio
+c022dd59 t cs5530_init_one
+c022dd63 t cs5530_config_dma
+c022dd71 t cs5530_udma_filter
+c022dddb t cs5530_set_xfer_mode
+c022de0e t cs5530_tuneproc
+c022de51 t cs5530_tune_chipset
+c022df39 t init_hwif_cs5530
+c022e044 t init_chipset_cs5530
+c022e184 t cs5535_init_one
+c022e18e t init_hwif_cs5535
+c022e255 t cs5535_set_speed
+c022e3d9 t cs5535_tuneproc
+c022e42c t cs5535_set_drive
+c022e454 t cs5535_dma_check
+c022e4a4 t calc_clk
+c022e4cd t cy82c693_dma_enable
+c022e518 t init_hwif_cy82c693
+c022e5ae t init_iops_cy82c693
+c022e5d6 t cy82c693_init_one
+c022e610 t cy82c693_ide_dma_on
+c022e658 t init_chipset_cy82c693
+c022e674 t cy82c693_tune_drive
+c022e82c t hpt34x_tune_chipset
+c022e934 t hpt34x_tune_drive
+c022e95e t hpt34x_config_drive_xfer_rate
+c022e98a t hpt34x_init_one
+c022e9e2 t init_chipset_hpt34x
+c022eb60 t init_hwif_hpt34x
+c022ec30 t check_in_drive_list
+c022ec60 t get_speed_setting
+c022ec81 t hpt3xx_intrproc
+c022ec9c t hpt3xxn_rw_disk
+c022ed94 t hpt366_init_one
+c022edbf t hpt370_clear_engine
+c022edf0 t hpt370_irq_timeout
+c022ee6c t hpt370_ide_dma_timeout
+c022ee7c t hpt370_ide_dma_end
+c022eebd t hpt370_ide_dma_start
+c022eecd t hpt3xx_quirkproc
+c022eefa t hpt3xx_tune_chipset
+c022f0c5 t hpt3xx_tune_drive
+c022f0ef t hpt366_config_drive_xfer_rate
+c022f122 t hpt3xx_udma_filter
+c022f1c7 t init_setup_hpt374
+c022f25c t init_setup_hpt372n
+c022f26b t init_dma_hpt366
+c022f329 t init_setup_hpt372a
+c022f379 t init_setup_hpt302
+c022f3c9 t init_setup_hpt366
+c022f550 t hpt3xx_maskproc
+c022f608 t hpt366_ide_dma_lostirq
+c022f6cf t hpt374_ide_dma_end
+c022f75c t init_setup_hpt371
+c022f7ed t hpt374_ide_dma_test_irq
+c022f862 t init_chipset_hpt366
+c022fe0f t hpt3xx_busproc
+c022ff81 t init_hwif_hpt366
+c0230290 t it821x_init_one
+c02302a2 t it821x_fixups
+c0230460 t it821x_program_udma
+c02304e4 t it821x_program
+c0230527 t it821x_clock_strategy
+c0230662 t it821x_tunepio
+c0230718 t it821x_tuneproc
+c0230740 t it821x_config_drive_for_dma
+c023075e t init_chipset_it821x
+c023085b t it821x_dma_start
+c023089f t it821x_dma_end
+c02308df t it821x_tune_chipset
+c0230adb t init_hwif_it821x
+c0230c54 t jmicron_tuneproc
+c0230c55 t jmicron_init_one
+c0230c67 t init_hwif_jmicron
+c0230dce t jmicron_config_drive_for_dma
+c0230e08 t jmicron_tune_chipset
+c0230e20 t pdc_old_disable_66MHz_clock
+c0230e48 t pdc202xx_init_one
+c0230e58 t init_setup_pdc202xx
+c0230e5d t init_setup_pdc20265
+c0230e9f t init_hwif_pdc202xx
+c0231020 t pdc202xx_ide_dma_timeout
+c023103c t pdc202xx_ide_dma_lostirq
+c0231058 t pdc202xx_tune_chipset
+c02312fd t pdc202xx_reset_host
+c023137c t pdc202xx_quirkproc
+c02313ab t pdc202xx_tune_drive
+c02313d5 t pdc202xx_reset
+c02313f6 t pdc202xx_config_drive_xfer_rate
+c0231429 t init_chipset_pdc202xx
+c0231482 t pdc202xx_old_ide_dma_end
+c02314e4 t pdc202xx_old_ide_dma_test_irq
+c0231505 t init_dma_pdc202xx
+c0231591 t pdc202xx_old_ide_dma_start
+c023163f t init_setup_pdc202ata4
+c02316d0 t read_counter
+c023177d t init_hwif_pdc202new
+c023185b t pdc202new_init_one
+c023186b t pdcnew_reset
+c0231898 t init_setup_pdc20276
+c02318da t init_setup_pdcnew
+c02318df t init_setup_pdc20270
+c023196f t pdcnew_tune_chipset
+c0231b75 t pdcnew_quirkproc
+c0231ba4 t pdcnew_tune_drive
+c0231bce t pdcnew_config_drive_xfer_rate
+c0231c01 t init_chipset_pdcnew
+c0231e70 t piix_dma_clear_irq
+c0231e91 t piix_init_one
+c0231ea0 t init_hwif_piix
+c0232094 t piix_tune_pio
+c023222b t piix_tune_drive
+c0232264 t piix_config_drive_xfer_rate
+c0232297 t piix_tune_chipset
+c02325cc t init_chipset_piix
+c0232680 t rz1000_init_one
+c023268a t init_hwif_rz1000
+c023271c t init_hwif_svwks
+c02328c3 t svwks_init_one
+c02328d3 t init_setup_csb6
+c023291a t init_setup_svwks
+c023291f t svwks_tune_chipset
+c0232d58 t svwks_tune_drive
+c0232d82 t svwks_config_drive_xfer_rate
+c0232db5 t svwks_udma_filter
+c0232eeb t init_chipset_svwks
+c0233154 t siimage_selreg
+c0233188 t siimage_init_one
+c0233197 t proc_reports_siimage
+c0233204 t siimage_tuneproc
+c02333b8 t config_siimage_chipset_for_pio
+c0233490 t siimage_config_drive_for_dma
+c02334bf t init_iops_siimage
+c023367b t siimage_mmio_ide_dma_test_irq
+c023372b t siimage_reset_poll
+c0233776 t siimage_pre_reset
+c02337a6 t siimage_fixup
+c023387a t init_hwif_siimage
+c0233a2f t sil_udma_filter
+c0233ad9 t siimage_io_ide_dma_test_irq
+c0233b2c t siimage_busproc
+c0233bca t siimage_tune_chipset
+c0233f58 t siimage_reset
+c023407c t init_chipset_siimage
+c02344c8 t sis5513_init_one
+c02344d2 t init_hwif_sis5513
+c023467b t sis5513_tune_drive
+c02348f4 t sis5513_tuneproc
+c02348fc t sis5513_config_xfer_rate
+c023493b t sis5513_tune_chipset
+c0234b84 t init_chipset_sis5513
+c0234f9c t slc90e66_init_one
+c0234fa6 t init_hwif_slc90e66
+c02350b9 t slc90e66_tune_pio
+c0235250 t slc90e66_tune_drive
+c0235289 t slc90e66_config_drive_xfer_rate
+c02352bc t slc90e66_tune_chipset
+c0235538 t init_hwif_triflex
+c0235595 t triflex_init_one
+c023559f t triflex_tune_chipset
+c023568d t triflex_tune_drive
+c02356b7 t triflex_config_drive_xfer_rate
+c02356d8 t ide_find_best_mode
+c023583d t ide_timing_merge
+c0235922 t ide_timing_compute
+c0235b80 t init_hwif_via82cxxx
+c0235c9f t via_set_drive
+c0235fa8 t via82cxxx_tune_drive
+c0235fd6 t via_config_find
+c0236042 t via_init_one
+c0236099 t via82cxxx_ide_dma_check
+c023611e t init_chipset_via82cxxx
+c0236414 t init_hwif_generic
+c0236491 t generic_init_one
+c0236568 T set_io_32bit
+c0236580 t ide_bus_match
+c0236586 t generic_ide_probe
+c02365a6 t generic_ide_remove
+c02365c3 t generic_ide_shutdown
+c02365df t modalias_show
+c0236635 t drivename_show
+c0236655 t ide_system_bus_speed
+c02366c0 T system_bus_clock
+c02366cc t init_hwif_data
+c02367c4 t init_hwif_default
+c02368b3 T set_pio_mode
+c023690c T ide_spin_wait_hwgroup
+c023696f t set_unmaskirq
+c02369a9 T set_using_dma
+c0236a64 t set_ksettings
+c0236a96 T ide_hwif_release_regions
+c0236b28 T ide_unregister
+c0237098 T ide_register_hw_with_fixup
+c02371fe T ide_register_hw
+c023720f t hwif_request_region
+c0237265 T ide_hwif_request_regions
+c0237339 T ide_setup_ports
+c0237397 t generic_ide_suspend
+c0237432 t generic_ide_resume
+c02374e0 T generic_ide_ioctl
+c0237a19 t media_show
+c0237a6f t ide_uevent
+c0237bcc t ide_complete_power_step
+c0237c1b T ide_init_sg_cmd
+c0237c42 T ide_stall_queue
+c0237c62 T ide_init_drive_cmd
+c0237c87 t ide_cmd
+c0237ce9 t ide_complete_pm_request
+c0237d47 T ide_end_drive_cmd
+c0238015 T ide_map_sg
+c0238086 T ide_get_error_location
+c0238157 T ide_end_request
+c023821d t ide_kill_rq
+c0238246 t ide_do_request
+c0238b2e T ide_do_drive_cmd
+c0238c4b T ide_intr
+c0238e0c T do_ide_request
+c0238e20 T __ide_abort
+c0238e32 T ide_abort
+c0238e82 T __ide_error
+c023901d T ide_error
+c023908e T ide_timer_expiry
+c02392fb T ide_end_dequeued_request
+c02393b3 t drive_cmd_intr
+c0239460 t ide_inb
+c0239467 t ide_inw
+c023946f t ide_insw
+c0239479 t ide_insl
+c0239482 t ide_outbsync
+c0239488 t ide_outw
+c023948e t ide_outsw
+c0239498 t ide_outsl
+c02394a1 T default_hwif_iops
+c02394fc t ide_mm_inb
+c0239502 t ide_mm_inw
+c0239509 t ide_mm_insw
+c023951f t ide_mm_insl
+c0239533 t ide_mm_outbsync
+c0239539 t ide_mm_outw
+c0239540 t ide_mm_outsw
+c0239556 t ide_mm_outsl
+c023956a T default_hwif_mmiops
+c02395c5 T ide_read_24
+c0239613 T SELECT_DRIVE
+c0239639 T SELECT_INTERRUPT
+c023965b T SELECT_MASK
+c0239671 T QUIRK_LIST
+c023968a t ata_vlb_sync
+c02396b4 t ata_input_data
+c0239718 t atapi_input_bytes
+c0239757 t atapi_output_bytes
+c0239796 T default_hwif_transport
+c02397bf T ide_fix_driveid
+c02397c0 T drive_is_ready
+c02397eb T set_transfer
+c023981f T ide_wait_not_busy
+c0239865 t check_dma_crc
+c0239903 t pre_reset
+c0239996 T eighty_ninty_three
+c0239a08 T ide_ata66_check
+c0239a46 T wait_for_ready
+c0239ac0 t __ide_set_handler
+c0239b33 t do_reset1
+c0239cca T ide_do_reset
+c0239cd1 T ide_set_handler
+c0239d12 t reset_pollfunc
+c0239e91 t atapi_reset_pollfunc
+c0239f47 T ide_execute_command
+c0239fec T ide_fixstring
+c023a068 T ide_config_drive_speed
+c023a3a2 t ata_output_data
+c023a406 T ide_wait_stat
+c023a4f5 t ide_mm_outb
+c023a4fb t ide_outb
+c023a4fd T ide_driveid_update
+c023a634 T ide_xfer_verbose
+c023a73b T ide_use_fast_pio
+c023a762 T ide_get_best_pio_mode
+c023a8a9 T ide_set_xfer_rate
+c023a8c5 t ide_dump_opcode
+c023a95f T ide_dump_status
+c023ae5e T ide_toggle_bounce
+c023aea3 T ide_rate_filter
+c023af10 t ata_lock
+c023af13 t exact_match
+c023af1a t save_match
+c023af7d T ide_undecoded_slave
+c023b001 t try_to_identify
+c023b44d t do_probe
+c023b64e t probe_hwif
+c023bd09 t hwif_release_dev
+c023bd13 t init_irq
+c023c141 t hwif_init
+c023c42c T ideprobe_init
+c023c54b T probe_hwif_init_with_fixup
+c023c5c9 T probe_hwif_init
+c023c5d0 T ide_register_region
+c023c600 t ata_probe
+c023c680 t drive_release_dev
+c023c729 T ide_init_disk
+c023c77f T ide_unregister_region
+c023c791 t exact_lock
+c023c7a0 t ata_bswap_data
+c023c7d6 T flagged_taskfile
+c023c9db T do_rw_taskfile
+c023cb7f T ide_task_ioctl
+c023cbea t ide_diag_taskfile
+c023cc91 T ide_raw_taskfile
+c023cca0 T ide_wait_cmd
+c023cd40 T ide_cmd_ioctl
+c023cf16 t task_error
+c023cf94 T recal_intr
+c023cfc3 T task_no_data_intr
+c023d026 t task_end_request
+c023d081 t ide_pio_sector
+c023d1a3 t ide_pio_datablock
+c023d1ff t task_out_intr
+c023d29b T task_in_intr
+c023d36b T pre_task_out_intr
+c023d410 T set_geometry_intr
+c023d49b T set_multmode_intr
+c023d4dd T taskfile_lib_get_identify
+c023d543 T ide_taskfile_ioctl
+c023d864 t get_cmd640_reg_vlb
+c023d880 t display_clocks
+c023d8dd t program_drive_counts
+c023d9d1 t set_prefetch_mode
+c023da64 t put_cmd640_reg
+c023da9a t get_cmd640_reg
+c023dac7 t cmd640_tune_drive
+c023dce4 t put_cmd640_reg_pci2
+c023dd0e t put_cmd640_reg_vlb
+c023dd2c t get_cmd640_reg_pci1
+c023dd5a t get_cmd640_reg_pci2
+c023dd86 t put_cmd640_reg_pci1
+c023ddb4 t ide_pci_check_iomem
+c023de1c T ide_setup_pci_noise
+c023de3e T __ide_pci_register_driver
+c023de65 T ide_pci_setup_ports
+c023e3eb t do_ide_setup_pci_device
+c023e7bc T ide_setup_pci_devices
+c023e846 T ide_setup_pci_device
+c023e8cc T ide_dma_host_off
+c023e909 T ide_dma_host_on
+c023e94e T ide_dma_start
+c023e97b T ide_set_dma
+c023e9b9 T __ide_dma_timeout
+c023e9f3 T __ide_dma_lostirq
+c023ea0e t __ide_dma_test_irq
+c023ea55 T ide_dma_off
+c023ea7a t dma_timer_expiry
+c023eae0 T ide_destroy_dmatable
+c023eaf1 T __ide_dma_end
+c023eb6a t ide_dma_exec_cmd
+c023eb8c T ide_release_dma
+c023ec26 T ide_setup_dma
+c023efab T ide_dma_verbose
+c023f0d0 T ide_max_dma_mode
+c023f1c5 T ide_dma_off_quietly
+c023f1e0 T ide_build_sglist
+c023f2aa T ide_build_dmatable
+c023f3e9 T ide_dma_setup
+c023f476 T ide_dma_intr
+c023f50f T ide_in_drive_list
+c023f572 T __ide_dma_good_drive
+c023f57f T __ide_dma_check
+c023f5dd T __ide_dma_bad_drive
+c023f61a T ide_tune_dma
+c023f65e T __ide_dma_on
+c023f68c t sectors_to_MB
+c023f6c8 t idedisk_prepare_flush
+c023f731 t set_lba_addressing
+c023f783 t idedisk_getgeo
+c023f7a1 t idedisk_media_changed
+c023f7bf t ide_cacheflush_p
+c023f848 t ide_device_shutdown
+c023f88a t idedisk_check_hpa
+c023fd1d t init_idedisk_capacity
+c023fe70 t ide_disk_resume
+c023fe8b t ide_disk_put
+c023feb2 t idedisk_release
+c023ff2e t ide_disk_remove
+c023ff4d t ide_disk_release
+c023ff74 t write_cache
+c02400ac t idedisk_issue_flush
+c024012d t set_nowerr
+c024016b t set_multcount
+c02401d6 t ide_disk_probe
+c0240564 t ide_do_rw_disk
+c02409f3 t set_acoustic
+c0240a5c t idedisk_open
+c0240b09 t idedisk_ioctl
+c0240c9d t idedisk_revalidate_disk
+c0240cc8 t msf_from_bcd
+c0240d05 t cdrom_get_toc_entry
+c0240d60 t ide_cdrom_open_real
+c0240d63 t ide_cdrom_release_real
+c0240d77 t ide_cdrom_prep_fn
+c0240e9b t ide_cd_put
+c0240ec2 t cdrom_timer_expiry
+c0240f13 t ide_cd_release
+c0240f9d t idecd_media_changed
+c0240faa t ide_cdrom_get_capabilities
+c024103d t idecd_ioctl
+c0241196 t idecd_release
+c02411bc t ide_cdrom_update_speed
+c024126e t idecd_open
+c02412fa t cdrom_prepare_request
+c0241318 t cdrom_queue_request_sense
+c0241373 t cdrom_queue_packet_command
+c024142c t ide_cdrom_select_speed
+c02414e0 t ide_cdrom_get_mcn
+c0241575 t cdrom_read_tocentry
+c0241613 t cdrom_lockdoor
+c02416e0 t ide_cdrom_lock_door
+c02416ea t ide_cdrom_tray_move
+c02417a3 t ide_cdrom_reset
+c02417fe t cdrom_check_status
+c024185d t ide_cdrom_check_media_change_real
+c0241891 t ide_cdrom_drive_status
+c0241925 t cdrom_read_toc
+c0241da3 t ide_cd_probe
+c02427c6 t idecd_revalidate_disk
+c02427dc t ide_cdrom_get_last_session
+c0242818 t ide_cdrom_audio_ioctl
+c02429f0 t cdrom_start_packet_command
+c0242b3a t ide_dump_status_no_sense
+c0242b47 t cdrom_analyze_sense_data
+c0242f35 t cdrom_end_request
+c0243040 t cdrom_write_check_ireason
+c02430b5 t ide_do_rw_cdrom
+c02435d0 t cdrom_read_check_ireason
+c0243658 t cdrom_decode_status
+c0243913 t cdrom_write_intr
+c0243ada t cdrom_newpc_intr
+c0243db8 t cdrom_pc_intr
+c0243fa7 t cdrom_seek_intr
+c0243ffb t cdrom_read_intr
+c024430d t cdrom_transfer_packet_command
+c02443eb t cdrom_do_newpc_cont
+c0244417 t cdrom_start_write_cont
+c0244434 t cdrom_do_pc_continuation
+c0244460 t ide_cdrom_packet
+c02444ff t cdrom_start_seek_continuation
+c024459f t cdrom_start_read_continuation
+c0244678 t ide_cd_remove
+c024468c t idefloppy_discard_data
+c02446a9 t idefloppy_next_pc_storage
+c02446d9 t idefloppy_init_pc
+c0244719 t idefloppy_create_request_sense_cmd
+c0244738 t idefloppy_transfer_pc2
+c0244754 t idefloppy_create_prevent_cmd
+c024476a t idefloppy_create_read_capacity_cmd
+c0244786 t idefloppy_create_start_stop_cmd
+c024479c t idefloppy_getgeo
+c02447ba t idefloppy_media_changed
+c02447e3 t idefloppy_revalidate_disk
+c0244806 t ide_floppy_put
+c024482d t ide_floppy_remove
+c024483e t ide_floppy_release
+c0244865 t idefloppy_queue_pc_tail
+c02448a6 t idefloppy_create_mode_sense_cmd
+c024490d t idefloppy_get_capacity
+c0244d13 t ide_floppy_probe
+c0244f4c t idefloppy_do_end_request
+c0244fa5 t idefloppy_rw_callback
+c0244fae t idefloppy_pc_callback
+c0244fc2 t idefloppy_request_sense_callback
+c024502b t idefloppy_do_request
+c0245472 t idefloppy_transfer_pc1
+c024550c t idefloppy_transfer_pc
+c02455b9 t idefloppy_ioctl
+c02459a2 t idefloppy_pc_intr
+c0245f56 t idefloppy_open
+c0246086 t idefloppy_release
+c02460e4 t cdrom_dummy_generic_packet
+c0246110 t media_changed
+c024617d T cdrom_media_changed
+c02461a9 t sanitize_format
+c02461fe t setup_report_key
+c0246250 t setup_send_key
+c0246292 T cdrom_mode_sense
+c02462f0 T cdrom_mode_select
+c024633b t cdrom_read_block
+c02463f5 t cdrom_switch_blocksize
+c0246484 t cdrom_sysctl_register
+c02464d9 t cdrom_sysctl_handler
+c024663b t cdrom_sysctl_info
+c0246d2c t cdrom_count_tracks
+c0246e93 t check_for_audio_disc
+c0247004 T init_cdrom_command
+c0247058 t cdrom_get_disc_info
+c02470db t cdrom_get_track_info
+c0247183 T cdrom_get_last_written
+c0247289 t cdrom_load_unload
+c0247329 t cdrom_read_mech_status
+c02473b4 T cdrom_release
+c0247590 t cdrom_get_random_writable
+c02475e8 t cdrom_mrw_exit
+c0247694 T cdrom_get_media_event
+c0247717 t dvd_read_struct
+c0247b68 T cdrom_number_of_slots
+c0247bca t cdrom_read_cdda_old
+c0247cce t cdrom_read_cdda
+c0247f3a t mmc_ioctl
+c0248eed T cdrom_ioctl
+c0249a2f T cdrom_open
+c024a34b T unregister_cdrom
+c024a3eb T register_cdrom
+c024a5a4 T usb_ifnum_to_if
+c024a5d6 T usb_altnum_to_altsetting
+c024a611 t __find_interface
+c024a638 T usb_disabled
+c024a63e T __usb_get_extra_descriptor
+c024a695 t ksuspend_usb_cleanup
+c024a69f T usb_buffer_unmap_sg
+c024a6a0 T usb_buffer_map_sg
+c024a74d T usb_buffer_free
+c024a765 T usb_buffer_alloc
+c024a77b T usb_get_current_frame_number
+c024a780 T usb_lock_device_for_reset
+c024a816 T usb_put_intf
+c024a823 T usb_put_dev
+c024a830 T usb_get_intf
+c024a843 T usb_get_dev
+c024a856 t match_device
+c024a8fe T usb_find_device
+c024a99a T usb_find_interface
+c024a9c6 T usb_alloc_dev
+c024ab80 t usb_release_dev
+c024abc0 t recursively_mark_NOTATTACHED
+c024abf8 T usb_port_suspend
+c024abfb T usb_port_resume
+c024abfe t locktree
+c024acaa t set_port_feature
+c024acf7 t set_port_led
+c024ad0c t clear_port_feature
+c024ad59 t clear_hub_feature
+c024ada5 t ep0_reinit
+c024adcc t hub_power_on
+c024ae10 t hub_port_status
+c024aefa t hub_hub_status
+c024afd9 T usb_root_hub_lost_power
+c024b061 T usb_set_device_state
+c024b0ea t hub_port_reset
+c024b2fd t hub_port_disable
+c024b36b t hub_port_init
+c024b8ae t kick_khubd
+c024b90f T usb_reset_device
+c024bc3d T usb_reset_composite_device
+c024bd72 T usb_hub_cleanup
+c024bd86 t hub_activate
+c024be07 t led_work
+c024bf1d t hub_quiesce
+c024bf70 t hub_ioctl
+c024bfde T usb_new_device
+c024c0bb T usb_disconnect
+c024c1b0 t hub_pre_reset
+c024c203 t hub_disconnect
+c024c2b7 T usb_hub_tt_clear_buffer
+c024c383 t hub_tt_kevent
+c024c498 t hub_thread
+c024ce9e t hub_irq
+c024cf69 t hub_probe
+c024d589 t hub_resume
+c024d5c2 t hub_post_reset
+c024d5d8 t hub_suspend
+c024d642 T usb_kick_khubd
+c024d656 T usb_hub_init
+c024d6e4 T usb_enable_root_hub_irq
+c024d701 T usb_calc_bus_time
+c024d82c T usb_hcd_platform_shutdown
+c024d844 t usb_deregister_bus
+c024d8b0 T usb_remove_hcd
+c024d983 T usb_put_hcd
+c024d995 t hcd_release
+c024d99d T usb_get_hcd
+c024d9b0 t hcd_resume_work
+c024d9f4 T usb_hc_died
+c024da5d t urb_unlink
+c024da8d T usb_hcd_giveback_urb
+c024dacd T usb_hcd_resume_root_hub
+c024db04 t unlink1
+c024db84 T usb_hcd_poll_rh_status
+c024dcd3 t rh_timer_func
+c024dcd8 T usb_host_cleanup
+c024dce2 T usb_host_init
+c024dd01 T usb_hcd_irq
+c024dd4f T usb_hcd_endpoint_disable
+c024de4c T hcd_bus_suspend
+c024de7f T hcd_bus_resume
+c024deca T usb_create_hcd
+c024dfa9 T usb_add_hcd
+c024e508 T usb_hcd_get_frame_number
+c024e527 T usb_hcd_unlink_urb
+c024e683 T usb_hcd_submit_urb
+c024ed9c T usb_unlink_urb
+c024edc4 T usb_kill_urb
+c024ee88 T usb_submit_urb
+c024f03f T usb_get_urb
+c024f04f T usb_free_urb
+c024f05e t urb_destroy
+c024f063 T usb_init_urb
+c024f094 T usb_alloc_urb
+c024f0cc t usb_enable_interface
+c024f14f t usb_if_uevent
+c024f390 T usb_driver_set_configuration
+c024f3e2 T usb_release_interface
+c024f3fe T usb_disable_endpoint
+c024f441 T usb_disable_device
+c024f4fc T usb_disable_interface
+c024f52b T usb_sg_cancel
+c024f5d6 t sg_complete
+c024f787 t usb_api_blocking_completion
+c024f78f t sg_clean
+c024f7eb t usb_start_wait_urb
+c024f872 T usb_bulk_msg
+c024f9a4 T usb_interrupt_msg
+c024f9ab T usb_control_msg
+c024fa8c T usb_clear_halt
+c024fb11 t usb_get_string
+c024fb89 t usb_string_sub
+c024fc66 T usb_string
+c024fdc5 T usb_cache_string
+c024fe55 T usb_set_configuration
+c025024f t driver_set_config_work
+c02502af T usb_get_descriptor
+c025035e T usb_reset_configuration
+c025045a T usb_sg_wait
+c0250563 T usb_set_interface
+c02506c7 T usb_sg_init
+c02508f6 T usb_get_device_descriptor
+c0250972 T usb_get_status
+c02509fc t usb_unbind_device
+c0250a0b T usb_match_device
+c0250a96 T usb_match_one_id
+c0250b07 T usb_match_id
+c0250b43 t usb_resume_device
+c0250b79 T usb_autosuspend_work
+c0250b7a t usb_match_dynamic_id
+c0250bcf t usb_resume_interface
+c0250c93 T usb_external_resume_device
+c0250d6a t usb_resume
+c0250d8f T usb_external_suspend_device
+c0250f74 T usb_deregister_device_driver
+c0250fa8 T usb_deregister
+c025102d T usb_register_device_driver
+c02510c7 T usb_register_driver
+c02511a6 T usb_driver_release_interface
+c025121c T usb_store_new_id
+c02512db t store_new_id
+c02512f3 t usb_probe_device
+c025132a t usb_uevent
+c0251510 t usb_suspend
+c0251527 t usb_device_match
+c0251578 t usb_probe_interface
+c02515f6 t usb_unbind_interface
+c0251655 T usb_driver_claim_interface
+c02516d0 t find_next_descriptor
+c025170e T usb_release_interface_cache
+c025173d T usb_destroy_configuration
+c02517f9 T usb_get_configuration
+c0252608 T usb_deregister_dev
+c02526a1 t release_usb_class
+c02526c3 T usb_register_dev
+c0252898 T usb_major_cleanup
+c02528a7 T usb_major_init
+c02528e8 t usb_open
+c02529b4 T hcd_buffer_free
+c0252a12 T hcd_buffer_destroy
+c0252a3c T hcd_buffer_create
+c0252abc T hcd_buffer_alloc
+c0252b1c t show_modalias
+c0252b9e t show_bInterfaceProtocol
+c0252bc0 t show_bInterfaceSubClass
+c0252be2 t show_bInterfaceClass
+c0252c04 t show_bNumEndpoints
+c0252c26 t show_bAlternateSetting
+c0252c48 t show_bInterfaceNumber
+c0252c6a t show_bMaxPacketSize0
+c0252c8c t show_bNumConfigurations
+c0252cae t show_bDeviceProtocol
+c0252cd0 t show_bDeviceSubClass
+c0252cf2 t show_bDeviceClass
+c0252d14 t show_bcdDevice
+c0252d36 t show_idProduct
+c0252d58 t show_idVendor
+c0252d7a t show_quirks
+c0252d9b t show_maxchild
+c0252dbc t show_version
+c0252de8 t show_devnum
+c0252e06 t show_busnum
+c0252e27 t show_speed
+c0252e6d t show_serial
+c0252e8e t show_manufacturer
+c0252eaf t show_product
+c0252ed0 t show_bConfigurationValue
+c0252efb t show_configuration_string
+c0252f2b t show_bMaxPower
+c0252f58 t show_bmAttributes
+c0252f83 t show_bNumInterfaces
+c0252fae t show_interface_string
+c0252fef T usb_remove_sysfs_intf_files
+c0253035 T usb_remove_sysfs_dev_files
+c025307c T usb_create_sysfs_intf_files
+c0253103 T usb_create_sysfs_dev_files
+c0253191 t set_bConfigurationValue
+c0253224 t show_ep_direction
+c025325e t show_ep_interval
+c0253330 t show_ep_type
+c0253383 t show_ep_wMaxPacketSize
+c02533aa t show_ep_bInterval
+c02533cc t show_ep_bmAttributes
+c02533ee t show_ep_bEndpointAddress
+c0253410 t show_ep_bLength
+c0253431 t destroy_endpoint_class
+c0253445 T usb_remove_ep_files
+c02534ad t release_endpoint_class
+c02534e0 t endpoint_free_minor
+c02534f0 T usb_create_ep_files
+c02537a7 t ep_device_release
+c02537bc t driver_probe
+c02537c2 t findintfep
+c0253870 t __match_minor
+c0253885 t usbdev_poll
+c02538cc t releaseintf
+c025390b t free_async
+c025393c t destroy_async
+c02539ce t destroy_async_on_interface
+c0253a45 t snoop_urb
+c0253b82 t driver_disconnect
+c0253be0 t processcompl
+c0253ca0 t claimintf
+c0253cef t checkintf
+c0253d79 t check_ctrlrecip
+c0253dce t proc_submiturb
+c025450f t async_completed
+c02545ec t proc_reapurb
+c0254712 t proc_ioctl_default
+c02548e6 t usbdev_lseek
+c0254942 T usb_devio_cleanup
+c025496f t usb_classdev_notify
+c02549ef t usbdev_open
+c0254b32 t usbdev_ioctl
+c0255d59 t usbdev_read
+c0255f7f t usbdev_release
+c0256030 T usb_notify_remove_bus
+c0256041 T usb_notify_add_bus
+c0256052 T usb_notify_add_device
+c0256063 T usb_notify_remove_device
+c025608c T usb_unregister_notify
+c0256098 T usb_register_notify
+c02560a4 t generic_resume
+c02560a9 t generic_suspend
+c02560ae t generic_disconnect
+c02560d1 t generic_probe
+c02562b0 T usb_detect_quirks
+c02562f4 T usb_hcd_pci_shutdown
+c0256310 T usb_hcd_pci_resume
+c02563ea T usb_hcd_pci_remove
+c0256489 T usb_hcd_pci_suspend
+c02565d0 T usb_hcd_pci_probe
+c02568fc t default_read_file
+c02568ff t default_write_file
+c0256902 t default_open
+c0256915 T usbfs_cleanup
+c0256943 t usb_get_sb
+c0256954 t default_file_lseek
+c02569b4 t remount
+c0256d21 T usbfs_update_special
+c0256d51 t usbfs_get_inode
+c0256e04 t usbfs_fill_super
+c0256e63 t usbfs_mknod
+c0256ea1 t fs_create_file
+c0256ffe t fs_remove_file
+c025712c t usbfs_notify
+c025745c t class_decode
+c0257479 t usb_device_open
+c0257486 t usb_device_release
+c02574a2 t usb_device_lseek
+c02574fe t usb_device_poll
+c0257594 t usb_device_dump
+c0257f02 t usb_device_read
+c025803c T usbfs_conn_disc_event
+c0258064 t mmio_resource_enabled
+c02580a8 T uhci_reset_hc
+c025811c T uhci_check_and_reset_hc
+c0258177 t quirk_usb_early_handoff
+c025852c T usb_usual_check_type
+c025855f t usu_disconnect
+c0258560 t usu_get_bias
+c025858d T usb_usual_clear_present
+c02585bb T usb_usual_set_present
+c02585e9 t usu_set_bias
+c0258675 t usu_probe_thread
+c025871f t usu_probe
+c02587e4 t serio_match_port
+c0258830 t serio_bus_match
+c025884f t serio_driver_show_bind_mode
+c025887b t serio_driver_show_description
+c02588a3 t serio_show_bind_mode
+c02588cf t serio_show_id_extra
+c02588ee t serio_show_id_id
+c025890d t serio_show_id_proto
+c025892c t serio_show_id_type
+c025894b t serio_show_modalias
+c0258987 t serio_show_description
+c02589a7 t serio_cleanup
+c02589d3 t serio_suspend
+c02589fc t serio_shutdown
+c0258a03 t serio_disconnect_driver
+c0258a29 t serio_driver_remove
+c0258a36 t serio_reconnect_driver
+c0258a6c t serio_connect_driver
+c0258a96 t serio_driver_probe
+c0258aa6 t serio_find_driver
+c0258ade t serio_set_drv
+c0258afc T serio_close
+c0258b0f T serio_open
+c0258b38 t serio_release_port
+c0258b49 t serio_free_event
+c0258b5c t serio_remove_pending_events
+c0258bb2 t serio_destroy_port
+c0258cac t serio_disconnect_port
+c0258ced T serio_unregister_child_port
+c0258d19 T serio_unregister_port
+c0258d3f t serio_reconnect_port
+c0258d65 t serio_uevent
+c0258f12 T serio_unregister_driver
+c0258f76 t serio_queue_event
+c0259072 T __serio_register_driver
+c02590f1 T serio_reconnect
+c02590fd T serio_rescan
+c0259106 T serio_interrupt
+c025916b t serio_resume
+c025919f T __serio_register_port
+c0259262 t serio_rebind_driver
+c0259406 t serio_set_bind_mode
+c0259479 t serio_driver_set_bind_mode
+c02594e5 t serio_thread
+c025979c t i8042_start
+c02597ab t i8042_flush
+c0259842 t i8042_controller_check
+c0259866 t i8042_wait_write
+c0259898 t __i8042_command
+c0259a69 t i8042_command
+c0259a99 t i8042_controller_selftest
+c0259afa t i8042_toggle_aux
+c0259b5f t i8042_set_mux_mode
+c0259c07 t i8042_controller_reset
+c0259c55 t i8042_shutdown
+c0259c57 t i8042_suspend
+c0259c7a t i8042_enable_aux_port
+c0259cb5 t i8042_enable_mux_ports
+c0259cea t i8042_enable_kbd_port
+c0259d25 t i8042_aux_write
+c0259d4b t i8042_interrupt
+c0259f58 t i8042_resume
+c025a03f t i8042_free_irqs
+c025a080 t i8042_remove
+c025a0b2 t i8042_create_aux_port
+c025a197 t i8042_stop
+c025a1ab t i8042_free_aux_ports
+c025a1cd t i8042_probe
+c025a6d0 t i8042_pnp_exit
+c025a70b t i8042_pnp_aux_probe
+c025a844 t i8042_pnp_kbd_probe
+c025a97d t i8042_aux_test_irq
+c025a9cf t i8042_kbd_write
+c025aa38 t i8042_panic_blink
+c025ab68 T ps2_is_keyboard_id
+c025ab89 T ps2_cmd_aborted
+c025abc2 T ps2_handle_response
+c025ac32 T ps2_handle_ack
+c025acd6 T ps2_init
+c025acfb T ps2_schedule_command
+c025ada3 T ps2_sendbyte
+c025ae6a T ps2_command
+c025b18b t ps2_execute_scheduled_command
+c025b1a4 T ps2_drain
+c025b28c T input_grab_device
+c025b2a8 T input_release_device
+c025b2f2 T input_flush_device
+c025b30e t input_fetch_keycode
+c025b340 t input_default_getkeycode
+c025b36a t input_match_device
+c025b485 t input_proc_devices_poll
+c025b4ae t list_get_nth_element
+c025b4dc t list_get_next_element
+c025b4f0 t input_devices_seq_start
+c025b4f7 t input_devices_seq_next
+c025b4fe t input_devices_seq_stop
+c025b4ff t input_handlers_seq_start
+c025b50b t input_handlers_seq_next
+c025b51a t input_handlers_seq_stop
+c025b51b t input_attach_handler
+c025b58a t input_proc_exit
+c025b5ba t input_proc_handlers_open
+c025b5c6 t input_proc_devices_open
+c025b5d2 t input_handlers_seq_show
+c025b62b t input_seq_print_bitmap
+c025b6bf t input_dev_release
+c025b6de t input_print_bitmap
+c025b796 t input_add_uevent_bm_var
+c025b834 t input_dev_show_cap_sw
+c025b86f t input_dev_show_cap_ff
+c025b8aa t input_dev_show_cap_snd
+c025b8e5 t input_dev_show_cap_led
+c025b920 t input_dev_show_cap_msc
+c025b95b t input_dev_show_cap_abs
+c025b996 t input_dev_show_cap_rel
+c025b9d1 t input_dev_show_cap_key
+c025ba0c t input_dev_show_cap_ev
+c025ba47 t input_print_modalias_bits
+c025bad6 t input_print_modalias
+c025bcd7 t input_dev_show_modalias
+c025bd09 T input_free_device
+c025bd18 t input_dev_show_id_version
+c025bd42 t input_dev_show_id_product
+c025bd6c t input_dev_show_id_vendor
+c025bd96 t input_dev_show_id_bustype
+c025bdc0 t input_dev_show_uniq
+c025bdf3 t input_dev_show_phys
+c025be26 t input_dev_show_name
+c025be59 T input_close_device
+c025be9f T input_open_device
+c025bef3 T input_event
+c025c322 T input_inject_event
+c025c352 t input_default_setkeycode
+c025c412 T input_set_capability
+c025c480 t input_dev_uevent
+c025c92c t input_devices_seq_show
+c025cb6d T input_allocate_device
+c025cbd9 T input_unregister_handler
+c025cc82 T input_unregister_handle
+c025ccad t input_open_file
+c025cd69 T input_register_handle
+c025cda2 T input_register_device
+c025cf1a T input_unregister_device
+c025d016 T input_register_handler
+c025d0b1 t input_repeat_key
+c025d11c t check_effect_access
+c025d145 t erase_effect
+c025d18d T input_ff_destroy
+c025d1ce t flush_effects
+c025d20f T input_ff_erase
+c025d259 T input_ff_event
+c025d2ea T input_ff_create
+c025d3c9 T input_ff_upload
+c025d574 t mousedev_poll
+c025d5ae t mousedev_fasync
+c025d5cc t mousedev_free
+c025d5df t mousedev_release
+c025d67d t mousedev_packet
+c025d7e8 t mousedev_write
+c025d9a1 t mousedev_notify_readers
+c025db49 t mousedev_disconnect
+c025dc05 t mousedev_event
+c025e020 t mousedev_read
+c025e162 t mousedev_open
+c025e282 t mousedev_connect
+c025e428 t evdev_poll
+c025e46c t evdev_fasync
+c025e490 t evdev_free
+c025e4a3 t evdev_release
+c025e50d t evdev_flush
+c025e52e t str_to_user
+c025e56d t bits_to_user
+c025e598 t evdev_ioctl
+c025eaa0 t evdev_disconnect
+c025eb51 t evdev_connect
+c025eca3 t evdev_event
+c025edd2 t evdev_write
+c025ee46 t evdev_read
+c025ef84 t evdev_open
+c025f028 t atkbd_compat_scancode
+c025f061 t atkbd_set_keycode_table
+c025f164 t atkbd_select_set
+c025f26a t atkbd_set_leds
+c025f344 t atkbd_set_repeat_rate
+c025f3ca t atkbd_attr_show_helper
+c025f416 t atkbd_do_show_err_count
+c025f41f t atkbd_do_show_softraw
+c025f428 t atkbd_do_show_softrepeat
+c025f431 t atkbd_do_show_set
+c025f43a t atkbd_do_show_scroll
+c025f443 t atkbd_do_show_extra
+c025f44f t atkbd_show_err_count
+c025f470 t atkbd_show_softraw
+c025f498 t atkbd_show_softrepeat
+c025f4c0 t atkbd_show_set
+c025f4e2 t atkbd_show_scroll
+c025f50a t atkbd_show_extra
+c025f532 t atkbd_attr_set_helper
+c025f5ba t atkbd_do_set_softraw
+c025f5cd t atkbd_do_set_softrepeat
+c025f5e0 t atkbd_do_set_set
+c025f5f3 t atkbd_do_set_scroll
+c025f606 t atkbd_do_set_extra
+c025f619 t atkbd_set_device_attrs
+c025f7c6 t atkbd_set_softraw
+c025f878 t atkbd_set_softrepeat
+c025f962 t atkbd_set_scroll
+c025fa25 t atkbd_schedule_event_work
+c025fa72 t atkbd_event
+c025faa9 t atkbd_activate
+c025fb14 t atkbd_set_set
+c025fc21 t atkbd_set_extra
+c025fd23 t atkbd_probe
+c025fdf2 t atkbd_reconnect
+c025fea6 t atkbd_event_work
+c025feeb t atkbd_cleanup
+c025fefd t atkbd_disconnect
+c025ff5e t atkbd_connect
+c0260121 t atkbd_interrupt
+c0260638 T touchkit_ps2_detect
+c026063e t ps2bare_detect
+c026065f t psmouse_protocol_by_name
+c0260703 t psmouse_set_maxproto
+c0260741 t psmouse_poll
+c0260756 t psmouse_initialize
+c026078e t psmouse_set_rate
+c02607cd T psmouse_set_resolution
+c026081d t psmouse_probe
+c0260888 t thinking_detect
+c0260929 t intellimouse_detect
+c02609ce t im_explorer_detect
+c0260ad4 t genius_detect
+c0260b85 T psmouse_reset
+c0260bb4 T psmouse_sliced_command
+c0260c0c t psmouse_set_state
+c0260c4a t psmouse_deactivate
+c0260c85 t psmouse_activate
+c0260cc3 t psmouse_attr_set_resolution
+c0260cf7 t psmouse_attr_set_rate
+c0260d2b t psmouse_set_int_attr
+c0260d5e t psmouse_show_int_attr
+c0260d7c t psmouse_protocol_by_type
+c0260dd7 t psmouse_get_maxproto
+c0260e03 t psmouse_attr_show_protocol
+c0260e2e t psmouse_extensions
+c0260fc4 t psmouse_switch_protocol
+c026111a t psmouse_attr_set_protocol
+c026131a t psmouse_handle_byte
+c02613ed t psmouse_resync
+c026155f t psmouse_cleanup
+c02615e1 t psmouse_reconnect
+c02616c4 t psmouse_disconnect
+c02617bb t psmouse_connect
+c02619a6 t psmouse_interrupt
+c0261baf T psmouse_attr_set_helper
+c0261c78 t psmouse_process_byte
+c0261eab T psmouse_attr_show_helper
+c0261efc t synaptics_validate_byte
+c0261f66 t synaptics_send_cmd
+c0261f97 t synaptics_query_hardware
+c02620f6 T synaptics_detect
+c0262174 t synaptics_mode_cmd
+c02621ac t synaptics_pt_activate
+c02621f0 t synaptics_set_rate
+c026221e t synaptics_set_absolute_mode
+c0262252 t synaptics_reconnect
+c02622e7 T synaptics_reset
+c02622ee t synaptics_disconnect
+c0262305 T synaptics_init
+c02625ff t synaptics_process_byte
+c0262d4f t synaptics_pt_write
+c0262d90 t alps_get_model
+c0262f1e T alps_detect
+c0262f64 t alps_passthrough_mode
+c0262fce t alps_hw_init
+c026318d t alps_reconnect
+c02631a7 t alps_poll
+c0263246 t alps_disconnect
+c026325d t alps_process_packet
+c0263713 t alps_process_byte
+c026376b T alps_init
+c0263950 t ps2pp_attr_show_smartscroll
+c0263978 t ps2pp_cmd
+c02639a9 t ps2pp_set_smartscroll
+c0263a0f T ps2pp_init
+c0263d41 t ps2pp_attr_set_smartscroll
+c0263d83 t ps2pp_disconnect
+c0263d95 t ps2pp_set_resolution
+c0263dfb t ps2pp_process_byte
+c0264044 t lifebook_set_serio_phys
+c026404f t lifebook_set_6byte_proto
+c0264059 t lifebook_set_resolution
+c02640ab t lifebook_disconnect
+c02640c2 t lifebook_absolute_mode
+c02640fb T lifebook_detect
+c0264153 T lifebook_init
+c026430a t lifebook_process_byte
+c02645c0 t trackpoint_start_protocol
+c02645fd t trackpoint_toggle_bit
+c0264665 t trackpoint_set_bit_attr
+c02646cd t trackpoint_write
+c026472b t trackpoint_set_int_attr
+c026477e t trackpoint_read
+c02647b5 t trackpoint_sync
+c026496e t trackpoint_reconnect
+c0264990 t trackpoint_show_int_attr
+c02649c4 T trackpoint_detect
+c0264ae9 t trackpoint_disconnect
+c0264b10 t linear_mergeable_bvec
+c0264c1b t linear_congested
+c0264c66 t linear_exit
+c0264c70 t linear_conf
+c0264fdc t linear_add
+c0265040 t linear_status
+c0265071 t linear_stop
+c026509c t linear_run
+c0265113 t linear_make_request
+c026533e t linear_unplug
+c0265372 t linear_issue_flush
+c02653c8 t calc_dev_size
+c02653f7 t md_csum_fold
+c0265408 t calc_sb_csum
+c0265448 t calc_sb_1_csum
+c02654ac t cmd_match
+c02654de t rdev_attr_show
+c02654fa t level_store
+c0265559 t null_show
+c026555f t update_raid_disks
+c02655ab t md_getgeo
+c02655d1 t md_media_changed
+c02655db t md_revalidate
+c02655eb t mdstat_poll
+c0265623 T md_autodetect_dev
+c026563d t get_ro
+c026565e t reshape_position_show
+c02656ab t suspend_hi_show
+c02656d8 t suspend_lo_show
+c0265705 t sync_speed_show
+c0265768 t mismatch_cnt_show
+c0265795 t metadata_show
+c02657d4 t size_show
+c0265801 t resync_start_show
+c026582e t chunk_size_show
+c026588f t raid_disks_show
+c02658f8 t layout_show
+c0265959 t level_show
+c02659ab t safe_delay_show
+c02659ec t rdev_size_show
+c0265a13 t offset_show
+c0265a3a t slot_show
+c0265a71 t errors_show
+c0265a92 t set_ro
+c0265aca t sync_max_store
+c0265b47 t chunk_size_store
+c0265bb0 t raid_disks_store
+c0265c2d t layout_store
+c0265c96 t errors_store
+c0265cda t print_desc
+c0265d0f T unregister_md_personality
+c0265d55 t restore_bitmap_write_access
+c0265d7c t bitmap_store
+c0265e1b t reshape_position_store
+c0265e9c t suspend_hi_store
+c0265f45 t suspend_lo_store
+c0265fca t resync_start_store
+c0266029 t rdev_size_store
+c02660a3 t offset_store
+c02660fe T md_wakeup_thread
+c0266126 t restart_array
+c02661ac t md_safemode_timeout
+c02661c1 t md_free
+c02661c9 t rdev_free
+c02661d1 t super_show
+c0266217 t delayed_delete
+c026621f t free_disk_sb
+c026625a t md_fail_request
+c026626c t mddev_put
+c02662ca t md_seq_stop
+c02662dd t md_print_devices
+c0266634 T md_error
+c02666c7 t unlock_rdev
+c026670c t export_rdev
+c0266789 t unbind_rdev_from_array
+c0266836 t kick_rdev_from_array
+c0266846 t export_array
+c02668cd t md_seq_open
+c026691d t safe_delay_store
+c0266a02 t md_release
+c0266a1e t rdev_attr_store
+c0266a59 t md_import_device
+c0266cb4 t bind_rdev_to_array
+c0266eac t update_size
+c0266fd7 t mddev_find
+c0267156 t md_probe
+c0267291 t is_mddev_idle
+c026735f T md_write_end
+c02673a1 T register_md_personality
+c02673ee T md_unregister_thread
+c0267401 T md_register_thread
+c0267494 T md_super_wait
+c0267539 T sync_page_io
+c02675cc t read_disk_sb
+c0267660 t super_1_load
+c0267984 t super_90_load
+c0267ccb t bi_complete
+c0267ce3 T md_super_write
+c0267d9b t md_update_sb
+c02680e4 T md_allow_write
+c0268158 t size_store
+c02681f7 t super_written
+c02682ac T md_new_event
+c02682e7 t do_md_stop
+c02685c8 t do_md_run
+c0268d68 t autostart_arrays
+c02690a2 T md_done_sync
+c02690ed t state_store
+c026919c t array_state_store
+c026931b t super_written_barrier
+c02693d7 t state_show
+c02694a1 t action_show
+c0269514 t action_store
+c0269647 t sync_completed_show
+c026968e t slot_store
+c0269731 t sync_min_store
+c02697ae t super_90_validate
+c0269ac4 t super_1_validate
+c0269d51 t super_90_sync
+c026a0bd t super_1_sync
+c026a306 t array_state_show
+c026a392 t metadata_store
+c026a456 T md_write_start
+c026a53b t sync_min_show
+c026a573 t sync_max_show
+c026a5ab t md_seq_start
+c026a644 t md_seq_next
+c026a6b7 T md_do_sync
+c026b0bd t md_notify_reboot
+c026b176 t md_open
+c026b1c6 t md_seq_show
+c026b9d1 T md_check_recovery
+c026be4c t md_attr_show
+c026be9d t md_attr_store
+c026bf04 t md_ioctl
+c026d193 t md_thread
+c026d262 t new_dev_store
+c026d37c t bitmap_file_set_bit
+c026d403 T bitmap_print_sb
+c026d556 t free_buffers
+c026d594 t read_page
+c026d78c t bitmap_mask_state
+c026d7ee t end_bitmap_write
+c026d839 t read_sb_page
+c026d959 t write_page
+c026db73 T bitmap_update_sb
+c026dc0f t bitmap_free_page
+c026dc16 t bitmap_count_page
+c026dc8f t bitmap_get_counter
+c026de71 t bitmap_set_memory_bits
+c026df1f T bitmap_dirty_bits
+c026df69 T bitmap_end_sync
+c026e03a T bitmap_close_sync
+c026e08b T bitmap_start_sync
+c026e10f T bitmap_endwrite
+c026e23f t bitmap_file_put
+c026e375 t bitmap_free
+c026e3cc T bitmap_destroy
+c026e3f6 T file_path
+c026e424 t bitmap_file_kick
+c026e4ae T bitmap_daemon_work
+c026e760 T bitmap_flush
+c026e79a T bitmap_startwrite
+c026e901 T bitmap_write_all
+c026e92e T bitmap_unplug
+c026ea75 T bitmap_create
+c026f2d4 t dm_netlink_exit
+c026f2d5 T dm_get_mapinfo
+c026f2e7 T dm_open_count
+c026f2eb T dm_get_geometry
+c026f301 T dm_get_xid
+c026f305 t __noflush_suspending
+c026f30f t max_io_len
+c026f3a0 T dm_get_mdptr
+c026f3a7 T dm_set_mdptr
+c026f3ae T dm_get
+c026f3b3 T dm_device_name
+c026f3b7 T dm_get_event_nr
+c026f3be T dm_disk
+c026f3c2 T dm_suspended
+c026f3cb T dm_set_geometry
+c026f46c t local_exit
+c026f4bb t clone_bio
+c026f52a t dm_bio_destructor
+c026f532 t event_callback
+c026f559 t dec_pending
+c026f6d2 t __map_bio
+c026f7f4 t clone_endio
+c026f8bb t unlock_fs
+c026f8e8 t __unbind
+c026f92b t free_minor
+c026f94f T dm_create
+c026fd01 T dm_get_table
+c026fd2c T dm_put
+c026fe36 T dm_noflush_suspending
+c026fe54 t dm_blk_close
+c026fe6c t dm_any_congested
+c026fea1 t dm_unplug_all
+c026fec2 t dm_flush_all
+c026feed t __split_bio
+c0270304 t __flush_deferred_io
+c0270324 t dm_blk_ioctl
+c02703c5 T dm_resume
+c02704bf T dm_wait_event
+c027054d T dm_swap_table
+c02706bc T dm_suspend
+c0270952 t dm_request
+c0270a40 t dm_blk_open
+c0270ab4 T dm_get_md
+c0270b26 T dm_lock_for_deletion
+c0270b56 t dm_blk_getgeo
+c0270b74 T dm_table_get
+c0270b79 T dm_set_device_limits
+c0270c57 T dm_table_get_size
+c0270c7e T dm_table_get_target
+c0270c96 T dm_table_find_target
+c0270cf0 T dm_table_get_num_targets
+c0270cf7 T dm_table_get_devices
+c0270cfd T dm_table_get_mode
+c0270d04 t suspend_targets
+c0270d3b T dm_table_presuspend_targets
+c0270d44 T dm_table_postsuspend_targets
+c0270d50 T dm_table_resume_targets
+c0270daf T dm_table_get_md
+c0270dbd T dm_table_set_restrictions
+c0270e2c T dm_table_event
+c0270e6a T dm_table_event_callback
+c0270e96 T dm_table_put
+c0270f43 t realloc_argv
+c0270fac T dm_split_args
+c0271074 t close_dev
+c027109f T dm_put_device
+c02710cb t open_dev
+c0271121 T dm_get_device
+c02713b1 T dm_vcalloc
+c02713f1 T dm_table_complete
+c02715aa t alloc_targets
+c0271690 T dm_table_add_target
+c0271900 T dm_table_create
+c027198b T dm_create_error_table
+c0271a3d T dm_table_any_congested
+c0271a85 T dm_table_flush_all
+c0271aed T dm_table_unplug_all
+c0271b18 t io_err_ctr
+c0271b1b t io_err_dtr
+c0271b1c t io_err_map
+c0271b22 T dm_unregister_target
+c0271bb3 T dm_target_exit
+c0271bd2 T dm_register_target
+c0271c86 T dm_target_iterate
+c0271cca T dm_put_target_type
+c0271cff t get_target_type
+c0271d80 T dm_get_target_type
+c0271db4 t linear_map
+c0271ddf T dm_linear_exit
+c0271e03 t linear_ioctl
+c0271e81 t linear_status
+c0271ece t linear_dtr
+c0271ee1 t linear_ctr
+c0271fb4 t stripe_map
+c027207a T dm_stripe_exit
+c0272099 t stripe_status
+c027215c t stripe_dtr
+c0272188 t stripe_ctr
+c02723e8 t init_buckets
+c02723f9 t hash_str
+c0272418 t get_result_buffer
+c0272440 t invalid_str
+c0272455 t check_name
+c027248f t __get_uuid_cell
+c027251f t __get_name_cell
+c02725a7 t __find_device_hash_cell
+c0272636 t find_device
+c02726ba t __dev_status
+c0272754 t dev_status
+c027277f t dev_set_geometry
+c027288a t target_message
+c02729b3 t free_cell
+c02729d4 t list_versions
+c0272a53 t retrieve_status
+c0272bb2 t table_status
+c0272c08 t table_deps
+c0272d1a t table_clear
+c0272d92 t table_load
+c0272f3d t dev_wait
+c0272fa5 t dev_suspend
+c02730fc t dev_rename
+c0273263 t __hash_remove
+c02732b7 t dev_remove
+c0273352 t dm_hash_remove_all
+c02733e0 t dm_hash_exit
+c02733e7 T dm_interface_exit
+c0273407 t dev_create
+c02735be t list_version_get_needed
+c02735dc t list_version_get_info
+c0273675 t ctl_ioctl
+c0273905 t remove_all
+c0273940 t list_devices
+c0273af4 t list_get_page
+c0273b11 t list_next_page
+c0273b21 t bvec_get_page
+c0273b39 t bvec_next_page
+c0273b3e t vm_next_page
+c0273b55 t km_get_page
+c0273b82 t km_next_page
+c0273b99 t vm_get_page
+c0273bc3 t dm_bio_destructor
+c0273bd1 t dec_count
+c0273c1a t dispatch_io
+c0273dd1 t endio
+c0273e22 T dm_io
+c027406b T dm_io_client_destroy
+c0274085 T dm_io_client_resize
+c027409c T dm_io_client_create
+c0274118 t drop_pages
+c027413a t client_free_pages
+c0274168 t jobs_exit
+c02741c1 t kcopyd_exit
+c02741fd T kcopyd_client_destroy
+c0274297 t process_jobs
+c027434e t do_work
+c027437b t run_io_job
+c02743ed t dispatch_job
+c0274437 t kcopyd_put_pages
+c027446b t run_pages_job
+c027450f t run_complete_job
+c0274588 T kcopyd_client_create
+c02747b2 t segment_complete
+c0274942 T kcopyd_copy
+c0274a58 t complete_io
+c0274afc T dmi_get_system_info
+c0274b04 T dmi_find_device
+c0274b53 T dmi_name_in_vendors
+c0274b87 T dmi_check_system
+c0274bdb T dmi_get_year
+c0274c34 t utf8_strlen
+c0274c47 t dummy
+c0274c4d t efivar_release
+c0274c57 t get_var_data
+c0274cbe t efivar_show_raw
+c0274cef t systab_read
+c0274df5 t efivar_size_read
+c0274e3f t efivar_attr_read
+c0274ec6 t efivar_guid_read
+c0274fa1 t efivar_attr_store
+c0274fdc t efivar_attr_show
+c0275013 t efivar_create_sysfs_entry
+c02751e6 t efivar_data_read
+c0275232 t efivar_store_raw
+c027533b t efivar_create
+c02754af t efivar_delete
+c027562c t read_cyclone
+c0275638 t acpi_pm_check_graylist
+c0275666 T acpi_pm_read_verified
+c02756ab t acpi_pm_read_slow
+c02756b3 t acpi_pm_read
+c02756c2 t acpi_pm_check_blacklist
+c0275710 t show_bytes_transferred
+c0275767 t show_memcpy_count
+c02757be t dma_chan_free_rcu
+c0275812 T dma_chan_cleanup
+c0275838 t dma_class_dev_release
+c0275848 t dma_async_device_cleanup
+c0275850 T dma_async_device_unregister
+c0275963 t dma_client_chan_alloc
+c0275a1f T dma_async_client_chan_request
+c0275a3e T dma_sync_wait
+c0275aa0 T dma_async_client_unregister
+c0275b66 t show_in_use
+c0275bb7 T dma_async_tx_descriptor_init
+c0275be3 T dma_async_memcpy_buf_to_pg
+c0275cb0 T dma_async_memcpy_pg_to_pg
+c0275d55 T dma_async_memcpy_buf_to_buf
+c0275e52 T dma_async_device_register
+c0276051 T dma_async_client_register
+c0276080 t num_pages_spanned
+c027609e T dma_memcpy_pg_to_iovec
+c02761af T dma_memcpy_to_iovec
+c02762ef T dma_unpin_iovec_pages
+c027634c T dma_pin_iovec_pages
+c02764e4 t hid_lookup_collection
+c0276521 t hid_add_usage
+c0276560 t hid_parser_reserved
+c0276563 t snto32
+c02765a2 t s32ton
+c02765d5 T hid_set_field
+c0276613 T hid_output_report
+c02768e2 T hid_free_device
+c0276967 t hid_process_event
+c02769ba T hid_input_field
+c0276c99 T hid_input_report
+c0276d68 t hid_add_field
+c0276f50 T hid_parse_report
+c0277191 t hid_parser_main
+c027731e t hid_parser_local
+c027741c t hid_parser_global
+c0277668 t hidinput_find_key
+c027771f t hidinput_getkeycode
+c0277740 t hidinput_close
+c027774b T hidinput_disconnect
+c0277782 T hidinput_connect
+c027a2b4 T hidinput_hid_event
+c027a502 t hidinput_setkeycode
+c027a55b T hidinput_report_event
+c027a593 T hidinput_find_field
+c027a615 t hidinput_open
+c027a620 t hid_find_max_report
+c027a670 t hid_set_idle
+c027a6c8 t hid_start_in
+c027a72f t hid_resume
+c027a754 t hid_post_reset
+c027a77e t hid_suspend
+c027a7be t hid_pre_reset
+c027a7c2 T usbhid_close
+c027a7e2 t hid_free_buffers
+c027a84d t hid_disconnect
+c027a8fe t hid_submit_out
+c027a994 t hid_submit_ctrl
+c027ab5a T usbhid_submit_report
+c027acc8 t usb_hidinput_input_event
+c027ad3b t hid_io_error
+c027ae0e T usbhid_open
+c027ae2b T usbhid_wait_io
+c027aedc T usbhid_init_reports
+c027af97 t hid_probe
+c027bbc4 t hid_irq_in
+c027bcfe t hid_irq_out
+c027be0d t hid_ctrl
+c027bf4e t hid_retry_timeout
+c027bf64 t hid_reset
+c027c08c T usbhid_lookup_quirk
+c027c137 T usbhid_quirks_exit
+c027c17b T usbhid_modify_dquirk
+c027c22f T usbhid_quirks_init
+c027c2a8 T pcibios_align_resource
+c027c2e4 T pci_mmap_page_range
+c027c32f T pcibios_set_master
+c027c3ba T pcibios_enable_resources
+c027c4b8 T pcibios_set_irq_routing
+c027c4f6 t pci_bios_write
+c027c5a4 t pci_bios_read
+c027c653 T pcibios_get_irq_routing_table
+c027c741 T pcibios_sort
+c027c898 t get_base_addr
+c027c8fb t pci_exp_set_dev_base
+c027c93d t pci_mmcfg_read
+c027ca3f t pci_mmcfg_write
+c027cb44 t pci_conf2_read
+c027cc25 t pci_conf2_write
+c027cd07 T pci_conf1_write
+c027cdae T pci_conf1_read
+c027ce5c t pci_fixup_latency
+c027ce67 t pci_fixup_piix4_acpi
+c027ce72 t pci_fixup_transparent_bridge
+c027ce99 t quirk_pcie_aspm_read
+c027cec7 t quirk_pcie_aspm_write
+c027cf25 t pci_siemens_interrupt_controller
+c027cf2d t pci_early_fixup_cyrix_5530
+c027cf72 t pci_pre_fixup_toshiba_ohci1394
+c027cfa7 t pcie_rootport_aspm_quirk
+c027d056 t pci_fixup_umc_ide
+c027d08a t pci_fixup_ncr53c810
+c027d0b7 t pci_fixup_i450gx
+c027d123 t pci_fixup_via_northbridge_bug
+c027d208 t pci_fixup_nforce2
+c027d268 t pci_post_fixup_toshiba_ohci1394
+c027d2e4 t pci_fixup_video
+c027d373 t pci_fixup_i450nx
+c027d454 T pci_acpi_scan_root
+c027d474 t pirq_get_info
+c027d4bf T eisa_set_level_irq
+c027d52d t read_config_nybble
+c027d569 t pirq_amd756_get
+c027d5bb t pirq_vlsi_get
+c027d5e6 t pirq_cyrix_get
+c027d5f4 t pirq_opti_get
+c027d601 t pirq_ite_get
+c027d612 t pirq_via586_get
+c027d623 t pirq_via_get
+c027d63a t pirq_ali_get
+c027d64d t write_config_nybble
+c027d6b3 t pirq_amd756_set
+c027d708 t pirq_vlsi_set
+c027d744 t pirq_cyrix_set
+c027d763 t pirq_opti_set
+c027d781 t pirq_ite_set
+c027d7a3 t pirq_via586_set
+c027d7c5 t pirq_via_set
+c027d7ed t pirq_ali_set
+c027d81d t pirq_bios_set
+c027d839 t pcibios_lookup_irq
+c027db90 T pcibios_penalize_isa_irq
+c027dbbc t pirq_serverworks_get
+c027dbce t pirq_serverworks_set
+c027dbe9 t pirq_enable_irq
+c027dd75 t pirq_piix_get
+c027dd9d t pirq_sis_get
+c027ddd9 t pirq_sis_set
+c027de3b t pirq_piix_set
+c027de5c t pci_read
+c027de8a t pci_write
+c027deb9 T pcibios_assign_all_busses
+c027dec5 T pcibios_disable_device
+c027dedb t assign_all_busses
+c027df00 t set_bf_sort
+c027df2e T pcibios_enable_device
+c027df4f T pcibios_scan_root
+c027dfa5 T pcibios_fixup_bus
+c027e06a T pcibios_setup
+c027e3d8 T write_pci_config_byte
+c027e412 T early_pci_allowed
+c027e424 T read_pci_config
+c027e459 T read_pci_config_byte
+c027e49a T read_pci_config_16
+c027e4dc T write_pci_config
+c027e518 T __restore_processor_state
+c027e67a T restore_processor_state
+c027e684 T __save_processor_state
+c027e6c6 T save_processor_state
+c027e6d0 t sockfs_delete_dentry
+c027e6d7 t sock_no_open
+c027e6dd t sock_sendpage
+c027e71f t sock_poll
+c027e730 t sock_mmap
+c027e741 t sock_pernet_init
+c027e74e T kernel_bind
+c027e757 T kernel_listen
+c027e75e T kernel_connect
+c027e774 T kernel_getsockname
+c027e788 T kernel_getpeername
+c027e79c t sockfs_get_sb
+c027e7b3 t sock_destroy_inode
+c027e7c0 t sock_alloc_inode
+c027e80e t init_once
+c027e816 T kernel_sendpage
+c027e85c T socket_seq_show
+c027e8b6 T sock_unregister
+c027e8fd T sock_register
+c027e972 T move_addr_to_kernel
+c027e9a0 t sock_aio_dtor
+c027e9a8 t alloc_sock_iocb
+c027e9db t sock_aio_write
+c027eb64 t sock_aio_read
+c027eca1 t sock_fasync
+c027edb7 t sock_ioctl
+c027ef91 T dlci_ioctl_set
+c027efaf T vlan_ioctl_set
+c027efcd T brioctl_set
+c027efeb t sockfd_lookup_light
+c027f030 T sys_shutdown
+c027f075 T sys_getsockopt
+c027f0f5 T sys_setsockopt
+c027f17e T sys_connect
+c027f21a T sys_listen
+c027f274 T sys_bind
+c027f303 t sock_alloc
+c027f34f t sock_alloc_fd
+c027f382 t sock_attach_fd
+c027f437 T sock_map_fd
+c027f481 t sockfs_dname
+c027f4ac T sock_wake_async
+c027f505 T sock_recvmsg
+c027f655 T sock_sendmsg
+c027f7e5 T sys_sendmsg
+c027f9de T sys_sendto
+c027fb1a T sys_send
+c027fb55 T __sock_recv_timestamp
+c027fbf9 T sock_release
+c027fc58 t __sock_create
+c027fe17 T sock_create_kern
+c027fe43 T sock_create
+c027fe7d T sys_socketpair
+c027fff2 T sys_socket
+c028003a t sock_close
+c0280069 T sock_create_lite
+c028008c T kernel_accept
+c02800e0 T sockfd_lookup
+c028011c T move_addr_to_user
+c028016c T sys_recvmsg
+c028033b T sys_recvfrom
+c0280469 T sys_recv
+c02804a4 T sys_getpeername
+c0280546 T sys_getsockname
+c02805e8 T sys_accept
+c0280795 T sys_socketcall
+c02809d7 T kernel_sendmsg
+c0280a0c T kernel_recvmsg
+c0280a4c T kernel_getsockopt
+c0280ab0 T kernel_setsockopt
+c0280b14 T kernel_sock_ioctl
+c0280b3c T sock_no_bind
+c0280b42 T sock_no_connect
+c0280b48 T sock_no_socketpair
+c0280b4e T sock_no_accept
+c0280b54 T sock_no_getname
+c0280b5a T sock_no_poll
+c0280b5d T sock_no_ioctl
+c0280b63 T sock_no_listen
+c0280b69 T sock_no_shutdown
+c0280b6f T sock_no_setsockopt
+c0280b75 T sock_no_getsockopt
+c0280b7b T sock_no_sendmsg
+c0280b81 T sock_no_recvmsg
+c0280b87 T sock_no_mmap
+c0280b8d T sock_common_getsockopt
+c0280baf T sock_common_recvmsg
+c0280c03 T sock_common_setsockopt
+c0280c25 t proto_seq_next
+c0280c4e t proto_seq_open
+c0280c5a t proto_seq_show
+c0280fef t proto_seq_stop
+c0280ff9 t proto_seq_start
+c0281053 T sock_i_ino
+c028107f T proto_unregister
+c0281120 t sock_def_destruct
+c028112b T sock_kfree_s
+c0281142 t sk_filter_rcu_free
+c028114a t sock_warn_obsolete_bsdism
+c02811b7 T sock_enable_timestamp
+c02811d1 T sock_get_timestampns
+c028124e T release_sock
+c02812e2 T lock_sock_nested
+c0281380 T sk_stop_timer
+c0281399 T sk_reset_timer
+c02813af T sk_send_sigurg
+c02813f1 T sock_no_sendpage
+c028145a T sock_rmalloc
+c02814ab T sock_alloc_send_skb
+c0281650 T sk_setup_caps
+c02816f2 T sk_alloc
+c02817eb T sk_free
+c0281910 T sk_common_release
+c02819a4 t sock_set_timeout
+c0281a81 T sock_rfree
+c0281a94 t sock_def_wakeup
+c0281ad6 T sk_wait_data
+c0281b79 T sock_i_uid
+c0281ba5 T sock_getsockopt
+c0281ee0 T sock_get_timestamp
+c0281f5d T sock_kmalloc
+c0281f9b T proto_register
+c0282168 T sock_setsockopt
+c02826af T sk_clone
+c028297e T sock_init_data
+c0282bd2 t sock_def_error_report
+c0282c35 t sock_def_readable
+c0282c9b t sock_def_write_space
+c0282d29 T sock_wmalloc
+c0282d81 T sk_dst_check
+c0282e7d T __sk_dst_check
+c0282ee8 T sk_receive_skb
+c0282fc9 T sock_wfree
+c0283002 T sock_queue_rcv_skb
+c02830dc T reqsk_queue_destroy
+c028318d T reqsk_queue_alloc
+c0283248 t copy_skb_header
+c02833b4 T skb_prepare_seq_read
+c02833db T skb_find_text
+c0283443 T skb_to_sgvec
+c0283648 T skb_truesize_bug
+c0283674 T skb_under_panic
+c02836d1 T skb_over_panic
+c028372e T skb_pull_rcsum
+c028379b T skb_abort_seq_read
+c02837b2 t skb_ts_finish
+c02837ba T skb_seq_read
+c028390e t skb_ts_get_next_block
+c028391a T skb_checksum
+c0283bbf T skb_store_bits
+c0283dc9 T skb_copy_bits
+c0283fdf T skb_insert
+c0284010 T skb_append
+c0284040 T skb_unlink
+c0284077 T skb_queue_tail
+c02840a4 T skb_queue_head
+c02840d0 T skb_dequeue_tail
+c0284119 T skb_dequeue
+c0284158 T skb_copy_and_csum_bits
+c0284459 T skb_clone
+c0284643 T kfree_skbmem
+c02846a6 T __kfree_skb
+c028477f T kfree_skb
+c02847ac T skb_queue_purge
+c02847c3 t skb_drop_list
+c02847df t skb_release_data
+c0284860 T pskb_expand_head
+c0284993 T __pskb_pull_tail
+c0284bc3 T ___pskb_trim
+c0284d7a T __alloc_skb
+c0284e82 T skb_copy_expand
+c0284f3f T pskb_copy
+c02850c7 T skb_copy
+c0285187 T skb_append_datato_frags
+c02852d5 T skb_split
+c02854fb T skb_realloc_headroom
+c028555e T skb_pad
+c028566e T skb_cow_data
+c028587c T __netdev_alloc_skb
+c02858b1 T skb_segment
+c0285c79 T skb_copy_and_csum_dev
+c0285d30 T memcpy_fromiovecend
+c0285d84 T memcpy_fromiovec
+c0285dce T csum_partial_copy_fromiovecend
+c0285f99 T memcpy_toiovec
+c0285fe3 T verify_iovec
+c0286050 t skb_copy_and_csum_datagram
+c02863bc T __skb_checksum_complete_head
+c028640d T __skb_checksum_complete
+c0286419 T skb_copy_datagram_iovec
+c02865f5 T skb_copy_and_csum_datagram_iovec
+c02866c4 T skb_kill_datagram
+c0286729 T skb_free_datagram
+c0286730 T datagram_poll
+c02867ed T skb_recv_datagram
+c02869a4 T __sk_stream_mem_reclaim
+c02869f1 T sk_stream_error
+c0286a39 T sk_stream_write_space
+c0286aba T sk_stream_rfree
+c0286af4 T sk_stream_wait_memory
+c0286c7e T sk_stream_mem_schedule
+c0286dc4 T sk_stream_kill_queues
+c0286ed6 T sk_stream_wait_connect
+c0287000 T sk_stream_wait_close
+c02870a8 T scm_fp_dup
+c02870ed T put_cmsg
+c028716c T __scm_destroy
+c02871a0 T __scm_send
+c02873c2 T scm_detach_fds
+c02874c4 T gnet_stats_start_copy_compat
+c028755b T gnet_stats_start_copy
+c028757e T gnet_stats_copy_basic
+c02875e6 T gnet_stats_copy_rate_est
+c0287644 T gnet_stats_copy_queue
+c02876ae T gnet_stats_copy_app
+c028770f T gnet_stats_finish_copy
+c02877bc T gen_kill_estimator
+c0287857 t __gen_kill_estimator
+c028785f T gen_new_estimator
+c028798a T gen_replace_estimator
+c02879b0 t est_timer
+c0287acc t setup_net
+c0287b32 T net_lock
+c0287b3c T net_unlock
+c0287b46 t unregister_pernet_operations
+c0287b7a T unregister_pernet_device
+c0287ba8 T unregister_pernet_subsys
+c0287bc7 t register_pernet_operations
+c0287c45 T register_pernet_device
+c0287c8b T register_pernet_subsys
+c0287cb4 t net_free
+c0287ce5 T __put_net
+c0287d04 t cleanup_net
+c0287d66 T copy_net_ns
+c0287e0c T __dev_get_by_name
+c0287e9d T __dev_get_by_index
+c0287ec9 T dev_valid_name
+c0287f3e T net_enable_timestamp
+c0287f46 T net_disable_timestamp
+c0287f4e T register_gifconf
+c0287f64 t softnet_seq_stop
+c0287f65 t ptype_get_idx
+c0288019 t ptype_seq_start
+c0288035 t ptype_seq_stop
+c0288036 T dev_get_flags
+c028808f t dev_new_index
+c02880bc t internal_stats
+c02880c0 T netdev_compute_features
+c0288114 t netdev_exit
+c028812e t softnet_get_online
+c0288175 t softnet_seq_next
+c0288180 t softnet_seq_start
+c0288184 t ptype_seq_open
+c0288190 t softnet_seq_open
+c028819c t dev_seq_open
+c02881ce t softnet_seq_show
+c028822a t ptype_seq_show
+c028835c t dev_seq_release
+c0288387 t dev_seq_show
+c0288484 t net_dma_rebalance
+c02885b3 t netdev_dma_event
+c0288638 T __netif_rx_schedule
+c028869c T __dev_getfirstbyhwtype
+c028870c t __dev_alloc_name
+c02888a1 t unlist_netdevice
+c028893f t list_netdevice
+c0288a31 T dev_set_mac_address
+c0288a7f T dev_set_mtu
+c0288ad8 T call_netdevice_notifiers
+c0288ae6 T netdev_features_change
+c0288af7 T synchronize_net
+c0288b0b T free_netdev
+c0288b45 T alloc_netdev
+c0288bd6 T register_netdevice
+c0288e88 t dev_gso_skb_destructor
+c0288eae t default_rebuild_header
+c0288ee1 T dev_seq_start
+c0288f5d T dev_seq_stop
+c0288f67 T dev_set_allmulti
+c0288faa T dev_set_promiscuity
+c028901b T dev_change_flags
+c0289118 T netdev_set_master
+c02891c0 T netdev_state_change
+c02891ee T netif_receive_skb
+c0289392 T netif_rx
+c0289457 T netif_rx_ni
+c0289481 T netdev_rx_csum_fault
+c02894b6 T skb_gso_segment
+c028961e T dev_hard_start_xmit
+c0289845 T skb_checksum_help
+c028990c T __netif_schedule
+c0289941 T netif_device_attach
+c0289974 T dev_kfree_skb_any
+c02899cd T unregister_netdevice_notifier
+c02899ec T dev_close
+c0289a53 T dev_change_net_namespace
+c0289be8 T unregister_netdevice
+c0289d3e t default_device_exit
+c0289db7 T unregister_netdev
+c0289dcc T dev_load
+c0289e1b T dev_alloc_name
+c0289e55 T register_netdev
+c0289e9e T dev_change_name
+c028a062 t dev_ifsioc
+c028a3f8 T netdev_boot_base
+c028a46c T __dev_remove_pack
+c028a4e4 T dev_remove_pack
+c028a4ee T dev_open
+c028a556 t ptype_seq_next
+c028a5c3 t net_tx_action
+c028a693 T dev_ioctl
+c028ab53 T netdev_boot_setup_check
+c028abc0 T dev_getbyhwaddr
+c028ac45 T register_netdevice_notifier
+c028acd5 T dev_add_pack
+c028ad36 T dev_seq_next
+c028ad7c T netdev_run_todo
+c028af75 T netif_device_detach
+c028af91 t process_backlog
+c028b05d t net_rx_action
+c028b17e T dev_get_by_name
+c028b1b3 T dev_get_by_index
+c028b1e8 T dev_getfirstbyhwtype
+c028b214 T dev_get_by_flags
+c028b276 t netdev_init
+c028b321 t dev_proc_net_exit
+c028b351 t dev_proc_net_init
+c028b3ed T dev_queue_xmit
+c028b650 T ethtool_op_get_link
+c028b65c T ethtool_op_get_tx_csum
+c028b667 T ethtool_op_set_tx_csum
+c028b678 T ethtool_op_set_tx_hw_csum
+c028b689 T ethtool_op_get_sg
+c028b690 T ethtool_op_set_sg
+c028b6a1 T ethtool_op_get_tso
+c028b6a9 T ethtool_op_set_tso
+c028b6c0 T ethtool_op_get_ufo
+c028b6ca T ethtool_op_set_ufo
+c028b6e1 t __ethtool_set_sg
+c028b732 T ethtool_op_get_perm_addr
+c028b771 t ethtool_get_eeprom
+c028b862 t ethtool_get_regs
+c028b919 T dev_ethtool
+c028c3c4 t __dev_mc_upload
+c028c3e5 t dev_mc_seq_next
+c028c406 t dev_mc_net_exit
+c028c413 t dev_mc_seq_release
+c028c43e t dev_mc_seq_open
+c028c470 t dev_mc_seq_show
+c028c51c t dev_mc_seq_stop
+c028c526 t dev_mc_seq_start
+c028c581 t dev_mc_net_init
+c028c5a5 T dev_mc_upload
+c028c5dc T dev_mc_delete
+c028c692 T dev_mc_add
+c028c7dc T dev_mc_discard
+c028c850 t ___dst_free
+c028c875 t dst_dev_event
+c028c943 t dst_discard
+c028c94b T dst_destroy
+c028c9fa T __dst_free
+c028ca5d t dst_run_gc
+c028cb8d T dst_alloc
+c028cbec T call_netevent_notifiers
+c028cbfa T unregister_netevent_notifier
+c028cc06 T register_netevent_notifier
+c028cc14 t neigh_get_next
+c028cca1 t neigh_get_idx
+c028cd7e t pneigh_get_first
+c028cdb2 t pneigh_get_next
+c028cdfc t neigh_stat_seq_stop
+c028cdfd T neigh_seq_start
+c028ce97 T neigh_seq_next
+c028ceee T neigh_seq_stop
+c028cefe T neigh_for_each
+c028cf51 t neigh_stat_seq_next
+c028cf90 t neigh_dump_info
+c028d342 t neightbl_fill_parms
+c028d661 T neigh_sysctl_unregister
+c028d68c T neigh_parms_destroy
+c028d699 t neigh_rcu_free_parms
+c028d6af T neigh_sysctl_register
+c028d8ab T neigh_connected_output
+c028d948 t neigh_blackhole
+c028d953 t pneigh_queue_purge
+c028d979 t neigh_hash_free
+c028d99c t neigh_stat_seq_open
+c028d9c5 t neigh_stat_seq_show
+c028da4e t neigh_hash_alloc
+c028da78 T __neigh_event_send
+c028dba3 T pneigh_enqueue
+c028dc9c T neigh_rand_reach_time
+c028dcb5 T neigh_table_init_no_netlink
+c028de81 T neigh_table_init
+c028dee6 T neigh_parms_alloc
+c028dfb2 T neigh_parms_alloc_default
+c028dfe3 T pneigh_delete
+c028e0ab T neigh_lookup
+c028e148 T neigh_destroy
+c028e242 t neigh_del_timer
+c028e27d T neigh_update
+c028e5e8 t neigh_flush_dev
+c028e6a4 T neigh_ifdown
+c028e74d T neigh_table_clear
+c028e80a T neigh_changeaddr
+c028e831 T neigh_create
+c028ec5e T neigh_event_ns
+c028ecd4 T __neigh_for_each_release
+c028ed64 T pneigh_lookup
+c028eed8 t neigh_stat_seq_start
+c028ef2c T neigh_lookup_nodev
+c028efd0 t neigh_proxy_process
+c028f08c T neigh_parms_release
+c028f10a t neightbl_dump_info
+c028f720 t neightbl_set
+c028f9ee T neigh_compat_output
+c028fa76 T neigh_resolve_output
+c028fc9a t neigh_periodic_timer
+c028fdec t neigh_delete
+c028ff23 t neigh_add
+c0290161 t neigh_timer_handler
+c02903e4 t rtnl_link_ops_get
+c0290420 t rtnl_link_get_size
+c0290469 t rtnetlink_net_exit
+c0290496 t rtnetlink_net_init
+c02904ed T rtnl_lock
+c02904f7 T __rtnl_unlock
+c0290501 t rtnetlink_rcv
+c029053e T rtattr_parse
+c02905a5 t rtnetlink_rcv_msg
+c029075b t set_operstate
+c02907ba t do_setlink
+c0290a35 T rtnl_unregister_all
+c0290a5a T rtnl_unregister
+c0290a9f t rtnl_fill_ifinfo
+c029107a t rtnl_dump_ifinfo
+c029113e T rtnl_put_cacheinfo
+c02911d1 T rtnl_set_sk_err
+c02911e8 T rtnl_notify
+c029122d T rtmsg_ifinfo
+c0291352 t rtnetlink_event
+c0291394 T rtnl_unicast
+c02913ba t rtnl_getlink
+c02914f9 T rtnetlink_send
+c0291566 T __rtnl_link_unregister
+c029156b T __rtnl_link_register
+c029157e T __rtnl_register
+c02915e0 T rtnl_register
+c0291615 T rtnl_trylock
+c029161f T rtnl_unlock
+c0291674 T rtnl_link_unregister
+c0291689 T rtnl_link_register
+c02916a3 T __rtattr_parse_nested_compat
+c029170b T __rta_fill
+c02917ae T rtattr_strlcpy
+c0291830 t rtnl_dump_all
+c02918b9 t rtnl_setlink
+c02919b0 t rtnl_dellink
+c0291a4a t rtnl_newlink
+c0291e8b T rtnetlink_put_metrics
+c0291fc8 T in4_pton
+c0292106 T in6_pton
+c02923db T in_aton
+c029242b T net_ratelimit
+c029243c t linkwatch_urgent_event
+c0292462 t linkwatch_add_event
+c029248e t linkwatch_schedule_work
+c029250e T linkwatch_fire_event
+c0292545 t __linkwatch_run_queue
+c02926c1 t linkwatch_event
+c02926e3 T linkwatch_run_queue
+c02926ec t __load_pointer
+c029272d T sk_chk_filter
+c029292c T sk_attach_filter
+c0292a11 t sk_filter_rcu_free
+c0292a19 T sk_run_filter
+c0292fd8 t flow_cache_flush_tasklet
+c029304a T flow_cache_flush
+c02930be t flow_cache_flush_per_cpu
+c02930e8 t __flow_cache_shrink
+c0293169 T flow_cache_lookup
+c029349a t flow_cache_new_hashrnd
+c02934f4 t change_tx_queue_len
+c02934fd t change_weight
+c0293506 t net_current_tag
+c0293516 t net_kobject_tag
+c029351d T netdev_sysfs_init
+c0293527 t netdev_store
+c0293589 t store_weight
+c02935a5 t store_tx_queue_len
+c02935c1 t store_flags
+c02935dd t store_mtu
+c02935f9 t wireless_show
+c029364f t show_iw_beacon
+c0293658 t show_iw_retries
+c0293661 t show_iw_misc
+c029366a t show_iw_fragment
+c0293673 t show_iw_crypt
+c029367f t show_iw_nwid
+c029368b t show_iw_noise
+c0293697 t show_iw_level
+c02936a3 t show_iw_link
+c02936af t show_iw_status
+c02936bb t netdev_show
+c02936f8 t show_weight
+c0293709 t show_tx_queue_len
+c029371a t show_flags
+c029372b t show_mtu
+c029373c t show_link_mode
+c029374d t show_type
+c029375e t show_features
+c029376f t show_ifindex
+c0293780 t show_iflink
+c0293791 t show_addr_len
+c02937a2 t format_iw_beacon
+c02937c0 t format_iw_retries
+c02937de t format_iw_misc
+c02937fc t format_iw_fragment
+c029381a t format_iw_crypt
+c0293838 t format_iw_nwid
+c0293856 t format_iw_noise
+c0293875 t format_iw_level
+c0293894 t format_iw_link
+c02938b3 t format_iw_status
+c02938d1 t format_weight
+c02938f2 t format_tx_queue_len
+c0293913 t format_flags
+c0293934 t format_mtu
+c0293955 t show_operstate
+c02939c8 t format_addr
+c0293a22 t show_broadcast
+c0293a4d t format_link_mode
+c0293a6f t format_type
+c0293a91 t format_features
+c0293aaf t format_ifindex
+c0293acd t format_iflink
+c0293aeb t format_addr_len
+c0293b0d t change_flags
+c0293b12 t change_mtu
+c0293b17 t netdev_release
+c0293b3a t netdev_uevent
+c0293be7 T netdev_register_sysfs
+c0293c5d t netstat_show
+c0293cfa t show_tx_compressed
+c0293d0b t show_rx_compressed
+c0293d1c t show_tx_window_errors
+c0293d2d t show_tx_heartbeat_errors
+c0293d3e t show_tx_fifo_errors
+c0293d4f t show_tx_carrier_errors
+c0293d60 t show_tx_aborted_errors
+c0293d71 t show_rx_missed_errors
+c0293d82 t show_rx_fifo_errors
+c0293d93 t show_rx_frame_errors
+c0293da4 t show_rx_crc_errors
+c0293db5 t show_rx_over_errors
+c0293dc6 t show_rx_length_errors
+c0293dd7 t show_collisions
+c0293de8 t show_multicast
+c0293df9 t show_tx_dropped
+c0293e0a t show_rx_dropped
+c0293e1b t show_tx_errors
+c0293e2c t show_rx_errors
+c0293e3d t show_tx_bytes
+c0293e4e t show_rx_bytes
+c0293e5f t show_tx_packets
+c0293e70 t show_rx_packets
+c0293e81 T netdev_unregister_sysfs
+c0293e9a t show_carrier
+c0293edc t show_dormant
+c0293f1c t show_address
+c0293f6c T dma_skb_copy_datagram_iovec
+c0294164 t flush_route_cache
+c029416e t validate_rulemsg
+c02941d8 t lookup_rules_ops
+c029422b t fib_rules_net_init
+c0294251 t fib_nl_fill_rule
+c029448b t rules_ops_put
+c0294498 t dump_rules
+c029450d t notify_rule_change
+c0294613 t fib_rule_put_rcu
+c029461b T fib_rules_register
+c02946af t fib_nl_dumprule
+c0294767 t fib_rules_event
+c0294862 T fib_rules_unregister
+c0294915 t fib_nl_delrule
+c0294b26 T fib_rules_lookup
+c0294bc0 t fib_nl_newrule
+c0294e94 t eth_change_mtu
+c0294eb2 T ether_setup
+c0294f46 T alloc_etherdev
+c0294f55 t eth_mac_addr
+c0294f8c T eth_rebuild_header
+c0294fee t eth_header_parse
+c0295009 T eth_header_cache
+c0295086 T eth_header_cache_update
+c02950aa T eth_header
+c0295199 T eth_type_trans
+c0295290 t noop_dequeue
+c0295293 t pfifo_fast_requeue
+c02952ca T qdisc_reset
+c02952db t noop_requeue
+c029530d t noop_enqueue
+c0295318 T __netdev_watchdog_up
+c0295361 T qdisc_lock_tree
+c029537d T qdisc_unlock_tree
+c0295399 T dev_init_scheduler
+c02953e8 T dev_deactivate
+c0295485 t pfifo_fast_dump
+c02954ec t pfifo_fast_init
+c0295526 T qdisc_destroy
+c0295581 T dev_shutdown
+c02955e3 t __qdisc_destroy
+c02955ee T qdisc_alloc
+c029566f T qdisc_create_dflt
+c02956b4 T dev_activate
+c029575a T netif_carrier_off
+c0295770 T netif_carrier_on
+c0295797 T __qdisc_run
+c0295902 t dev_watchdog
+c02959bd t pfifo_fast_dequeue
+c0295a09 t pfifo_fast_reset
+c0295a38 t pfifo_fast_enqueue
+c0295aa0 T qdisc_lookup
+c0295ad6 t qdisc_leaf
+c0295b0c T qdisc_tree_decrease_qlen
+c0295b5b t check_loop
+c0295bad t check_loop_fn
+c0295bdb T tc_classify
+c0295c15 t psched_open
+c0295c2b t psched_show
+c0295c64 t tc_dump_tclass
+c0295d8c t tc_fill_tclass
+c0295f51 t qdisc_class_dump
+c0295f93 t tclass_notify
+c029603f t tc_ctl_tclass
+c029624f t tc_fill_qdisc
+c029641b t qdisc_notify
+c0296517 t qdisc_lookup_ops
+c0296597 t dev_graft_qdisc
+c0296632 t qdisc_graft
+c02966b5 T tcf_destroy
+c02966d1 T tcf_destroy_chain
+c02966e3 T qdisc_put_rtab
+c0296724 t qdisc_create
+c02968ad T qdisc_watchdog_cancel
+c02968be T qdisc_watchdog_schedule
+c02968df T qdisc_watchdog_init
+c02968fe t qdisc_watchdog
+c0296919 T qdisc_get_rtab
+c02969b1 T unregister_qdisc
+c02969f4 T register_qdisc
+c0296a77 t tc_dump_qdisc
+c0296b81 t tc_get_qdisc
+c0296d4a t tc_modify_qdisc
+c02970fc t blackhole_dequeue
+c02970ff t blackhole_enqueue
+c0297110 T tcf_exts_destroy
+c0297111 T tcf_exts_validate
+c0297139 T tcf_exts_change
+c029713a T tcf_exts_dump
+c029713d T tcf_exts_dump_stats
+c0297140 t tcf_fill_node
+c02972c1 t tcf_node_dump
+c0297303 t tcf_proto_lookup_ops
+c0297383 t tfilter_notify
+c029742f t tc_ctl_tfilter
+c0297894 T unregister_tcf_proto_ops
+c02978d1 T register_tcf_proto_ops
+c029792a t tc_dump_tfilter
+c0297b3c t qdisc_requeue
+c0297b5e t qdisc_dequeue_head
+c0297b95 t qdisc_queue_drop
+c0297bd8 t fifo_dump
+c0297c23 t qdisc_reset_queue
+c0297c37 t pfifo_enqueue
+c0297c83 t fifo_init
+c0297cd1 t bfifo_enqueue
+c0297d20 t nl_pid_hashfn
+c0297d96 t netlink_update_listeners
+c0297de3 t netlink_update_subscriptions
+c0297e3c t netlink_overrun
+c0297e60 T netlink_set_nonroot
+c0297e74 t netlink_seq_socket_idx
+c0297f17 t netlink_net_exit
+c0297f24 t netlink_seq_release
+c0297f51 t netlink_seq_show
+c0297fd8 t netlink_seq_stop
+c0297fe2 t netlink_seq_start
+c0298018 T netlink_set_err
+c02980a3 t netlink_seq_open
+c02980fe t netlink_net_init
+c0298122 t netlink_queue_skip
+c0298147 t netlink_alloc_groups
+c02981e1 t __netlink_create
+c029826f t netlink_destroy_callback
+c0298285 t netlink_dump
+c02983e9 t netlink_table_grab
+c0298477 T netlink_sendskb
+c02984aa t nl_pid_hash_rehash
+c02985e9 t netlink_insert
+c0298702 t netlink_autobind
+c02987ee T netlink_unregister_notifier
+c02987fa T netlink_register_notifier
+c0298806 T netlink_broadcast
+c0298ab6 T netlink_attachskb
+c0298bf8 T netlink_unicast
+c0298dc0 T netlink_ack
+c0298f5d T nlmsg_notify
+c0298fc4 T netlink_getsockbyfilp
+c0298ff6 T netlink_run_queue
+c02990d1 t netlink_seq_next
+c0299179 t netlink_sock_destruct
+c0299253 T netlink_has_listeners
+c0299280 t netlink_getsockopt
+c02992ec t netlink_sendmsg
+c0299533 t netlink_data_ready
+c0299585 T netlink_kernel_create
+c02996c2 t netlink_recvmsg
+c02998f5 t netlink_create
+c0299a43 t netlink_connect
+c0299ae1 t netlink_bind
+c0299c0b t netlink_setsockopt
+c0299d46 t netlink_release
+c0299f46 T netlink_detachskb
+c0299f65 T netlink_dump_start
+c029a09c t netlink_getname
+c029a0f8 T nla_find
+c029a12f t validate_nla
+c029a21f T __nla_reserve_nohdr
+c029a27a T __nla_put_nohdr
+c029a29c T nla_put_nohdr
+c029a2d9 T __nla_reserve
+c029a352 T __nla_put
+c029a377 T nla_strcmp
+c029a39f T nla_reserve_nohdr
+c029a3d0 T nla_put
+c029a418 T nla_reserve
+c029a44c T nla_strlcpy
+c029a4ce T nla_memcpy
+c029a4f3 T nla_memcmp
+c029a50b T nla_validate
+c029a552 T nla_parse
+c029a600 t genl_family_find_byid
+c029a637 t genl_family_find_byname
+c029a691 t genl_get_cmd
+c029a6c8 t genl_lock
+c029a6d2 t ctrl_fill_info
+c029aa0d t genl_unlock
+c029aa35 t ctrl_build_msg
+c029aaa7 t ctrl_getfamily
+c029ab1f t genl_rcv
+c029ab68 t genl_ctrl_event
+c029abc5 T genl_unregister_family
+c029ac5a T genl_register_family
+c029ad69 T genl_register_ops
+c029addc T genl_unregister_ops
+c029ae32 t genl_rcv_msg
+c029af85 t ctrl_dumpfamily
+c029b060 T nf_iterate
+c029b0ca T nf_ct_attach
+c029b0dd t netfilter_proc_exit
+c029b0ea t netfilter_proc_init
+c029b112 T nf_conntrack_destroy
+c029b123 T skb_make_writable
+c029b1ee T nf_hook_slow
+c029b2a3 T nf_unregister_hook
+c029b2d1 T nf_unregister_hooks
+c029b2ef T nf_register_hook
+c029b34d T nf_register_hooks
+c029b38e T nf_register_afinfo
+c029b3b7 T nf_unregister_afinfo
+c029b3e2 T nf_proto_csum_replace4
+c029b4a8 t seq_start
+c029b4ba t seq_next
+c029b4db t seq_stop
+c029b4dc t nflog_open
+c029b4e8 t seq_show
+c029b53c T nf_log_packet
+c029b5d7 T nf_log_unregister
+c029b610 T nf_log_unregister_pf
+c029b63f T nf_log_register
+c029b690 t seq_start
+c029b6a2 t seq_next
+c029b6c3 t seq_stop
+c029b6c4 t nfqueue_open
+c029b6d0 t seq_show
+c029b740 t __nf_queue
+c029b8ab T nf_queue
+c029b983 T nf_unregister_queue_handlers
+c029b9b7 T nf_unregister_queue_handler
+c029b9e7 T nf_register_queue_handler
+c029ba32 T nf_reinject
+c029bb80 t nf_sockopt
+c029bc62 T nf_getsockopt
+c029bc87 T nf_setsockopt
+c029bcac T nf_unregister_sockopt
+c029bcf8 T nf_register_sockopt
+c029bd74 t path_free
+c029bd8f T nf_unregister_sysctl_table
+c029bda2 T nf_register_sysctl_table
+c029be18 t rt_hash_code
+c029be8f t rt_cpu_seq_stop
+c029be90 t rt_may_expire
+c029befe t ipv4_dst_check
+c029bf01 t set_class_tag
+c029bf28 t ipv4_rt_blackhole_update_pmtu
+c029bf29 t ipv4_link_failure
+c029bf6d t rt_del
+c029c014 t ipv4_negative_advice
+c029c09b t dst_rcu_free
+c029c0ba t ipv4_dst_ifdown
+c029c103 t ip_handle_martian_source
+c029c214 t rt_garbage_collect
+c029c489 t rt_run_flush
+c029c515 t ip_rt_net_exit
+c029c547 t ip_rt_net_init
+c029c5b7 t rt_cpu_seq_open
+c029c5c3 t rt_cpu_seq_show
+c029c670 t rt_cpu_seq_next
+c029c6a8 t rt_cache_seq_release
+c029c6d5 t fib_rule_put_rcu
+c029c6dd t rt_cache_seq_stop
+c029c6e8 t rt_cache_get_next
+c029c71e t rt_cache_get_first
+c029c752 t rt_cache_seq_next
+c029c76f t rt_cache_seq_start
+c029c7b8 t ip_rt_acct_read
+c029c88d t ipv4_blackhole_output
+c029c895 t ip_error
+c029c91d t rt_fill_info
+c029cc7a t rt_check_expire
+c029cdd2 t rt_set_nexthop
+c029ced6 t rt_intern_hash
+c029d21e T __ip_route_output_key
+c029d926 T ip_route_output_flow
+c029db15 T ip_route_output_key
+c029db28 T ip_route_input
+c029e783 T rt_bind_peer
+c029e7db T rt_cache_flush
+c029e888 t ipv4_sysctl_rtcache_flush_strategy
+c029e8b4 t ipv4_sysctl_rtcache_flush
+c029e8f2 T ip_rt_multicast_event
+c029e8f9 t rt_secret_rebuild
+c029e91a t rt_cpu_seq_start
+c029e96b T __ip_select_ident
+c029ea23 T ip_rt_get_source
+c029eac8 t inet_rtm_getroute
+c029ece6 t rt_cache_seq_show
+c029ee57 T ip_rt_frag_needed
+c029efff t ip_rt_update_pmtu
+c029f05a t ip_rt_bug
+c029f0d9 T ip_rt_dump
+c029f23f T ip_rt_redirect
+c029f86b T ip_rt_send_redirect
+c029fa12 t ipv4_dst_destroy
+c029fa64 t rt_cache_seq_open
+c029facc t peer_avl_rebalance
+c029fc21 T inet_putpeer
+c029fc74 t unlink_from_unused
+c029fcbf t cleanup_once
+c029fe36 t inet_peers_net_exit
+c029fe40 t peer_check_expire
+c029ff1f T inet_getpeer
+c02a0094 t inet_peers_net_init
+c02a017c T inet_add_protocol
+c02a01b4 T inet_del_protocol
+c02a01f4 t ip_rcv_finish
+c02a049c t ip_local_deliver_finish
+c02a062b T ip_call_ra_chain
+c02a06f2 T ip_rcv
+c02a0bc3 T ip_local_deliver
+c02a0dd4 t ipqhashfn
+c02a0e59 T ipfrag_init
+c02a0e63 t ipq_kill
+c02a0ec6 t ip_frag_destroy
+c02a0f86 t ip_evictor
+c02a1035 t ipfrag_net_exit
+c02a106b t ipfrag_net_init
+c02a1166 t ipfrag_secret_rebuild
+c02a123b T ip_defrag
+c02a1c7d t ip_expire
+c02a1d2c t ip_forward_finish
+c02a1d5a T ip_forward
+c02a2020 t ip_options_get_alloc
+c02a2049 T ip_options_compile
+c02a24df t ip_options_get_finish
+c02a252a T ip_options_get_from_user
+c02a257c T ip_options_get
+c02a25c1 T ip_options_undo
+c02a2664 T ip_options_build
+c02a27c3 T ip_options_fragment
+c02a282c T ip_options_echo
+c02a2b1f T ip_forward_options
+c02a2c76 T ip_options_rcv_srr
+c02a2e40 t dst_output
+c02a2e47 T ip_send_check
+c02a2e87 t ip_reply_glue_bits
+c02a2ef7 T ip_push_pending_frames
+c02a32ad T ip_append_data
+c02a3c20 t ip_copy_metadata
+c02a3d17 T ip_fragment
+c02a43e3 t ip_finish_output
+c02a4606 t ip_finish_output2
+c02a47d0 t ip_dev_loopback_xmit
+c02a484d T ip_generic_getfrag
+c02a48e3 T ip_append_page
+c02a4d09 T ip_send_reply
+c02a4f08 T ip_queue_xmit
+c02a526d T ip_flush_pending_frames
+c02a5317 T ip_build_and_send_pkt
+c02a5506 T ip_mc_output
+c02a58c7 T ip_output
+c02a5b84 T ip_getsockopt
+c02a60da T ip_ra_control
+c02a61cb T ip_cmsg_send
+c02a6260 T ip_cmsg_recv
+c02a63bd T ip_recv_error
+c02a657a T ip_local_error
+c02a66d1 T ip_setsockopt
+c02a710f T ip_icmp_error
+c02a722c T inet_bind_hash
+c02a7259 T inet_bind_bucket_destroy
+c02a727b T inet_put_port
+c02a72e6 t __inet_check_established
+c02a7601 T inet_listen_wlock
+c02a768b T inet_bind_bucket_create
+c02a76d5 T __inet_lookup_listener
+c02a7927 T inet_hash_connect
+c02a7db8 T inet_twsk_schedule
+c02a7f07 T inet_twsk_alloc
+c02a7fcb T __inet_twsk_kill
+c02a80ad T inet_twdr_twcal_tick
+c02a823e t inet_twdr_do_twkill_work
+c02a8330 T inet_twdr_twkill_work
+c02a83b9 T inet_twdr_hangman
+c02a844f T __inet_twsk_hashdance
+c02a853a T inet_twsk_deschedule
+c02a85f4 T inet_csk_ctl_sock_create
+c02a8642 T inet_csk_destroy_sock
+c02a876b T inet_csk_reset_keepalive_timer
+c02a877e T inet_csk_delete_keepalive_timer
+c02a8789 T inet_csk_listen_stop
+c02a88c8 T ipv4_rcv_saddr_equal
+c02a8a9f T inet_csk_bind_conflict
+c02a8b2b T inet_csk_route_req
+c02a8c4c T inet_csk_addr2sockaddr
+c02a8c65 T inet_csk_accept
+c02a8e6d T inet_csk_init_xmit_timers
+c02a8ed1 T inet_csk_clear_xmit_timers
+c02a8f0f T inet_csk_reqsk_queue_hash_add
+c02a9001 T inet_csk_reqsk_queue_prune
+c02a91c9 T inet_csk_clone
+c02a9223 T inet_csk_listen_start
+c02a9334 T inet_csk_get_port
+c02a951d T inet_csk_search_req
+c02a960c T tcp_enter_memory_pressure
+c02a9650 t tcp_net_init
+c02a967b t tcp_close_state
+c02a978c T tcp_done
+c02a987f T tcp_get_info
+c02a9a26 T tcp_getsockopt
+c02a9c6c T tcp_shutdown
+c02a9c97 t tcp_prequeue_process
+c02a9cf9 T tcp_cleanup_rbuf
+c02a9de7 T tcp_setsockopt
+c02aa0fa T tcp_poll
+c02aa220 T tcp_tso_segment
+c02aa45d T tcp_ioctl
+c02aa574 T tcp_sendpage
+c02aab29 T tcp_sendmsg
+c02ab54a T tcp_read_sock
+c02ab6bb T tcp_close
+c02abc07 T tcp_recvmsg
+c02ac610 T tcp_disconnect
+c02aca00 t tcp_incr_quickack
+c02aca47 T tcp_enter_quickack_mode
+c02aca62 t tcp_init_buffer_space
+c02acbb7 T tcp_initialize_rcv_mss
+c02acbfb t tcp_rcv_rtt_update
+c02acc3d T tcp_rcv_space_adjust
+c02acd4a t tcp_rtt_estimator
+c02ace45 T tcp_update_metrics
+c02acfb7 T tcp_init_cwnd
+c02acff2 T tcp_enter_cwr
+c02ad0a9 t tcp_init_metrics
+c02ad20d t tcp_update_reordering
+c02ad2ab T tcp_clear_retrans
+c02ad2f2 t tcp_check_reno_reordering
+c02ad342 t tcp_cwnd_down
+c02ad3d9 t tcp_undo_cwr
+c02ad4c3 t tcp_try_undo_recovery
+c02ad5cf t tcp_try_undo_dsack
+c02ad611 t tcp_ack_saw_tstamp
+c02ad654 t tcp_cong_avoid
+c02ad685 t tcp_ratehalving_spur_to_response
+c02ad68c t tcp_dsack_set
+c02ad712 t tcp_dsack_extend
+c02ad752 t tcp_check_space
+c02ad816 t tcp_disordered_ack
+c02ad8b1 t tcp_reset
+c02ad901 t tcp_send_dupack
+c02ad966 t tcp_mark_head_lost
+c02ada85 t tcp_add_reno_sack
+c02adad2 T tcp_enter_loss
+c02adce2 t tcp_enter_frto_loss
+c02adeb9 t tcp_sacktag_write_queue
+c02ae68e t tcp_ack
+c02afe82 t tcp_urg
+c02b000a t tcp_fin
+c02b01c3 t tcp_event_data_recv
+c02b0484 t tcp_collapse
+c02b07df t tcp_prune_queue
+c02b0a1a t tcp_data_queue
+c02b147c t __tcp_ack_snd_check
+c02b14e8 t __tcp_checksum_complete_user
+c02b1515 T tcp_parse_options
+c02b16fc t tcp_fast_parse_options
+c02b1761 T tcp_cwnd_application_limited
+c02b17e4 T tcp_enter_frto
+c02b19a9 T tcp_use_frto
+c02b1a04 T tcp_rcv_state_process
+c02b24d7 T tcp_rcv_established
+c02b2cb4 T tcp_select_initial_window
+c02b2da1 t tcp_set_skb_tso_segs
+c02b2e1e T tcp_mtu_to_mss
+c02b2e5c T tcp_mss_to_mtu
+c02b2e7f T tcp_mtup_init
+c02b2edb T tcp_sync_mss
+c02b2f4d T tcp_current_mss
+c02b3014 t tcp_window_allows
+c02b3032 t tcp_init_tso_segs
+c02b3073 t tcp_snd_test
+c02b314e T tcp_may_send_now
+c02b319f T __tcp_select_window
+c02b32ab t update_send_head
+c02b333b t tcp_syn_build_options
+c02b33a8 t tcp_transmit_skb
+c02b3a3a t tcp_xmit_probe_skb
+c02b3ae4 T tcp_send_ack
+c02b3bd3 t tcp_cwnd_validate
+c02b3c2b t __pskb_trim_head
+c02b3cf3 T tcp_trim_head
+c02b3da9 T tcp_fragment
+c02b41b3 T tcp_write_wakeup
+c02b42d0 T tcp_retransmit_skb
+c02b4856 T tcp_xmit_retransmit_queue
+c02b4ada t tso_fragment
+c02b4c7c T __tcp_push_pending_frames
+c02b544a T tcp_send_active_reset
+c02b552f T tcp_make_synack
+c02b5824 T tcp_send_delayed_ack
+c02b58dd T tcp_push_one
+c02b59ba T tcp_simple_retransmit
+c02b5b36 T tcp_connect
+c02b5e65 T tcp_send_probe0
+c02b5f2c T tcp_send_synack
+c02b609d T tcp_send_fin
+c02b61d4 t tcp_orphan_retries
+c02b61fc T tcp_init_xmit_timers
+c02b6217 t tcp_write_err
+c02b6258 t tcp_out_of_resources
+c02b6321 T tcp_set_keepalive
+c02b6361 t tcp_keepalive_timer
+c02b6513 t tcp_delack_timer
+c02b66a2 t tcp_write_timer
+c02b6ca0 t tcp_v4_get_port
+c02b6cbb t tcp_v4_hash
+c02b6e37 t tcp_v4_send_ack
+c02b6f8b t tcp_v4_send_reset
+c02b70c6 t tcp_v4_send_synack
+c02b71b9 T tcp4_proc_exit
+c02b71c3 t tcp4_seq_show
+c02b77f9 T tcp_proc_unregister
+c02b7825 t tcp4_proc_net_exit
+c02b782f T tcp_proc_register
+c02b789d t tcp4_proc_net_init
+c02b78a7 t tcp_seq_release
+c02b78d4 t tcp_seq_open
+c02b7968 t tcp_seq_stop
+c02b79d9 t established_get_next
+c02b7ae0 t established_get_first
+c02b7bb5 t listening_get_next
+c02b7d62 t tcp_get_idx
+c02b7e12 t tcp_seq_start
+c02b7e4a T tcp_v4_tw_remember_stamp
+c02b7e9c T tcp_v4_do_rcv
+c02b81ce T tcp_unhash
+c02b826c t tcp_v4_reqsk_destructor
+c02b8274 t tcp_v4_reqsk_send_ack
+c02b829f T tcp_v4_remember_stamp
+c02b8344 t tcp_v4_init_sock
+c02b8485 T tcp_twsk_unique
+c02b84e4 T tcp_v4_syn_recv_sock
+c02b87d1 T tcp_v4_send_check
+c02b8887 t tcp_seq_next
+c02b890a T tcp_v4_conn_request
+c02b8cb8 T tcp_v4_destroy_sock
+c02b8e26 T tcp_v4_connect
+c02b93d4 T tcp_v4_gso_send_check
+c02b9461 T tcp_v4_err
+c02b999a T tcp_v4_rcv
+c02ba28c T tcp_twsk_destructor
+c02ba28d T tcp_child_process
+c02ba313 T tcp_create_openreq_child
+c02ba689 T tcp_check_req
+c02ba970 T tcp_time_wait
+c02bab6b T tcp_timewait_state_process
+c02baf54 t tcp_ca_find
+c02baf90 T tcp_slow_start
+c02bb026 T tcp_reno_min_cwnd
+c02bb02f T tcp_get_default_congestion_control
+c02bb059 T tcp_set_allowed_congestion_control
+c02bb12d T tcp_unregister_congestion_control
+c02bb156 T tcp_register_congestion_control
+c02bb1eb T tcp_set_default_congestion_control
+c02bb27a T tcp_cleanup_congestion_control
+c02bb29d T tcp_set_congestion_control
+c02bb353 T tcp_get_available_congestion_control
+c02bb3b8 T tcp_get_allowed_congestion_control
+c02bb425 T tcp_reno_cong_avoid
+c02bb4f3 T tcp_reno_ssthresh
+c02bb507 T tcp_init_congestion_control
+c02bb56c T ip4_datagram_connect
+c02bb898 t dst_output
+c02bb89f T __raw_v4_lookup
+c02bb9db t raw_get_next
+c02bba2f t raw_get_first
+c02bba8e t raw_seq_next
+c02bbaab t raw_v4_unhash
+c02bbb2a t raw_rcv_skb
+c02bbb48 t raw_getsockopt
+c02bbbc6 t raw_setsockopt
+c02bbc21 t raw_ioctl
+c02bbc88 t raw_close
+c02bbc9c t raw_proc_net_exit
+c02bbca9 t raw_seq_release
+c02bbcd6 t raw_seq_show
+c02bbe5f t raw_seq_stop
+c02bbe69 t raw_seq_start
+c02bbebe t raw_seq_open
+c02bbf24 t raw_proc_net_init
+c02bbf4b T raw_rcv
+c02bc008 T raw_v4_input
+c02bc146 t raw_init
+c02bc15d t raw_v4_hash
+c02bc1bf t raw_bind
+c02bc379 t raw_recvmsg
+c02bc4f8 T raw_err
+c02bc5f2 t raw_sendmsg
+c02bcde0 t udp_lib_hash
+c02bcde4 T __udp_lib_get_port
+c02bcfd3 T udp_get_port
+c02bcff6 t udp_v4_get_port
+c02bd003 t udp_get_next
+c02bd058 t udp_get_idx
+c02bd0f1 t udp_seq_next
+c02bd112 t udp_lib_close
+c02bd117 T udp4_proc_exit
+c02bd121 T udp4_seq_show
+c02bd2cf T udp_proc_unregister
+c02bd2fb t udp4_proc_net_exit
+c02bd305 T udp_proc_register
+c02bd373 t udp4_proc_net_init
+c02bd37d t udp_seq_release
+c02bd3aa t udp_seq_open
+c02bd43c t udp_seq_stop
+c02bd446 t udp_seq_start
+c02bd47c t __udp4_lib_lookup
+c02bd62c T udp_poll
+c02bd707 T udp_lib_getsockopt
+c02bd79d T udp_getsockopt
+c02bd7de t udp_push_pending_frames
+c02bdab8 T udp_lib_setsockopt
+c02bdba2 T udp_setsockopt
+c02bdbec t udp_flush_pending_frames
+c02bdc0e T udp_destroy_sock
+c02bdc2a T udp_queue_rcv_skb
+c02bdf92 T __udp4_lib_rcv
+c02bea1c T udp_rcv
+c02bea2b T udp_disconnect
+c02beb09 T udp_sendmsg
+c02bf110 t udplite_getfrag
+c02bf11d T __udp4_lib_err
+c02bf26e T udp_err
+c02bf278 T udp_ioctl
+c02bf2e2 t udp_lib_unhash
+c02bf36a T udp_recvmsg
+c02bf569 T udp_sendpage
+c02bf6a0 t udp_lib_hash
+c02bf6a4 t udplite_sk_init
+c02bf6ae t udp_lib_unhash
+c02bf736 t udp_lib_close
+c02bf73b t udplite_err
+c02bf75c t udplite_rcv
+c02bf78b T udplite_get_port
+c02bf7a9 t udplite_v4_get_port
+c02bf7b8 t arp_hash
+c02bf834 t arp_state_to_flags
+c02bf84e T arp_mc_map
+c02bf94f t arp_error_report
+c02bf973 t arp_ignore
+c02bf9f2 T arp_bind_neighbour
+c02bfa56 t arp_netdev_event
+c02bfa7d t arp_proc_exit
+c02bfa8a t arp_net_exit
+c02bfaad t arp_seq_release
+c02bfada t arp_seq_show
+c02bfcbd t arp_seq_start
+c02bfcd3 t arp_seq_open
+c02bfd2e t arp_net_init
+c02bfdbf T arp_xmit
+c02bfe10 T arp_ifdown
+c02bfe1c T arp_ioctl
+c02c03aa T arp_create
+c02c05a1 T arp_send
+c02c0605 t arp_process
+c02c0b51 t arp_rcv
+c02c0c54 t parp_redo
+c02c0c59 t arp_constructor
+c02c0d68 t arp_solicit
+c02c0efd T arp_find
+c02c1080 T xrlim_allow
+c02c10b3 t icmp_out_count
+c02c111e t icmp_address
+c02c111f t icmp_discard
+c02c1120 t icmp_net_exit
+c02c117b t icmp_net_init
+c02c1263 t icmp_push_reply
+c02c13e1 t icmp_glue_bits
+c02c145f t icmp_xmit_unlock
+c02c147e t icmp_reply
+c02c1649 t icmp_ping_of_death
+c02c176a T icmp_rcv
+c02c189b t icmp_address_reply
+c02c19e6 t icmp_echo
+c02c1a33 t icmp_timestamp
+c02c1af6 T icmp_send
+c02c1eaf t icmp_unreach
+c02c21a5 t icmp_redirect
+c02c2224 t confirm_addr_indev
+c02c22b8 T in_dev_finish_destroy
+c02c2344 t in_dev_rcu_put
+c02c2360 t inet_alloc_ifa
+c02c2382 t inet_fill_ifaddr
+c02c255b t rtmsg_ifa
+c02c2657 t __inet_insert_ifa
+c02c2766 t inet_insert_ifa
+c02c276f t inet_dump_ifaddr
+c02c2933 t __inet_del_ifa
+c02c2b26 t inet_del_ifa
+c02c2b40 t devinet_sysctl_unregister
+c02c2b69 t devinet_net_exit
+c02c2b80 t devinet_sysctl_register
+c02c2c7e t devinet_net_init
+c02c2d02 t devinet_copy_dflt_conf
+c02c2d68 t devinet_conf_proc
+c02c2dc6 t devinet_conf_sysctl
+c02c2e91 T ipv4_doint_and_flush_strategy
+c02c2ece T ipv4_doint_and_flush
+c02c2f15 T inet_forward_change
+c02c2f8d t devinet_sysctl_forward
+c02c3000 T inetdev_by_index
+c02c303c t inet_rtm_newaddr
+c02c31d8 T unregister_inetaddr_notifier
+c02c31e4 T register_inetaddr_notifier
+c02c31f0 T inet_addr_onlink
+c02c322f T inet_ifa_byprefix
+c02c3294 T inet_select_addr
+c02c334e T inet_confirm_addr
+c02c33f1 t inetdev_event
+c02c38bc t inet_rtm_deladdr
+c02c39d8 t inet_gifconf
+c02c3b1c t inet_rcu_free_ifa
+c02c3b41 T devinet_ioctl
+c02c4250 t inet_net_init
+c02c4267 t inet_net_exit
+c02c4268 t inet_autobind
+c02c42d9 T inet_shutdown
+c02c4395 T snmp_mib_free
+c02c43be T snmp_mib_init
+c02c4419 T snmp_fold_field
+c02c4465 T inet_unregister_protosw
+c02c44b6 T inet_register_protosw
+c02c454a T inet_ioctl
+c02c45e7 T build_ehash_secret
+c02c4623 t inet_create
+c02c4906 T inet_dgram_connect
+c02c4954 T inet_sendmsg
+c02c4999 t inet_sendpage
+c02c4a1c T inet_sk_rebuild_header
+c02c4d79 T inet_getname
+c02c4e4a t inet_gso_send_check
+c02c4f0a t inet_gso_segment
+c02c50a4 T inet_release
+c02c50e9 T inet_listen
+c02c5147 T inet_bind
+c02c53f7 T inet_stream_connect
+c02c55f6 T inet_accept
+c02c5697 T inet_sock_destruct
+c02c5858 T ip_mc_rejoin_group
+c02c5859 T ip_check_mc
+c02c58d6 t igmp_mcf_get_next
+c02c5996 t igmp_mcf_seq_start
+c02c5aa9 t igmp_mcf_seq_next
+c02c5b7d t igmp_mc_get_next
+c02c5c0c t igmp_mc_seq_start
+c02c5cff t igmp_mc_seq_next
+c02c5d99 t ip_ma_put
+c02c5dc5 t igmp_mcf_seq_stop
+c02c5e1b t igmp_mcf_seq_open
+c02c5e64 t igmp_mc_seq_show
+c02c5f17 t ip_mc_del1_src
+c02c5f7b t ip_mc_add_src
+c02c60bf t ip_mc_del_src
+c02c6189 t ip_mc_leave_src
+c02c620b t ip_mc_find_dev
+c02c62dd t igmp_group_dropped
+c02c6373 T ip_mc_dec_group
+c02c640b T ip_mc_leave_group
+c02c64af T ip_mc_down
+c02c6509 T ip_mc_destroy_dev
+c02c6582 t igmp_group_added
+c02c65cd T ip_mc_init_dev
+c02c6631 T ip_mc_inc_group
+c02c6753 T ip_mc_up
+c02c67ac t igmp_mcf_seq_show
+c02c6841 T ip_mc_join_group
+c02c6902 T ip_mc_source
+c02c6bd8 T ip_mc_msfilter
+c02c6de1 T ip_mc_msfget
+c02c6ed4 T ip_mc_gsfget
+c02c6ff8 T ip_mc_sf_allow
+c02c7071 T ip_mc_drop_socket
+c02c70ec t igmp_mc_seq_stop
+c02c712c t igmp_mc_seq_open
+c02c7178 t ipv4_sysctl_forward_strategy
+c02c7216 t ipv4_sysctl_forward
+c02c7266 t strategy_allowed_congestion_control
+c02c7307 t sysctl_tcp_congestion_control
+c02c7381 t proc_tcp_congestion_control
+c02c73ea t proc_tcp_available_congestion_control
+c02c7468 t proc_allowed_congestion_control
+c02c74f8 T fib_get_table
+c02c7526 t put_rtax
+c02c753c t fib_flush
+c02c7584 t fib_disable_ip
+c02c75bb t nl_fib_lookup_exit
+c02c75e8 t ip_fib_net_exit
+c02c7645 t fib_net_exit
+c02c7660 t fib_rule_put_rcu
+c02c7668 t fib_net_init
+c02c7735 t nl_fib_input
+c02c788e T inet_addr_type
+c02c794c t inet_dump_fib
+c02c7a31 t rtm_to_fib_config
+c02c7b76 t inet_rtm_delroute
+c02c7baf T fib_new_table
+c02c7c00 t fib_magic
+c02c7cb0 T fib_add_ifaddr
+c02c7de1 t fib_netdev_event
+c02c7e46 t fib_inetaddr_event
+c02c8007 t inet_rtm_newroute
+c02c8040 T ip_rt_ioctl
+c02c83c5 T ip_dev_find
+c02c8474 T fib_validate_source
+c02c86c0 T fib_nh_match
+c02c86f8 T fib_info_exit
+c02c8703 t fib_rule_put_rcu
+c02c870b T fib_info_init
+c02c872d T free_fib_info
+c02c877b T fib_dump_info
+c02c89eb T __fib_res_prefsrc
+c02c8a02 t fib_hash_alloc
+c02c8a29 t fib_hash_free
+c02c8a4e T fib_detect_death
+c02c8ac4 T rtmsg_fib
+c02c8c14 T fib_find_alias
+c02c8c56 T fib_semantic_match
+c02c8d05 T fib_sync_down
+c02c8e16 T fib_release_info
+c02c8ec5 T ip_fib_check_default
+c02c8f3b T fib_create_info
+c02c969c T fib_proc_exit
+c02c96a9 t fib_seq_release
+c02c96d6 t fib_seq_show
+c02c98b8 t fib_get_first
+c02c997a t fib_get_next
+c02c9a7a t fib_seq_next
+c02c9a8e t fib_seq_stop
+c02c9a98 t fib_seq_start
+c02c9b30 t fib_find_node
+c02c9b74 t fib_seq_open
+c02c9bcf T fib_proc_init
+c02c9c00 T fib_hash_init
+c02c9cc9 t fn_hash_flush
+c02c9df9 T fib_hash_exit
+c02c9e0f t fn_hash_delete
+c02c9fc0 t fz_hash_alloc
+c02c9fea t fn_hash_dump
+c02ca1ac t fn_hash_lookup
+c02ca260 t fn_hash_insert
+c02ca8a8 t fn_hash_select_default
+c02caa4c t netstat_seq_open
+c02caa5a t snmp_seq_open
+c02caa68 t sockstat_seq_open
+c02caa76 t fold_prot_inuse
+c02caaae t sockstat_seq_show
+c02cab9e t netstat_seq_show
+c02cac97 t snmp_seq_show
+c02caf20 T fib_rules_tclass
+c02caf2d t fib4_rule_match
+c02caf64 t fib4_rule_default_pref
+c02caf7f T fib4_rules_exit
+c02caf9d t fib4_rule_flush_cache
+c02cafa5 t fib4_rule_fill
+c02cb04e T fib_select_default
+c02cb08f t fib4_rule_action
+c02cb0d9 T fib_lookup
+c02cb11f t fib4_rule_nlmsg_payload
+c02cb125 t fib4_rule_compare
+c02cb197 t fib4_rule_configure
+c02cb27d T fib4_rules_init
+c02cb2f4 t tunnel4_err
+c02cb328 t tunnel64_rcv
+c02cb38f T xfrm4_tunnel_register
+c02cb3e6 T xfrm4_tunnel_deregister
+c02cb43a t tunnel4_rcv
+c02cb4b0 t ipv4_netfilter_fini
+c02cb4ba t ipv4_netfilter_init
+c02cb4c4 T nf_ip_checksum
+c02cb5a4 T ip_xfrm_me_harder
+c02cb6c2 T ip_route_me_harder
+c02cb96e t nf_ip_saveroute
+c02cb994 t nf_ip_reroute
+c02cb9e8 t bictcp_acked
+c02cba0e t bictcp_undo_cwnd
+c02cba24 t bictcp_state
+c02cba89 t bictcp_cong_avoid
+c02cbe1e t bictcp_recalc_ssthresh
+c02cbe7b t bictcp_init
+c02cbeec t xfrm4_garbage_collect
+c02cbf06 t xfrm4_update_pmtu
+c02cbf13 t xfrm4_dst_ifdown
+c02cbf80 t xfrm4_dst_lookup
+c02cbf85 t __xfrm4_find_bundle
+c02cc00f t __xfrm4_bundle_create
+c02cc3f0 t xfrm4_dst_destroy
+c02cc49a t xfrm4_get_saddr
+c02cc528 t _decode_session4
+c02cc6f0 t xfrm4_init_flags
+c02cc703 t __xfrm4_init_tempsel
+c02cc808 T xfrm4_rcv_encap
+c02ccbfb T xfrm4_rcv
+c02ccc1f t xfrm4_rcv_encap_finish
+c02ccc78 t dst_output
+c02ccc7f t xfrm4_output_finish2
+c02ccefc t xfrm4_output_finish
+c02ccf91 T xfrm4_output
+c02ccff4 t xfrm_gen_index
+c02cd049 t __xfrm_policy_unlink
+c02cd09f T xfrm_dst_ifdown
+c02cd0c9 t xfrm_link_failure
+c02cd0ca t unused_bundle
+c02cd0d8 T xfrm_spd_getinfo
+c02cd12f t prune_one_bundle
+c02cd186 t xfrm_prune_bundles
+c02cd255 t xfrm_dev_event
+c02cd273 t __xfrm_garbage_collect
+c02cd27d t xfrm_policy_unlock_afinfo
+c02cd287 t xfrm_policy_lock_afinfo
+c02cd2b6 T xfrm_unregister_mode
+c02cd2fe T xfrm_register_mode
+c02cd343 T xfrm_unregister_type
+c02cd37d T xfrm_register_type
+c02cd3b4 T xfrm_policy_unregister_afinfo
+c02cd436 T xfrm_policy_register_afinfo
+c02cd4d5 t xfrm_negative_advice
+c02cd528 t policy_hash_bysel
+c02cd59c T xfrm_selector_match
+c02cd820 T xfrm_bundle_ok
+c02cda2b t stale_bundle
+c02cda53 t xfrm_dst_check
+c02cda6c t xfrm_sk_policy_lookup
+c02cdab0 t xfrm_policy_match
+c02cdae4 t xfrm_policy_put_afinfo
+c02cdaee t xfrm_policy_get_afinfo
+c02cdb1f T xfrm_decode_session
+c02cdb50 T xfrm_dst_lookup
+c02cdb8f t xfrm_tmpl_resolve
+c02cde64 T __xfrm_policy_destroy
+c02cde99 T __xfrm_lookup
+c02ce345 T xfrm_lookup
+c02ce3af T __xfrm_route_forward
+c02ce3ec t xfrm_policy_gc_task
+c02ce48b t __xfrm_policy_link
+c02ce518 t xfrm_policy_kill
+c02ce5b5 T xfrm_policy_delete
+c02ce5fb T xfrm_policy_alloc
+c02ce664 t clone_policy
+c02ce74f T __xfrm_sk_clone_policy
+c02ce7a5 T xfrm_put_mode
+c02ce7ad T xfrm_put_type
+c02ce7b5 T xfrm_get_mode
+c02ce839 T xfrm_policy_walk
+c02ce9a0 T xfrm_policy_byid
+c02ceaa1 T xfrm_policy_flush
+c02cec29 T xfrm_sk_policy_insert
+c02cecad T xfrm_init_pmtu
+c02cece7 t xfrm_hash_resize
+c02cef10 T xfrm_policy_insert
+c02cf24a T xfrm_policy_bysel_ctx
+c02cf34f t xfrm_policy_lookup
+c02cf4e9 T xfrm_get_type
+c02cf574 T __xfrm_policy_check
+c02cfa22 t xfrm_policy_timer
+c02cfc0c t __xfrm_find_acq_byseq
+c02cfc5c t xfrm_state_pernet_init
+c02cfc7d T xfrm_state_mtu
+c02cfcc7 T xfrm_get_acqseq
+c02cfcfd T xfrm_find_acq_byseq
+c02cfd21 T xfrm_sad_getinfo
+c02cfd50 t xfrm_state_gc_task
+c02cfe28 T xfrm_state_put_afinfo
+c02cfe32 T xfrm_state_get_afinfo
+c02cfe63 T xfrm_init_state
+c02cfefb T km_query
+c02cff60 T km_state_notify
+c02cffa3 T km_state_expired
+c02cffe6 T km_policy_notify
+c02d0035 T km_policy_expired
+c02d007c T xfrm_state_unregister_afinfo
+c02d00d2 T xfrm_state_register_afinfo
+c02d011c T xfrm_unregister_km
+c02d013e T xfrm_register_km
+c02d016b t __xfrm_state_lookup_byaddr
+c02d025f T xfrm_state_lookup_byaddr
+c02d029e t __xfrm_state_lookup
+c02d0364 T xfrm_state_lookup
+c02d03a3 T xfrm_user_policy
+c02d0498 T xfrm_replay_notify
+c02d056b T xfrm_replay_advance
+c02d05e5 T xfrm_state_check_expire
+c02d06bf t xfrm_hash_grow_check
+c02d06e7 t __xfrm_state_insert
+c02d0886 t xfrm_hash_resize
+c02d0ae0 T xfrm_state_check
+c02d0b33 t __xfrm_state_bump_genids
+c02d0c1e T xfrm_state_insert
+c02d0c44 T __xfrm_state_delete
+c02d0ce3 T xfrm_state_delete
+c02d0d06 t xfrm_timer_handler
+c02d0ee4 T __xfrm_state_destroy
+c02d0f54 T xfrm_state_delete_tunnel
+c02d0f98 T xfrm_state_alloc
+c02d10b1 t __find_acq_core
+c02d13d3 T xfrm_find_acq
+c02d1431 T xfrm_replay_check
+c02d148f T xfrm_state_walk
+c02d1547 T km_new_mapping
+c02d15aa T km_migrate
+c02d1624 T km_report
+c02d168b t xfrm_replay_timer_handler
+c02d16d7 T xfrm_state_flush
+c02d17a5 T xfrm_state_find
+c02d1c67 T xfrm_state_add
+c02d1dea T xfrm_state_update
+c02d1fdf T xfrm_alloc_spi
+c02d2134 T xfrm_hash_free
+c02d2162 T xfrm_hash_alloc
+c02d21d8 T secpath_dup
+c02d222a T __secpath_destroy
+c02d225c T xfrm_parse_spi
+c02d2330 t xfrm_alg_id_match
+c02d233d T xfrm_count_auth_supported
+c02d235b T xfrm_count_enc_supported
+c02d2379 T skb_icv_walk
+c02d255c t xfrm_find_algo
+c02d25bf T xfrm_calg_get_byname
+c02d25d8 T xfrm_ealg_get_byname
+c02d25f1 T xfrm_aalg_get_byname
+c02d260a T xfrm_calg_get_byid
+c02d2627 T xfrm_ealg_get_byid
+c02d2644 T xfrm_aalg_get_byid
+c02d2661 t xfrm_alg_name_match
+c02d26b8 T xfrm_aalg_get_byidx
+c02d26cb T xfrm_ealg_get_byidx
+c02d26de T xfrm_probe_algs
+c02d27dc t unix_poll
+c02d2873 t unix_net_exit
+c02d2889 t unix_seq_release
+c02d28b6 t unix_seq_show
+c02d29d5 t unix_seq_stop
+c02d29df t unix_ioctl
+c02d2a8e t unix_peer_get
+c02d2ab9 t unix_seq_start
+c02d2bc9 t unix_state_double_unlock
+c02d2bf1 t unix_state_double_lock
+c02d2c2d t __unix_insert_socket
+c02d2c7e t unix_copy_addr
+c02d2cba t unix_seq_open
+c02d2d1c t unix_net_init
+c02d2d4e t unix_detach_fds
+c02d2d84 t unix_mkname
+c02d2df8 t __unix_find_socket_byname
+c02d2e69 t __unix_remove_socket
+c02d2ec3 t unix_autobind
+c02d300d t unix_attach_fds
+c02d3041 t unix_dgram_disconnected
+c02d309e t unix_wait_for_peer
+c02d3138 t unix_find_other
+c02d32cb t unix_dgram_sendmsg
+c02d3712 t unix_stream_recvmsg
+c02d3b7e t unix_accept
+c02d3c59 t unix_release_sock
+c02d3e33 t unix_release
+c02d3e4d t unix_create1
+c02d3f47 t unix_create
+c02d3fae t unix_listen
+c02d4076 t unix_socketpair
+c02d40fe t unix_seq_next
+c02d422e t unix_seqpacket_sendmsg
+c02d4289 t unix_sock_destructor
+c02d4361 t unix_bind
+c02d45f1 t unix_dgram_recvmsg
+c02d47b4 t unix_destruct_fds
+c02d47ec t unix_stream_sendmsg
+c02d4ae3 t unix_dgram_connect
+c02d4c4d t unix_stream_connect
+c02d4fc4 t unix_getname
+c02d5052 t unix_write_space
+c02d50c9 t unix_shutdown
+c02d5204 t unix_get_socket
+c02d5233 t maybe_unmark_and_push
+c02d5254 T unix_inflight
+c02d526c T unix_notinflight
+c02d5284 T unix_gc
+c02d5678 T unix_sysctl_unregister
+c02d5692 T unix_sysctl_register
+c02d56f4 T ipv6_opt_accepted
+c02d5759 t cleanup_ipv6_mibs
+c02d5781 T inet6_register_protosw
+c02d5810 T inet6_unregister_protosw
+c02d5861 T inet6_ioctl
+c02d58fe T inet6_release
+c02d5928 t inet6_create
+c02d5c2d T inet6_destroy_sock
+c02d5c67 T inet6_getname
+c02d5d2c T inet6_sk_rebuild_header
+c02d5e7c T inet6_bind
+c02d61d8 T ac6_proc_exit
+c02d61e8 t ac6_get_next
+c02d6279 t ac6_seq_next
+c02d628a t ipv6_chk_acast_dev
+c02d6308 t ac6_seq_stop
+c02d633b t ac6_seq_start
+c02d6415 T ipv6_chk_acast_addr
+c02d6470 t ac6_seq_open
+c02d64b9 t aca_put
+c02d6532 T __ipv6_dev_ac_dec
+c02d665d t ipv6_dev_ac_dec
+c02d6692 T ipv6_dev_ac_inc
+c02d685d t ac6_seq_show
+c02d696e T ipv6_sock_ac_close
+c02d69fe T ipv6_sock_ac_drop
+c02d6aba T ipv6_sock_ac_join
+c02d6d44 t dst_output
+c02d6d4b t ip6_forward_finish
+c02d6d52 T ip6_find_1stfragopt
+c02d6db8 t ip6_output_finish
+c02d6eab t ip6_dst_lookup_tail
+c02d6f54 T ip6_dst_lookup
+c02d6f5f t ip6_copy_metadata
+c02d7050 t ip6_dev_loopback_xmit
+c02d70cd t ip6_output2
+c02d73c3 T ip6_flush_pending_frames
+c02d74f1 T ip6_output
+c02d8007 T ip6_sk_dst_lookup
+c02d8110 T ip6_push_pending_frames
+c02d8518 T ip6_xmit
+c02d88f0 T ip6_forward
+c02d8fce T ip6_nd_hdr
+c02d906a T ip6_append_data
+c02d9acc T ip6_input
+c02d9df6 T ip6_mc_input
+c02d9e65 t ip6_input_finish
+c02da141 T ip6_rcv_finish
+c02da162 T ipv6_rcv
+c02da454 t ipv6_generate_eui64
+c02da533 t if6_get_next
+c02da551 t if6_seq_next
+c02da562 t put_ifaddrmsg
+c02da580 t addrconf_del_timer
+c02da595 t put_cacheinfo
+c02da611 t inet6_fill_ifaddr
+c02da7ac t addrconf_join_anycast
+c02da824 t addrconf_leave_anycast
+c02da89a t addrconf_mod_timer
+c02da8f3 t in6_dev_finish_destroy_rcu
+c02da8fd T addrconf_join_solict
+c02da938 t ipv6_add_addr
+c02dab77 t addrconf_add_mroute
+c02dabdf t addrconf_prefix_route
+c02dac5a t addrconf_add_lroute
+c02daca0 t if6_seq_start
+c02dacf6 t if6_seq_stop
+c02dad00 T ipv6_get_ifaddr
+c02dad8e T ipv6_get_lladdr
+c02dadee t addrconf_dad_kick
+c02dae31 t addrconf_sysctl_register
+c02daf0b t dev_forward_change
+c02daf8e t addrconf_forward_change
+c02daff2 t addrconf_sysctl_forward_strategy
+c02db0f4 t addrconf_sysctl_forward
+c02db17c t addrconf_sysctl_unregister
+c02db1a7 t extract_addr
+c02db1d4 t snmp6_fill_stats
+c02db29e t inet6_fill_ifinfo
+c02db655 T inet6_ifinfo_notify
+c02db72a T unregister_inet6addr_notifier
+c02db736 T register_inet6addr_notifier
+c02db742 t if6_seq_open
+c02db78b T addrconf_leave_solict
+c02db7c8 t __ipv6_ifa_notify
+c02db93b t ipv6_ifa_notify
+c02db95f t addrconf_dad_completed
+c02dba04 T in6_dev_finish_destroy
+c02dbaaf t inet6_dump_addr
+c02dc0d5 t inet6_dump_ifacaddr
+c02dc0f5 t inet6_dump_ifmcaddr
+c02dc115 t inet6_dump_ifaddr
+c02dc132 T inet6_ifa_finish_destroy
+c02dc226 t addrconf_ifdown
+c02dc440 T ipv6_dev_get_saddr
+c02dca53 T ipv6_get_saddr
+c02dca78 t ipv6_del_addr
+c02dcd89 t addrconf_verify
+c02dcf20 t inet6_addr_del
+c02dcfc5 T addrconf_del_ifaddr
+c02dd016 t addrconf_dad_stop
+c02dd05a t addrconf_dad_start
+c02dd11b t addrconf_add_linklocal
+c02dd181 T addrconf_dad_failure
+c02dd1af t inet6_rtm_getaddr
+c02dd307 t ipv6_add_dev
+c02dd50d t ipv6_find_idev
+c02dd574 t addrconf_add_dev
+c02dd5cd t inet6_addr_add
+c02dd746 T addrconf_add_ifaddr
+c02dd7b2 T addrconf_set_dstaddr
+c02dd8ad t if6_seq_show
+c02dda6a T ipv6_chk_addr
+c02ddafd t inet6_dump_ifinfo
+c02ddbef t addrconf_notify
+c02de37f T ipv6_rcv_saddr_equal
+c02de621 T if6_proc_exit
+c02de631 t inet6_rtm_deladdr
+c02de699 t addrconf_rs_timer
+c02de776 t addrconf_dad_timer
+c02de853 t inet6_rtm_newaddr
+c02dea6b T addrconf_prefix_rcv
+c02df074 t ip6_rt_blackhole_update_pmtu
+c02df075 t ip6_dst_check
+c02df08b t fib6_ifdown
+c02df0a3 t ipv6_get_mtu
+c02df0d3 T ipv6_get_hoplimit
+c02df104 t ipv6_sysctl_rtcache_flush
+c02df14b t ip6_dst_gc
+c02df1c7 t ip6_blackhole_output
+c02df1cf t ip6_pkt_discard_out
+c02df26c t rt6_stats_seq_open
+c02df27a t rt6_stats_seq_show
+c02df2d9 t rt6_fill_node
+c02df61f T rt6_dump_route
+c02df689 t rtm_to_fib6_config
+c02df7d1 t find_match
+c02df89c t rt6_select
+c02df96d T rt6_get_dflt_router
+c02dfa00 t __ip6_del_rt
+c02dfa7c t ip6_route_del
+c02dfb54 t inet6_rtm_delroute
+c02dfb8c T ip6_del_rt
+c02dfbb3 T rt6_purge_dflt_routers
+c02dfc10 t rt6_proc_info
+c02dfca2 T rt6_mtu_change
+c02dfcbd T rt6_ifdown
+c02dfccb t ip6_rt_copy
+c02dfd88 t rt6_alloc_cow
+c02dfe5c T ip6_route_output
+c02dfe96 T ip6_route_input
+c02dff23 T rt6_lookup
+c02dffcc t __ip6_ins_rt
+c02e0000 T ip6_route_add
+c02e055e t inet6_rtm_newroute
+c02e0596 T ipv6_route_ioctl
+c02e06ac T ip6_ins_rt
+c02e06d3 t rt6_info_route
+c02e09e7 t ip6_rt_update_pmtu
+c02e0a24 t rt6_mtu_change_route
+c02e0a86 t ip6_pol_route_lookup
+c02e0b57 t __ip6_route_redirect
+c02e0c1b t ip6_link_failure
+c02e0c9c T rt6_pmtu_discovery
+c02e0e28 T inet6_rt_notify
+c02e0f62 T rt6_add_dflt_router
+c02e0fcc t inet6_rtm_getroute
+c02e1187 T addrconf_dst_alloc
+c02e12e9 t ip6_pol_route_input
+c02e1493 t ip6_pol_route_output
+c02e163d t ip6_negative_advice
+c02e1697 T rt6_redirect
+c02e18ab t ip6_dst_destroy
+c02e18d2 t ip6_dst_ifdown
+c02e190f t ip6_pkt_discard
+c02e1a2c T ip6_route_cleanup
+c02e1a67 T ndisc_dst_alloc
+c02e1b71 T ip6_dst_blackhole
+c02e1ca6 T ndisc_dst_gc
+c02e1d14 T fib6_get_table
+c02e1d1a T fib6_rule_lookup
+c02e1d2a t fib6_find_prefix
+c02e1d4e t fib6_prune_clone
+c02e1d61 t fib6_age
+c02e1dc0 T fib6_gc_cleanup
+c02e1dd4 t fib6_walk_continue
+c02e1eb5 t fib6_walk
+c02e1f23 t fib6_clean_tree
+c02e1f4d t fib6_prune_clones
+c02e1f64 T fib6_clean_all
+c02e1fb0 t fib6_dump_end
+c02e1fd5 t inet6_dump_fib
+c02e21a4 t fib6_dump_done
+c02e21bb t fib6_dump_node
+c02e221f T fib6_force_start_gc
+c02e223f T fib6_run_gc
+c02e22f8 T fib6_del
+c02e270d t fib6_clean_node
+c02e27a5 T fib6_locate
+c02e284a T fib6_lookup
+c02e293b T fib6_add
+c02e2dea T fib6_new_table
+c02e2df0 T ipv6_packet_cleanup
+c02e2dfa t ipv6_gso_pull_exthdrs
+c02e2e99 T ipv6_getsockopt
+c02e34d7 T ip6_ra_control
+c02e35ca t ipv6_gso_segment
+c02e36ad t ipv6_gso_send_check
+c02e372b T ipv6_setsockopt
+c02e4268 t dst_output
+c02e426f t ndisc_parse_options
+c02e42e7 t ndisc_hash
+c02e436c t ndisc_error_report
+c02e4390 t ndisc_warn_deprecated_sysctl
+c02e4416 T ndisc_mc_map
+c02e4595 t ndisc_fill_addr_option
+c02e464a t __ndisc_send
+c02e4b30 T ndisc_send_rs
+c02e4b80 t ndisc_send_na
+c02e4c75 t ndisc_recv_ns
+c02e50e0 t pndisc_redo
+c02e50f0 T ndisc_cleanup
+c02e5123 t ndisc_netdev_event
+c02e515e t ndisc_ifinfo_sysctl_strategy
+c02e526d T ndisc_send_ns
+c02e52ed T ndisc_rcv
+c02e5d86 t ndisc_solicit
+c02e5f45 t pndisc_constructor
+c02e5f8e t pndisc_destructor
+c02e5fce t ndisc_constructor
+c02e6130 T ndisc_send_redirect
+c02e677e T ndisc_ifinfo_sysctl_change
+c02e68ac t udp_lib_hash
+c02e68b0 t udp_v6_get_port
+c02e68bd t udp_lib_close
+c02e68c2 T udp6_proc_exit
+c02e68d1 T udp6_seq_show
+c02e6a2b T udpv6_getsockopt
+c02e6a6c T udpv6_setsockopt
+c02e6ab6 t udp_v6_push_pending_frames
+c02e6c89 t udp_v6_flush_pending_frames
+c02e6cab T udpv6_destroy_sock
+c02e6cce t udplite_getfrag
+c02e6cdb t __udp6_lib_lookup
+c02e6ef8 t udp_v6_mcast_next
+c02e7023 T udpv6_queue_rcv_skb
+c02e71cd T __udp6_lib_rcv
+c02e76f6 t udpv6_rcv
+c02e7705 T __udp6_lib_err
+c02e77d7 t udpv6_err
+c02e7804 t udp_lib_unhash
+c02e788c T udpv6_recvmsg
+c02e7ae8 T udpv6_sendmsg
+c02e83cc t udp_lib_hash
+c02e83d0 t udplite_sk_init
+c02e83da t udplite_v6_get_port
+c02e83e7 t udp_lib_unhash
+c02e846f t udp_lib_close
+c02e8474 T udplite6_proc_exit
+c02e8483 t udplitev6_err
+c02e84b0 t udplitev6_rcv
+c02e84c0 t dst_output
+c02e84c7 t rawv6_init_sk
+c02e850a t raw6_get_first
+c02e8549 t raw6_get_next
+c02e8580 t raw6_seq_next
+c02e859d t raw_v6_unhash
+c02e861c t rawv6_rcv_skb
+c02e865f t rawv6_ioctl
+c02e86cf T raw6_proc_exit
+c02e86df t raw6_seq_show
+c02e880f t raw6_seq_stop
+c02e8819 t raw6_seq_start
+c02e886e t raw6_seq_open
+c02e88b7 T rawv6_rcv
+c02e8a86 T __raw_v6_lookup
+c02e8b90 t raw_v6_hash
+c02e8bf2 t rawv6_setsockopt
+c02e8cbf t rawv6_getsockopt
+c02e8dcf t rawv6_close
+c02e8def T ipv6_raw_deliver
+c02e8f69 T rawv6_err
+c02e901c t rawv6_sendmsg
+c02e9b98 t rawv6_recvmsg
+c02e9d7c t rawv6_bind
+c02e9ea4 T inet6_add_protocol
+c02e9edc T inet6_del_protocol
+c02e9f1c T icmpv6_err_convert
+c02e9f73 T icmpv6_cleanup
+c02e9fb7 t icmpv6_push_pending_frames
+c02ea0bb t icmpv6_getfrag
+c02ea132 t icmpv6_notify
+c02ea29d T icmpv6_send
+c02ea938 T icmpv6_param_prob
+c02ea960 t icmpv6_rcv
+c02eb214 t is_in
+c02eb2d3 t sf_markstate
+c02eb309 t ip6_mc_clear_src
+c02eb357 t ip6_mc_del1_src
+c02eb430 t mld_clear_zeros
+c02eb460 t igmp6_mcf_get_next
+c02eb520 t igmp6_mcf_seq_next
+c02eb5f4 t igmp6_mc_get_next
+c02eb685 t igmp6_mc_seq_next
+c02eb696 t ma_put
+c02eb6c3 t igmp6_mcf_seq_stop
+c02eb719 t igmp6_mcf_seq_start
+c02eb82c t igmp6_mc_seq_start
+c02eb906 t igmp6_mcf_seq_open
+c02eb94f t mld_clear_delrec
+c02eb9eb t mld_newpack
+c02ebb61 t add_grhead
+c02ebc0b t igmp6_send
+c02ec24f t mld_sendpack
+c02ec5c1 t add_grec
+c02ec94b t mld_send_report
+c02eca01 t mld_dev_queue_xmit
+c02ecabe t mld_dev_queue_xmit2
+c02ecb31 t igmp6_group_queried
+c02ecbc0 t mld_ifc_start_timer
+c02ecbee t mld_ifc_event
+c02ecc22 t igmp6_group_dropped
+c02ecdbc T ipv6_mc_down
+c02ece17 T __ipv6_dev_mc_dec
+c02ece9a T ipv6_mc_destroy_dev
+c02ecf3c t mld_ifc_timer_expire
+c02ed131 T ipv6_mc_init_dev
+c02ed19f t igmp6_group_added
+c02ed2bc T ipv6_mc_up
+c02ed2e6 t igmp6_timer_handler
+c02ed351 t sf_setstate
+c02ed49a t ip6_mc_add_src
+c02ed6a2 T ipv6_dev_mc_inc
+c02ed97f t ip6_mc_del_src
+c02edafc t ip6_mc_find_dev
+c02edbc0 t ip6_mc_leave_src
+c02edc3c T ipv6_sock_mc_drop
+c02edd4f t igmp6_mc_seq_show
+c02ede98 t igmp6_mcf_seq_show
+c02ee140 t mld_gq_timer_expire
+c02ee154 T inet6_mc_check
+c02ee24b T ipv6_sock_mc_join
+c02ee418 T igmp6_cleanup
+c02ee44c T ipv6_sock_mc_close
+c02ee515 T ip6_mc_source
+c02ee8d2 T ip6_mc_msfilter
+c02eeb8e T ip6_mc_msfget
+c02eed36 T ipv6_dev_mc_dec
+c02eed6b T ipv6_chk_mcast_addr
+c02eeea2 T igmp6_event_report
+c02eefbc t igmp6_mc_seq_stop
+c02eeffc t igmp6_mc_seq_open
+c02ef045 T ipv6_is_mld
+c02ef097 T igmp6_event_query
+c02ef574 t ip6qhashfn
+c02ef6d3 t ip6_frag_destroy
+c02ef783 t ip6_frag_secret_rebuild
+c02ef82d t ipv6_frag_rcv
+c02f06c4 t ip6_frag_expire
+c02f0814 t tcp_v6_remember_stamp
+c02f0817 t tcp_v6_send_ack
+c02f0a79 t tcp_v6_send_reset
+c02f0ce4 t tcp_v6_send_synack
+c02f0f68 t tcp_v6_get_port
+c02f0f83 t tcp_v6_do_rcv
+c02f1308 t tcp_v6_destroy_sock
+c02f1318 t tcp_v6_init_sock
+c02f1459 T tcp6_proc_exit
+c02f1468 t tcp6_seq_show
+c02f1993 t tcp_v6_hash
+c02f19cc t tcp_v6_reqsk_send_ack
+c02f19f7 t tcp_v6_reqsk_destructor
+c02f1a09 t tcp_v6_conn_request
+c02f1cb9 t tcp_v6_syn_recv_sock
+c02f21dd t tcp_v6_send_check
+c02f22b9 t tcp_v6_connect
+c02f28b1 t tcp_v6_gso_send_check
+c02f2960 t tcp_v6_err
+c02f2d80 t tcp_v6_rcv
+c02f34e0 T ipv6_fixup_options
+c02f352c t ipv6_renew_option
+c02f35b1 t ipv6_push_exthdr
+c02f3628 T ipv6_push_frag_opts
+c02f364b T ipv6_push_nfrag_opts
+c02f375a t ipv6_nodata_rcv
+c02f3764 t ip6_parse_tlv
+c02f386c T ipv6_dup_options
+c02f38c9 T ipv6_invert_rthdr
+c02f3988 T ipv6_renew_options
+c02f3bec T ipv6_find_tlv
+c02f3c52 t ipv6_hop_ra
+c02f3ca6 t ipv6_hop_jumbo
+c02f3e8b t ipv6_destopt_rcv
+c02f4044 T ipv6_parse_hopopts
+c02f40e8 t ipv6_rthdr_rcv
+c02f45e0 T ipv6_sysctl_unregister
+c02f45ea T ipv6_sysctl_register
+c02f45fc T datagram_recv_ctl
+c02f4994 T datagram_send_ctl
+c02f4da7 T ipv6_local_error
+c02f4f0e T ip6_datagram_connect
+c02f5322 T ipv6_recv_error
+c02f55cf T ipv6_icmp_error
+c02f56e8 T fl6_merge_options
+c02f5750 t ip6fl_get_first
+c02f5775 t ip6fl_get_next
+c02f5795 t ip6fl_seq_next
+c02f57b2 t fl_free
+c02f57c9 t ip6_fl_gc
+c02f5875 T ip6_flowlabel_cleanup
+c02f588f t ip6fl_seq_stop
+c02f5899 t ip6fl_seq_start
+c02f58ee t fl_lookup
+c02f592e t ip6fl_seq_open
+c02f5977 T ip6_flowlabel_init
+c02f5998 t check_linger
+c02f59c4 t fl6_renew
+c02f5a15 t ipv6_hdr_cmp
+c02f5a48 t fl_release
+c02f5abc T ipv6_flowlabel_opt
+c02f614a t ip6fl_seq_show
+c02f6306 T fl6_sock_lookup
+c02f6338 T fl6_free_socklist
+c02f6360 t inet6_synq_hash
+c02f6455 T inet6_csk_reqsk_queue_hash_add
+c02f64f9 T inet6_csk_bind_conflict
+c02f6551 T inet6_csk_addr2sockaddr
+c02f65a4 T inet6_csk_xmit
+c02f6773 T inet6_csk_search_req
+c02f6868 t xfrm6_garbage_collect
+c02f6882 t xfrm6_update_pmtu
+c02f688f T xfrm6_fini
+c02f689e t xfrm6_dst_ifdown
+c02f690b t xfrm6_dst_lookup
+c02f696a t __xfrm6_bundle_create
+c02f6e07 t xfrm6_dst_destroy
+c02f6e91 t xfrm6_get_saddr
+c02f6f34 t _decode_session6
+c02f70cb t __xfrm6_find_bundle
+c02f7278 T xfrm6_state_fini
+c02f7282 t __xfrm6_tmpl_sort
+c02f72f4 t __xfrm6_state_sort
+c02f73a0 t __xfrm6_init_tempsel
+c02f74c0 T xfrm6_rcv_spi
+c02f786d T xfrm6_rcv
+c02f7876 T xfrm6_input_addr
+c02f79e0 t dst_output
+c02f79e7 t xfrm6_output_finish2
+c02f7c88 t xfrm6_output_finish
+c02f7d02 T xfrm6_output
+c02f7d5b T xfrm6_find_1stfragopt
+c02f7d64 T ipv6_netfilter_fini
+c02f7d6e T ip6_route_me_harder
+c02f7f31 t nf_ip6_saveroute
+c02f7f66 t nf_ip6_reroute
+c02f7fd5 T nf_ip6_checksum
+c02f8120 T snmp6_unregister_dev
+c02f815d t snmp6_seq_open
+c02f8173 t sockstat6_seq_open
+c02f8181 t fold_prot_inuse
+c02f81b9 t sockstat6_seq_show
+c02f8260 T snmp6_register_dev
+c02f82ac T ipv6_misc_proc_exit
+c02f82dc t snmp6_seq_show
+c02f84a0 t xfrm6_transport_input
+c02f84ff t xfrm6_transport_output
+c02f8578 t xfrm6_tunnel_input
+c02f8706 t xfrm6_tunnel_output
+c02f883c t xfrm6_beet_input
+c02f8918 t xfrm6_beet_output
+c02f89c0 t dst_output
+c02f89c7 t ipip6_tunnel_lookup
+c02f8a75 t __ipip6_bucket
+c02f8ab6 t ipip6_tunnel_change_mtu
+c02f8ad7 t ipip6_tunnel_setup
+c02f8b45 t ipip6_tunnel_link
+c02f8b72 t ipip6_tunnel_unlink
+c02f8bac t ipip6_tunnel_locate
+c02f8c9f t ipip6_tunnel_ioctl
+c02f8f11 t ipip6_tunnel_get_stats
+c02f8f17 t ipip6_tunnel_init
+c02f9064 t ipip6_tunnel_uninit
+c02f90a3 t ipip6_err
+c02f9141 t ipip6_rcv
+c02f92db t ipip6_tunnel_xmit
+c02f9910 T __ipv6_addr_type
+c02f99c8 T ipv6_ext_hdr
+c02f99f1 T ipv6_skip_exthdr
+c02f9b00 t __inet6_check_established
+c02f9e99 T inet6_lookup_listener
+c02fa02c T __inet6_lookup_established
+c02fa218 T __inet6_hash
+c02fa34c T inet6_lookup
+c02fa3d1 T inet6_hash_connect
+c02fa694 t packet_seq_next
+c02fa6b9 t packet_seq_start
+c02fa70d t packet_seq_stop
+c02fa71a t packet_dev_mc
+c02fa777 t packet_net_exit
+c02fa784 t packet_seq_release
+c02fa7af t packet_seq_open
+c02fa7e1 t packet_seq_show
+c02fa87b t packet_net_init
+c02fa8c2 t packet_do_bind
+c02fa99f t free_pg_vec
+c02fa9cb t packet_set_ring
+c02faca5 t packet_ioctl
+c02fad78 t tpacket_rcv
+c02fb15b t packet_sendmsg
+c02fb39a t packet_release
+c02fb50d t packet_bind_spkt
+c02fb561 t packet_bind
+c02fb5c3 t packet_create
+c02fb746 t packet_recvmsg
+c02fb8d4 t packet_getname_spkt
+c02fb93a t packet_getname
+c02fb9d4 t packet_setsockopt
+c02fbcd6 t packet_getsockopt
+c02fbdd9 t packet_notifier
+c02fbf2d t packet_poll
+c02fbf8f t packet_mm_open
+c02fbfa7 t packet_mm_close
+c02fbfbf t packet_mmap
+c02fc0ac t packet_sock_destruct
+c02fc134 t packet_sendmsg_spkt
+c02fc2ea t packet_rcv
+c02fc607 t packet_rcv_spkt
+c02fc744 t get_wireless_stats
+c02fc75b t call_commit_handler
+c02fc78f t wireless_nlevent_process
+c02fc7dd T wireless_send_event
+c02fcad3 t iw_send_thrspy_event
+c02fcb2f T wireless_spy_update
+c02fcc01 t ioctl_standard_call
+c02fcecc T wext_handle_ioctl
+c02fd24a T wext_proc_exit
+c02fd257 t wireless_seq_release
+c02fd282 t wireless_seq_open
+c02fd2b4 t wireless_seq_show
+c02fd3f6 T wext_proc_init
+c02fd41d t iw_handler_get_iwstats
+c02fd456 t iw_handler_get_private
+c02fd4af T iw_handler_set_spy
+c02fd517 T iw_handler_get_spy
+c02fd59e T iw_handler_set_thrspy
+c02fd5d4 T iw_handler_get_thrspy
+c02fd600 T klist_node_attached
+c02fd60a T klist_iter_init_node
+c02fd622 T klist_iter_init
+c02fd629 t klist_dec_and_del
+c02fd636 T klist_next
+c02fd6a3 T klist_del
+c02fd6de T klist_iter_exit
+c02fd6f6 t klist_release
+c02fd712 T klist_remove
+c02fd725 t klist_node_init
+c02fd75b T klist_add_tail
+c02fd78a T klist_add_head
+c02fd7b6 T klist_init
+c02fd7e4 T __down_trylock
+c02fd828 T __up
+c02fd848 T sha_init
+c02fd86b T sha_transform
+c02fda64 t rest_init
+c02fdaa3 t alloc_node_mem_map
+c02fdb2f t zone_wait_table_init
+c02fdbd7 t setup_cpu_cache
+c02fdd00 T __sched_text_start
+c02fdd00 T schedule
+c02fe7d6 T cond_resched_softirq
+c02fe817 T yield
+c02fe82b T wait_for_completion
+c02fe8be T io_schedule_timeout
+c02fe8e6 T sleep_on_timeout
+c02fe959 T io_schedule
+c02fe980 T cond_resched
+c02fe9b1 T wait_for_completion_interruptible_timeout
+c02fea81 T wait_for_completion_timeout
+c02feb30 T wait_for_completion_interruptible
+c02febe2 T interruptible_sleep_on
+c02fec4b T interruptible_sleep_on_timeout
+c02fecbe T sleep_on
+c02fed27 T console_conditional_schedule
+c02fed36 T schedule_timeout
+c02fedc3 T schedule_timeout_uninterruptible
+c02fedd5 T schedule_timeout_interruptible
+c02fede7 T __wait_on_bit_lock
+c02fee39 T out_of_line_wait_on_bit_lock
+c02feea4 T __wait_on_bit
+c02feefc T out_of_line_wait_on_bit
+c02fef67 T mutex_unlock
+c02fef72 T mutex_trylock
+c02fef8e T mutex_lock_interruptible
+c02fefb3 T mutex_lock
+c02fefd7 t __mutex_lock_interruptible_slowpath
+c02ff074 t __mutex_unlock_slowpath
+c02ff0a4 t __mutex_lock_slowpath
+c02ff11b t do_nanosleep
+c02ff187 T hrtimer_nanosleep_restart
+c02ff22f T rt_mutex_unlock
+c02ff251 T rt_mutex_trylock
+c02ff272 T rt_mutex_lock_interruptible
+c02ff2bb t rt_mutex_slowlock
+c02ff701 t rt_mutex_slowunlock
+c02ff89d T rt_mutex_lock
+c02ff8dc T rwsem_down_write_failed
+c02ff8fb T rwsem_down_read_failed
+c02ff91c T __down_failed
+c02ff928 T __down_failed_interruptible
+c02ff934 T __down_failed_trylock
+c02ff940 T __up_wakeup
+c02ff94c T __write_lock_failed
+c02ff968 T __read_lock_failed
+c02ff978 T call_rwsem_down_read_failed
+c02ff984 T call_rwsem_down_write_failed
+c02ff98c T call_rwsem_wake
+c02ff998 T call_rwsem_downgrade_wake
+c02ff9a2 T __down_interruptible
+c02ffa92 T __down
+c02ffb4a T __sched_text_end
+c02ffb50 T __lock_text_start
+c02ffb50 T _spin_trylock
+c02ffb5e T _spin_trylock_bh
+c02ffb85 T _write_unlock_bh
+c02ffb92 T _write_unlock_irq
+c02ffb99 T _write_unlock
+c02ffb9e T _read_unlock_bh
+c02ffbab T _read_unlock
+c02ffbb0 T _spin_unlock_bh
+c02ffbbd T _spin_unlock
+c02ffbc2 T _write_lock
+c02ffbc7 T _write_lock_bh
+c02ffbd7 T _write_lock_irq
+c02ffbdd T _write_lock_irqsave
+c02ffbea T _spin_lock
+c02ffbef T _spin_lock_bh
+c02ffbff T _read_lock_bh
+c02ffc0f T _read_lock
+c02ffc14 T _write_trylock
+c02ffc22 T _read_trylock
+c02ffc30 T _write_unlock_irqrestore
+c02ffc3c T _spin_lock_irq
+c02ffc42 T _read_lock_irq
+c02ffc48 T _spin_unlock_irq
+c02ffc4f T _read_unlock_irq
+c02ffc56 T _spin_lock_irqsave
+c02ffc63 T _read_lock_irqsave
+c02ffc70 T _spin_unlock_irqrestore
+c02ffc7c T _read_unlock_irqrestore
+c02ffc88 T unlock_kernel
+c02ffcb7 T lock_kernel
+c02ffcef T __release_kernel_lock
+c02ffd04 T __reacquire_kernel_lock
+c02ffd4a T __lock_text_end
+c02ffd50 T __kprobes_text_start
+c02ffd50 T page_fault
+c02ffd58 t error_code
+c02ffdd0 T debug
+c02ffde1 t debug_esp_fix_insn
+c02ffdf0 t debug_stack_correct
+c02ffe1c T nmi
+c02ffe4d t nmi_stack_correct
+c02ffe78 t nmi_stack_fixup
+c02ffe91 t nmi_debug_stack_check
+c02ffec4 t nmi_espfix_stack
+c02fff38 T int3
+c02fff64 T general_protection
+c02fff6e t do_trap
+c030002b T do_int3
+c0300097 T do_general_protection
+c030026d T die_nmi
+c0300345 T do_debug
+c0300418 T do_nmi
+c0300640 T nmi_watchdog_tick
+c03007a5 T arch_arm_kprobe
+c03007ac T arch_disarm_kprobe
+c03007b5 t restore_previous_kprobe
+c03007e7 t set_current_kprobe
+c0300828 t prepare_singlestep
+c0300848 T arch_prepare_kretprobe
+c0300856 T kretprobe_trampoline
+c0300856 T kretprobe_trampoline_holder
+c0300885 T arch_trampoline_kprobe
+c0300888 T kprobe_exceptions_notify
+c0300c1f T arch_remove_kprobe
+c0300c48 T arch_prepare_kprobe
+c0300d9d T longjmp_break_handler
+c0300e70 T trampoline_handler
+c0300fa3 T setjmp_pre_handler
+c030100e T jprobe_return
+c0301022 T jprobe_return_end
+c0301025 T do_page_fault
+c0301621 t notifier_call_chain
+c0301673 T __atomic_notifier_call_chain
+c030167a T atomic_notifier_call_chain
+c0301694 T get_kprobe
+c03016bc t aggr_fault_handler
+c03016ed t aggr_break_handler
+c0301730 T recycle_rp_inst
+c03017a1 T kretprobe_inst_table_head
+c03017b2 t add_new_kprobe
+c0301813 t kprobe_seq_start
+c0301825 t kprobe_seq_next
+c0301846 t kprobe_seq_stop
+c0301847 t debugfs_kprobe_init
+c03018c7 t kprobes_open
+c03018d3 t report_probe
+c0301965 t __register_kprobe
+c0301bce T register_jprobe
+c0301be4 T register_kprobe
+c0301bec T unregister_kprobe
+c0301d58 T unregister_kretprobe
+c0301dd6 T unregister_jprobe
+c0301ddb t collect_one_slot
+c0301e5e t collect_garbage_slots
+c0301eba T free_insn_slot
+c0301f39 T kprobes_inc_nmissed_count
+c0301f62 t show_kprobe_addr
+c0302028 T kprobe_flush_task
+c03020a8 t pre_handler_kretprobe
+c030213d t aggr_pre_handler
+c030219a t aggr_post_handler
+c03021ef T register_kretprobe
+c03022e5 T get_insn_slot
+c03023cd T __kprobes_text_end
+c03026e2 t iret_exc
+c0302fac T _etext
+c0302fb0 R __start___ex_table
+c0303eb8 R __start___bug_table
+c0303eb8 R __stop___ex_table
+c0308058 R __stop___bug_table
+c0308058 ? __tracedata_end
+c0308058 ? __tracedata_start
+c0309000 R __start_rodata
+c0309000 R linux_banner
+c0309080 R linux_proc_banner
+c0309100 r p.13756
+c0309140 r border
+c03091a0 r mask_bits
+c03091e0 r cplens
+c0309220 r cplext
+c0309260 r cpdist
+c03092a0 r cpdext
+c0309300 r p.13560
+c0309340 r border
+c03093a0 r mask_bits
+c03093e0 r cplens
+c0309420 r cplext
+c0309460 r cpdist
+c03094a0 r cpdext
+c03094dc r __func__.4939
+c03094ef r __func__.4978
+c0309520 R sys_call_table
+c0309a3c r __func__.12125
+c0309a47 r __func__.12034
+c0309b78 r noptypes
+c0309b90 r __func__.10528
+c0309bac r __func__.10500
+c0309bc8 r __func__.10418
+c0309be0 r x86_power_flags.8979
+c0309c20 r x86_cap_flags.8978
+c0309ff4 r types
+c0309ff7 r levels
+c030a000 r assocs
+c030a020 r __func__.8816
+c030a040 r mtrr_fops
+c030a0b0 r mtrr_strings
+c030a0e0 r fixed_range_blocks
+c030a100 r ccr_state
+c030a120 r arr_state
+c030a180 r __func__.18534
+c030a19e r __func__.18227
+c030a1b4 r C.254.18943
+c030a1c0 r C.253.18942
+c030a1cc r __func__.7759
+c030a1fc r __func__.23611
+c030a220 r twobyte_is_boostable.15580
+c030a2d8 r C.222.19038
+c030a2e8 r C.221.19036
+c030a2f8 r C.220.19034
+c030a308 r C.219.19032
+c030a318 r C.218.19030
+c030a328 r C.217.19024
+c030a338 r bases.4584
+c030a3a0 R proc_schedstat_operations
+c030a410 r __func__.32894
+c030a428 r __func__.32455
+c030a438 r __func__.32585
+c030a444 r stat_nam
+c030a44c r __func__.29958
+c030a45c r VLA_RSS
+c030a46c r __func__.26988
+c030a4c0 r proc_profile_operations
+c030a530 r __func__.18185
+c030a546 r __func__.29739
+c030a54e r __func__.18405
+c030a55e r __func__.18355
+c030a56f r __func__.18315
+c030a5a0 r proc_ioports_operations
+c030a620 r proc_iomem_operations
+c030a690 r resource_op
+c030a6a0 r __func__.13482
+c030a6b6 r __func__.20656
+c030a708 r __func__.27640
+c030a71c r C.296.24105
+c030a72c r __func__.11247
+c030a74f r __func__.10496
+c030a75c r __func__.10355
+c030a770 r C.182.16234
+c030a780 R space_mask
+c030a788 R vlimit_mask
+c030a794 r VLA_RSS
+c030a7bc r __func__.24911
+c030a7c8 r __func__.30572
+c030a7da r __func__.30505
+c030a7ec r __func__.30536
+c030a800 r type.29492
+c030a818 r VLA_RSS
+c030a89c r __func__.19818
+c030a8c0 r futex_fops
+c030a930 r __func__.19540
+c030a93e r __func__.19990
+c030a94c r __func__.19469
+c030a95c r __func__.19383
+c030a96b r __func__.19863
+c030a980 r __func__.19838
+c030a98e r __func__.19431
+c030a9a1 r __func__.10834
+c030a9b2 r __func__.10582
+c030a9c5 r __func__.10624
+c030a9e0 r proc_dma_operations
+c030aa50 r __func__.14655
+c030aa60 R modules_op
+c030aa80 r vermagic
+c030aac0 r masks.19173
+c030aae0 r modinfo_attrs
+c030ab00 r kallsyms_operations
+c030ab70 r kallsyms_op
+c030ab80 r pm_states
+c030ab90 r subsys
+c030ab98 r __func__.11838
+c030aba1 r __func__.11745
+c030abae r __func__.11715
+c030abb9 r __func__.11721
+c030abc6 r __func__.11701
+c030abda r __func__.11686
+c030abeb r __func__.11556
+c030ac00 R relay_file_operations
+c030ac98 r zone_names
+c030aca4 r __func__.21103
+c030acac r __func__.21016
+c030ad18 R fragmentation_op
+c030ad28 R zoneinfo_op
+c030ad38 R vmstat_op
+c030ad60 r vmstat_text
+c030ae14 r VLA_RSS
+c030ae84 r __func__.24288
+c030ae90 r VLA_RSS
+c030aea0 r __func__.17702
+c030aea9 r __func__.17471
+c030aeb8 r __func__.17384
+c030aee0 r swap_aops
+c030af20 r proc_swaps_operations
+c030af90 r swaps_op
+c030afa0 r Bad_file
+c030afb5 r Unused_offset
+c030afcf r Bad_offset
+c030afe6 r Unused_file
+c030affe r __func__.26545
+c030b020 r shmem_ops
+c030b080 r shmem_aops
+c030b0c0 r shmem_special_inode_operations
+c030b120 r shmem_inode_operations
+c030b180 r shmem_file_operations
+c030b200 r shmem_dir_inode_operations
+c030b260 r shmem_symlink_inline_operations
+c030b2c0 r shmem_symlink_inode_operations
+c030b368 R slabinfo_op
+c030b378 r __func__.19636
+c030b38b r __func__.19420
+c030b3a0 R generic_ro_fops
+c030b420 R def_chr_fops
+c030b4a0 R read_fifo_fops
+c030b520 R write_fifo_fops
+c030b5a0 R rdwr_fifo_fops
+c030b610 r anon_pipe_buf_ops
+c030b640 r read_pipe_fops
+c030b6c0 r write_pipe_fops
+c030b740 r rdwr_pipe_fops
+c030b7e0 R page_symlink_inode_operations
+c030b83c r band_table
+c030b854 r __func__.23953
+c030b860 R def_fifo_fops
+c030b8d0 r anonstring.25567
+c030b8dc r name.25542
+c030b900 r bad_inode_ops
+c030b960 r bad_file_ops
+c030b9d0 r __func__.26069
+c030ba00 R simple_dir_operations
+c030ba80 R simple_dir_inode_operations
+c030bae0 r simple_super_operations
+c030bb34 r __func__.17934
+c030bb46 r __func__.20012
+c030bb60 r user_page_pipe_buf_ops
+c030bb7c r page_cache_pipe_buf_ops
+c030bb98 r __func__.25270
+c030bbb2 r __func__.22237
+c030bbc7 r __func__.23711
+c030bbd9 r __func__.22845
+c030bbf1 r __func__.23536
+c030bc05 r __func__.22944
+c030bc1b r __func__.23097
+c030bc30 r __func__.22517
+c030bc3d r __func__.22560
+c030bc46 r __func__.20691
+c030bc60 R def_blk_aops
+c030bca0 R def_blk_fops
+c030bd20 r bdev_sops
+c030bd80 r revoked_special_file_ops
+c030be00 r revoked_file_ops
+c030be80 r revoked_aops
+c030bebc r __func__.14586
+c030bed3 r __func__.14673
+c030bf00 r inotify_fops
+c030bf70 r inotify_user_ops
+c030bf80 r eventpoll_fops
+c030c000 r signalfd_fops
+c030c080 r eventfd_fops
+c030c100 r s_ops
+c030c160 r bm_entry_operations
+c030c1e0 r bm_status_operations
+c030c260 r bm_register_operations
+c030c2d0 r buf.25804
+c030c2ec r quotatypes
+c030c2f8 r module_names
+c030c310 r quota_versions.11846
+c030c318 r quota_magics.11845
+c030c360 R proc_maps_operations
+c030c3e0 R proc_smaps_operations
+c030c460 R proc_clear_refs_operations
+c030c4e0 R proc_pagemap_operations
+c030c560 r proc_sops
+c030c5c0 r proc_root_inode_operations
+c030c620 r proc_root_operations
+c030c6a0 r proc_base_stuff
+c030c6c0 r proc_tgid_base_inode_operations
+c030c720 r proc_tgid_base_operations
+c030c7a0 r tgid_base_stuff
+c030ca20 r proc_pid_link_inode_operations
+c030ca80 r proc_fdinfo_file_operations
+c030cb00 r proc_tid_base_inode_operations
+c030cb60 r proc_tid_base_operations
+c030cbe0 r tid_base_stuff
+c030ce00 r proc_def_inode_operations
+c030ce60 r proc_self_inode_operations
+c030cec0 r proc_task_inode_operations
+c030cf20 r proc_task_operations
+c030cfa0 r proc_fd_inode_operations
+c030d000 r proc_fd_operations
+c030d080 r proc_fdinfo_inode_operations
+c030d0e0 r proc_fdinfo_operations
+c030d160 r proc_info_file_operations
+c030d1e0 r proc_mem_operations
+c030d260 r proc_mounts_operations
+c030d2e0 r proc_mountstats_operations
+c030d360 r proc_oom_adjust_operations
+c030d3e0 r proc_coredump_filter_operations
+c030d460 r __func__.17467
+c030d480 r proc_dir_operations
+c030d500 r proc_dir_inode_operations
+c030d560 r proc_link_inode_operations
+c030d5c0 r proc_file_operations
+c030d640 r proc_file_inode_operations
+c030d6a0 r proc_tty_drivers_operations
+c030d720 r proc_devinfo_operations
+c030d7a0 r proc_cpuinfo_operations
+c030d820 r proc_partitions_operations
+c030d8a0 r proc_stat_operations
+c030d920 r proc_interrupts_operations
+c030d9a0 r proc_slabinfo_operations
+c030da20 r fragmentation_file_operations
+c030daa0 r proc_vmstat_file_operations
+c030db20 r proc_zoneinfo_file_operations
+c030dba0 r proc_diskstats_operations
+c030dc20 r proc_modules_operations
+c030dca0 r proc_sysrq_trigger_operations
+c030dd20 r proc_sys_file_operations
+c030dda0 r proc_net_dir_operations
+c030de20 R proc_kcore_operations
+c030dea0 R proc_vmcore_operations
+c030df20 R proc_kmsg_operations
+c030dfa0 r block_str.20512
+c030dfa4 r check_part
+c030dfc0 r subtypes
+c030e000 r sysfs_aops
+c030e040 r sysfs_inode_operations
+c030e0a0 R sysfs_file_operations
+c030e110 r __func__.14993
+c030e120 R sysfs_dir_inode_operations
+c030e180 R sysfs_dir_operations
+c030e1f0 r __func__.12013
+c030e1fc r C.128.12158
+c030e220 R sysfs_symlink_inode_operations
+c030e27c r __func__.11934
+c030e2a0 r sysfs_ops
+c030e2f4 r __func__.17687
+c030e320 R bin_fops
+c030e390 r __func__.12175
+c030e39a r __func__.12370
+c030e3b0 r __func__.8338
+c030e3c0 r devpts_sops
+c030e420 r __func__.20488
+c030e430 r __func__.20365
+c030e44e r __func__.20017
+c030e462 r __func__.19950
+c030e480 R ext3_dir_operations
+c030e4f0 r ext3_filetype_table
+c030e500 R ext3_file_operations
+c030e580 R ext3_file_inode_operations
+c030e5dc r __func__.19546
+c030e5eb r __func__.20509
+c030e5fb r __func__.20384
+c030e60a r __func__.20161
+c030e620 r __func__.22661
+c030e63f r __func__.22646
+c030e650 r __func__.22625
+c030e669 r __func__.22385
+c030e67e r __func__.22516
+c030e68b r __func__.22236
+c030e69b r __func__.21994
+c030e6a9 r __func__.20754
+c030e6bb r __func__.21780
+c030e6d4 r __func__.21233
+c030e6e3 r __func__.21928
+c030e6f2 r __func__.21905
+c030e704 r __func__.21947
+c030e720 r ext3_ordered_aops
+c030e760 r ext3_writeback_aops
+c030e7a0 r ext3_journalled_aops
+c030e7dc r __func__.21484
+c030e7f9 r __func__.21398
+c030e809 r __func__.21618
+c030e823 r __func__.21338
+c030e83f r __func__.21449
+c030e85b r __func__.21591
+c030e874 r __func__.21720
+c030e883 r __func__.21687
+c030e894 r __func__.21418
+c030e8ae r __func__.21361
+c030e8c1 r __func__.21557
+c030e8d8 r __func__.21391
+c030e8f0 r __func__.21261
+c030e8fc r __func__.21151
+c030e913 r __func__.21014
+c030e925 r __func__.21087
+c030e938 r __func__.20786
+c030e94a r __func__.20724
+c030e956 r __func__.19512
+c030e980 R ext3_dir_inode_operations
+c030e9e0 R ext3_special_inode_operations
+c030ea3c r __func__.22336
+c030ea48 r __func__.22000
+c030ea52 r __func__.21689
+c030ea64 r __func__.20768
+c030ea6d r __func__.21064
+c030ea7d r __func__.21408
+c030ea86 r __func__.21559
+c030ea97 r __func__.20575
+c030eaa3 r __func__.21483
+c030eab5 r ext3_type_by_mode
+c030eac4 r __func__.21163
+c030ead4 r __func__.21230
+c030eae7 r __func__.21775
+c030eaf9 r __func__.21873
+c030eb04 r __func__.22142
+c030eb0f r __func__.21931
+c030eb1a r __func__.22228
+c030eb27 r __func__.22183
+c030eb33 r __func__.22299
+c030eb3d r __func__.21820
+c030eb49 r __func__.22104
+c030eb59 r __func__.22058
+c030ec40 r ext3_sops
+c030ec94 r __func__.23585
+c030eca4 r __func__.23543
+c030ecb7 r __func__.23509
+c030ecca r __func__.23484
+c030ecdb r __func__.23455
+c030eceb r __func__.23421
+c030ed01 r __func__.23700
+c030ed12 r __func__.23284
+c030ed1f r __func__.23203
+c030ed36 r __func__.21998
+c030ed45 r __func__.22513
+c030ed59 r __func__.21930
+c030ed71 r __func__.21786
+c030eda0 R ext3_symlink_inode_operations
+c030ee00 R ext3_fast_symlink_inode_operations
+c030ee5c r __func__.20099
+c030ee6e r __func__.19933
+c030ee7d r __func__.19992
+c030ee8c r __func__.19449
+c030ee9f r __func__.19574
+c030eeb6 r __func__.19518
+c030eebd r __func__.19832
+c030eed0 r __func__.19691
+c030eee4 r __func__.19730
+c030ef00 r __func__.19486
+c030ef20 r __func__.19477
+c030ef41 r __func__.19468
+c030ef57 r __func__.19458
+c030ef80 r __func__.19449
+c030efa0 r __func__.19440
+c030efc0 r __func__.20928
+c030efd8 r __func__.20438
+c030eff1 r __func__.20909
+c030f000 r __func__.20846
+c030f016 r __func__.20613
+c030f02c r __func__.20652
+c030f041 r __func__.21034
+c030f057 r __func__.20417
+c030f078 r ext3_xattr_handler_map
+c030f094 r __func__.20345
+c030f0aa r __func__.20212
+c030f0bf r __func__.20008
+c030f0d2 r __func__.19903
+c030f148 r __func__.19477
+c030f160 r __func__.19255
+c030f17d r __func__.19419
+c030f193 r __func__.19397
+c030f1aa r __func__.19361
+c030f1bf r __func__.19321
+c030f1db r __func__.19176
+c030f1e8 r __func__.19149
+c030f1f7 r __func__.19112
+c030f20e r __func__.19082
+c030f221 r __func__.19058
+c030f239 r __func__.18962
+c030f24d r __func__.19033
+c030f267 r __func__.18927
+c030f27e r __func__.18893
+c030f28e r __func__.18796
+c030f2a0 r __func__.18772
+c030f2b0 r __func__.18848
+c030f2be r __func__.18900
+c030f2d9 r __func__.18937
+c030f2e5 r __func__.19007
+c030f300 r __func__.18990
+c030f31c r __func__.18925
+c030f331 r __func__.18872
+c030f342 r __func__.18932
+c030f351 r __func__.18906
+c030f368 r __func__.18862
+c030f380 r __func__.20241
+c030f3a0 r __func__.20249
+c030f3c3 r __func__.20338
+c030f3dc r __func__.20315
+c030f3fa r __func__.20287
+c030f413 r __func__.20263
+c030f42e r __func__.20105
+c030f43b r __func__.19712
+c030f452 r __func__.20081
+c030f460 r __func__.19885
+c030f470 r jbd_slab_names
+c030f484 r __func__.19599
+c030f493 r __func__.19517
+c030f4a6 r __func__.19458
+c030f4ba r __func__.19489
+c030f4cb r __func__.19425
+c030f4d8 r __func__.19406
+c030f4ef r __func__.19269
+c030f520 r __func__.19027
+c030f560 R ext2_dir_operations
+c030f5d0 r __func__.18132
+c030f5dd r __func__.18481
+c030f5ec r ext2_type_by_mode
+c030f5fb r __func__.18399
+c030f60d r __func__.18319
+c030f61b r __func__.18212
+c030f640 R ext2_file_operations
+c030f6c0 R ext2_xip_file_operations
+c030f740 R ext2_file_inode_operations
+c030f7a0 R ext2_aops
+c030f7e0 R ext2_aops_xip
+c030f820 R ext2_nobh_aops
+c030f860 R ext2_dir_inode_operations
+c030f8c0 R ext2_special_inode_operations
+c030f9a0 r ext2_sops
+c030f9f4 r __func__.21061
+c030fa04 r __func__.21436
+c030fa11 r __func__.20653
+c030fa40 R ext2_symlink_inode_operations
+c030faa0 R ext2_fast_symlink_inode_operations
+c030fafc r ext2_xattr_handler_map
+c030fb18 r __func__.18778
+c030fb40 r cramfs_ops
+c030fba0 r cramfs_aops
+c030fbe0 r cramfs_dir_inode_operations
+c030fc40 r cramfs_directory_operations
+c030fcc0 r ramfs_ops
+c030fd20 r ramfs_dir_inode_operations
+c030fd80 R ramfs_aops
+c030fdc0 R ramfs_file_operations
+c030fe40 R ramfs_file_inode_operations
+c030ff00 r isofs_sops
+c030ff60 r isofs_aops
+c030ffa0 R isofs_dir_operations
+c0310020 R isofs_dir_inode_operations
+c0310080 r C.220.18441
+c03100c0 R isofs_symlink_aops
+c0310100 R zisofs_aops
+c0310140 r charset2uni
+c0310340 r page_uni2charset
+c0310740 r charset2uni
+c0310940 r page_uni2charset
+c0310d40 r charset2uni
+c0310f40 r page_uni2charset
+c0311340 R debugfs_file_operations
+c03113c0 R debugfs_link_operations
+c0311420 r fops_blob
+c03114a0 r fops_bool
+c0311520 r sysvipc_proc_fops
+c0311620 r shm_file_operations
+c03116a0 r mqueue_file_operations
+c0311720 r mqueue_dir_inode_operations
+c031177c r oflag2acc.28602
+c0311788 r __func__.18913
+c031178f r __func__.18835
+c03117a0 r __func__.20278
+c03117b1 r __func__.20184
+c03117bc r __func__.23248
+c03117d8 r C.355.22660
+c03117e8 r __func__.22637
+c03117fe r __func__.22109
+c031180e r __func__.22034
+c031181e r __func__.22008
+c031182e r __func__.21471
+c0311848 r __func__.21431
+c031185c r __func__.21398
+c031186e r __func__.21300
+c031187b r __func__.21228
+c0311896 r __func__.21149
+c03118b1 r __func__.21140
+c03118cb r __func__.21131
+c03118e7 r __func__.21121
+c03118fd r __func__.21037
+c031190c r __func__.20189
+c031191e R scsi_command_size
+c0311928 r __func__.19529
+c0311937 r __func__.20449
+c0311949 r __func__.20410
+c031195e r __func__.20697
+c0311974 r __func__.20007
+c0311988 r __func__.19836
+c031199f r __func__.19849
+c03119b2 r __func__.20086
+c03119c4 r C.304.21178
+c03119e0 r blk_dropped_fops
+c0311a50 r __func__.7934
+c0311a65 r __func__.7800
+c0311a8c r __func__.7720
+c0311a95 r __func__.7708
+c0311aa0 r __func__.7936
+c0311ac0 r large_digits.7862
+c0311b00 r small_digits.7861
+c0311b40 r __func__.15710
+c0311b4e r __func__.15861
+c0311b5b r __func__.15789
+c0311b6d r __func__.15749
+c0311b7a r __func__.4131
+c0311ba0 R byte_rev_table
+c0311ca0 r crc32table_be
+c03120a0 r crc32table_le
+c0312520 r order.2234
+c0312560 r distfix.2170
+c03125e0 r lenfix.2169
+c0312de0 r dext.2094
+c0312e20 r dbase.2093
+c0312e60 r lext.2092
+c0312ea0 r lbase.2091
+c0312ee0 r __func__.18389
+c0312efc r __func__.16450
+c0312f0c r __func__.16434
+c0312f1f r __func__.16160
+c0312f6c r __func__.18382
+c0312f84 r __func__.18364
+c0312f97 r __func__.18950
+c0312fa8 r __func__.18927
+c0312fb6 r __func__.18898
+c0312fcd r __func__.18852
+c0312fdc r __func__.18805
+c0312fec r __func__.18762
+c0312ff9 r __func__.18730
+c0313020 r proc_bus_pci_dev_operations
+c03130a0 r proc_bus_pci_operations
+c0313120 r __func__.15859
+c0313136 r C.225.15879
+c0313160 r __func__.16197
+c0313173 r device_name
+c03131a0 r port_pci_ids
+c03131e0 r aer_error_severity_string
+c03131ec r aer_error_layer
+c03131f8 r aer_agent_string
+c0313220 r aer_correctable_error_string
+c03132a0 r aer_uncorrectable_error_string
+c0313320 r __func__.22020
+c0313329 r __func__.21963
+c031333c r __func__.18762
+c0313348 r C.229.18734
+c0313358 r __func__.19436
+c0313368 r __func__.19320
+c0313378 r state_conv.19225
+c03133a0 R dummy_con
+c0313440 R vga_con
+c03134e4 r mps_inti_flags_trigger
+c03134f4 r mps_inti_flags_polarity
+c031355c r _acpi_module_name
+c0313560 r _acpi_module_name
+c0313564 r _acpi_module_name
+c03135ac r _acpi_module_name
+c03135c0 r acpi_gbl_op_type_dispatch
+c03135f0 r _acpi_module_name
+c03135f4 r _acpi_module_name
+c03135f8 r _acpi_module_name
+c03135fc r _acpi_module_name
+c031363c r _acpi_module_name
+c0313640 r _acpi_module_name
+c0313644 r _acpi_module_name
+c0313648 r _acpi_module_name
+c031366c r _acpi_module_name
+c0313670 r acpi_gbl_default_address_spaces
+c0313674 r _acpi_module_name
+c0313678 r _acpi_module_name
+c031367c r _acpi_module_name
+c0313680 r _acpi_module_name
+c0313684 r _acpi_module_name
+c0313688 r _acpi_module_name
+c031368c r _acpi_module_name
+c0313690 r _acpi_module_name
+c0313694 r _acpi_module_name
+c03136b0 r _acpi_module_name
+c03136fc r _acpi_module_name
+c031371c r _acpi_module_name
+c0313720 r _acpi_module_name
+c031374c r _acpi_module_name
+c0313768 r _acpi_module_name
+c03137c4 r _acpi_module_name
+c03137c8 r _acpi_module_name
+c03137cc r _acpi_module_name
+c0313808 r _acpi_module_name
+c031380c r _acpi_module_name
+c0313810 r _acpi_module_name
+c0313814 r _acpi_module_name
+c0313818 r _acpi_module_name
+c031381c r _acpi_module_name
+c0313820 r _acpi_module_name
+c0313878 r _acpi_module_name
+c031387c r _acpi_module_name
+c0313880 r _acpi_module_name
+c03138cc r _acpi_module_name
+c03138d0 r _acpi_module_name
+c03138d4 r _acpi_module_name
+c03138d8 r _acpi_module_name
+c03138dc r _acpi_module_name
+c03138e0 r _acpi_module_name
+c03138e4 r _acpi_module_name
+c03138e8 r _acpi_module_name
+c03138ec r _acpi_module_name
+c03138f0 r _acpi_module_name
+c031398c r _acpi_module_name
+c03139b4 r _acpi_module_name
+c03139b8 r _acpi_module_name
+c03139bc r _acpi_module_name
+c03139c0 R acpi_gbl_aml_op_info
+c03141c0 r acpi_gbl_short_op_index
+c03142c0 r acpi_gbl_long_op_index
+c031434c r _acpi_module_name
+c0314350 R acpi_gbl_aml_resource_sizes
+c0314361 R acpi_gbl_resource_struct_sizes
+c0314380 r _acpi_module_name
+c0314428 r _acpi_module_name
+c0314454 r _acpi_module_name
+c0314460 r _acpi_module_name
+c0314464 r _acpi_module_name
+c0314468 r _acpi_module_name
+c0314480 r _acpi_module_name
+c03144a0 r fadt_info_table
+c03144e0 r _acpi_module_name
+c0314500 r acpi_interfaces_supported
+c0314520 r _acpi_module_name
+c0314524 r _acpi_module_name
+c0314528 r _acpi_module_name
+c031452c r _acpi_module_name
+c03145a8 r _acpi_module_name
+c03145c0 R acpi_gbl_pre_defined_names
+c0314638 R acpi_gbl_ns_properties
+c0314657 r acpi_gbl_bad_type
+c0314680 r acpi_gbl_desc_type_names
+c03146c0 r acpi_gbl_ns_type_names
+c031473c r acpi_gbl_event_types
+c0314750 r acpi_gbl_hex_to_ascii
+c0314760 r _acpi_module_name
+c0314764 r _acpi_module_name
+c0314768 r _acpi_module_name
+c031476c r _acpi_module_name
+c0314770 r _acpi_module_name
+c0314774 R acpi_gbl_resource_aml_sizes
+c0314790 r acpi_gbl_resource_types
+c03147ac r __func__.15813
+c03147bc r __func__.18272
+c03147c8 r _acpi_module_name
+c03147e8 r __func__.16443
+c03147fc r _acpi_module_name
+c0314800 r _acpi_module_name
+c0314804 r _acpi_module_name
+c0314808 r _acpi_module_name
+c031480c r _acpi_module_name
+c0314820 r acpi_power_fops
+c03148a0 r acpi_system_event_ops
+c0314920 r xtab.8829
+c0314940 r xtab.8872
+c0314960 r pnp_dev_table
+c0314aa0 r memory_fops
+c0314b20 r devlist
+c0314bc0 r mem_fops
+c0314c40 r kmem_fops
+c0314cc0 r null_fops
+c0314d40 r port_fops
+c0314dc0 r zero_fops
+c0314e40 r full_fops
+c0314ec0 r kmsg_fops
+c0314f40 r oldmem_fops
+c0314fc0 R random_fops
+c0315040 R urandom_fops
+c03150c0 r twist_table.16590
+c0315180 r tty_fops
+c0315200 r console_fops
+c0315280 r ptmx_fops
+c0315300 r hung_up_tty_fops
+c0315370 r __func__.19333
+c0315380 r __func__.21266
+c0315390 r ptychar
+c03153c0 r baud_table
+c0315440 r baud_bits
+c03154c0 r pty_ops
+c0315520 r misc_proc_fops
+c03155a0 r misc_fops
+c0315620 r vcs_fops
+c0315700 R max_vals
+c031573c R NR_TYPES
+c0315740 r k_handler
+c0315780 r cur_chars.18837
+c0315785 r ret_diacr.18814
+c031578b r app_map.18851
+c03157a1 r pad_chars.18850
+c03157c0 r fn_handler
+c0315820 r x86_keycodes
+c0315a20 r kbd_ids
+c0315e1c r __func__.19550
+c0315e27 r __func__.19583
+c0315e33 r __func__.21603
+c0315e3f r __func__.21623
+c0315e4c r __func__.21579
+c0315e61 r __func__.21536
+c0315e73 r __func__.21502
+c0315ea0 r con_ops
+c0315f00 r utf8_length_changes.20654
+c0315f20 r double_width.20625
+c0315f80 r __func__.19836
+c0315f8e r __func__.19751
+c0315f98 r __func__.19688
+c0315fa4 r __func__.19624
+c0315fb2 r __func__.19352
+c0315fc1 r __func__.19292
+c0315fcf r __func__.19193
+c0315fe0 r rtc_proc_fops
+c0316050 r days_in_mo
+c0316060 r rtc_fops
+c03160e0 r __func__.21009
+c03160ea r __func__.21494
+c03160f8 r __func__.21454
+c0316107 r __func__.21376
+c0316120 r hpet_fops
+c03161a0 r rng_chrdev_ops
+c0316220 r pci_tbl
+c03165c0 r uart_ops
+c0316620 r __func__.17092
+c0316632 r __func__.17029
+c0316640 r baud_rates
+c03166e0 r old_serial_port
+c0316760 r uart_config
+c0316880 r pnp_dev_table
+c0316fa0 r timedia_data
+c0316fc0 r timedia_single_port
+c0316fe0 r timedia_dual_port
+c0317020 r timedia_quad_port
+c031704e r timedia_eight_port
+c0317068 r __func__.17007
+c0317080 r __func__.8634
+c031708f r __func__.8863
+c031709e r __func__.8775
+c03170b0 r __func__.11133
+c03170bd r __func__.11088
+c03170ca r __func__.8774
+c03170dc r __func__.8765
+c03170e7 r __func__.8721
+c03170fc r __func__.8699
+c0317110 r __func__.8680
+c0317123 r __func__.8557
+c0317137 r __func__.8517
+c0317146 r enabled
+c031714e r disabled
+c0317157 r __func__.14771
+c0317174 r __func__.14740
+c031718a r __func__.14671
+c0317195 r __func__.14709
+c03171a8 r __func__.17312
+c03171c0 r __func__.12050
+c03171d4 r __func__.12008
+c03171ef r __func__.11955
+c0317201 r __func__.11935
+c0317211 r __func__.11775
+c0317240 r firmware_attr_data_tmpl
+c0317260 r __func__.11910
+c0317273 r __func__.11831
+c03172a0 r ramdisk_aops
+c03172e0 r loopback_ethtool_ops
+c031737c r __func__.23388
+c03173a0 r aec6xxx_33_base
+c03173e0 r aec6xxx_34_base
+c0317410 r C.309.22445
+c0317420 r amd_cyc2udma
+c0317430 r amd_dma
+c0317444 r mdma_timing
+c031744a r pio_timing
+c0317460 r cmd64x_chipsets
+c0317540 r drwtim_regs.22235
+c0317544 r recovery_values.22234
+c0317555 r arttim_regs.22263
+c0317559 r setup_values.22262
+c0317560 r cs5520_pio_clocks
+c03175a0 r cs5530_pio_timings
+c03175c8 r cs5535_pio_cmd_timings
+c03175dc r cs5535_pio_dta_timings
+c03175f0 r cs5535_udma_timings
+c0317604 r cs5535_mwdma_timings
+c0317610 r chipset_names.22325
+c0317618 r C.291.22283
+c0317628 r C.290.22282
+c0317640 r hpt366_chipsets
+c0317790 r __func__.22472
+c03177a7 r __func__.22540
+c03177bf r xfer_speeds
+c03177d0 r info.22928
+c03177ec r chipset_names.22927
+c0317808 r pio_want.22324
+c031780e r pio.22323
+c0317818 r mwdma_want.22362
+c031781c r dma.22361
+c0317822 r udma_want.22396
+c031782a r udma.22395
+c0317838 r mode.22599
+c0317840 r udma_timings
+c0317855 r mwdma_timings
+c031785b r pio_timings
+c031786a r timings.22255
+c0317874 r drive_pci2.22282
+c0317878 r drive_pci.22281
+c031787c r pio_modes.22280
+c0317881 r dma_modes.22279
+c0317884 r udma_modes.22278
+c031788a r __func__.22512
+c03178a8 r C.296.22409
+c03178af r __func__.22595
+c0317900 r cycle_time_value
+c0317940 r cvs_time_value
+c0317978 r cycle_time_range
+c031797f r cycle_time_offset
+c03179a0 r ini_time_value
+c03179e0 r act_time_value
+c0317a20 r rco_time_value
+c0317a60 r SiSHostChipInfo
+c0317b40 r chipset_capability
+c0317b60 r timings.22250
+c0317bd8 r via_dma
+c0317c90 r ide_hwif_to_major
+c0317ca0 r C.323.23602
+c0317cdc r hex.23501
+c0317ce0 r decimal.23500
+c0317ce4 r C.320.23911
+c0317d40 R ide_pio_timings
+c0317d88 r __func__.23032
+c0317d96 r __func__.22518
+c0317da4 r __func__.22683
+c0317dbf r __func__.22670
+c0317dd2 r __func__.22572
+c0317de0 r __func__.22548
+c0317ded r ven_dev.22319
+c0317df1 r arttim_regs
+c0317df5 r drwtim_regs
+c0317df9 r prefetch_regs
+c0317dfd r prefetch_masks
+c0317e04 r __func__.22639
+c0317e14 r ata_index.22487
+c0317e20 r __func__.22571
+c0317e33 r xfer_mode_bases
+c0317e40 r drive_whitelist
+c0317e80 r drive_blacklist
+c0317f78 r __func__.18176
+c0317fbc r __func__.25023
+c0317fe0 r sense_key_texts
+c0318020 r sense_data_texts
+c0318420 r packet_command_texts
+c03186f0 r mrw_format_status
+c0318700 r __func__.18205
+c0318728 r __func__.17896
+c0318738 r __func__.17485
+c0318747 r __func__.16294
+c0318755 r usb2_rh_dev_descriptor
+c0318767 r usb11_rh_dev_descriptor
+c0318779 r hs_rh_config_descriptor
+c0318792 r fs_rh_config_descriptor
+c03187ab r __func__.20011
+c03187b9 r __func__.19859
+c03187e0 r usb_fops
+c0318850 r pool_max
+c0318860 R usbdev_file_operations
+c03188d0 r __func__.25200
+c03188dd r __func__.18071
+c0318900 r usb_quirk_list
+c0318950 r __func__.19787
+c03189c0 r default_file_operations
+c0318a40 R usbfs_devices_fops
+c0318ab0 r format_topo
+c0318ab4 r format_bandwidth
+c0318ab8 r format_device1
+c0318abc r format_device2
+c0318ac0 r clas_info
+c0318b38 r format_string_manufacturer
+c0318b3c r format_string_product
+c0318b40 r format_string_serialnumber
+c0318b44 r format_config
+c0318b48 r format_iface
+c0318b4c r format_endpt
+c0318b50 r bias_names
+c0318b5c r __func__.16147
+c0318b68 r keyboard_ids.16111
+c0318b6e r __func__.16085
+c0318c40 r input_fops
+c0318cc0 r input_devices_fileops
+c0318d40 r input_handlers_fileops
+c0318db0 r __func__.17938
+c0318dc9 r __func__.17869
+c0318e00 r mousedev_imex_seq
+c0318e06 r mousedev_imps_seq
+c0318e20 r mousedev_fops
+c0318ea0 r mousedev_ids
+c0319180 r evdev_fops
+c0319200 r evdev_ids
+c0319300 r atkbd_unxlate_table
+c0319380 r atkbd_scroll_keys
+c031938e r delay.16438
+c03193a0 r period.16437
+c03193e0 r xl_table
+c0319400 r psmouse_protocols
+c0319508 r seq.16579
+c0319511 r __func__.16634
+c031952a r rates.16699
+c0319532 r params.16685
+c0319537 r oldabs_rslt.16585
+c031953c r oldabs_mask.16584
+c0319541 r newabs_rslt.16583
+c0319546 r newabs_rel_mask.16582
+c031954b r newabs_mask.16581
+c0319560 r alps_model_data
+c03195c0 r rates.16266
+c03195e0 r ps2pp_list.16284
+c0319680 r params.16314
+c03196c0 r super_types
+c0319700 r md_seq_fops
+c0319770 r __func__.21913
+c0319780 r _name
+c0319784 r __func__.22079
+c031978c r _claim_ptr.20300
+c03197a0 r _ioctls.21363
+c0319820 r _ctl_fops
+c0319890 r __func__.20325
+c0319898 r __func__.20356
+c03198c0 r fields.17392
+c03198e4 r var_subsys_attrs
+c03198f0 r efi_subsys_attrs
+c03198f8 r __func__.14447
+c0319964 r __func__.15602
+c031996e r __func__.15580
+c0319978 r dispatch_type.15501
+c0319a80 r hid_keyboard
+c0319b80 r hid_hat_to_axis
+c0319be0 r hid_types
+c0319c04 r __func__.18059
+c0319c12 r __func__.19045
+c0319c40 r hid_blacklist
+c031a178 r pirqmap.22008
+c031a18c r pirqmap.21997
+c031a1a0 r pirqmap.22030
+c031a1a4 r pirqmap.22018
+c031a1a8 r irqmap.21950
+c031a1b8 r irqmap.21938
+c031a240 R bad_sock_fops
+c031a2b0 r nargs
+c031a2e0 r socket_file_ops
+c031a480 r proto_seq_fops
+c031a4f0 r proto_seq_ops
+c031a500 r mask.35512
+c031a50b r mask.35509
+c031a51b r __func__.24663
+c031a527 r __func__.34895
+c031a52f r __func__.19946
+c031a53a r __func__.31045
+c031a546 r __func__.25169
+c031a560 r __func__.31215
+c031a580 r dev_seq_fops
+c031a600 r softnet_seq_fops
+c031a680 r ptype_seq_fops
+c031a6f0 r ptype_seq_ops
+c031a700 r softnet_seq_ops
+c031a710 r dev_seq_ops
+c031a720 r __func__.30948
+c031a735 r __func__.29404
+c031a860 r dev_mc_seq_fops
+c031a8d0 r dev_mc_seq_ops
+c031a920 r nl_neightbl_policy
+c031a960 r nl_ntbl_parm_policy
+c031a9a0 r __func__.17006
+c031a9c0 r neigh_stat_seq_fops
+c031aa30 r neigh_stat_seq_ops
+c031aa40 r __func__.22819
+c031aaa0 r rta_max
+c031aae0 r rtm_min
+c031ab20 r ifla_policy
+c031ab6c r ifla_info_policy
+c031ab7c r __func__.19449
+c031ab87 r __func__.30893
+c031ab94 r __func__.30949
+c031aba1 r __func__.26523
+c031abb7 r __func__.28241
+c031abc8 r fmt_dec
+c031abcc r fmt_ulong
+c031abd1 r fmt_hex
+c031abd8 r operstates
+c031abf4 r fmt_long_hex
+c031abfa r __func__.26400
+c031ac08 r net_shadow_dir_operations
+c031ac10 r __func__.17361
+c031ac1b r __func__.26262
+c031ac40 r prio2band
+c031ac60 r psched_fops
+c031acd0 r __func__.19607
+c031acdb r __func__.19607
+c031ad00 r netlink_seq_fops
+c031ad80 r netlink_ops
+c031add4 r __func__.25764
+c031ae04 r __func__.16912
+c031ae10 r ctrl_policy
+c031ae40 r nflog_file_ops
+c031aec0 r nfqueue_file_ops
+c031af40 r __func__.25305
+c031af60 r rt_cache_seq_fops
+c031afe0 r rt_cpu_seq_fops
+c031b050 r rt_cpu_seq_ops
+c031b060 r rt_cache_seq_ops
+c031b070 r __func__.17296
+c031b07c r mtu_plateau
+c031b090 r __func__.24497
+c031b09c r __func__.25163
+c031b0a8 r __func__.19772
+c031b234 r __func__.24685
+c031b240 R inet_csk_timer_bug_msg
+c031b263 r __func__.24675
+c031b2d4 r __func__.25963
+c031b2e0 r new_state
+c031b2f0 r __func__.20260
+c031b344 r __func__.34563
+c031b34c r __func__.16989
+c031b357 r __func__.24510
+c031b363 r __func__.24613
+c031b380 r __func__.31848
+c031b3a3 r __func__.24692
+c031b3c0 r __func__.24795
+c031b3d1 r __func__.24536
+c031b3e0 r raw_seq_fops
+c031b450 r raw_seq_ops
+c031b460 r __func__.25109
+c031b471 r __func__.24850
+c031b47d r __func__.24845
+c031b48e r __func__.28515
+c031b4a0 r __func__.25188
+c031b4c0 r arp_seq_fops
+c031b530 r arp_seq_ops
+c031b540 r icmp_pointers
+c031b670 r __func__.25417
+c031b6cc r __func__.30186
+c031b6d6 r __func__.19535
+c031b700 r ifa_ipv4_policy
+c031b720 R inet_stream_ops
+c031b780 R inet_dgram_ops
+c031b7d4 r __func__.35823
+c031b7eb r __func__.25447
+c031b800 r inet_sockraw_ops
+c031b860 r igmp_mc_seq_fops
+c031b8e0 r igmp_mcf_seq_fops
+c031b950 r igmp_mcf_seq_ops
+c031b960 r igmp_mc_seq_ops
+c031b970 r __func__.25098
+c031b9c0 R rtm_ipv4_policy
+c031ba00 r __func__.17084
+c031ba20 r fib_props
+c031ba80 r __func__.32407
+c031baa0 r fib_seq_fops
+c031bb10 r fib_seq_ops
+c031bb20 r type2flags.32931
+c031bb60 r netstat_seq_fops
+c031bbe0 r snmp_seq_fops
+c031bc60 r sockstat_seq_fops
+c031bce0 r snmp4_ipstats_list
+c031bd80 r snmp4_icmp_list
+c031be60 r snmp4_tcp_list
+c031bee0 r snmp4_udp_list
+c031bf20 r snmp4_net_list
+c031c140 r snmp4_ipextstats_list
+c031c180 r fib4_rule_policy
+c031c1c4 r __func__.23409
+c031c1e0 r v.31755
+c031c220 r __func__.24844
+c031c22c r __func__.25019
+c031c238 r __func__.25019
+c031c244 r __func__.24957
+c031c250 r __func__.31621
+c031c261 r __func__.31899
+c031c274 r xfrm_calg_list
+c031c284 r xfrm_ealg_list
+c031c294 r xfrm_aalg_list
+c031c2c0 r __func__.27922
+c031c2e0 r unix_seq_fops
+c031c360 r unix_stream_ops
+c031c3c0 r unix_dgram_ops
+c031c420 r unix_seqpacket_ops
+c031c474 r __func__.24799
+c031c4a0 R inet6_stream_ops
+c031c500 R inet6_dgram_ops
+c031c560 r inet6_sockraw_ops
+c031c5c0 r ac6_seq_fops
+c031c630 r __func__.24469
+c031c63c r __func__.24532
+c031c648 r __func__.17006
+c031c688 R in6addr_any
+c031c698 R in6addr_loopback
+c031c6a8 r __func__.24689
+c031c6b4 r __func__.35853
+c031c6c5 r __func__.17006
+c031c6e0 r ifa_ipv6_policy
+c031c700 r __func__.35821
+c031c712 r __func__.36098
+c031c740 r if6_fops
+c031c7b0 r __func__.36181
+c031c7e0 r __func__.24896
+c031c800 r rt6_stats_seq_fops
+c031c880 r rtm_ipv6_policy
+c031c8c0 r __func__.17025
+c031c8cb r __func__.35420
+c031c8dc r C.510.34697
+c031c8e8 r C.484.34261
+c031c8f4 r C.425.29285
+c031cb18 r __func__.24756
+c031cb38 r __func__.29905
+c031cb45 r __func__.24695
+c031cb51 r __func__.30154
+c031cb5f r __func__.30520
+c031cb76 r __func__.30749
+c031cb8a r __func__.24940
+c031cb9b r __func__.24681
+c031cba7 r __func__.24845
+c031cbb8 r __func__.29281
+c031cbe0 r __func__.25349
+c031cbf1 r __func__.25090
+c031cc00 r raw6_seq_fops
+c031cc80 r tab_unreach
+c031cca8 r __func__.25060
+c031cce0 r igmp6_mc_seq_fops
+c031cd60 r igmp6_mcf_seq_fops
+c031cdd0 r __func__.24861
+c031cddc r __func__.25040
+c031cde8 r __func__.24486
+c031ce00 r ip6fl_seq_fops
+c031ce70 r __func__.24866
+c031ce7c r __func__.24982
+c031ce88 r __func__.24982
+c031ce94 r __func__.24659
+c031cea0 r snmp6_seq_fops
+c031cf20 r sockstat6_seq_fops
+c031cf90 r __func__.24804
+c031cf9c r tunnels
+c031d000 r packet_seq_fops
+c031d080 r packet_ops
+c031d0e0 r packet_ops_spkt
+c031d134 r __func__.25112
+c031d145 r __func__.24853
+c031d160 r standard_ioctl
+c031d400 r standard_event
+c031d480 r event_type_size
+c031d4ac r __func__.17006
+c031d4b7 r iw_priv_type_size
+c031d4c0 r wireless_seq_fops
+c031d530 r wireless_seq_ops
+c031d540 R kallsyms_addresses
+c03353b0 R kallsyms_num_syms
+c03353b4 R kallsyms_names
+c0377490 R kallsyms_markers
+c0377610 R kallsyms_token_table
+c037797c R kallsyms_token_index
+c03abc30 r __pci_fixup_PCI_VENDOR_ID_SERVERWORKSPCI_DEVICE_ID_SERVERWORKS_CSB5IDEquirk_svwks_csb5ide
+c03abc30 R __start_pci_fixups_early
+c03abc38 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801CA_10quirk_ide_samemode
+c03abc40 r __pci_fixup_PCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB360quirk_jmicron_ata
+c03abc48 r __pci_fixup_PCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB361quirk_jmicron_ata
+c03abc50 r __pci_fixup_PCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB363quirk_jmicron_ata
+c03abc58 r __pci_fixup_PCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB365quirk_jmicron_ata
+c03abc60 r __pci_fixup_PCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB366quirk_jmicron_ata
+c03abc68 r __pci_fixup_PCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB368quirk_jmicron_ata
+c03abc70 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_PXHD_0quirk_pcie_pxh
+c03abc78 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_PXHD_1quirk_pcie_pxh
+c03abc80 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_PXH_0quirk_pcie_pxh
+c03abc88 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_PXH_1quirk_pcie_pxh
+c03abc90 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_PXHVquirk_pcie_pxh
+c03abc98 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_ANY_IDquirk_e100_interrupt
+c03abca0 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82371AB_3acpi_pm_check_blacklist
+c03abca8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801DB_0acpi_pm_check_graylist
+c03abcb0 r __pci_fixup_PCI_VENDOR_ID_SERVERWORKSPCI_DEVICE_ID_SERVERWORKS_LEacpi_pm_check_graylist
+c03abcb8 r __pci_fixup_PCI_VENDOR_ID_CYRIXPCI_DEVICE_ID_CYRIX_5530_LEGACYpci_early_fixup_cyrix_5530
+c03abcc0 R __end_pci_fixups_early
+c03abcc0 r __pci_fixup_PCI_VENDOR_ID_IBMPCI_DEVICE_ID_IBM_CITRINEquirk_citrine
+c03abcc0 R __start_pci_fixups_header
+c03abcc8 r __pci_fixup_PCI_VENDOR_ID_S3PCI_DEVICE_ID_S3_868quirk_s3_64M
+c03abcd0 r __pci_fixup_PCI_VENDOR_ID_S3PCI_DEVICE_ID_S3_968quirk_s3_64M
+c03abcd8 r __pci_fixup_PCI_VENDOR_ID_ALPCI_DEVICE_ID_AL_M7101quirk_ali7101_acpi
+c03abce0 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82371AB_3quirk_piix4_acpi
+c03abce8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82443MX_3quirk_piix4_acpi
+c03abcf0 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801AA_0quirk_ich4_lpc_acpi
+c03abcf8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801AB_0quirk_ich4_lpc_acpi
+c03abd00 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801BA_0quirk_ich4_lpc_acpi
+c03abd08 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801BA_10quirk_ich4_lpc_acpi
+c03abd10 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801CA_0quirk_ich4_lpc_acpi
+c03abd18 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801CA_12quirk_ich4_lpc_acpi
+c03abd20 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801DB_0quirk_ich4_lpc_acpi
+c03abd28 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801DB_12quirk_ich4_lpc_acpi
+c03abd30 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801EB_0quirk_ich4_lpc_acpi
+c03abd38 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ESB_1quirk_ich4_lpc_acpi
+c03abd40 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH6_0quirk_ich6_lpc_acpi
+c03abd48 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH6_1quirk_ich6_lpc_acpi
+c03abd50 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH7_0quirk_ich6_lpc_acpi
+c03abd58 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH7_1quirk_ich6_lpc_acpi
+c03abd60 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH7_31quirk_ich6_lpc_acpi
+c03abd68 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH8_0quirk_ich6_lpc_acpi
+c03abd70 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH8_2quirk_ich6_lpc_acpi
+c03abd78 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH8_3quirk_ich6_lpc_acpi
+c03abd80 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C586_3quirk_vt82c586_acpi
+c03abd88 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C686_4quirk_vt82c686_acpi
+c03abd90 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8235quirk_vt8235_acpi
+c03abd98 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C586_3quirk_via_acpi
+c03abda0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C686_4quirk_via_acpi
+c03abda8 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C686quirk_via_bridge
+c03abdb0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8231quirk_via_bridge
+c03abdb8 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8233_0quirk_via_bridge
+c03abdc0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8233Aquirk_via_bridge
+c03abdc8 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8233C_0quirk_via_bridge
+c03abdd0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8235quirk_via_bridge
+c03abdd8 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237quirk_via_bridge
+c03abde0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237Aquirk_via_bridge
+c03abde8 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C597_0quirk_vt82c598_id
+c03abdf0 r __pci_fixup_PCI_VENDOR_ID_DUNORDPCI_DEVICE_ID_DUNORD_I3000quirk_dunord
+c03abdf8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82380FBquirk_transparent_bridge
+c03abe00 r __pci_fixup_PCI_VENDOR_ID_TOSHIBA0x605quirk_transparent_bridge
+c03abe08 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_IXP600_SATAquirk_sb600_sata
+c03abe10 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_IXP700_SATAquirk_sb600_sata
+c03abe18 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82375quirk_eisa_bridge
+c03abe20 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237k8t_sound_hostbridge
+c03abe28 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82845_HBasus_hides_smbus_hostbridge
+c03abe30 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82845G_HBasus_hides_smbus_hostbridge
+c03abe38 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82850_HBasus_hides_smbus_hostbridge
+c03abe40 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82865_HBasus_hides_smbus_hostbridge
+c03abe48 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_7205_0asus_hides_smbus_hostbridge
+c03abe50 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_E7501_MCHasus_hides_smbus_hostbridge
+c03abe58 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82855PM_HBasus_hides_smbus_hostbridge
+c03abe60 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82855GM_HBasus_hides_smbus_hostbridge
+c03abe68 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82915GM_HBasus_hides_smbus_hostbridge
+c03abe70 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801DB_0asus_hides_smbus_lpc
+c03abe78 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801BA_0asus_hides_smbus_lpc
+c03abe80 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801CA_0asus_hides_smbus_lpc
+c03abe88 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801CA_12asus_hides_smbus_lpc
+c03abe90 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801DB_12asus_hides_smbus_lpc
+c03abe98 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801EB_0asus_hides_smbus_lpc
+c03abea0 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH6_1asus_hides_smbus_lpc_ich6
+c03abea8 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_961quirk_sis_96x_smbus
+c03abeb0 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_962quirk_sis_96x_smbus
+c03abeb8 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_963quirk_sis_96x_smbus
+c03abec0 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_LPCquirk_sis_96x_smbus
+c03abec8 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_503quirk_sis_503
+c03abed0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237asus_hides_ac97_lpc
+c03abed8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_EESSCquirk_alder_ioapic
+c03abee0 r __pci_fixup_PCI_VENDOR_ID_TOSHIBA_2PCI_DEVICE_ID_TOSHIBA_TC86C001_IDEquirk_tc86c001_ide
+c03abee8 r __pci_fixup_PCI_VENDOR_ID_NETMOSPCI_ANY_IDquirk_netmos
+c03abef0 r __pci_fixup_PCI_VENDOR_ID_NCRPCI_DEVICE_ID_NCR_53C810fixup_rev1_53c810
+c03abef8 r __pci_fixup_PCI_VENDOR_ID_INTEL0x1460quirk_p64h2_1k_io
+c03abf00 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82451NXpci_fixup_i450nx
+c03abf08 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82454GXpci_fixup_i450gx
+c03abf10 r __pci_fixup_PCI_VENDOR_ID_UMCPCI_DEVICE_ID_UMC_UM8886BFpci_fixup_umc_ide
+c03abf18 r __pci_fixup_PCI_VENDOR_ID_NCRPCI_DEVICE_ID_NCR_53C810pci_fixup_ncr53c810
+c03abf20 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_5597pci_fixup_latency
+c03abf28 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_5598pci_fixup_latency
+c03abf30 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82371AB_3pci_fixup_piix4_acpi
+c03abf38 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8363_0pci_fixup_via_northbridge_bug
+c03abf40 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8622pci_fixup_via_northbridge_bug
+c03abf48 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8361pci_fixup_via_northbridge_bug
+c03abf50 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8367_0pci_fixup_via_northbridge_bug
+c03abf58 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_ANY_IDpci_fixup_transparent_bridge
+c03abf60 r __pci_fixup_PCI_VENDOR_ID_NVIDIAPCI_DEVICE_ID_NVIDIA_NFORCE2pci_fixup_nforce2
+c03abf68 r __pci_fixup_PCI_VENDOR_ID_TI0x8032pci_pre_fixup_toshiba_ohci1394
+c03abf70 r __pci_fixup_PCI_VENDOR_ID_SIEMENS0x0015pci_siemens_interrupt_controller
+c03abf78 R __end_pci_fixups_header
+c03abf78 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_ANY_IDvia_no_dac
+c03abf78 R __start_pci_fixups_final
+c03abf80 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_E7320_MCHquirk_intel_irqbalance
+c03abf88 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_E7525_MCHquirk_intel_irqbalance
+c03abf90 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_E7520_MCHquirk_intel_irqbalance
+c03abf98 r __pci_fixup_PCI_VENDOR_ID_MELLANOXPCI_DEVICE_ID_MELLANOX_TAVORquirk_mellanox_tavor
+c03abfa0 r __pci_fixup_PCI_VENDOR_ID_MELLANOXPCI_DEVICE_ID_MELLANOX_TAVOR_BRIDGEquirk_mellanox_tavor
+c03abfa8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82441quirk_passive_release
+c03abfb0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C586_0quirk_isa_dma_hangs
+c03abfb8 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C596quirk_isa_dma_hangs
+c03abfc0 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82371SB_0quirk_isa_dma_hangs
+c03abfc8 r __pci_fixup_PCI_VENDOR_ID_ALPCI_DEVICE_ID_AL_M1533quirk_isa_dma_hangs
+c03abfd0 r __pci_fixup_PCI_VENDOR_ID_NECPCI_DEVICE_ID_NEC_CBUS_1quirk_isa_dma_hangs
+c03abfd8 r __pci_fixup_PCI_VENDOR_ID_NECPCI_DEVICE_ID_NEC_CBUS_2quirk_isa_dma_hangs
+c03abfe0 r __pci_fixup_PCI_VENDOR_ID_NECPCI_DEVICE_ID_NEC_CBUS_3quirk_isa_dma_hangs
+c03abfe8 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_5597quirk_nopcipci
+c03abff0 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_496quirk_nopcipci
+c03abff8 r __pci_fixup_PCI_VENDOR_ID_AMDPCI_DEVICE_ID_AMD_8151_0quirk_nopciamd
+c03ac000 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82437quirk_triton
+c03ac008 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82437VXquirk_triton
+c03ac010 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82439quirk_triton
+c03ac018 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82439TXquirk_triton
+c03ac020 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8363_0quirk_vialatency
+c03ac028 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8371_1quirk_vialatency
+c03ac030 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8361quirk_vialatency
+c03ac038 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C597_0quirk_viaetbf
+c03ac040 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C576quirk_vsfx
+c03ac048 r __pci_fixup_PCI_VENDOR_ID_ALPCI_DEVICE_ID_AL_M1647quirk_alimagik
+c03ac050 r __pci_fixup_PCI_VENDOR_ID_ALPCI_DEVICE_ID_AL_M1651quirk_alimagik
+c03ac058 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82441quirk_natoma
+c03ac060 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82443LX_0quirk_natoma
+c03ac068 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82443LX_1quirk_natoma
+c03ac070 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82443BX_0quirk_natoma
+c03ac078 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82443BX_1quirk_natoma
+c03ac080 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82443BX_2quirk_natoma
+c03ac088 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_RS100quirk_ati_exploding_mce
+c03ac090 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C686quirk_via_ioapic
+c03ac098 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237quirk_via_vt8237_bypass_apic_deassert
+c03ac0a0 r __pci_fixup_PCI_VENDOR_ID_AMDPCI_DEVICE_ID_AMD_VIPER_7410quirk_amd_ioapic
+c03ac0a8 r __pci_fixup_PCI_VENDOR_ID_SIPCI_ANY_IDquirk_ioapic_rmw
+c03ac0b0 r __pci_fixup_PCI_VENDOR_ID_AMDPCI_DEVICE_ID_AMD_8131_BRIDGEquirk_amd_8131_ioapic
+c03ac0b8 r __pci_fixup_PCI_ANY_IDPCI_ANY_IDquirk_cardbus_legacy
+c03ac0c0 r __pci_fixup_PCI_VENDOR_ID_AMDPCI_DEVICE_ID_AMD_FE_GATE_700Cquirk_amd_ordering
+c03ac0c8 r __pci_fixup_PCI_VENDOR_ID_CYRIXPCI_DEVICE_ID_CYRIX_PCI_MASTERquirk_mediagx_master
+c03ac0d0 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82454NXquirk_disable_pxb
+c03ac0d8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_E7520_MCHquirk_pcie_mch
+c03ac0e0 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_E7320_MCHquirk_pcie_mch
+c03ac0e8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_E7525_MCHquirk_pcie_mch
+c03ac0f0 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25e2quirk_intel_pcie_pm
+c03ac0f8 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25e3quirk_intel_pcie_pm
+c03ac100 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25e4quirk_intel_pcie_pm
+c03ac108 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25e5quirk_intel_pcie_pm
+c03ac110 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25e6quirk_intel_pcie_pm
+c03ac118 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25e7quirk_intel_pcie_pm
+c03ac120 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25f7quirk_intel_pcie_pm
+c03ac128 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25f8quirk_intel_pcie_pm
+c03ac130 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25f9quirk_intel_pcie_pm
+c03ac138 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25faquirk_intel_pcie_pm
+c03ac140 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2601quirk_intel_pcie_pm
+c03ac148 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2602quirk_intel_pcie_pm
+c03ac150 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2603quirk_intel_pcie_pm
+c03ac158 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2604quirk_intel_pcie_pm
+c03ac160 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2605quirk_intel_pcie_pm
+c03ac168 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2606quirk_intel_pcie_pm
+c03ac170 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2607quirk_intel_pcie_pm
+c03ac178 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2608quirk_intel_pcie_pm
+c03ac180 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2609quirk_intel_pcie_pm
+c03ac188 r __pci_fixup_PCI_VENDOR_ID_INTEL0x260aquirk_intel_pcie_pm
+c03ac190 r __pci_fixup_PCI_VENDOR_ID_INTEL0x260bquirk_intel_pcie_pm
+c03ac198 r __pci_fixup_PCI_VENDOR_ID_INTEL0x1460quirk_p64h2_1k_io_fix_iobl
+c03ac1a0 r __pci_fixup_PCI_VENDOR_ID_NVIDIAPCI_DEVICE_ID_NVIDIA_CK804_PCIEquirk_nvidia_ck804_pcie_aer_ext_cap
+c03ac1a8 r __pci_fixup_PCI_VENDOR_ID_SERVERWORKSPCI_DEVICE_ID_SERVERWORKS_GCNB_LEquirk_disable_all_msi
+c03ac1b0 r __pci_fixup_PCI_VENDOR_ID_SERVERWORKSPCI_DEVICE_ID_SERVERWORKS_HT1000_PCIXquirk_disable_all_msi
+c03ac1b8 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_RS400_200quirk_disable_all_msi
+c03ac1c0 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_RS480quirk_disable_all_msi
+c03ac1c8 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_RD580quirk_disable_all_msi
+c03ac1d0 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_RX790quirk_disable_all_msi
+c03ac1d8 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_RS690quirk_disable_all_msi
+c03ac1e0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_VT3351quirk_disable_all_msi
+c03ac1e8 r __pci_fixup_PCI_VENDOR_ID_AMDPCI_DEVICE_ID_AMD_8131_BRIDGEquirk_disable_msi
+c03ac1f0 r __pci_fixup_PCI_VENDOR_ID_SERVERWORKSPCI_DEVICE_ID_SERVERWORKS_HT2000_PCIEquirk_msi_ht_cap
+c03ac1f8 r __pci_fixup_PCI_VENDOR_ID_NVIDIAPCI_DEVICE_ID_NVIDIA_CK804_PCIEquirk_nvidia_ck804_msi_ht_cap
+c03ac200 r __pci_fixup_PCI_ANY_IDPCI_ANY_IDquirk_usb_early_handoff
+c03ac208 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_MCH_PApcie_rootport_aspm_quirk
+c03ac210 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_MCH_PA1pcie_rootport_aspm_quirk
+c03ac218 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_MCH_PBpcie_rootport_aspm_quirk
+c03ac220 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_MCH_PB1pcie_rootport_aspm_quirk
+c03ac228 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_MCH_PCpcie_rootport_aspm_quirk
+c03ac230 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_MCH_PC1pcie_rootport_aspm_quirk
+c03ac238 r __pci_fixup_PCI_ANY_IDPCI_ANY_IDpci_fixup_video
+c03ac240 R __end_pci_fixups_final
+c03ac240 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_ANY_IDquirk_via_vlink
+c03ac240 R __start_pci_fixups_enable
+c03ac248 r __pci_fixup_PCI_VENDOR_ID_TI0x8032pci_post_fixup_toshiba_ohci1394
+c03ac250 R __end_pci_fixups_enable
+c03ac250 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82441quirk_passive_release
+c03ac250 R __start_pci_fixups_resume
+c03ac258 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8363_0quirk_vialatency
+c03ac260 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8371_1quirk_vialatency
+c03ac268 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8361quirk_vialatency
+c03ac270 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C686quirk_via_ioapic
+c03ac278 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237quirk_via_vt8237_bypass_apic_deassert
+c03ac280 r __pci_fixup_resumePCI_VENDOR_ID_AMDPCI_DEVICE_ID_AMD_8131_BRIDGEquirk_amd_8131_ioapic
+c03ac288 r __pci_fixup_resumePCI_ANY_IDPCI_ANY_IDquirk_cardbus_legacy
+c03ac290 r __pci_fixup_resumePCI_VENDOR_ID_AMDPCI_DEVICE_ID_AMD_FE_GATE_700Cquirk_amd_ordering
+c03ac298 r __pci_fixup_resumePCI_VENDOR_ID_CYRIXPCI_DEVICE_ID_CYRIX_PCI_MASTERquirk_mediagx_master
+c03ac2a0 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82454NXquirk_disable_pxb
+c03ac2a8 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237k8t_sound_hostbridge
+c03ac2b0 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801DB_0asus_hides_smbus_lpc
+c03ac2b8 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801BA_0asus_hides_smbus_lpc
+c03ac2c0 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801CA_0asus_hides_smbus_lpc
+c03ac2c8 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801CA_12asus_hides_smbus_lpc
+c03ac2d0 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801DB_12asus_hides_smbus_lpc
+c03ac2d8 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801EB_0asus_hides_smbus_lpc
+c03ac2e0 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH6_1asus_hides_smbus_lpc_ich6
+c03ac2e8 r __pci_fixup_resumePCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_961quirk_sis_96x_smbus
+c03ac2f0 r __pci_fixup_resumePCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_962quirk_sis_96x_smbus
+c03ac2f8 r __pci_fixup_resumePCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_963quirk_sis_96x_smbus
+c03ac300 r __pci_fixup_resumePCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_LPCquirk_sis_96x_smbus
+c03ac308 r __pci_fixup_resumePCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_503quirk_sis_503
+c03ac310 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237asus_hides_ac97_lpc
+c03ac318 r __pci_fixup_resumePCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB360quirk_jmicron_ata
+c03ac320 r __pci_fixup_resumePCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB361quirk_jmicron_ata
+c03ac328 r __pci_fixup_resumePCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB363quirk_jmicron_ata
+c03ac330 r __pci_fixup_resumePCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB365quirk_jmicron_ata
+c03ac338 r __pci_fixup_resumePCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB366quirk_jmicron_ata
+c03ac340 r __pci_fixup_resumePCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB368quirk_jmicron_ata
+c03ac348 r __pci_fixup_resumePCI_VENDOR_ID_NVIDIAPCI_DEVICE_ID_NVIDIA_CK804_PCIEquirk_nvidia_ck804_pcie_aer_ext_cap
+c03ac350 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8363_0pci_fixup_via_northbridge_bug
+c03ac358 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8622pci_fixup_via_northbridge_bug
+c03ac360 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8361pci_fixup_via_northbridge_bug
+c03ac368 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8367_0pci_fixup_via_northbridge_bug
+c03ac370 r __pci_fixup_resumePCI_VENDOR_ID_NVIDIAPCI_DEVICE_ID_NVIDIA_NFORCE2pci_fixup_nforce2
+c03ac378 r __pci_fixup_resumePCI_VENDOR_ID_CYRIXPCI_DEVICE_ID_CYRIX_5530_LEGACYpci_early_fixup_cyrix_5530
+c03ac380 R __end_pci_fixups_resume
+c03ac380 ? __end_rio_route_ops
+c03ac380 r __ksymtab_init_mm
+c03ac380 R __start___ksymtab
+c03ac380 ? __start_rio_route_ops
+c03ac388 r __ksymtab_init_task
+c03ac390 r __ksymtab_system_state
+c03ac398 r __ksymtab_reset_devices
+c03ac3a0 r __ksymtab_loops_per_jiffy
+c03ac3a8 r __ksymtab___per_cpu_offset
+c03ac3b0 r __ksymtab_boot_option_idle_override
+c03ac3b8 r __ksymtab_per_cpu__current_task
+c03ac3c0 r __ksymtab_per_cpu__cpu_number
+c03ac3c8 r __ksymtab_pm_idle
+c03ac3d0 r __ksymtab_disable_hlt
+c03ac3d8 r __ksymtab_enable_hlt
+c03ac3e0 r __ksymtab_kernel_thread
+c03ac3e8 r __ksymtab_dump_thread
+c03ac3f0 r __ksymtab_dump_trace
+c03ac3f8 r __ksymtab_dump_stack
+c03ac400 r __ksymtab_per_cpu__irq_stat
+c03ac408 r __ksymtab_per_cpu__irq_regs
+c03ac410 r __ksymtab_do_softirq
+c03ac418 r __ksymtab_cpu_khz
+c03ac420 r __ksymtab_rtc_lock
+c03ac428 r __ksymtab_cmos_lock
+c03ac430 r __ksymtab_rtc_cmos_read
+c03ac438 r __ksymtab_rtc_cmos_write
+c03ac440 r __ksymtab_profile_pc
+c03ac448 r __ksymtab_boot_cpu_data
+c03ac450 r __ksymtab_drive_info
+c03ac458 r __ksymtab_screen_info
+c03ac460 r __ksymtab_apm_info
+c03ac468 r __ksymtab_edd
+c03ac470 r __ksymtab_dma_alloc_coherent
+c03ac478 r __ksymtab_dma_free_coherent
+c03ac480 r __ksymtab_dma_declare_coherent_memory
+c03ac488 r __ksymtab_dma_release_declared_memory
+c03ac490 r __ksymtab_dma_mark_declared_memory_occupied
+c03ac498 r __ksymtab_forbid_dac
+c03ac4a0 r __ksymtab___down_failed
+c03ac4a8 r __ksymtab___down_failed_interruptible
+c03ac4b0 r __ksymtab___down_failed_trylock
+c03ac4b8 r __ksymtab___up_wakeup
+c03ac4c0 r __ksymtab_csum_partial_copy_generic
+c03ac4c8 r __ksymtab___get_user_1
+c03ac4d0 r __ksymtab___get_user_2
+c03ac4d8 r __ksymtab___get_user_4
+c03ac4e0 r __ksymtab___put_user_1
+c03ac4e8 r __ksymtab___put_user_2
+c03ac4f0 r __ksymtab___put_user_4
+c03ac4f8 r __ksymtab___put_user_8
+c03ac500 r __ksymtab_strstr
+c03ac508 r __ksymtab___write_lock_failed
+c03ac510 r __ksymtab___read_lock_failed
+c03ac518 r __ksymtab_csum_partial
+c03ac520 r __ksymtab_dump_fpu
+c03ac528 r __ksymtab_efi_enabled
+c03ac530 r __ksymtab_pci_mem_start
+c03ac538 r __ksymtab_i8253_lock
+c03ac540 r __ksymtab_recalibrate_cpu_khz
+c03ac548 r __ksymtab_mtrr_add
+c03ac550 r __ksymtab_mtrr_del
+c03ac558 r __ksymtab_avail_to_resrv_perfctr_nmi
+c03ac560 r __ksymtab_avail_to_resrv_perfctr_nmi_bit
+c03ac568 r __ksymtab_reserve_perfctr_nmi
+c03ac570 r __ksymtab_release_perfctr_nmi
+c03ac578 r __ksymtab_reserve_evntsel_nmi
+c03ac580 r __ksymtab_release_evntsel_nmi
+c03ac588 r __ksymtab_acpi_disabled
+c03ac590 r __ksymtab_acpi_strict
+c03ac598 r __ksymtab_acpi_register_gsi
+c03ac5a0 r __ksymtab_acpi_register_ioapic
+c03ac5a8 r __ksymtab_acpi_unregister_ioapic
+c03ac5b0 r __ksymtab_pm_power_off
+c03ac5b8 r __ksymtab_flush_tlb_page
+c03ac5c0 r __ksymtab_smp_num_siblings
+c03ac5c8 r __ksymtab_cpu_sibling_map
+c03ac5d0 r __ksymtab_cpu_core_map
+c03ac5d8 r __ksymtab_cpu_online_map
+c03ac5e0 r __ksymtab_cpu_callout_map
+c03ac5e8 r __ksymtab_cpu_possible_map
+c03ac5f0 r __ksymtab_cpu_data
+c03ac5f8 r __ksymtab_x86_cpu_to_apicid
+c03ac600 r __ksymtab_per_cpu__this_cpu_off
+c03ac608 r __ksymtab_smp_call_function
+c03ac610 r __ksymtab_smp_call_function_single
+c03ac618 r __ksymtab_touch_nmi_watchdog
+c03ac620 r __ksymtab_nmi_active
+c03ac628 r __ksymtab_nmi_watchdog
+c03ac630 r __ksymtab_IO_APIC_get_PCI_irq_vector
+c03ac638 r __ksymtab_efi
+c03ac640 r __ksymtab___PAGE_KERNEL
+c03ac648 r __ksymtab___FIXADDR_TOP
+c03ac650 r __ksymtab___ioremap
+c03ac658 r __ksymtab_ioremap_nocache
+c03ac660 r __ksymtab_iounmap
+c03ac668 r __ksymtab_change_page_attr
+c03ac670 r __ksymtab_global_flush_tlb
+c03ac678 r __ksymtab_kmap
+c03ac680 r __ksymtab_kunmap
+c03ac688 r __ksymtab_kmap_atomic
+c03ac690 r __ksymtab_kunmap_atomic
+c03ac698 r __ksymtab_kmap_atomic_to_page
+c03ac6a0 r __ksymtab_wake_up_process
+c03ac6a8 r __ksymtab_per_cpu__kstat
+c03ac6b0 r __ksymtab_schedule
+c03ac6b8 r __ksymtab_default_wake_function
+c03ac6c0 r __ksymtab___wake_up
+c03ac6c8 r __ksymtab_complete
+c03ac6d0 r __ksymtab_complete_all
+c03ac6d8 r __ksymtab_wait_for_completion
+c03ac6e0 r __ksymtab_wait_for_completion_timeout
+c03ac6e8 r __ksymtab_wait_for_completion_interruptible
+c03ac6f0 r __ksymtab_wait_for_completion_interruptible_timeout
+c03ac6f8 r __ksymtab_interruptible_sleep_on
+c03ac700 r __ksymtab_interruptible_sleep_on_timeout
+c03ac708 r __ksymtab_sleep_on
+c03ac710 r __ksymtab_sleep_on_timeout
+c03ac718 r __ksymtab_set_user_nice
+c03ac720 r __ksymtab_cpu_present_map
+c03ac728 r __ksymtab_cond_resched
+c03ac730 r __ksymtab_cond_resched_lock
+c03ac738 r __ksymtab_cond_resched_softirq
+c03ac740 r __ksymtab_yield
+c03ac748 r __ksymtab_io_schedule
+c03ac750 r __ksymtab_nr_cpu_ids
+c03ac758 r __ksymtab___might_sleep
+c03ac760 r __ksymtab_free_task
+c03ac768 r __ksymtab_unshare_files
+c03ac770 r __ksymtab_register_exec_domain
+c03ac778 r __ksymtab_unregister_exec_domain
+c03ac780 r __ksymtab___set_personality
+c03ac788 r __ksymtab_panic_notifier_list
+c03ac790 r __ksymtab_panic_blink
+c03ac798 r __ksymtab_panic
+c03ac7a0 r __ksymtab_add_taint
+c03ac7a8 r __ksymtab_oops_in_progress
+c03ac7b0 r __ksymtab_printk
+c03ac7b8 r __ksymtab_vprintk
+c03ac7c0 r __ksymtab_acquire_console_sem
+c03ac7c8 r __ksymtab_try_acquire_console_sem
+c03ac7d0 r __ksymtab_release_console_sem
+c03ac7d8 r __ksymtab_console_conditional_schedule
+c03ac7e0 r __ksymtab_console_print
+c03ac7e8 r __ksymtab_console_stop
+c03ac7f0 r __ksymtab_console_start
+c03ac7f8 r __ksymtab_register_console
+c03ac800 r __ksymtab_unregister_console
+c03ac808 r __ksymtab___printk_ratelimit
+c03ac810 r __ksymtab_printk_ratelimit
+c03ac818 r __ksymtab_printk_timed_ratelimit
+c03ac820 r __ksymtab_allow_signal
+c03ac828 r __ksymtab_disallow_signal
+c03ac830 r __ksymtab_daemonize
+c03ac838 r __ksymtab_put_files_struct
+c03ac840 r __ksymtab_reset_files_struct
+c03ac848 r __ksymtab_complete_and_exit
+c03ac850 r __ksymtab_sys_tz
+c03ac858 r __ksymtab_current_kernel_time
+c03ac860 r __ksymtab_current_fs_time
+c03ac868 r __ksymtab_jiffies_to_msecs
+c03ac870 r __ksymtab_jiffies_to_usecs
+c03ac878 r __ksymtab_timespec_trunc
+c03ac880 r __ksymtab_mktime
+c03ac888 r __ksymtab_ns_to_timespec
+c03ac890 r __ksymtab_ns_to_timeval
+c03ac898 r __ksymtab_msecs_to_jiffies
+c03ac8a0 r __ksymtab_usecs_to_jiffies
+c03ac8a8 r __ksymtab_timespec_to_jiffies
+c03ac8b0 r __ksymtab_jiffies_to_timespec
+c03ac8b8 r __ksymtab_timeval_to_jiffies
+c03ac8c0 r __ksymtab_jiffies_to_timeval
+c03ac8c8 r __ksymtab_jiffies_to_clock_t
+c03ac8d0 r __ksymtab_clock_t_to_jiffies
+c03ac8d8 r __ksymtab_jiffies_64_to_clock_t
+c03ac8e0 r __ksymtab_get_jiffies_64
+c03ac8e8 r __ksymtab_jiffies
+c03ac8f0 r __ksymtab_local_bh_disable
+c03ac8f8 r __ksymtab__local_bh_enable
+c03ac900 r __ksymtab_local_bh_enable
+c03ac908 r __ksymtab_local_bh_enable_ip
+c03ac910 r __ksymtab_raise_softirq_irqoff
+c03ac918 r __ksymtab___tasklet_schedule
+c03ac920 r __ksymtab___tasklet_hi_schedule
+c03ac928 r __ksymtab_tasklet_init
+c03ac930 r __ksymtab_tasklet_kill
+c03ac938 r __ksymtab_on_each_cpu
+c03ac940 r __ksymtab_ioport_resource
+c03ac948 r __ksymtab_iomem_resource
+c03ac950 r __ksymtab_request_resource
+c03ac958 r __ksymtab_release_resource
+c03ac960 r __ksymtab_allocate_resource
+c03ac968 r __ksymtab_adjust_resource
+c03ac970 r __ksymtab___request_region
+c03ac978 r __ksymtab___check_region
+c03ac980 r __ksymtab___release_region
+c03ac988 r __ksymtab___devm_request_region
+c03ac990 r __ksymtab___devm_release_region
+c03ac998 r __ksymtab_proc_dointvec
+c03ac9a0 r __ksymtab_proc_dointvec_jiffies
+c03ac9a8 r __ksymtab_proc_dointvec_minmax
+c03ac9b0 r __ksymtab_proc_dointvec_userhz_jiffies
+c03ac9b8 r __ksymtab_proc_dointvec_ms_jiffies
+c03ac9c0 r __ksymtab_proc_dostring
+c03ac9c8 r __ksymtab_proc_doulongvec_minmax
+c03ac9d0 r __ksymtab_proc_doulongvec_ms_jiffies_minmax
+c03ac9d8 r __ksymtab_register_sysctl_table
+c03ac9e0 r __ksymtab_sysctl_intvec
+c03ac9e8 r __ksymtab_sysctl_jiffies
+c03ac9f0 r __ksymtab_sysctl_ms_jiffies
+c03ac9f8 r __ksymtab_sysctl_string
+c03aca00 r __ksymtab_sysctl_data
+c03aca08 r __ksymtab_unregister_sysctl_table
+c03aca10 r __ksymtab_securebits
+c03aca18 r __ksymtab_cap_bset
+c03aca20 r __ksymtab___capable
+c03aca28 r __ksymtab_capable
+c03aca30 r __ksymtab_jiffies_64
+c03aca38 r __ksymtab_boot_tvec_bases
+c03aca40 r __ksymtab_init_timer
+c03aca48 r __ksymtab_init_timer_deferrable
+c03aca50 r __ksymtab___mod_timer
+c03aca58 r __ksymtab_mod_timer
+c03aca60 r __ksymtab_del_timer
+c03aca68 r __ksymtab_try_to_del_timer_sync
+c03aca70 r __ksymtab_del_timer_sync
+c03aca78 r __ksymtab_avenrun
+c03aca80 r __ksymtab_schedule_timeout
+c03aca88 r __ksymtab_schedule_timeout_interruptible
+c03aca90 r __ksymtab_schedule_timeout_uninterruptible
+c03aca98 r __ksymtab_msleep
+c03acaa0 r __ksymtab_msleep_interruptible
+c03acaa8 r __ksymtab_kill_pgrp
+c03acab0 r __ksymtab_kill_pid
+c03acab8 r __ksymtab_recalc_sigpending
+c03acac0 r __ksymtab_flush_signals
+c03acac8 r __ksymtab_force_sig
+c03acad0 r __ksymtab_kill_proc
+c03acad8 r __ksymtab_ptrace_notify
+c03acae0 r __ksymtab_send_sig
+c03acae8 r __ksymtab_send_sig_info
+c03acaf0 r __ksymtab_sigprocmask
+c03acaf8 r __ksymtab_block_all_signals
+c03acb00 r __ksymtab_unblock_all_signals
+c03acb08 r __ksymtab_overflowuid
+c03acb10 r __ksymtab_overflowgid
+c03acb18 r __ksymtab_fs_overflowuid
+c03acb20 r __ksymtab_fs_overflowgid
+c03acb28 r __ksymtab_cad_pid
+c03acb30 r __ksymtab_register_reboot_notifier
+c03acb38 r __ksymtab_unregister_reboot_notifier
+c03acb40 r __ksymtab_groups_alloc
+c03acb48 r __ksymtab_groups_free
+c03acb50 r __ksymtab_set_current_groups
+c03acb58 r __ksymtab_in_group_p
+c03acb60 r __ksymtab_in_egroup_p
+c03acb68 r __ksymtab_uts_sem
+c03acb70 r __ksymtab_request_module
+c03acb78 r __ksymtab_call_usermodehelper_freeinfo
+c03acb80 r __ksymtab_call_usermodehelper_setup
+c03acb88 r __ksymtab_call_usermodehelper_setkeys
+c03acb90 r __ksymtab_call_usermodehelper_setcleanup
+c03acb98 r __ksymtab_call_usermodehelper_stdinpipe
+c03acba0 r __ksymtab_call_usermodehelper_exec
+c03acba8 r __ksymtab_call_usermodehelper_pipe
+c03acbb0 r __ksymtab_cancel_rearming_delayed_work
+c03acbb8 r __ksymtab_schedule_work
+c03acbc0 r __ksymtab_schedule_delayed_work
+c03acbc8 r __ksymtab_schedule_delayed_work_on
+c03acbd0 r __ksymtab_flush_scheduled_work
+c03acbd8 r __ksymtab_find_task_by_pid_type
+c03acbe0 r __ksymtab_param_set_byte
+c03acbe8 r __ksymtab_param_get_byte
+c03acbf0 r __ksymtab_param_set_short
+c03acbf8 r __ksymtab_param_get_short
+c03acc00 r __ksymtab_param_set_ushort
+c03acc08 r __ksymtab_param_get_ushort
+c03acc10 r __ksymtab_param_set_int
+c03acc18 r __ksymtab_param_get_int
+c03acc20 r __ksymtab_param_set_uint
+c03acc28 r __ksymtab_param_get_uint
+c03acc30 r __ksymtab_param_set_long
+c03acc38 r __ksymtab_param_get_long
+c03acc40 r __ksymtab_param_set_ulong
+c03acc48 r __ksymtab_param_get_ulong
+c03acc50 r __ksymtab_param_set_charp
+c03acc58 r __ksymtab_param_get_charp
+c03acc60 r __ksymtab_param_set_bool
+c03acc68 r __ksymtab_param_get_bool
+c03acc70 r __ksymtab_param_set_invbool
+c03acc78 r __ksymtab_param_get_invbool
+c03acc80 r __ksymtab_param_array_set
+c03acc88 r __ksymtab_param_array_get
+c03acc90 r __ksymtab_param_set_copystring
+c03acc98 r __ksymtab_param_get_string
+c03acca0 r __ksymtab_kthread_should_stop
+c03acca8 r __ksymtab_kthread_create
+c03accb0 r __ksymtab_kthread_bind
+c03accb8 r __ksymtab_kthread_stop
+c03accc0 r __ksymtab_init_waitqueue_head
+c03accc8 r __ksymtab_add_wait_queue
+c03accd0 r __ksymtab_add_wait_queue_exclusive
+c03accd8 r __ksymtab_remove_wait_queue
+c03acce0 r __ksymtab_prepare_to_wait
+c03acce8 r __ksymtab_prepare_to_wait_exclusive
+c03accf0 r __ksymtab_finish_wait
+c03accf8 r __ksymtab_autoremove_wake_function
+c03acd00 r __ksymtab_wake_bit_function
+c03acd08 r __ksymtab___wait_on_bit
+c03acd10 r __ksymtab_out_of_line_wait_on_bit
+c03acd18 r __ksymtab___wait_on_bit_lock
+c03acd20 r __ksymtab_out_of_line_wait_on_bit_lock
+c03acd28 r __ksymtab___wake_up_bit
+c03acd30 r __ksymtab_wake_up_bit
+c03acd38 r __ksymtab_bit_waitqueue
+c03acd40 r __ksymtab_kfifo_init
+c03acd48 r __ksymtab_kfifo_alloc
+c03acd50 r __ksymtab_kfifo_free
+c03acd58 r __ksymtab___kfifo_put
+c03acd60 r __ksymtab___kfifo_get
+c03acd68 r __ksymtab___mutex_init
+c03acd70 r __ksymtab_mutex_lock
+c03acd78 r __ksymtab_mutex_unlock
+c03acd80 r __ksymtab_mutex_lock_interruptible
+c03acd88 r __ksymtab_mutex_trylock
+c03acd90 r __ksymtab_down_read
+c03acd98 r __ksymtab_down_read_trylock
+c03acda0 r __ksymtab_down_write
+c03acda8 r __ksymtab_down_write_trylock
+c03acdb0 r __ksymtab_up_read
+c03acdb8 r __ksymtab_up_write
+c03acdc0 r __ksymtab_downgrade_write
+c03acdc8 r __ksymtab_xtime_lock
+c03acdd0 r __ksymtab_xtime
+c03acdd8 r __ksymtab_getnstimeofday
+c03acde0 r __ksymtab_do_gettimeofday
+c03acde8 r __ksymtab_do_settimeofday
+c03acdf0 r __ksymtab_getboottime
+c03acdf8 r __ksymtab_monotonic_to_bootbased
+c03ace00 r __ksymtab_clocksource_register
+c03ace08 r __ksymtab_request_dma
+c03ace10 r __ksymtab_free_dma
+c03ace18 r __ksymtab_dma_spin_lock
+c03ace20 r __ksymtab__spin_trylock
+c03ace28 r __ksymtab__read_trylock
+c03ace30 r __ksymtab__write_trylock
+c03ace38 r __ksymtab__read_lock
+c03ace40 r __ksymtab__spin_lock_irqsave
+c03ace48 r __ksymtab__spin_lock_irq
+c03ace50 r __ksymtab__spin_lock_bh
+c03ace58 r __ksymtab__read_lock_irqsave
+c03ace60 r __ksymtab__read_lock_irq
+c03ace68 r __ksymtab__read_lock_bh
+c03ace70 r __ksymtab__write_lock_irqsave
+c03ace78 r __ksymtab__write_lock_irq
+c03ace80 r __ksymtab__write_lock_bh
+c03ace88 r __ksymtab__spin_lock
+c03ace90 r __ksymtab__write_lock
+c03ace98 r __ksymtab__spin_unlock
+c03acea0 r __ksymtab__write_unlock
+c03acea8 r __ksymtab__read_unlock
+c03aceb0 r __ksymtab__spin_unlock_irqrestore
+c03aceb8 r __ksymtab__spin_unlock_irq
+c03acec0 r __ksymtab__spin_unlock_bh
+c03acec8 r __ksymtab__read_unlock_irqrestore
+c03aced0 r __ksymtab__read_unlock_irq
+c03aced8 r __ksymtab__read_unlock_bh
+c03acee0 r __ksymtab__write_unlock_irqrestore
+c03acee8 r __ksymtab__write_unlock_irq
+c03acef0 r __ksymtab__write_unlock_bh
+c03acef8 r __ksymtab__spin_trylock_bh
+c03acf00 r __ksymtab_in_lock_functions
+c03acf08 r __ksymtab_register_module_notifier
+c03acf10 r __ksymtab_unregister_module_notifier
+c03acf18 r __ksymtab___module_put_and_exit
+c03acf20 r __ksymtab_module_refcount
+c03acf28 r __ksymtab___symbol_put
+c03acf30 r __ksymtab_module_put
+c03acf38 r __ksymtab_module_add_driver
+c03acf40 r __ksymtab_module_remove_driver
+c03acf48 r __ksymtab___print_symbol
+c03acf50 r __ksymtab_pm_suspend
+c03acf58 r __ksymtab_refrigerator
+c03acf60 r __ksymtab_pm_register
+c03acf68 r __ksymtab_pm_send_all
+c03acf70 r __ksymtab_pm_active
+c03acf78 r __ksymtab_touch_softlockup_watchdog
+c03acf80 r __ksymtab_touch_all_softlockup_watchdogs
+c03acf88 r __ksymtab_synchronize_irq
+c03acf90 r __ksymtab_disable_irq_nosync
+c03acf98 r __ksymtab_disable_irq
+c03acfa0 r __ksymtab_enable_irq
+c03acfa8 r __ksymtab_set_irq_wake
+c03acfb0 r __ksymtab_free_irq
+c03acfb8 r __ksymtab_request_irq
+c03acfc0 r __ksymtab_set_irq_chip
+c03acfc8 r __ksymtab_set_irq_type
+c03acfd0 r __ksymtab_set_irq_data
+c03acfd8 r __ksymtab_set_irq_chip_data
+c03acfe0 r __ksymtab_devm_request_irq
+c03acfe8 r __ksymtab_devm_free_irq
+c03acff0 r __ksymtab_probe_irq_on
+c03acff8 r __ksymtab_probe_irq_mask
+c03ad000 r __ksymtab_probe_irq_off
+c03ad008 r __ksymtab_filemap_fdatawrite
+c03ad010 r __ksymtab_filemap_flush
+c03ad018 r __ksymtab_sync_page_range
+c03ad020 r __ksymtab_sync_page_range_nolock
+c03ad028 r __ksymtab_filemap_fdatawait
+c03ad030 r __ksymtab_filemap_write_and_wait
+c03ad038 r __ksymtab_add_to_page_cache
+c03ad040 r __ksymtab_wait_on_page_bit
+c03ad048 r __ksymtab_unlock_page
+c03ad050 r __ksymtab_end_page_writeback
+c03ad058 r __ksymtab___lock_page
+c03ad060 r __ksymtab_find_get_page
+c03ad068 r __ksymtab_find_lock_page
+c03ad070 r __ksymtab_find_or_create_page
+c03ad078 r __ksymtab_find_get_pages_contig
+c03ad080 r __ksymtab_find_get_pages_tag
+c03ad088 r __ksymtab_grab_cache_page_nowait
+c03ad090 r __ksymtab_do_generic_mapping_read
+c03ad098 r __ksymtab_generic_segment_checks
+c03ad0a0 r __ksymtab_generic_file_aio_read
+c03ad0a8 r __ksymtab_generic_file_sendfile
+c03ad0b0 r __ksymtab_filemap_fault
+c03ad0b8 r __ksymtab_filemap_nopage
+c03ad0c0 r __ksymtab_filemap_populate
+c03ad0c8 r __ksymtab_generic_file_mmap
+c03ad0d0 r __ksymtab_generic_file_readonly_mmap
+c03ad0d8 r __ksymtab_read_cache_page_async
+c03ad0e0 r __ksymtab_read_cache_page
+c03ad0e8 r __ksymtab_should_remove_suid
+c03ad0f0 r __ksymtab_remove_suid
+c03ad0f8 r __ksymtab_generic_write_checks
+c03ad100 r __ksymtab_generic_file_direct_write
+c03ad108 r __ksymtab_generic_file_buffered_write
+c03ad110 r __ksymtab_generic_file_aio_write_nolock
+c03ad118 r __ksymtab_generic_file_aio_write
+c03ad120 r __ksymtab_try_to_release_page
+c03ad128 r __ksymtab_mempool_create
+c03ad130 r __ksymtab_mempool_create_node
+c03ad138 r __ksymtab_mempool_resize
+c03ad140 r __ksymtab_mempool_destroy
+c03ad148 r __ksymtab_mempool_alloc
+c03ad150 r __ksymtab_mempool_free
+c03ad158 r __ksymtab_mempool_alloc_slab
+c03ad160 r __ksymtab_mempool_free_slab
+c03ad168 r __ksymtab_mempool_kmalloc
+c03ad170 r __ksymtab_mempool_kzalloc
+c03ad178 r __ksymtab_mempool_kfree
+c03ad180 r __ksymtab_mempool_alloc_pages
+c03ad188 r __ksymtab_mempool_free_pages
+c03ad190 r __ksymtab_node_online_map
+c03ad198 r __ksymtab_node_possible_map
+c03ad1a0 r __ksymtab_totalram_pages
+c03ad1a8 r __ksymtab___alloc_pages
+c03ad1b0 r __ksymtab___get_free_pages
+c03ad1b8 r __ksymtab_get_zeroed_page
+c03ad1c0 r __ksymtab___free_pages
+c03ad1c8 r __ksymtab_free_pages
+c03ad1d0 r __ksymtab_si_meminfo
+c03ad1d8 r __ksymtab_contig_page_data
+c03ad1e0 r __ksymtab_laptop_mode
+c03ad1e8 r __ksymtab_balance_dirty_pages_ratelimited_nr
+c03ad1f0 r __ksymtab_write_cache_pages
+c03ad1f8 r __ksymtab_generic_writepages
+c03ad200 r __ksymtab_write_one_page
+c03ad208 r __ksymtab___set_page_dirty_nobuffers
+c03ad210 r __ksymtab_redirty_page_for_writepage
+c03ad218 r __ksymtab_set_page_dirty
+c03ad220 r __ksymtab_set_page_dirty_lock
+c03ad228 r __ksymtab_clear_page_dirty_for_io
+c03ad230 r __ksymtab_test_set_page_writeback
+c03ad238 r __ksymtab_mapping_tagged
+c03ad240 r __ksymtab_default_unplug_io_fn
+c03ad248 r __ksymtab_read_cache_pages
+c03ad250 r __ksymtab_put_page
+c03ad258 r __ksymtab_put_pages_list
+c03ad260 r __ksymtab_mark_page_accessed
+c03ad268 r __ksymtab___pagevec_release
+c03ad270 r __ksymtab___pagevec_lru_add
+c03ad278 r __ksymtab_pagevec_lookup
+c03ad280 r __ksymtab_pagevec_lookup_tag
+c03ad288 r __ksymtab_cancel_dirty_page
+c03ad290 r __ksymtab_truncate_inode_pages_range
+c03ad298 r __ksymtab_truncate_inode_pages
+c03ad2a0 r __ksymtab_invalidate_mapping_pages
+c03ad2a8 r __ksymtab_set_shrinker
+c03ad2b0 r __ksymtab_remove_shrinker
+c03ad2b8 r __ksymtab___kzalloc
+c03ad2c0 r __ksymtab_kstrdup
+c03ad2c8 r __ksymtab_kstrndup
+c03ad2d0 r __ksymtab_kmemdup
+c03ad2d8 r __ksymtab_strndup_user
+c03ad2e0 r __ksymtab_per_cpu__vm_event_states
+c03ad2e8 r __ksymtab_vm_stat
+c03ad2f0 r __ksymtab___mod_zone_page_state
+c03ad2f8 r __ksymtab_mod_zone_page_state
+c03ad300 r __ksymtab___inc_zone_page_state
+c03ad308 r __ksymtab___dec_zone_page_state
+c03ad310 r __ksymtab_inc_zone_page_state
+c03ad318 r __ksymtab_dec_zone_page_state
+c03ad320 r __ksymtab_refresh_vm_stats
+c03ad328 r __ksymtab_clear_bdi_congested
+c03ad330 r __ksymtab_set_bdi_congested
+c03ad338 r __ksymtab_congestion_wait
+c03ad340 r __ksymtab_congestion_wait_interruptible
+c03ad348 r __ksymtab_congestion_end
+c03ad350 r __ksymtab_install_page
+c03ad358 r __ksymtab_kmap_high
+c03ad360 r __ksymtab_kunmap_high
+c03ad368 r __ksymtab_page_address
+c03ad370 r __ksymtab_max_mapnr
+c03ad378 r __ksymtab_mem_map
+c03ad380 r __ksymtab_num_physpages
+c03ad388 r __ksymtab_high_memory
+c03ad390 r __ksymtab_vmalloc_earlyreserve
+c03ad398 r __ksymtab_get_user_pages
+c03ad3a0 r __ksymtab_vm_insert_page
+c03ad3a8 r __ksymtab_vm_insert_pfn
+c03ad3b0 r __ksymtab_remap_pfn_range
+c03ad3b8 r __ksymtab_unmap_mapping_range
+c03ad3c0 r __ksymtab_vmtruncate
+c03ad3c8 r __ksymtab_vmalloc_to_page
+c03ad3d0 r __ksymtab_vmalloc_to_pfn
+c03ad3d8 r __ksymtab_can_do_mlock
+c03ad3e0 r __ksymtab_vm_get_page_prot
+c03ad3e8 r __ksymtab___vm_enough_memory
+c03ad3f0 r __ksymtab_do_mmap_pgoff
+c03ad3f8 r __ksymtab_get_unmapped_area
+c03ad400 r __ksymtab_find_vma
+c03ad408 r __ksymtab_do_munmap
+c03ad410 r __ksymtab_do_brk
+c03ad418 r __ksymtab_vfree
+c03ad420 r __ksymtab_vunmap
+c03ad428 r __ksymtab_vmap
+c03ad430 r __ksymtab___vmalloc
+c03ad438 r __ksymtab_vmalloc
+c03ad440 r __ksymtab_vmalloc_user
+c03ad448 r __ksymtab_vmalloc_node
+c03ad450 r __ksymtab_vmalloc_32
+c03ad458 r __ksymtab_vmalloc_32_user
+c03ad460 r __ksymtab_remap_vmalloc_range
+c03ad468 r __ksymtab_blk_queue_bounce
+c03ad470 r __ksymtab_malloc_sizes
+c03ad478 r __ksymtab_kmem_cache_create
+c03ad480 r __ksymtab_kmem_cache_shrink
+c03ad488 r __ksymtab_kmem_cache_destroy
+c03ad490 r __ksymtab_kmem_cache_alloc
+c03ad498 r __ksymtab_kmem_cache_zalloc
+c03ad4a0 r __ksymtab___kmalloc
+c03ad4a8 r __ksymtab_krealloc
+c03ad4b0 r __ksymtab_kmem_cache_free
+c03ad4b8 r __ksymtab_kfree
+c03ad4c0 r __ksymtab_kmem_cache_size
+c03ad4c8 r __ksymtab_vfs_statfs
+c03ad4d0 r __ksymtab_filp_open
+c03ad4d8 r __ksymtab_dentry_open
+c03ad4e0 r __ksymtab_get_unused_fd
+c03ad4e8 r __ksymtab_put_unused_fd
+c03ad4f0 r __ksymtab_fd_install
+c03ad4f8 r __ksymtab_filp_close
+c03ad500 r __ksymtab_sys_close
+c03ad508 r __ksymtab_generic_file_open
+c03ad510 r __ksymtab_nonseekable_open
+c03ad518 r __ksymtab_generic_ro_fops
+c03ad520 r __ksymtab_generic_file_llseek
+c03ad528 r __ksymtab_remote_llseek
+c03ad530 r __ksymtab_no_llseek
+c03ad538 r __ksymtab_default_llseek
+c03ad540 r __ksymtab_vfs_llseek
+c03ad548 r __ksymtab_do_sync_read
+c03ad550 r __ksymtab_vfs_read
+c03ad558 r __ksymtab_do_sync_write
+c03ad560 r __ksymtab_vfs_write
+c03ad568 r __ksymtab_vfs_readv
+c03ad570 r __ksymtab_vfs_writev
+c03ad578 r __ksymtab_get_empty_filp
+c03ad580 r __ksymtab_fput
+c03ad588 r __ksymtab_fget
+c03ad590 r __ksymtab_deactivate_super
+c03ad598 r __ksymtab_lock_super
+c03ad5a0 r __ksymtab_unlock_super
+c03ad5a8 r __ksymtab_generic_shutdown_super
+c03ad5b0 r __ksymtab_sget
+c03ad5b8 r __ksymtab_drop_super
+c03ad5c0 r __ksymtab_get_super
+c03ad5c8 r __ksymtab_set_anon_super
+c03ad5d0 r __ksymtab_kill_anon_super
+c03ad5d8 r __ksymtab_kill_litter_super
+c03ad5e0 r __ksymtab_get_sb_bdev
+c03ad5e8 r __ksymtab_kill_block_super
+c03ad5f0 r __ksymtab_get_sb_nodev
+c03ad5f8 r __ksymtab_get_sb_single
+c03ad600 r __ksymtab_kern_mount
+c03ad608 r __ksymtab_register_chrdev_region
+c03ad610 r __ksymtab_unregister_chrdev_region
+c03ad618 r __ksymtab_alloc_chrdev_region
+c03ad620 r __ksymtab_cdev_init
+c03ad628 r __ksymtab_cdev_alloc
+c03ad630 r __ksymtab_cdev_del
+c03ad638 r __ksymtab_cdev_add
+c03ad640 r __ksymtab_register_chrdev
+c03ad648 r __ksymtab_unregister_chrdev
+c03ad650 r __ksymtab_directly_mappable_cdev_bdi
+c03ad658 r __ksymtab_generic_fillattr
+c03ad660 r __ksymtab_vfs_getattr
+c03ad668 r __ksymtab_vfs_stat
+c03ad670 r __ksymtab_vfs_lstat
+c03ad678 r __ksymtab_vfs_fstat
+c03ad680 r __ksymtab_inode_add_bytes
+c03ad688 r __ksymtab_inode_sub_bytes
+c03ad690 r __ksymtab_inode_get_bytes
+c03ad698 r __ksymtab_inode_set_bytes
+c03ad6a0 r __ksymtab_suid_dumpable
+c03ad6a8 r __ksymtab_register_binfmt
+c03ad6b0 r __ksymtab_unregister_binfmt
+c03ad6b8 r __ksymtab_copy_strings_kernel
+c03ad6c0 r __ksymtab_setup_arg_pages
+c03ad6c8 r __ksymtab_open_exec
+c03ad6d0 r __ksymtab_kernel_read
+c03ad6d8 r __ksymtab_flush_old_exec
+c03ad6e0 r __ksymtab_prepare_binprm
+c03ad6e8 r __ksymtab_compute_creds
+c03ad6f0 r __ksymtab_remove_arg_zero
+c03ad6f8 r __ksymtab_search_binary_handler
+c03ad700 r __ksymtab_set_binfmt
+c03ad708 r __ksymtab___user_walk
+c03ad710 r __ksymtab___user_walk_fd
+c03ad718 r __ksymtab_follow_down
+c03ad720 r __ksymtab_follow_up
+c03ad728 r __ksymtab_get_write_access
+c03ad730 r __ksymtab_getname
+c03ad738 r __ksymtab_lock_rename
+c03ad740 r __ksymtab_lookup_one_len_nd
+c03ad748 r __ksymtab_page_follow_link_light
+c03ad750 r __ksymtab_page_put_link
+c03ad758 r __ksymtab_page_readlink
+c03ad760 r __ksymtab___page_symlink
+c03ad768 r __ksymtab_page_symlink
+c03ad770 r __ksymtab_page_symlink_inode_operations
+c03ad778 r __ksymtab_path_lookup
+c03ad780 r __ksymtab_path_release
+c03ad788 r __ksymtab_path_walk
+c03ad790 r __ksymtab_permission
+c03ad798 r __ksymtab_vfs_permission
+c03ad7a0 r __ksymtab_file_permission
+c03ad7a8 r __ksymtab_unlock_rename
+c03ad7b0 r __ksymtab_vfs_create
+c03ad7b8 r __ksymtab_vfs_follow_link
+c03ad7c0 r __ksymtab_vfs_link
+c03ad7c8 r __ksymtab_vfs_mkdir
+c03ad7d0 r __ksymtab_vfs_mknod
+c03ad7d8 r __ksymtab_generic_permission
+c03ad7e0 r __ksymtab_vfs_readlink
+c03ad7e8 r __ksymtab_vfs_rename
+c03ad7f0 r __ksymtab_vfs_rmdir
+c03ad7f8 r __ksymtab_vfs_symlink
+c03ad800 r __ksymtab_vfs_unlink
+c03ad808 r __ksymtab_dentry_unhash
+c03ad810 r __ksymtab_generic_readlink
+c03ad818 r __ksymtab___f_setown
+c03ad820 r __ksymtab_f_setown
+c03ad828 r __ksymtab_fasync_helper
+c03ad830 r __ksymtab___kill_fasync
+c03ad838 r __ksymtab_kill_fasync
+c03ad840 r __ksymtab_vfs_readdir
+c03ad848 r __ksymtab_poll_initwait
+c03ad850 r __ksymtab_poll_freewait
+c03ad858 r __ksymtab_locks_init_lock
+c03ad860 r __ksymtab_locks_copy_lock
+c03ad868 r __ksymtab_posix_test_lock
+c03ad870 r __ksymtab_posix_lock_file
+c03ad878 r __ksymtab_posix_lock_file_wait
+c03ad880 r __ksymtab_locks_mandatory_area
+c03ad888 r __ksymtab_lease_modify
+c03ad890 r __ksymtab___break_lease
+c03ad898 r __ksymtab_lease_get_mtime
+c03ad8a0 r __ksymtab_setlease
+c03ad8a8 r __ksymtab_flock_lock_file_wait
+c03ad8b0 r __ksymtab_locks_remove_posix
+c03ad8b8 r __ksymtab_posix_unblock_lock
+c03ad8c0 r __ksymtab_lock_may_read
+c03ad8c8 r __ksymtab_lock_may_write
+c03ad8d0 r __ksymtab_dcache_lock
+c03ad8d8 r __ksymtab_d_instantiate_unique
+c03ad8e0 r __ksymtab_d_genocide
+c03ad8e8 r __ksymtab_d_alloc
+c03ad8f0 r __ksymtab_d_alloc_anon
+c03ad8f8 r __ksymtab_d_alloc_root
+c03ad900 r __ksymtab_d_delete
+c03ad908 r __ksymtab_d_find_alias
+c03ad910 r __ksymtab_d_instantiate
+c03ad918 r __ksymtab_d_invalidate
+c03ad920 r __ksymtab_d_lookup
+c03ad928 r __ksymtab_d_move
+c03ad930 r __ksymtab_d_path
+c03ad938 r __ksymtab_d_prune_aliases
+c03ad940 r __ksymtab_d_rehash
+c03ad948 r __ksymtab_d_splice_alias
+c03ad950 r __ksymtab_d_validate
+c03ad958 r __ksymtab_dget_locked
+c03ad960 r __ksymtab_dput
+c03ad968 r __ksymtab_find_inode_number
+c03ad970 r __ksymtab_have_submounts
+c03ad978 r __ksymtab_names_cachep
+c03ad980 r __ksymtab_shrink_dcache_parent
+c03ad988 r __ksymtab_shrink_dcache_sb
+c03ad990 r __ksymtab_inode_init_once
+c03ad998 r __ksymtab_clear_inode
+c03ad9a0 r __ksymtab_invalidate_inodes
+c03ad9a8 r __ksymtab_new_inode
+c03ad9b0 r __ksymtab_unlock_new_inode
+c03ad9b8 r __ksymtab_iunique
+c03ad9c0 r __ksymtab_igrab
+c03ad9c8 r __ksymtab_ilookup5_nowait
+c03ad9d0 r __ksymtab_ilookup5
+c03ad9d8 r __ksymtab_ilookup
+c03ad9e0 r __ksymtab_iget5_locked
+c03ad9e8 r __ksymtab_iget_locked
+c03ad9f0 r __ksymtab___insert_inode_hash
+c03ad9f8 r __ksymtab_remove_inode_hash
+c03ada00 r __ksymtab_generic_delete_inode
+c03ada08 r __ksymtab_iput
+c03ada10 r __ksymtab_bmap
+c03ada18 r __ksymtab_touch_atime
+c03ada20 r __ksymtab_file_update_time
+c03ada28 r __ksymtab_inode_needs_sync
+c03ada30 r __ksymtab_inode_double_lock
+c03ada38 r __ksymtab_inode_double_unlock
+c03ada40 r __ksymtab_init_special_inode
+c03ada48 r __ksymtab_inode_change_ok
+c03ada50 r __ksymtab_inode_setattr
+c03ada58 r __ksymtab_notify_change
+c03ada60 r __ksymtab_make_bad_inode
+c03ada68 r __ksymtab_is_bad_inode
+c03ada70 r __ksymtab_register_filesystem
+c03ada78 r __ksymtab_unregister_filesystem
+c03ada80 r __ksymtab_get_fs_type
+c03ada88 r __ksymtab_simple_set_mnt
+c03ada90 r __ksymtab_mntput_no_expire
+c03ada98 r __ksymtab_mnt_pin
+c03adaa0 r __ksymtab_mnt_unpin
+c03adaa8 r __ksymtab_may_umount_tree
+c03adab0 r __ksymtab_may_umount
+c03adab8 r __ksymtab_kick_iocb
+c03adac0 r __ksymtab_aio_complete
+c03adac8 r __ksymtab_aio_put_req
+c03adad0 r __ksymtab_wait_on_sync_kiocb
+c03adad8 r __ksymtab_seq_open
+c03adae0 r __ksymtab_seq_read
+c03adae8 r __ksymtab_seq_lseek
+c03adaf0 r __ksymtab_seq_release
+c03adaf8 r __ksymtab_seq_escape
+c03adb00 r __ksymtab_seq_printf
+c03adb08 r __ksymtab_seq_path
+c03adb10 r __ksymtab_single_open
+c03adb18 r __ksymtab_single_release
+c03adb20 r __ksymtab_seq_release_private
+c03adb28 r __ksymtab_seq_putc
+c03adb30 r __ksymtab_seq_puts
+c03adb38 r __ksymtab_generic_getxattr
+c03adb40 r __ksymtab_generic_listxattr
+c03adb48 r __ksymtab_generic_setxattr
+c03adb50 r __ksymtab_generic_removexattr
+c03adb58 r __ksymtab_dcache_dir_close
+c03adb60 r __ksymtab_dcache_dir_lseek
+c03adb68 r __ksymtab_dcache_dir_open
+c03adb70 r __ksymtab_dcache_readdir
+c03adb78 r __ksymtab_dcache_readdir_filter
+c03adb80 r __ksymtab_generic_read_dir
+c03adb88 r __ksymtab_get_sb_pseudo
+c03adb90 r __ksymtab_simple_commit_write
+c03adb98 r __ksymtab_simple_dir_inode_operations
+c03adba0 r __ksymtab_simple_dir_operations
+c03adba8 r __ksymtab_simple_empty
+c03adbb0 r __ksymtab_d_alloc_name
+c03adbb8 r __ksymtab_simple_fill_super
+c03adbc0 r __ksymtab_simple_getattr
+c03adbc8 r __ksymtab_simple_link
+c03adbd0 r __ksymtab_simple_lookup
+c03adbd8 r __ksymtab_simple_pin_fs
+c03adbe0 r __ksymtab_simple_prepare_write
+c03adbe8 r __ksymtab_simple_readpage
+c03adbf0 r __ksymtab_simple_release_fs
+c03adbf8 r __ksymtab_simple_rename
+c03adc00 r __ksymtab_simple_rmdir
+c03adc08 r __ksymtab_simple_statfs
+c03adc10 r __ksymtab_simple_sync_file
+c03adc18 r __ksymtab_simple_unlink
+c03adc20 r __ksymtab_simple_read_from_buffer
+c03adc28 r __ksymtab_simple_transaction_get
+c03adc30 r __ksymtab_simple_transaction_read
+c03adc38 r __ksymtab_simple_transaction_release
+c03adc40 r __ksymtab___mark_inode_dirty
+c03adc48 r __ksymtab_write_inode_now
+c03adc50 r __ksymtab_sync_inode
+c03adc58 r __ksymtab_generic_osync_inode
+c03adc60 r __ksymtab_drop_pagecache_sb
+c03adc68 r __ksymtab_generic_file_splice_read
+c03adc70 r __ksymtab___splice_from_pipe
+c03adc78 r __ksymtab_generic_file_splice_write_nolock
+c03adc80 r __ksymtab_generic_file_splice_write
+c03adc88 r __ksymtab_generic_splice_sendpage
+c03adc90 r __ksymtab___lock_buffer
+c03adc98 r __ksymtab_sync_blockdev
+c03adca0 r __ksymtab_freeze_bdev
+c03adca8 r __ksymtab_thaw_bdev
+c03adcb0 r __ksymtab_mark_buffer_async_write
+c03adcb8 r __ksymtab_sync_mapping_buffers
+c03adcc0 r __ksymtab_mark_buffer_dirty_inode
+c03adcc8 r __ksymtab___set_page_dirty_buffers
+c03adcd0 r __ksymtab___find_get_block
+c03adcd8 r __ksymtab___getblk
+c03adce0 r __ksymtab___breadahead
+c03adce8 r __ksymtab___bread
+c03adcf0 r __ksymtab_set_bh_page
+c03adcf8 r __ksymtab_block_invalidatepage
+c03add00 r __ksymtab_create_empty_buffers
+c03add08 r __ksymtab_unmap_underlying_metadata
+c03add10 r __ksymtab_nobh_prepare_write
+c03add18 r __ksymtab_nobh_commit_write
+c03add20 r __ksymtab_nobh_writepage
+c03add28 r __ksymtab_nobh_truncate_page
+c03add30 r __ksymtab_try_to_free_buffers
+c03add38 r __ksymtab_alloc_buffer_head
+c03add40 r __ksymtab_free_buffer_head
+c03add48 r __ksymtab___bforget
+c03add50 r __ksymtab___brelse
+c03add58 r __ksymtab___wait_on_buffer
+c03add60 r __ksymtab_block_commit_write
+c03add68 r __ksymtab_block_prepare_write
+c03add70 r __ksymtab_block_read_full_page
+c03add78 r __ksymtab_block_sync_page
+c03add80 r __ksymtab_block_truncate_page
+c03add88 r __ksymtab_block_write_full_page
+c03add90 r __ksymtab_cont_prepare_write
+c03add98 r __ksymtab_end_buffer_read_sync
+c03adda0 r __ksymtab_end_buffer_write_sync
+c03adda8 r __ksymtab_file_fsync
+c03addb0 r __ksymtab_fsync_bdev
+c03addb8 r __ksymtab_generic_block_bmap
+c03addc0 r __ksymtab_generic_commit_write
+c03addc8 r __ksymtab_generic_cont_expand
+c03addd0 r __ksymtab_generic_cont_expand_simple
+c03addd8 r __ksymtab_init_buffer
+c03adde0 r __ksymtab_invalidate_bdev
+c03adde8 r __ksymtab_ll_rw_block
+c03addf0 r __ksymtab_mark_buffer_dirty
+c03addf8 r __ksymtab_submit_bh
+c03ade00 r __ksymtab_sync_dirty_buffer
+c03ade08 r __ksymtab_unlock_buffer
+c03ade10 r __ksymtab_zero_fill_bio
+c03ade18 r __ksymtab_bio_alloc
+c03ade20 r __ksymtab_bio_put
+c03ade28 r __ksymtab_bio_free
+c03ade30 r __ksymtab_bio_endio
+c03ade38 r __ksymtab_bio_init
+c03ade40 r __ksymtab___bio_clone
+c03ade48 r __ksymtab_bio_clone
+c03ade50 r __ksymtab_bio_phys_segments
+c03ade58 r __ksymtab_bio_hw_segments
+c03ade60 r __ksymtab_bio_add_page
+c03ade68 r __ksymtab_bio_add_pc_page
+c03ade70 r __ksymtab_bio_get_nr_vecs
+c03ade78 r __ksymtab_bio_map_user
+c03ade80 r __ksymtab_bio_unmap_user
+c03ade88 r __ksymtab_bio_map_kern
+c03ade90 r __ksymtab_bio_pair_release
+c03ade98 r __ksymtab_bio_split
+c03adea0 r __ksymtab_bio_split_pool
+c03adea8 r __ksymtab_bio_copy_user
+c03adeb0 r __ksymtab_bio_uncopy_user
+c03adeb8 r __ksymtab_bioset_create
+c03adec0 r __ksymtab_bioset_free
+c03adec8 r __ksymtab_bio_alloc_bioset
+c03aded0 r __ksymtab_I_BDEV
+c03aded8 r __ksymtab_set_blocksize
+c03adee0 r __ksymtab_sb_set_blocksize
+c03adee8 r __ksymtab_sb_min_blocksize
+c03adef0 r __ksymtab_bdget
+c03adef8 r __ksymtab_bdput
+c03adf00 r __ksymtab_bd_claim
+c03adf08 r __ksymtab_bd_release
+c03adf10 r __ksymtab_open_by_devnum
+c03adf18 r __ksymtab_check_disk_change
+c03adf20 r __ksymtab_bd_set_size
+c03adf28 r __ksymtab_blkdev_get
+c03adf30 r __ksymtab_blkdev_put
+c03adf38 r __ksymtab_ioctl_by_bdev
+c03adf40 r __ksymtab_open_bdev_excl
+c03adf48 r __ksymtab_close_bdev_excl
+c03adf50 r __ksymtab___invalidate_device
+c03adf58 r __ksymtab___blockdev_direct_IO
+c03adf60 r __ksymtab_mpage_readpages
+c03adf68 r __ksymtab_mpage_readpage
+c03adf70 r __ksymtab_mpage_writepages
+c03adf78 r __ksymtab_mpage_writepage
+c03adf80 r __ksymtab_generic_file_revoke
+c03adf88 r __ksymtab_mb_cache_create
+c03adf90 r __ksymtab_mb_cache_shrink
+c03adf98 r __ksymtab_mb_cache_destroy
+c03adfa0 r __ksymtab_mb_cache_entry_alloc
+c03adfa8 r __ksymtab_mb_cache_entry_insert
+c03adfb0 r __ksymtab_mb_cache_entry_release
+c03adfb8 r __ksymtab_mb_cache_entry_free
+c03adfc0 r __ksymtab_mb_cache_entry_get
+c03adfc8 r __ksymtab_mb_cache_entry_find_first
+c03adfd0 r __ksymtab_mb_cache_entry_find_next
+c03adfd8 r __ksymtab_posix_acl_alloc
+c03adfe0 r __ksymtab_posix_acl_clone
+c03adfe8 r __ksymtab_posix_acl_valid
+c03adff0 r __ksymtab_posix_acl_equiv_mode
+c03adff8 r __ksymtab_posix_acl_from_mode
+c03ae000 r __ksymtab_posix_acl_create_masq
+c03ae008 r __ksymtab_posix_acl_chmod_masq
+c03ae010 r __ksymtab_posix_acl_permission
+c03ae018 r __ksymtab_posix_acl_from_xattr
+c03ae020 r __ksymtab_posix_acl_to_xattr
+c03ae028 r __ksymtab_mark_info_dirty
+c03ae030 r __ksymtab_register_quota_format
+c03ae038 r __ksymtab_unregister_quota_format
+c03ae040 r __ksymtab_dqstats
+c03ae048 r __ksymtab_dq_data_lock
+c03ae050 r __ksymtab_vfs_quota_on
+c03ae058 r __ksymtab_vfs_quota_on_mount
+c03ae060 r __ksymtab_vfs_quota_off
+c03ae068 r __ksymtab_vfs_quota_sync
+c03ae070 r __ksymtab_vfs_get_dqinfo
+c03ae078 r __ksymtab_vfs_set_dqinfo
+c03ae080 r __ksymtab_vfs_get_dqblk
+c03ae088 r __ksymtab_vfs_set_dqblk
+c03ae090 r __ksymtab_dquot_commit
+c03ae098 r __ksymtab_dquot_commit_info
+c03ae0a0 r __ksymtab_dquot_acquire
+c03ae0a8 r __ksymtab_dquot_release
+c03ae0b0 r __ksymtab_dquot_mark_dquot_dirty
+c03ae0b8 r __ksymtab_dquot_initialize
+c03ae0c0 r __ksymtab_dquot_drop
+c03ae0c8 r __ksymtab_dquot_alloc_space
+c03ae0d0 r __ksymtab_dquot_alloc_inode
+c03ae0d8 r __ksymtab_dquot_free_space
+c03ae0e0 r __ksymtab_dquot_free_inode
+c03ae0e8 r __ksymtab_dquot_transfer
+c03ae0f0 r __ksymtab___inode_dir_notify
+c03ae0f8 r __ksymtab_proc_symlink
+c03ae100 r __ksymtab_proc_mkdir
+c03ae108 r __ksymtab_create_proc_entry
+c03ae110 r __ksymtab_remove_proc_entry
+c03ae118 r __ksymtab_proc_root
+c03ae120 r __ksymtab_proc_root_fs
+c03ae128 r __ksymtab_proc_bus
+c03ae130 r __ksymtab_proc_root_driver
+c03ae138 r __ksymtab_maps_protect
+c03ae140 r __ksymtab_bdevname
+c03ae148 r __ksymtab___bdevname
+c03ae150 r __ksymtab_read_dev_sector
+c03ae158 r __ksymtab_journal_start
+c03ae160 r __ksymtab_journal_restart
+c03ae168 r __ksymtab_journal_extend
+c03ae170 r __ksymtab_journal_stop
+c03ae178 r __ksymtab_journal_lock_updates
+c03ae180 r __ksymtab_journal_unlock_updates
+c03ae188 r __ksymtab_journal_get_write_access
+c03ae190 r __ksymtab_journal_get_create_access
+c03ae198 r __ksymtab_journal_get_undo_access
+c03ae1a0 r __ksymtab_journal_dirty_data
+c03ae1a8 r __ksymtab_journal_dirty_metadata
+c03ae1b0 r __ksymtab_journal_release_buffer
+c03ae1b8 r __ksymtab_journal_forget
+c03ae1c0 r __ksymtab_journal_flush
+c03ae1c8 r __ksymtab_journal_revoke
+c03ae1d0 r __ksymtab_journal_init_dev
+c03ae1d8 r __ksymtab_journal_init_inode
+c03ae1e0 r __ksymtab_journal_update_format
+c03ae1e8 r __ksymtab_journal_check_used_features
+c03ae1f0 r __ksymtab_journal_check_available_features
+c03ae1f8 r __ksymtab_journal_set_features
+c03ae200 r __ksymtab_journal_create
+c03ae208 r __ksymtab_journal_load
+c03ae210 r __ksymtab_journal_destroy
+c03ae218 r __ksymtab_journal_update_superblock
+c03ae220 r __ksymtab_journal_abort
+c03ae228 r __ksymtab_journal_errno
+c03ae230 r __ksymtab_journal_ack_err
+c03ae238 r __ksymtab_journal_clear_err
+c03ae240 r __ksymtab_log_wait_commit
+c03ae248 r __ksymtab_journal_start_commit
+c03ae250 r __ksymtab_journal_force_commit_nested
+c03ae258 r __ksymtab_journal_wipe
+c03ae260 r __ksymtab_journal_blocks_per_page
+c03ae268 r __ksymtab_journal_invalidatepage
+c03ae270 r __ksymtab_journal_try_to_free_buffers
+c03ae278 r __ksymtab_journal_force_commit
+c03ae280 r __ksymtab_register_nls
+c03ae288 r __ksymtab_unregister_nls
+c03ae290 r __ksymtab_unload_nls
+c03ae298 r __ksymtab_load_nls
+c03ae2a0 r __ksymtab_load_nls_default
+c03ae2a8 r __ksymtab_utf8_mbtowc
+c03ae2b0 r __ksymtab_utf8_mbstowcs
+c03ae2b8 r __ksymtab_utf8_wctomb
+c03ae2c0 r __ksymtab_utf8_wcstombs
+c03ae2c8 r __ksymtab_cap_netlink_send
+c03ae2d0 r __ksymtab_cap_netlink_recv
+c03ae2d8 r __ksymtab_cap_capable
+c03ae2e0 r __ksymtab_cap_settime
+c03ae2e8 r __ksymtab_cap_ptrace
+c03ae2f0 r __ksymtab_cap_capget
+c03ae2f8 r __ksymtab_cap_capset_check
+c03ae300 r __ksymtab_cap_capset_set
+c03ae308 r __ksymtab_cap_bprm_set_security
+c03ae310 r __ksymtab_cap_bprm_apply_creds
+c03ae318 r __ksymtab_cap_bprm_secureexec
+c03ae320 r __ksymtab_cap_inode_setxattr
+c03ae328 r __ksymtab_cap_inode_removexattr
+c03ae330 r __ksymtab_cap_task_post_setuid
+c03ae338 r __ksymtab_cap_task_reparent_to_init
+c03ae340 r __ksymtab_cap_syslog
+c03ae348 r __ksymtab_cap_vm_enough_memory
+c03ae350 r __ksymtab_elv_rq_merge_ok
+c03ae358 r __ksymtab_elevator_init
+c03ae360 r __ksymtab_elevator_exit
+c03ae368 r __ksymtab_elv_rb_add
+c03ae370 r __ksymtab_elv_rb_del
+c03ae378 r __ksymtab_elv_rb_find
+c03ae380 r __ksymtab_elv_dispatch_sort
+c03ae388 r __ksymtab_elv_dispatch_add_tail
+c03ae390 r __ksymtab___elv_add_request
+c03ae398 r __ksymtab_elv_add_request
+c03ae3a0 r __ksymtab_elv_next_request
+c03ae3a8 r __ksymtab_elv_dequeue_request
+c03ae3b0 r __ksymtab_elv_queue_empty
+c03ae3b8 r __ksymtab_elv_rb_former_request
+c03ae3c0 r __ksymtab_elv_rb_latter_request
+c03ae3c8 r __ksymtab_blk_max_low_pfn
+c03ae3d0 r __ksymtab_blk_max_pfn
+c03ae3d8 r __ksymtab_blk_get_backing_dev_info
+c03ae3e0 r __ksymtab_blk_queue_prep_rq
+c03ae3e8 r __ksymtab_blk_queue_merge_bvec
+c03ae3f0 r __ksymtab_blk_queue_softirq_done
+c03ae3f8 r __ksymtab_blk_queue_make_request
+c03ae400 r __ksymtab_blk_queue_ordered
+c03ae408 r __ksymtab_blk_queue_issue_flush_fn
+c03ae410 r __ksymtab_blk_queue_bounce_limit
+c03ae418 r __ksymtab_blk_queue_max_sectors
+c03ae420 r __ksymtab_blk_queue_max_phys_segments
+c03ae428 r __ksymtab_blk_queue_max_hw_segments
+c03ae430 r __ksymtab_blk_queue_max_segment_size
+c03ae438 r __ksymtab_blk_queue_hardsect_size
+c03ae440 r __ksymtab_blk_queue_stack_limits
+c03ae448 r __ksymtab_blk_queue_segment_boundary
+c03ae450 r __ksymtab_blk_queue_dma_alignment
+c03ae458 r __ksymtab_blk_queue_find_tag
+c03ae460 r __ksymtab_blk_free_tags
+c03ae468 r __ksymtab_blk_queue_free_tags
+c03ae470 r __ksymtab_blk_init_tags
+c03ae478 r __ksymtab_blk_queue_init_tags
+c03ae480 r __ksymtab_blk_queue_resize_tags
+c03ae488 r __ksymtab_blk_queue_end_tag
+c03ae490 r __ksymtab_blk_queue_start_tag
+c03ae498 r __ksymtab_blk_queue_invalidate_tags
+c03ae4a0 r __ksymtab_blk_dump_rq_flags
+c03ae4a8 r __ksymtab_blk_recount_segments
+c03ae4b0 r __ksymtab_blk_rq_map_sg
+c03ae4b8 r __ksymtab_ll_back_merge_fn
+c03ae4c0 r __ksymtab_blk_plug_device
+c03ae4c8 r __ksymtab_blk_remove_plug
+c03ae4d0 r __ksymtab___generic_unplug_device
+c03ae4d8 r __ksymtab_generic_unplug_device
+c03ae4e0 r __ksymtab_blk_start_queue
+c03ae4e8 r __ksymtab_blk_stop_queue
+c03ae4f0 r __ksymtab_blk_sync_queue
+c03ae4f8 r __ksymtab_blk_run_queue
+c03ae500 r __ksymtab_blk_put_queue
+c03ae508 r __ksymtab_blk_cleanup_queue
+c03ae510 r __ksymtab_blk_alloc_queue
+c03ae518 r __ksymtab_blk_alloc_queue_node
+c03ae520 r __ksymtab_blk_init_queue
+c03ae528 r __ksymtab_blk_init_queue_node
+c03ae530 r __ksymtab_blk_get_queue
+c03ae538 r __ksymtab_blk_get_request
+c03ae540 r __ksymtab_blk_start_queueing
+c03ae548 r __ksymtab_blk_requeue_request
+c03ae550 r __ksymtab_blk_insert_request
+c03ae558 r __ksymtab_blk_rq_map_user
+c03ae560 r __ksymtab_blk_rq_map_user_iov
+c03ae568 r __ksymtab_blk_rq_unmap_user
+c03ae570 r __ksymtab_blk_rq_map_kern
+c03ae578 r __ksymtab_blk_execute_rq
+c03ae580 r __ksymtab_blkdev_issue_flush
+c03ae588 r __ksymtab_blk_put_request
+c03ae590 r __ksymtab_blk_end_sync_rq
+c03ae598 r __ksymtab_generic_make_request
+c03ae5a0 r __ksymtab_submit_bio
+c03ae5a8 r __ksymtab_end_that_request_first
+c03ae5b0 r __ksymtab_end_that_request_chunk
+c03ae5b8 r __ksymtab_blk_complete_request
+c03ae5c0 r __ksymtab_end_that_request_last
+c03ae5c8 r __ksymtab_end_request
+c03ae5d0 r __ksymtab_blk_rq_bio_prep
+c03ae5d8 r __ksymtab_kblockd_schedule_work
+c03ae5e0 r __ksymtab_kblockd_flush_work
+c03ae5e8 r __ksymtab_put_io_context
+c03ae5f0 r __ksymtab_get_io_context
+c03ae5f8 r __ksymtab_copy_io_context
+c03ae600 r __ksymtab_swap_io_context
+c03ae608 r __ksymtab_register_blkdev
+c03ae610 r __ksymtab_unregister_blkdev
+c03ae618 r __ksymtab_blk_register_region
+c03ae620 r __ksymtab_blk_unregister_region
+c03ae628 r __ksymtab_add_disk
+c03ae630 r __ksymtab_del_gendisk
+c03ae638 r __ksymtab_alloc_disk
+c03ae640 r __ksymtab_alloc_disk_node
+c03ae648 r __ksymtab_get_disk
+c03ae650 r __ksymtab_put_disk
+c03ae658 r __ksymtab_set_device_ro
+c03ae660 r __ksymtab_set_disk_ro
+c03ae668 r __ksymtab_bdev_read_only
+c03ae670 r __ksymtab_invalidate_partition
+c03ae678 r __ksymtab_scsi_command_size
+c03ae680 r __ksymtab_scsi_cmd_ioctl
+c03ae688 r __ksymtab_argv_free
+c03ae690 r __ksymtab_argv_split
+c03ae698 r __ksymtab___bitmap_empty
+c03ae6a0 r __ksymtab___bitmap_full
+c03ae6a8 r __ksymtab___bitmap_equal
+c03ae6b0 r __ksymtab___bitmap_complement
+c03ae6b8 r __ksymtab___bitmap_shift_right
+c03ae6c0 r __ksymtab___bitmap_shift_left
+c03ae6c8 r __ksymtab___bitmap_and
+c03ae6d0 r __ksymtab___bitmap_or
+c03ae6d8 r __ksymtab___bitmap_xor
+c03ae6e0 r __ksymtab___bitmap_andnot
+c03ae6e8 r __ksymtab___bitmap_intersects
+c03ae6f0 r __ksymtab___bitmap_subset
+c03ae6f8 r __ksymtab___bitmap_weight
+c03ae700 r __ksymtab_bitmap_scnprintf
+c03ae708 r __ksymtab___bitmap_parse
+c03ae710 r __ksymtab_bitmap_parse_user
+c03ae718 r __ksymtab_bitmap_scnlistprintf
+c03ae720 r __ksymtab_bitmap_parselist
+c03ae728 r __ksymtab_bitmap_remap
+c03ae730 r __ksymtab_bitmap_bitremap
+c03ae738 r __ksymtab_bitmap_find_free_region
+c03ae740 r __ksymtab_bitmap_release_region
+c03ae748 r __ksymtab_bitmap_allocate_region
+c03ae750 r __ksymtab_memparse
+c03ae758 r __ksymtab_get_option
+c03ae760 r __ksymtab_get_options
+c03ae768 r __ksymtab___first_cpu
+c03ae770 r __ksymtab___next_cpu
+c03ae778 r __ksymtab___any_online_cpu
+c03ae780 r __ksymtab__ctype
+c03ae788 r __ksymtab__atomic_dec_and_lock
+c03ae790 r __ksymtab_idr_pre_get
+c03ae798 r __ksymtab_idr_get_new_above
+c03ae7a0 r __ksymtab_idr_get_new
+c03ae7a8 r __ksymtab_idr_remove
+c03ae7b0 r __ksymtab_idr_destroy
+c03ae7b8 r __ksymtab_idr_find
+c03ae7c0 r __ksymtab_idr_replace
+c03ae7c8 r __ksymtab_idr_init
+c03ae7d0 r __ksymtab_ida_pre_get
+c03ae7d8 r __ksymtab_ida_get_new_above
+c03ae7e0 r __ksymtab_ida_get_new
+c03ae7e8 r __ksymtab_ida_remove
+c03ae7f0 r __ksymtab_ida_destroy
+c03ae7f8 r __ksymtab_ida_init
+c03ae800 r __ksymtab_int_sqrt
+c03ae808 r __ksymtab_kobject_set_name
+c03ae810 r __ksymtab_kobject_init
+c03ae818 r __ksymtab_kobject_register
+c03ae820 r __ksymtab_kobject_unregister
+c03ae828 r __ksymtab_kobject_get
+c03ae830 r __ksymtab_kobject_put
+c03ae838 r __ksymtab_kobject_add
+c03ae840 r __ksymtab_kobject_del
+c03ae848 r __ksymtab_kset_register
+c03ae850 r __ksymtab_kset_unregister
+c03ae858 r __ksymtab_subsystem_register
+c03ae860 r __ksymtab_subsystem_unregister
+c03ae868 r __ksymtab_subsys_create_file
+c03ae870 r __ksymtab_kref_init
+c03ae878 r __ksymtab_kref_get
+c03ae880 r __ksymtab_kref_put
+c03ae888 r __ksymtab_radix_tree_insert
+c03ae890 r __ksymtab_radix_tree_lookup_slot
+c03ae898 r __ksymtab_radix_tree_lookup
+c03ae8a0 r __ksymtab_radix_tree_tag_set
+c03ae8a8 r __ksymtab_radix_tree_tag_clear
+c03ae8b0 r __ksymtab_radix_tree_gang_lookup
+c03ae8b8 r __ksymtab_radix_tree_gang_lookup_tag
+c03ae8c0 r __ksymtab_radix_tree_delete
+c03ae8c8 r __ksymtab_radix_tree_tagged
+c03ae8d0 r __ksymtab_rb_insert_color
+c03ae8d8 r __ksymtab_rb_erase
+c03ae8e0 r __ksymtab_rb_first
+c03ae8e8 r __ksymtab_rb_last
+c03ae8f0 r __ksymtab_rb_next
+c03ae8f8 r __ksymtab_rb_prev
+c03ae900 r __ksymtab_rb_replace_node
+c03ae908 r __ksymtab___init_rwsem
+c03ae910 r __ksymtab_rwsem_down_read_failed
+c03ae918 r __ksymtab_rwsem_down_write_failed
+c03ae920 r __ksymtab_rwsem_wake
+c03ae928 r __ksymtab_rwsem_downgrade_wake
+c03ae930 r __ksymtab_strnicmp
+c03ae938 r __ksymtab_strcasecmp
+c03ae940 r __ksymtab_strncasecmp
+c03ae948 r __ksymtab_strlcpy
+c03ae950 r __ksymtab_strlcat
+c03ae958 r __ksymtab_strnchr
+c03ae960 r __ksymtab_strstrip
+c03ae968 r __ksymtab_strspn
+c03ae970 r __ksymtab_strcspn
+c03ae978 r __ksymtab_strpbrk
+c03ae980 r __ksymtab_strsep
+c03ae988 r __ksymtab_memcmp
+c03ae990 r __ksymtab_simple_strtoul
+c03ae998 r __ksymtab_simple_strtol
+c03ae9a0 r __ksymtab_simple_strtoull
+c03ae9a8 r __ksymtab_vsnprintf
+c03ae9b0 r __ksymtab_vscnprintf
+c03ae9b8 r __ksymtab_snprintf
+c03ae9c0 r __ksymtab_scnprintf
+c03ae9c8 r __ksymtab_vsprintf
+c03ae9d0 r __ksymtab_sprintf
+c03ae9d8 r __ksymtab_vsscanf
+c03ae9e0 r __ksymtab_sscanf
+c03ae9e8 r __ksymtab_kvasprintf
+c03ae9f0 r __ksymtab_kasprintf
+c03ae9f8 r __ksymtab_find_next_bit
+c03aea00 r __ksymtab_find_next_zero_bit
+c03aea08 r __ksymtab___delay
+c03aea10 r __ksymtab___const_udelay
+c03aea18 r __ksymtab___udelay
+c03aea20 r __ksymtab___ndelay
+c03aea28 r __ksymtab_memcpy
+c03aea30 r __ksymtab_memset
+c03aea38 r __ksymtab_memmove
+c03aea40 r __ksymtab___strncpy_from_user
+c03aea48 r __ksymtab_strncpy_from_user
+c03aea50 r __ksymtab_clear_user
+c03aea58 r __ksymtab___clear_user
+c03aea60 r __ksymtab_strnlen_user
+c03aea68 r __ksymtab___copy_to_user_ll
+c03aea70 r __ksymtab___copy_from_user_ll
+c03aea78 r __ksymtab___copy_from_user_ll_nozero
+c03aea80 r __ksymtab_copy_to_user
+c03aea88 r __ksymtab_copy_from_user
+c03aea90 r __ksymtab___div64_32
+c03aea98 r __ksymtab_div64_64
+c03aeaa0 r __ksymtab_sort
+c03aeaa8 r __ksymtab_match_token
+c03aeab0 r __ksymtab_match_int
+c03aeab8 r __ksymtab_match_octal
+c03aeac0 r __ksymtab_match_hex
+c03aeac8 r __ksymtab_match_strcpy
+c03aead0 r __ksymtab_match_strdup
+c03aead8 r __ksymtab_half_md4_transform
+c03aeae0 r __ksymtab_random32
+c03aeae8 r __ksymtab_srandom32
+c03aeaf0 r __ksymtab_hex_dump_to_buffer
+c03aeaf8 r __ksymtab_print_hex_dump
+c03aeb00 r __ksymtab_print_hex_dump_bytes
+c03aeb08 r __ksymtab_ioread8
+c03aeb10 r __ksymtab_ioread16
+c03aeb18 r __ksymtab_ioread16be
+c03aeb20 r __ksymtab_ioread32
+c03aeb28 r __ksymtab_ioread32be
+c03aeb30 r __ksymtab_iowrite8
+c03aeb38 r __ksymtab_iowrite16
+c03aeb40 r __ksymtab_iowrite16be
+c03aeb48 r __ksymtab_iowrite32
+c03aeb50 r __ksymtab_iowrite32be
+c03aeb58 r __ksymtab_ioread8_rep
+c03aeb60 r __ksymtab_ioread16_rep
+c03aeb68 r __ksymtab_ioread32_rep
+c03aeb70 r __ksymtab_iowrite8_rep
+c03aeb78 r __ksymtab_iowrite16_rep
+c03aeb80 r __ksymtab_iowrite32_rep
+c03aeb88 r __ksymtab_ioport_map
+c03aeb90 r __ksymtab_ioport_unmap
+c03aeb98 r __ksymtab_pci_iomap
+c03aeba0 r __ksymtab_pci_iounmap
+c03aeba8 r __ksymtab_devm_ioremap
+c03aebb0 r __ksymtab_devm_ioremap_nocache
+c03aebb8 r __ksymtab_devm_iounmap
+c03aebc0 r __ksymtab_devm_ioport_map
+c03aebc8 r __ksymtab_devm_ioport_unmap
+c03aebd0 r __ksymtab_pcim_iomap_table
+c03aebd8 r __ksymtab_pcim_iomap
+c03aebe0 r __ksymtab_pcim_iounmap
+c03aebe8 r __ksymtab_pcim_iomap_regions
+c03aebf0 r __ksymtab_pcim_iounmap_regions
+c03aebf8 r __ksymtab___spin_lock_init
+c03aec00 r __ksymtab___rwlock_init
+c03aec08 r __ksymtab_hweight32
+c03aec10 r __ksymtab_hweight16
+c03aec18 r __ksymtab_hweight8
+c03aec20 r __ksymtab_hweight64
+c03aec28 r __ksymtab_lock_kernel
+c03aec30 r __ksymtab_unlock_kernel
+c03aec38 r __ksymtab___list_add
+c03aec40 r __ksymtab_list_add
+c03aec48 r __ksymtab_list_del
+c03aec50 r __ksymtab_bitrev32
+c03aec58 r __ksymtab_crc32_le
+c03aec60 r __ksymtab_crc32_be
+c03aec68 r __ksymtab_zlib_inflate_workspacesize
+c03aec70 r __ksymtab_zlib_inflate
+c03aec78 r __ksymtab_zlib_inflateInit2
+c03aec80 r __ksymtab_zlib_inflateEnd
+c03aec88 r __ksymtab_zlib_inflateReset
+c03aec90 r __ksymtab_zlib_inflateIncomp
+c03aec98 r __ksymtab_textsearch_register
+c03aeca0 r __ksymtab_textsearch_unregister
+c03aeca8 r __ksymtab_textsearch_prepare
+c03aecb0 r __ksymtab_textsearch_find_continuous
+c03aecb8 r __ksymtab_textsearch_destroy
+c03aecc0 r __ksymtab_percpu_counter_mod
+c03aecc8 r __ksymtab_percpu_counter_sum
+c03aecd0 r __ksymtab_rdmsr_on_cpu
+c03aecd8 r __ksymtab_wrmsr_on_cpu
+c03aece0 r __ksymtab_rdmsr_safe_on_cpu
+c03aece8 r __ksymtab_wrmsr_safe_on_cpu
+c03aecf0 r __ksymtab_pci_bus_read_config_byte
+c03aecf8 r __ksymtab_pci_bus_read_config_word
+c03aed00 r __ksymtab_pci_bus_read_config_dword
+c03aed08 r __ksymtab_pci_bus_write_config_byte
+c03aed10 r __ksymtab_pci_bus_write_config_word
+c03aed18 r __ksymtab_pci_bus_write_config_dword
+c03aed20 r __ksymtab_pci_bus_alloc_resource
+c03aed28 r __ksymtab_pci_bus_add_devices
+c03aed30 r __ksymtab_pci_enable_bridges
+c03aed38 r __ksymtab_pci_root_buses
+c03aed40 r __ksymtab_alloc_pci_dev
+c03aed48 r __ksymtab_pci_scan_bus_parented
+c03aed50 r __ksymtab_pci_add_new_bus
+c03aed58 r __ksymtab_pci_do_scan_bus
+c03aed60 r __ksymtab_pci_scan_slot
+c03aed68 r __ksymtab_pci_scan_bridge
+c03aed70 r __ksymtab_pci_scan_single_device
+c03aed78 r __ksymtab_pci_remove_bus
+c03aed80 r __ksymtab_pci_remove_bus_device
+c03aed88 r __ksymtab_pci_remove_behind_bridge
+c03aed90 r __ksymtab_pci_choose_state
+c03aed98 r __ksymtab_pci_enable_device_bars
+c03aeda0 r __ksymtab_pci_enable_device
+c03aeda8 r __ksymtab_pcim_enable_device
+c03aedb0 r __ksymtab_pcim_pin_device
+c03aedb8 r __ksymtab_pci_disable_device
+c03aedc0 r __ksymtab_pci_find_capability
+c03aedc8 r __ksymtab_pci_bus_find_capability
+c03aedd0 r __ksymtab_pci_release_regions
+c03aedd8 r __ksymtab_pci_request_regions
+c03aede0 r __ksymtab_pci_release_region
+c03aede8 r __ksymtab_pci_request_region
+c03aedf0 r __ksymtab_pci_release_selected_regions
+c03aedf8 r __ksymtab_pci_request_selected_regions
+c03aee00 r __ksymtab_pci_set_master
+c03aee08 r __ksymtab_pci_set_mwi
+c03aee10 r __ksymtab_pci_clear_mwi
+c03aee18 r __ksymtab_pci_set_dma_mask
+c03aee20 r __ksymtab_pci_set_consistent_dma_mask
+c03aee28 r __ksymtab_pci_assign_resource
+c03aee30 r __ksymtab_pci_find_parent_resource
+c03aee38 r __ksymtab_pci_select_bars
+c03aee40 r __ksymtab_pci_set_power_state
+c03aee48 r __ksymtab_pci_save_state
+c03aee50 r __ksymtab_pci_restore_state
+c03aee58 r __ksymtab_pci_enable_wake
+c03aee60 r __ksymtab_isa_dma_bridge_buggy
+c03aee68 r __ksymtab_pci_pci_problems
+c03aee70 r __ksymtab_pcie_mch_quirk
+c03aee78 r __ksymtab_pci_fixup_device
+c03aee80 r __ksymtab_pci_match_id
+c03aee88 r __ksymtab_pci_match_device
+c03aee90 r __ksymtab___pci_register_driver
+c03aee98 r __ksymtab_pci_unregister_driver
+c03aeea0 r __ksymtab_pci_dev_driver
+c03aeea8 r __ksymtab_pci_bus_type
+c03aeeb0 r __ksymtab_pci_dev_get
+c03aeeb8 r __ksymtab_pci_dev_put
+c03aeec0 r __ksymtab_pci_dev_present
+c03aeec8 r __ksymtab_pci_find_present
+c03aeed0 r __ksymtab_pci_find_device
+c03aeed8 r __ksymtab_pci_find_slot
+c03aeee0 r __ksymtab_pci_find_bus
+c03aeee8 r __ksymtab_pci_find_next_bus
+c03aeef0 r __ksymtab_pci_get_device
+c03aeef8 r __ksymtab_pci_get_device_reverse
+c03aef00 r __ksymtab_pci_get_subsys
+c03aef08 r __ksymtab_pci_get_slot
+c03aef10 r __ksymtab_pci_get_bus_and_slot
+c03aef18 r __ksymtab_pci_get_class
+c03aef20 r __ksymtab_pci_map_rom
+c03aef28 r __ksymtab_pci_map_rom_copy
+c03aef30 r __ksymtab_pci_unmap_rom
+c03aef38 r __ksymtab_pci_remove_rom
+c03aef40 r __ksymtab_pci_proc_attach_device
+c03aef48 r __ksymtab_pci_proc_detach_bus
+c03aef50 r __ksymtab_pcie_port_service_register
+c03aef58 r __ksymtab_pcie_port_service_unregister
+c03aef60 r __ksymtab_pci_enable_msi
+c03aef68 r __ksymtab_pci_disable_msi
+c03aef70 r __ksymtab_pci_enable_msix
+c03aef78 r __ksymtab_pci_disable_msix
+c03aef80 r __ksymtab___ht_create_irq
+c03aef88 r __ksymtab_ht_create_irq
+c03aef90 r __ksymtab_ht_destroy_irq
+c03aef98 r __ksymtab_pci_setup_cardbus
+c03aefa0 r __ksymtab_pci_bus_size_bridges
+c03aefa8 r __ksymtab_pci_bus_assign_resources
+c03aefb0 r __ksymtab_pci_osc_support_set
+c03aefb8 r __ksymtab_pci_osc_control_set
+c03aefc0 r __ksymtab_fb_register_client
+c03aefc8 r __ksymtab_fb_unregister_client
+c03aefd0 r __ksymtab_acpi_os_printf
+c03aefd8 r __ksymtab_acpi_os_sleep
+c03aefe0 r __ksymtab_acpi_os_stall
+c03aefe8 r __ksymtab_acpi_os_read_port
+c03aeff0 r __ksymtab_acpi_os_write_port
+c03aeff8 r __ksymtab_acpi_os_read_pci_configuration
+c03af000 r __ksymtab_acpi_os_execute
+c03af008 r __ksymtab_acpi_os_wait_events_complete
+c03af010 r __ksymtab_acpi_os_create_semaphore
+c03af018 r __ksymtab_acpi_os_delete_semaphore
+c03af020 r __ksymtab_acpi_os_wait_semaphore
+c03af028 r __ksymtab_acpi_os_signal_semaphore
+c03af030 r __ksymtab_acpi_os_signal
+c03af038 r __ksymtab_max_cstate
+c03af040 r __ksymtab_acpi_do_set_cstate_limit
+c03af048 r __ksymtab_acpi_set_cstate_limit
+c03af050 r __ksymtab_acpi_extract_package
+c03af058 r __ksymtab_acpi_evaluate_integer
+c03af060 r __ksymtab_acpi_evaluate_reference
+c03af068 r __ksymtab_acpi_enable
+c03af070 r __ksymtab_acpi_disable
+c03af078 r __ksymtab_acpi_enable_event
+c03af080 r __ksymtab_acpi_set_gpe_type
+c03af088 r __ksymtab_acpi_enable_gpe
+c03af090 r __ksymtab_acpi_disable_gpe
+c03af098 r __ksymtab_acpi_disable_event
+c03af0a0 r __ksymtab_acpi_clear_event
+c03af0a8 r __ksymtab_acpi_clear_gpe
+c03af0b0 r __ksymtab_acpi_install_gpe_block
+c03af0b8 r __ksymtab_acpi_remove_gpe_block
+c03af0c0 r __ksymtab_acpi_install_fixed_event_handler
+c03af0c8 r __ksymtab_acpi_remove_fixed_event_handler
+c03af0d0 r __ksymtab_acpi_install_notify_handler
+c03af0d8 r __ksymtab_acpi_remove_notify_handler
+c03af0e0 r __ksymtab_acpi_install_gpe_handler
+c03af0e8 r __ksymtab_acpi_remove_gpe_handler
+c03af0f0 r __ksymtab_acpi_acquire_global_lock
+c03af0f8 r __ksymtab_acpi_release_global_lock
+c03af100 r __ksymtab_acpi_install_address_space_handler
+c03af108 r __ksymtab_acpi_remove_address_space_handler
+c03af110 r __ksymtab_acpi_get_sleep_type_data
+c03af118 r __ksymtab_acpi_get_register
+c03af120 r __ksymtab_acpi_set_register
+c03af128 r __ksymtab_acpi_set_firmware_waking_vector
+c03af130 r __ksymtab_acpi_enter_sleep_state_prep
+c03af138 r __ksymtab_acpi_enter_sleep_state
+c03af140 r __ksymtab_acpi_enter_sleep_state_s4bios
+c03af148 r __ksymtab_acpi_leave_sleep_state
+c03af150 r __ksymtab_acpi_evaluate_object
+c03af158 r __ksymtab_acpi_walk_namespace
+c03af160 r __ksymtab_acpi_get_devices
+c03af168 r __ksymtab_acpi_attach_data
+c03af170 r __ksymtab_acpi_detach_data
+c03af178 r __ksymtab_acpi_get_data
+c03af180 r __ksymtab_acpi_get_handle
+c03af188 r __ksymtab_acpi_get_name
+c03af190 r __ksymtab_acpi_get_object_info
+c03af198 r __ksymtab_acpi_get_id
+c03af1a0 r __ksymtab_acpi_get_type
+c03af1a8 r __ksymtab_acpi_get_parent
+c03af1b0 r __ksymtab_acpi_get_next_object
+c03af1b8 r __ksymtab_acpi_get_irq_routing_table
+c03af1c0 r __ksymtab_acpi_get_current_resources
+c03af1c8 r __ksymtab_acpi_set_current_resources
+c03af1d0 r __ksymtab_acpi_resource_to_address64
+c03af1d8 r __ksymtab_acpi_get_vendor_resource
+c03af1e0 r __ksymtab_acpi_rs_match_vendor_resource
+c03af1e8 r __ksymtab_acpi_walk_resources
+c03af1f0 r __ksymtab_acpi_load_table
+c03af1f8 r __ksymtab_acpi_get_table_header
+c03af200 r __ksymtab_acpi_unload_table_id
+c03af208 r __ksymtab_acpi_get_table
+c03af210 r __ksymtab_acpi_get_table_by_index
+c03af218 r __ksymtab_acpi_load_tables
+c03af220 r __ksymtab_acpi_ut_exception
+c03af228 r __ksymtab_acpi_enable_subsystem
+c03af230 r __ksymtab_acpi_initialize_objects
+c03af238 r __ksymtab_acpi_terminate
+c03af240 r __ksymtab_acpi_purge_cached_objects
+c03af248 r __ksymtab_acpi_gbl_FADT
+c03af250 r __ksymtab_acpi_format_exception
+c03af258 r __ksymtab_acpi_dbg_level
+c03af260 r __ksymtab_acpi_dbg_layer
+c03af268 r __ksymtab_acpi_gpe_count
+c03af270 r __ksymtab_acpi_root_dir
+c03af278 r __ksymtab_acpi_bus_get_device
+c03af280 r __ksymtab_acpi_bus_get_status
+c03af288 r __ksymtab_acpi_bus_get_power
+c03af290 r __ksymtab_acpi_bus_set_power
+c03af298 r __ksymtab_acpi_bus_generate_event
+c03af2a0 r __ksymtab_acpi_bus_receive_event
+c03af2a8 r __ksymtab_register_acpi_bus_type
+c03af2b0 r __ksymtab_unregister_acpi_bus_type
+c03af2b8 r __ksymtab_acpi_get_child
+c03af2c0 r __ksymtab_acpi_get_physical_device
+c03af2c8 r __ksymtab_acpi_bus_register_driver
+c03af2d0 r __ksymtab_acpi_bus_unregister_driver
+c03af2d8 r __ksymtab_acpi_bus_add
+c03af2e0 r __ksymtab_acpi_bus_start
+c03af2e8 r __ksymtab_ec_burst_enable
+c03af2f0 r __ksymtab_ec_burst_disable
+c03af2f8 r __ksymtab_ec_read
+c03af300 r __ksymtab_ec_write
+c03af308 r __ksymtab_ec_transaction
+c03af310 r __ksymtab_acpi_pci_register_driver
+c03af318 r __ksymtab_acpi_pci_unregister_driver
+c03af320 r __ksymtab_acpi_pci_irq_enable
+c03af328 r __ksymtab_acpi_get_pci_id
+c03af330 r __ksymtab_acpi_lock_ac_dir
+c03af338 r __ksymtab_acpi_unlock_ac_dir
+c03af340 r __ksymtab_acpi_lock_battery_dir
+c03af348 r __ksymtab_acpi_unlock_battery_dir
+c03af350 r __ksymtab_pnp_platform_devices
+c03af358 r __ksymtab_pnp_request_card_device
+c03af360 r __ksymtab_pnp_release_card_device
+c03af368 r __ksymtab_pnp_register_card_driver
+c03af370 r __ksymtab_pnp_unregister_card_driver
+c03af378 r __ksymtab_pnp_register_driver
+c03af380 r __ksymtab_pnp_unregister_driver
+c03af388 r __ksymtab_pnp_device_attach
+c03af390 r __ksymtab_pnp_device_detach
+c03af398 r __ksymtab_pnp_manual_config_dev
+c03af3a0 r __ksymtab_pnp_start_dev
+c03af3a8 r __ksymtab_pnp_stop_dev
+c03af3b0 r __ksymtab_pnp_activate_dev
+c03af3b8 r __ksymtab_pnp_disable_dev
+c03af3c0 r __ksymtab_pnp_resource_change
+c03af3c8 r __ksymtab_pnp_init_resource_table
+c03af3d0 r __ksymtab_pnp_is_active
+c03af3d8 r __ksymtab_add_disk_randomness
+c03af3e0 r __ksymtab_get_random_bytes
+c03af3e8 r __ksymtab_generate_random_uuid
+c03af3f0 r __ksymtab_secure_tcpv6_sequence_number
+c03af3f8 r __ksymtab_tty_std_termios
+c03af400 r __ksymtab_tty_mutex
+c03af408 r __ksymtab_tty_name
+c03af410 r __ksymtab_tty_insert_flip_string
+c03af418 r __ksymtab_tty_insert_flip_string_flags
+c03af420 r __ksymtab_tty_schedule_flip
+c03af428 r __ksymtab_tty_register_ldisc
+c03af430 r __ksymtab_tty_unregister_ldisc
+c03af438 r __ksymtab_tty_check_change
+c03af440 r __ksymtab_tty_hangup
+c03af448 r __ksymtab_tty_vhangup
+c03af450 r __ksymtab_tty_hung_up_p
+c03af458 r __ksymtab_stop_tty
+c03af460 r __ksymtab_start_tty
+c03af468 r __ksymtab_do_SAK
+c03af470 r __ksymtab_tty_flip_buffer_push
+c03af478 r __ksymtab_tty_register_device
+c03af480 r __ksymtab_tty_unregister_device
+c03af488 r __ksymtab_alloc_tty_driver
+c03af490 r __ksymtab_put_tty_driver
+c03af498 r __ksymtab_tty_set_operations
+c03af4a0 r __ksymtab_tty_register_driver
+c03af4a8 r __ksymtab_tty_unregister_driver
+c03af4b0 r __ksymtab_tty_devnum
+c03af4b8 r __ksymtab_proc_clear_tty
+c03af4c0 r __ksymtab_tty_wait_until_sent
+c03af4c8 r __ksymtab_tty_termios_baud_rate
+c03af4d0 r __ksymtab_tty_termios_input_baud_rate
+c03af4d8 r __ksymtab_tty_get_baud_rate
+c03af4e0 r __ksymtab_n_tty_ioctl
+c03af4e8 r __ksymtab_misc_register
+c03af4f0 r __ksymtab_misc_deregister
+c03af4f8 r __ksymtab_con_set_default_unimap
+c03af500 r __ksymtab_con_copy_unimap
+c03af508 r __ksymtab_con_is_bound
+c03af510 r __ksymtab_register_con_driver
+c03af518 r __ksymtab_unregister_con_driver
+c03af520 r __ksymtab_do_blank_screen
+c03af528 r __ksymtab_do_unblank_screen
+c03af530 r __ksymtab_color_table
+c03af538 r __ksymtab_default_red
+c03af540 r __ksymtab_default_grn
+c03af548 r __ksymtab_default_blu
+c03af550 r __ksymtab_update_region
+c03af558 r __ksymtab_redraw_screen
+c03af560 r __ksymtab_vc_resize
+c03af568 r __ksymtab_vc_lock_resize
+c03af570 r __ksymtab_fg_console
+c03af578 r __ksymtab_console_blank_hook
+c03af580 r __ksymtab_console_blanked
+c03af588 r __ksymtab_vc_cons
+c03af590 r __ksymtab_take_over_console
+c03af598 r __ksymtab_give_up_console
+c03af5a0 r __ksymtab_handle_sysrq
+c03af5a8 r __ksymtab_register_sysrq_key
+c03af5b0 r __ksymtab_unregister_sysrq_key
+c03af5b8 r __ksymtab_rtc_register
+c03af5c0 r __ksymtab_rtc_unregister
+c03af5c8 r __ksymtab_rtc_control
+c03af5d0 r __ksymtab_hpet_alloc
+c03af5d8 r __ksymtab_hpet_register
+c03af5e0 r __ksymtab_hpet_unregister
+c03af5e8 r __ksymtab_hpet_control
+c03af5f0 r __ksymtab_uart_update_timeout
+c03af5f8 r __ksymtab_uart_get_baud_rate
+c03af600 r __ksymtab_uart_get_divisor
+c03af608 r __ksymtab_uart_match_port
+c03af610 r __ksymtab_uart_write_wakeup
+c03af618 r __ksymtab_uart_register_driver
+c03af620 r __ksymtab_uart_unregister_driver
+c03af628 r __ksymtab_uart_suspend_port
+c03af630 r __ksymtab_uart_resume_port
+c03af638 r __ksymtab_uart_add_one_port
+c03af640 r __ksymtab_uart_remove_one_port
+c03af648 r __ksymtab_serial8250_register_port
+c03af650 r __ksymtab_serial8250_unregister_port
+c03af658 r __ksymtab_serial8250_unregister_by_port
+c03af660 r __ksymtab_serial8250_suspend_port
+c03af668 r __ksymtab_serial8250_resume_port
+c03af670 r __ksymtab_dev_driver_string
+c03af678 r __ksymtab_cpu_sysdev_class
+c03af680 r __ksymtab_dpm_runtime_resume
+c03af688 r __ksymtab_dpm_runtime_suspend
+c03af690 r __ksymtab_dmam_alloc_coherent
+c03af698 r __ksymtab_dmam_free_coherent
+c03af6a0 r __ksymtab_dmam_alloc_noncoherent
+c03af6a8 r __ksymtab_dmam_free_noncoherent
+c03af6b0 r __ksymtab_dmam_declare_coherent_memory
+c03af6b8 r __ksymtab_dmam_release_declared_memory
+c03af6c0 r __ksymtab_dma_pool_create
+c03af6c8 r __ksymtab_dma_pool_destroy
+c03af6d0 r __ksymtab_dma_pool_alloc
+c03af6d8 r __ksymtab_dma_pool_free
+c03af6e0 r __ksymtab_dmam_pool_create
+c03af6e8 r __ksymtab_dmam_pool_destroy
+c03af6f0 r __ksymtab_release_firmware
+c03af6f8 r __ksymtab_request_firmware
+c03af700 r __ksymtab_request_firmware_nowait
+c03af708 r __ksymtab_noautodma
+c03af710 r __ksymtab_ide_hwifs
+c03af718 r __ksymtab_ide_unregister
+c03af720 r __ksymtab_ide_register_hw_with_fixup
+c03af728 r __ksymtab_ide_register_hw
+c03af730 r __ksymtab_ide_spin_wait_hwgroup
+c03af738 r __ksymtab_system_bus_clock
+c03af740 r __ksymtab_generic_ide_ioctl
+c03af748 r __ksymtab_ide_lock
+c03af750 r __ksymtab_ide_end_request
+c03af758 r __ksymtab_ide_get_error_location
+c03af760 r __ksymtab_ide_end_drive_cmd
+c03af768 r __ksymtab_ide_stall_queue
+c03af770 r __ksymtab_ide_init_drive_cmd
+c03af778 r __ksymtab_ide_do_drive_cmd
+c03af780 r __ksymtab_default_hwif_mmiops
+c03af788 r __ksymtab_SELECT_DRIVE
+c03af790 r __ksymtab_ide_fix_driveid
+c03af798 r __ksymtab_ide_fixstring
+c03af7a0 r __ksymtab_drive_is_ready
+c03af7a8 r __ksymtab_ide_wait_stat
+c03af7b0 r __ksymtab_ide_config_drive_speed
+c03af7b8 r __ksymtab_ide_set_handler
+c03af7c0 r __ksymtab_ide_execute_command
+c03af7c8 r __ksymtab_ide_do_reset
+c03af7d0 r __ksymtab_ide_xfer_verbose
+c03af7d8 r __ksymtab_ide_rate_filter
+c03af7e0 r __ksymtab_ide_dump_status
+c03af7e8 r __ksymtab_probe_hwif_init
+c03af7f0 r __ksymtab_task_no_data_intr
+c03af7f8 r __ksymtab_task_in_intr
+c03af800 r __ksymtab_pre_task_out_intr
+c03af808 r __ksymtab_ide_raw_taskfile
+c03af810 r __ksymtab_ide_dma_host_off
+c03af818 r __ksymtab_ide_dma_off_quietly
+c03af820 r __ksymtab_ide_dma_off
+c03af828 r __ksymtab_ide_dma_host_on
+c03af830 r __ksymtab___ide_dma_on
+c03af838 r __ksymtab___ide_dma_check
+c03af840 r __ksymtab___ide_dma_end
+c03af848 r __ksymtab___ide_dma_bad_drive
+c03af850 r __ksymtab___ide_dma_good_drive
+c03af858 r __ksymtab_ide_dma_verbose
+c03af860 r __ksymtab___ide_dma_lostirq
+c03af868 r __ksymtab___ide_dma_timeout
+c03af870 r __ksymtab_cdrom_get_last_written
+c03af878 r __ksymtab_register_cdrom
+c03af880 r __ksymtab_unregister_cdrom
+c03af888 r __ksymtab_cdrom_open
+c03af890 r __ksymtab_cdrom_release
+c03af898 r __ksymtab_cdrom_ioctl
+c03af8a0 r __ksymtab_cdrom_media_changed
+c03af8a8 r __ksymtab_cdrom_number_of_slots
+c03af8b0 r __ksymtab_cdrom_mode_select
+c03af8b8 r __ksymtab_cdrom_mode_sense
+c03af8c0 r __ksymtab_init_cdrom_command
+c03af8c8 r __ksymtab_cdrom_get_media_event
+c03af8d0 r __ksymtab_usb_disabled
+c03af8d8 r __ksymtab_usb_put_dev
+c03af8e0 r __ksymtab_usb_get_dev
+c03af8e8 r __ksymtab_usb_hub_tt_clear_buffer
+c03af8f0 r __ksymtab_usb_lock_device_for_reset
+c03af8f8 r __ksymtab_usb_find_interface
+c03af900 r __ksymtab_usb_ifnum_to_if
+c03af908 r __ksymtab_usb_altnum_to_altsetting
+c03af910 r __ksymtab___usb_get_extra_descriptor
+c03af918 r __ksymtab_usb_find_device
+c03af920 r __ksymtab_usb_get_current_frame_number
+c03af928 r __ksymtab_usb_buffer_alloc
+c03af930 r __ksymtab_usb_buffer_free
+c03af938 r __ksymtab_usb_buffer_map_sg
+c03af940 r __ksymtab_usb_buffer_unmap_sg
+c03af948 r __ksymtab_usb_reset_device
+c03af950 r __ksymtab_usb_reset_composite_device
+c03af958 r __ksymtab_usb_calc_bus_time
+c03af960 r __ksymtab_usb_hcd_giveback_urb
+c03af968 r __ksymtab_usb_create_hcd
+c03af970 r __ksymtab_usb_get_hcd
+c03af978 r __ksymtab_usb_put_hcd
+c03af980 r __ksymtab_usb_add_hcd
+c03af988 r __ksymtab_usb_remove_hcd
+c03af990 r __ksymtab_usb_hcd_platform_shutdown
+c03af998 r __ksymtab_usb_init_urb
+c03af9a0 r __ksymtab_usb_alloc_urb
+c03af9a8 r __ksymtab_usb_free_urb
+c03af9b0 r __ksymtab_usb_get_urb
+c03af9b8 r __ksymtab_usb_submit_urb
+c03af9c0 r __ksymtab_usb_unlink_urb
+c03af9c8 r __ksymtab_usb_kill_urb
+c03af9d0 r __ksymtab_usb_control_msg
+c03af9d8 r __ksymtab_usb_bulk_msg
+c03af9e0 r __ksymtab_usb_sg_init
+c03af9e8 r __ksymtab_usb_sg_cancel
+c03af9f0 r __ksymtab_usb_sg_wait
+c03af9f8 r __ksymtab_usb_get_descriptor
+c03afa00 r __ksymtab_usb_get_status
+c03afa08 r __ksymtab_usb_string
+c03afa10 r __ksymtab_usb_clear_halt
+c03afa18 r __ksymtab_usb_reset_configuration
+c03afa20 r __ksymtab_usb_set_interface
+c03afa28 r __ksymtab_usb_driver_claim_interface
+c03afa30 r __ksymtab_usb_driver_release_interface
+c03afa38 r __ksymtab_usb_register_dev
+c03afa40 r __ksymtab_usb_deregister_dev
+c03afa48 r __ksymtab_usb_hcd_pci_probe
+c03afa50 r __ksymtab_usb_hcd_pci_remove
+c03afa58 r __ksymtab_usb_hcd_pci_suspend
+c03afa60 r __ksymtab_usb_hcd_pci_resume
+c03afa68 r __ksymtab_usb_hcd_pci_shutdown
+c03afa70 r __ksymtab_serio_interrupt
+c03afa78 r __ksymtab___serio_register_port
+c03afa80 r __ksymtab_serio_unregister_port
+c03afa88 r __ksymtab_serio_unregister_child_port
+c03afa90 r __ksymtab___serio_register_driver
+c03afa98 r __ksymtab_serio_unregister_driver
+c03afaa0 r __ksymtab_serio_open
+c03afaa8 r __ksymtab_serio_close
+c03afab0 r __ksymtab_serio_rescan
+c03afab8 r __ksymtab_serio_reconnect
+c03afac0 r __ksymtab_ps2_sendbyte
+c03afac8 r __ksymtab_ps2_drain
+c03afad0 r __ksymtab_ps2_is_keyboard_id
+c03afad8 r __ksymtab_ps2_command
+c03afae0 r __ksymtab_ps2_schedule_command
+c03afae8 r __ksymtab_ps2_init
+c03afaf0 r __ksymtab_ps2_handle_ack
+c03afaf8 r __ksymtab_ps2_handle_response
+c03afb00 r __ksymtab_ps2_cmd_aborted
+c03afb08 r __ksymtab_input_event
+c03afb10 r __ksymtab_input_inject_event
+c03afb18 r __ksymtab_input_grab_device
+c03afb20 r __ksymtab_input_release_device
+c03afb28 r __ksymtab_input_open_device
+c03afb30 r __ksymtab_input_flush_device
+c03afb38 r __ksymtab_input_close_device
+c03afb40 r __ksymtab_input_allocate_device
+c03afb48 r __ksymtab_input_free_device
+c03afb50 r __ksymtab_input_set_capability
+c03afb58 r __ksymtab_input_register_device
+c03afb60 r __ksymtab_input_unregister_device
+c03afb68 r __ksymtab_input_register_handler
+c03afb70 r __ksymtab_input_unregister_handler
+c03afb78 r __ksymtab_input_register_handle
+c03afb80 r __ksymtab_input_unregister_handle
+c03afb88 r __ksymtab_register_md_personality
+c03afb90 r __ksymtab_unregister_md_personality
+c03afb98 r __ksymtab_md_error
+c03afba0 r __ksymtab_md_done_sync
+c03afba8 r __ksymtab_md_write_start
+c03afbb0 r __ksymtab_md_write_end
+c03afbb8 r __ksymtab_md_register_thread
+c03afbc0 r __ksymtab_md_unregister_thread
+c03afbc8 r __ksymtab_md_wakeup_thread
+c03afbd0 r __ksymtab_md_check_recovery
+c03afbd8 r __ksymtab_bitmap_startwrite
+c03afbe0 r __ksymtab_bitmap_endwrite
+c03afbe8 r __ksymtab_bitmap_start_sync
+c03afbf0 r __ksymtab_bitmap_end_sync
+c03afbf8 r __ksymtab_bitmap_unplug
+c03afc00 r __ksymtab_bitmap_close_sync
+c03afc08 r __ksymtab_dm_get_mapinfo
+c03afc10 r __ksymtab_dm_vcalloc
+c03afc18 r __ksymtab_dm_get_device
+c03afc20 r __ksymtab_dm_put_device
+c03afc28 r __ksymtab_dm_table_event
+c03afc30 r __ksymtab_dm_table_get_size
+c03afc38 r __ksymtab_dm_table_get_mode
+c03afc40 r __ksymtab_dm_table_get_md
+c03afc48 r __ksymtab_dm_table_put
+c03afc50 r __ksymtab_dm_table_get
+c03afc58 r __ksymtab_dm_table_unplug_all
+c03afc60 r __ksymtab_dm_table_flush_all
+c03afc68 r __ksymtab_dm_register_target
+c03afc70 r __ksymtab_dm_unregister_target
+c03afc78 r __ksymtab_dm_io_client_create
+c03afc80 r __ksymtab_dm_io_client_resize
+c03afc88 r __ksymtab_dm_io_client_destroy
+c03afc90 r __ksymtab_dm_io
+c03afc98 r __ksymtab_kcopyd_client_create
+c03afca0 r __ksymtab_kcopyd_client_destroy
+c03afca8 r __ksymtab_kcopyd_copy
+c03afcb0 r __ksymtab_dmi_check_system
+c03afcb8 r __ksymtab_dmi_get_system_info
+c03afcc0 r __ksymtab_dmi_name_in_vendors
+c03afcc8 r __ksymtab_dmi_find_device
+c03afcd0 r __ksymtab_dma_sync_wait
+c03afcd8 r __ksymtab_dma_chan_cleanup
+c03afce0 r __ksymtab_dma_async_client_register
+c03afce8 r __ksymtab_dma_async_client_unregister
+c03afcf0 r __ksymtab_dma_async_client_chan_request
+c03afcf8 r __ksymtab_dma_async_device_register
+c03afd00 r __ksymtab_dma_async_device_unregister
+c03afd08 r __ksymtab_dma_async_memcpy_buf_to_buf
+c03afd10 r __ksymtab_dma_async_memcpy_buf_to_pg
+c03afd18 r __ksymtab_dma_async_memcpy_pg_to_pg
+c03afd20 r __ksymtab_dma_async_tx_descriptor_init
+c03afd28 r __ksymtab_pcibios_get_irq_routing_table
+c03afd30 r __ksymtab_pcibios_set_irq_routing
+c03afd38 r __ksymtab_save_processor_state
+c03afd40 r __ksymtab_restore_processor_state
+c03afd48 r __ksymtab_brioctl_set
+c03afd50 r __ksymtab_vlan_ioctl_set
+c03afd58 r __ksymtab_dlci_ioctl_set
+c03afd60 r __ksymtab_move_addr_to_kernel
+c03afd68 r __ksymtab_move_addr_to_user
+c03afd70 r __ksymtab_sock_create
+c03afd78 r __ksymtab_sock_create_kern
+c03afd80 r __ksymtab_sock_create_lite
+c03afd88 r __ksymtab_sock_map_fd
+c03afd90 r __ksymtab_sock_recvmsg
+c03afd98 r __ksymtab_sock_register
+c03afda0 r __ksymtab_sock_release
+c03afda8 r __ksymtab_sock_sendmsg
+c03afdb0 r __ksymtab_sock_unregister
+c03afdb8 r __ksymtab_sock_wake_async
+c03afdc0 r __ksymtab_sockfd_lookup
+c03afdc8 r __ksymtab_kernel_sendmsg
+c03afdd0 r __ksymtab_kernel_recvmsg
+c03afdd8 r __ksymtab_kernel_bind
+c03afde0 r __ksymtab_kernel_listen
+c03afde8 r __ksymtab_kernel_accept
+c03afdf0 r __ksymtab_kernel_connect
+c03afdf8 r __ksymtab_kernel_getsockname
+c03afe00 r __ksymtab_kernel_getpeername
+c03afe08 r __ksymtab_kernel_getsockopt
+c03afe10 r __ksymtab_kernel_setsockopt
+c03afe18 r __ksymtab_kernel_sendpage
+c03afe20 r __ksymtab_kernel_sock_ioctl
+c03afe28 r __ksymtab_sock_queue_rcv_skb
+c03afe30 r __ksymtab_sk_receive_skb
+c03afe38 r __ksymtab___sk_dst_check
+c03afe40 r __ksymtab_sk_dst_check
+c03afe48 r __ksymtab_sk_wait_data
+c03afe50 r __ksymtab_sk_reset_timer
+c03afe58 r __ksymtab_sk_stop_timer
+c03afe60 r __ksymtab_lock_sock_nested
+c03afe68 r __ksymtab_release_sock
+c03afe70 r __ksymtab_sock_get_timestamp
+c03afe78 r __ksymtab_sock_get_timestampns
+c03afe80 r __ksymtab_sock_enable_timestamp
+c03afe88 r __ksymtab_sock_common_getsockopt
+c03afe90 r __ksymtab_sock_common_recvmsg
+c03afe98 r __ksymtab_sock_common_setsockopt
+c03afea0 r __ksymtab_sk_common_release
+c03afea8 r __ksymtab_proto_register
+c03afeb0 r __ksymtab_proto_unregister
+c03afeb8 r __ksymtab_sk_alloc
+c03afec0 r __ksymtab_sk_free
+c03afec8 r __ksymtab_sk_send_sigurg
+c03afed0 r __ksymtab_sock_alloc_send_skb
+c03afed8 r __ksymtab_sock_init_data
+c03afee0 r __ksymtab_sock_kfree_s
+c03afee8 r __ksymtab_sock_kmalloc
+c03afef0 r __ksymtab_sock_no_accept
+c03afef8 r __ksymtab_sock_no_bind
+c03aff00 r __ksymtab_sock_no_connect
+c03aff08 r __ksymtab_sock_no_getname
+c03aff10 r __ksymtab_sock_no_getsockopt
+c03aff18 r __ksymtab_sock_no_ioctl
+c03aff20 r __ksymtab_sock_no_listen
+c03aff28 r __ksymtab_sock_no_mmap
+c03aff30 r __ksymtab_sock_no_poll
+c03aff38 r __ksymtab_sock_no_recvmsg
+c03aff40 r __ksymtab_sock_no_sendmsg
+c03aff48 r __ksymtab_sock_no_sendpage
+c03aff50 r __ksymtab_sock_no_setsockopt
+c03aff58 r __ksymtab_sock_no_shutdown
+c03aff60 r __ksymtab_sock_no_socketpair
+c03aff68 r __ksymtab_sock_rfree
+c03aff70 r __ksymtab_sock_setsockopt
+c03aff78 r __ksymtab_sock_wfree
+c03aff80 r __ksymtab_sock_wmalloc
+c03aff88 r __ksymtab_sock_i_uid
+c03aff90 r __ksymtab_sock_i_ino
+c03aff98 r __ksymtab_sysctl_optmem_max
+c03affa0 r __ksymtab_sysctl_rmem_max
+c03affa8 r __ksymtab_sysctl_wmem_max
+c03affb0 r __ksymtab_reqsk_queue_alloc
+c03affb8 r __ksymtab_reqsk_queue_destroy
+c03affc0 r __ksymtab_skb_truesize_bug
+c03affc8 r __ksymtab_skb_store_bits
+c03affd0 r __ksymtab____pskb_trim
+c03affd8 r __ksymtab___kfree_skb
+c03affe0 r __ksymtab_kfree_skb
+c03affe8 r __ksymtab___pskb_pull_tail
+c03afff0 r __ksymtab___alloc_skb
+c03afff8 r __ksymtab___netdev_alloc_skb
+c03b0000 r __ksymtab_pskb_copy
+c03b0008 r __ksymtab_pskb_expand_head
+c03b0010 r __ksymtab_skb_checksum
+c03b0018 r __ksymtab_skb_clone
+c03b0020 r __ksymtab_skb_copy
+c03b0028 r __ksymtab_skb_copy_and_csum_bits
+c03b0030 r __ksymtab_skb_copy_and_csum_dev
+c03b0038 r __ksymtab_skb_copy_bits
+c03b0040 r __ksymtab_skb_copy_expand
+c03b0048 r __ksymtab_skb_over_panic
+c03b0050 r __ksymtab_skb_pad
+c03b0058 r __ksymtab_skb_realloc_headroom
+c03b0060 r __ksymtab_skb_under_panic
+c03b0068 r __ksymtab_skb_dequeue
+c03b0070 r __ksymtab_skb_dequeue_tail
+c03b0078 r __ksymtab_skb_insert
+c03b0080 r __ksymtab_skb_queue_purge
+c03b0088 r __ksymtab_skb_queue_head
+c03b0090 r __ksymtab_skb_queue_tail
+c03b0098 r __ksymtab_skb_unlink
+c03b00a0 r __ksymtab_skb_append
+c03b00a8 r __ksymtab_skb_split
+c03b00b0 r __ksymtab_skb_prepare_seq_read
+c03b00b8 r __ksymtab_skb_seq_read
+c03b00c0 r __ksymtab_skb_abort_seq_read
+c03b00c8 r __ksymtab_skb_find_text
+c03b00d0 r __ksymtab_skb_append_datato_frags
+c03b00d8 r __ksymtab_csum_partial_copy_fromiovecend
+c03b00e0 r __ksymtab_memcpy_fromiovec
+c03b00e8 r __ksymtab_memcpy_fromiovecend
+c03b00f0 r __ksymtab_memcpy_toiovec
+c03b00f8 r __ksymtab_skb_kill_datagram
+c03b0100 r __ksymtab___skb_checksum_complete_head
+c03b0108 r __ksymtab___skb_checksum_complete
+c03b0110 r __ksymtab_datagram_poll
+c03b0118 r __ksymtab_skb_copy_and_csum_datagram_iovec
+c03b0120 r __ksymtab_skb_copy_datagram_iovec
+c03b0128 r __ksymtab_skb_free_datagram
+c03b0130 r __ksymtab_skb_recv_datagram
+c03b0138 r __ksymtab_sk_stream_write_space
+c03b0140 r __ksymtab_sk_stream_wait_connect
+c03b0148 r __ksymtab_sk_stream_wait_close
+c03b0150 r __ksymtab_sk_stream_wait_memory
+c03b0158 r __ksymtab_sk_stream_rfree
+c03b0160 r __ksymtab_sk_stream_error
+c03b0168 r __ksymtab___sk_stream_mem_reclaim
+c03b0170 r __ksymtab_sk_stream_mem_schedule
+c03b0178 r __ksymtab_sk_stream_kill_queues
+c03b0180 r __ksymtab___scm_destroy
+c03b0188 r __ksymtab___scm_send
+c03b0190 r __ksymtab_put_cmsg
+c03b0198 r __ksymtab_scm_detach_fds
+c03b01a0 r __ksymtab_scm_fp_dup
+c03b01a8 r __ksymtab_gnet_stats_start_copy
+c03b01b0 r __ksymtab_gnet_stats_start_copy_compat
+c03b01b8 r __ksymtab_gnet_stats_copy_basic
+c03b01c0 r __ksymtab_gnet_stats_copy_rate_est
+c03b01c8 r __ksymtab_gnet_stats_copy_queue
+c03b01d0 r __ksymtab_gnet_stats_copy_app
+c03b01d8 r __ksymtab_gnet_stats_finish_copy
+c03b01e0 r __ksymtab_gen_kill_estimator
+c03b01e8 r __ksymtab_gen_new_estimator
+c03b01f0 r __ksymtab_gen_replace_estimator
+c03b01f8 r __ksymtab_dev_base_lock
+c03b0200 r __ksymtab_dev_getbyhwaddr
+c03b0208 r __ksymtab___dev_getfirstbyhwtype
+c03b0210 r __ksymtab_dev_getfirstbyhwtype
+c03b0218 r __ksymtab_netdev_features_change
+c03b0220 r __ksymtab___netif_schedule
+c03b0228 r __ksymtab___netif_rx_schedule
+c03b0230 r __ksymtab_dev_kfree_skb_any
+c03b0238 r __ksymtab_netif_device_detach
+c03b0240 r __ksymtab_netif_device_attach
+c03b0248 r __ksymtab_skb_gso_segment
+c03b0250 r __ksymtab_netdev_rx_csum_fault
+c03b0258 r __ksymtab_netif_rx_ni
+c03b0260 r __ksymtab_register_netdev
+c03b0268 r __ksymtab_alloc_netdev
+c03b0270 r __ksymtab_unregister_netdev
+c03b0278 r __ksymtab_netdev_compute_features
+c03b0280 r __ksymtab___dev_get_by_index
+c03b0288 r __ksymtab___dev_get_by_name
+c03b0290 r __ksymtab___dev_remove_pack
+c03b0298 r __ksymtab_dev_valid_name
+c03b02a0 r __ksymtab_dev_add_pack
+c03b02a8 r __ksymtab_dev_alloc_name
+c03b02b0 r __ksymtab_dev_close
+c03b02b8 r __ksymtab_dev_get_by_flags
+c03b02c0 r __ksymtab_dev_get_by_index
+c03b02c8 r __ksymtab_dev_get_by_name
+c03b02d0 r __ksymtab_dev_open
+c03b02d8 r __ksymtab_dev_queue_xmit
+c03b02e0 r __ksymtab_dev_remove_pack
+c03b02e8 r __ksymtab_dev_set_allmulti
+c03b02f0 r __ksymtab_dev_set_promiscuity
+c03b02f8 r __ksymtab_dev_change_flags
+c03b0300 r __ksymtab_dev_set_mtu
+c03b0308 r __ksymtab_dev_set_mac_address
+c03b0310 r __ksymtab_free_netdev
+c03b0318 r __ksymtab_netdev_boot_setup_check
+c03b0320 r __ksymtab_netdev_set_master
+c03b0328 r __ksymtab_netdev_state_change
+c03b0330 r __ksymtab_netif_receive_skb
+c03b0338 r __ksymtab_netif_rx
+c03b0340 r __ksymtab_register_gifconf
+c03b0348 r __ksymtab_register_netdevice
+c03b0350 r __ksymtab_register_netdevice_notifier
+c03b0358 r __ksymtab_skb_checksum_help
+c03b0360 r __ksymtab_synchronize_net
+c03b0368 r __ksymtab_unregister_netdevice
+c03b0370 r __ksymtab_unregister_netdevice_notifier
+c03b0378 r __ksymtab_net_enable_timestamp
+c03b0380 r __ksymtab_net_disable_timestamp
+c03b0388 r __ksymtab_dev_get_flags
+c03b0390 r __ksymtab_dev_load
+c03b0398 r __ksymtab_per_cpu__softnet_data
+c03b03a0 r __ksymtab_dev_ethtool
+c03b03a8 r __ksymtab_ethtool_op_get_link
+c03b03b0 r __ksymtab_ethtool_op_get_sg
+c03b03b8 r __ksymtab_ethtool_op_get_tso
+c03b03c0 r __ksymtab_ethtool_op_get_tx_csum
+c03b03c8 r __ksymtab_ethtool_op_set_sg
+c03b03d0 r __ksymtab_ethtool_op_set_tso
+c03b03d8 r __ksymtab_ethtool_op_set_tx_csum
+c03b03e0 r __ksymtab_ethtool_op_set_tx_hw_csum
+c03b03e8 r __ksymtab_ethtool_op_set_ufo
+c03b03f0 r __ksymtab_ethtool_op_get_ufo
+c03b03f8 r __ksymtab_dev_mc_add
+c03b0400 r __ksymtab_dev_mc_delete
+c03b0408 r __ksymtab_dev_mc_upload
+c03b0410 r __ksymtab___dst_free
+c03b0418 r __ksymtab_dst_alloc
+c03b0420 r __ksymtab_dst_destroy
+c03b0428 r __ksymtab_neigh_for_each
+c03b0430 r __ksymtab___neigh_for_each_release
+c03b0438 r __ksymtab_neigh_seq_start
+c03b0440 r __ksymtab_neigh_seq_next
+c03b0448 r __ksymtab_neigh_seq_stop
+c03b0450 r __ksymtab___neigh_event_send
+c03b0458 r __ksymtab_neigh_changeaddr
+c03b0460 r __ksymtab_neigh_compat_output
+c03b0468 r __ksymtab_neigh_connected_output
+c03b0470 r __ksymtab_neigh_create
+c03b0478 r __ksymtab_neigh_destroy
+c03b0480 r __ksymtab_neigh_event_ns
+c03b0488 r __ksymtab_neigh_ifdown
+c03b0490 r __ksymtab_neigh_lookup
+c03b0498 r __ksymtab_neigh_lookup_nodev
+c03b04a0 r __ksymtab_neigh_parms_alloc
+c03b04a8 r __ksymtab_neigh_parms_alloc_default
+c03b04b0 r __ksymtab_neigh_parms_release
+c03b04b8 r __ksymtab_neigh_rand_reach_time
+c03b04c0 r __ksymtab_neigh_resolve_output
+c03b04c8 r __ksymtab_neigh_table_clear
+c03b04d0 r __ksymtab_neigh_table_init
+c03b04d8 r __ksymtab_neigh_table_init_no_netlink
+c03b04e0 r __ksymtab_neigh_update
+c03b04e8 r __ksymtab_pneigh_enqueue
+c03b04f0 r __ksymtab_pneigh_lookup
+c03b04f8 r __ksymtab_neigh_sysctl_register
+c03b0500 r __ksymtab_neigh_sysctl_unregister
+c03b0508 r __ksymtab___rta_fill
+c03b0510 r __ksymtab_rtattr_strlcpy
+c03b0518 r __ksymtab_rtattr_parse
+c03b0520 r __ksymtab___rtattr_parse_nested_compat
+c03b0528 r __ksymtab_rtnetlink_put_metrics
+c03b0530 r __ksymtab_rtnl_lock
+c03b0538 r __ksymtab_rtnl_trylock
+c03b0540 r __ksymtab_rtnl_unlock
+c03b0548 r __ksymtab_rtnl_unicast
+c03b0550 r __ksymtab_rtnl_notify
+c03b0558 r __ksymtab_rtnl_set_sk_err
+c03b0560 r __ksymtab_net_msg_warn
+c03b0568 r __ksymtab_net_ratelimit
+c03b0570 r __ksymtab_in_aton
+c03b0578 r __ksymtab_in4_pton
+c03b0580 r __ksymtab_in6_pton
+c03b0588 r __ksymtab_linkwatch_fire_event
+c03b0590 r __ksymtab_sk_chk_filter
+c03b0598 r __ksymtab_sk_run_filter
+c03b05a0 r __ksymtab_flow_cache_genid
+c03b05a8 r __ksymtab_flow_cache_lookup
+c03b05b0 r __ksymtab_eth_type_trans
+c03b05b8 r __ksymtab_ether_setup
+c03b05c0 r __ksymtab_alloc_etherdev
+c03b05c8 r __ksymtab_netif_carrier_on
+c03b05d0 r __ksymtab_netif_carrier_off
+c03b05d8 r __ksymtab_noop_qdisc
+c03b05e0 r __ksymtab_qdisc_create_dflt
+c03b05e8 r __ksymtab_qdisc_destroy
+c03b05f0 r __ksymtab_qdisc_reset
+c03b05f8 r __ksymtab_qdisc_lock_tree
+c03b0600 r __ksymtab_qdisc_unlock_tree
+c03b0608 r __ksymtab_qdisc_watchdog_init
+c03b0610 r __ksymtab_qdisc_watchdog_schedule
+c03b0618 r __ksymtab_qdisc_watchdog_cancel
+c03b0620 r __ksymtab_qdisc_tree_decrease_qlen
+c03b0628 r __ksymtab_tcf_destroy_chain
+c03b0630 r __ksymtab_qdisc_get_rtab
+c03b0638 r __ksymtab_qdisc_put_rtab
+c03b0640 r __ksymtab_register_qdisc
+c03b0648 r __ksymtab_unregister_qdisc
+c03b0650 r __ksymtab_tc_classify
+c03b0658 r __ksymtab_register_tcf_proto_ops
+c03b0660 r __ksymtab_unregister_tcf_proto_ops
+c03b0668 r __ksymtab_tcf_exts_validate
+c03b0670 r __ksymtab_tcf_exts_destroy
+c03b0678 r __ksymtab_tcf_exts_change
+c03b0680 r __ksymtab_tcf_exts_dump
+c03b0688 r __ksymtab_tcf_exts_dump_stats
+c03b0690 r __ksymtab_bfifo_qdisc_ops
+c03b0698 r __ksymtab_pfifo_qdisc_ops
+c03b06a0 r __ksymtab_netlink_ack
+c03b06a8 r __ksymtab_netlink_run_queue
+c03b06b0 r __ksymtab_netlink_broadcast
+c03b06b8 r __ksymtab_netlink_dump_start
+c03b06c0 r __ksymtab_netlink_kernel_create
+c03b06c8 r __ksymtab_netlink_register_notifier
+c03b06d0 r __ksymtab_netlink_set_nonroot
+c03b06d8 r __ksymtab_netlink_unicast
+c03b06e0 r __ksymtab_netlink_unregister_notifier
+c03b06e8 r __ksymtab_nlmsg_notify
+c03b06f0 r __ksymtab_nla_validate
+c03b06f8 r __ksymtab_nla_parse
+c03b0700 r __ksymtab_nla_find
+c03b0708 r __ksymtab_nla_strlcpy
+c03b0710 r __ksymtab___nla_reserve
+c03b0718 r __ksymtab___nla_reserve_nohdr
+c03b0720 r __ksymtab_nla_reserve
+c03b0728 r __ksymtab_nla_reserve_nohdr
+c03b0730 r __ksymtab___nla_put
+c03b0738 r __ksymtab___nla_put_nohdr
+c03b0740 r __ksymtab_nla_put
+c03b0748 r __ksymtab_nla_put_nohdr
+c03b0750 r __ksymtab_nla_memcpy
+c03b0758 r __ksymtab_nla_memcmp
+c03b0760 r __ksymtab_nla_strcmp
+c03b0768 r __ksymtab_genl_sock
+c03b0770 r __ksymtab_genl_register_ops
+c03b0778 r __ksymtab_genl_unregister_ops
+c03b0780 r __ksymtab_genl_register_family
+c03b0788 r __ksymtab_genl_unregister_family
+c03b0790 r __ksymtab_nf_afinfo
+c03b0798 r __ksymtab_nf_hooks
+c03b07a0 r __ksymtab_nf_register_hook
+c03b07a8 r __ksymtab_nf_unregister_hook
+c03b07b0 r __ksymtab_nf_register_hooks
+c03b07b8 r __ksymtab_nf_unregister_hooks
+c03b07c0 r __ksymtab_nf_hook_slow
+c03b07c8 r __ksymtab_skb_make_writable
+c03b07d0 r __ksymtab_nf_proto_csum_replace4
+c03b07d8 r __ksymtab_ip_ct_attach
+c03b07e0 r __ksymtab_nf_ct_attach
+c03b07e8 r __ksymtab_nf_ct_destroy
+c03b07f0 r __ksymtab_nf_conntrack_destroy
+c03b07f8 r __ksymtab_nf_log_register
+c03b0800 r __ksymtab_nf_log_unregister_pf
+c03b0808 r __ksymtab_nf_log_unregister
+c03b0810 r __ksymtab_nf_log_packet
+c03b0818 r __ksymtab_nf_register_queue_handler
+c03b0820 r __ksymtab_nf_unregister_queue_handler
+c03b0828 r __ksymtab_nf_reinject
+c03b0830 r __ksymtab_nf_register_sockopt
+c03b0838 r __ksymtab_nf_unregister_sockopt
+c03b0840 r __ksymtab_nf_setsockopt
+c03b0848 r __ksymtab_nf_getsockopt
+c03b0850 r __ksymtab___ip_select_ident
+c03b0858 r __ksymtab_ip_route_input
+c03b0860 r __ksymtab_ip_route_output_key
+c03b0868 r __ksymtab_inet_add_protocol
+c03b0870 r __ksymtab_inet_del_protocol
+c03b0878 r __ksymtab_ip_statistics
+c03b0880 r __ksymtab_ip_defrag
+c03b0888 r __ksymtab_ip_fragment
+c03b0890 r __ksymtab_ip_generic_getfrag
+c03b0898 r __ksymtab_ip_queue_xmit
+c03b08a0 r __ksymtab_ip_send_check
+c03b08a8 r __ksymtab_ip_cmsg_recv
+c03b08b0 r __ksymtab_ip_getsockopt
+c03b08b8 r __ksymtab_ip_setsockopt
+c03b08c0 r __ksymtab_inet_put_port
+c03b08c8 r __ksymtab_inet_listen_wlock
+c03b08d0 r __ksymtab_inet_twsk_deschedule
+c03b08d8 r __ksymtab_inet_csk_timer_bug_msg
+c03b08e0 r __ksymtab_inet_csk_accept
+c03b08e8 r __ksymtab_inet_csk_init_xmit_timers
+c03b08f0 r __ksymtab_inet_csk_clear_xmit_timers
+c03b08f8 r __ksymtab_inet_csk_delete_keepalive_timer
+c03b0900 r __ksymtab_inet_csk_reset_keepalive_timer
+c03b0908 r __ksymtab_inet_csk_destroy_sock
+c03b0910 r __ksymtab_sysctl_tcp_mem
+c03b0918 r __ksymtab_sysctl_tcp_rmem
+c03b0920 r __ksymtab_sysctl_tcp_wmem
+c03b0928 r __ksymtab_tcp_memory_allocated
+c03b0930 r __ksymtab_tcp_sockets_allocated
+c03b0938 r __ksymtab_tcp_memory_pressure
+c03b0940 r __ksymtab_tcp_enter_memory_pressure
+c03b0948 r __ksymtab_tcp_tso_segment
+c03b0950 r __ksymtab_tcp_close
+c03b0958 r __ksymtab_tcp_disconnect
+c03b0960 r __ksymtab_tcp_getsockopt
+c03b0968 r __ksymtab_tcp_ioctl
+c03b0970 r __ksymtab_tcp_poll
+c03b0978 r __ksymtab_tcp_read_sock
+c03b0980 r __ksymtab_tcp_recvmsg
+c03b0988 r __ksymtab_tcp_sendmsg
+c03b0990 r __ksymtab_tcp_sendpage
+c03b0998 r __ksymtab_tcp_setsockopt
+c03b09a0 r __ksymtab_tcp_shutdown
+c03b09a8 r __ksymtab_tcp_statistics
+c03b09b0 r __ksymtab_sysctl_tcp_ecn
+c03b09b8 r __ksymtab_sysctl_tcp_reordering
+c03b09c0 r __ksymtab_tcp_parse_options
+c03b09c8 r __ksymtab_tcp_rcv_established
+c03b09d0 r __ksymtab_tcp_rcv_state_process
+c03b09d8 r __ksymtab_tcp_initialize_rcv_mss
+c03b09e0 r __ksymtab_tcp_connect
+c03b09e8 r __ksymtab_tcp_make_synack
+c03b09f0 r __ksymtab_tcp_simple_retransmit
+c03b09f8 r __ksymtab_tcp_sync_mss
+c03b0a00 r __ksymtab_sysctl_tcp_tso_win_divisor
+c03b0a08 r __ksymtab_tcp_mtup_init
+c03b0a10 r __ksymtab_tcp_init_xmit_timers
+c03b0a18 r __ksymtab_tcp_v4_destroy_sock
+c03b0a20 r __ksymtab_ipv4_specific
+c03b0a28 r __ksymtab_tcp_hashinfo
+c03b0a30 r __ksymtab_tcp_prot
+c03b0a38 r __ksymtab_tcp_unhash
+c03b0a40 r __ksymtab_tcp_v4_conn_request
+c03b0a48 r __ksymtab_tcp_v4_connect
+c03b0a50 r __ksymtab_tcp_v4_do_rcv
+c03b0a58 r __ksymtab_tcp_v4_remember_stamp
+c03b0a60 r __ksymtab_tcp_v4_send_check
+c03b0a68 r __ksymtab_tcp_v4_syn_recv_sock
+c03b0a70 r __ksymtab_tcp_proc_register
+c03b0a78 r __ksymtab_tcp_proc_unregister
+c03b0a80 r __ksymtab_sysctl_tcp_low_latency
+c03b0a88 r __ksymtab_tcp_check_req
+c03b0a90 r __ksymtab_tcp_child_process
+c03b0a98 r __ksymtab_tcp_create_openreq_child
+c03b0aa0 r __ksymtab_tcp_timewait_state_process
+c03b0aa8 r __ksymtab_ip4_datagram_connect
+c03b0ab0 r __ksymtab_udp_disconnect
+c03b0ab8 r __ksymtab_udp_hash
+c03b0ac0 r __ksymtab_udp_hash_lock
+c03b0ac8 r __ksymtab_udp_ioctl
+c03b0ad0 r __ksymtab_udp_get_port
+c03b0ad8 r __ksymtab_udp_prot
+c03b0ae0 r __ksymtab_udp_sendmsg
+c03b0ae8 r __ksymtab_udp_lib_getsockopt
+c03b0af0 r __ksymtab_udp_lib_setsockopt
+c03b0af8 r __ksymtab_udp_poll
+c03b0b00 r __ksymtab_udp_proc_register
+c03b0b08 r __ksymtab_udp_proc_unregister
+c03b0b10 r __ksymtab_udplite_hash
+c03b0b18 r __ksymtab_udplite_prot
+c03b0b20 r __ksymtab_udplite_get_port
+c03b0b28 r __ksymtab_arp_broken_ops
+c03b0b30 r __ksymtab_arp_find
+c03b0b38 r __ksymtab_arp_create
+c03b0b40 r __ksymtab_arp_xmit
+c03b0b48 r __ksymtab_arp_send
+c03b0b50 r __ksymtab_arp_tbl
+c03b0b58 r __ksymtab_icmp_err_convert
+c03b0b60 r __ksymtab_icmp_send
+c03b0b68 r __ksymtab_icmp_statistics
+c03b0b70 r __ksymtab_xrlim_allow
+c03b0b78 r __ksymtab_in_dev_finish_destroy
+c03b0b80 r __ksymtab_inet_select_addr
+c03b0b88 r __ksymtab_inetdev_by_index
+c03b0b90 r __ksymtab_register_inetaddr_notifier
+c03b0b98 r __ksymtab_unregister_inetaddr_notifier
+c03b0ba0 r __ksymtab_inet_ehash_secret
+c03b0ba8 r __ksymtab_build_ehash_secret
+c03b0bb0 r __ksymtab_inet_sk_rebuild_header
+c03b0bb8 r __ksymtab_inet_accept
+c03b0bc0 r __ksymtab_inet_bind
+c03b0bc8 r __ksymtab_inet_dgram_connect
+c03b0bd0 r __ksymtab_inet_dgram_ops
+c03b0bd8 r __ksymtab_inet_getname
+c03b0be0 r __ksymtab_inet_ioctl
+c03b0be8 r __ksymtab_inet_listen
+c03b0bf0 r __ksymtab_inet_register_protosw
+c03b0bf8 r __ksymtab_inet_release
+c03b0c00 r __ksymtab_inet_sendmsg
+c03b0c08 r __ksymtab_inet_shutdown
+c03b0c10 r __ksymtab_inet_sock_destruct
+c03b0c18 r __ksymtab_inet_stream_connect
+c03b0c20 r __ksymtab_inet_stream_ops
+c03b0c28 r __ksymtab_inet_unregister_protosw
+c03b0c30 r __ksymtab_net_statistics
+c03b0c38 r __ksymtab_ip_mc_dec_group
+c03b0c40 r __ksymtab_ip_mc_inc_group
+c03b0c48 r __ksymtab_ip_mc_join_group
+c03b0c50 r __ksymtab_ip_mc_rejoin_group
+c03b0c58 r __ksymtab_inet_addr_type
+c03b0c60 r __ksymtab_ip_dev_find
+c03b0c68 r __ksymtab_xfrm4_tunnel_register
+c03b0c70 r __ksymtab_xfrm4_tunnel_deregister
+c03b0c78 r __ksymtab_ip_route_me_harder
+c03b0c80 r __ksymtab_ip_xfrm_me_harder
+c03b0c88 r __ksymtab_ip_nat_decode_session
+c03b0c90 r __ksymtab_nf_ip_checksum
+c03b0c98 r __ksymtab_xfrm4_rcv
+c03b0ca0 r __ksymtab_xfrm_cfg_mutex
+c03b0ca8 r __ksymtab_xfrm_policy_count
+c03b0cb0 r __ksymtab_xfrm_register_type
+c03b0cb8 r __ksymtab_xfrm_unregister_type
+c03b0cc0 r __ksymtab_xfrm_dst_lookup
+c03b0cc8 r __ksymtab_xfrm_register_mode
+c03b0cd0 r __ksymtab_xfrm_unregister_mode
+c03b0cd8 r __ksymtab_xfrm_policy_alloc
+c03b0ce0 r __ksymtab___xfrm_policy_destroy
+c03b0ce8 r __ksymtab_xfrm_spd_getinfo
+c03b0cf0 r __ksymtab_xfrm_policy_insert
+c03b0cf8 r __ksymtab_xfrm_policy_bysel_ctx
+c03b0d00 r __ksymtab_xfrm_policy_byid
+c03b0d08 r __ksymtab_xfrm_policy_flush
+c03b0d10 r __ksymtab_xfrm_policy_walk
+c03b0d18 r __ksymtab_xfrm_policy_delete
+c03b0d20 r __ksymtab___xfrm_lookup
+c03b0d28 r __ksymtab_xfrm_lookup
+c03b0d30 r __ksymtab_xfrm_decode_session
+c03b0d38 r __ksymtab___xfrm_policy_check
+c03b0d40 r __ksymtab___xfrm_route_forward
+c03b0d48 r __ksymtab_xfrm_dst_ifdown
+c03b0d50 r __ksymtab_xfrm_init_pmtu
+c03b0d58 r __ksymtab_xfrm_bundle_ok
+c03b0d60 r __ksymtab_xfrm_policy_register_afinfo
+c03b0d68 r __ksymtab_xfrm_policy_unregister_afinfo
+c03b0d70 r __ksymtab_xfrm_nl
+c03b0d78 r __ksymtab_km_waitq
+c03b0d80 r __ksymtab_xfrm_state_alloc
+c03b0d88 r __ksymtab___xfrm_state_destroy
+c03b0d90 r __ksymtab___xfrm_state_delete
+c03b0d98 r __ksymtab_xfrm_state_delete
+c03b0da0 r __ksymtab_xfrm_state_flush
+c03b0da8 r __ksymtab_xfrm_sad_getinfo
+c03b0db0 r __ksymtab_xfrm_state_insert
+c03b0db8 r __ksymtab_xfrm_state_add
+c03b0dc0 r __ksymtab_xfrm_state_update
+c03b0dc8 r __ksymtab_xfrm_state_check_expire
+c03b0dd0 r __ksymtab_xfrm_state_check
+c03b0dd8 r __ksymtab_xfrm_state_lookup
+c03b0de0 r __ksymtab_xfrm_state_lookup_byaddr
+c03b0de8 r __ksymtab_xfrm_find_acq
+c03b0df0 r __ksymtab_xfrm_find_acq_byseq
+c03b0df8 r __ksymtab_xfrm_get_acqseq
+c03b0e00 r __ksymtab_xfrm_alloc_spi
+c03b0e08 r __ksymtab_xfrm_state_walk
+c03b0e10 r __ksymtab_xfrm_replay_notify
+c03b0e18 r __ksymtab_xfrm_replay_check
+c03b0e20 r __ksymtab_xfrm_replay_advance
+c03b0e28 r __ksymtab_km_policy_notify
+c03b0e30 r __ksymtab_km_state_notify
+c03b0e38 r __ksymtab_km_state_expired
+c03b0e40 r __ksymtab_km_query
+c03b0e48 r __ksymtab_km_new_mapping
+c03b0e50 r __ksymtab_km_policy_expired
+c03b0e58 r __ksymtab_km_migrate
+c03b0e60 r __ksymtab_km_report
+c03b0e68 r __ksymtab_xfrm_user_policy
+c03b0e70 r __ksymtab_xfrm_register_km
+c03b0e78 r __ksymtab_xfrm_unregister_km
+c03b0e80 r __ksymtab_xfrm_state_register_afinfo
+c03b0e88 r __ksymtab_xfrm_state_unregister_afinfo
+c03b0e90 r __ksymtab_xfrm_state_get_afinfo
+c03b0e98 r __ksymtab_xfrm_state_put_afinfo
+c03b0ea0 r __ksymtab_xfrm_state_delete_tunnel
+c03b0ea8 r __ksymtab_xfrm_init_state
+c03b0eb0 r __ksymtab___secpath_destroy
+c03b0eb8 r __ksymtab_secpath_dup
+c03b0ec0 r __ksymtab_xfrm_parse_spi
+c03b0ec8 r __ksymtab_inet6_bind
+c03b0ed0 r __ksymtab_inet6_release
+c03b0ed8 r __ksymtab_inet6_getname
+c03b0ee0 r __ksymtab_inet6_ioctl
+c03b0ee8 r __ksymtab_inet6_register_protosw
+c03b0ef0 r __ksymtab_inet6_unregister_protosw
+c03b0ef8 r __ksymtab_ip6_xmit
+c03b0f00 r __ksymtab_in6_dev_finish_destroy
+c03b0f08 r __ksymtab_ipv6_get_saddr
+c03b0f10 r __ksymtab_ipv6_chk_addr
+c03b0f18 r __ksymtab_register_inet6addr_notifier
+c03b0f20 r __ksymtab_unregister_inet6addr_notifier
+c03b0f28 r __ksymtab_rt6_lookup
+c03b0f30 r __ksymtab_ip6_route_output
+c03b0f38 r __ksymtab_ipv6_setsockopt
+c03b0f40 r __ksymtab_ipv6_getsockopt
+c03b0f48 r __ksymtab_ndisc_mc_map
+c03b0f50 r __ksymtab_inet6_add_protocol
+c03b0f58 r __ksymtab_inet6_del_protocol
+c03b0f60 r __ksymtab_icmpv6_statistics
+c03b0f68 r __ksymtab_icmpv6_send
+c03b0f70 r __ksymtab_icmpv6_err_convert
+c03b0f78 r __ksymtab_ipv6_push_nfrag_opts
+c03b0f80 r __ksymtab_xfrm6_rcv_spi
+c03b0f88 r __ksymtab_xfrm6_rcv
+c03b0f90 r __ksymtab_xfrm6_input_addr
+c03b0f98 r __ksymtab_xfrm6_find_1stfragopt
+c03b0fa0 r __ksymtab_ip6_route_me_harder
+c03b0fa8 r __ksymtab_nf_ip6_checksum
+c03b0fb0 r __ksymtab___ipv6_addr_type
+c03b0fb8 r __ksymtab_ipv6_ext_hdr
+c03b0fc0 r __ksymtab_ipv6_skip_exthdr
+c03b0fc8 r __ksymtab___inet6_hash
+c03b0fd0 r __ksymtab___inet6_lookup_established
+c03b0fd8 r __ksymtab_wireless_send_event
+c03b0fe0 r __ksymtab_iw_handler_set_spy
+c03b0fe8 r __ksymtab_iw_handler_get_spy
+c03b0ff0 r __ksymtab_iw_handler_set_thrspy
+c03b0ff8 r __ksymtab_iw_handler_get_thrspy
+c03b1000 r __ksymtab_wireless_spy_update
+c03b1008 r __ksymtab_sha_transform
+c03b1010 r __ksymtab_init_uts_ns
+c03b1010 R __start___ksymtab_gpl
+c03b1010 R __stop___ksymtab
+c03b1018 r __ksymtab_cpu_idle_wait
+c03b1020 r __ksymtab_edid_info
+c03b1028 r __ksymtab_kernel_fpu_begin
+c03b1030 r __ksymtab_e820_any_mapped
+c03b1038 r __ksymtab_mark_tsc_unstable
+c03b1040 r __ksymtab_per_cpu__gdt_page
+c03b1048 r __ksymtab_nr_mce_banks
+c03b1050 r __ksymtab_local_apic_timer_c2_ok
+c03b1058 r __ksymtab_vdso_enabled
+c03b1060 r __ksymtab_register_page_fault_notifier
+c03b1068 r __ksymtab_unregister_page_fault_notifier
+c03b1070 r __ksymtab___wake_up_sync
+c03b1078 r __ksymtab_task_nice
+c03b1080 r __ksymtab_sched_setscheduler
+c03b1088 r __ksymtab_set_cpus_allowed
+c03b1090 r __ksymtab_mmput
+c03b1098 r __ksymtab_get_task_mm
+c03b10a0 r __ksymtab_copy_fs_struct
+c03b10a8 r __ksymtab_prof_on
+c03b10b0 r __ksymtab_register_timer_hook
+c03b10b8 r __ksymtab_unregister_timer_hook
+c03b10c0 r __ksymtab_task_handoff_register
+c03b10c8 r __ksymtab_task_handoff_unregister
+c03b10d0 r __ksymtab_profile_event_register
+c03b10d8 r __ksymtab_profile_event_unregister
+c03b10e0 r __ksymtab_profile_hits
+c03b10e8 r __ksymtab_exit_fs
+c03b10f0 r __ksymtab_do_exit
+c03b10f8 r __ksymtab___local_bh_enable
+c03b1100 r __ksymtab_register_net_sysctl_table
+c03b1108 r __ksymtab_unregister_net_sysctl_table
+c03b1110 r __ksymtab___round_jiffies
+c03b1118 r __ksymtab___round_jiffies_relative
+c03b1120 r __ksymtab_round_jiffies
+c03b1128 r __ksymtab_round_jiffies_relative
+c03b1130 r __ksymtab_init_user_ns
+c03b1138 r __ksymtab_kill_pid_info_as_uid
+c03b1140 r __ksymtab_dequeue_signal
+c03b1148 r __ksymtab_atomic_notifier_chain_register
+c03b1150 r __ksymtab_atomic_notifier_chain_unregister
+c03b1158 r __ksymtab___atomic_notifier_call_chain
+c03b1160 r __ksymtab_atomic_notifier_call_chain
+c03b1168 r __ksymtab_blocking_notifier_chain_register
+c03b1170 r __ksymtab_blocking_notifier_chain_unregister
+c03b1178 r __ksymtab___blocking_notifier_call_chain
+c03b1180 r __ksymtab_blocking_notifier_call_chain
+c03b1188 r __ksymtab_raw_notifier_chain_register
+c03b1190 r __ksymtab_raw_notifier_chain_unregister
+c03b1198 r __ksymtab___raw_notifier_call_chain
+c03b11a0 r __ksymtab_raw_notifier_call_chain
+c03b11a8 r __ksymtab_srcu_notifier_chain_register
+c03b11b0 r __ksymtab_srcu_notifier_chain_unregister
+c03b11b8 r __ksymtab___srcu_notifier_call_chain
+c03b11c0 r __ksymtab_srcu_notifier_call_chain
+c03b11c8 r __ksymtab_srcu_init_notifier_head
+c03b11d0 r __ksymtab_emergency_restart
+c03b11d8 r __ksymtab_kernel_restart
+c03b11e0 r __ksymtab_kernel_halt
+c03b11e8 r __ksymtab_kernel_power_off
+c03b11f0 r __ksymtab_orderly_poweroff
+c03b11f8 r __ksymtab_queue_work
+c03b1200 r __ksymtab_queue_delayed_work
+c03b1208 r __ksymtab_queue_delayed_work_on
+c03b1210 r __ksymtab_flush_workqueue
+c03b1218 r __ksymtab_cancel_work_sync
+c03b1220 r __ksymtab_execute_in_process_context
+c03b1228 r __ksymtab___create_workqueue
+c03b1230 r __ksymtab_destroy_workqueue
+c03b1238 r __ksymtab_put_pid
+c03b1240 r __ksymtab_find_pid
+c03b1248 r __ksymtab_find_get_pid
+c03b1250 r __ksymtab_rcu_barrier
+c03b1258 r __ksymtab_rcu_batches_completed
+c03b1260 r __ksymtab_rcu_batches_completed_bh
+c03b1268 r __ksymtab_call_rcu
+c03b1270 r __ksymtab_call_rcu_bh
+c03b1278 r __ksymtab_synchronize_rcu
+c03b1280 r __ksymtab_posix_timer_event
+c03b1288 r __ksymtab_register_posix_clock
+c03b1290 r __ksymtab_do_posix_clock_nosettime
+c03b1298 r __ksymtab_do_posix_clock_nonanosleep
+c03b12a0 r __ksymtab_ktime_get
+c03b12a8 r __ksymtab_ktime_get_real
+c03b12b0 r __ksymtab_ktime_get_ts
+c03b12b8 r __ksymtab_hrtimer_forward
+c03b12c0 r __ksymtab_hrtimer_start
+c03b12c8 r __ksymtab_hrtimer_try_to_cancel
+c03b12d0 r __ksymtab_hrtimer_cancel
+c03b12d8 r __ksymtab_hrtimer_get_remaining
+c03b12e0 r __ksymtab_hrtimer_init
+c03b12e8 r __ksymtab_hrtimer_get_res
+c03b12f0 r __ksymtab_set_acceptable_latency
+c03b12f8 r __ksymtab_modify_acceptable_latency
+c03b1300 r __ksymtab_remove_acceptable_latency
+c03b1308 r __ksymtab_system_latency_constraint
+c03b1310 r __ksymtab_synchronize_acceptable_latency
+c03b1318 r __ksymtab_register_latency_notifier
+c03b1320 r __ksymtab_unregister_latency_notifier
+c03b1328 r __ksymtab_init_srcu_struct
+c03b1330 r __ksymtab_cleanup_srcu_struct
+c03b1338 r __ksymtab_srcu_read_lock
+c03b1340 r __ksymtab_srcu_read_unlock
+c03b1348 r __ksymtab_synchronize_srcu
+c03b1350 r __ksymtab_srcu_batches_completed
+c03b1358 r __ksymtab_srcu_readers_active
+c03b1360 r __ksymtab_register_die_notifier
+c03b1368 r __ksymtab_unregister_die_notifier
+c03b1370 r __ksymtab_free_vx_info
+c03b1378 r __ksymtab_free_nx_info
+c03b1380 r __ksymtab_unhash_nx_info
+c03b1388 r __ksymtab_vlimit_name
+c03b1390 r __ksymtab_locate_dl_info
+c03b1398 r __ksymtab_rcu_free_dl_info
+c03b13a0 r __ksymtab_ip_v4_find_src
+c03b13a8 r __ksymtab_clockevents_notify
+c03b13b0 r __ksymtab_get_futex_key
+c03b13b8 r __ksymtab_get_futex_key_refs
+c03b13c0 r __ksymtab_drop_futex_key_refs
+c03b13c8 r __ksymtab_rt_mutex_lock
+c03b13d0 r __ksymtab_rt_mutex_lock_interruptible
+c03b13d8 r __ksymtab_rt_mutex_timed_lock
+c03b13e0 r __ksymtab_rt_mutex_trylock
+c03b13e8 r __ksymtab_rt_mutex_unlock
+c03b13f0 r __ksymtab_rt_mutex_destroy
+c03b13f8 r __ksymtab___rt_mutex_init
+c03b1400 r __ksymtab_symbol_put_addr
+c03b1408 r __ksymtab___symbol_get
+c03b1410 r __ksymtab_sprint_symbol
+c03b1418 r __ksymtab_stop_machine_run
+c03b1420 r __ksymtab_register_kprobe
+c03b1428 r __ksymtab_unregister_kprobe
+c03b1430 r __ksymtab_register_jprobe
+c03b1438 r __ksymtab_unregister_jprobe
+c03b1440 r __ksymtab_jprobe_return
+c03b1448 r __ksymtab_register_kretprobe
+c03b1450 r __ksymtab_unregister_kretprobe
+c03b1458 r __ksymtab_kernel_subsys
+c03b1460 r __ksymtab_relay_buf_empty
+c03b1468 r __ksymtab_relay_buf_full
+c03b1470 r __ksymtab_relay_reset
+c03b1478 r __ksymtab_relay_open
+c03b1480 r __ksymtab_relay_switch_subbuf
+c03b1488 r __ksymtab_relay_subbufs_consumed
+c03b1490 r __ksymtab_relay_close
+c03b1498 r __ksymtab_relay_flush
+c03b14a0 r __ksymtab_relay_file_operations
+c03b14a8 r __ksymtab_default_backing_dev_info
+c03b14b0 r __ksymtab_file_ra_state_init
+c03b14b8 r __ksymtab_page_cache_readahead
+c03b14c0 r __ksymtab_invalidate_inode_pages2_range
+c03b14c8 r __ksymtab_invalidate_inode_pages2
+c03b14d0 r __ksymtab_all_vm_events
+c03b14d8 r __ksymtab_apply_to_page_range
+c03b14e0 r __ksymtab___handle_mm_fault
+c03b14e8 r __ksymtab_page_mkclean
+c03b14f0 r __ksymtab_kmem_cache_name
+c03b14f8 r __ksymtab_xip_file_read
+c03b1500 r __ksymtab_xip_file_sendfile
+c03b1508 r __ksymtab_xip_file_mmap
+c03b1510 r __ksymtab_xip_file_write
+c03b1518 r __ksymtab_xip_truncate_page
+c03b1520 r __ksymtab_percpu_depopulate
+c03b1528 r __ksymtab___percpu_depopulate_mask
+c03b1530 r __ksymtab_percpu_populate
+c03b1538 r __ksymtab___percpu_populate_mask
+c03b1540 r __ksymtab___percpu_alloc_mask
+c03b1548 r __ksymtab_percpu_free
+c03b1550 r __ksymtab_lookup_instantiate_filp
+c03b1558 r __ksymtab_sys_open
+c03b1560 r __ksymtab_sys_read
+c03b1568 r __ksymtab_get_max_files
+c03b1570 r __ksymtab_vfs_kern_mount
+c03b1578 r __ksymtab_lookup_create
+c03b1580 r __ksymtab_vfs_test_lock
+c03b1588 r __ksymtab_vfs_lock_file
+c03b1590 r __ksymtab_vfs_cancel_lock
+c03b1598 r __ksymtab_sysctl_vfs_cache_pressure
+c03b15a0 r __ksymtab_d_materialise_unique
+c03b15a8 r __ksymtab___iget
+c03b15b0 r __ksymtab_generic_drop_inode
+c03b15b8 r __ksymtab_fs_subsys
+c03b15c0 r __ksymtab_do_add_mount
+c03b15c8 r __ksymtab_mark_mounts_for_expiry
+c03b15d0 r __ksymtab_shrink_submounts
+c03b15d8 r __ksymtab_vfs_setxattr
+c03b15e0 r __ksymtab_vfs_getxattr
+c03b15e8 r __ksymtab_vfs_listxattr
+c03b15f0 r __ksymtab_vfs_removexattr
+c03b15f8 r __ksymtab_simple_attr_open
+c03b1600 r __ksymtab_simple_attr_close
+c03b1608 r __ksymtab_simple_attr_read
+c03b1610 r __ksymtab_simple_attr_write
+c03b1618 r __ksymtab_do_sync_mapping_range
+c03b1620 r __ksymtab_fsstack_copy_inode_size
+c03b1628 r __ksymtab_fsstack_copy_attr_all
+c03b1630 r __ksymtab_alloc_page_buffers
+c03b1638 r __ksymtab_bd_claim_by_disk
+c03b1640 r __ksymtab_bd_release_from_disk
+c03b1648 r __ksymtab_get_inotify_watch
+c03b1650 r __ksymtab_put_inotify_watch
+c03b1658 r __ksymtab_inotify_remove_watch_locked
+c03b1660 r __ksymtab_inotify_inode_queue_event
+c03b1668 r __ksymtab_inotify_dentry_parent_queue_event
+c03b1670 r __ksymtab_inotify_get_cookie
+c03b1678 r __ksymtab_inotify_unmount_inodes
+c03b1680 r __ksymtab_inotify_inode_is_dead
+c03b1688 r __ksymtab_inotify_init
+c03b1690 r __ksymtab_inotify_init_watch
+c03b1698 r __ksymtab_inotify_destroy
+c03b16a0 r __ksymtab_inotify_find_watch
+c03b16a8 r __ksymtab_inotify_find_update_watch
+c03b16b0 r __ksymtab_inotify_add_watch
+c03b16b8 r __ksymtab_inotify_rm_wd
+c03b16c0 r __ksymtab_inotify_rm_watch
+c03b16c8 r __ksymtab_dnotify_parent
+c03b16d0 r __ksymtab_sysfs_notify
+c03b16d8 r __ksymtab_sysfs_add_file_to_group
+c03b16e0 r __ksymtab_sysfs_chmod_file
+c03b16e8 r __ksymtab_sysfs_remove_file_from_group
+c03b16f0 r __ksymtab_sysfs_schedule_callback
+c03b16f8 r __ksymtab_sysfs_create_file
+c03b1700 r __ksymtab_sysfs_remove_file
+c03b1708 r __ksymtab_sysfs_update_file
+c03b1710 r __ksymtab_sysfs_create_link
+c03b1718 r __ksymtab_sysfs_remove_link
+c03b1720 r __ksymtab_sysfs_create_bin_file
+c03b1728 r __ksymtab_sysfs_remove_bin_file
+c03b1730 r __ksymtab_sysfs_create_group
+c03b1738 r __ksymtab_sysfs_remove_group
+c03b1740 r __ksymtab_dcookie_register
+c03b1748 r __ksymtab_dcookie_unregister
+c03b1750 r __ksymtab_get_dcookie
+c03b1758 r __ksymtab_debugfs_create_file
+c03b1760 r __ksymtab_debugfs_create_dir
+c03b1768 r __ksymtab_debugfs_create_symlink
+c03b1770 r __ksymtab_debugfs_remove
+c03b1778 r __ksymtab_debugfs_create_u8
+c03b1780 r __ksymtab_debugfs_create_u16
+c03b1788 r __ksymtab_debugfs_create_u32
+c03b1790 r __ksymtab_debugfs_create_u64
+c03b1798 r __ksymtab_debugfs_create_bool
+c03b17a0 r __ksymtab_debugfs_create_blob
+c03b17a8 r __ksymtab_crypto_alg_list
+c03b17b0 r __ksymtab_crypto_alg_sem
+c03b17b8 r __ksymtab_crypto_chain
+c03b17c0 r __ksymtab_crypto_mod_get
+c03b17c8 r __ksymtab_crypto_mod_put
+c03b17d0 r __ksymtab___crypto_alg_lookup
+c03b17d8 r __ksymtab_crypto_alg_mod_lookup
+c03b17e0 r __ksymtab_crypto_shoot_alg
+c03b17e8 r __ksymtab___crypto_alloc_tfm
+c03b17f0 r __ksymtab_crypto_alloc_base
+c03b17f8 r __ksymtab_crypto_free_tfm
+c03b1800 r __ksymtab_crypto_has_alg
+c03b1808 r __ksymtab_crypto_km_types
+c03b1810 r __ksymtab_scatterwalk_start
+c03b1818 r __ksymtab_scatterwalk_map
+c03b1820 r __ksymtab_scatterwalk_done
+c03b1828 r __ksymtab_scatterwalk_copychunks
+c03b1830 r __ksymtab_elv_register
+c03b1838 r __ksymtab_elv_unregister
+c03b1840 r __ksymtab_blk_execute_rq_nowait
+c03b1848 r __ksymtab_disk_round_stats
+c03b1850 r __ksymtab___blk_put_request
+c03b1858 r __ksymtab_blkdev_driver_ioctl
+c03b1860 r __ksymtab_blkdev_ioctl
+c03b1868 r __ksymtab_genhd_media_change_notify
+c03b1870 r __ksymtab_sg_scsi_ioctl
+c03b1878 r __ksymtab___blk_add_trace
+c03b1880 r __ksymtab_kobject_get_path
+c03b1888 r __ksymtab_kobject_uevent_env
+c03b1890 r __ksymtab_kobject_uevent
+c03b1898 r __ksymtab_add_uevent_var
+c03b18a0 r __ksymtab___iowrite32_copy
+c03b18a8 r __ksymtab___iowrite64_copy
+c03b18b0 r __ksymtab_byte_rev_table
+c03b18b8 r __ksymtab_pci_block_user_cfg_access
+c03b18c0 r __ksymtab_pci_unblock_user_cfg_access
+c03b18c8 r __ksymtab_pci_walk_bus
+c03b18d0 r __ksymtab_pci_bus_add_device
+c03b18d8 r __ksymtab_pci_create_bus
+c03b18e0 r __ksymtab_pci_scan_child_bus
+c03b18e8 r __ksymtab_pci_stop_bus_device
+c03b18f0 r __ksymtab_pci_bus_max_busnr
+c03b18f8 r __ksymtab_pci_find_next_capability
+c03b1900 r __ksymtab_pci_find_ext_capability
+c03b1908 r __ksymtab_pci_find_next_ht_capability
+c03b1910 r __ksymtab_pci_find_ht_capability
+c03b1918 r __ksymtab_pci_restore_bars
+c03b1920 r __ksymtab_pci_intx
+c03b1928 r __ksymtab_pci_set_pcie_reset_state
+c03b1930 r __ksymtab_pci_claim_resource
+c03b1938 r __ksymtab_pcie_port_bus_type
+c03b1940 r __ksymtab_pci_find_aer_capability
+c03b1948 r __ksymtab_pci_enable_pcie_error_reporting
+c03b1950 r __ksymtab_pci_disable_pcie_error_reporting
+c03b1958 r __ksymtab_pci_cleanup_aer_uncorrect_error_status
+c03b1960 r __ksymtab_fb_notifier_call_chain
+c03b1968 r __ksymtab_acpi_os_map_memory
+c03b1970 r __ksymtab_acpi_os_unmap_memory
+c03b1978 r __ksymtab_acpi_bus_get_ejd
+c03b1980 r __ksymtab_acpi_bus_trim
+c03b1988 r __ksymtab_acpi_ec_add_query_handler
+c03b1990 r __ksymtab_acpi_ec_remove_query_handler
+c03b1998 r __ksymtab_acpi_get_pci_rootbridge_handle
+c03b19a0 r __ksymtab_add_input_randomness
+c03b19a8 r __ksymtab_tty_buffer_request_room
+c03b19b0 r __ksymtab_tty_prepare_flip_string
+c03b19b8 r __ksymtab_tty_prepare_flip_string_flags
+c03b19c0 r __ksymtab_tty_ldisc_get
+c03b19c8 r __ksymtab_tty_ldisc_put
+c03b19d0 r __ksymtab_tty_ldisc_ref_wait
+c03b19d8 r __ksymtab_tty_ldisc_ref
+c03b19e0 r __ksymtab_tty_ldisc_deref
+c03b19e8 r __ksymtab_tty_wakeup
+c03b19f0 r __ksymtab_tty_ldisc_flush
+c03b19f8 r __ksymtab_get_current_tty
+c03b1a00 r __ksymtab_tty_termios_encode_baud_rate
+c03b1a08 r __ksymtab_hwrng_register
+c03b1a10 r __ksymtab_hwrng_unregister
+c03b1a18 r __ksymtab_uart_console_write
+c03b1a20 r __ksymtab_pciserial_init_ports
+c03b1a28 r __ksymtab_pciserial_remove_ports
+c03b1a30 r __ksymtab_pciserial_suspend_ports
+c03b1a38 r __ksymtab_pciserial_resume_ports
+c03b1a40 r __ksymtab_device_create_bin_file
+c03b1a48 r __ksymtab_device_remove_bin_file
+c03b1a50 r __ksymtab_device_schedule_callback_owner
+c03b1a58 r __ksymtab_device_for_each_child
+c03b1a60 r __ksymtab_device_find_child
+c03b1a68 r __ksymtab_device_initialize
+c03b1a70 r __ksymtab_device_add
+c03b1a78 r __ksymtab_device_register
+c03b1a80 r __ksymtab_device_del
+c03b1a88 r __ksymtab_device_unregister
+c03b1a90 r __ksymtab_get_device
+c03b1a98 r __ksymtab_put_device
+c03b1aa0 r __ksymtab_device_create_file
+c03b1aa8 r __ksymtab_device_remove_file
+c03b1ab0 r __ksymtab_device_create
+c03b1ab8 r __ksymtab_device_destroy
+c03b1ac0 r __ksymtab_device_rename
+c03b1ac8 r __ksymtab_device_move
+c03b1ad0 r __ksymtab_sysdev_create_file
+c03b1ad8 r __ksymtab_sysdev_remove_file
+c03b1ae0 r __ksymtab_sysdev_class_create_file
+c03b1ae8 r __ksymtab_sysdev_class_remove_file
+c03b1af0 r __ksymtab_sysdev_class_register
+c03b1af8 r __ksymtab_sysdev_class_unregister
+c03b1b00 r __ksymtab_sysdev_driver_register
+c03b1b08 r __ksymtab_sysdev_driver_unregister
+c03b1b10 r __ksymtab_sysdev_register
+c03b1b18 r __ksymtab_sysdev_unregister
+c03b1b20 r __ksymtab_device_reprobe
+c03b1b28 r __ksymtab_bus_register_notifier
+c03b1b30 r __ksymtab_bus_unregister_notifier
+c03b1b38 r __ksymtab_bus_for_each_dev
+c03b1b40 r __ksymtab_bus_find_device
+c03b1b48 r __ksymtab_bus_for_each_drv
+c03b1b50 r __ksymtab_bus_register
+c03b1b58 r __ksymtab_bus_unregister
+c03b1b60 r __ksymtab_bus_rescan_devices
+c03b1b68 r __ksymtab_bus_create_file
+c03b1b70 r __ksymtab_bus_remove_file
+c03b1b78 r __ksymtab_device_bind_driver
+c03b1b80 r __ksymtab_device_release_driver
+c03b1b88 r __ksymtab_device_attach
+c03b1b90 r __ksymtab_driver_attach
+c03b1b98 r __ksymtab_driver_for_each_device
+c03b1ba0 r __ksymtab_driver_find_device
+c03b1ba8 r __ksymtab_driver_register
+c03b1bb0 r __ksymtab_driver_unregister
+c03b1bb8 r __ksymtab_get_driver
+c03b1bc0 r __ksymtab_put_driver
+c03b1bc8 r __ksymtab_driver_find
+c03b1bd0 r __ksymtab_driver_create_file
+c03b1bd8 r __ksymtab_driver_remove_file
+c03b1be0 r __ksymtab_class_create_file
+c03b1be8 r __ksymtab_class_remove_file
+c03b1bf0 r __ksymtab_class_register
+c03b1bf8 r __ksymtab_class_unregister
+c03b1c00 r __ksymtab_class_create
+c03b1c08 r __ksymtab_class_destroy
+c03b1c10 r __ksymtab_class_device_register
+c03b1c18 r __ksymtab_class_device_unregister
+c03b1c20 r __ksymtab_class_device_initialize
+c03b1c28 r __ksymtab_class_device_add
+c03b1c30 r __ksymtab_class_device_del
+c03b1c38 r __ksymtab_class_device_get
+c03b1c40 r __ksymtab_class_device_put
+c03b1c48 r __ksymtab_class_device_create
+c03b1c50 r __ksymtab_class_device_destroy
+c03b1c58 r __ksymtab_class_device_create_file
+c03b1c60 r __ksymtab_class_device_remove_file
+c03b1c68 r __ksymtab_class_device_create_bin_file
+c03b1c70 r __ksymtab_class_device_remove_bin_file
+c03b1c78 r __ksymtab_class_interface_register
+c03b1c80 r __ksymtab_class_interface_unregister
+c03b1c88 r __ksymtab_platform_bus
+c03b1c90 r __ksymtab_platform_get_resource
+c03b1c98 r __ksymtab_platform_get_irq
+c03b1ca0 r __ksymtab_platform_get_resource_byname
+c03b1ca8 r __ksymtab_platform_get_irq_byname
+c03b1cb0 r __ksymtab_platform_add_devices
+c03b1cb8 r __ksymtab_platform_device_put
+c03b1cc0 r __ksymtab_platform_device_alloc
+c03b1cc8 r __ksymtab_platform_device_add_resources
+c03b1cd0 r __ksymtab_platform_device_add_data
+c03b1cd8 r __ksymtab_platform_device_add
+c03b1ce0 r __ksymtab_platform_device_del
+c03b1ce8 r __ksymtab_platform_device_register
+c03b1cf0 r __ksymtab_platform_device_unregister
+c03b1cf8 r __ksymtab_platform_device_register_simple
+c03b1d00 r __ksymtab_platform_driver_register
+c03b1d08 r __ksymtab_platform_driver_unregister
+c03b1d10 r __ksymtab_platform_driver_probe
+c03b1d18 r __ksymtab_platform_bus_type
+c03b1d20 r __ksymtab_dma_get_required_mask
+c03b1d28 r __ksymtab_get_cpu_sysdev
+c03b1d30 r __ksymtab_firmware_register
+c03b1d38 r __ksymtab_firmware_unregister
+c03b1d40 r __ksymtab_devres_alloc
+c03b1d48 r __ksymtab_devres_free
+c03b1d50 r __ksymtab_devres_add
+c03b1d58 r __ksymtab_devres_find
+c03b1d60 r __ksymtab_devres_get
+c03b1d68 r __ksymtab_devres_remove
+c03b1d70 r __ksymtab_devres_destroy
+c03b1d78 r __ksymtab_devres_open_group
+c03b1d80 r __ksymtab_devres_close_group
+c03b1d88 r __ksymtab_devres_remove_group
+c03b1d90 r __ksymtab_devres_release_group
+c03b1d98 r __ksymtab_devm_kzalloc
+c03b1da0 r __ksymtab_devm_kfree
+c03b1da8 r __ksymtab_attribute_container_classdev_to_container
+c03b1db0 r __ksymtab_attribute_container_register
+c03b1db8 r __ksymtab_attribute_container_unregister
+c03b1dc0 r __ksymtab_attribute_container_find_class_device
+c03b1dc8 r __ksymtab_transport_class_register
+c03b1dd0 r __ksymtab_transport_class_unregister
+c03b1dd8 r __ksymtab_anon_transport_class_register
+c03b1de0 r __ksymtab_anon_transport_class_unregister
+c03b1de8 r __ksymtab_transport_setup_device
+c03b1df0 r __ksymtab_transport_add_device
+c03b1df8 r __ksymtab_transport_configure_device
+c03b1e00 r __ksymtab_transport_remove_device
+c03b1e08 r __ksymtab_transport_destroy_device
+c03b1e10 r __ksymtab_device_pm_set_parent
+c03b1e18 r __ksymtab_device_suspend
+c03b1e20 r __ksymtab_device_power_down
+c03b1e28 r __ksymtab___suspend_report_result
+c03b1e30 r __ksymtab_device_resume
+c03b1e38 r __ksymtab_device_power_up
+c03b1e40 r __ksymtab_ide_setting_sem
+c03b1e48 r __ksymtab_ide_bus_type
+c03b1e50 r __ksymtab_ide_end_dequeued_request
+c03b1e58 r __ksymtab___ide_error
+c03b1e60 r __ksymtab_ide_error
+c03b1e68 r __ksymtab___ide_abort
+c03b1e70 r __ksymtab_ide_map_sg
+c03b1e78 r __ksymtab_ide_init_sg_cmd
+c03b1e80 r __ksymtab_ide_wait_not_busy
+c03b1e88 r __ksymtab_ide_use_fast_pio
+c03b1e90 r __ksymtab_ide_pio_timings
+c03b1e98 r __ksymtab_ide_get_best_pio_mode
+c03b1ea0 r __ksymtab_ide_undecoded_slave
+c03b1ea8 r __ksymtab_ide_register_region
+c03b1eb0 r __ksymtab_ide_unregister_region
+c03b1eb8 r __ksymtab_ide_init_disk
+c03b1ec0 r __ksymtab_ideprobe_init
+c03b1ec8 r __ksymtab_ide_setup_pci_noise
+c03b1ed0 r __ksymtab_ide_pci_setup_ports
+c03b1ed8 r __ksymtab_ide_setup_pci_device
+c03b1ee0 r __ksymtab_ide_setup_pci_devices
+c03b1ee8 r __ksymtab___ide_pci_register_driver
+c03b1ef0 r __ksymtab_ide_dma_intr
+c03b1ef8 r __ksymtab_ide_build_sglist
+c03b1f00 r __ksymtab_ide_build_dmatable
+c03b1f08 r __ksymtab_ide_destroy_dmatable
+c03b1f10 r __ksymtab_ide_dma_setup
+c03b1f18 r __ksymtab_ide_dma_start
+c03b1f20 r __ksymtab_ide_max_dma_mode
+c03b1f28 r __ksymtab_ide_tune_dma
+c03b1f30 r __ksymtab_ide_set_dma
+c03b1f38 r __ksymtab_ide_setup_dma
+c03b1f40 r __ksymtab_usb_get_intf
+c03b1f48 r __ksymtab_usb_put_intf
+c03b1f50 r __ksymtab_ehci_cf_port_reset_rwsem
+c03b1f58 r __ksymtab_usb_root_hub_lost_power
+c03b1f60 r __ksymtab_usb_bus_list
+c03b1f68 r __ksymtab_usb_bus_list_lock
+c03b1f70 r __ksymtab_usb_hcd_poll_rh_status
+c03b1f78 r __ksymtab_usb_hcd_resume_root_hub
+c03b1f80 r __ksymtab_usb_hc_died
+c03b1f88 r __ksymtab_usb_interrupt_msg
+c03b1f90 r __ksymtab_usb_driver_set_configuration
+c03b1f98 r __ksymtab_usb_store_new_id
+c03b1fa0 r __ksymtab_usb_match_one_id
+c03b1fa8 r __ksymtab_usb_register_device_driver
+c03b1fb0 r __ksymtab_usb_deregister_device_driver
+c03b1fb8 r __ksymtab_usb_register_notify
+c03b1fc0 r __ksymtab_usb_unregister_notify
+c03b1fc8 r __ksymtab_uhci_reset_hc
+c03b1fd0 r __ksymtab_uhci_check_and_reset_hc
+c03b1fd8 r __ksymtab_storage_usb_ids
+c03b1fe0 r __ksymtab_usb_usual_set_present
+c03b1fe8 r __ksymtab_usb_usual_clear_present
+c03b1ff0 r __ksymtab_usb_usual_check_type
+c03b1ff8 r __ksymtab_input_class
+c03b2000 r __ksymtab_input_ff_upload
+c03b2008 r __ksymtab_input_ff_erase
+c03b2010 r __ksymtab_input_ff_event
+c03b2018 r __ksymtab_input_ff_create
+c03b2020 r __ksymtab_input_ff_destroy
+c03b2028 r __ksymtab___i2c_board_lock
+c03b2030 r __ksymtab___i2c_board_list
+c03b2038 r __ksymtab___i2c_first_dynamic_bus_num
+c03b2040 r __ksymtab_md_new_event
+c03b2048 r __ksymtab_sync_page_io
+c03b2050 r __ksymtab_md_allow_write
+c03b2058 r __ksymtab_md_do_sync
+c03b2060 r __ksymtab_dm_device_name
+c03b2068 r __ksymtab_dm_put
+c03b2070 r __ksymtab_dm_noflush_suspending
+c03b2078 r __ksymtab_dm_create_error_table
+c03b2080 r __ksymtab_dm_set_device_limits
+c03b2088 r __ksymtab_hid_free_device
+c03b2090 r __ksymtab_hid_parse_report
+c03b2098 r __ksymtab_hid_input_field
+c03b20a0 r __ksymtab_hid_output_report
+c03b20a8 r __ksymtab_hid_set_field
+c03b20b0 r __ksymtab_hid_input_report
+c03b20b8 r __ksymtab_hidinput_report_event
+c03b20c0 r __ksymtab_hidinput_find_field
+c03b20c8 r __ksymtab_hidinput_connect
+c03b20d0 r __ksymtab_hidinput_disconnect
+c03b20d8 r __ksymtab___sock_recv_timestamp
+c03b20e0 r __ksymtab_sk_clone
+c03b20e8 r __ksymtab_sk_setup_caps
+c03b20f0 r __ksymtab_skb_pull_rcsum
+c03b20f8 r __ksymtab_skb_segment
+c03b2100 r __ksymtab_skb_to_sgvec
+c03b2108 r __ksymtab_skb_cow_data
+c03b2110 r __ksymtab_init_net
+c03b2118 r __ksymtab___put_net
+c03b2120 r __ksymtab_register_pernet_subsys
+c03b2128 r __ksymtab_unregister_pernet_subsys
+c03b2130 r __ksymtab_register_pernet_device
+c03b2138 r __ksymtab_unregister_pernet_device
+c03b2140 r __ksymtab_ethtool_op_get_perm_addr
+c03b2148 r __ksymtab_register_netevent_notifier
+c03b2150 r __ksymtab_unregister_netevent_notifier
+c03b2158 r __ksymtab_call_netevent_notifiers
+c03b2160 r __ksymtab___rtnl_register
+c03b2168 r __ksymtab_rtnl_register
+c03b2170 r __ksymtab_rtnl_unregister
+c03b2178 r __ksymtab_rtnl_unregister_all
+c03b2180 r __ksymtab___rtnl_link_register
+c03b2188 r __ksymtab_rtnl_link_register
+c03b2190 r __ksymtab___rtnl_link_unregister
+c03b2198 r __ksymtab_rtnl_link_unregister
+c03b21a0 r __ksymtab_rtnl_put_cacheinfo
+c03b21a8 r __ksymtab_fib_rules_register
+c03b21b0 r __ksymtab_fib_rules_unregister
+c03b21b8 r __ksymtab_fib_rules_lookup
+c03b21c0 r __ksymtab_netlink_has_listeners
+c03b21c8 r __ksymtab_nf_register_afinfo
+c03b21d0 r __ksymtab_nf_unregister_afinfo
+c03b21d8 r __ksymtab_nf_unregister_queue_handlers
+c03b21e0 r __ksymtab_nf_register_sysctl_table
+c03b21e8 r __ksymtab_nf_unregister_sysctl_table
+c03b21f0 r __ksymtab_nf_net_netfilter_sysctl_path
+c03b21f8 r __ksymtab_nf_net_ipv4_netfilter_sysctl_path
+c03b2200 r __ksymtab___ip_route_output_key
+c03b2208 r __ksymtab_ip_route_output_flow
+c03b2210 r __ksymtab_ip_build_and_send_pkt
+c03b2218 r __ksymtab___inet_lookup_listener
+c03b2220 r __ksymtab_inet_hash_connect
+c03b2228 r __ksymtab___inet_twsk_kill
+c03b2230 r __ksymtab___inet_twsk_hashdance
+c03b2238 r __ksymtab_inet_twsk_alloc
+c03b2240 r __ksymtab_inet_twdr_hangman
+c03b2248 r __ksymtab_inet_twdr_twkill_work
+c03b2250 r __ksymtab_inet_twsk_schedule
+c03b2258 r __ksymtab_inet_twdr_twcal_tick
+c03b2260 r __ksymtab_inet_csk_bind_conflict
+c03b2268 r __ksymtab_inet_csk_get_port
+c03b2270 r __ksymtab_inet_csk_route_req
+c03b2278 r __ksymtab_inet_csk_search_req
+c03b2280 r __ksymtab_inet_csk_reqsk_queue_hash_add
+c03b2288 r __ksymtab_inet_csk_reqsk_queue_prune
+c03b2290 r __ksymtab_inet_csk_clone
+c03b2298 r __ksymtab_inet_csk_listen_start
+c03b22a0 r __ksymtab_inet_csk_listen_stop
+c03b22a8 r __ksymtab_inet_csk_addr2sockaddr
+c03b22b0 r __ksymtab_inet_csk_ctl_sock_create
+c03b22b8 r __ksymtab_tcp_orphan_count
+c03b22c0 r __ksymtab_tcp_get_info
+c03b22c8 r __ksymtab_tcp_done
+c03b22d0 r __ksymtab_tcp_twsk_unique
+c03b22d8 r __ksymtab_tcp_death_row
+c03b22e0 r __ksymtab_tcp_twsk_destructor
+c03b22e8 r __ksymtab_tcp_register_congestion_control
+c03b22f0 r __ksymtab_tcp_unregister_congestion_control
+c03b22f8 r __ksymtab_tcp_slow_start
+c03b2300 r __ksymtab_tcp_reno_cong_avoid
+c03b2308 r __ksymtab_tcp_reno_ssthresh
+c03b2310 r __ksymtab_tcp_reno_min_cwnd
+c03b2318 r __ksymtab_tcp_init_congestion_ops
+c03b2320 r __ksymtab_snmp_fold_field
+c03b2328 r __ksymtab_snmp_mib_init
+c03b2330 r __ksymtab_snmp_mib_free
+c03b2338 r __ksymtab_xfrm_aalg_get_byid
+c03b2340 r __ksymtab_xfrm_ealg_get_byid
+c03b2348 r __ksymtab_xfrm_calg_get_byid
+c03b2350 r __ksymtab_xfrm_aalg_get_byname
+c03b2358 r __ksymtab_xfrm_ealg_get_byname
+c03b2360 r __ksymtab_xfrm_calg_get_byname
+c03b2368 r __ksymtab_xfrm_aalg_get_byidx
+c03b2370 r __ksymtab_xfrm_ealg_get_byidx
+c03b2378 r __ksymtab_xfrm_probe_algs
+c03b2380 r __ksymtab_xfrm_count_auth_supported
+c03b2388 r __ksymtab_xfrm_count_enc_supported
+c03b2390 r __ksymtab_skb_icv_walk
+c03b2398 r __ksymtab_inet6_destroy_sock
+c03b23a0 r __ksymtab_inet6_sk_rebuild_header
+c03b23a8 r __ksymtab_ipv6_opt_accepted
+c03b23b0 r __ksymtab_ip6_find_1stfragopt
+c03b23b8 r __ksymtab_ip6_dst_lookup
+c03b23c0 r __ksymtab_ip6_sk_dst_lookup
+c03b23c8 r __ksymtab_ip6_dst_blackhole
+c03b23d0 r __ksymtab_ipv6_find_tlv
+c03b23d8 r __ksymtab_ipv6_invert_rthdr
+c03b23e0 r __ksymtab_ipv6_dup_options
+c03b23e8 r __ksymtab_fl6_sock_lookup
+c03b23f0 r __ksymtab_inet6_csk_bind_conflict
+c03b23f8 r __ksymtab_inet6_csk_search_req
+c03b2400 r __ksymtab_inet6_csk_reqsk_queue_hash_add
+c03b2408 r __ksymtab_inet6_csk_addr2sockaddr
+c03b2410 r __ksymtab_inet6_csk_xmit
+c03b2418 r __ksymtab_inet6_lookup_listener
+c03b2420 r __ksymtab_inet6_lookup
+c03b2428 r __ksymtab_inet6_hash_connect
+c03b2430 r __ksymtab_klist_init
+c03b2438 r __ksymtab_klist_add_head
+c03b2440 r __ksymtab_klist_add_tail
+c03b2448 r __ksymtab_klist_del
+c03b2450 r __ksymtab_klist_remove
+c03b2458 r __ksymtab_klist_node_attached
+c03b2460 r __ksymtab_klist_iter_init_node
+c03b2468 r __ksymtab_klist_iter_init
+c03b2470 r __ksymtab_klist_iter_exit
+c03b2478 r __ksymtab_klist_next
+c03b2480 r __ksymtab_usb_match_id
+c03b2480 R __start___ksymtab_gpl_future
+c03b2480 ? __start___ksymtab_unused
+c03b2480 ? __start___ksymtab_unused_gpl
+c03b2480 R __stop___ksymtab_gpl
+c03b2480 ? __stop___ksymtab_unused
+c03b2480 ? __stop___ksymtab_unused_gpl
+c03b2488 r __ksymtab_usb_register_driver
+c03b2490 r __ksymtab_usb_deregister
+c03b2498 ? __start___kcrctab
+c03b2498 ? __start___kcrctab_gpl
+c03b2498 ? __start___kcrctab_gpl_future
+c03b2498 ? __start___kcrctab_unused
+c03b2498 ? __start___kcrctab_unused_gpl
+c03b2498 ? __stop___kcrctab
+c03b2498 ? __stop___kcrctab_gpl
+c03b2498 ? __stop___kcrctab_gpl_future
+c03b2498 ? __stop___kcrctab_unused
+c03b2498 ? __stop___kcrctab_unused_gpl
+c03b2498 R __stop___ksymtab_gpl_future
+c03b24a0 r __kstrtab_init_mm
+c03b24a8 r __kstrtab_init_task
+c03b24b2 r __kstrtab_system_state
+c03b24bf r __kstrtab_reset_devices
+c03b24cd r __kstrtab_loops_per_jiffy
+c03b24dd r __kstrtab___per_cpu_offset
+c03b24ee r __kstrtab_init_uts_ns
+c03b2500 r __kstrtab_boot_option_idle_override
+c03b251a r __kstrtab_per_cpu__current_task
+c03b2530 r __kstrtab_per_cpu__cpu_number
+c03b2544 r __kstrtab_pm_idle
+c03b254c r __kstrtab_disable_hlt
+c03b2558 r __kstrtab_enable_hlt
+c03b2563 r __kstrtab_cpu_idle_wait
+c03b2571 r __kstrtab_kernel_thread
+c03b257f r __kstrtab_dump_thread
+c03b258b r __kstrtab_dump_trace
+c03b2596 r __kstrtab_dump_stack
+c03b25a1 r __kstrtab_per_cpu__irq_stat
+c03b25b3 r __kstrtab_per_cpu__irq_regs
+c03b25c5 r __kstrtab_do_softirq
+c03b25d0 r __kstrtab_cpu_khz
+c03b25d8 r __kstrtab_rtc_lock
+c03b25e1 r __kstrtab_cmos_lock
+c03b25eb r __kstrtab_rtc_cmos_read
+c03b25f9 r __kstrtab_rtc_cmos_write
+c03b2608 r __kstrtab_profile_pc
+c03b2613 r __kstrtab_boot_cpu_data
+c03b2621 r __kstrtab_drive_info
+c03b262c r __kstrtab_screen_info
+c03b2638 r __kstrtab_apm_info
+c03b2641 r __kstrtab_edid_info
+c03b264b r __kstrtab_edd
+c03b2660 r __kstrtab_dma_alloc_coherent
+c03b2673 r __kstrtab_dma_free_coherent
+c03b2685 r __kstrtab_dma_declare_coherent_memory
+c03b26a1 r __kstrtab_dma_release_declared_memory
+c03b26c0 r __kstrtab_dma_mark_declared_memory_occupied
+c03b26e2 r __kstrtab_forbid_dac
+c03b26ed r __kstrtab___down_failed
+c03b26fb r __kstrtab___down_failed_interruptible
+c03b2717 r __kstrtab___down_failed_trylock
+c03b272d r __kstrtab___up_wakeup
+c03b2739 r __kstrtab_csum_partial_copy_generic
+c03b2753 r __kstrtab___get_user_1
+c03b2760 r __kstrtab___get_user_2
+c03b276d r __kstrtab___get_user_4
+c03b277a r __kstrtab___put_user_1
+c03b2787 r __kstrtab___put_user_2
+c03b2794 r __kstrtab___put_user_4
+c03b27a1 r __kstrtab___put_user_8
+c03b27ae r __kstrtab_strstr
+c03b27b5 r __kstrtab___write_lock_failed
+c03b27c9 r __kstrtab___read_lock_failed
+c03b27dc r __kstrtab_csum_partial
+c03b27e9 r __kstrtab_kernel_fpu_begin
+c03b27fa r __kstrtab_dump_fpu
+c03b2803 r __kstrtab_efi_enabled
+c03b280f r __kstrtab_pci_mem_start
+c03b281d r __kstrtab_e820_any_mapped
+c03b282d r __kstrtab_i8253_lock
+c03b2838 r __kstrtab_recalibrate_cpu_khz
+c03b284c r __kstrtab_mark_tsc_unstable
+c03b285e r __kstrtab_per_cpu__gdt_page
+c03b2870 r __kstrtab_nr_mce_banks
+c03b287d r __kstrtab_mtrr_add
+c03b2886 r __kstrtab_mtrr_del
+c03b288f r __kstrtab_avail_to_resrv_perfctr_nmi
+c03b28aa r __kstrtab_avail_to_resrv_perfctr_nmi_bit
+c03b28c9 r __kstrtab_reserve_perfctr_nmi
+c03b28dd r __kstrtab_release_perfctr_nmi
+c03b28f1 r __kstrtab_reserve_evntsel_nmi
+c03b2905 r __kstrtab_release_evntsel_nmi
+c03b2919 r __kstrtab_acpi_disabled
+c03b2927 r __kstrtab_acpi_strict
+c03b2933 r __kstrtab_acpi_register_gsi
+c03b2945 r __kstrtab_acpi_register_ioapic
+c03b295a r __kstrtab_acpi_unregister_ioapic
+c03b2971 r __kstrtab_pm_power_off
+c03b297e r __kstrtab_flush_tlb_page
+c03b298d r __kstrtab_smp_num_siblings
+c03b299e r __kstrtab_cpu_sibling_map
+c03b29ae r __kstrtab_cpu_core_map
+c03b29bb r __kstrtab_cpu_online_map
+c03b29ca r __kstrtab_cpu_callout_map
+c03b29da r __kstrtab_cpu_possible_map
+c03b29eb r __kstrtab_cpu_data
+c03b29f4 r __kstrtab_x86_cpu_to_apicid
+c03b2a06 r __kstrtab_per_cpu__this_cpu_off
+c03b2a1c r __kstrtab_smp_call_function
+c03b2a2e r __kstrtab_smp_call_function_single
+c03b2a47 r __kstrtab_local_apic_timer_c2_ok
+c03b2a5e r __kstrtab_touch_nmi_watchdog
+c03b2a71 r __kstrtab_nmi_active
+c03b2a7c r __kstrtab_nmi_watchdog
+c03b2a89 r __kstrtab_IO_APIC_get_PCI_irq_vector
+c03b2aa4 r __kstrtab_vdso_enabled
+c03b2ab1 r __kstrtab_efi
+c03b2ab5 r __kstrtab___PAGE_KERNEL
+c03b2ac3 r __kstrtab___FIXADDR_TOP
+c03b2ad1 r __kstrtab_register_page_fault_notifier
+c03b2aee r __kstrtab_unregister_page_fault_notifier
+c03b2b0d r __kstrtab___ioremap
+c03b2b17 r __kstrtab_ioremap_nocache
+c03b2b27 r __kstrtab_iounmap
+c03b2b2f r __kstrtab_change_page_attr
+c03b2b40 r __kstrtab_global_flush_tlb
+c03b2b51 r __kstrtab_kmap
+c03b2b56 r __kstrtab_kunmap
+c03b2b5d r __kstrtab_kmap_atomic
+c03b2b69 r __kstrtab_kunmap_atomic
+c03b2b77 r __kstrtab_kmap_atomic_to_page
+c03b2ba0 r __kstrtab_wake_up_process
+c03b2bb0 r __kstrtab_per_cpu__kstat
+c03b2bbf r __kstrtab_schedule
+c03b2bc8 r __kstrtab_default_wake_function
+c03b2bde r __kstrtab___wake_up
+c03b2be8 r __kstrtab___wake_up_sync
+c03b2bf7 r __kstrtab_complete
+c03b2c00 r __kstrtab_complete_all
+c03b2c0d r __kstrtab_wait_for_completion
+c03b2c21 r __kstrtab_wait_for_completion_timeout
+c03b2c40 r __kstrtab_wait_for_completion_interruptible
+c03b2c80 r __kstrtab_wait_for_completion_interruptible_timeout
+c03b2caa r __kstrtab_interruptible_sleep_on
+c03b2cc1 r __kstrtab_interruptible_sleep_on_timeout
+c03b2ce0 r __kstrtab_sleep_on
+c03b2ce9 r __kstrtab_sleep_on_timeout
+c03b2cfa r __kstrtab_set_user_nice
+c03b2d08 r __kstrtab_task_nice
+c03b2d12 r __kstrtab_sched_setscheduler
+c03b2d25 r __kstrtab_cpu_present_map
+c03b2d35 r __kstrtab_cond_resched
+c03b2d42 r __kstrtab_cond_resched_lock
+c03b2d54 r __kstrtab_cond_resched_softirq
+c03b2d69 r __kstrtab_yield
+c03b2d6f r __kstrtab_io_schedule
+c03b2d7b r __kstrtab_set_cpus_allowed
+c03b2d8c r __kstrtab_nr_cpu_ids
+c03b2d97 r __kstrtab___might_sleep
+c03b2da5 r __kstrtab_free_task
+c03b2daf r __kstrtab_mmput
+c03b2db5 r __kstrtab_get_task_mm
+c03b2dc1 r __kstrtab_copy_fs_struct
+c03b2dd0 r __kstrtab_unshare_files
+c03b2dde r __kstrtab_register_exec_domain
+c03b2df3 r __kstrtab_unregister_exec_domain
+c03b2e0a r __kstrtab___set_personality
+c03b2e1c r __kstrtab_panic_notifier_list
+c03b2e30 r __kstrtab_panic_blink
+c03b2e3c r __kstrtab_panic
+c03b2e42 r __kstrtab_add_taint
+c03b2e4c r __kstrtab_oops_in_progress
+c03b2e5d r __kstrtab_printk
+c03b2e64 r __kstrtab_vprintk
+c03b2e6c r __kstrtab_acquire_console_sem
+c03b2e80 r __kstrtab_try_acquire_console_sem
+c03b2e98 r __kstrtab_release_console_sem
+c03b2eac r __kstrtab_console_conditional_schedule
+c03b2ec9 r __kstrtab_console_print
+c03b2ed7 r __kstrtab_console_stop
+c03b2ee4 r __kstrtab_console_start
+c03b2ef2 r __kstrtab_register_console
+c03b2f03 r __kstrtab_unregister_console
+c03b2f16 r __kstrtab___printk_ratelimit
+c03b2f29 r __kstrtab_printk_ratelimit
+c03b2f3a r __kstrtab_printk_timed_ratelimit
+c03b2f51 r __kstrtab_prof_on
+c03b2f59 r __kstrtab_register_timer_hook
+c03b2f6d r __kstrtab_unregister_timer_hook
+c03b2f83 r __kstrtab_task_handoff_register
+c03b2f99 r __kstrtab_task_handoff_unregister
+c03b2fb1 r __kstrtab_profile_event_register
+c03b2fc8 r __kstrtab_profile_event_unregister
+c03b2fe1 r __kstrtab_profile_hits
+c03b2fee r __kstrtab_allow_signal
+c03b2ffb r __kstrtab_disallow_signal
+c03b300b r __kstrtab_daemonize
+c03b3015 r __kstrtab_put_files_struct
+c03b3026 r __kstrtab_reset_files_struct
+c03b3039 r __kstrtab_exit_fs
+c03b3041 r __kstrtab_do_exit
+c03b3049 r __kstrtab_complete_and_exit
+c03b305b r __kstrtab_sys_tz
+c03b3062 r __kstrtab_current_kernel_time
+c03b3076 r __kstrtab_current_fs_time
+c03b3086 r __kstrtab_jiffies_to_msecs
+c03b3097 r __kstrtab_jiffies_to_usecs
+c03b30a8 r __kstrtab_timespec_trunc
+c03b30b7 r __kstrtab_mktime
+c03b30be r __kstrtab_ns_to_timespec
+c03b30cd r __kstrtab_ns_to_timeval
+c03b30db r __kstrtab_msecs_to_jiffies
+c03b30ec r __kstrtab_usecs_to_jiffies
+c03b30fd r __kstrtab_timespec_to_jiffies
+c03b3111 r __kstrtab_jiffies_to_timespec
+c03b3125 r __kstrtab_timeval_to_jiffies
+c03b3138 r __kstrtab_jiffies_to_timeval
+c03b314b r __kstrtab_jiffies_to_clock_t
+c03b315e r __kstrtab_clock_t_to_jiffies
+c03b3171 r __kstrtab_jiffies_64_to_clock_t
+c03b3187 r __kstrtab_get_jiffies_64
+c03b3196 r __kstrtab_jiffies
+c03b319e r __kstrtab_local_bh_disable
+c03b31af r __kstrtab___local_bh_enable
+c03b31c1 r __kstrtab__local_bh_enable
+c03b31d2 r __kstrtab_local_bh_enable
+c03b31e2 r __kstrtab_local_bh_enable_ip
+c03b31f5 r __kstrtab_raise_softirq_irqoff
+c03b320a r __kstrtab___tasklet_schedule
+c03b321d r __kstrtab___tasklet_hi_schedule
+c03b3233 r __kstrtab_tasklet_init
+c03b3240 r __kstrtab_tasklet_kill
+c03b324d r __kstrtab_on_each_cpu
+c03b3259 r __kstrtab_ioport_resource
+c03b3269 r __kstrtab_iomem_resource
+c03b3278 r __kstrtab_request_resource
+c03b3289 r __kstrtab_release_resource
+c03b329a r __kstrtab_allocate_resource
+c03b32ac r __kstrtab_adjust_resource
+c03b32bc r __kstrtab___request_region
+c03b32cd r __kstrtab___check_region
+c03b32dc r __kstrtab___release_region
+c03b32ed r __kstrtab___devm_request_region
+c03b3303 r __kstrtab___devm_release_region
+c03b3320 r __kstrtab_register_net_sysctl_table
+c03b333a r __kstrtab_unregister_net_sysctl_table
+c03b3356 r __kstrtab_proc_dointvec
+c03b3364 r __kstrtab_proc_dointvec_jiffies
+c03b337a r __kstrtab_proc_dointvec_minmax
+c03b338f r __kstrtab_proc_dointvec_userhz_jiffies
+c03b33ac r __kstrtab_proc_dointvec_ms_jiffies
+c03b33c5 r __kstrtab_proc_dostring
+c03b33d3 r __kstrtab_proc_doulongvec_minmax
+c03b3400 r __kstrtab_proc_doulongvec_ms_jiffies_minmax
+c03b3422 r __kstrtab_register_sysctl_table
+c03b3438 r __kstrtab_sysctl_intvec
+c03b3446 r __kstrtab_sysctl_jiffies
+c03b3455 r __kstrtab_sysctl_ms_jiffies
+c03b3467 r __kstrtab_sysctl_string
+c03b3475 r __kstrtab_sysctl_data
+c03b3481 r __kstrtab_unregister_sysctl_table
+c03b3499 r __kstrtab_securebits
+c03b34a4 r __kstrtab_cap_bset
+c03b34ad r __kstrtab___capable
+c03b34b7 r __kstrtab_capable
+c03b34c0 r __kstrtab_jiffies_64
+c03b34cb r __kstrtab_boot_tvec_bases
+c03b34db r __kstrtab___round_jiffies
+c03b34eb r __kstrtab___round_jiffies_relative
+c03b3504 r __kstrtab_round_jiffies
+c03b3512 r __kstrtab_round_jiffies_relative
+c03b3529 r __kstrtab_init_timer
+c03b3534 r __kstrtab_init_timer_deferrable
+c03b354a r __kstrtab___mod_timer
+c03b3556 r __kstrtab_mod_timer
+c03b3560 r __kstrtab_del_timer
+c03b356a r __kstrtab_try_to_del_timer_sync
+c03b3580 r __kstrtab_del_timer_sync
+c03b358f r __kstrtab_avenrun
+c03b3597 r __kstrtab_schedule_timeout
+c03b35a8 r __kstrtab_schedule_timeout_interruptible
+c03b35e0 r __kstrtab_schedule_timeout_uninterruptible
+c03b3601 r __kstrtab_msleep
+c03b3608 r __kstrtab_msleep_interruptible
+c03b361d r __kstrtab_init_user_ns
+c03b362a r __kstrtab_kill_pid_info_as_uid
+c03b363f r __kstrtab_kill_pgrp
+c03b3649 r __kstrtab_kill_pid
+c03b3652 r __kstrtab_recalc_sigpending
+c03b3664 r __kstrtab_dequeue_signal
+c03b3673 r __kstrtab_flush_signals
+c03b3681 r __kstrtab_force_sig
+c03b368b r __kstrtab_kill_proc
+c03b3695 r __kstrtab_ptrace_notify
+c03b36a3 r __kstrtab_send_sig
+c03b36ac r __kstrtab_send_sig_info
+c03b36ba r __kstrtab_sigprocmask
+c03b36c6 r __kstrtab_block_all_signals
+c03b36d8 r __kstrtab_unblock_all_signals
+c03b3700 r __kstrtab_overflowuid
+c03b370c r __kstrtab_overflowgid
+c03b3718 r __kstrtab_fs_overflowuid
+c03b3727 r __kstrtab_fs_overflowgid
+c03b3736 r __kstrtab_cad_pid
+c03b373e r __kstrtab_atomic_notifier_chain_register
+c03b3760 r __kstrtab_atomic_notifier_chain_unregister
+c03b3781 r __kstrtab___atomic_notifier_call_chain
+c03b379e r __kstrtab_atomic_notifier_call_chain
+c03b37c0 r __kstrtab_blocking_notifier_chain_register
+c03b3800 r __kstrtab_blocking_notifier_chain_unregister
+c03b3823 r __kstrtab___blocking_notifier_call_chain
+c03b3842 r __kstrtab_blocking_notifier_call_chain
+c03b385f r __kstrtab_raw_notifier_chain_register
+c03b387b r __kstrtab_raw_notifier_chain_unregister
+c03b3899 r __kstrtab___raw_notifier_call_chain
+c03b38b3 r __kstrtab_raw_notifier_call_chain
+c03b38cb r __kstrtab_srcu_notifier_chain_register
+c03b38e8 r __kstrtab_srcu_notifier_chain_unregister
+c03b3907 r __kstrtab___srcu_notifier_call_chain
+c03b3922 r __kstrtab_srcu_notifier_call_chain
+c03b393b r __kstrtab_srcu_init_notifier_head
+c03b3953 r __kstrtab_register_reboot_notifier
+c03b396c r __kstrtab_unregister_reboot_notifier
+c03b3987 r __kstrtab_emergency_restart
+c03b3999 r __kstrtab_kernel_restart
+c03b39a8 r __kstrtab_kernel_halt
+c03b39b4 r __kstrtab_kernel_power_off
+c03b39c5 r __kstrtab_groups_alloc
+c03b39d2 r __kstrtab_groups_free
+c03b39de r __kstrtab_set_current_groups
+c03b39f1 r __kstrtab_in_group_p
+c03b39fc r __kstrtab_in_egroup_p
+c03b3a08 r __kstrtab_uts_sem
+c03b3a10 r __kstrtab_orderly_poweroff
+c03b3a21 r __kstrtab_request_module
+c03b3a30 r __kstrtab_call_usermodehelper_freeinfo
+c03b3a4d r __kstrtab_call_usermodehelper_setup
+c03b3a67 r __kstrtab_call_usermodehelper_setkeys
+c03b3a83 r __kstrtab_call_usermodehelper_setcleanup
+c03b3aa2 r __kstrtab_call_usermodehelper_stdinpipe
+c03b3ac0 r __kstrtab_call_usermodehelper_exec
+c03b3ad9 r __kstrtab_call_usermodehelper_pipe
+c03b3af2 r __kstrtab_queue_work
+c03b3afd r __kstrtab_queue_delayed_work
+c03b3b10 r __kstrtab_queue_delayed_work_on
+c03b3b26 r __kstrtab_flush_workqueue
+c03b3b36 r __kstrtab_cancel_work_sync
+c03b3b47 r __kstrtab_cancel_rearming_delayed_work
+c03b3b64 r __kstrtab_schedule_work
+c03b3b72 r __kstrtab_schedule_delayed_work
+c03b3b88 r __kstrtab_schedule_delayed_work_on
+c03b3ba1 r __kstrtab_flush_scheduled_work
+c03b3bb6 r __kstrtab_execute_in_process_context
+c03b3bd1 r __kstrtab___create_workqueue
+c03b3be4 r __kstrtab_destroy_workqueue
+c03b3bf6 r __kstrtab_put_pid
+c03b3bfe r __kstrtab_find_pid
+c03b3c07 r __kstrtab_find_task_by_pid_type
+c03b3c1d r __kstrtab_find_get_pid
+c03b3c2a r __kstrtab_rcu_barrier
+c03b3c36 r __kstrtab_rcu_batches_completed
+c03b3c4c r __kstrtab_rcu_batches_completed_bh
+c03b3c65 r __kstrtab_call_rcu
+c03b3c6e r __kstrtab_call_rcu_bh
+c03b3c7a r __kstrtab_synchronize_rcu
+c03b3c8a r __kstrtab_param_set_byte
+c03b3c99 r __kstrtab_param_get_byte
+c03b3ca8 r __kstrtab_param_set_short
+c03b3cb8 r __kstrtab_param_get_short
+c03b3cc8 r __kstrtab_param_set_ushort
+c03b3cd9 r __kstrtab_param_get_ushort
+c03b3cea r __kstrtab_param_set_int
+c03b3cf8 r __kstrtab_param_get_int
+c03b3d06 r __kstrtab_param_set_uint
+c03b3d15 r __kstrtab_param_get_uint
+c03b3d24 r __kstrtab_param_set_long
+c03b3d33 r __kstrtab_param_get_long
+c03b3d42 r __kstrtab_param_set_ulong
+c03b3d52 r __kstrtab_param_get_ulong
+c03b3d62 r __kstrtab_param_set_charp
+c03b3d72 r __kstrtab_param_get_charp
+c03b3d82 r __kstrtab_param_set_bool
+c03b3d91 r __kstrtab_param_get_bool
+c03b3da0 r __kstrtab_param_set_invbool
+c03b3db2 r __kstrtab_param_get_invbool
+c03b3dc4 r __kstrtab_param_array_set
+c03b3dd4 r __kstrtab_param_array_get
+c03b3de4 r __kstrtab_param_set_copystring
+c03b3df9 r __kstrtab_param_get_string
+c03b3e0a r __kstrtab_posix_timer_event
+c03b3e1c r __kstrtab_register_posix_clock
+c03b3e31 r __kstrtab_do_posix_clock_nosettime
+c03b3e4a r __kstrtab_do_posix_clock_nonanosleep
+c03b3e65 r __kstrtab_kthread_should_stop
+c03b3e79 r __kstrtab_kthread_create
+c03b3e88 r __kstrtab_kthread_bind
+c03b3e95 r __kstrtab_kthread_stop
+c03b3ea2 r __kstrtab_init_waitqueue_head
+c03b3eb6 r __kstrtab_add_wait_queue
+c03b3ec5 r __kstrtab_add_wait_queue_exclusive
+c03b3ede r __kstrtab_remove_wait_queue
+c03b3ef0 r __kstrtab_prepare_to_wait
+c03b3f00 r __kstrtab_prepare_to_wait_exclusive
+c03b3f1a r __kstrtab_finish_wait
+c03b3f26 r __kstrtab_autoremove_wake_function
+c03b3f3f r __kstrtab_wake_bit_function
+c03b3f51 r __kstrtab___wait_on_bit
+c03b3f5f r __kstrtab_out_of_line_wait_on_bit
+c03b3f77 r __kstrtab___wait_on_bit_lock
+c03b3f8a r __kstrtab_out_of_line_wait_on_bit_lock
+c03b3fa7 r __kstrtab___wake_up_bit
+c03b3fb5 r __kstrtab_wake_up_bit
+c03b3fc1 r __kstrtab_bit_waitqueue
+c03b3fcf r __kstrtab_kfifo_init
+c03b3fda r __kstrtab_kfifo_alloc
+c03b3fe6 r __kstrtab_kfifo_free
+c03b3ff1 r __kstrtab___kfifo_put
+c03b3ffd r __kstrtab___kfifo_get
+c03b4009 r __kstrtab___mutex_init
+c03b4016 r __kstrtab_mutex_lock
+c03b4021 r __kstrtab_mutex_unlock
+c03b402e r __kstrtab_mutex_lock_interruptible
+c03b4047 r __kstrtab_mutex_trylock
+c03b4055 r __kstrtab_ktime_get
+c03b405f r __kstrtab_ktime_get_real
+c03b406e r __kstrtab_ktime_get_ts
+c03b407b r __kstrtab_hrtimer_forward
+c03b408b r __kstrtab_hrtimer_start
+c03b4099 r __kstrtab_hrtimer_try_to_cancel
+c03b40af r __kstrtab_hrtimer_cancel
+c03b40be r __kstrtab_hrtimer_get_remaining
+c03b40d4 r __kstrtab_hrtimer_init
+c03b40e1 r __kstrtab_hrtimer_get_res
+c03b40f1 r __kstrtab_down_read
+c03b40fb r __kstrtab_down_read_trylock
+c03b410d r __kstrtab_down_write
+c03b4118 r __kstrtab_down_write_trylock
+c03b412b r __kstrtab_up_read
+c03b4133 r __kstrtab_up_write
+c03b413c r __kstrtab_downgrade_write
+c03b414c r __kstrtab_set_acceptable_latency
+c03b4163 r __kstrtab_modify_acceptable_latency
+c03b417d r __kstrtab_remove_acceptable_latency
+c03b4197 r __kstrtab_system_latency_constraint
+c03b41b1 r __kstrtab_synchronize_acceptable_latency
+c03b41d0 r __kstrtab_register_latency_notifier
+c03b41ea r __kstrtab_unregister_latency_notifier
+c03b4206 r __kstrtab_init_srcu_struct
+c03b4217 r __kstrtab_cleanup_srcu_struct
+c03b422b r __kstrtab_srcu_read_lock
+c03b423a r __kstrtab_srcu_read_unlock
+c03b424b r __kstrtab_synchronize_srcu
+c03b425c r __kstrtab_srcu_batches_completed
+c03b4273 r __kstrtab_srcu_readers_active
+c03b4287 r __kstrtab_register_die_notifier
+c03b429d r __kstrtab_unregister_die_notifier
+c03b42b5 r __kstrtab_free_vx_info
+c03b42c2 r __kstrtab_free_nx_info
+c03b42cf r __kstrtab_unhash_nx_info
+c03b42de r __kstrtab_vlimit_name
+c03b42ea r __kstrtab_locate_dl_info
+c03b42f9 r __kstrtab_rcu_free_dl_info
+c03b430a r __kstrtab_ip_v4_find_src
+c03b4319 r __kstrtab_xtime_lock
+c03b4324 r __kstrtab_xtime
+c03b432a r __kstrtab_getnstimeofday
+c03b4339 r __kstrtab_do_gettimeofday
+c03b4349 r __kstrtab_do_settimeofday
+c03b4359 r __kstrtab_getboottime
+c03b4365 r __kstrtab_monotonic_to_bootbased
+c03b437c r __kstrtab_clocksource_register
+c03b4391 r __kstrtab_clockevents_notify
+c03b43a4 r __kstrtab_get_futex_key
+c03b43b2 r __kstrtab_get_futex_key_refs
+c03b43c5 r __kstrtab_drop_futex_key_refs
+c03b43d9 r __kstrtab_rt_mutex_lock
+c03b43e7 r __kstrtab_rt_mutex_lock_interruptible
+c03b4403 r __kstrtab_rt_mutex_timed_lock
+c03b4417 r __kstrtab_rt_mutex_trylock
+c03b4428 r __kstrtab_rt_mutex_unlock
+c03b4438 r __kstrtab_rt_mutex_destroy
+c03b4449 r __kstrtab___rt_mutex_init
+c03b4459 r __kstrtab_request_dma
+c03b4465 r __kstrtab_free_dma
+c03b446e r __kstrtab_dma_spin_lock
+c03b447c r __kstrtab__spin_trylock
+c03b448a r __kstrtab__read_trylock
+c03b4498 r __kstrtab__write_trylock
+c03b44a7 r __kstrtab__read_lock
+c03b44b2 r __kstrtab__spin_lock_irqsave
+c03b44c5 r __kstrtab__spin_lock_irq
+c03b44d4 r __kstrtab__spin_lock_bh
+c03b44e2 r __kstrtab__read_lock_irqsave
+c03b44f5 r __kstrtab__read_lock_irq
+c03b4504 r __kstrtab__read_lock_bh
+c03b4512 r __kstrtab__write_lock_irqsave
+c03b4526 r __kstrtab__write_lock_irq
+c03b4536 r __kstrtab__write_lock_bh
+c03b4545 r __kstrtab__spin_lock
+c03b4550 r __kstrtab__write_lock
+c03b455c r __kstrtab__spin_unlock
+c03b4569 r __kstrtab__write_unlock
+c03b4577 r __kstrtab__read_unlock
+c03b4584 r __kstrtab__spin_unlock_irqrestore
+c03b459c r __kstrtab__spin_unlock_irq
+c03b45ad r __kstrtab__spin_unlock_bh
+c03b45bd r __kstrtab__read_unlock_irqrestore
+c03b45d5 r __kstrtab__read_unlock_irq
+c03b45e6 r __kstrtab__read_unlock_bh
+c03b45f6 r __kstrtab__write_unlock_irqrestore
+c03b460f r __kstrtab__write_unlock_irq
+c03b4621 r __kstrtab__write_unlock_bh
+c03b4632 r __kstrtab__spin_trylock_bh
+c03b4643 r __kstrtab_in_lock_functions
+c03b4655 r __kstrtab_register_module_notifier
+c03b466e r __kstrtab_unregister_module_notifier
+c03b4689 r __kstrtab___module_put_and_exit
+c03b469f r __kstrtab_module_refcount
+c03b46af r __kstrtab___symbol_put
+c03b46bc r __kstrtab_symbol_put_addr
+c03b46cc r __kstrtab_module_put
+c03b46d7 r __kstrtab___symbol_get
+c03b46e4 r __kstrtab_module_add_driver
+c03b46f6 r __kstrtab_module_remove_driver
+c03b470b r __kstrtab___print_symbol
+c03b471a r __kstrtab_sprint_symbol
+c03b4728 r __kstrtab_pm_suspend
+c03b4733 r __kstrtab_refrigerator
+c03b4740 r __kstrtab_pm_register
+c03b474c r __kstrtab_pm_send_all
+c03b4758 r __kstrtab_pm_active
+c03b4762 r __kstrtab_stop_machine_run
+c03b4773 r __kstrtab_register_kprobe
+c03b4783 r __kstrtab_unregister_kprobe
+c03b4795 r __kstrtab_register_jprobe
+c03b47a5 r __kstrtab_unregister_jprobe
+c03b47b7 r __kstrtab_jprobe_return
+c03b47c5 r __kstrtab_register_kretprobe
+c03b47d8 r __kstrtab_unregister_kretprobe
+c03b47ed r __kstrtab_kernel_subsys
+c03b47fb r __kstrtab_touch_softlockup_watchdog
+c03b4815 r __kstrtab_touch_all_softlockup_watchdogs
+c03b4834 r __kstrtab_synchronize_irq
+c03b4844 r __kstrtab_disable_irq_nosync
+c03b4857 r __kstrtab_disable_irq
+c03b4863 r __kstrtab_enable_irq
+c03b486e r __kstrtab_set_irq_wake
+c03b487b r __kstrtab_free_irq
+c03b4884 r __kstrtab_request_irq
+c03b4890 r __kstrtab_set_irq_chip
+c03b489d r __kstrtab_set_irq_type
+c03b48aa r __kstrtab_set_irq_data
+c03b48b7 r __kstrtab_set_irq_chip_data
+c03b48c9 r __kstrtab_devm_request_irq
+c03b48da r __kstrtab_devm_free_irq
+c03b48e8 r __kstrtab_probe_irq_on
+c03b48f5 r __kstrtab_probe_irq_mask
+c03b4904 r __kstrtab_probe_irq_off
+c03b4912 r __kstrtab_relay_buf_empty
+c03b4922 r __kstrtab_relay_buf_full
+c03b4931 r __kstrtab_relay_reset
+c03b493d r __kstrtab_relay_open
+c03b4948 r __kstrtab_relay_switch_subbuf
+c03b495c r __kstrtab_relay_subbufs_consumed
+c03b4973 r __kstrtab_relay_close
+c03b497f r __kstrtab_relay_flush
+c03b498b r __kstrtab_relay_file_operations
+c03b49c0 r __kstrtab_filemap_fdatawrite
+c03b49d3 r __kstrtab_filemap_flush
+c03b49e1 r __kstrtab_sync_page_range
+c03b49f1 r __kstrtab_sync_page_range_nolock
+c03b4a08 r __kstrtab_filemap_fdatawait
+c03b4a1a r __kstrtab_filemap_write_and_wait
+c03b4a31 r __kstrtab_add_to_page_cache
+c03b4a43 r __kstrtab_wait_on_page_bit
+c03b4a54 r __kstrtab_unlock_page
+c03b4a60 r __kstrtab_end_page_writeback
+c03b4a73 r __kstrtab___lock_page
+c03b4a7f r __kstrtab_find_get_page
+c03b4a8d r __kstrtab_find_lock_page
+c03b4a9c r __kstrtab_find_or_create_page
+c03b4ab0 r __kstrtab_find_get_pages_contig
+c03b4ac6 r __kstrtab_find_get_pages_tag
+c03b4ad9 r __kstrtab_grab_cache_page_nowait
+c03b4af0 r __kstrtab_do_generic_mapping_read
+c03b4b08 r __kstrtab_generic_segment_checks
+c03b4b1f r __kstrtab_generic_file_aio_read
+c03b4b35 r __kstrtab_generic_file_sendfile
+c03b4b4b r __kstrtab_filemap_fault
+c03b4b59 r __kstrtab_filemap_nopage
+c03b4b68 r __kstrtab_filemap_populate
+c03b4b79 r __kstrtab_generic_file_mmap
+c03b4b8b r __kstrtab_generic_file_readonly_mmap
+c03b4ba6 r __kstrtab_read_cache_page_async
+c03b4bbc r __kstrtab_read_cache_page
+c03b4bcc r __kstrtab_should_remove_suid
+c03b4bdf r __kstrtab_remove_suid
+c03b4beb r __kstrtab_generic_write_checks
+c03b4c00 r __kstrtab_generic_file_direct_write
+c03b4c1a r __kstrtab_generic_file_buffered_write
+c03b4c36 r __kstrtab_generic_file_aio_write_nolock
+c03b4c54 r __kstrtab_generic_file_aio_write
+c03b4c6b r __kstrtab_try_to_release_page
+c03b4c7f r __kstrtab_mempool_create
+c03b4c8e r __kstrtab_mempool_create_node
+c03b4ca2 r __kstrtab_mempool_resize
+c03b4cb1 r __kstrtab_mempool_destroy
+c03b4cc1 r __kstrtab_mempool_alloc
+c03b4ccf r __kstrtab_mempool_free
+c03b4cdc r __kstrtab_mempool_alloc_slab
+c03b4cef r __kstrtab_mempool_free_slab
+c03b4d01 r __kstrtab_mempool_kmalloc
+c03b4d11 r __kstrtab_mempool_kzalloc
+c03b4d21 r __kstrtab_mempool_kfree
+c03b4d2f r __kstrtab_mempool_alloc_pages
+c03b4d43 r __kstrtab_mempool_free_pages
+c03b4d56 r __kstrtab_node_online_map
+c03b4d66 r __kstrtab_node_possible_map
+c03b4d78 r __kstrtab_totalram_pages
+c03b4d87 r __kstrtab___alloc_pages
+c03b4d95 r __kstrtab___get_free_pages
+c03b4da6 r __kstrtab_get_zeroed_page
+c03b4db6 r __kstrtab___free_pages
+c03b4dc3 r __kstrtab_free_pages
+c03b4dce r __kstrtab_si_meminfo
+c03b4dd9 r __kstrtab_contig_page_data
+c03b4e00 r __kstrtab_laptop_mode
+c03b4e20 r __kstrtab_balance_dirty_pages_ratelimited_nr
+c03b4e43 r __kstrtab_write_cache_pages
+c03b4e55 r __kstrtab_generic_writepages
+c03b4e68 r __kstrtab_write_one_page
+c03b4e77 r __kstrtab___set_page_dirty_nobuffers
+c03b4e92 r __kstrtab_redirty_page_for_writepage
+c03b4ead r __kstrtab_set_page_dirty
+c03b4ebc r __kstrtab_set_page_dirty_lock
+c03b4ed0 r __kstrtab_clear_page_dirty_for_io
+c03b4ee8 r __kstrtab_test_set_page_writeback
+c03b4f00 r __kstrtab_mapping_tagged
+c03b4f0f r __kstrtab_default_unplug_io_fn
+c03b4f24 r __kstrtab_default_backing_dev_info
+c03b4f3d r __kstrtab_file_ra_state_init
+c03b4f50 r __kstrtab_read_cache_pages
+c03b4f61 r __kstrtab_page_cache_readahead
+c03b4f76 r __kstrtab_put_page
+c03b4f7f r __kstrtab_put_pages_list
+c03b4f8e r __kstrtab_mark_page_accessed
+c03b4fa1 r __kstrtab___pagevec_release
+c03b4fb3 r __kstrtab___pagevec_lru_add
+c03b4fc5 r __kstrtab_pagevec_lookup
+c03b4fd4 r __kstrtab_pagevec_lookup_tag
+c03b4fe7 r __kstrtab_cancel_dirty_page
+c03b4ff9 r __kstrtab_truncate_inode_pages_range
+c03b5014 r __kstrtab_truncate_inode_pages
+c03b5029 r __kstrtab_invalidate_mapping_pages
+c03b5042 r __kstrtab_invalidate_inode_pages2_range
+c03b5060 r __kstrtab_invalidate_inode_pages2
+c03b5078 r __kstrtab_set_shrinker
+c03b5085 r __kstrtab_remove_shrinker
+c03b5095 r __kstrtab___kzalloc
+c03b509f r __kstrtab_kstrdup
+c03b50a7 r __kstrtab_kstrndup
+c03b50b0 r __kstrtab_kmemdup
+c03b50b8 r __kstrtab_strndup_user
+c03b50c5 r __kstrtab_per_cpu__vm_event_states
+c03b50de r __kstrtab_all_vm_events
+c03b50ec r __kstrtab_vm_stat
+c03b50f4 r __kstrtab___mod_zone_page_state
+c03b510a r __kstrtab_mod_zone_page_state
+c03b511e r __kstrtab___inc_zone_page_state
+c03b5134 r __kstrtab___dec_zone_page_state
+c03b514a r __kstrtab_inc_zone_page_state
+c03b515e r __kstrtab_dec_zone_page_state
+c03b5172 r __kstrtab_refresh_vm_stats
+c03b5183 r __kstrtab_clear_bdi_congested
+c03b5197 r __kstrtab_set_bdi_congested
+c03b51a9 r __kstrtab_congestion_wait
+c03b51b9 r __kstrtab_congestion_wait_interruptible
+c03b51d7 r __kstrtab_congestion_end
+c03b51e6 r __kstrtab_install_page
+c03b51f3 r __kstrtab_kmap_high
+c03b51fd r __kstrtab_kunmap_high
+c03b5209 r __kstrtab_page_address
+c03b5216 r __kstrtab_max_mapnr
+c03b5220 r __kstrtab_mem_map
+c03b5228 r __kstrtab_num_physpages
+c03b5236 r __kstrtab_high_memory
+c03b5242 r __kstrtab_vmalloc_earlyreserve
+c03b5257 r __kstrtab_get_user_pages
+c03b5266 r __kstrtab_vm_insert_page
+c03b5275 r __kstrtab_vm_insert_pfn
+c03b5283 r __kstrtab_remap_pfn_range
+c03b5293 r __kstrtab_apply_to_page_range
+c03b52a7 r __kstrtab_unmap_mapping_range
+c03b52bb r __kstrtab_vmtruncate
+c03b52c6 r __kstrtab___handle_mm_fault
+c03b52d8 r __kstrtab_vmalloc_to_page
+c03b52e8 r __kstrtab_vmalloc_to_pfn
+c03b52f7 r __kstrtab_can_do_mlock
+c03b5304 r __kstrtab_vm_get_page_prot
+c03b5315 r __kstrtab___vm_enough_memory
+c03b5328 r __kstrtab_do_mmap_pgoff
+c03b5336 r __kstrtab_get_unmapped_area
+c03b5348 r __kstrtab_find_vma
+c03b5351 r __kstrtab_do_munmap
+c03b535b r __kstrtab_do_brk
+c03b5362 r __kstrtab_page_mkclean
+c03b536f r __kstrtab_vfree
+c03b5375 r __kstrtab_vunmap
+c03b537c r __kstrtab_vmap
+c03b5381 r __kstrtab___vmalloc
+c03b538b r __kstrtab_vmalloc
+c03b5393 r __kstrtab_vmalloc_user
+c03b53a0 r __kstrtab_vmalloc_node
+c03b53ad r __kstrtab_vmalloc_32
+c03b53b8 r __kstrtab_vmalloc_32_user
+c03b53c8 r __kstrtab_remap_vmalloc_range
+c03b53dc r __kstrtab_blk_queue_bounce
+c03b53ed r __kstrtab_malloc_sizes
+c03b53fa r __kstrtab_kmem_cache_create
+c03b540c r __kstrtab_kmem_cache_shrink
+c03b541e r __kstrtab_kmem_cache_destroy
+c03b5431 r __kstrtab_kmem_cache_alloc
+c03b5442 r __kstrtab_kmem_cache_zalloc
+c03b5454 r __kstrtab___kmalloc
+c03b545e r __kstrtab_krealloc
+c03b5467 r __kstrtab_kmem_cache_free
+c03b5477 r __kstrtab_kfree
+c03b547d r __kstrtab_kmem_cache_size
+c03b548d r __kstrtab_kmem_cache_name
+c03b549d r __kstrtab_xip_file_read
+c03b54ab r __kstrtab_xip_file_sendfile
+c03b54bd r __kstrtab_xip_file_mmap
+c03b54cb r __kstrtab_xip_file_write
+c03b54da r __kstrtab_xip_truncate_page
+c03b54ec r __kstrtab_percpu_depopulate
+c03b54fe r __kstrtab___percpu_depopulate_mask
+c03b5517 r __kstrtab_percpu_populate
+c03b5527 r __kstrtab___percpu_populate_mask
+c03b553e r __kstrtab___percpu_alloc_mask
+c03b5552 r __kstrtab_percpu_free
+c03b5560 r __kstrtab_vfs_statfs
+c03b556b r __kstrtab_filp_open
+c03b5575 r __kstrtab_lookup_instantiate_filp
+c03b558d r __kstrtab_dentry_open
+c03b5599 r __kstrtab_get_unused_fd
+c03b55a7 r __kstrtab_put_unused_fd
+c03b55b5 r __kstrtab_fd_install
+c03b55c0 r __kstrtab_sys_open
+c03b55c9 r __kstrtab_filp_close
+c03b55d4 r __kstrtab_sys_close
+c03b55de r __kstrtab_generic_file_open
+c03b55f0 r __kstrtab_nonseekable_open
+c03b5601 r __kstrtab_generic_ro_fops
+c03b5611 r __kstrtab_generic_file_llseek
+c03b5625 r __kstrtab_remote_llseek
+c03b5633 r __kstrtab_no_llseek
+c03b563d r __kstrtab_default_llseek
+c03b564c r __kstrtab_vfs_llseek
+c03b5657 r __kstrtab_do_sync_read
+c03b5664 r __kstrtab_vfs_read
+c03b566d r __kstrtab_do_sync_write
+c03b567b r __kstrtab_vfs_write
+c03b5685 r __kstrtab_sys_read
+c03b568e r __kstrtab_vfs_readv
+c03b5698 r __kstrtab_vfs_writev
+c03b56a3 r __kstrtab_get_max_files
+c03b56b1 r __kstrtab_get_empty_filp
+c03b56c0 r __kstrtab_fput
+c03b56c5 r __kstrtab_fget
+c03b56ca r __kstrtab_deactivate_super
+c03b56db r __kstrtab_lock_super
+c03b56e6 r __kstrtab_unlock_super
+c03b56f3 r __kstrtab_generic_shutdown_super
+c03b570a r __kstrtab_sget
+c03b570f r __kstrtab_drop_super
+c03b571a r __kstrtab_get_super
+c03b5724 r __kstrtab_set_anon_super
+c03b5733 r __kstrtab_kill_anon_super
+c03b5743 r __kstrtab_kill_litter_super
+c03b5755 r __kstrtab_get_sb_bdev
+c03b5761 r __kstrtab_kill_block_super
+c03b5772 r __kstrtab_get_sb_nodev
+c03b577f r __kstrtab_get_sb_single
+c03b578d r __kstrtab_vfs_kern_mount
+c03b579c r __kstrtab_kern_mount
+c03b57a7 r __kstrtab_register_chrdev_region
+c03b57be r __kstrtab_unregister_chrdev_region
+c03b57d7 r __kstrtab_alloc_chrdev_region
+c03b57eb r __kstrtab_cdev_init
+c03b57f5 r __kstrtab_cdev_alloc
+c03b5800 r __kstrtab_cdev_del
+c03b5809 r __kstrtab_cdev_add
+c03b5812 r __kstrtab_register_chrdev
+c03b5822 r __kstrtab_unregister_chrdev
+c03b5834 r __kstrtab_directly_mappable_cdev_bdi
+c03b584f r __kstrtab_generic_fillattr
+c03b5860 r __kstrtab_vfs_getattr
+c03b586c r __kstrtab_vfs_stat
+c03b5875 r __kstrtab_vfs_lstat
+c03b587f r __kstrtab_vfs_fstat
+c03b5889 r __kstrtab_inode_add_bytes
+c03b5899 r __kstrtab_inode_sub_bytes
+c03b58a9 r __kstrtab_inode_get_bytes
+c03b58b9 r __kstrtab_inode_set_bytes
+c03b58c9 r __kstrtab_suid_dumpable
+c03b58d7 r __kstrtab_register_binfmt
+c03b58e7 r __kstrtab_unregister_binfmt
+c03b58f9 r __kstrtab_copy_strings_kernel
+c03b590d r __kstrtab_setup_arg_pages
+c03b591d r __kstrtab_open_exec
+c03b5927 r __kstrtab_kernel_read
+c03b5933 r __kstrtab_flush_old_exec
+c03b5942 r __kstrtab_prepare_binprm
+c03b5951 r __kstrtab_compute_creds
+c03b595f r __kstrtab_remove_arg_zero
+c03b596f r __kstrtab_search_binary_handler
+c03b5985 r __kstrtab_set_binfmt
+c03b5990 r __kstrtab_lookup_create
+c03b599e r __kstrtab___user_walk
+c03b59aa r __kstrtab___user_walk_fd
+c03b59b9 r __kstrtab_follow_down
+c03b59c5 r __kstrtab_follow_up
+c03b59cf r __kstrtab_get_write_access
+c03b59e0 r __kstrtab_getname
+c03b59e8 r __kstrtab_lock_rename
+c03b59f4 r __kstrtab_lookup_one_len_nd
+c03b5a06 r __kstrtab_page_follow_link_light
+c03b5a1d r __kstrtab_page_put_link
+c03b5a2b r __kstrtab_page_readlink
+c03b5a39 r __kstrtab___page_symlink
+c03b5a48 r __kstrtab_page_symlink
+c03b5a55 r __kstrtab_page_symlink_inode_operations
+c03b5a73 r __kstrtab_path_lookup
+c03b5a7f r __kstrtab_path_release
+c03b5a8c r __kstrtab_path_walk
+c03b5a96 r __kstrtab_permission
+c03b5aa1 r __kstrtab_vfs_permission
+c03b5ab0 r __kstrtab_file_permission
+c03b5ac0 r __kstrtab_unlock_rename
+c03b5ace r __kstrtab_vfs_create
+c03b5ad9 r __kstrtab_vfs_follow_link
+c03b5ae9 r __kstrtab_vfs_link
+c03b5af2 r __kstrtab_vfs_mkdir
+c03b5afc r __kstrtab_vfs_mknod
+c03b5b06 r __kstrtab_generic_permission
+c03b5b19 r __kstrtab_vfs_readlink
+c03b5b26 r __kstrtab_vfs_rename
+c03b5b31 r __kstrtab_vfs_rmdir
+c03b5b3b r __kstrtab_vfs_symlink
+c03b5b47 r __kstrtab_vfs_unlink
+c03b5b52 r __kstrtab_dentry_unhash
+c03b5b60 r __kstrtab_generic_readlink
+c03b5b71 r __kstrtab___f_setown
+c03b5b7c r __kstrtab_f_setown
+c03b5b85 r __kstrtab_fasync_helper
+c03b5b93 r __kstrtab___kill_fasync
+c03b5ba1 r __kstrtab_kill_fasync
+c03b5bad r __kstrtab_vfs_readdir
+c03b5bb9 r __kstrtab_poll_initwait
+c03b5bc7 r __kstrtab_poll_freewait
+c03b5bd5 r __kstrtab_locks_init_lock
+c03b5be5 r __kstrtab_locks_copy_lock
+c03b5bf5 r __kstrtab_posix_test_lock
+c03b5c05 r __kstrtab_posix_lock_file
+c03b5c15 r __kstrtab_posix_lock_file_wait
+c03b5c2a r __kstrtab_locks_mandatory_area
+c03b5c3f r __kstrtab_lease_modify
+c03b5c4c r __kstrtab___break_lease
+c03b5c5a r __kstrtab_lease_get_mtime
+c03b5c6a r __kstrtab_setlease
+c03b5c73 r __kstrtab_flock_lock_file_wait
+c03b5c88 r __kstrtab_vfs_test_lock
+c03b5c96 r __kstrtab_vfs_lock_file
+c03b5ca4 r __kstrtab_locks_remove_posix
+c03b5cb7 r __kstrtab_posix_unblock_lock
+c03b5cca r __kstrtab_vfs_cancel_lock
+c03b5cda r __kstrtab_lock_may_read
+c03b5ce8 r __kstrtab_lock_may_write
+c03b5cf7 r __kstrtab_sysctl_vfs_cache_pressure
+c03b5d11 r __kstrtab_dcache_lock
+c03b5d1d r __kstrtab_d_instantiate_unique
+c03b5d32 r __kstrtab_d_genocide
+c03b5d3d r __kstrtab_d_alloc
+c03b5d45 r __kstrtab_d_alloc_anon
+c03b5d52 r __kstrtab_d_alloc_root
+c03b5d5f r __kstrtab_d_delete
+c03b5d68 r __kstrtab_d_find_alias
+c03b5d75 r __kstrtab_d_instantiate
+c03b5d83 r __kstrtab_d_invalidate
+c03b5d90 r __kstrtab_d_lookup
+c03b5d99 r __kstrtab_d_move
+c03b5da0 r __kstrtab_d_materialise_unique
+c03b5db5 r __kstrtab_d_path
+c03b5dbc r __kstrtab_d_prune_aliases
+c03b5dcc r __kstrtab_d_rehash
+c03b5dd5 r __kstrtab_d_splice_alias
+c03b5de4 r __kstrtab_d_validate
+c03b5def r __kstrtab_dget_locked
+c03b5dfb r __kstrtab_dput
+c03b5e00 r __kstrtab_find_inode_number
+c03b5e12 r __kstrtab_have_submounts
+c03b5e21 r __kstrtab_names_cachep
+c03b5e2e r __kstrtab_shrink_dcache_parent
+c03b5e43 r __kstrtab_shrink_dcache_sb
+c03b5e54 r __kstrtab_inode_init_once
+c03b5e64 r __kstrtab___iget
+c03b5e6b r __kstrtab_clear_inode
+c03b5e77 r __kstrtab_invalidate_inodes
+c03b5e89 r __kstrtab_new_inode
+c03b5e93 r __kstrtab_unlock_new_inode
+c03b5ea4 r __kstrtab_iunique
+c03b5eac r __kstrtab_igrab
+c03b5eb2 r __kstrtab_ilookup5_nowait
+c03b5ec2 r __kstrtab_ilookup5
+c03b5ecb r __kstrtab_ilookup
+c03b5ed3 r __kstrtab_iget5_locked
+c03b5ee0 r __kstrtab_iget_locked
+c03b5eec r __kstrtab___insert_inode_hash
+c03b5f00 r __kstrtab_remove_inode_hash
+c03b5f12 r __kstrtab_generic_delete_inode
+c03b5f27 r __kstrtab_generic_drop_inode
+c03b5f3a r __kstrtab_iput
+c03b5f3f r __kstrtab_bmap
+c03b5f44 r __kstrtab_touch_atime
+c03b5f50 r __kstrtab_file_update_time
+c03b5f61 r __kstrtab_inode_needs_sync
+c03b5f72 r __kstrtab_inode_double_lock
+c03b5f84 r __kstrtab_inode_double_unlock
+c03b5f98 r __kstrtab_init_special_inode
+c03b5fab r __kstrtab_inode_change_ok
+c03b5fbb r __kstrtab_inode_setattr
+c03b5fc9 r __kstrtab_notify_change
+c03b5fd7 r __kstrtab_make_bad_inode
+c03b5fe6 r __kstrtab_is_bad_inode
+c03b5ff3 r __kstrtab_register_filesystem
+c03b6007 r __kstrtab_unregister_filesystem
+c03b601d r __kstrtab_get_fs_type
+c03b6029 r __kstrtab_fs_subsys
+c03b6033 r __kstrtab_simple_set_mnt
+c03b6042 r __kstrtab_mntput_no_expire
+c03b6053 r __kstrtab_mnt_pin
+c03b605b r __kstrtab_mnt_unpin
+c03b6065 r __kstrtab_may_umount_tree
+c03b6075 r __kstrtab_may_umount
+c03b6080 r __kstrtab_do_add_mount
+c03b608d r __kstrtab_mark_mounts_for_expiry
+c03b60a4 r __kstrtab_shrink_submounts
+c03b60b5 r __kstrtab_kick_iocb
+c03b60bf r __kstrtab_aio_complete
+c03b60cc r __kstrtab_aio_put_req
+c03b60d8 r __kstrtab_wait_on_sync_kiocb
+c03b60eb r __kstrtab_seq_open
+c03b60f4 r __kstrtab_seq_read
+c03b60fd r __kstrtab_seq_lseek
+c03b6107 r __kstrtab_seq_release
+c03b6113 r __kstrtab_seq_escape
+c03b611e r __kstrtab_seq_printf
+c03b6129 r __kstrtab_seq_path
+c03b6132 r __kstrtab_single_open
+c03b613e r __kstrtab_single_release
+c03b614d r __kstrtab_seq_release_private
+c03b6161 r __kstrtab_seq_putc
+c03b616a r __kstrtab_seq_puts
+c03b6173 r __kstrtab_vfs_setxattr
+c03b6180 r __kstrtab_vfs_getxattr
+c03b618d r __kstrtab_vfs_listxattr
+c03b619b r __kstrtab_vfs_removexattr
+c03b61ab r __kstrtab_generic_getxattr
+c03b61bc r __kstrtab_generic_listxattr
+c03b61ce r __kstrtab_generic_setxattr
+c03b61df r __kstrtab_generic_removexattr
+c03b61f3 r __kstrtab_dcache_dir_close
+c03b6204 r __kstrtab_dcache_dir_lseek
+c03b6215 r __kstrtab_dcache_dir_open
+c03b6225 r __kstrtab_dcache_readdir
+c03b6234 r __kstrtab_dcache_readdir_filter
+c03b624a r __kstrtab_generic_read_dir
+c03b625b r __kstrtab_get_sb_pseudo
+c03b6269 r __kstrtab_simple_commit_write
+c03b627d r __kstrtab_simple_dir_inode_operations
+c03b6299 r __kstrtab_simple_dir_operations
+c03b62af r __kstrtab_simple_empty
+c03b62bc r __kstrtab_d_alloc_name
+c03b62c9 r __kstrtab_simple_fill_super
+c03b62db r __kstrtab_simple_getattr
+c03b62ea r __kstrtab_simple_link
+c03b62f6 r __kstrtab_simple_lookup
+c03b6304 r __kstrtab_simple_pin_fs
+c03b6312 r __kstrtab_simple_prepare_write
+c03b6327 r __kstrtab_simple_readpage
+c03b6337 r __kstrtab_simple_release_fs
+c03b6349 r __kstrtab_simple_rename
+c03b6357 r __kstrtab_simple_rmdir
+c03b6364 r __kstrtab_simple_statfs
+c03b6372 r __kstrtab_simple_sync_file
+c03b6383 r __kstrtab_simple_unlink
+c03b6391 r __kstrtab_simple_read_from_buffer
+c03b63a9 r __kstrtab_simple_transaction_get
+c03b63c0 r __kstrtab_simple_transaction_read
+c03b63d8 r __kstrtab_simple_transaction_release
+c03b63f3 r __kstrtab_simple_attr_open
+c03b6404 r __kstrtab_simple_attr_close
+c03b6416 r __kstrtab_simple_attr_read
+c03b6427 r __kstrtab_simple_attr_write
+c03b6439 r __kstrtab___mark_inode_dirty
+c03b644c r __kstrtab_write_inode_now
+c03b645c r __kstrtab_sync_inode
+c03b6467 r __kstrtab_generic_osync_inode
+c03b647b r __kstrtab_drop_pagecache_sb
+c03b64a0 r __kstrtab_generic_file_splice_read
+c03b64b9 r __kstrtab___splice_from_pipe
+c03b64e0 r __kstrtab_generic_file_splice_write_nolock
+c03b6501 r __kstrtab_generic_file_splice_write
+c03b651b r __kstrtab_generic_splice_sendpage
+c03b6533 r __kstrtab_do_sync_mapping_range
+c03b6549 r __kstrtab_fsstack_copy_inode_size
+c03b6561 r __kstrtab_fsstack_copy_attr_all
+c03b6577 r __kstrtab___lock_buffer
+c03b6585 r __kstrtab_sync_blockdev
+c03b6593 r __kstrtab_freeze_bdev
+c03b659f r __kstrtab_thaw_bdev
+c03b65a9 r __kstrtab_mark_buffer_async_write
+c03b65c1 r __kstrtab_sync_mapping_buffers
+c03b65d6 r __kstrtab_mark_buffer_dirty_inode
+c03b65ee r __kstrtab___set_page_dirty_buffers
+c03b6607 r __kstrtab_alloc_page_buffers
+c03b661a r __kstrtab___find_get_block
+c03b662b r __kstrtab___getblk
+c03b6634 r __kstrtab___breadahead
+c03b6641 r __kstrtab___bread
+c03b6649 r __kstrtab_set_bh_page
+c03b6655 r __kstrtab_block_invalidatepage
+c03b666a r __kstrtab_create_empty_buffers
+c03b667f r __kstrtab_unmap_underlying_metadata
+c03b6699 r __kstrtab_nobh_prepare_write
+c03b66ac r __kstrtab_nobh_commit_write
+c03b66be r __kstrtab_nobh_writepage
+c03b66cd r __kstrtab_nobh_truncate_page
+c03b66e0 r __kstrtab_try_to_free_buffers
+c03b66f4 r __kstrtab_alloc_buffer_head
+c03b6706 r __kstrtab_free_buffer_head
+c03b6717 r __kstrtab___bforget
+c03b6721 r __kstrtab___brelse
+c03b672a r __kstrtab___wait_on_buffer
+c03b673b r __kstrtab_block_commit_write
+c03b674e r __kstrtab_block_prepare_write
+c03b6762 r __kstrtab_block_read_full_page
+c03b6777 r __kstrtab_block_sync_page
+c03b6787 r __kstrtab_block_truncate_page
+c03b679b r __kstrtab_block_write_full_page
+c03b67b1 r __kstrtab_cont_prepare_write
+c03b67c4 r __kstrtab_end_buffer_read_sync
+c03b67d9 r __kstrtab_end_buffer_write_sync
+c03b67ef r __kstrtab_file_fsync
+c03b67fa r __kstrtab_fsync_bdev
+c03b6805 r __kstrtab_generic_block_bmap
+c03b6818 r __kstrtab_generic_commit_write
+c03b682d r __kstrtab_generic_cont_expand
+c03b6841 r __kstrtab_generic_cont_expand_simple
+c03b685c r __kstrtab_init_buffer
+c03b6868 r __kstrtab_invalidate_bdev
+c03b6878 r __kstrtab_ll_rw_block
+c03b6884 r __kstrtab_mark_buffer_dirty
+c03b6896 r __kstrtab_submit_bh
+c03b68a0 r __kstrtab_sync_dirty_buffer
+c03b68b2 r __kstrtab_unlock_buffer
+c03b68c0 r __kstrtab_zero_fill_bio
+c03b68ce r __kstrtab_bio_alloc
+c03b68d8 r __kstrtab_bio_put
+c03b68e0 r __kstrtab_bio_free
+c03b68e9 r __kstrtab_bio_endio
+c03b68f3 r __kstrtab_bio_init
+c03b68fc r __kstrtab___bio_clone
+c03b6908 r __kstrtab_bio_clone
+c03b6912 r __kstrtab_bio_phys_segments
+c03b6924 r __kstrtab_bio_hw_segments
+c03b6934 r __kstrtab_bio_add_page
+c03b6941 r __kstrtab_bio_add_pc_page
+c03b6951 r __kstrtab_bio_get_nr_vecs
+c03b6961 r __kstrtab_bio_map_user
+c03b696e r __kstrtab_bio_unmap_user
+c03b697d r __kstrtab_bio_map_kern
+c03b698a r __kstrtab_bio_pair_release
+c03b699b r __kstrtab_bio_split
+c03b69a5 r __kstrtab_bio_split_pool
+c03b69b4 r __kstrtab_bio_copy_user
+c03b69c2 r __kstrtab_bio_uncopy_user
+c03b69d2 r __kstrtab_bioset_create
+c03b69e0 r __kstrtab_bioset_free
+c03b69ec r __kstrtab_bio_alloc_bioset
+c03b69fd r __kstrtab_I_BDEV
+c03b6a04 r __kstrtab_set_blocksize
+c03b6a12 r __kstrtab_sb_set_blocksize
+c03b6a23 r __kstrtab_sb_min_blocksize
+c03b6a34 r __kstrtab_bdget
+c03b6a3a r __kstrtab_bdput
+c03b6a40 r __kstrtab_bd_claim
+c03b6a49 r __kstrtab_bd_release
+c03b6a54 r __kstrtab_bd_claim_by_disk
+c03b6a65 r __kstrtab_bd_release_from_disk
+c03b6a7a r __kstrtab_open_by_devnum
+c03b6a89 r __kstrtab_check_disk_change
+c03b6a9b r __kstrtab_bd_set_size
+c03b6aa7 r __kstrtab_blkdev_get
+c03b6ab2 r __kstrtab_blkdev_put
+c03b6abd r __kstrtab_ioctl_by_bdev
+c03b6acb r __kstrtab_open_bdev_excl
+c03b6ada r __kstrtab_close_bdev_excl
+c03b6aea r __kstrtab___invalidate_device
+c03b6afe r __kstrtab___blockdev_direct_IO
+c03b6b13 r __kstrtab_mpage_readpages
+c03b6b23 r __kstrtab_mpage_readpage
+c03b6b32 r __kstrtab_mpage_writepages
+c03b6b43 r __kstrtab_mpage_writepage
+c03b6b53 r __kstrtab_generic_file_revoke
+c03b6b80 r __kstrtab_get_inotify_watch
+c03b6b92 r __kstrtab_put_inotify_watch
+c03b6ba4 r __kstrtab_inotify_remove_watch_locked
+c03b6bc0 r __kstrtab_inotify_inode_queue_event
+c03b6be0 r __kstrtab_inotify_dentry_parent_queue_event
+c03b6c02 r __kstrtab_inotify_get_cookie
+c03b6c15 r __kstrtab_inotify_unmount_inodes
+c03b6c2c r __kstrtab_inotify_inode_is_dead
+c03b6c42 r __kstrtab_inotify_init
+c03b6c4f r __kstrtab_inotify_init_watch
+c03b6c62 r __kstrtab_inotify_destroy
+c03b6c72 r __kstrtab_inotify_find_watch
+c03b6c85 r __kstrtab_inotify_find_update_watch
+c03b6c9f r __kstrtab_inotify_add_watch
+c03b6cb1 r __kstrtab_inotify_rm_wd
+c03b6cbf r __kstrtab_inotify_rm_watch
+c03b6cd0 r __kstrtab_mb_cache_create
+c03b6ce0 r __kstrtab_mb_cache_shrink
+c03b6cf0 r __kstrtab_mb_cache_destroy
+c03b6d01 r __kstrtab_mb_cache_entry_alloc
+c03b6d16 r __kstrtab_mb_cache_entry_insert
+c03b6d2c r __kstrtab_mb_cache_entry_release
+c03b6d43 r __kstrtab_mb_cache_entry_free
+c03b6d57 r __kstrtab_mb_cache_entry_get
+c03b6d6a r __kstrtab_mb_cache_entry_find_first
+c03b6d84 r __kstrtab_mb_cache_entry_find_next
+c03b6d9d r __kstrtab_posix_acl_alloc
+c03b6dad r __kstrtab_posix_acl_clone
+c03b6dbd r __kstrtab_posix_acl_valid
+c03b6dcd r __kstrtab_posix_acl_equiv_mode
+c03b6de2 r __kstrtab_posix_acl_from_mode
+c03b6df6 r __kstrtab_posix_acl_create_masq
+c03b6e0c r __kstrtab_posix_acl_chmod_masq
+c03b6e21 r __kstrtab_posix_acl_permission
+c03b6e36 r __kstrtab_posix_acl_from_xattr
+c03b6e4b r __kstrtab_posix_acl_to_xattr
+c03b6e5e r __kstrtab_mark_info_dirty
+c03b6e6e r __kstrtab_register_quota_format
+c03b6e84 r __kstrtab_unregister_quota_format
+c03b6e9c r __kstrtab_dqstats
+c03b6ea4 r __kstrtab_dq_data_lock
+c03b6eb1 r __kstrtab_vfs_quota_on
+c03b6ebe r __kstrtab_vfs_quota_on_mount
+c03b6ed1 r __kstrtab_vfs_quota_off
+c03b6edf r __kstrtab_vfs_quota_sync
+c03b6eee r __kstrtab_vfs_get_dqinfo
+c03b6efd r __kstrtab_vfs_set_dqinfo
+c03b6f0c r __kstrtab_vfs_get_dqblk
+c03b6f1a r __kstrtab_vfs_set_dqblk
+c03b6f28 r __kstrtab_dquot_commit
+c03b6f35 r __kstrtab_dquot_commit_info
+c03b6f47 r __kstrtab_dquot_acquire
+c03b6f55 r __kstrtab_dquot_release
+c03b6f63 r __kstrtab_dquot_mark_dquot_dirty
+c03b6f7a r __kstrtab_dquot_initialize
+c03b6f8b r __kstrtab_dquot_drop
+c03b6f96 r __kstrtab_dquot_alloc_space
+c03b6fa8 r __kstrtab_dquot_alloc_inode
+c03b6fba r __kstrtab_dquot_free_space
+c03b6fcb r __kstrtab_dquot_free_inode
+c03b6fdc r __kstrtab_dquot_transfer
+c03b6feb r __kstrtab___inode_dir_notify
+c03b6ffe r __kstrtab_dnotify_parent
+c03b700d r __kstrtab_proc_symlink
+c03b701a r __kstrtab_proc_mkdir
+c03b7025 r __kstrtab_create_proc_entry
+c03b7037 r __kstrtab_remove_proc_entry
+c03b7049 r __kstrtab_proc_root
+c03b7053 r __kstrtab_proc_root_fs
+c03b7060 r __kstrtab_proc_bus
+c03b7069 r __kstrtab_proc_root_driver
+c03b707a r __kstrtab_maps_protect
+c03b7087 r __kstrtab_bdevname
+c03b7090 r __kstrtab___bdevname
+c03b709b r __kstrtab_read_dev_sector
+c03b70ab r __kstrtab_sysfs_notify
+c03b70b8 r __kstrtab_sysfs_add_file_to_group
+c03b70d0 r __kstrtab_sysfs_chmod_file
+c03b70e1 r __kstrtab_sysfs_remove_file_from_group
+c03b70fe r __kstrtab_sysfs_schedule_callback
+c03b7116 r __kstrtab_sysfs_create_file
+c03b7128 r __kstrtab_sysfs_remove_file
+c03b713a r __kstrtab_sysfs_update_file
+c03b714c r __kstrtab_sysfs_create_link
+c03b715e r __kstrtab_sysfs_remove_link
+c03b7170 r __kstrtab_sysfs_create_bin_file
+c03b7186 r __kstrtab_sysfs_remove_bin_file
+c03b719c r __kstrtab_sysfs_create_group
+c03b71af r __kstrtab_sysfs_remove_group
+c03b71c2 r __kstrtab_dcookie_register
+c03b71d3 r __kstrtab_dcookie_unregister
+c03b71e6 r __kstrtab_get_dcookie
+c03b7200 r __kstrtab_journal_start
+c03b720e r __kstrtab_journal_restart
+c03b721e r __kstrtab_journal_extend
+c03b722d r __kstrtab_journal_stop
+c03b723a r __kstrtab_journal_lock_updates
+c03b724f r __kstrtab_journal_unlock_updates
+c03b7266 r __kstrtab_journal_get_write_access
+c03b727f r __kstrtab_journal_get_create_access
+c03b7299 r __kstrtab_journal_get_undo_access
+c03b72b1 r __kstrtab_journal_dirty_data
+c03b72c4 r __kstrtab_journal_dirty_metadata
+c03b72db r __kstrtab_journal_release_buffer
+c03b72f2 r __kstrtab_journal_forget
+c03b7301 r __kstrtab_journal_flush
+c03b730f r __kstrtab_journal_revoke
+c03b731e r __kstrtab_journal_init_dev
+c03b732f r __kstrtab_journal_init_inode
+c03b7342 r __kstrtab_journal_update_format
+c03b7358 r __kstrtab_journal_check_used_features
+c03b7380 r __kstrtab_journal_check_available_features
+c03b73a1 r __kstrtab_journal_set_features
+c03b73b6 r __kstrtab_journal_create
+c03b73c5 r __kstrtab_journal_load
+c03b73d2 r __kstrtab_journal_destroy
+c03b73e2 r __kstrtab_journal_update_superblock
+c03b73fc r __kstrtab_journal_abort
+c03b740a r __kstrtab_journal_errno
+c03b7418 r __kstrtab_journal_ack_err
+c03b7428 r __kstrtab_journal_clear_err
+c03b743a r __kstrtab_log_wait_commit
+c03b744a r __kstrtab_journal_start_commit
+c03b745f r __kstrtab_journal_force_commit_nested
+c03b747b r __kstrtab_journal_wipe
+c03b7488 r __kstrtab_journal_blocks_per_page
+c03b74a0 r __kstrtab_journal_invalidatepage
+c03b74b7 r __kstrtab_journal_try_to_free_buffers
+c03b74d3 r __kstrtab_journal_force_commit
+c03b74e8 r __kstrtab_register_nls
+c03b74f5 r __kstrtab_unregister_nls
+c03b7504 r __kstrtab_unload_nls
+c03b750f r __kstrtab_load_nls
+c03b7518 r __kstrtab_load_nls_default
+c03b7529 r __kstrtab_utf8_mbtowc
+c03b7535 r __kstrtab_utf8_mbstowcs
+c03b7543 r __kstrtab_utf8_wctomb
+c03b754f r __kstrtab_utf8_wcstombs
+c03b755d r __kstrtab_debugfs_create_file
+c03b7571 r __kstrtab_debugfs_create_dir
+c03b7584 r __kstrtab_debugfs_create_symlink
+c03b759b r __kstrtab_debugfs_remove
+c03b75aa r __kstrtab_debugfs_create_u8
+c03b75bc r __kstrtab_debugfs_create_u16
+c03b75cf r __kstrtab_debugfs_create_u32
+c03b75e2 r __kstrtab_debugfs_create_u64
+c03b75f5 r __kstrtab_debugfs_create_bool
+c03b7609 r __kstrtab_debugfs_create_blob
+c03b761d r __kstrtab_cap_netlink_send
+c03b762e r __kstrtab_cap_netlink_recv
+c03b763f r __kstrtab_cap_capable
+c03b764b r __kstrtab_cap_settime
+c03b7657 r __kstrtab_cap_ptrace
+c03b7662 r __kstrtab_cap_capget
+c03b766d r __kstrtab_cap_capset_check
+c03b767e r __kstrtab_cap_capset_set
+c03b768d r __kstrtab_cap_bprm_set_security
+c03b76a3 r __kstrtab_cap_bprm_apply_creds
+c03b76b8 r __kstrtab_cap_bprm_secureexec
+c03b76cc r __kstrtab_cap_inode_setxattr
+c03b76df r __kstrtab_cap_inode_removexattr
+c03b76f5 r __kstrtab_cap_task_post_setuid
+c03b770a r __kstrtab_cap_task_reparent_to_init
+c03b7724 r __kstrtab_cap_syslog
+c03b772f r __kstrtab_cap_vm_enough_memory
+c03b7744 r __kstrtab_crypto_alg_list
+c03b7754 r __kstrtab_crypto_alg_sem
+c03b7763 r __kstrtab_crypto_chain
+c03b7770 r __kstrtab_crypto_mod_get
+c03b777f r __kstrtab_crypto_mod_put
+c03b778e r __kstrtab___crypto_alg_lookup
+c03b77a2 r __kstrtab_crypto_alg_mod_lookup
+c03b77b8 r __kstrtab_crypto_shoot_alg
+c03b77c9 r __kstrtab___crypto_alloc_tfm
+c03b77dc r __kstrtab_crypto_alloc_base
+c03b77ee r __kstrtab_crypto_free_tfm
+c03b77fe r __kstrtab_crypto_has_alg
+c03b780d r __kstrtab_crypto_km_types
+c03b781d r __kstrtab_scatterwalk_start
+c03b782f r __kstrtab_scatterwalk_map
+c03b783f r __kstrtab_scatterwalk_done
+c03b7850 r __kstrtab_scatterwalk_copychunks
+c03b7867 r __kstrtab_elv_rq_merge_ok
+c03b7877 r __kstrtab_elevator_init
+c03b7885 r __kstrtab_elevator_exit
+c03b7893 r __kstrtab_elv_rb_add
+c03b789e r __kstrtab_elv_rb_del
+c03b78a9 r __kstrtab_elv_rb_find
+c03b78b5 r __kstrtab_elv_dispatch_sort
+c03b78c7 r __kstrtab_elv_dispatch_add_tail
+c03b78dd r __kstrtab___elv_add_request
+c03b78ef r __kstrtab_elv_add_request
+c03b78ff r __kstrtab_elv_next_request
+c03b7910 r __kstrtab_elv_dequeue_request
+c03b7924 r __kstrtab_elv_queue_empty
+c03b7934 r __kstrtab_elv_register
+c03b7941 r __kstrtab_elv_unregister
+c03b7950 r __kstrtab_elv_rb_former_request
+c03b7966 r __kstrtab_elv_rb_latter_request
+c03b797c r __kstrtab_blk_max_low_pfn
+c03b798c r __kstrtab_blk_max_pfn
+c03b7998 r __kstrtab_blk_get_backing_dev_info
+c03b79b1 r __kstrtab_blk_queue_prep_rq
+c03b79c3 r __kstrtab_blk_queue_merge_bvec
+c03b79d8 r __kstrtab_blk_queue_softirq_done
+c03b79ef r __kstrtab_blk_queue_make_request
+c03b7a06 r __kstrtab_blk_queue_ordered
+c03b7a18 r __kstrtab_blk_queue_issue_flush_fn
+c03b7a31 r __kstrtab_blk_queue_bounce_limit
+c03b7a48 r __kstrtab_blk_queue_max_sectors
+c03b7a5e r __kstrtab_blk_queue_max_phys_segments
+c03b7a7a r __kstrtab_blk_queue_max_hw_segments
+c03b7a94 r __kstrtab_blk_queue_max_segment_size
+c03b7aaf r __kstrtab_blk_queue_hardsect_size
+c03b7ac7 r __kstrtab_blk_queue_stack_limits
+c03b7ade r __kstrtab_blk_queue_segment_boundary
+c03b7af9 r __kstrtab_blk_queue_dma_alignment
+c03b7b11 r __kstrtab_blk_queue_find_tag
+c03b7b24 r __kstrtab_blk_free_tags
+c03b7b32 r __kstrtab_blk_queue_free_tags
+c03b7b46 r __kstrtab_blk_init_tags
+c03b7b54 r __kstrtab_blk_queue_init_tags
+c03b7b68 r __kstrtab_blk_queue_resize_tags
+c03b7b7e r __kstrtab_blk_queue_end_tag
+c03b7b90 r __kstrtab_blk_queue_start_tag
+c03b7ba4 r __kstrtab_blk_queue_invalidate_tags
+c03b7bbe r __kstrtab_blk_dump_rq_flags
+c03b7bd0 r __kstrtab_blk_recount_segments
+c03b7be5 r __kstrtab_blk_rq_map_sg
+c03b7bf3 r __kstrtab_ll_back_merge_fn
+c03b7c04 r __kstrtab_blk_plug_device
+c03b7c14 r __kstrtab_blk_remove_plug
+c03b7c24 r __kstrtab___generic_unplug_device
+c03b7c3c r __kstrtab_generic_unplug_device
+c03b7c52 r __kstrtab_blk_start_queue
+c03b7c62 r __kstrtab_blk_stop_queue
+c03b7c71 r __kstrtab_blk_sync_queue
+c03b7c80 r __kstrtab_blk_run_queue
+c03b7c8e r __kstrtab_blk_put_queue
+c03b7c9c r __kstrtab_blk_cleanup_queue
+c03b7cae r __kstrtab_blk_alloc_queue
+c03b7cbe r __kstrtab_blk_alloc_queue_node
+c03b7cd3 r __kstrtab_blk_init_queue
+c03b7ce2 r __kstrtab_blk_init_queue_node
+c03b7cf6 r __kstrtab_blk_get_queue
+c03b7d04 r __kstrtab_blk_get_request
+c03b7d14 r __kstrtab_blk_start_queueing
+c03b7d27 r __kstrtab_blk_requeue_request
+c03b7d3b r __kstrtab_blk_insert_request
+c03b7d4e r __kstrtab_blk_rq_map_user
+c03b7d5e r __kstrtab_blk_rq_map_user_iov
+c03b7d72 r __kstrtab_blk_rq_unmap_user
+c03b7d84 r __kstrtab_blk_rq_map_kern
+c03b7d94 r __kstrtab_blk_execute_rq_nowait
+c03b7daa r __kstrtab_blk_execute_rq
+c03b7db9 r __kstrtab_blkdev_issue_flush
+c03b7dcc r __kstrtab_disk_round_stats
+c03b7ddd r __kstrtab___blk_put_request
+c03b7def r __kstrtab_blk_put_request
+c03b7dff r __kstrtab_blk_end_sync_rq
+c03b7e0f r __kstrtab_generic_make_request
+c03b7e24 r __kstrtab_submit_bio
+c03b7e2f r __kstrtab_end_that_request_first
+c03b7e46 r __kstrtab_end_that_request_chunk
+c03b7e5d r __kstrtab_blk_complete_request
+c03b7e72 r __kstrtab_end_that_request_last
+c03b7e88 r __kstrtab_end_request
+c03b7e94 r __kstrtab_blk_rq_bio_prep
+c03b7ea4 r __kstrtab_kblockd_schedule_work
+c03b7eba r __kstrtab_kblockd_flush_work
+c03b7ecd r __kstrtab_put_io_context
+c03b7edc r __kstrtab_get_io_context
+c03b7eeb r __kstrtab_copy_io_context
+c03b7efb r __kstrtab_swap_io_context
+c03b7f0b r __kstrtab_blkdev_driver_ioctl
+c03b7f1f r __kstrtab_blkdev_ioctl
+c03b7f2c r __kstrtab_register_blkdev
+c03b7f3c r __kstrtab_unregister_blkdev
+c03b7f4e r __kstrtab_blk_register_region
+c03b7f62 r __kstrtab_blk_unregister_region
+c03b7f78 r __kstrtab_add_disk
+c03b7f81 r __kstrtab_del_gendisk
+c03b7f8d r __kstrtab_genhd_media_change_notify
+c03b7fa7 r __kstrtab_alloc_disk
+c03b7fb2 r __kstrtab_alloc_disk_node
+c03b7fc2 r __kstrtab_get_disk
+c03b7fcb r __kstrtab_put_disk
+c03b7fd4 r __kstrtab_set_device_ro
+c03b7fe2 r __kstrtab_set_disk_ro
+c03b7fee r __kstrtab_bdev_read_only
+c03b7ffd r __kstrtab_invalidate_partition
+c03b8012 r __kstrtab_scsi_command_size
+c03b8024 r __kstrtab_sg_scsi_ioctl
+c03b8032 r __kstrtab_scsi_cmd_ioctl
+c03b8041 r __kstrtab___blk_add_trace
+c03b8051 r __kstrtab_argv_free
+c03b805b r __kstrtab_argv_split
+c03b8066 r __kstrtab___bitmap_empty
+c03b8075 r __kstrtab___bitmap_full
+c03b8083 r __kstrtab___bitmap_equal
+c03b8092 r __kstrtab___bitmap_complement
+c03b80a6 r __kstrtab___bitmap_shift_right
+c03b80bb r __kstrtab___bitmap_shift_left
+c03b80cf r __kstrtab___bitmap_and
+c03b80dc r __kstrtab___bitmap_or
+c03b80e8 r __kstrtab___bitmap_xor
+c03b80f5 r __kstrtab___bitmap_andnot
+c03b8105 r __kstrtab___bitmap_intersects
+c03b8119 r __kstrtab___bitmap_subset
+c03b8129 r __kstrtab___bitmap_weight
+c03b8139 r __kstrtab_bitmap_scnprintf
+c03b814a r __kstrtab___bitmap_parse
+c03b8159 r __kstrtab_bitmap_parse_user
+c03b816b r __kstrtab_bitmap_scnlistprintf
+c03b8180 r __kstrtab_bitmap_parselist
+c03b8191 r __kstrtab_bitmap_remap
+c03b819e r __kstrtab_bitmap_bitremap
+c03b81ae r __kstrtab_bitmap_find_free_region
+c03b81c6 r __kstrtab_bitmap_release_region
+c03b81dc r __kstrtab_bitmap_allocate_region
+c03b81f3 r __kstrtab_memparse
+c03b81fc r __kstrtab_get_option
+c03b8207 r __kstrtab_get_options
+c03b8213 r __kstrtab___first_cpu
+c03b821f r __kstrtab___next_cpu
+c03b822a r __kstrtab___any_online_cpu
+c03b823b r __kstrtab__ctype
+c03b8242 r __kstrtab__atomic_dec_and_lock
+c03b8257 r __kstrtab_idr_pre_get
+c03b8263 r __kstrtab_idr_get_new_above
+c03b8275 r __kstrtab_idr_get_new
+c03b8281 r __kstrtab_idr_remove
+c03b828c r __kstrtab_idr_destroy
+c03b8298 r __kstrtab_idr_find
+c03b82a1 r __kstrtab_idr_replace
+c03b82ad r __kstrtab_idr_init
+c03b82b6 r __kstrtab_ida_pre_get
+c03b82c2 r __kstrtab_ida_get_new_above
+c03b82d4 r __kstrtab_ida_get_new
+c03b82e0 r __kstrtab_ida_remove
+c03b82eb r __kstrtab_ida_destroy
+c03b82f7 r __kstrtab_ida_init
+c03b8300 r __kstrtab_int_sqrt
+c03b8309 r __kstrtab_kobject_get_path
+c03b831a r __kstrtab_kobject_set_name
+c03b832b r __kstrtab_kobject_init
+c03b8338 r __kstrtab_kobject_register
+c03b8349 r __kstrtab_kobject_unregister
+c03b835c r __kstrtab_kobject_get
+c03b8368 r __kstrtab_kobject_put
+c03b8374 r __kstrtab_kobject_add
+c03b8380 r __kstrtab_kobject_del
+c03b838c r __kstrtab_kset_register
+c03b839a r __kstrtab_kset_unregister
+c03b83aa r __kstrtab_subsystem_register
+c03b83bd r __kstrtab_subsystem_unregister
+c03b83d2 r __kstrtab_subsys_create_file
+c03b83e5 r __kstrtab_kobject_uevent_env
+c03b83f8 r __kstrtab_kobject_uevent
+c03b8407 r __kstrtab_add_uevent_var
+c03b8416 r __kstrtab_kref_init
+c03b8420 r __kstrtab_kref_get
+c03b8429 r __kstrtab_kref_put
+c03b8432 r __kstrtab_radix_tree_insert
+c03b8444 r __kstrtab_radix_tree_lookup_slot
+c03b845b r __kstrtab_radix_tree_lookup
+c03b846d r __kstrtab_radix_tree_tag_set
+c03b8480 r __kstrtab_radix_tree_tag_clear
+c03b8495 r __kstrtab_radix_tree_gang_lookup
+c03b84ac r __kstrtab_radix_tree_gang_lookup_tag
+c03b84c7 r __kstrtab_radix_tree_delete
+c03b84d9 r __kstrtab_radix_tree_tagged
+c03b84eb r __kstrtab_rb_insert_color
+c03b84fb r __kstrtab_rb_erase
+c03b8504 r __kstrtab_rb_first
+c03b850d r __kstrtab_rb_last
+c03b8515 r __kstrtab_rb_next
+c03b851d r __kstrtab_rb_prev
+c03b8525 r __kstrtab_rb_replace_node
+c03b8535 r __kstrtab___init_rwsem
+c03b8542 r __kstrtab_rwsem_down_read_failed
+c03b8559 r __kstrtab_rwsem_down_write_failed
+c03b8571 r __kstrtab_rwsem_wake
+c03b857c r __kstrtab_rwsem_downgrade_wake
+c03b8591 r __kstrtab_strnicmp
+c03b859a r __kstrtab_strcasecmp
+c03b85a5 r __kstrtab_strncasecmp
+c03b85b1 r __kstrtab_strlcpy
+c03b85b9 r __kstrtab_strlcat
+c03b85c1 r __kstrtab_strnchr
+c03b85c9 r __kstrtab_strstrip
+c03b85d2 r __kstrtab_strspn
+c03b85d9 r __kstrtab_strcspn
+c03b85e1 r __kstrtab_strpbrk
+c03b85e9 r __kstrtab_strsep
+c03b85f0 r __kstrtab_memcmp
+c03b85f7 r __kstrtab_simple_strtoul
+c03b8606 r __kstrtab_simple_strtol
+c03b8614 r __kstrtab_simple_strtoull
+c03b8624 r __kstrtab_vsnprintf
+c03b862e r __kstrtab_vscnprintf
+c03b8639 r __kstrtab_snprintf
+c03b8642 r __kstrtab_scnprintf
+c03b864c r __kstrtab_vsprintf
+c03b8655 r __kstrtab_sprintf
+c03b865d r __kstrtab_vsscanf
+c03b8665 r __kstrtab_sscanf
+c03b866c r __kstrtab_kvasprintf
+c03b8677 r __kstrtab_kasprintf
+c03b8681 r __kstrtab_find_next_bit
+c03b868f r __kstrtab_find_next_zero_bit
+c03b86a2 r __kstrtab___delay
+c03b86aa r __kstrtab___const_udelay
+c03b86b9 r __kstrtab___udelay
+c03b86c2 r __kstrtab___ndelay
+c03b86cb r __kstrtab_memcpy
+c03b86d2 r __kstrtab_memset
+c03b86d9 r __kstrtab_memmove
+c03b86e1 r __kstrtab___strncpy_from_user
+c03b86f5 r __kstrtab_strncpy_from_user
+c03b8707 r __kstrtab_clear_user
+c03b8712 r __kstrtab___clear_user
+c03b871f r __kstrtab_strnlen_user
+c03b872c r __kstrtab___copy_to_user_ll
+c03b873e r __kstrtab___copy_from_user_ll
+c03b8752 r __kstrtab___copy_from_user_ll_nozero
+c03b876d r __kstrtab_copy_to_user
+c03b877a r __kstrtab_copy_from_user
+c03b8789 r __kstrtab___div64_32
+c03b8794 r __kstrtab_div64_64
+c03b879d r __kstrtab_sort
+c03b87a2 r __kstrtab_match_token
+c03b87ae r __kstrtab_match_int
+c03b87b8 r __kstrtab_match_octal
+c03b87c4 r __kstrtab_match_hex
+c03b87ce r __kstrtab_match_strcpy
+c03b87db r __kstrtab_match_strdup
+c03b87e8 r __kstrtab_half_md4_transform
+c03b87fb r __kstrtab_random32
+c03b8804 r __kstrtab_srandom32
+c03b880e r __kstrtab_hex_dump_to_buffer
+c03b8821 r __kstrtab_print_hex_dump
+c03b8830 r __kstrtab_print_hex_dump_bytes
+c03b8845 r __kstrtab_ioread8
+c03b884d r __kstrtab_ioread16
+c03b8856 r __kstrtab_ioread16be
+c03b8861 r __kstrtab_ioread32
+c03b886a r __kstrtab_ioread32be
+c03b8875 r __kstrtab_iowrite8
+c03b887e r __kstrtab_iowrite16
+c03b8888 r __kstrtab_iowrite16be
+c03b8894 r __kstrtab_iowrite32
+c03b889e r __kstrtab_iowrite32be
+c03b88aa r __kstrtab_ioread8_rep
+c03b88b6 r __kstrtab_ioread16_rep
+c03b88c3 r __kstrtab_ioread32_rep
+c03b88d0 r __kstrtab_iowrite8_rep
+c03b88dd r __kstrtab_iowrite16_rep
+c03b88eb r __kstrtab_iowrite32_rep
+c03b88f9 r __kstrtab_ioport_map
+c03b8904 r __kstrtab_ioport_unmap
+c03b8911 r __kstrtab_pci_iomap
+c03b891b r __kstrtab_pci_iounmap
+c03b8927 r __kstrtab___iowrite32_copy
+c03b8938 r __kstrtab___iowrite64_copy
+c03b8949 r __kstrtab_devm_ioremap
+c03b8956 r __kstrtab_devm_ioremap_nocache
+c03b896b r __kstrtab_devm_iounmap
+c03b8978 r __kstrtab_devm_ioport_map
+c03b8988 r __kstrtab_devm_ioport_unmap
+c03b899a r __kstrtab_pcim_iomap_table
+c03b89ab r __kstrtab_pcim_iomap
+c03b89b6 r __kstrtab_pcim_iounmap
+c03b89c3 r __kstrtab_pcim_iomap_regions
+c03b89d6 r __kstrtab_pcim_iounmap_regions
+c03b89eb r __kstrtab___spin_lock_init
+c03b89fc r __kstrtab___rwlock_init
+c03b8a0a r __kstrtab_hweight32
+c03b8a14 r __kstrtab_hweight16
+c03b8a1e r __kstrtab_hweight8
+c03b8a27 r __kstrtab_hweight64
+c03b8a31 r __kstrtab_lock_kernel
+c03b8a3d r __kstrtab_unlock_kernel
+c03b8a4b r __kstrtab___list_add
+c03b8a56 r __kstrtab_list_add
+c03b8a5f r __kstrtab_list_del
+c03b8a68 r __kstrtab_byte_rev_table
+c03b8a77 r __kstrtab_bitrev32
+c03b8a80 r __kstrtab_crc32_le
+c03b8a89 r __kstrtab_crc32_be
+c03b8a92 r __kstrtab_zlib_inflate_workspacesize
+c03b8aad r __kstrtab_zlib_inflate
+c03b8aba r __kstrtab_zlib_inflateInit2
+c03b8acc r __kstrtab_zlib_inflateEnd
+c03b8adc r __kstrtab_zlib_inflateReset
+c03b8aee r __kstrtab_zlib_inflateIncomp
+c03b8b01 r __kstrtab_textsearch_register
+c03b8b15 r __kstrtab_textsearch_unregister
+c03b8b2b r __kstrtab_textsearch_prepare
+c03b8b3e r __kstrtab_textsearch_find_continuous
+c03b8b59 r __kstrtab_textsearch_destroy
+c03b8b6c r __kstrtab_percpu_counter_mod
+c03b8b7f r __kstrtab_percpu_counter_sum
+c03b8b92 r __kstrtab_rdmsr_on_cpu
+c03b8b9f r __kstrtab_wrmsr_on_cpu
+c03b8bac r __kstrtab_rdmsr_safe_on_cpu
+c03b8bbe r __kstrtab_wrmsr_safe_on_cpu
+c03b8be0 r __kstrtab_pci_bus_read_config_byte
+c03b8bf9 r __kstrtab_pci_bus_read_config_word
+c03b8c12 r __kstrtab_pci_bus_read_config_dword
+c03b8c2c r __kstrtab_pci_bus_write_config_byte
+c03b8c46 r __kstrtab_pci_bus_write_config_word
+c03b8c60 r __kstrtab_pci_bus_write_config_dword
+c03b8c7b r __kstrtab_pci_block_user_cfg_access
+c03b8c95 r __kstrtab_pci_unblock_user_cfg_access
+c03b8cb1 r __kstrtab_pci_walk_bus
+c03b8cbe r __kstrtab_pci_bus_alloc_resource
+c03b8cd5 r __kstrtab_pci_bus_add_device
+c03b8ce8 r __kstrtab_pci_bus_add_devices
+c03b8cfc r __kstrtab_pci_enable_bridges
+c03b8d0f r __kstrtab_pci_root_buses
+c03b8d1e r __kstrtab_alloc_pci_dev
+c03b8d2c r __kstrtab_pci_create_bus
+c03b8d3b r __kstrtab_pci_scan_bus_parented
+c03b8d51 r __kstrtab_pci_add_new_bus
+c03b8d61 r __kstrtab_pci_do_scan_bus
+c03b8d71 r __kstrtab_pci_scan_slot
+c03b8d7f r __kstrtab_pci_scan_bridge
+c03b8d8f r __kstrtab_pci_scan_single_device
+c03b8da6 r __kstrtab_pci_scan_child_bus
+c03b8db9 r __kstrtab_pci_remove_bus
+c03b8dc8 r __kstrtab_pci_remove_bus_device
+c03b8dde r __kstrtab_pci_remove_behind_bridge
+c03b8df7 r __kstrtab_pci_stop_bus_device
+c03b8e0b r __kstrtab_pci_bus_max_busnr
+c03b8e1d r __kstrtab_pci_find_next_capability
+c03b8e36 r __kstrtab_pci_find_ext_capability
+c03b8e4e r __kstrtab_pci_find_next_ht_capability
+c03b8e6a r __kstrtab_pci_find_ht_capability
+c03b8e81 r __kstrtab_pci_choose_state
+c03b8e92 r __kstrtab_pci_restore_bars
+c03b8ea3 r __kstrtab_pci_enable_device_bars
+c03b8eba r __kstrtab_pci_enable_device
+c03b8ecc r __kstrtab_pcim_enable_device
+c03b8edf r __kstrtab_pcim_pin_device
+c03b8eef r __kstrtab_pci_disable_device
+c03b8f02 r __kstrtab_pci_find_capability
+c03b8f16 r __kstrtab_pci_bus_find_capability
+c03b8f2e r __kstrtab_pci_release_regions
+c03b8f42 r __kstrtab_pci_request_regions
+c03b8f56 r __kstrtab_pci_release_region
+c03b8f69 r __kstrtab_pci_request_region
+c03b8f7c r __kstrtab_pci_release_selected_regions
+c03b8f99 r __kstrtab_pci_request_selected_regions
+c03b8fb6 r __kstrtab_pci_set_master
+c03b8fc5 r __kstrtab_pci_set_mwi
+c03b8fd1 r __kstrtab_pci_clear_mwi
+c03b8fdf r __kstrtab_pci_intx
+c03b8fe8 r __kstrtab_pci_set_dma_mask
+c03b8ff9 r __kstrtab_pci_set_consistent_dma_mask
+c03b9015 r __kstrtab_pci_assign_resource
+c03b9029 r __kstrtab_pci_find_parent_resource
+c03b9042 r __kstrtab_pci_select_bars
+c03b9052 r __kstrtab_pci_set_power_state
+c03b9066 r __kstrtab_pci_save_state
+c03b9075 r __kstrtab_pci_restore_state
+c03b9087 r __kstrtab_pci_enable_wake
+c03b9097 r __kstrtab_pci_set_pcie_reset_state
+c03b90b0 r __kstrtab_isa_dma_bridge_buggy
+c03b90c5 r __kstrtab_pci_pci_problems
+c03b90d6 r __kstrtab_pcie_mch_quirk
+c03b90e5 r __kstrtab_pci_fixup_device
+c03b90f6 r __kstrtab_pci_match_id
+c03b9103 r __kstrtab_pci_match_device
+c03b9114 r __kstrtab___pci_register_driver
+c03b912a r __kstrtab_pci_unregister_driver
+c03b9140 r __kstrtab_pci_dev_driver
+c03b914f r __kstrtab_pci_bus_type
+c03b915c r __kstrtab_pci_dev_get
+c03b9168 r __kstrtab_pci_dev_put
+c03b9174 r __kstrtab_pci_dev_present
+c03b9184 r __kstrtab_pci_find_present
+c03b9195 r __kstrtab_pci_find_device
+c03b91a5 r __kstrtab_pci_find_slot
+c03b91b3 r __kstrtab_pci_find_bus
+c03b91c0 r __kstrtab_pci_find_next_bus
+c03b91d2 r __kstrtab_pci_get_device
+c03b91e1 r __kstrtab_pci_get_device_reverse
+c03b91f8 r __kstrtab_pci_get_subsys
+c03b9207 r __kstrtab_pci_get_slot
+c03b9214 r __kstrtab_pci_get_bus_and_slot
+c03b9229 r __kstrtab_pci_get_class
+c03b9237 r __kstrtab_pci_map_rom
+c03b9243 r __kstrtab_pci_map_rom_copy
+c03b9254 r __kstrtab_pci_unmap_rom
+c03b9262 r __kstrtab_pci_remove_rom
+c03b9271 r __kstrtab_pci_claim_resource
+c03b9284 r __kstrtab_pci_proc_attach_device
+c03b929b r __kstrtab_pci_proc_detach_bus
+c03b92c0 r __kstrtab_pcie_port_service_register
+c03b92db r __kstrtab_pcie_port_service_unregister
+c03b92f8 r __kstrtab_pcie_port_bus_type
+c03b9320 r __kstrtab_pci_find_aer_capability
+c03b9340 r __kstrtab_pci_enable_pcie_error_reporting
+c03b9360 r __kstrtab_pci_disable_pcie_error_reporting
+c03b93a0 r __kstrtab_pci_cleanup_aer_uncorrect_error_status
+c03b93c7 r __kstrtab_pci_enable_msi
+c03b93d6 r __kstrtab_pci_disable_msi
+c03b93e6 r __kstrtab_pci_enable_msix
+c03b93f6 r __kstrtab_pci_disable_msix
+c03b9407 r __kstrtab___ht_create_irq
+c03b9417 r __kstrtab_ht_create_irq
+c03b9425 r __kstrtab_ht_destroy_irq
+c03b9434 r __kstrtab_pci_setup_cardbus
+c03b9446 r __kstrtab_pci_bus_size_bridges
+c03b945b r __kstrtab_pci_bus_assign_resources
+c03b9474 r __kstrtab_pci_osc_support_set
+c03b9488 r __kstrtab_pci_osc_control_set
+c03b949c r __kstrtab_fb_register_client
+c03b94af r __kstrtab_fb_unregister_client
+c03b94c4 r __kstrtab_fb_notifier_call_chain
+c03b94e0 r __kstrtab_acpi_os_printf
+c03b94ef r __kstrtab_acpi_os_map_memory
+c03b9502 r __kstrtab_acpi_os_unmap_memory
+c03b9517 r __kstrtab_acpi_os_sleep
+c03b9525 r __kstrtab_acpi_os_stall
+c03b9533 r __kstrtab_acpi_os_read_port
+c03b9545 r __kstrtab_acpi_os_write_port
+c03b9558 r __kstrtab_acpi_os_read_pci_configuration
+c03b9577 r __kstrtab_acpi_os_execute
+c03b9587 r __kstrtab_acpi_os_wait_events_complete
+c03b95a4 r __kstrtab_acpi_os_create_semaphore
+c03b95bd r __kstrtab_acpi_os_delete_semaphore
+c03b95d6 r __kstrtab_acpi_os_wait_semaphore
+c03b95ed r __kstrtab_acpi_os_signal_semaphore
+c03b9606 r __kstrtab_acpi_os_signal
+c03b9615 r __kstrtab_max_cstate
+c03b9620 r __kstrtab_acpi_do_set_cstate_limit
+c03b9639 r __kstrtab_acpi_set_cstate_limit
+c03b964f r __kstrtab_acpi_extract_package
+c03b9664 r __kstrtab_acpi_evaluate_integer
+c03b967a r __kstrtab_acpi_evaluate_reference
+c03b96a0 r __kstrtab_acpi_enable
+c03b96ac r __kstrtab_acpi_disable
+c03b96b9 r __kstrtab_acpi_enable_event
+c03b96cb r __kstrtab_acpi_set_gpe_type
+c03b96dd r __kstrtab_acpi_enable_gpe
+c03b96ed r __kstrtab_acpi_disable_gpe
+c03b96fe r __kstrtab_acpi_disable_event
+c03b9711 r __kstrtab_acpi_clear_event
+c03b9722 r __kstrtab_acpi_clear_gpe
+c03b9731 r __kstrtab_acpi_install_gpe_block
+c03b9748 r __kstrtab_acpi_remove_gpe_block
+c03b9760 r __kstrtab_acpi_install_fixed_event_handler
+c03b97a0 r __kstrtab_acpi_remove_fixed_event_handler
+c03b97c0 r __kstrtab_acpi_install_notify_handler
+c03b97dc r __kstrtab_acpi_remove_notify_handler
+c03b97f7 r __kstrtab_acpi_install_gpe_handler
+c03b9810 r __kstrtab_acpi_remove_gpe_handler
+c03b9828 r __kstrtab_acpi_acquire_global_lock
+c03b9841 r __kstrtab_acpi_release_global_lock
+c03b9860 r __kstrtab_acpi_install_address_space_handler
+c03b98a0 r __kstrtab_acpi_remove_address_space_handler
+c03b98e0 r __kstrtab_acpi_get_sleep_type_data
+c03b98f9 r __kstrtab_acpi_get_register
+c03b990b r __kstrtab_acpi_set_register
+c03b9920 r __kstrtab_acpi_set_firmware_waking_vector
+c03b9940 r __kstrtab_acpi_enter_sleep_state_prep
+c03b995c r __kstrtab_acpi_enter_sleep_state
+c03b9973 r __kstrtab_acpi_enter_sleep_state_s4bios
+c03b9991 r __kstrtab_acpi_leave_sleep_state
+c03b99a8 r __kstrtab_acpi_evaluate_object
+c03b99bd r __kstrtab_acpi_walk_namespace
+c03b99d1 r __kstrtab_acpi_get_devices
+c03b99e2 r __kstrtab_acpi_attach_data
+c03b99f3 r __kstrtab_acpi_detach_data
+c03b9a04 r __kstrtab_acpi_get_data
+c03b9a12 r __kstrtab_acpi_get_handle
+c03b9a22 r __kstrtab_acpi_get_name
+c03b9a30 r __kstrtab_acpi_get_object_info
+c03b9a45 r __kstrtab_acpi_get_id
+c03b9a51 r __kstrtab_acpi_get_type
+c03b9a5f r __kstrtab_acpi_get_parent
+c03b9a6f r __kstrtab_acpi_get_next_object
+c03b9a84 r __kstrtab_acpi_get_irq_routing_table
+c03b9a9f r __kstrtab_acpi_get_current_resources
+c03b9aba r __kstrtab_acpi_set_current_resources
+c03b9ad5 r __kstrtab_acpi_resource_to_address64
+c03b9af0 r __kstrtab_acpi_get_vendor_resource
+c03b9b09 r __kstrtab_acpi_rs_match_vendor_resource
+c03b9b27 r __kstrtab_acpi_walk_resources
+c03b9b3b r __kstrtab_acpi_load_table
+c03b9b4b r __kstrtab_acpi_get_table_header
+c03b9b61 r __kstrtab_acpi_unload_table_id
+c03b9b76 r __kstrtab_acpi_get_table
+c03b9b85 r __kstrtab_acpi_get_table_by_index
+c03b9b9d r __kstrtab_acpi_load_tables
+c03b9bae r __kstrtab_acpi_ut_exception
+c03b9bc0 r __kstrtab_acpi_enable_subsystem
+c03b9bd6 r __kstrtab_acpi_initialize_objects
+c03b9bee r __kstrtab_acpi_terminate
+c03b9bfd r __kstrtab_acpi_purge_cached_objects
+c03b9c17 r __kstrtab_acpi_gbl_FADT
+c03b9c25 r __kstrtab_acpi_format_exception
+c03b9c3b r __kstrtab_acpi_dbg_level
+c03b9c4a r __kstrtab_acpi_dbg_layer
+c03b9c59 r __kstrtab_acpi_gpe_count
+c03b9c68 r __kstrtab_acpi_root_dir
+c03b9c76 r __kstrtab_acpi_bus_get_device
+c03b9c8a r __kstrtab_acpi_bus_get_status
+c03b9c9e r __kstrtab_acpi_bus_get_power
+c03b9cb1 r __kstrtab_acpi_bus_set_power
+c03b9cc4 r __kstrtab_acpi_bus_generate_event
+c03b9cdc r __kstrtab_acpi_bus_receive_event
+c03b9cf3 r __kstrtab_register_acpi_bus_type
+c03b9d0a r __kstrtab_unregister_acpi_bus_type
+c03b9d23 r __kstrtab_acpi_get_child
+c03b9d32 r __kstrtab_acpi_get_physical_device
+c03b9d4b r __kstrtab_acpi_bus_register_driver
+c03b9d64 r __kstrtab_acpi_bus_unregister_driver
+c03b9d7f r __kstrtab_acpi_bus_get_ejd
+c03b9d90 r __kstrtab_acpi_bus_add
+c03b9d9d r __kstrtab_acpi_bus_start
+c03b9dac r __kstrtab_acpi_bus_trim
+c03b9dba r __kstrtab_ec_burst_enable
+c03b9dca r __kstrtab_ec_burst_disable
+c03b9ddb r __kstrtab_ec_read
+c03b9de3 r __kstrtab_ec_write
+c03b9dec r __kstrtab_ec_transaction
+c03b9dfb r __kstrtab_acpi_ec_add_query_handler
+c03b9e15 r __kstrtab_acpi_ec_remove_query_handler
+c03b9e32 r __kstrtab_acpi_pci_register_driver
+c03b9e4b r __kstrtab_acpi_pci_unregister_driver
+c03b9e66 r __kstrtab_acpi_get_pci_rootbridge_handle
+c03b9e85 r __kstrtab_acpi_pci_irq_enable
+c03b9e99 r __kstrtab_acpi_get_pci_id
+c03b9ea9 r __kstrtab_acpi_lock_ac_dir
+c03b9eba r __kstrtab_acpi_unlock_ac_dir
+c03b9ecd r __kstrtab_acpi_lock_battery_dir
+c03b9ee3 r __kstrtab_acpi_unlock_battery_dir
+c03b9efb r __kstrtab_pnp_platform_devices
+c03b9f10 r __kstrtab_pnp_request_card_device
+c03b9f28 r __kstrtab_pnp_release_card_device
+c03b9f40 r __kstrtab_pnp_register_card_driver
+c03b9f59 r __kstrtab_pnp_unregister_card_driver
+c03b9f74 r __kstrtab_pnp_register_driver
+c03b9f88 r __kstrtab_pnp_unregister_driver
+c03b9f9e r __kstrtab_pnp_device_attach
+c03b9fb0 r __kstrtab_pnp_device_detach
+c03b9fc2 r __kstrtab_pnp_manual_config_dev
+c03b9fd8 r __kstrtab_pnp_start_dev
+c03b9fe6 r __kstrtab_pnp_stop_dev
+c03b9ff3 r __kstrtab_pnp_activate_dev
+c03ba004 r __kstrtab_pnp_disable_dev
+c03ba014 r __kstrtab_pnp_resource_change
+c03ba028 r __kstrtab_pnp_init_resource_table
+c03ba040 r __kstrtab_pnp_is_active
+c03ba04e r __kstrtab_add_input_randomness
+c03ba063 r __kstrtab_add_disk_randomness
+c03ba077 r __kstrtab_get_random_bytes
+c03ba088 r __kstrtab_generate_random_uuid
+c03ba09d r __kstrtab_secure_tcpv6_sequence_number
+c03ba0ba r __kstrtab_tty_std_termios
+c03ba0ca r __kstrtab_tty_mutex
+c03ba0d4 r __kstrtab_tty_name
+c03ba0dd r __kstrtab_tty_buffer_request_room
+c03ba0f5 r __kstrtab_tty_insert_flip_string
+c03ba10c r __kstrtab_tty_insert_flip_string_flags
+c03ba129 r __kstrtab_tty_schedule_flip
+c03ba13b r __kstrtab_tty_prepare_flip_string
+c03ba153 r __kstrtab_tty_prepare_flip_string_flags
+c03ba171 r __kstrtab_tty_register_ldisc
+c03ba184 r __kstrtab_tty_unregister_ldisc
+c03ba199 r __kstrtab_tty_ldisc_get
+c03ba1a7 r __kstrtab_tty_ldisc_put
+c03ba1b5 r __kstrtab_tty_ldisc_ref_wait
+c03ba1c8 r __kstrtab_tty_ldisc_ref
+c03ba1d6 r __kstrtab_tty_ldisc_deref
+c03ba1e6 r __kstrtab_tty_check_change
+c03ba1f7 r __kstrtab_tty_wakeup
+c03ba202 r __kstrtab_tty_ldisc_flush
+c03ba212 r __kstrtab_tty_hangup
+c03ba21d r __kstrtab_tty_vhangup
+c03ba229 r __kstrtab_tty_hung_up_p
+c03ba237 r __kstrtab_stop_tty
+c03ba240 r __kstrtab_start_tty
+c03ba24a r __kstrtab_do_SAK
+c03ba251 r __kstrtab_tty_flip_buffer_push
+c03ba266 r __kstrtab_tty_register_device
+c03ba27a r __kstrtab_tty_unregister_device
+c03ba290 r __kstrtab_alloc_tty_driver
+c03ba2a1 r __kstrtab_put_tty_driver
+c03ba2b0 r __kstrtab_tty_set_operations
+c03ba2c3 r __kstrtab_tty_register_driver
+c03ba2d7 r __kstrtab_tty_unregister_driver
+c03ba2ed r __kstrtab_tty_devnum
+c03ba2f8 r __kstrtab_proc_clear_tty
+c03ba307 r __kstrtab_get_current_tty
+c03ba317 r __kstrtab_tty_wait_until_sent
+c03ba32b r __kstrtab_tty_termios_baud_rate
+c03ba341 r __kstrtab_tty_termios_input_baud_rate
+c03ba35d r __kstrtab_tty_termios_encode_baud_rate
+c03ba37a r __kstrtab_tty_get_baud_rate
+c03ba38c r __kstrtab_n_tty_ioctl
+c03ba398 r __kstrtab_misc_register
+c03ba3a6 r __kstrtab_misc_deregister
+c03ba3b6 r __kstrtab_con_set_default_unimap
+c03ba3cd r __kstrtab_con_copy_unimap
+c03ba3dd r __kstrtab_con_is_bound
+c03ba3ea r __kstrtab_register_con_driver
+c03ba3fe r __kstrtab_unregister_con_driver
+c03ba414 r __kstrtab_do_blank_screen
+c03ba424 r __kstrtab_do_unblank_screen
+c03ba436 r __kstrtab_color_table
+c03ba442 r __kstrtab_default_red
+c03ba44e r __kstrtab_default_grn
+c03ba45a r __kstrtab_default_blu
+c03ba466 r __kstrtab_update_region
+c03ba474 r __kstrtab_redraw_screen
+c03ba482 r __kstrtab_vc_resize
+c03ba48c r __kstrtab_vc_lock_resize
+c03ba49b r __kstrtab_fg_console
+c03ba4a6 r __kstrtab_console_blank_hook
+c03ba4b9 r __kstrtab_console_blanked
+c03ba4c9 r __kstrtab_vc_cons
+c03ba4d1 r __kstrtab_take_over_console
+c03ba4e3 r __kstrtab_give_up_console
+c03ba4f3 r __kstrtab_handle_sysrq
+c03ba500 r __kstrtab_register_sysrq_key
+c03ba513 r __kstrtab_unregister_sysrq_key
+c03ba528 r __kstrtab_rtc_register
+c03ba535 r __kstrtab_rtc_unregister
+c03ba544 r __kstrtab_rtc_control
+c03ba550 r __kstrtab_hpet_alloc
+c03ba55b r __kstrtab_hpet_register
+c03ba569 r __kstrtab_hpet_unregister
+c03ba579 r __kstrtab_hpet_control
+c03ba586 r __kstrtab_hwrng_register
+c03ba595 r __kstrtab_hwrng_unregister
+c03ba5a6 r __kstrtab_uart_update_timeout
+c03ba5ba r __kstrtab_uart_get_baud_rate
+c03ba5cd r __kstrtab_uart_get_divisor
+c03ba5de r __kstrtab_uart_console_write
+c03ba5f1 r __kstrtab_uart_match_port
+c03ba601 r __kstrtab_uart_write_wakeup
+c03ba613 r __kstrtab_uart_register_driver
+c03ba628 r __kstrtab_uart_unregister_driver
+c03ba63f r __kstrtab_uart_suspend_port
+c03ba651 r __kstrtab_uart_resume_port
+c03ba662 r __kstrtab_uart_add_one_port
+c03ba674 r __kstrtab_uart_remove_one_port
+c03ba689 r __kstrtab_serial8250_register_port
+c03ba6a2 r __kstrtab_serial8250_unregister_port
+c03ba6bd r __kstrtab_serial8250_unregister_by_port
+c03ba6db r __kstrtab_serial8250_suspend_port
+c03ba6f3 r __kstrtab_serial8250_resume_port
+c03ba70a r __kstrtab_pciserial_init_ports
+c03ba71f r __kstrtab_pciserial_remove_ports
+c03ba736 r __kstrtab_pciserial_suspend_ports
+c03ba74e r __kstrtab_pciserial_resume_ports
+c03ba780 r __kstrtab_dev_driver_string
+c03ba792 r __kstrtab_device_create_bin_file
+c03ba7a9 r __kstrtab_device_remove_bin_file
+c03ba7c0 r __kstrtab_device_schedule_callback_owner
+c03ba7df r __kstrtab_device_for_each_child
+c03ba7f5 r __kstrtab_device_find_child
+c03ba807 r __kstrtab_device_initialize
+c03ba819 r __kstrtab_device_add
+c03ba824 r __kstrtab_device_register
+c03ba834 r __kstrtab_device_del
+c03ba83f r __kstrtab_device_unregister
+c03ba851 r __kstrtab_get_device
+c03ba85c r __kstrtab_put_device
+c03ba867 r __kstrtab_device_create_file
+c03ba87a r __kstrtab_device_remove_file
+c03ba88d r __kstrtab_device_create
+c03ba89b r __kstrtab_device_destroy
+c03ba8aa r __kstrtab_device_rename
+c03ba8b8 r __kstrtab_device_move
+c03ba8c4 r __kstrtab_sysdev_create_file
+c03ba8d7 r __kstrtab_sysdev_remove_file
+c03ba8ea r __kstrtab_sysdev_class_create_file
+c03ba903 r __kstrtab_sysdev_class_remove_file
+c03ba91c r __kstrtab_sysdev_class_register
+c03ba932 r __kstrtab_sysdev_class_unregister
+c03ba94a r __kstrtab_sysdev_driver_register
+c03ba961 r __kstrtab_sysdev_driver_unregister
+c03ba97a r __kstrtab_sysdev_register
+c03ba98a r __kstrtab_sysdev_unregister
+c03ba99c r __kstrtab_device_reprobe
+c03ba9ab r __kstrtab_bus_register_notifier
+c03ba9c1 r __kstrtab_bus_unregister_notifier
+c03ba9d9 r __kstrtab_bus_for_each_dev
+c03ba9ea r __kstrtab_bus_find_device
+c03ba9fa r __kstrtab_bus_for_each_drv
+c03baa0b r __kstrtab_bus_register
+c03baa18 r __kstrtab_bus_unregister
+c03baa27 r __kstrtab_bus_rescan_devices
+c03baa3a r __kstrtab_bus_create_file
+c03baa4a r __kstrtab_bus_remove_file
+c03baa5a r __kstrtab_device_bind_driver
+c03baa6d r __kstrtab_device_release_driver
+c03baa83 r __kstrtab_device_attach
+c03baa91 r __kstrtab_driver_attach
+c03baa9f r __kstrtab_driver_for_each_device
+c03baab6 r __kstrtab_driver_find_device
+c03baac9 r __kstrtab_driver_register
+c03baad9 r __kstrtab_driver_unregister
+c03baaeb r __kstrtab_get_driver
+c03baaf6 r __kstrtab_put_driver
+c03bab01 r __kstrtab_driver_find
+c03bab0d r __kstrtab_driver_create_file
+c03bab20 r __kstrtab_driver_remove_file
+c03bab33 r __kstrtab_class_create_file
+c03bab45 r __kstrtab_class_remove_file
+c03bab57 r __kstrtab_class_register
+c03bab66 r __kstrtab_class_unregister
+c03bab77 r __kstrtab_class_create
+c03bab84 r __kstrtab_class_destroy
+c03bab92 r __kstrtab_class_device_register
+c03baba8 r __kstrtab_class_device_unregister
+c03babc0 r __kstrtab_class_device_initialize
+c03babd8 r __kstrtab_class_device_add
+c03babe9 r __kstrtab_class_device_del
+c03babfa r __kstrtab_class_device_get
+c03bac0b r __kstrtab_class_device_put
+c03bac1c r __kstrtab_class_device_create
+c03bac30 r __kstrtab_class_device_destroy
+c03bac45 r __kstrtab_class_device_create_file
+c03bac5e r __kstrtab_class_device_remove_file
+c03bac77 r __kstrtab_class_device_create_bin_file
+c03bac94 r __kstrtab_class_device_remove_bin_file
+c03bacb1 r __kstrtab_class_interface_register
+c03bacca r __kstrtab_class_interface_unregister
+c03bad00 r __kstrtab_platform_bus
+c03bad0d r __kstrtab_platform_get_resource
+c03bad23 r __kstrtab_platform_get_irq
+c03bad34 r __kstrtab_platform_get_resource_byname
+c03bad51 r __kstrtab_platform_get_irq_byname
+c03bad69 r __kstrtab_platform_add_devices
+c03bad7e r __kstrtab_platform_device_put
+c03bad92 r __kstrtab_platform_device_alloc
+c03bada8 r __kstrtab_platform_device_add_resources
+c03badc6 r __kstrtab_platform_device_add_data
+c03baddf r __kstrtab_platform_device_add
+c03badf3 r __kstrtab_platform_device_del
+c03bae07 r __kstrtab_platform_device_register
+c03bae20 r __kstrtab_platform_device_unregister
+c03bae40 r __kstrtab_platform_device_register_simple
+c03bae60 r __kstrtab_platform_driver_register
+c03bae79 r __kstrtab_platform_driver_unregister
+c03bae94 r __kstrtab_platform_driver_probe
+c03baeaa r __kstrtab_platform_bus_type
+c03baebc r __kstrtab_dma_get_required_mask
+c03baed2 r __kstrtab_cpu_sysdev_class
+c03baee3 r __kstrtab_get_cpu_sysdev
+c03baef2 r __kstrtab_firmware_register
+c03baf04 r __kstrtab_firmware_unregister
+c03baf18 r __kstrtab_devres_alloc
+c03baf25 r __kstrtab_devres_free
+c03baf31 r __kstrtab_devres_add
+c03baf3c r __kstrtab_devres_find
+c03baf48 r __kstrtab_devres_get
+c03baf53 r __kstrtab_devres_remove
+c03baf61 r __kstrtab_devres_destroy
+c03baf70 r __kstrtab_devres_open_group
+c03baf82 r __kstrtab_devres_close_group
+c03baf95 r __kstrtab_devres_remove_group
+c03bafa9 r __kstrtab_devres_release_group
+c03bafbe r __kstrtab_devm_kzalloc
+c03bafcb r __kstrtab_devm_kfree
+c03bafe0 r __kstrtab_attribute_container_classdev_to_container
+c03bb00a r __kstrtab_attribute_container_register
+c03bb027 r __kstrtab_attribute_container_unregister
+c03bb060 r __kstrtab_attribute_container_find_class_device
+c03bb0a0 r __kstrtab_transport_class_register
+c03bb0b9 r __kstrtab_transport_class_unregister
+c03bb0d4 r __kstrtab_anon_transport_class_register
+c03bb100 r __kstrtab_anon_transport_class_unregister
+c03bb120 r __kstrtab_transport_setup_device
+c03bb137 r __kstrtab_transport_add_device
+c03bb14c r __kstrtab_transport_configure_device
+c03bb167 r __kstrtab_transport_remove_device
+c03bb17f r __kstrtab_transport_destroy_device
+c03bb198 r __kstrtab_device_pm_set_parent
+c03bb1ad r __kstrtab_device_suspend
+c03bb1bc r __kstrtab_device_power_down
+c03bb1ce r __kstrtab___suspend_report_result
+c03bb1e6 r __kstrtab_device_resume
+c03bb1f4 r __kstrtab_device_power_up
+c03bb204 r __kstrtab_dpm_runtime_resume
+c03bb217 r __kstrtab_dpm_runtime_suspend
+c03bb22b r __kstrtab_dmam_alloc_coherent
+c03bb23f r __kstrtab_dmam_free_coherent
+c03bb252 r __kstrtab_dmam_alloc_noncoherent
+c03bb269 r __kstrtab_dmam_free_noncoherent
+c03bb27f r __kstrtab_dmam_declare_coherent_memory
+c03bb29c r __kstrtab_dmam_release_declared_memory
+c03bb2b9 r __kstrtab_dma_pool_create
+c03bb2c9 r __kstrtab_dma_pool_destroy
+c03bb2da r __kstrtab_dma_pool_alloc
+c03bb2e9 r __kstrtab_dma_pool_free
+c03bb2f7 r __kstrtab_dmam_pool_create
+c03bb308 r __kstrtab_dmam_pool_destroy
+c03bb31a r __kstrtab_release_firmware
+c03bb32b r __kstrtab_request_firmware
+c03bb33c r __kstrtab_request_firmware_nowait
+c03bb354 r __kstrtab_noautodma
+c03bb35e r __kstrtab_ide_hwifs
+c03bb368 r __kstrtab_ide_unregister
+c03bb377 r __kstrtab_ide_register_hw_with_fixup
+c03bb392 r __kstrtab_ide_register_hw
+c03bb3a2 r __kstrtab_ide_setting_sem
+c03bb3b2 r __kstrtab_ide_spin_wait_hwgroup
+c03bb3c8 r __kstrtab_system_bus_clock
+c03bb3d9 r __kstrtab_generic_ide_ioctl
+c03bb3eb r __kstrtab_ide_lock
+c03bb3f4 r __kstrtab_ide_bus_type
+c03bb401 r __kstrtab_ide_end_request
+c03bb411 r __kstrtab_ide_end_dequeued_request
+c03bb42a r __kstrtab_ide_get_error_location
+c03bb441 r __kstrtab_ide_end_drive_cmd
+c03bb453 r __kstrtab___ide_error
+c03bb45f r __kstrtab_ide_error
+c03bb469 r __kstrtab___ide_abort
+c03bb475 r __kstrtab_ide_map_sg
+c03bb480 r __kstrtab_ide_init_sg_cmd
+c03bb490 r __kstrtab_ide_stall_queue
+c03bb4a0 r __kstrtab_ide_init_drive_cmd
+c03bb4b3 r __kstrtab_ide_do_drive_cmd
+c03bb4c4 r __kstrtab_default_hwif_mmiops
+c03bb4d8 r __kstrtab_SELECT_DRIVE
+c03bb4e5 r __kstrtab_ide_fix_driveid
+c03bb4f5 r __kstrtab_ide_fixstring
+c03bb503 r __kstrtab_drive_is_ready
+c03bb512 r __kstrtab_ide_wait_stat
+c03bb520 r __kstrtab_ide_config_drive_speed
+c03bb537 r __kstrtab_ide_set_handler
+c03bb547 r __kstrtab_ide_execute_command
+c03bb55b r __kstrtab_ide_do_reset
+c03bb568 r __kstrtab_ide_wait_not_busy
+c03bb57a r __kstrtab_ide_xfer_verbose
+c03bb58b r __kstrtab_ide_rate_filter
+c03bb59b r __kstrtab_ide_use_fast_pio
+c03bb5ac r __kstrtab_ide_pio_timings
+c03bb5bc r __kstrtab_ide_get_best_pio_mode
+c03bb5d2 r __kstrtab_ide_dump_status
+c03bb5e2 r __kstrtab_ide_undecoded_slave
+c03bb5f6 r __kstrtab_probe_hwif_init
+c03bb606 r __kstrtab_ide_register_region
+c03bb61a r __kstrtab_ide_unregister_region
+c03bb630 r __kstrtab_ide_init_disk
+c03bb63e r __kstrtab_ideprobe_init
+c03bb64c r __kstrtab_task_no_data_intr
+c03bb65e r __kstrtab_task_in_intr
+c03bb66b r __kstrtab_pre_task_out_intr
+c03bb67d r __kstrtab_ide_raw_taskfile
+c03bb68e r __kstrtab_ide_setup_pci_noise
+c03bb6a2 r __kstrtab_ide_pci_setup_ports
+c03bb6b6 r __kstrtab_ide_setup_pci_device
+c03bb6cb r __kstrtab_ide_setup_pci_devices
+c03bb6e1 r __kstrtab___ide_pci_register_driver
+c03bb6fb r __kstrtab_ide_dma_intr
+c03bb708 r __kstrtab_ide_build_sglist
+c03bb719 r __kstrtab_ide_build_dmatable
+c03bb72c r __kstrtab_ide_destroy_dmatable
+c03bb741 r __kstrtab_ide_dma_host_off
+c03bb752 r __kstrtab_ide_dma_off_quietly
+c03bb766 r __kstrtab_ide_dma_off
+c03bb772 r __kstrtab_ide_dma_host_on
+c03bb782 r __kstrtab___ide_dma_on
+c03bb78f r __kstrtab___ide_dma_check
+c03bb79f r __kstrtab_ide_dma_setup
+c03bb7ad r __kstrtab_ide_dma_start
+c03bb7bb r __kstrtab___ide_dma_end
+c03bb7c9 r __kstrtab___ide_dma_bad_drive
+c03bb7dd r __kstrtab___ide_dma_good_drive
+c03bb7f2 r __kstrtab_ide_max_dma_mode
+c03bb803 r __kstrtab_ide_tune_dma
+c03bb810 r __kstrtab_ide_dma_verbose
+c03bb820 r __kstrtab_ide_set_dma
+c03bb82c r __kstrtab___ide_dma_lostirq
+c03bb83e r __kstrtab___ide_dma_timeout
+c03bb850 r __kstrtab_ide_setup_dma
+c03bb85e r __kstrtab_cdrom_get_last_written
+c03bb875 r __kstrtab_register_cdrom
+c03bb884 r __kstrtab_unregister_cdrom
+c03bb895 r __kstrtab_cdrom_open
+c03bb8a0 r __kstrtab_cdrom_release
+c03bb8ae r __kstrtab_cdrom_ioctl
+c03bb8ba r __kstrtab_cdrom_media_changed
+c03bb8ce r __kstrtab_cdrom_number_of_slots
+c03bb8e4 r __kstrtab_cdrom_mode_select
+c03bb8f6 r __kstrtab_cdrom_mode_sense
+c03bb907 r __kstrtab_init_cdrom_command
+c03bb91a r __kstrtab_cdrom_get_media_event
+c03bb930 r __kstrtab_usb_disabled
+c03bb93d r __kstrtab_usb_get_intf
+c03bb94a r __kstrtab_usb_put_intf
+c03bb957 r __kstrtab_usb_put_dev
+c03bb963 r __kstrtab_usb_get_dev
+c03bb96f r __kstrtab_usb_hub_tt_clear_buffer
+c03bb987 r __kstrtab_usb_lock_device_for_reset
+c03bb9a1 r __kstrtab_usb_find_interface
+c03bb9b4 r __kstrtab_usb_ifnum_to_if
+c03bb9c4 r __kstrtab_usb_altnum_to_altsetting
+c03bb9dd r __kstrtab___usb_get_extra_descriptor
+c03bb9f8 r __kstrtab_usb_find_device
+c03bba08 r __kstrtab_usb_get_current_frame_number
+c03bba25 r __kstrtab_usb_buffer_alloc
+c03bba36 r __kstrtab_usb_buffer_free
+c03bba46 r __kstrtab_usb_buffer_map_sg
+c03bba58 r __kstrtab_usb_buffer_unmap_sg
+c03bba6c r __kstrtab_ehci_cf_port_reset_rwsem
+c03bba85 r __kstrtab_usb_root_hub_lost_power
+c03bba9d r __kstrtab_usb_reset_device
+c03bbaae r __kstrtab_usb_reset_composite_device
+c03bbac9 r __kstrtab_usb_bus_list
+c03bbad6 r __kstrtab_usb_bus_list_lock
+c03bbae8 r __kstrtab_usb_hcd_poll_rh_status
+c03bbaff r __kstrtab_usb_calc_bus_time
+c03bbb11 r __kstrtab_usb_hcd_resume_root_hub
+c03bbb29 r __kstrtab_usb_hcd_giveback_urb
+c03bbb3e r __kstrtab_usb_hc_died
+c03bbb4a r __kstrtab_usb_create_hcd
+c03bbb59 r __kstrtab_usb_get_hcd
+c03bbb65 r __kstrtab_usb_put_hcd
+c03bbb71 r __kstrtab_usb_add_hcd
+c03bbb7d r __kstrtab_usb_remove_hcd
+c03bbb8c r __kstrtab_usb_hcd_platform_shutdown
+c03bbba6 r __kstrtab_usb_init_urb
+c03bbbb3 r __kstrtab_usb_alloc_urb
+c03bbbc1 r __kstrtab_usb_free_urb
+c03bbbce r __kstrtab_usb_get_urb
+c03bbbda r __kstrtab_usb_submit_urb
+c03bbbe9 r __kstrtab_usb_unlink_urb
+c03bbbf8 r __kstrtab_usb_kill_urb
+c03bbc05 r __kstrtab_usb_interrupt_msg
+c03bbc17 r __kstrtab_usb_driver_set_configuration
+c03bbc34 r __kstrtab_usb_control_msg
+c03bbc44 r __kstrtab_usb_bulk_msg
+c03bbc51 r __kstrtab_usb_sg_init
+c03bbc5d r __kstrtab_usb_sg_cancel
+c03bbc6b r __kstrtab_usb_sg_wait
+c03bbc77 r __kstrtab_usb_get_descriptor
+c03bbc8a r __kstrtab_usb_get_status
+c03bbc99 r __kstrtab_usb_string
+c03bbca4 r __kstrtab_usb_clear_halt
+c03bbcb3 r __kstrtab_usb_reset_configuration
+c03bbccb r __kstrtab_usb_set_interface
+c03bbcdd r __kstrtab_usb_store_new_id
+c03bbcee r __kstrtab_usb_driver_claim_interface
+c03bbd09 r __kstrtab_usb_driver_release_interface
+c03bbd26 r __kstrtab_usb_match_one_id
+c03bbd37 r __kstrtab_usb_match_id
+c03bbd44 r __kstrtab_usb_register_device_driver
+c03bbd5f r __kstrtab_usb_deregister_device_driver
+c03bbd7c r __kstrtab_usb_register_driver
+c03bbd90 r __kstrtab_usb_deregister
+c03bbd9f r __kstrtab_usb_register_dev
+c03bbdb0 r __kstrtab_usb_deregister_dev
+c03bbdc3 r __kstrtab_usb_register_notify
+c03bbdd7 r __kstrtab_usb_unregister_notify
+c03bbded r __kstrtab_usb_hcd_pci_probe
+c03bbdff r __kstrtab_usb_hcd_pci_remove
+c03bbe12 r __kstrtab_usb_hcd_pci_suspend
+c03bbe26 r __kstrtab_usb_hcd_pci_resume
+c03bbe39 r __kstrtab_usb_hcd_pci_shutdown
+c03bbe4e r __kstrtab_uhci_reset_hc
+c03bbe5c r __kstrtab_uhci_check_and_reset_hc
+c03bbe74 r __kstrtab_storage_usb_ids
+c03bbe84 r __kstrtab_usb_usual_set_present
+c03bbe9a r __kstrtab_usb_usual_clear_present
+c03bbeb2 r __kstrtab_usb_usual_check_type
+c03bbec7 r __kstrtab_serio_interrupt
+c03bbed7 r __kstrtab___serio_register_port
+c03bbeed r __kstrtab_serio_unregister_port
+c03bbf03 r __kstrtab_serio_unregister_child_port
+c03bbf1f r __kstrtab___serio_register_driver
+c03bbf37 r __kstrtab_serio_unregister_driver
+c03bbf4f r __kstrtab_serio_open
+c03bbf5a r __kstrtab_serio_close
+c03bbf66 r __kstrtab_serio_rescan
+c03bbf73 r __kstrtab_serio_reconnect
+c03bbf83 r __kstrtab_ps2_sendbyte
+c03bbf90 r __kstrtab_ps2_drain
+c03bbf9a r __kstrtab_ps2_is_keyboard_id
+c03bbfad r __kstrtab_ps2_command
+c03bbfb9 r __kstrtab_ps2_schedule_command
+c03bbfce r __kstrtab_ps2_init
+c03bbfd7 r __kstrtab_ps2_handle_ack
+c03bbfe6 r __kstrtab_ps2_handle_response
+c03bbffa r __kstrtab_ps2_cmd_aborted
+c03bc00a r __kstrtab_input_event
+c03bc016 r __kstrtab_input_inject_event
+c03bc029 r __kstrtab_input_grab_device
+c03bc03b r __kstrtab_input_release_device
+c03bc050 r __kstrtab_input_open_device
+c03bc062 r __kstrtab_input_flush_device
+c03bc075 r __kstrtab_input_close_device
+c03bc088 r __kstrtab_input_class
+c03bc094 r __kstrtab_input_allocate_device
+c03bc0aa r __kstrtab_input_free_device
+c03bc0bc r __kstrtab_input_set_capability
+c03bc0d1 r __kstrtab_input_register_device
+c03bc0e7 r __kstrtab_input_unregister_device
+c03bc0ff r __kstrtab_input_register_handler
+c03bc116 r __kstrtab_input_unregister_handler
+c03bc12f r __kstrtab_input_register_handle
+c03bc145 r __kstrtab_input_unregister_handle
+c03bc15d r __kstrtab_input_ff_upload
+c03bc16d r __kstrtab_input_ff_erase
+c03bc17c r __kstrtab_input_ff_event
+c03bc18b r __kstrtab_input_ff_create
+c03bc19b r __kstrtab_input_ff_destroy
+c03bc1ac r __kstrtab___i2c_board_lock
+c03bc1bd r __kstrtab___i2c_board_list
+c03bc1ce r __kstrtab___i2c_first_dynamic_bus_num
+c03bc1ea r __kstrtab_md_new_event
+c03bc1f7 r __kstrtab_sync_page_io
+c03bc204 r __kstrtab_md_allow_write
+c03bc213 r __kstrtab_md_do_sync
+c03bc21e r __kstrtab_register_md_personality
+c03bc236 r __kstrtab_unregister_md_personality
+c03bc250 r __kstrtab_md_error
+c03bc259 r __kstrtab_md_done_sync
+c03bc266 r __kstrtab_md_write_start
+c03bc275 r __kstrtab_md_write_end
+c03bc282 r __kstrtab_md_register_thread
+c03bc295 r __kstrtab_md_unregister_thread
+c03bc2aa r __kstrtab_md_wakeup_thread
+c03bc2bb r __kstrtab_md_check_recovery
+c03bc2cd r __kstrtab_bitmap_startwrite
+c03bc2df r __kstrtab_bitmap_endwrite
+c03bc2ef r __kstrtab_bitmap_start_sync
+c03bc301 r __kstrtab_bitmap_end_sync
+c03bc311 r __kstrtab_bitmap_unplug
+c03bc31f r __kstrtab_bitmap_close_sync
+c03bc331 r __kstrtab_dm_device_name
+c03bc340 r __kstrtab_dm_put
+c03bc347 r __kstrtab_dm_noflush_suspending
+c03bc35d r __kstrtab_dm_get_mapinfo
+c03bc36c r __kstrtab_dm_create_error_table
+c03bc382 r __kstrtab_dm_set_device_limits
+c03bc397 r __kstrtab_dm_vcalloc
+c03bc3a2 r __kstrtab_dm_get_device
+c03bc3b0 r __kstrtab_dm_put_device
+c03bc3be r __kstrtab_dm_table_event
+c03bc3cd r __kstrtab_dm_table_get_size
+c03bc3df r __kstrtab_dm_table_get_mode
+c03bc3f1 r __kstrtab_dm_table_get_md
+c03bc401 r __kstrtab_dm_table_put
+c03bc40e r __kstrtab_dm_table_get
+c03bc41b r __kstrtab_dm_table_unplug_all
+c03bc42f r __kstrtab_dm_table_flush_all
+c03bc442 r __kstrtab_dm_register_target
+c03bc455 r __kstrtab_dm_unregister_target
+c03bc46a r __kstrtab_dm_io_client_create
+c03bc47e r __kstrtab_dm_io_client_resize
+c03bc492 r __kstrtab_dm_io_client_destroy
+c03bc4a7 r __kstrtab_dm_io
+c03bc4ad r __kstrtab_kcopyd_client_create
+c03bc4c2 r __kstrtab_kcopyd_client_destroy
+c03bc4d8 r __kstrtab_kcopyd_copy
+c03bc4e4 r __kstrtab_dmi_check_system
+c03bc4f5 r __kstrtab_dmi_get_system_info
+c03bc509 r __kstrtab_dmi_name_in_vendors
+c03bc51d r __kstrtab_dmi_find_device
+c03bc52d r __kstrtab_dma_sync_wait
+c03bc53b r __kstrtab_dma_chan_cleanup
+c03bc54c r __kstrtab_dma_async_client_register
+c03bc566 r __kstrtab_dma_async_client_unregister
+c03bc582 r __kstrtab_dma_async_client_chan_request
+c03bc5a0 r __kstrtab_dma_async_device_register
+c03bc5ba r __kstrtab_dma_async_device_unregister
+c03bc5d6 r __kstrtab_dma_async_memcpy_buf_to_buf
+c03bc5f2 r __kstrtab_dma_async_memcpy_buf_to_pg
+c03bc60d r __kstrtab_dma_async_memcpy_pg_to_pg
+c03bc627 r __kstrtab_dma_async_tx_descriptor_init
+c03bc644 r __kstrtab_hid_free_device
+c03bc654 r __kstrtab_hid_parse_report
+c03bc665 r __kstrtab_hid_input_field
+c03bc675 r __kstrtab_hid_output_report
+c03bc687 r __kstrtab_hid_set_field
+c03bc695 r __kstrtab_hid_input_report
+c03bc6a6 r __kstrtab_hidinput_report_event
+c03bc6bc r __kstrtab_hidinput_find_field
+c03bc6d0 r __kstrtab_hidinput_connect
+c03bc6e1 r __kstrtab_hidinput_disconnect
+c03bc6f5 r __kstrtab_pcibios_get_irq_routing_table
+c03bc713 r __kstrtab_pcibios_set_irq_routing
+c03bc72b r __kstrtab_save_processor_state
+c03bc740 r __kstrtab_restore_processor_state
+c03bc760 r __kstrtab___sock_recv_timestamp
+c03bc776 r __kstrtab_brioctl_set
+c03bc782 r __kstrtab_vlan_ioctl_set
+c03bc791 r __kstrtab_dlci_ioctl_set
+c03bc7a0 r __kstrtab_move_addr_to_kernel
+c03bc7b4 r __kstrtab_move_addr_to_user
+c03bc7c6 r __kstrtab_sock_create
+c03bc7d2 r __kstrtab_sock_create_kern
+c03bc7e3 r __kstrtab_sock_create_lite
+c03bc7f4 r __kstrtab_sock_map_fd
+c03bc800 r __kstrtab_sock_recvmsg
+c03bc80d r __kstrtab_sock_register
+c03bc81b r __kstrtab_sock_release
+c03bc828 r __kstrtab_sock_sendmsg
+c03bc835 r __kstrtab_sock_unregister
+c03bc845 r __kstrtab_sock_wake_async
+c03bc855 r __kstrtab_sockfd_lookup
+c03bc863 r __kstrtab_kernel_sendmsg
+c03bc872 r __kstrtab_kernel_recvmsg
+c03bc881 r __kstrtab_kernel_bind
+c03bc88d r __kstrtab_kernel_listen
+c03bc89b r __kstrtab_kernel_accept
+c03bc8a9 r __kstrtab_kernel_connect
+c03bc8b8 r __kstrtab_kernel_getsockname
+c03bc8cb r __kstrtab_kernel_getpeername
+c03bc8de r __kstrtab_kernel_getsockopt
+c03bc8f0 r __kstrtab_kernel_setsockopt
+c03bc902 r __kstrtab_kernel_sendpage
+c03bc912 r __kstrtab_kernel_sock_ioctl
+c03bc940 r __kstrtab_sock_queue_rcv_skb
+c03bc953 r __kstrtab_sk_receive_skb
+c03bc962 r __kstrtab___sk_dst_check
+c03bc971 r __kstrtab_sk_dst_check
+c03bc97e r __kstrtab_sk_clone
+c03bc987 r __kstrtab_sk_setup_caps
+c03bc995 r __kstrtab_sk_wait_data
+c03bc9a2 r __kstrtab_sk_reset_timer
+c03bc9b1 r __kstrtab_sk_stop_timer
+c03bc9bf r __kstrtab_lock_sock_nested
+c03bc9d0 r __kstrtab_release_sock
+c03bc9dd r __kstrtab_sock_get_timestamp
+c03bc9f0 r __kstrtab_sock_get_timestampns
+c03bca05 r __kstrtab_sock_enable_timestamp
+c03bca1b r __kstrtab_sock_common_getsockopt
+c03bca32 r __kstrtab_sock_common_recvmsg
+c03bca46 r __kstrtab_sock_common_setsockopt
+c03bca5d r __kstrtab_sk_common_release
+c03bca6f r __kstrtab_proto_register
+c03bca7e r __kstrtab_proto_unregister
+c03bca8f r __kstrtab_sk_alloc
+c03bca98 r __kstrtab_sk_free
+c03bcaa0 r __kstrtab_sk_send_sigurg
+c03bcaaf r __kstrtab_sock_alloc_send_skb
+c03bcac3 r __kstrtab_sock_init_data
+c03bcad2 r __kstrtab_sock_kfree_s
+c03bcadf r __kstrtab_sock_kmalloc
+c03bcaec r __kstrtab_sock_no_accept
+c03bcafb r __kstrtab_sock_no_bind
+c03bcb08 r __kstrtab_sock_no_connect
+c03bcb18 r __kstrtab_sock_no_getname
+c03bcb28 r __kstrtab_sock_no_getsockopt
+c03bcb3b r __kstrtab_sock_no_ioctl
+c03bcb49 r __kstrtab_sock_no_listen
+c03bcb58 r __kstrtab_sock_no_mmap
+c03bcb65 r __kstrtab_sock_no_poll
+c03bcb72 r __kstrtab_sock_no_recvmsg
+c03bcb82 r __kstrtab_sock_no_sendmsg
+c03bcb92 r __kstrtab_sock_no_sendpage
+c03bcba3 r __kstrtab_sock_no_setsockopt
+c03bcbb6 r __kstrtab_sock_no_shutdown
+c03bcbc7 r __kstrtab_sock_no_socketpair
+c03bcbda r __kstrtab_sock_rfree
+c03bcbe5 r __kstrtab_sock_setsockopt
+c03bcbf5 r __kstrtab_sock_wfree
+c03bcc00 r __kstrtab_sock_wmalloc
+c03bcc0d r __kstrtab_sock_i_uid
+c03bcc18 r __kstrtab_sock_i_ino
+c03bcc23 r __kstrtab_sysctl_optmem_max
+c03bcc35 r __kstrtab_sysctl_rmem_max
+c03bcc45 r __kstrtab_sysctl_wmem_max
+c03bcc55 r __kstrtab_reqsk_queue_alloc
+c03bcc67 r __kstrtab_reqsk_queue_destroy
+c03bcc7b r __kstrtab_skb_truesize_bug
+c03bcc8c r __kstrtab_skb_store_bits
+c03bcc9b r __kstrtab_skb_pull_rcsum
+c03bccaa r __kstrtab_skb_segment
+c03bccb6 r __kstrtab____pskb_trim
+c03bccc3 r __kstrtab___kfree_skb
+c03bcccf r __kstrtab_kfree_skb
+c03bccd9 r __kstrtab___pskb_pull_tail
+c03bccea r __kstrtab___alloc_skb
+c03bccf6 r __kstrtab___netdev_alloc_skb
+c03bcd09 r __kstrtab_pskb_copy
+c03bcd13 r __kstrtab_pskb_expand_head
+c03bcd24 r __kstrtab_skb_checksum
+c03bcd31 r __kstrtab_skb_clone
+c03bcd3b r __kstrtab_skb_copy
+c03bcd44 r __kstrtab_skb_copy_and_csum_bits
+c03bcd5b r __kstrtab_skb_copy_and_csum_dev
+c03bcd71 r __kstrtab_skb_copy_bits
+c03bcd7f r __kstrtab_skb_copy_expand
+c03bcd8f r __kstrtab_skb_over_panic
+c03bcd9e r __kstrtab_skb_pad
+c03bcda6 r __kstrtab_skb_realloc_headroom
+c03bcdbb r __kstrtab_skb_under_panic
+c03bcdcb r __kstrtab_skb_dequeue
+c03bcdd7 r __kstrtab_skb_dequeue_tail
+c03bcde8 r __kstrtab_skb_insert
+c03bcdf3 r __kstrtab_skb_queue_purge
+c03bce03 r __kstrtab_skb_queue_head
+c03bce12 r __kstrtab_skb_queue_tail
+c03bce21 r __kstrtab_skb_unlink
+c03bce2c r __kstrtab_skb_append
+c03bce37 r __kstrtab_skb_split
+c03bce41 r __kstrtab_skb_prepare_seq_read
+c03bce56 r __kstrtab_skb_seq_read
+c03bce63 r __kstrtab_skb_abort_seq_read
+c03bce76 r __kstrtab_skb_find_text
+c03bce84 r __kstrtab_skb_append_datato_frags
+c03bce9c r __kstrtab_skb_to_sgvec
+c03bcea9 r __kstrtab_skb_cow_data
+c03bceb6 r __kstrtab_csum_partial_copy_fromiovecend
+c03bced5 r __kstrtab_memcpy_fromiovec
+c03bcee6 r __kstrtab_memcpy_fromiovecend
+c03bcefa r __kstrtab_memcpy_toiovec
+c03bcf20 r __kstrtab_skb_kill_datagram
+c03bcf32 r __kstrtab___skb_checksum_complete_head
+c03bcf4f r __kstrtab___skb_checksum_complete
+c03bcf67 r __kstrtab_datagram_poll
+c03bcf80 r __kstrtab_skb_copy_and_csum_datagram_iovec
+c03bcfa1 r __kstrtab_skb_copy_datagram_iovec
+c03bcfb9 r __kstrtab_skb_free_datagram
+c03bcfcb r __kstrtab_skb_recv_datagram
+c03bcfdd r __kstrtab_sk_stream_write_space
+c03bcff3 r __kstrtab_sk_stream_wait_connect
+c03bd00a r __kstrtab_sk_stream_wait_close
+c03bd01f r __kstrtab_sk_stream_wait_memory
+c03bd035 r __kstrtab_sk_stream_rfree
+c03bd045 r __kstrtab_sk_stream_error
+c03bd055 r __kstrtab___sk_stream_mem_reclaim
+c03bd06d r __kstrtab_sk_stream_mem_schedule
+c03bd084 r __kstrtab_sk_stream_kill_queues
+c03bd09a r __kstrtab___scm_destroy
+c03bd0a8 r __kstrtab___scm_send
+c03bd0b3 r __kstrtab_put_cmsg
+c03bd0bc r __kstrtab_scm_detach_fds
+c03bd0cb r __kstrtab_scm_fp_dup
+c03bd0d6 r __kstrtab_gnet_stats_start_copy
+c03bd0ec r __kstrtab_gnet_stats_start_copy_compat
+c03bd109 r __kstrtab_gnet_stats_copy_basic
+c03bd11f r __kstrtab_gnet_stats_copy_rate_est
+c03bd138 r __kstrtab_gnet_stats_copy_queue
+c03bd14e r __kstrtab_gnet_stats_copy_app
+c03bd162 r __kstrtab_gnet_stats_finish_copy
+c03bd179 r __kstrtab_gen_kill_estimator
+c03bd18c r __kstrtab_gen_new_estimator
+c03bd19e r __kstrtab_gen_replace_estimator
+c03bd1b4 r __kstrtab_init_net
+c03bd1bd r __kstrtab___put_net
+c03bd1c7 r __kstrtab_register_pernet_subsys
+c03bd1de r __kstrtab_unregister_pernet_subsys
+c03bd1f7 r __kstrtab_register_pernet_device
+c03bd20e r __kstrtab_unregister_pernet_device
+c03bd227 r __kstrtab_dev_base_lock
+c03bd235 r __kstrtab_dev_getbyhwaddr
+c03bd245 r __kstrtab___dev_getfirstbyhwtype
+c03bd25c r __kstrtab_dev_getfirstbyhwtype
+c03bd271 r __kstrtab_netdev_features_change
+c03bd288 r __kstrtab___netif_schedule
+c03bd299 r __kstrtab___netif_rx_schedule
+c03bd2ad r __kstrtab_dev_kfree_skb_any
+c03bd2bf r __kstrtab_netif_device_detach
+c03bd2d3 r __kstrtab_netif_device_attach
+c03bd2e7 r __kstrtab_skb_gso_segment
+c03bd2f7 r __kstrtab_netdev_rx_csum_fault
+c03bd30c r __kstrtab_netif_rx_ni
+c03bd318 r __kstrtab_register_netdev
+c03bd328 r __kstrtab_alloc_netdev
+c03bd335 r __kstrtab_unregister_netdev
+c03bd347 r __kstrtab_netdev_compute_features
+c03bd35f r __kstrtab___dev_get_by_index
+c03bd372 r __kstrtab___dev_get_by_name
+c03bd384 r __kstrtab___dev_remove_pack
+c03bd396 r __kstrtab_dev_valid_name
+c03bd3a5 r __kstrtab_dev_add_pack
+c03bd3b2 r __kstrtab_dev_alloc_name
+c03bd3c1 r __kstrtab_dev_close
+c03bd3cb r __kstrtab_dev_get_by_flags
+c03bd3dc r __kstrtab_dev_get_by_index
+c03bd3ed r __kstrtab_dev_get_by_name
+c03bd3fd r __kstrtab_dev_open
+c03bd406 r __kstrtab_dev_queue_xmit
+c03bd415 r __kstrtab_dev_remove_pack
+c03bd425 r __kstrtab_dev_set_allmulti
+c03bd436 r __kstrtab_dev_set_promiscuity
+c03bd44a r __kstrtab_dev_change_flags
+c03bd45b r __kstrtab_dev_set_mtu
+c03bd467 r __kstrtab_dev_set_mac_address
+c03bd47b r __kstrtab_free_netdev
+c03bd487 r __kstrtab_netdev_boot_setup_check
+c03bd49f r __kstrtab_netdev_set_master
+c03bd4b1 r __kstrtab_netdev_state_change
+c03bd4c5 r __kstrtab_netif_receive_skb
+c03bd4d7 r __kstrtab_netif_rx
+c03bd4e0 r __kstrtab_register_gifconf
+c03bd4f1 r __kstrtab_register_netdevice
+c03bd504 r __kstrtab_register_netdevice_notifier
+c03bd520 r __kstrtab_skb_checksum_help
+c03bd532 r __kstrtab_synchronize_net
+c03bd542 r __kstrtab_unregister_netdevice
+c03bd557 r __kstrtab_unregister_netdevice_notifier
+c03bd575 r __kstrtab_net_enable_timestamp
+c03bd58a r __kstrtab_net_disable_timestamp
+c03bd5a0 r __kstrtab_dev_get_flags
+c03bd5ae r __kstrtab_dev_load
+c03bd5b7 r __kstrtab_per_cpu__softnet_data
+c03bd5cd r __kstrtab_dev_ethtool
+c03bd5d9 r __kstrtab_ethtool_op_get_link
+c03bd5ed r __kstrtab_ethtool_op_get_perm_addr
+c03bd606 r __kstrtab_ethtool_op_get_sg
+c03bd618 r __kstrtab_ethtool_op_get_tso
+c03bd62b r __kstrtab_ethtool_op_get_tx_csum
+c03bd642 r __kstrtab_ethtool_op_set_sg
+c03bd654 r __kstrtab_ethtool_op_set_tso
+c03bd667 r __kstrtab_ethtool_op_set_tx_csum
+c03bd67e r __kstrtab_ethtool_op_set_tx_hw_csum
+c03bd698 r __kstrtab_ethtool_op_set_ufo
+c03bd6ab r __kstrtab_ethtool_op_get_ufo
+c03bd6be r __kstrtab_dev_mc_add
+c03bd6c9 r __kstrtab_dev_mc_delete
+c03bd6d7 r __kstrtab_dev_mc_upload
+c03bd6e5 r __kstrtab___dst_free
+c03bd6f0 r __kstrtab_dst_alloc
+c03bd6fa r __kstrtab_dst_destroy
+c03bd706 r __kstrtab_register_netevent_notifier
+c03bd721 r __kstrtab_unregister_netevent_notifier
+c03bd73e r __kstrtab_call_netevent_notifiers
+c03bd756 r __kstrtab_neigh_for_each
+c03bd765 r __kstrtab___neigh_for_each_release
+c03bd77e r __kstrtab_neigh_seq_start
+c03bd78e r __kstrtab_neigh_seq_next
+c03bd79d r __kstrtab_neigh_seq_stop
+c03bd7ac r __kstrtab___neigh_event_send
+c03bd7bf r __kstrtab_neigh_changeaddr
+c03bd7d0 r __kstrtab_neigh_compat_output
+c03bd7e4 r __kstrtab_neigh_connected_output
+c03bd7fb r __kstrtab_neigh_create
+c03bd808 r __kstrtab_neigh_destroy
+c03bd816 r __kstrtab_neigh_event_ns
+c03bd825 r __kstrtab_neigh_ifdown
+c03bd832 r __kstrtab_neigh_lookup
+c03bd83f r __kstrtab_neigh_lookup_nodev
+c03bd852 r __kstrtab_neigh_parms_alloc
+c03bd864 r __kstrtab_neigh_parms_alloc_default
+c03bd87e r __kstrtab_neigh_parms_release
+c03bd892 r __kstrtab_neigh_rand_reach_time
+c03bd8a8 r __kstrtab_neigh_resolve_output
+c03bd8bd r __kstrtab_neigh_table_clear
+c03bd8cf r __kstrtab_neigh_table_init
+c03bd8e0 r __kstrtab_neigh_table_init_no_netlink
+c03bd8fc r __kstrtab_neigh_update
+c03bd909 r __kstrtab_pneigh_enqueue
+c03bd918 r __kstrtab_pneigh_lookup
+c03bd926 r __kstrtab_neigh_sysctl_register
+c03bd93c r __kstrtab_neigh_sysctl_unregister
+c03bd954 r __kstrtab___rtnl_register
+c03bd964 r __kstrtab_rtnl_register
+c03bd972 r __kstrtab_rtnl_unregister
+c03bd982 r __kstrtab_rtnl_unregister_all
+c03bd996 r __kstrtab___rtnl_link_register
+c03bd9ab r __kstrtab_rtnl_link_register
+c03bd9be r __kstrtab___rtnl_link_unregister
+c03bd9d5 r __kstrtab_rtnl_link_unregister
+c03bd9ea r __kstrtab_rtnl_put_cacheinfo
+c03bd9fd r __kstrtab___rta_fill
+c03bda08 r __kstrtab_rtattr_strlcpy
+c03bda17 r __kstrtab_rtattr_parse
+c03bda24 r __kstrtab___rtattr_parse_nested_compat
+c03bda41 r __kstrtab_rtnetlink_put_metrics
+c03bda57 r __kstrtab_rtnl_lock
+c03bda61 r __kstrtab_rtnl_trylock
+c03bda6e r __kstrtab_rtnl_unlock
+c03bda7a r __kstrtab_rtnl_unicast
+c03bda87 r __kstrtab_rtnl_notify
+c03bda93 r __kstrtab_rtnl_set_sk_err
+c03bdaa3 r __kstrtab_net_msg_warn
+c03bdab0 r __kstrtab_net_ratelimit
+c03bdabe r __kstrtab_in_aton
+c03bdac6 r __kstrtab_in4_pton
+c03bdacf r __kstrtab_in6_pton
+c03bdad8 r __kstrtab_linkwatch_fire_event
+c03bdaed r __kstrtab_sk_chk_filter
+c03bdafb r __kstrtab_sk_run_filter
+c03bdb09 r __kstrtab_flow_cache_genid
+c03bdb1a r __kstrtab_flow_cache_lookup
+c03bdb2c r __kstrtab_fib_rules_register
+c03bdb3f r __kstrtab_fib_rules_unregister
+c03bdb54 r __kstrtab_fib_rules_lookup
+c03bdb65 r __kstrtab_eth_type_trans
+c03bdb74 r __kstrtab_ether_setup
+c03bdb80 r __kstrtab_alloc_etherdev
+c03bdb8f r __kstrtab_netif_carrier_on
+c03bdba0 r __kstrtab_netif_carrier_off
+c03bdbb2 r __kstrtab_noop_qdisc
+c03bdbbd r __kstrtab_qdisc_create_dflt
+c03bdbcf r __kstrtab_qdisc_destroy
+c03bdbdd r __kstrtab_qdisc_reset
+c03bdbe9 r __kstrtab_qdisc_lock_tree
+c03bdbf9 r __kstrtab_qdisc_unlock_tree
+c03bdc0b r __kstrtab_qdisc_watchdog_init
+c03bdc1f r __kstrtab_qdisc_watchdog_schedule
+c03bdc37 r __kstrtab_qdisc_watchdog_cancel
+c03bdc4d r __kstrtab_qdisc_tree_decrease_qlen
+c03bdc66 r __kstrtab_tcf_destroy_chain
+c03bdc78 r __kstrtab_qdisc_get_rtab
+c03bdc87 r __kstrtab_qdisc_put_rtab
+c03bdc96 r __kstrtab_register_qdisc
+c03bdca5 r __kstrtab_unregister_qdisc
+c03bdcb6 r __kstrtab_tc_classify
+c03bdcc2 r __kstrtab_register_tcf_proto_ops
+c03bdcd9 r __kstrtab_unregister_tcf_proto_ops
+c03bdcf2 r __kstrtab_tcf_exts_validate
+c03bdd04 r __kstrtab_tcf_exts_destroy
+c03bdd15 r __kstrtab_tcf_exts_change
+c03bdd25 r __kstrtab_tcf_exts_dump
+c03bdd33 r __kstrtab_tcf_exts_dump_stats
+c03bdd47 r __kstrtab_bfifo_qdisc_ops
+c03bdd57 r __kstrtab_pfifo_qdisc_ops
+c03bdd67 r __kstrtab_netlink_has_listeners
+c03bdd7d r __kstrtab_netlink_ack
+c03bdd89 r __kstrtab_netlink_run_queue
+c03bdd9b r __kstrtab_netlink_broadcast
+c03bddad r __kstrtab_netlink_dump_start
+c03bddc0 r __kstrtab_netlink_kernel_create
+c03bddd6 r __kstrtab_netlink_register_notifier
+c03bddf0 r __kstrtab_netlink_set_nonroot
+c03bde04 r __kstrtab_netlink_unicast
+c03bde14 r __kstrtab_netlink_unregister_notifier
+c03bde30 r __kstrtab_nlmsg_notify
+c03bde3d r __kstrtab_nla_validate
+c03bde4a r __kstrtab_nla_parse
+c03bde54 r __kstrtab_nla_find
+c03bde5d r __kstrtab_nla_strlcpy
+c03bde69 r __kstrtab___nla_reserve
+c03bde77 r __kstrtab___nla_reserve_nohdr
+c03bde8b r __kstrtab_nla_reserve
+c03bde97 r __kstrtab_nla_reserve_nohdr
+c03bdea9 r __kstrtab___nla_put
+c03bdeb3 r __kstrtab___nla_put_nohdr
+c03bdec3 r __kstrtab_nla_put
+c03bdecb r __kstrtab_nla_put_nohdr
+c03bded9 r __kstrtab_nla_memcpy
+c03bdee4 r __kstrtab_nla_memcmp
+c03bdeef r __kstrtab_nla_strcmp
+c03bdefa r __kstrtab_genl_sock
+c03bdf04 r __kstrtab_genl_register_ops
+c03bdf16 r __kstrtab_genl_unregister_ops
+c03bdf2a r __kstrtab_genl_register_family
+c03bdf3f r __kstrtab_genl_unregister_family
+c03bdf60 r __kstrtab_nf_afinfo
+c03bdf6a r __kstrtab_nf_register_afinfo
+c03bdf7d r __kstrtab_nf_unregister_afinfo
+c03bdf92 r __kstrtab_nf_hooks
+c03bdf9b r __kstrtab_nf_register_hook
+c03bdfac r __kstrtab_nf_unregister_hook
+c03bdfbf r __kstrtab_nf_register_hooks
+c03bdfd1 r __kstrtab_nf_unregister_hooks
+c03bdfe5 r __kstrtab_nf_hook_slow
+c03bdff2 r __kstrtab_skb_make_writable
+c03be004 r __kstrtab_nf_proto_csum_replace4
+c03be01b r __kstrtab_ip_ct_attach
+c03be028 r __kstrtab_nf_ct_attach
+c03be035 r __kstrtab_nf_ct_destroy
+c03be043 r __kstrtab_nf_conntrack_destroy
+c03be058 r __kstrtab_nf_log_register
+c03be068 r __kstrtab_nf_log_unregister_pf
+c03be07d r __kstrtab_nf_log_unregister
+c03be08f r __kstrtab_nf_log_packet
+c03be09d r __kstrtab_nf_register_queue_handler
+c03be0b7 r __kstrtab_nf_unregister_queue_handler
+c03be0d3 r __kstrtab_nf_unregister_queue_handlers
+c03be0f0 r __kstrtab_nf_reinject
+c03be0fc r __kstrtab_nf_register_sockopt
+c03be110 r __kstrtab_nf_unregister_sockopt
+c03be126 r __kstrtab_nf_setsockopt
+c03be134 r __kstrtab_nf_getsockopt
+c03be160 r __kstrtab_nf_register_sysctl_table
+c03be179 r __kstrtab_nf_unregister_sysctl_table
+c03be194 r __kstrtab_nf_net_netfilter_sysctl_path
+c03be1c0 r __kstrtab_nf_net_ipv4_netfilter_sysctl_path
+c03be200 r __kstrtab___ip_route_output_key
+c03be216 r __kstrtab_ip_route_output_flow
+c03be22b r __kstrtab___ip_select_ident
+c03be23d r __kstrtab_ip_route_input
+c03be24c r __kstrtab_ip_route_output_key
+c03be260 r __kstrtab_inet_add_protocol
+c03be272 r __kstrtab_inet_del_protocol
+c03be284 r __kstrtab_ip_statistics
+c03be292 r __kstrtab_ip_defrag
+c03be29c r __kstrtab_ip_build_and_send_pkt
+c03be2b2 r __kstrtab_ip_fragment
+c03be2be r __kstrtab_ip_generic_getfrag
+c03be2d1 r __kstrtab_ip_queue_xmit
+c03be2df r __kstrtab_ip_send_check
+c03be2ed r __kstrtab_ip_cmsg_recv
+c03be2fa r __kstrtab_ip_getsockopt
+c03be308 r __kstrtab_ip_setsockopt
+c03be316 r __kstrtab_inet_put_port
+c03be324 r __kstrtab_inet_listen_wlock
+c03be336 r __kstrtab___inet_lookup_listener
+c03be34d r __kstrtab_inet_hash_connect
+c03be35f r __kstrtab___inet_twsk_kill
+c03be370 r __kstrtab___inet_twsk_hashdance
+c03be386 r __kstrtab_inet_twsk_alloc
+c03be396 r __kstrtab_inet_twdr_hangman
+c03be3a8 r __kstrtab_inet_twdr_twkill_work
+c03be3be r __kstrtab_inet_twsk_deschedule
+c03be3d3 r __kstrtab_inet_twsk_schedule
+c03be3e6 r __kstrtab_inet_twdr_twcal_tick
+c03be400 r __kstrtab_inet_csk_timer_bug_msg
+c03be417 r __kstrtab_inet_csk_bind_conflict
+c03be42e r __kstrtab_inet_csk_get_port
+c03be440 r __kstrtab_inet_csk_accept
+c03be450 r __kstrtab_inet_csk_init_xmit_timers
+c03be46a r __kstrtab_inet_csk_clear_xmit_timers
+c03be4a0 r __kstrtab_inet_csk_delete_keepalive_timer
+c03be4c0 r __kstrtab_inet_csk_reset_keepalive_timer
+c03be4df r __kstrtab_inet_csk_route_req
+c03be4f2 r __kstrtab_inet_csk_search_req
+c03be506 r __kstrtab_inet_csk_reqsk_queue_hash_add
+c03be524 r __kstrtab_inet_csk_reqsk_queue_prune
+c03be53f r __kstrtab_inet_csk_clone
+c03be54e r __kstrtab_inet_csk_destroy_sock
+c03be564 r __kstrtab_inet_csk_listen_start
+c03be57a r __kstrtab_inet_csk_listen_stop
+c03be58f r __kstrtab_inet_csk_addr2sockaddr
+c03be5a6 r __kstrtab_inet_csk_ctl_sock_create
+c03be5bf r __kstrtab_tcp_orphan_count
+c03be5d0 r __kstrtab_sysctl_tcp_mem
+c03be5df r __kstrtab_sysctl_tcp_rmem
+c03be5ef r __kstrtab_sysctl_tcp_wmem
+c03be5ff r __kstrtab_tcp_memory_allocated
+c03be614 r __kstrtab_tcp_sockets_allocated
+c03be62a r __kstrtab_tcp_memory_pressure
+c03be63e r __kstrtab_tcp_enter_memory_pressure
+c03be658 r __kstrtab_tcp_get_info
+c03be665 r __kstrtab_tcp_tso_segment
+c03be675 r __kstrtab_tcp_done
+c03be67e r __kstrtab_tcp_close
+c03be688 r __kstrtab_tcp_disconnect
+c03be697 r __kstrtab_tcp_getsockopt
+c03be6a6 r __kstrtab_tcp_ioctl
+c03be6b0 r __kstrtab_tcp_poll
+c03be6b9 r __kstrtab_tcp_read_sock
+c03be6c7 r __kstrtab_tcp_recvmsg
+c03be6d3 r __kstrtab_tcp_sendmsg
+c03be6df r __kstrtab_tcp_sendpage
+c03be6ec r __kstrtab_tcp_setsockopt
+c03be6fb r __kstrtab_tcp_shutdown
+c03be708 r __kstrtab_tcp_statistics
+c03be717 r __kstrtab_sysctl_tcp_ecn
+c03be726 r __kstrtab_sysctl_tcp_reordering
+c03be73c r __kstrtab_tcp_parse_options
+c03be74e r __kstrtab_tcp_rcv_established
+c03be762 r __kstrtab_tcp_rcv_state_process
+c03be778 r __kstrtab_tcp_initialize_rcv_mss
+c03be78f r __kstrtab_tcp_connect
+c03be79b r __kstrtab_tcp_make_synack
+c03be7ab r __kstrtab_tcp_simple_retransmit
+c03be7c1 r __kstrtab_tcp_sync_mss
+c03be7ce r __kstrtab_sysctl_tcp_tso_win_divisor
+c03be7e9 r __kstrtab_tcp_mtup_init
+c03be7f7 r __kstrtab_tcp_init_xmit_timers
+c03be80c r __kstrtab_tcp_twsk_unique
+c03be81c r __kstrtab_tcp_v4_destroy_sock
+c03be830 r __kstrtab_ipv4_specific
+c03be83e r __kstrtab_tcp_hashinfo
+c03be84b r __kstrtab_tcp_prot
+c03be854 r __kstrtab_tcp_unhash
+c03be85f r __kstrtab_tcp_v4_conn_request
+c03be873 r __kstrtab_tcp_v4_connect
+c03be882 r __kstrtab_tcp_v4_do_rcv
+c03be890 r __kstrtab_tcp_v4_remember_stamp
+c03be8a6 r __kstrtab_tcp_v4_send_check
+c03be8b8 r __kstrtab_tcp_v4_syn_recv_sock
+c03be8cd r __kstrtab_tcp_proc_register
+c03be8df r __kstrtab_tcp_proc_unregister
+c03be8f3 r __kstrtab_sysctl_tcp_low_latency
+c03be90a r __kstrtab_tcp_death_row
+c03be918 r __kstrtab_tcp_twsk_destructor
+c03be92c r __kstrtab_tcp_check_req
+c03be93a r __kstrtab_tcp_child_process
+c03be94c r __kstrtab_tcp_create_openreq_child
+c03be965 r __kstrtab_tcp_timewait_state_process
+c03be980 r __kstrtab_tcp_register_congestion_control
+c03be9a0 r __kstrtab_tcp_unregister_congestion_control
+c03be9c2 r __kstrtab_tcp_slow_start
+c03be9d1 r __kstrtab_tcp_reno_cong_avoid
+c03be9e5 r __kstrtab_tcp_reno_ssthresh
+c03be9f7 r __kstrtab_tcp_reno_min_cwnd
+c03bea09 r __kstrtab_tcp_init_congestion_ops
+c03bea21 r __kstrtab_ip4_datagram_connect
+c03bea36 r __kstrtab_udp_disconnect
+c03bea45 r __kstrtab_udp_hash
+c03bea4e r __kstrtab_udp_hash_lock
+c03bea5c r __kstrtab_udp_ioctl
+c03bea66 r __kstrtab_udp_get_port
+c03bea73 r __kstrtab_udp_prot
+c03bea7c r __kstrtab_udp_sendmsg
+c03bea88 r __kstrtab_udp_lib_getsockopt
+c03bea9b r __kstrtab_udp_lib_setsockopt
+c03beaae r __kstrtab_udp_poll
+c03beab7 r __kstrtab_udp_proc_register
+c03beac9 r __kstrtab_udp_proc_unregister
+c03beadd r __kstrtab_udplite_hash
+c03beaea r __kstrtab_udplite_prot
+c03beaf7 r __kstrtab_udplite_get_port
+c03beb08 r __kstrtab_arp_broken_ops
+c03beb17 r __kstrtab_arp_find
+c03beb20 r __kstrtab_arp_create
+c03beb2b r __kstrtab_arp_xmit
+c03beb34 r __kstrtab_arp_send
+c03beb3d r __kstrtab_arp_tbl
+c03beb45 r __kstrtab_icmp_err_convert
+c03beb56 r __kstrtab_icmp_send
+c03beb60 r __kstrtab_icmp_statistics
+c03beb70 r __kstrtab_xrlim_allow
+c03beb7c r __kstrtab_in_dev_finish_destroy
+c03beb92 r __kstrtab_inet_select_addr
+c03beba3 r __kstrtab_inetdev_by_index
+c03bebb4 r __kstrtab_register_inetaddr_notifier
+c03bebcf r __kstrtab_unregister_inetaddr_notifier
+c03bebec r __kstrtab_inet_ehash_secret
+c03bebfe r __kstrtab_build_ehash_secret
+c03bec11 r __kstrtab_inet_sk_rebuild_header
+c03bec28 r __kstrtab_snmp_fold_field
+c03bec38 r __kstrtab_snmp_mib_init
+c03bec46 r __kstrtab_snmp_mib_free
+c03bec54 r __kstrtab_inet_accept
+c03bec60 r __kstrtab_inet_bind
+c03bec6a r __kstrtab_inet_dgram_connect
+c03bec7d r __kstrtab_inet_dgram_ops
+c03bec8c r __kstrtab_inet_getname
+c03bec99 r __kstrtab_inet_ioctl
+c03beca4 r __kstrtab_inet_listen
+c03becb0 r __kstrtab_inet_register_protosw
+c03becc6 r __kstrtab_inet_release
+c03becd3 r __kstrtab_inet_sendmsg
+c03bece0 r __kstrtab_inet_shutdown
+c03becee r __kstrtab_inet_sock_destruct
+c03bed01 r __kstrtab_inet_stream_connect
+c03bed15 r __kstrtab_inet_stream_ops
+c03bed25 r __kstrtab_inet_unregister_protosw
+c03bed3d r __kstrtab_net_statistics
+c03bed4c r __kstrtab_ip_mc_dec_group
+c03bed5c r __kstrtab_ip_mc_inc_group
+c03bed6c r __kstrtab_ip_mc_join_group
+c03bed7d r __kstrtab_ip_mc_rejoin_group
+c03bed90 r __kstrtab_inet_addr_type
+c03bed9f r __kstrtab_ip_dev_find
+c03bedab r __kstrtab_xfrm4_tunnel_register
+c03bedc1 r __kstrtab_xfrm4_tunnel_deregister
+c03bedd9 r __kstrtab_ip_route_me_harder
+c03bedec r __kstrtab_ip_xfrm_me_harder
+c03bedfe r __kstrtab_ip_nat_decode_session
+c03bee14 r __kstrtab_nf_ip_checksum
+c03bee23 r __kstrtab_xfrm4_rcv
+c03bee2d r __kstrtab_xfrm_cfg_mutex
+c03bee3c r __kstrtab_xfrm_policy_count
+c03bee4e r __kstrtab_xfrm_register_type
+c03bee61 r __kstrtab_xfrm_unregister_type
+c03bee76 r __kstrtab_xfrm_dst_lookup
+c03bee86 r __kstrtab_xfrm_register_mode
+c03bee99 r __kstrtab_xfrm_unregister_mode
+c03beeae r __kstrtab_xfrm_policy_alloc
+c03beec0 r __kstrtab___xfrm_policy_destroy
+c03beed6 r __kstrtab_xfrm_spd_getinfo
+c03beee7 r __kstrtab_xfrm_policy_insert
+c03beefa r __kstrtab_xfrm_policy_bysel_ctx
+c03bef10 r __kstrtab_xfrm_policy_byid
+c03bef21 r __kstrtab_xfrm_policy_flush
+c03bef33 r __kstrtab_xfrm_policy_walk
+c03bef44 r __kstrtab_xfrm_policy_delete
+c03bef57 r __kstrtab___xfrm_lookup
+c03bef65 r __kstrtab_xfrm_lookup
+c03bef71 r __kstrtab_xfrm_decode_session
+c03bef85 r __kstrtab___xfrm_policy_check
+c03bef99 r __kstrtab___xfrm_route_forward
+c03befae r __kstrtab_xfrm_dst_ifdown
+c03befbe r __kstrtab_xfrm_init_pmtu
+c03befcd r __kstrtab_xfrm_bundle_ok
+c03befdc r __kstrtab_xfrm_policy_register_afinfo
+c03beff8 r __kstrtab_xfrm_policy_unregister_afinfo
+c03bf016 r __kstrtab_xfrm_nl
+c03bf01e r __kstrtab_km_waitq
+c03bf027 r __kstrtab_xfrm_state_alloc
+c03bf038 r __kstrtab___xfrm_state_destroy
+c03bf04d r __kstrtab___xfrm_state_delete
+c03bf061 r __kstrtab_xfrm_state_delete
+c03bf073 r __kstrtab_xfrm_state_flush
+c03bf084 r __kstrtab_xfrm_sad_getinfo
+c03bf095 r __kstrtab_xfrm_state_insert
+c03bf0a7 r __kstrtab_xfrm_state_add
+c03bf0b6 r __kstrtab_xfrm_state_update
+c03bf0c8 r __kstrtab_xfrm_state_check_expire
+c03bf0e0 r __kstrtab_xfrm_state_check
+c03bf0f1 r __kstrtab_xfrm_state_lookup
+c03bf103 r __kstrtab_xfrm_state_lookup_byaddr
+c03bf11c r __kstrtab_xfrm_find_acq
+c03bf12a r __kstrtab_xfrm_find_acq_byseq
+c03bf13e r __kstrtab_xfrm_get_acqseq
+c03bf14e r __kstrtab_xfrm_alloc_spi
+c03bf15d r __kstrtab_xfrm_state_walk
+c03bf16d r __kstrtab_xfrm_replay_notify
+c03bf180 r __kstrtab_xfrm_replay_check
+c03bf192 r __kstrtab_xfrm_replay_advance
+c03bf1a6 r __kstrtab_km_policy_notify
+c03bf1b7 r __kstrtab_km_state_notify
+c03bf1c7 r __kstrtab_km_state_expired
+c03bf1d8 r __kstrtab_km_query
+c03bf1e1 r __kstrtab_km_new_mapping
+c03bf1f0 r __kstrtab_km_policy_expired
+c03bf202 r __kstrtab_km_migrate
+c03bf20d r __kstrtab_km_report
+c03bf217 r __kstrtab_xfrm_user_policy
+c03bf228 r __kstrtab_xfrm_register_km
+c03bf239 r __kstrtab_xfrm_unregister_km
+c03bf24c r __kstrtab_xfrm_state_register_afinfo
+c03bf267 r __kstrtab_xfrm_state_unregister_afinfo
+c03bf284 r __kstrtab_xfrm_state_get_afinfo
+c03bf29a r __kstrtab_xfrm_state_put_afinfo
+c03bf2b0 r __kstrtab_xfrm_state_delete_tunnel
+c03bf2c9 r __kstrtab_xfrm_init_state
+c03bf2d9 r __kstrtab___secpath_destroy
+c03bf2eb r __kstrtab_secpath_dup
+c03bf2f7 r __kstrtab_xfrm_parse_spi
+c03bf306 r __kstrtab_xfrm_aalg_get_byid
+c03bf319 r __kstrtab_xfrm_ealg_get_byid
+c03bf32c r __kstrtab_xfrm_calg_get_byid
+c03bf33f r __kstrtab_xfrm_aalg_get_byname
+c03bf354 r __kstrtab_xfrm_ealg_get_byname
+c03bf369 r __kstrtab_xfrm_calg_get_byname
+c03bf37e r __kstrtab_xfrm_aalg_get_byidx
+c03bf392 r __kstrtab_xfrm_ealg_get_byidx
+c03bf3a6 r __kstrtab_xfrm_probe_algs
+c03bf3b6 r __kstrtab_xfrm_count_auth_supported
+c03bf3d0 r __kstrtab_xfrm_count_enc_supported
+c03bf3e9 r __kstrtab_skb_icv_walk
+c03bf3f6 r __kstrtab_inet6_bind
+c03bf401 r __kstrtab_inet6_release
+c03bf40f r __kstrtab_inet6_destroy_sock
+c03bf422 r __kstrtab_inet6_getname
+c03bf430 r __kstrtab_inet6_ioctl
+c03bf43c r __kstrtab_inet6_register_protosw
+c03bf453 r __kstrtab_inet6_unregister_protosw
+c03bf46c r __kstrtab_inet6_sk_rebuild_header
+c03bf484 r __kstrtab_ipv6_opt_accepted
+c03bf496 r __kstrtab_ip6_xmit
+c03bf49f r __kstrtab_ip6_find_1stfragopt
+c03bf4b3 r __kstrtab_ip6_dst_lookup
+c03bf4c2 r __kstrtab_ip6_sk_dst_lookup
+c03bf4d4 r __kstrtab_in6_dev_finish_destroy
+c03bf4eb r __kstrtab_ipv6_get_saddr
+c03bf4fa r __kstrtab_ipv6_chk_addr
+c03bf508 r __kstrtab_register_inet6addr_notifier
+c03bf524 r __kstrtab_unregister_inet6addr_notifier
+c03bf542 r __kstrtab_rt6_lookup
+c03bf54d r __kstrtab_ip6_route_output
+c03bf55e r __kstrtab_ip6_dst_blackhole
+c03bf570 r __kstrtab_ipv6_setsockopt
+c03bf580 r __kstrtab_ipv6_getsockopt
+c03bf590 r __kstrtab_ndisc_mc_map
+c03bf59d r __kstrtab_inet6_add_protocol
+c03bf5b0 r __kstrtab_inet6_del_protocol
+c03bf5c3 r __kstrtab_icmpv6_statistics
+c03bf5d5 r __kstrtab_icmpv6_send
+c03bf5e1 r __kstrtab_icmpv6_err_convert
+c03bf5f4 r __kstrtab_ipv6_find_tlv
+c03bf602 r __kstrtab_ipv6_invert_rthdr
+c03bf614 r __kstrtab_ipv6_push_nfrag_opts
+c03bf629 r __kstrtab_ipv6_dup_options
+c03bf63a r __kstrtab_fl6_sock_lookup
+c03bf64a r __kstrtab_inet6_csk_bind_conflict
+c03bf662 r __kstrtab_inet6_csk_search_req
+c03bf677 r __kstrtab_inet6_csk_reqsk_queue_hash_add
+c03bf696 r __kstrtab_inet6_csk_addr2sockaddr
+c03bf6ae r __kstrtab_inet6_csk_xmit
+c03bf6bd r __kstrtab_xfrm6_rcv_spi
+c03bf6cb r __kstrtab_xfrm6_rcv
+c03bf6d5 r __kstrtab_xfrm6_input_addr
+c03bf6e6 r __kstrtab_xfrm6_find_1stfragopt
+c03bf6fc r __kstrtab_ip6_route_me_harder
+c03bf710 r __kstrtab_nf_ip6_checksum
+c03bf720 r __kstrtab___ipv6_addr_type
+c03bf731 r __kstrtab_ipv6_ext_hdr
+c03bf73e r __kstrtab_ipv6_skip_exthdr
+c03bf74f r __kstrtab___inet6_hash
+c03bf75c r __kstrtab___inet6_lookup_established
+c03bf777 r __kstrtab_inet6_lookup_listener
+c03bf78d r __kstrtab_inet6_lookup
+c03bf79a r __kstrtab_inet6_hash_connect
+c03bf7ad r __kstrtab_wireless_send_event
+c03bf7c1 r __kstrtab_iw_handler_set_spy
+c03bf7d4 r __kstrtab_iw_handler_get_spy
+c03bf7e7 r __kstrtab_iw_handler_set_thrspy
+c03bf7fd r __kstrtab_iw_handler_get_thrspy
+c03bf813 r __kstrtab_wireless_spy_update
+c03bf827 r __kstrtab_klist_init
+c03bf832 r __kstrtab_klist_add_head
+c03bf841 r __kstrtab_klist_add_tail
+c03bf850 r __kstrtab_klist_del
+c03bf85a r __kstrtab_klist_remove
+c03bf867 r __kstrtab_klist_node_attached
+c03bf87b r __kstrtab_klist_iter_init_node
+c03bf890 r __kstrtab_klist_iter_init
+c03bf8a0 r __kstrtab_klist_iter_exit
+c03bf8b0 r __kstrtab_klist_next
+c03bf8bb r __kstrtab_sha_transform
+c03bf8cc r __param_show
+c03bf8cc R __start___param
+c03bf8e0 r __param_printk_time
+c03bf8f4 r __param_blimit
+c03bf908 r __param_qhimark
+c03bf91c r __param_qlowmark
+c03bf930 r __param_forceload
+c03bf944 r __param_acpica_version
+c03bf958 r __param_brl_timeout
+c03bf96c r __param_brl_nbchords
+c03bf980 r __param_default_utf8
+c03bf994 r __param_default_red
+c03bf9a8 r __param_default_grn
+c03bf9bc r __param_default_blu
+c03bf9d0 r __param_italic
+c03bf9e4 r __param_underline
+c03bf9f8 r __param_no_fwh_detect
+c03bfa0c r __param_hangcheck_tick
+c03bfa20 r __param_hangcheck_margin
+c03bfa34 r __param_hangcheck_reboot
+c03bfa48 r __param_hangcheck_dump_tasks
+c03bfa5c r __param_share_irqs
+c03bfa70 r __param_nr_uarts
+c03bfa84 r __param_probe_rsa
+c03bfa98 r __param_rd_size
+c03bfaac r __param_rd_blocksize
+c03bfac0 r __param_newif
+c03bfad4 r __param_delif
+c03bfae8 r __param_noraid
+c03bfafc r __param_all_generic_ide
+c03bfb10 r __param_ignore
+c03bfb24 r __param_debug
+c03bfb38 r __param_autoclose
+c03bfb4c r __param_autoeject
+c03bfb60 r __param_lockdoor
+c03bfb74 r __param_check_media_type
+c03bfb88 r __param_mrw_format_restart
+c03bfb9c r __param_nousb
+c03bfbb0 r __param_blinkenlights
+c03bfbc4 r __param_old_scheme_first
+c03bfbd8 r __param_use_both_schemes
+c03bfbec r __param_usbfs_snoop
+c03bfc00 r __param_bias
+c03bfc14 r __param_nokbd
+c03bfc28 r __param_noaux
+c03bfc3c r __param_nomux
+c03bfc50 r __param_unlock
+c03bfc64 r __param_reset
+c03bfc78 r __param_direct
+c03bfc8c r __param_dumbkbd
+c03bfca0 r __param_noloop
+c03bfcb4 r __param_panicblink
+c03bfcc8 r __param_nopnp
+c03bfcdc r __param_debug
+c03bfcf0 r __param_xres
+c03bfd04 r __param_yres
+c03bfd18 r __param_tap_time
+c03bfd2c r __param_set
+c03bfd40 r __param_reset
+c03bfd54 r __param_softrepeat
+c03bfd68 r __param_softraw
+c03bfd7c r __param_scroll
+c03bfd90 r __param_extra
+c03bfda4 r __param_proto
+c03bfdb8 r __param_resolution
+c03bfdcc r __param_rate
+c03bfde0 r __param_smartscroll
+c03bfdf4 r __param_resetafter
+c03bfe08 r __param_resync_time
+c03bfe1c r __param_start_ro
+c03bfe30 r __param_start_dirty_degraded
+c03bfe44 r __param_major
+c03bfe58 r __param_pb_fnmode
+c03bfe6c r __param_mousepoll
+c03bfe80 r __param_quirks
+c03bfe94 r __param_fast_convergence
+c03bfea8 r __param_max_increment
+c03bfebc r __param_beta
+c03bfed0 r __param_initial_ssthresh
+c03bfee4 r __param_bic_scale
+c03bfef8 r __param_tcp_friendliness
+c03bff0c R __end_rodata
+c03bff0c R __stop___param
+c03c0000 D stack_start
+c03c0008 d ready
+c03c0009 d early_recursion_flag
+c03c000d d int_msg
+c03c0039 d fault_msg
+c03c008e D boot_gdt_descr
+c03c0096 D idt_descr
+c03c00a0 D early_gdt_descr
+c03c0100 D boot_gdt
+c03c0180 D init_mm
+c03c0380 D init_task
+c03c08e0 d init_fs
+c03c0980 d init_files
+c03c0b00 d init_signals
+c03c0ca0 d init_sighand
+c03c11c0 D envp_init
+c03c1248 D loops_per_jiffy
+c03c1260 d argv_init
+c03c12e8 d max_cpus
+c03c1300 D init_uts_ns
+c03c148c D root_mountflags
+c03c1490 d argv.14999
+c03c14a0 D genapic
+c03c14c0 D apic_summit
+c03c1560 D apic_bigsmp
+c03c15ec d cpu.4885
+c03c1600 d bigsmp_dmi_table
+c03c16a0 D apic_es7000
+c03c1740 D apic_default
+c03c1800 D interrupt
+c03c1b80 D kstack_depth_to_print
+c03c1b84 d code_bytes
+c03c1b88 d nmi_print_lock
+c03c1b98 d die.19656
+c03c1bb0 d print_trace_ops
+c03c1bc0 D rtc_lock
+c03c1bd0 d sync_cmos_timer
+c03c1be8 d highmem_pages
+c03c1c00 D i8259A_lock
+c03c1c10 D cached_irq_mask
+c03c1c20 d i8259_sysdev_class
+c03c1ca0 d device_i8259A
+c03c1d00 d fpu_irq
+c03c1d20 d i8259A_chip
+c03c1d60 D pci_mem_start
+c03c1d80 D data_resource
+c03c1dc0 D code_resource
+c03c1e00 d video_ram_resource
+c03c1e40 d standard_io_resources
+c03c1fa0 d adapter_rom_resources
+c03c2080 d video_rom_resource
+c03c20c0 d system_rom_resource
+c03c2100 d extension_rom_resource
+c03c2140 d i8237_sysdev_class
+c03c21c0 d device_i8237A
+c03c2220 d intelnops
+c03c2244 d k8nops
+c03c2268 d k7nops
+c03c22a0 d intel_nops
+c03c22c4 d smp_alt
+c03c22d4 d smp_alt_modules
+c03c22e0 d k8_nops
+c03c2320 d k7_nops
+c03c2380 D i8253_lock
+c03c23a0 D pit_clockevent
+c03c2400 d clocksource_pit
+c03c2500 d clocksource_tsc
+c03c2600 D cpuinfo_op
+c03c2620 d ktype_percpu_entry
+c03c262c d ktype_cache
+c03c2638 d sysfs_ops
+c03c2640 d default_attrs
+c03c2664 d type
+c03c2678 d level
+c03c268c d coherency_line_size
+c03c26a0 d physical_line_partition
+c03c26b4 d ways_of_associativity
+c03c26c8 d number_of_sets
+c03c26dc d size
+c03c26f0 d shared_cpu_map
+c03c2704 D machine_check_vector
+c03c2708 d vendor_thermal_interrupt
+c03c270c d thermal_throttle_attr_group
+c03c2714 d thermal_throttle_attrs
+c03c271c d attr_count
+c03c2740 d mtrr_sysdev_driver
+c03c275c d mtrr_mutex
+c03c2780 D generic_mtrr_ops
+c03c27a0 d set_atomicity_lock
+c03c27b0 d __param_str_show
+c03c27c0 d amd_mtrr_ops
+c03c27e0 d cyrix_mtrr_ops
+c03c2800 d centaur_mtrr_ops
+c03c2820 d k7_wd_ops
+c03c2860 d intel_arch_wd_ops
+c03c28a0 d p6_wd_ops
+c03c28e0 d p4_wd_ops
+c03c2920 D machine_ops
+c03c2938 d jump_to_bios
+c03c2940 d reboot_cpu
+c03c2960 d real_mode_switch
+c03c298b d real_mode_idt
+c03c2993 d real_mode_gdt
+c03c29a0 d real_mode_gdt_entries
+c03c29b8 D smp_ops
+c03c29d4 d call_lock
+c03c29e4 d tlbstate_lock
+c03c29f4 D smp_num_siblings
+c03c2a00 D mp_bus_id_to_pci_bus
+c03c2e10 D boot_cpu_physical_apicid
+c03c2e14 D bios_cpu_apicid
+c03c2e24 d pci_irq.21808
+c03c2e40 d lapic_sysclass
+c03c2ec0 d device_lapic
+c03c2f20 d lapic_clockevent
+c03c2f80 D nmi_watchdog
+c03c2fa0 d nmi_sysclass
+c03c3020 d device_lapic_nmi
+c03c3074 d nmi_hz
+c03c3078 d lock.17234
+c03c30a0 D sis_apic_bug
+c03c30c0 d ioapic_sysdev_class
+c03c3140 d ioapic_lock
+c03c3150 d first_free_entry.22706
+c03c3154 d vector_lock
+c03c3164 d current_vector.23161
+c03c3180 d ht_irq_chip
+c03c31c0 d msi_chip
+c03c3200 d ioapic_i8259
+c03c3208 d crash_nmi_nb
+c03c3214 d efi_rt_lock
+c03c3224 d saved_return_addr
+c03c3228 d efi_rt_function_ptr
+c03c322c d irqbits_lock
+c03c3240 D early_console
+c03c3260 d early_vga_console
+c03c3294 d current_ypos
+c03c3298 d max_ypos
+c03c329c d max_xpos
+c03c32a0 d early_serial_console
+c03c32e0 d simnow_console
+c03c3314 d early_serial_base
+c03c3380 d hpet_class
+c03c3400 d hpet_device
+c03c3460 d hpet_clockevent
+c03c3500 d clocksource_hpet
+c03c3600 D __VMALLOC_RESERVE
+c03c3608 D __PAGE_KERNEL
+c03c3610 D __PAGE_KERNEL_EXEC
+c03c3618 D __FIXADDR_TOP
+c03c361c D pgd_lock
+c03c362c D show_unhandled_signals
+c03c3630 d start.19309
+c03c3634 d notify_page_fault_chain
+c03c3648 d cpa_lock
+c03c3658 d df_list
+c03c3660 d irq0
+c03c3680 d irq2
+c03c3700 D attr_sched_mc_power_savings
+c03c3714 D attr_sched_smt_power_savings
+c03c3728 d migration_factor
+c03c3740 d migration_cost
+c03c3840 d balancing
+c03c3850 d sched_hotcpu_mutex
+c03c3880 D default_exec_domain
+c03c38ac d exec_domains_lock
+c03c38bc d exec_domains
+c03c38c0 d ident_map
+c03c3940 D panic_notifier_list
+c03c3954 d pause_on_oops_lock
+c03c3980 D log_wait
+c03c3998 D console_printk
+c03c39a8 D printk_ratelimit_jiffies
+c03c39ac D printk_ratelimit_burst
+c03c39b0 d log_buf_len
+c03c39b4 d logbuf_lock
+c03c39c4 d log_buf
+c03c39c8 d toks.25918
+c03c39cc d ratelimit_lock.25916
+c03c39dc d preferred_console
+c03c39e0 d selected_console
+c03c3a00 d console_sem
+c03c3a20 d secondary_console_sem
+c03c3a40 d msg_level.25429
+c03c3a44 d printk_cpu
+c03c3a48 d log_level_unknown.25561
+c03c3a4c d __param_str_printk_time
+c03c3a60 d profile_flip_mutex
+c03c3a7c d prof_cpu_mask
+c03c3a80 d task_exit_notifier
+c03c3aa0 d munmap_notifier
+c03c3ac0 d task_free_notifier
+c03c3ad4 d lowest_to_date.29713
+c03c3ad8 d low_water_lock.29711
+c03c3ae8 d firsttime.23842
+c03c3b00 D ioport_resource
+c03c3b40 D iomem_resource
+c03c3b64 d resource_lock
+c03c3b80 d root_table
+c03c3cb4 d sysctl_lock
+c03c3cc4 d root_table_header
+c03c3ce0 d kern_table
+c03c42c0 d vm_table
+c03c46a0 d fs_table
+c03c4960 d debug_table
+c03c49b8 d maxolduid
+c03c49bc d ngroups_max
+c03c49c0 d one_hundred
+c03c49c4 d min_percpu_pagelist_fract
+c03c49c8 D cap_bset
+c03c49cc d task_capability_lock
+c03c49dc d count.20411
+c03c49e0 D root_user
+c03c4a10 d uidhash_lock
+c03c4a20 D init_user_ns
+c03c5240 D overflowuid
+c03c5244 D overflowgid
+c03c5248 D fs_overflowuid
+c03c524c D fs_overflowgid
+c03c5250 D C_A_D
+c03c5260 D init_groups
+c03c52ec D uts_sem
+c03c5320 D poweroff_cmd
+c03c5420 d envp.27637
+c03c542c d cad_work.26420
+c03c5440 d reboot_notifier_list
+c03c5460 D modprobe_path
+c03c5560 d envp.23942
+c03c5570 d workqueue_mutex
+c03c558c d workqueues
+c03c55a0 D init_struct_pid
+c03c55c4 D pid_max
+c03c55c8 D pid_max_min
+c03c55cc D pid_max_max
+c03c55d0 D init_pid_ns
+c03c5600 d blimit
+c03c5604 d qhimark
+c03c5608 d qlowmark
+c03c5680 d rcu_ctrlblk
+c03c5780 d rcu_bh_ctrlblk
+c03c5880 d rcu_barrier_mutex
+c03c589c d __param_str_blimit
+c03c58ac d __param_str_qhimark
+c03c58bd d __param_str_qlowmark
+c03c58e0 D module_subsys
+c03c594c d module_ktype
+c03c5958 d module_uevent_ops
+c03c5964 d module_sysfs_ops
+c03c596c d idr_lock
+c03c597c d kthread_create_list
+c03c5984 d kthread_create_lock
+c03c5994 d kthread_stop_lock
+c03c59c0 d latency_notifier
+c03c59e0 d latency_lock
+c03c59f0 d latency_list
+c03c5a00 D init_nsproxy
+c03c5a2c d die_chain
+c03c5a40 d vx_info_hash_lock
+c03c5a50 d vx_info_inactive_lock
+c03c5a60 d nx_info_hash_lock
+c03c5a70 d tokens
+c03c5a80 D vlimit_name
+c03c5ae0 D account_mask
+c03c5b00 D vshelper_path
+c03c5c00 d dl_info_hash_lock
+c03c5c20 d proc_virtual_dir_operations
+c03c5ca0 d proc_virtual_dir_inode_operations
+c03c5d00 d proc_virtnet_dir_operations
+c03c5d80 d proc_virtnet_dir_inode_operations
+c03c5de0 d nx_virtnet_stuff
+c03c5e40 d nx_base_stuff
+c03c5e88 d proc_nid_dentry_operations
+c03c5ec0 d vx_virtual_stuff
+c03c5f20 d vx_base_stuff
+c03c5fe0 d proc_xid_dentry_operations
+c03c6000 d proc_vs_info_file_operations
+c03c6080 d proc_nid_inode_operations
+c03c60e0 d proc_nid_file_operations
+c03c6160 d proc_nx_info_file_operations
+c03c61e0 d proc_xid_inode_operations
+c03c6240 d proc_xid_file_operations
+c03c62c0 d proc_vx_info_file_operations
+c03c6380 d timekeeping_sysclass
+c03c6400 d device_timer
+c03c6454 D tick_usec
+c03c6458 D time_status
+c03c645c D time_maxerror
+c03c6460 D time_esterror
+c03c6464 d time_constant
+c03c6480 d clocksource_lock
+c03c64a0 d clocksource_sysclass
+c03c6520 d device_clocksource
+c03c6574 d attr_current_clocksource
+c03c6588 d attr_available_clocksource
+c03c659c d clocksource_list
+c03c65a4 d curr_clocksource
+c03c65a8 d watchdog_lock
+c03c65b8 d watchdog_list
+c03c6600 D clocksource_jiffies
+c03c6700 d timer_list_fops
+c03c6770 d clockevents_lock
+c03c6780 d clockevents_released
+c03c6788 d clockevent_devices
+c03c6790 D tick_device_lock
+c03c67a0 d tick_notifier
+c03c67ac d tick_broadcast_lock
+c03c67c0 d futex_fs_type
+c03c67e0 D max_lock_depth
+c03c6800 D dma_spin_lock
+c03c6820 d dma_chan_busy
+c03c6860 d cpu_add_remove_lock
+c03c687c d cpu_bitmask_lock
+c03c68a0 d modules
+c03c68a8 d module_mutex
+c03c68c4 d modlist_lock
+c03c68e0 d module_notify_list
+c03c6900 d notify_mutex
+c03c6920 d modinfo_version
+c03c6940 d modinfo_srcversion
+c03c6960 d initstate
+c03c6980 d refcnt
+c03c69a0 D pm_mutex
+c03c69c0 D power_subsys
+c03c6a2c d attr_group
+c03c6a34 d g
+c03c6a3c d state_attr
+c03c6a50 d pm_devs_lock
+c03c6a6c d pm_devs
+c03c6a74 d sysrq_poweroff_op
+c03c6a84 d poweroff_work
+c03c6a94 D acct_parm
+c03c6aa0 D crashk_res
+c03c6ae0 D proc_container_operations
+c03c6b50 d container_mutex
+c03c6b6c d roots
+c03c6b74 d release_list
+c03c6b7c d release_agent_work
+c03c6b8c d container_dops.23817
+c03c6ba8 d css_group_lock
+c03c6bc0 d container_fs_type
+c03c6be0 d proc_containerstats_operations
+c03c6c60 d files
+c03c6d80 d cft_release_agent
+c03c6de0 d container_ops
+c03c6e40 d container_dir_inode_operations
+c03c6ea0 d container_file_operations
+c03c6f10 d container_backing_dev_info.23788
+c03c6f40 D cpuacct_subsys
+c03c6fa0 d files
+c03c7060 D ns_subsys
+c03c70c0 d stopmachine_mutex
+c03c70e0 D kprobe_mutex
+c03c70fc D kretprobe_lock
+c03c710c d kprobe_exceptions_nb
+c03c7120 d debugfs_kprobes_operations
+c03c71a0 d fops_kp
+c03c7210 d kprobe_page_fault_nb
+c03c721c d kprobes_seq_ops
+c03c7240 D kernel_subsys
+c03c72ac d kernel_attr_group
+c03c72b4 d kernel_attrs
+c03c72c8 d uevent_seqnum_attr
+c03c72dc d uevent_helper_attr
+c03c72f0 d kexec_loaded_attr
+c03c7304 d kexec_crash_loaded_attr
+c03c7318 d panic_block
+c03c7324 d print_lock
+c03c7340 D no_irq_chip
+c03c7380 D dummy_irq_chip
+c03c73c0 d count.11610
+c03c73c4 d probing_active
+c03c73e0 d relay_channels_mutex
+c03c73fc d relay_channels
+c03c7404 d default_channel_callbacks
+c03c7418 d relay_file_mmap_ops
+c03c7440 d uts_root_table
+c03c74a0 d uts_kern_table
+c03c7600 d bdata_list
+c03c7608 D generic_file_vm_ops
+c03c7624 d oom_lock.17064
+c03c7680 D sysctl_lowmem_reserve_ratio
+c03c7688 D min_free_kbytes
+c03c7700 D contig_page_data
+c03c9700 D dirty_background_ratio
+c03c9704 D vm_dirty_ratio
+c03c9708 D dirty_writeback_interval
+c03c970c D dirty_expire_interval
+c03c9710 d wb_timer
+c03c9728 d ratelimit_pages
+c03c972c d laptop_mode_wb_timer
+c03c9744 d pdflush_lock
+c03c9754 d pdflush_list
+c03c975c D default_backing_dev_info
+c03c9778 D vm_swappiness
+c03c977c d shrinker_rwsem
+c03c9798 d shrinker_list
+c03c97a0 d congestion_wqh
+c03c97d0 d pkmap_map_wait
+c03c97e8 d shmlock_user_lock
+c03c9800 D protection_map
+c03c9840 D sysctl_overcommit_ratio
+c03c9844 d special_mapping_vmops
+c03c9860 D vmlist_lock
+c03c9880 D swapper_space
+c03c98f8 d swap_backing_dev_info
+c03c9914 D swap_lock
+c03c9924 D swap_list
+c03c992c d swapon_mutex
+c03c9948 d swap_unplug_sem
+c03c9964 d swap_token_lock
+c03c9980 d tmpfs_fs_type
+c03c99a0 d shmem_export_ops
+c03c99b8 d shmem_swaplist_lock
+c03c99c8 d lock.26387
+c03c99d8 d shmem_vm_ops
+c03c99f4 d shmem_swaplist
+c03c9a00 D malloc_sizes
+c03c9ae4 d cache_chain_mutex
+c03c9b00 d cache_cache
+c03c9b8c d slab_early_init
+c03c9ba0 d initarray_generic
+c03c9bc4 d xip_file_vm_ops
+c03c9be0 d xip_alloc_lock.18143
+c03c9c00 D files_stat
+c03c9c0c D super_blocks
+c03c9c14 D sb_lock
+c03c9c24 d unnamed_dev_lock
+c03c9c34 d mutex.27200
+c03c9c50 D directly_mappable_cdev_bdi
+c03c9c6c d chrdevs_lock
+c03c9c88 d ktype_cdev_default
+c03c9c94 d cdev_lock
+c03c9ca4 d ktype_cdev_dynamic
+c03c9cb0 d warncount.24372
+c03c9cc0 D core_pattern
+c03c9d40 d binfmt_lock
+c03c9d60 d pipe_fs_type
+c03c9d80 d pipefs_dentry_operations
+c03c9d9c d fasync_lock
+c03c9dc0 D leases_enable
+c03c9dc4 D lease_break_time
+c03c9dc8 d file_lock_list
+c03c9dd0 d blocked_list
+c03c9de0 d lease_manager_ops
+c03c9e00 D dentry_stat
+c03c9e18 d dentry_unused
+c03c9e20 D inode_in_use
+c03c9e28 D inode_unused
+c03c9e30 D inode_lock
+c03c9e40 d iprune_mutex
+c03c9e5c d file_systems_lock
+c03c9e80 D fs_subsys
+c03c9eec D mounts_op
+c03c9efc D mountstats_op
+c03c9f20 d fs_info.25062
+c03c9fe0 D aio_max_nr
+c03c9fe4 d fput_lock
+c03c9ff4 d fput_head
+c03c9ffc d fput_work
+c03ca00c d aio_nr_lock
+c03ca01c d simple_transaction_lock.18011
+c03ca02c d pin_fs_lock
+c03ca03c d cursor_name.17640
+c03ca048 d simple_dentry_operations.17626
+c03ca064 d bio_dirty_lock
+c03ca074 d bio_dirty_work
+c03ca0a0 d all_bdevs
+c03ca0c0 d bd_type
+c03ca0e0 d revokefs_fs_type
+c03ca100 d revokefs_super_ops
+c03ca160 d revoked_inode_ops
+c03ca1c0 D inotify_table
+c03ca280 d inotify_fs_type
+c03ca2a0 d anon_inode_fs_type
+c03ca2c0 d anon_inodefs_dentry_operations
+c03ca2e0 d bm_fs_type
+c03ca300 d misc_format
+c03ca31c d enabled
+c03ca320 d entries_lock
+c03ca330 d entries
+c03ca340 d bm_files.19395
+c03ca37c d script_format
+c03ca398 d elf_format
+c03ca3b4 d mb_cache_spinlock
+c03ca3c4 d mb_cache_list
+c03ca3cc d mb_cache_lru_list
+c03ca3d4 d mb_cache_queue
+c03ca400 D dq_data_lock
+c03ca420 D dquot_operations
+c03ca460 D vfs_quotactl_ops
+c03ca4a0 d sys_table
+c03ca4f8 d flag_print_warnings
+c03ca4fc d dq_list_lock
+c03ca50c d free_dquots
+c03ca514 d inuse_list
+c03ca520 d fs_table
+c03ca580 d fs_dqstats_table
+c03ca738 d v2_quota_format
+c03ca748 d v2_format_ops
+c03ca780 d pagemap_walk
+c03ca790 d clear_refs_walk
+c03ca7a0 d proc_pid_smaps_op
+c03ca7b0 d smaps_walk
+c03ca7c0 d proc_pid_maps_op
+c03ca7e0 D proc_root
+c03ca840 d proc_fs_type
+c03ca860 d proc_base_dentry_operations
+c03ca87c d pid_dentry_operations
+c03ca898 d tid_fd_dentry_operations
+c03ca8c0 D proc_subdir_lock
+c03ca8d0 d proc_dentry_operations
+c03ca8ec d proc_inum_lock
+c03ca900 d proc_inum_idr
+c03ca920 d task_state_array
+c03ca940 d tty_drivers_op
+c03ca960 d simple_ones.21868
+c03ca9a8 d int_seq_ops
+c03ca9b8 d devinfo_ops
+c03ca9e0 d proc_sys_inode_operations
+c03caa3c d proc_sys_dentry_operations
+c03caa60 D proc_net_ns_ops
+c03caa80 d proc_net_dir_inode_operations
+c03caadc d kclist_lock
+c03caaf0 D elfcorehdr_addr
+c03caaf8 d vmcore_list
+c03cab00 D warn_no_part
+c03cab04 D ktype_part
+c03cab10 d addpartattr.20485
+c03cab1c d part_sysfs_ops
+c03cab24 d default_attrs
+c03cab3c d part_attr_uevent
+c03cab50 d part_attr_dev
+c03cab64 d part_attr_start
+c03cab78 d part_attr_size
+c03cab8c d part_attr_stat
+c03caba0 d sysfs_backing_dev_info
+c03cabbc d subsys_sysfs_ops
+c03cabe0 D sysfs_mutex
+c03cabfc D sysfs_assoc_lock
+c03cac0c d sysfs_dentry_ops
+c03cac28 d sysfs_ino_lock
+c03cac40 d sysfs_ino_ida
+c03cac80 D sysfs_root
+c03cacc0 d sysfs_fs_type
+c03cace0 d devpts_fs_type
+c03cad00 d devpts_dir_operations
+c03cad70 d config
+c03cada0 d tokens
+c03cadc0 d devpts_file_inode_operations
+c03cae1c d dcookie_mutex
+c03cae38 d dcookie_users
+c03cae40 d ext3_fs_type
+c03cae60 d ext3_export_ops
+c03cae80 d ext3_qctl_operations
+c03caec0 d ext3_quota_operations
+c03caf00 d tokens
+c03cb0a0 D ext3_xattr_handlers
+c03cb0b8 D ext3_xattr_user_handler
+c03cb0c8 D ext3_xattr_trusted_handler
+c03cb0d8 D ext3_xattr_acl_access_handler
+c03cb0e8 D ext3_xattr_acl_default_handler
+c03cb0f8 D ext3_xattr_security_handler
+c03cb120 d ext2_filetype_table
+c03cb140 d ext2_fs_type
+c03cb160 d ext2_export_ops
+c03cb180 d tokens
+c03cb288 D ext2_xattr_handlers
+c03cb2a0 D ext2_xattr_user_handler
+c03cb2b0 D ext2_xattr_trusted_handler
+c03cb2c0 D ext2_xattr_acl_access_handler
+c03cb2d0 D ext2_xattr_acl_default_handler
+c03cb2e0 D ext2_xattr_security_handler
+c03cb300 d cramfs_fs_type
+c03cb320 d read_mutex
+c03cb340 d ramfs_fs_type
+c03cb360 d rootfs_fs_type
+c03cb380 d ramfs_backing_dev_info
+c03cb3a0 d iso9660_fs_type
+c03cb3c0 d isofs_dentry_ops
+c03cb440 d tokens
+c03cb550 D isofs_export_ops
+c03cb580 d default_table
+c03cb5a0 d nls_lock
+c03cb5b0 d tables
+c03cb5c0 d utf8_table
+c03cb660 d charset2lower
+c03cb760 d charset2upper
+c03cb860 d page00
+c03cb960 d table
+c03cb980 d charset2lower
+c03cba80 d charset2upper
+c03cbb80 d page00
+c03cbc80 d page01
+c03cbd80 d page03
+c03cbe80 d page20
+c03cbf80 d page22
+c03cc080 d page23
+c03cc180 d page25
+c03cc280 d table
+c03cc2a0 d charset2lower
+c03cc3a0 d charset2upper
+c03cc4a0 d page00
+c03cc5a0 d debug_subsys
+c03cc620 d debug_fs_type
+c03cc640 d debug_files.17949
+c03cc660 d fops_u64
+c03cc6e0 d fops_u32
+c03cc760 d fops_u16
+c03cc7e0 d fops_u8
+c03cc860 D init_ipc_ns
+c03cc8a0 d sysvipc_proc_seqops
+c03cc8b0 d shm_vm_ops
+c03cc8e0 d ipc_root_table
+c03cc940 d ipc_kern_table
+c03ccaa0 d mq_sysctl_root
+c03ccb00 d mqueue_fs_type
+c03ccb20 d queues_max
+c03ccb24 d msg_max
+c03ccb28 d msgsize_max
+c03ccb40 d mqueue_super_ops
+c03ccba0 d mq_sysctl_dir
+c03ccc00 d mq_sysctls
+c03cccb0 d msg_max_limit_min
+c03cccb4 d msg_max_limit_max
+c03cccb8 d msg_maxsize_limit_min
+c03cccbc d msg_maxsize_limit_max
+c03cccc0 D crypto_alg_list
+c03cccc8 D crypto_alg_sem
+c03ccd00 D crypto_chain
+c03ccd20 D crypto_km_types
+c03ccd40 d elv_list_lock
+c03ccd50 d elv_list
+c03ccd58 d elv_ktype
+c03ccd64 d elv_sysfs_ops
+c03ccd6c d queue_ktype
+c03ccd78 d queue_sysfs_ops
+c03ccd80 d default_attrs
+c03ccd98 d queue_requests_entry
+c03ccdac d queue_ra_entry
+c03ccdc0 d queue_max_hw_sectors_entry
+c03ccdd4 d queue_max_sectors_entry
+c03ccde8 d queue_iosched_entry
+c03cce00 D partitions_op
+c03cce20 D block_subsys
+c03cce8c D diskstats_op
+c03cce9c d ktype_block
+c03ccea8 d block_subsys_lock
+c03ccec4 d block_uevent_ops
+c03cced0 d disk_sysfs_ops
+c03ccee0 d default_attrs
+c03ccf00 d disk_attr_uevent
+c03ccf14 d disk_attr_dev
+c03ccf28 d disk_attr_range
+c03ccf3c d disk_attr_removable
+c03ccf50 d disk_attr_size
+c03ccf64 d disk_attr_stat
+c03ccf78 d disk_attr_capability
+c03ccfa0 d cmd_type.20322
+c03cd0a0 d elevator_noop
+c03cd120 d cfq_slice_async
+c03cd124 d cfq_slice_idle
+c03cd140 d iosched_cfq
+c03cd1c0 d cfq_attrs
+c03cd288 d blk_relay_callbacks
+c03cd29c d module_bug_list
+c03cd2c0 D _ctype
+c03cd3c0 d dir_ktype
+c03cd3e0 D uevent_helper
+c03cd4e0 d sequence_lock
+c03cd4f0 d warn.7934
+c03cd4f4 d delay_fn
+c03cd500 D debug_locks
+c03cd504 d count.15708
+c03cd520 d kernel_sem
+c03cd540 d ts_ops
+c03cd548 d ts_mod_lock
+c03cd580 d pci_lock
+c03cd590 d pci_ucfg_wait
+c03cd5c0 D pci_root_buses
+c03cd5c8 D pci_devices
+c03cd5d0 D class_device_attr_cpuaffinity
+c03cd600 d pcibus_class
+c03cd744 D pci_pm_d3_delay
+c03cd748 D pci_cardbus_io_size
+c03cd74c D pci_cardbus_mem_size
+c03cd750 D pci_cache_line_size
+c03cd754 d via_vlink_dev_lo
+c03cd758 d via_vlink_dev_hi
+c03cd760 D pci_bus_type
+c03cd980 d pci_compat_driver
+c03cda90 d pci_driver_kobj_type
+c03cda9c d driver_attr_new_id
+c03cdab0 d pci_driver_sysfs_ops
+c03cdab8 D pci_bus_sem
+c03cdae0 D pci_dev_attrs
+c03cdc00 d pci_config_attr
+c03cdc20 d pcie_config_attr
+c03cdc40 d proc_bus_pci_devices_op
+c03cdc60 d pcie_portdriver
+c03cdd70 d pcie_portdrv_err_handler
+c03cdda0 D pcie_port_bus_type
+c03cdfc0 d logbuf_lock
+c03cdfd0 d __param_str_forceload
+c03ce000 d aerdriver
+c03ce0e0 d aer_error_handlers
+c03ce100 d aer_id
+c03ce148 d pci_msi_enable
+c03ce14c d ht_irq_lock
+c03ce15c d acpi_pci_bus
+c03ce170 d OSC_UUID
+c03ce180 d fb_notifier_list
+c03ce1a0 d vga_lock
+c03ce1b0 d vga_font_is_default
+c03ce1c0 d cga_console_resource.17919
+c03ce200 d vga_console_resource.17912
+c03ce240 d ega_console_resource.17911
+c03ce280 d mda2_console_resource.17909
+c03ce2c0 d mda1_console_resource.17908
+c03ce300 d ega_console_resource.17907
+c03ce340 D max_cstate
+c03ce360 D acpi_rs_convert_address16
+c03ce374 D acpi_rs_convert_address32
+c03ce388 D acpi_rs_convert_address64
+c03ce39c D acpi_rs_convert_ext_address64
+c03ce3b0 d acpi_rs_convert_general_flags
+c03ce3c8 d acpi_rs_convert_mem_flags
+c03ce3dc d acpi_rs_convert_io_flags
+c03ce400 D acpi_gbl_set_resource_dispatch
+c03ce460 D acpi_gbl_get_resource_dispatch
+c03ce4d0 D acpi_rs_convert_io
+c03ce4e4 D acpi_rs_convert_fixed_io
+c03ce4f4 D acpi_rs_convert_generic_reg
+c03ce504 D acpi_rs_convert_end_dpf
+c03ce50c D acpi_rs_convert_end_tag
+c03ce514 D acpi_rs_get_start_dpf
+c03ce528 D acpi_rs_set_start_dpf
+c03ce540 D acpi_rs_get_irq
+c03ce560 D acpi_rs_set_irq
+c03ce5a0 D acpi_rs_convert_ext_irq
+c03ce5c4 D acpi_rs_convert_dma
+c03ce5dc D acpi_rs_convert_memory24
+c03ce5ec D acpi_rs_convert_memory32
+c03ce5fc D acpi_rs_convert_fixed_memory32
+c03ce60c D acpi_rs_get_vendor_small
+c03ce618 D acpi_rs_get_vendor_large
+c03ce624 D acpi_rs_set_vendor
+c03ce640 D acpi_gbl_exception_names_env
+c03ce6c0 D acpi_gbl_exception_names_pgm
+c03ce6e4 D acpi_gbl_exception_names_tbl
+c03ce700 D acpi_gbl_exception_names_aml
+c03ce7a0 D acpi_gbl_exception_names_ctrl
+c03ce7d4 D acpi_gbl_create_osi_method
+c03ce7d5 D acpi_gbl_leave_wake_gpes_disabled
+c03ce7d8 D acpi_dbg_level
+c03ce7dc D acpi_dbg_layer
+c03ce7e0 D acpi_gbl_shutdown
+c03ce7e4 D acpi_gbl_sleep_state_names
+c03ce7fc D acpi_gbl_highest_dstate_names
+c03ce820 D acpi_gbl_bit_register_info
+c03ce878 D acpi_gbl_fixed_event_info
+c03ce8a0 D acpi_gbl_region_types
+c03ce8c0 d acpi_sysclass
+c03ce940 d device_acpi
+c03ce9a0 D acpi_bus_event_list
+c03ce9a8 D acpi_bus_event_queue
+c03ce9c0 D acpi_subsys
+c03cea2c d acpi_bus_event_lock
+c03cea3c d bus_type_sem
+c03cea58 d bus_type_list
+c03cea60 D acpi_device_lock
+c03cea70 D acpi_wakeup_device_list
+c03cea80 D acpi_bus_type
+c03cec88 d acpi_bus_id_list
+c03cec90 d acpi_device_list
+c03cec98 d dev_attr_path
+c03cecac d dev_attr_hid
+c03cecc0 d dev_attr_eject
+c03cece0 d acpi_ec_mode
+c03ced00 d acpi_ec_driver
+c03ceea0 d acpi_ec_info_ops
+c03cef20 d acpi_pci_root_driver
+c03cf0b4 d acpi_pci_roots
+c03cf0c0 D acpi_link_lock
+c03cf0e0 d acpi_pci_link_driver
+c03cf280 d irqrouter_sysdev_class
+c03cf300 d device_irqrouter
+c03cf360 d acpi_irq_penalty
+c03cf760 d acpi_prt_lock
+c03cf770 d first_time.18832
+c03cf780 d acpi_power_driver
+c03cf914 d acpi_table_attr_list
+c03cf91c d __param_str_acpica_version
+c03cf930 d acpi_system_event_lock
+c03cf940 d cm_sbs_mutex
+c03cf960 D pnp_global
+c03cf968 D pnp_lock
+c03cf978 d pnp_protocols
+c03cf980 D pnp_cards
+c03cf988 d pnp_card_drivers
+c03cf990 d dev_attr_name
+c03cf9a4 d dev_attr_card_id
+c03cf9c0 D pnp_bus_type
+c03cfbe0 d pnp_reserve_mem
+c03cfc20 d pnp_reserve_io
+c03cfc60 d pnp_reserve_dma
+c03cfc80 d pnp_reserve_irq
+c03cfcc0 D pnp_res_mutex
+c03cfce0 d dev_attr_options
+c03cfcf4 d dev_attr_resources
+c03cfd08 d dev_attr_id
+c03cfd20 d pnp_fixups
+c03cfdc0 d system_pnp_driver
+c03cfea0 d pnpacpi_protocol
+c03d0080 d zero_bdi
+c03d0100 D random_table
+c03d0280 d input_pool
+c03d0380 d random_read_wakeup_thresh
+c03d0384 d random_write_wakeup_thresh
+c03d03a0 d rekey_work
+c03d0400 d nonblocking_pool
+c03d0500 d random_write_wait
+c03d0518 d random_read_wait
+c03d0580 d blocking_pool
+c03d0680 d sysctl_poolsize
+c03d0684 d min_read_thresh
+c03d0688 d max_read_thresh
+c03d068c d max_write_thresh
+c03d06a0 d poolinfo_table
+c03d06e0 D tty_std_termios
+c03d070c D tty_drivers
+c03d0714 D tty_mutex
+c03d0740 d allocated_ptys_lock
+c03d0760 d allocated_ptys
+c03d0780 d redirect_lock
+c03d0790 d tty_ldisc_wait
+c03d07a8 d tty_ldisc_lock
+c03d07c0 D tty_ldisc_N_TTY
+c03d0820 D pty_limit
+c03d0840 D pty_table
+c03d08c4 d pty_limit_max
+c03d08c8 d misc_mtx
+c03d08e4 d misc_list
+c03d08ec d misc_seq_ops
+c03d08fc d vt_activate_queue
+c03d0920 d translations
+c03d1120 D dfont_unicount
+c03d1220 D dfont_unitable
+c03d1480 d sel_start
+c03d14a0 d inwordLut
+c03d14c0 D vt_spawn_con
+c03d14e0 D kbd_sysrq_xlate
+c03d16e0 D keyboard_tasklet
+c03d16f4 d brl_timeout
+c03d16f8 d brl_nbchords
+c03d16fc d ledstate
+c03d1700 d kbd_handler
+c03d1738 d kbd
+c03d173c d npadch
+c03d1740 d buf.18552
+c03d1744 d kd_mksound_timer
+c03d175c d __param_str_brl_timeout
+c03d1771 d __param_str_brl_nbchords
+c03d17a0 D want_console
+c03d17a4 D color_table
+c03d17c0 D default_red
+c03d1800 D default_grn
+c03d1840 D default_blu
+c03d1880 D con_buf_mtx
+c03d189c d default_italic_color
+c03d18a0 d default_underline_color
+c03d18c0 d device_attrs
+c03d18e8 d blankinterval
+c03d18ec d console_timer
+c03d1920 d vt_console_driver
+c03d1954 d console_work
+c03d1964 d old_offset.19347
+c03d1968 d __param_str_default_utf8
+c03d1978 d __param_str_default_red
+c03d1988 d __param_arr_default_red
+c03d19a0 d __param_str_default_grn
+c03d19b0 d __param_arr_default_grn
+c03d19c8 d __param_str_default_blu
+c03d19d8 d __param_arr_default_blu
+c03d19f0 d __param_str_italic
+c03d19fa d __param_str_underline
+c03d1a20 D plain_map
+c03d1c20 D shift_map
+c03d1e20 D altgr_map
+c03d2020 D ctrl_map
+c03d2220 D shift_ctrl_map
+c03d2420 D alt_map
+c03d2620 D ctrl_alt_map
+c03d2820 D key_maps
+c03d2c20 D keymap_count
+c03d2c40 D func_buf
+c03d2cdc D funcbufptr
+c03d2ce0 D funcbufsize
+c03d2d00 D func_table
+c03d3100 D accent_table
+c03d3400 D accent_table_size
+c03d3420 d sysrq_key_table_lock
+c03d3440 d sysrq_key_table
+c03d34d0 d moom_work
+c03d34e0 d sysrq_loglevel_op
+c03d34f0 d sysrq_reboot_op
+c03d3500 d sysrq_crashdump_op
+c03d3510 d sysrq_term_op
+c03d3520 d sysrq_moom_op
+c03d3530 d sysrq_kill_op
+c03d3540 d sysrq_SAK_op
+c03d3550 d sysrq_showmem_op
+c03d3560 d sysrq_unrt_op
+c03d3570 d sysrq_showregs_op
+c03d3580 d sysrq_show_timers_op
+c03d3590 d sysrq_unraw_op
+c03d35a0 d sysrq_sync_op
+c03d35b0 d sysrq_showstate_op
+c03d35c0 d sysrq_mountro_op
+c03d35d0 d sysrq_showstate_blocked_op
+c03d35e0 d rtc_has_irq
+c03d35e4 d rtc_dev
+c03d3600 d rtc_irq_timer
+c03d3618 d rtc_wait
+c03d3630 d rtc_max_user_freq
+c03d3634 d epoch
+c03d3640 d dev_root
+c03d3698 d rtc_task_lock
+c03d36c0 d rtc_root
+c03d3720 d rtc_table
+c03d3780 d hpet_misc
+c03d37a0 d dev_root
+c03d3800 d hpet_acpi_driver
+c03d3994 d hpet_max_freq
+c03d3998 d hpet_lock
+c03d39a8 d hpet_task_lock
+c03d39c0 d hpet_root
+c03d3a20 d hpet_table
+c03d3a80 d rng_mutex
+c03d3a9c d rng_list
+c03d3aa4 d rng_miscdev
+c03d3ac0 d dev_attr_rng_available
+c03d3ad4 d dev_attr_rng_current
+c03d3b00 d intel_rng
+c03d3b20 d __param_str_no_fwh_detect
+c03d3b40 d hangcheck_tick
+c03d3b44 d hangcheck_margin
+c03d3b48 d hangcheck_ticktock
+c03d3b60 d __param_str_hangcheck_tick
+c03d3b80 d __param_str_hangcheck_margin
+c03d3bc0 d __param_str_hangcheck_reboot
+c03d3c00 d __param_str_hangcheck_dump_tasks
+c03d3c40 d port_mutex
+c03d3c60 d share_irqs
+c03d3c64 d nr_uarts
+c03d3c80 d serial8250_reg
+c03d3cc0 d serial8250_isa_driver
+c03d3da0 d serial8250_console
+c03d3de0 d serial8250_pops
+c03d3e30 d first.18280
+c03d3e34 d serial_mutex
+c03d3e50 d __param_str_share_irqs
+c03d3e60 d __param_str_nr_uarts
+c03d3e6e d __param_str_probe_rsa
+c03d3e80 d __param_arr_probe_rsa
+c03d3ea0 d serial_pnp_driver
+c03d3f80 d modem_names
+c03d4000 d serial_pci_driver
+c03d4120 d pci_boards
+c03d4820 d pci_serial_quirks
+c03d4a80 d serial_pci_tbl
+c03d5a20 D devices_subsys
+c03d5a8c d ktype_device
+c03d5a98 d devt_attr
+c03d5aac d uevent_attr
+c03d5ac0 d device_uevent_ops
+c03d5acc d dev_sysfs_ops
+c03d5ae0 d system_subsys
+c03d5b4c d sysdev_drivers
+c03d5b60 d sysdev_drivers_lock
+c03d5b80 d ktype_sysdev
+c03d5b8c d ktype_sysdev_class
+c03d5b98 d sysfs_ops
+c03d5ba0 d sysfs_class_ops
+c03d5bc0 d bus_subsys
+c03d5c2c d ktype_driver
+c03d5c38 d driver_attr_bind
+c03d5c4c d driver_attr_unbind
+c03d5c60 d ktype_bus
+c03d5c6c d driver_sysfs_ops
+c03d5c74 d bus_sysfs_ops
+c03d5c7c d probe_waitqueue
+c03d5ca0 d class_subsys
+c03d5d20 d class_obj_subsys
+c03d5d8c d ktype_class_device
+c03d5d98 d class_uevent_attr
+c03d5dac d class_devt_attr
+c03d5dc0 d ktype_class
+c03d5dcc d class_uevent_ops
+c03d5dd8 d class_dev_sysfs_ops
+c03d5de0 d class_sysfs_ops
+c03d5e00 D platform_bus
+c03d5fc0 D platform_bus_type
+c03d61e0 d platform_dev_attrs
+c03d6220 D cpu_sysdev_class
+c03d62a0 d attr_crash_notes
+c03d62c0 d firmware_subsys
+c03d632c d attribute_container_mutex
+c03d6360 D dpm_active
+c03d6368 D dpm_off
+c03d6370 D dpm_off_irq
+c03d6380 D dpm_sem
+c03d63a0 D dpm_list_sem
+c03d63c0 d pm_attr_group
+c03d63c8 d power_attrs
+c03d63d0 d dev_attr_wakeup
+c03d63e4 d pools_lock
+c03d6400 d dev_attr_pools
+c03d6420 d firmware_class
+c03d6564 d class_attr_timeout
+c03d6578 d loading_timeout
+c03d657c d fw_lock
+c03d6598 d dev_attr_loading
+c03d65ac d topology_attr_group
+c03d65b4 d default_attrs
+c03d65c8 d attr_physical_package_id
+c03d65dc d attr_core_id
+c03d65f0 d attr_thread_siblings
+c03d6604 d attr_core_siblings
+c03d6620 D rd_size
+c03d6624 d rd_blocksize
+c03d6640 d rd_bd_op
+c03d6668 d rd_backing_dev_info
+c03d6684 d rd_file_backing_dev_info
+c03d66a0 d __param_str_rd_size
+c03d66ab d __param_str_rd_blocksize
+c03d66c0 d loopback_net_ops
+c03d66e0 d etun_list
+c03d6700 d etun_ethtool_ops
+c03d67a0 d ethtool_stats_keys
+c03d67c0 d __param_str_newif
+c03d67cb d __param_str_delif
+c03d67e0 d driver
+c03d6900 d aec62xx_chipsets
+c03d6a20 d aec62xx_pci_tbl
+c03d6ae0 d driver
+c03d6c00 d ali15x3_chipset
+c03d6c40 d ati_rs100.22479
+c03d6c80 d alim15x3_pci_tbl
+c03d6ce0 d driver
+c03d6e00 d amd74xx_chipsets
+c03d7320 d amd_ide_chips
+c03d7440 d ide_timing
+c03d75e0 d amd74xx_pci_tbl
+c03d7840 d driver
+c03d7960 d atiixp_pci_info
+c03d79d0 d atiixp_lock
+c03d79e0 d atiixp_pci_tbl
+c03d7aa0 d driver
+c03d7bc0 d cmd64x_pci_tbl
+c03d7c60 d driver
+c03d7d80 d cyrix_chipsets
+c03d7e00 d cs5520_pci_tbl
+c03d7e60 d driver
+c03d7f80 d cs5530_chipset
+c03d7fc0 d cs5530_pci_tbl
+c03d8000 d driver
+c03d8120 d cs5535_chipset
+c03d8160 d cs5535_pci_tbl
+c03d81a0 d driver
+c03d82c0 d cy82c693_chipset
+c03d8300 d cy82c693_pci_tbl
+c03d8340 d driver
+c03d8460 d hpt34x_chipset
+c03d84a0 d hpt34x_pci_tbl
+c03d84e0 d driver
+c03d85f0 d hpt372n
+c03d85f8 d hpt374
+c03d8600 d hpt371n
+c03d8608 d hpt371
+c03d8610 d hpt302n
+c03d8618 d hpt302
+c03d8620 d hpt372a
+c03d8640 d bad_ata100_5
+c03d8680 d bad_ata66_4
+c03d86c4 d bad_ata66_3
+c03d86e0 d bad_ata33
+c03d8780 d quirk_drives
+c03d87a0 d hpt366_pci_tbl
+c03d8864 d hpt37x_settings
+c03d8878 d hpt36x
+c03d8880 d hpt370
+c03d8888 d hpt370a
+c03d8890 d hpt372
+c03d88a0 d thirty_three_base_hpt37x
+c03d88e0 d fifty_base_hpt37x
+c03d8920 d sixty_six_base_hpt37x
+c03d895c d hpt36x_settings
+c03d8980 d twenty_five_base_hpt36x
+c03d89c0 d thirty_three_base_hpt36x
+c03d8a00 d forty_base_hpt36x
+c03d8a40 d driver
+c03d8b60 d it821x_chipsets
+c03d8b98 d __param_str_noraid
+c03d8bc0 d it821x_pci_tbl
+c03d8c20 d driver
+c03d8d40 d jmicron_chipsets
+c03d8e60 d jmicron_pci_tbl
+c03d8f20 d driver
+c03d9040 d pdc202xx_chipsets
+c03d9160 d pdc_quirk_drives
+c03d91a0 d pdc202xx_pci_tbl
+c03d9260 d driver
+c03d9380 d pdcnew_chipsets
+c03d9520 d pdc_quirk_drives
+c03d9560 d pdc202new_pci_tbl
+c03d9640 d driver
+c03d9760 d piix_pci_info
+c03d9cd8 d tune_lock.22252
+c03d9d00 d piix_pci_tbl
+c03d9fc0 d driver
+c03da0e0 d rz1000_chipset
+c03da120 d rz1000_pci_tbl
+c03da180 d driver
+c03da2a0 d serverworks_chipsets
+c03da3b8 d svwks_bad_ata100
+c03da3e0 d svwks_pci_tbl
+c03da4a0 d driver
+c03da5c0 d siimage_chipsets
+c03da668 d first.22812
+c03da680 d siimage_pci_tbl
+c03da6c0 d driver
+c03da7e0 d sis5513_chipset
+c03da820 d sis5513_pci_tbl
+c03da8a0 d driver
+c03da9c0 d slc90e66_chipset
+c03daa00 d slc90e66_pci_tbl
+c03daa40 d driver
+c03dab60 d triflex_device
+c03daba0 d triflex_pci_tbl
+c03dabe0 d driver
+c03dad00 d via82cxxx_chipsets
+c03dad80 d ide_timing
+c03daf20 d via_isa_bridges
+c03db040 d via_pci_tbl
+c03db0e0 d driver
+c03db200 d generic_chipsets
+c03db548 d __param_str_all_generic_ide
+c03db560 d generic_pci_tbl
+c03db720 D ide_cfg_sem
+c03db740 D ide_setting_sem
+c03db760 D ide_bus_type
+c03db980 d pci_default.22880
+c03db9b8 d magic_cookie.22869
+c03db9c0 d ide_words.23571
+c03dba20 d ide_dev_attrs
+c03dba80 d ide_pio_blacklist
+c03dbc10 d setup_counts
+c03dbc14 d active_counts
+c03dbc18 d recovery_counts
+c03dbc1c d pre_init
+c03dbc20 d ide_pci_drivers
+c03dbc40 d idedisk_driver
+c03dbd28 d idedisk_ref_mutex
+c03dbd60 d idedisk_ops
+c03dbda0 d ide_cdrom_driver
+c03dbe88 d idecd_ref_mutex
+c03dbec0 d idecd_ops
+c03dbf00 d ide_cdrom_dops
+c03dbf3c d retry.23522
+c03dbf40 d __param_str_ignore
+c03dbf60 d idefloppy_driver
+c03dc048 d idefloppy_ref_mutex
+c03dc080 d idefloppy_ops
+c03dc0c0 d autoclose
+c03dc0c4 d lockdoor
+c03dc0c8 d mrw_format_restart
+c03dc0e0 d cdrom_root_table
+c03dc138 d cdrom_lock
+c03dc148 d __param_str_debug
+c03dc154 d __param_str_autoclose
+c03dc164 d __param_str_autoeject
+c03dc174 d __param_str_lockdoor
+c03dc183 d __param_str_check_media_type
+c03dc19a d __param_str_mrw_format_restart
+c03dc1c0 d cdrom_cdrom_table
+c03dc220 d cdrom_table
+c03dc360 D usbcore_name
+c03dc364 D usb_device_type
+c03dc37c d __param_str_nousb
+c03dc3a0 D ehci_cf_port_reset_rwsem
+c03dc3bc d use_both_schemes
+c03dc3c0 d usb_address0_mutex.18091
+c03dc3dc d hub_event_lock
+c03dc3ec d hub_event_list
+c03dc3f4 d khubd_wait
+c03dc420 d hub_driver
+c03dc524 d device_state_lock
+c03dc534 d __param_str_blinkenlights
+c03dc54a d __param_str_old_scheme_first
+c03dc563 d __param_str_use_both_schemes
+c03dc580 d hub_id_table
+c03dc5bc D usb_bus_list
+c03dc5c4 D usb_bus_list_lock
+c03dc5e0 D usb_kill_urb_queue
+c03dc5f8 d hcd_root_hub_lock
+c03dc608 d hcd_data_lock
+c03dc618 D usb_if_device_type
+c03dc640 D usb_bus_type
+c03dc848 d driver_attr_new_id
+c03dc85c d minor_lock
+c03dc880 d dev_attr_interface
+c03dc894 d intf_attr_grp
+c03dc89c d dev_attr_manufacturer
+c03dc8b0 d dev_attr_product
+c03dc8c4 d dev_attr_serial
+c03dc8d8 d dev_attr_grp
+c03dc8e0 d intf_attrs
+c03dc900 d dev_attrs
+c03dc950 d dev_attr_bInterfaceNumber
+c03dc964 d dev_attr_bAlternateSetting
+c03dc978 d dev_attr_bNumEndpoints
+c03dc98c d dev_attr_bInterfaceClass
+c03dc9a0 d dev_attr_bInterfaceSubClass
+c03dc9b4 d dev_attr_bInterfaceProtocol
+c03dc9c8 d dev_attr_modalias
+c03dc9dc d dev_attr_configuration
+c03dc9f0 d dev_attr_bNumInterfaces
+c03dca04 d dev_attr_bConfigurationValue
+c03dca18 d dev_attr_bmAttributes
+c03dca2c d dev_attr_bMaxPower
+c03dca40 d dev_attr_idVendor
+c03dca54 d dev_attr_idProduct
+c03dca68 d dev_attr_bcdDevice
+c03dca7c d dev_attr_bDeviceClass
+c03dca90 d dev_attr_bDeviceSubClass
+c03dcaa4 d dev_attr_bDeviceProtocol
+c03dcab8 d dev_attr_bNumConfigurations
+c03dcacc d dev_attr_bMaxPacketSize0
+c03dcae0 d dev_attr_speed
+c03dcaf4 d dev_attr_busnum
+c03dcb08 d dev_attr_devnum
+c03dcb1c d dev_attr_version
+c03dcb30 d dev_attr_maxchild
+c03dcb44 d dev_attr_quirks
+c03dcb60 d ep_dev_attr_grp
+c03dcb80 d endpoint_idr
+c03dcba0 d minor_lock.16707
+c03dcbc0 d ep_dev_attrs
+c03dcbe4 d dev_attr_bLength
+c03dcbf8 d dev_attr_bEndpointAddress
+c03dcc0c d dev_attr_bmAttributes
+c03dcc20 d dev_attr_bInterval
+c03dcc34 d dev_attr_wMaxPacketSize
+c03dcc48 d dev_attr_interval
+c03dcc5c d dev_attr_type
+c03dcc70 d dev_attr_direction
+c03dcca0 D usbfs_mutex
+c03dccc0 D usbfs_driver
+c03dcdc4 d usbdev_nb
+c03dcde0 d usb_device_cdev
+c03dce44 d __param_str_usbfs_snoop
+c03dce60 d usb_notifier_list
+c03dce80 D usb_generic_driver
+c03dcf60 d usbfs_nb
+c03dcf80 d usb_fs_type
+c03dcfa0 d usbfs_ops
+c03dcff4 d devmode
+c03dcff6 d busmode
+c03dcff8 d listmode
+c03dd000 d tokens
+c03dd050 d deviceconndiscwq
+c03dd080 D storage_usb_ids
+c03de048 d usu_bias
+c03de060 d usu_driver
+c03de180 d usu_init_notify
+c03de1a0 d usu_lock
+c03de1b0 d usu_end_notify
+c03de1cc d __param_str_bias
+c03de1e0 d serio_bus
+c03de3e8 d serio_mutex
+c03de404 d serio_id_attr_group
+c03de40c d serio_event_lock
+c03de41c d serio_event_list
+c03de424 d serio_wait
+c03de43c d serio_list
+c03de460 d serio_device_attrs
+c03de4e0 d serio_driver_attrs
+c03de51c d serio_device_id_attrs
+c03de530 d dev_attr_type
+c03de544 d dev_attr_proto
+c03de558 d dev_attr_id
+c03de56c d dev_attr_extra
+c03de580 d i8042_blink_frequency
+c03de5a0 d i8042_driver
+c03de67c d i8042_lock
+c03de68c d i8042_command_reg
+c03de690 d i8042_data_reg
+c03de6a0 d i8042_pnp_kbd_driver
+c03de780 d i8042_pnp_aux_driver
+c03de85c d __param_str_nokbd
+c03de868 d __param_str_noaux
+c03de874 d __param_str_nomux
+c03de880 d __param_str_unlock
+c03de88d d __param_str_reset
+c03de899 d __param_str_direct
+c03de8a6 d __param_str_dumbkbd
+c03de8b4 d __param_str_noloop
+c03de8c1 d __param_str_panicblink
+c03de8d2 d __param_str_nopnp
+c03de8de d __param_str_debug
+c03de900 d pnp_kbd_devids
+c03de940 d pnp_aux_devids
+c03de9e0 D input_class
+c03deb24 d input_handlers_seq_ops
+c03deb34 d input_handler_list
+c03deb3c d input_devices_seq_ops
+c03deb4c d input_dev_list
+c03deb54 d input_devices_poll_wait
+c03deb6c d input_dev_attr_groups
+c03deb7c d input_dev_attr_group
+c03deb84 d input_dev_id_attr_group
+c03deb8c d input_dev_caps_attr_group
+c03deb94 d input_dev_attrs
+c03deba8 d input_dev_id_attrs
+c03debc0 d input_dev_caps_attrs
+c03debe8 d class_device_attr_name
+c03debfc d class_device_attr_phys
+c03dec10 d class_device_attr_uniq
+c03dec24 d class_device_attr_modalias
+c03dec38 d class_device_attr_bustype
+c03dec4c d class_device_attr_vendor
+c03dec60 d class_device_attr_product
+c03dec74 d class_device_attr_version
+c03dec88 d class_device_attr_ev
+c03dec9c d class_device_attr_key
+c03decb0 d class_device_attr_rel
+c03decc4 d class_device_attr_abs
+c03decd8 d class_device_attr_msc
+c03decec d class_device_attr_led
+c03ded00 d class_device_attr_snd
+c03ded14 d class_device_attr_ff
+c03ded28 d class_device_attr_sw
+c03ded40 d xres
+c03ded44 d yres
+c03ded48 d tap_time
+c03ded60 d mousedev_handler
+c03ded98 d mousedev_mix_list
+c03deda0 d __param_str_xres
+c03dedae d __param_str_yres
+c03dedbc d __param_str_tap_time
+c03dede0 d evdev_handler
+c03dee20 d atkbd_set
+c03dee24 d atkbd_softraw
+c03dee40 d atkbd_drv
+c03def28 d atkbd_attribute_group
+c03def40 d atkbd_set2_keycode
+c03df140 d atkbd_set3_keycode
+c03df340 d __param_str_set
+c03df34a d __param_str_reset
+c03df356 d __param_str_softrepeat
+c03df367 d __param_str_softraw
+c03df375 d __param_str_scroll
+c03df382 d __param_str_extra
+c03df38e d atkbd_serio_ids
+c03df3a0 d atkbd_attributes
+c03df3bc d atkbd_attr_extra
+c03df3d0 d atkbd_attr_scroll
+c03df3e4 d atkbd_attr_set
+c03df3f8 d atkbd_attr_softrepeat
+c03df40c d atkbd_attr_softraw
+c03df420 d atkbd_attr_err_count
+c03df440 d psmouse_max_proto
+c03df444 d psmouse_resolution
+c03df448 d psmouse_rate
+c03df44c d psmouse_smartscroll
+c03df450 d psmouse_resetafter
+c03df460 d psmouse_drv
+c03df548 d psmouse_mutex
+c03df564 d psmouse_attribute_group
+c03df56c d __param_str_proto
+c03df57a d __param_str_resolution
+c03df58d d __param_str_rate
+c03df59a d __param_str_smartscroll
+c03df5ae d __param_str_resetafter
+c03df5c1 d __param_str_resync_time
+c03df5d5 d psmouse_serio_ids
+c03df5e4 d psmouse_attributes
+c03df600 d psmouse_attr_protocol
+c03df620 d psmouse_attr_rate
+c03df640 d psmouse_attr_resolution
+c03df660 d psmouse_attr_resetafter
+c03df680 d psmouse_attr_resync_time
+c03df6a0 d toshiba_dmi_table
+c03df760 d psmouse_attr_smartscroll
+c03df780 d lifebook_dmi_table
+c03df940 d trackpoint_attr_group
+c03df960 d trackpoint_attrs
+c03df9a0 d psmouse_attr_sensitivity
+c03df9c0 d psmouse_attr_speed
+c03df9e0 d psmouse_attr_inertia
+c03dfa00 d psmouse_attr_reach
+c03dfa20 d psmouse_attr_draghys
+c03dfa40 d psmouse_attr_mindrag
+c03dfa60 d psmouse_attr_thresh
+c03dfa80 d psmouse_attr_upthresh
+c03dfaa0 d psmouse_attr_ztime
+c03dfac0 d psmouse_attr_jenks
+c03dfae0 d psmouse_attr_press_to_select
+c03dfb00 d psmouse_attr_skipback
+c03dfb20 d psmouse_attr_ext_dev
+c03dfb40 d trackpoint_attr_sensitivity
+c03dfb48 d trackpoint_attr_speed
+c03dfb50 d trackpoint_attr_inertia
+c03dfb58 d trackpoint_attr_reach
+c03dfb60 d trackpoint_attr_draghys
+c03dfb68 d trackpoint_attr_mindrag
+c03dfb70 d trackpoint_attr_thresh
+c03dfb78 d trackpoint_attr_upthresh
+c03dfb80 d trackpoint_attr_ztime
+c03dfb88 d trackpoint_attr_jenks
+c03dfb90 d trackpoint_attr_press_to_select
+c03dfb98 d trackpoint_attr_skipback
+c03dfba0 d trackpoint_attr_ext_dev
+c03dfba8 D __i2c_board_lock
+c03dfbc4 D __i2c_board_list
+c03dfbe0 d linear_personality
+c03dfc40 d md_notifier
+c03dfc60 d raid_root_table
+c03dfcb8 d sysctl_speed_limit_min
+c03dfcbc d sysctl_speed_limit_max
+c03dfcc0 d all_mddevs_lock
+c03dfcd0 d all_mddevs
+c03dfcd8 d md_redundancy_group
+c03dfce0 d md_seq_ops
+c03dfcf0 d pers_lock
+c03dfd00 d pers_list
+c03dfd08 d pending_raid_disks
+c03dfd10 d md_event_waiters
+c03dfd40 d md_fops
+c03dfd68 d md_ktype
+c03dfd74 d disks_mutex.24027
+c03dfda0 d array_states
+c03dfdc8 d rdev_ktype
+c03dfdd4 d resync_wait
+c03dfdec d __param_str_start_ro
+c03dfdfc d __param_str_start_dirty_degraded
+c03dfe20 d raid_dir_table
+c03dfe80 d md_redundancy_attrs
+c03dfea8 d md_sysfs_ops
+c03dfec0 d md_default_attrs
+c03dfef0 d rdev_sysfs_ops
+c03dfef8 d rdev_default_attrs
+c03dff20 d raid_table
+c03dffa4 d md_scan_mode
+c03dffb8 d md_mismatches
+c03dffcc d md_sync_min
+c03dffe0 d md_sync_max
+c03dfff4 d md_sync_speed
+c03e0008 d md_sync_completed
+c03e001c d md_suspend_lo
+c03e0030 d md_suspend_hi
+c03e0044 d md_bitmap
+c03e0058 d md_level
+c03e006c d md_layout
+c03e0080 d md_raid_disks
+c03e0094 d md_chunk_size
+c03e00a8 d md_size
+c03e00bc d md_resync_start
+c03e00d0 d md_metadata
+c03e00e4 d md_new_device
+c03e00f8 d md_safe_delay
+c03e010c d md_array_state
+c03e0120 d md_reshape_position
+c03e0134 d rdev_state
+c03e0148 d rdev_super
+c03e015c d rdev_errors
+c03e0170 d rdev_slot
+c03e0184 d rdev_offset
+c03e0198 d rdev_size
+c03e01c0 D _exits
+c03e01d8 d _minor_lock
+c03e0200 d _minor_idr
+c03e0220 d dm_blk_dops
+c03e0248 d __param_str_major
+c03e0258 d _event_lock
+c03e0280 d error_target
+c03e02c4 d _lock
+c03e02e0 d _targets
+c03e0300 d linear_target
+c03e0360 d stripe_target
+c03e03a4 d _dm_misc
+c03e03c0 d _hash_lock
+c03e03dc d _client_lock
+c03e03f8 d kcopyd_init_lock
+c03e0414 d _complete_jobs
+c03e041c d _io_jobs
+c03e0424 d _pages_jobs
+c03e042c d _job_lock
+c03e043c d _clients
+c03e0460 d dmi_devices
+c03e0480 d efi_subsys
+c03e0500 d vars_subsys
+c03e056c d efivars_lock
+c03e057c d efivar_list
+c03e0584 d ktype_efivar
+c03e0590 d var_subsys_attr_new_var
+c03e05a4 d var_subsys_attr_del_var
+c03e05b8 d efi_attr_systab
+c03e05cc d efivar_attr_ops
+c03e05d4 d def_attrs
+c03e05ec d efivar_attr_guid
+c03e0600 d efivar_attr_size
+c03e0614 d efivar_attr_attributes
+c03e0628 d efivar_attr_data
+c03e063c d efivar_attr_raw_var
+c03e0680 d clocksource_cyclone
+c03e0780 d clocksource_acpi_pm
+c03e0880 d dma_list_mutex
+c03e08a0 d dma_devclass
+c03e09e4 d dma_client_list
+c03e09ec d dma_device_list
+c03e0a00 d dma_class_attrs
+c03e0a60 d __param_str_pb_fnmode
+c03e0a70 d hid_pb_fnmode
+c03e0a80 d hid_driver
+c03e0b84 d __param_str_mousepoll
+c03e0b95 d __param_str_quirks
+c03e0ba4 d __param_arr_quirks
+c03e0bc0 d hid_usb_ids
+c03e0be8 d dquirks_rwsem
+c03e0c04 d dquirks_list
+c03e0c20 D pcibios_max_latency
+c03e0c24 d bios32_indirect
+c03e0c2c d pci_bios_access
+c03e0c34 d pci_indirect
+c03e0c3c d pci_mmcfg
+c03e0c44 D pci_direct_conf1
+c03e0c4c d pci_direct_conf2
+c03e0c60 d toshiba_ohci1394_dmi_table
+c03e0d10 d quirk_pcie_aspm_ops
+c03e0d20 D pcibios_irq_mask
+c03e0d40 d pirq_penalty
+c03e0d80 D pci_probe
+c03e0d84 D pcibios_last_bus
+c03e0d88 D pci_root_ops
+c03e0d90 D pci_config_lock
+c03e0da0 d pciprobe_dmi_table
+c03e10c0 d sock_fs_type
+c03e10e0 d sock_net_ops
+c03e1100 d sockfs_ops
+c03e1154 d net_family_lock
+c03e1164 d br_ioctl_mutex
+c03e1180 d vlan_ioctl_mutex
+c03e119c d dlci_ioctl_mutex
+c03e11b8 d sockfs_dentry_operations
+c03e11e0 d proto_list
+c03e11e8 d proto_list_lock
+c03e11f8 D sysctl_max_syn_backlog
+c03e11fc d est_lock
+c03e120c D net_namespace_list
+c03e1214 d net_mutex
+c03e1230 d pernet_list
+c03e1238 d first_device
+c03e123c d net_list_mutex
+c03e1260 D core_table
+c03e1480 D multi_core_table
+c03e15a0 D dev_base_lock
+c03e15b0 d dev_boot_phase
+c03e15b4 d netdev_net_ops
+c03e15c4 d default_device_ops
+c03e15d4 d dev_proc_ops
+c03e1600 d net_dma
+c03e1664 d net_todo_list_lock
+c03e1674 d net_todo_list
+c03e167c d net_todo_run_mutex
+c03e1698 d ptype_lock
+c03e16a8 d dev_mc_net_ops
+c03e16b8 d dst_dev_notifier
+c03e16c4 d dst_lock
+c03e16d4 d dst_gc_timer_inc
+c03e16d8 d dst_gc_timer
+c03e16f0 d netevent_notif_chain
+c03e1704 d neigh_tbl_lock
+c03e1714 d rtnetlink_net_ops
+c03e1724 d rtnetlink_dev_notifier
+c03e1730 d rtnl_mutex
+c03e174c d link_ops
+c03e1760 d lweventlist_lock
+c03e1780 d linkwatch_work
+c03e17a8 d flow_flush_sem.23195
+c03e17e0 d net_class
+c03e1924 d netstat_group
+c03e192c d wireless_group
+c03e1940 d net_class_attributes
+c03e1a80 d netstat_attrs
+c03e1ae0 d wireless_attrs
+c03e1b0c d dev_attr_rx_packets
+c03e1b20 d dev_attr_tx_packets
+c03e1b34 d dev_attr_rx_bytes
+c03e1b48 d dev_attr_tx_bytes
+c03e1b5c d dev_attr_rx_errors
+c03e1b70 d dev_attr_tx_errors
+c03e1b84 d dev_attr_rx_dropped
+c03e1b98 d dev_attr_tx_dropped
+c03e1bac d dev_attr_multicast
+c03e1bc0 d dev_attr_collisions
+c03e1bd4 d dev_attr_rx_length_errors
+c03e1be8 d dev_attr_rx_over_errors
+c03e1bfc d dev_attr_rx_crc_errors
+c03e1c10 d dev_attr_rx_frame_errors
+c03e1c24 d dev_attr_rx_fifo_errors
+c03e1c38 d dev_attr_rx_missed_errors
+c03e1c4c d dev_attr_tx_aborted_errors
+c03e1c60 d dev_attr_tx_carrier_errors
+c03e1c74 d dev_attr_tx_fifo_errors
+c03e1c88 d dev_attr_tx_heartbeat_errors
+c03e1c9c d dev_attr_tx_window_errors
+c03e1cb0 d dev_attr_rx_compressed
+c03e1cc4 d dev_attr_tx_compressed
+c03e1cd8 d dev_attr_status
+c03e1cec d dev_attr_link
+c03e1d00 d dev_attr_level
+c03e1d14 d dev_attr_noise
+c03e1d28 d dev_attr_nwid
+c03e1d3c d dev_attr_crypt
+c03e1d50 d dev_attr_fragment
+c03e1d64 d dev_attr_retries
+c03e1d78 d dev_attr_misc
+c03e1d8c d dev_attr_beacon
+c03e1da0 D sysctl_tcp_dma_copybreak
+c03e1da4 d fib_rules_net_ops
+c03e1db4 d fib_rules_notifier
+c03e1dc0 D noop_qdisc_ops
+c03e1e20 D noop_qdisc
+c03e1ec0 d pfifo_fast_ops
+c03e1f20 d noqueue_qdisc
+c03e1fc0 d noqueue_qdisc_ops
+c03e2008 d qdisc_mod_lock
+c03e2018 d autohandle.26693
+c03e2020 d blackhole_qdisc_ops
+c03e2068 d cls_mod_lock
+c03e2080 D pfifo_qdisc_ops
+c03e20e0 D bfifo_qdisc_ops
+c03e2140 d netlink_proto
+c03e29f0 d netlink_family_ops
+c03e29fc d netlink_net_ops
+c03e2a0c d netlink_seq_ops
+c03e2a1c d nl_table_lock
+c03e2a2c d nl_table_wait
+c03e2a44 d rover.27150
+c03e2a48 d netlink_chain
+c03e2a60 d genl_ctrl
+c03e2aa0 d genl_ctrl_ops
+c03e2ac0 d genl_mutex
+c03e2ae0 d netfilter_proc_ops
+c03e2af0 d nf_hook_mutex
+c03e2b0c d afinfo_mutex
+c03e2b28 d nflog_seq_ops
+c03e2b38 d nf_log_mutex
+c03e2b54 d nfqueue_seq_ops
+c03e2b64 d queue_handler_lock
+c03e2b74 d nf_sockopt_mutex
+c03e2b90 d nf_sockopts
+c03e2ba0 D nf_net_netfilter_sysctl_path
+c03e2c00 D nf_net_ipv4_netfilter_sysctl_path
+c03e2c60 d nf_net_netfilter_table
+c03e2cc0 d nf_net_ipv4_table
+c03e2d20 d nf_net_ipv4_netfilter_table
+c03e2d80 D ip_tos2prio
+c03e2da0 D ipv4_route_table
+c03e3110 D ip_rt_net_ops
+c03e3120 d ip_rt_min_delay
+c03e3124 d ip_rt_max_delay
+c03e3140 d ipv4_dst_ops
+c03e3170 d ip_rt_gc_min_interval
+c03e3174 d ip_rt_gc_timeout
+c03e3178 d ip_rt_gc_interval
+c03e317c d ip_rt_redirect_load
+c03e3180 d ip_rt_redirect_number
+c03e3184 d ip_rt_redirect_silence
+c03e3188 d ip_rt_error_cost
+c03e318c d ip_rt_error_burst
+c03e3190 d ip_rt_gc_elasticity
+c03e3194 d ip_rt_mtu_expires
+c03e3198 d ip_rt_min_pmtu
+c03e319c d ip_rt_min_advmss
+c03e31a0 d ip_rt_secret_interval
+c03e31a4 d expire.35644
+c03e31c0 d ipv4_dst_blackhole_ops
+c03e31f0 d ip_fb_id_lock.35856
+c03e3200 d rt_peer_lock.35846
+c03e3210 d rt_flush_lock
+c03e3220 D inet_peer_idlock
+c03e3230 d inet_peer_unused_lock
+c03e3240 d peer_pool_lock
+c03e3260 d peer_fake_node
+c03e328c d inet_peers_net_ops
+c03e329c d inet_proto_lock
+c03e32ac d ipfrag_net_ops
+c03e32bc d ipfrag_lock
+c03e32cc D ip_ra_lock
+c03e32dc d tcp_net_ops
+c03e3300 D ipv4_specific
+c03e3340 D tcp_prot
+c03e3bf0 d tcp4_proc_net_ops
+c03e3c00 d tcp4_seq_afinfo
+c03e3c14 d tcp_timewait_sock_ops
+c03e3c40 D tcp_death_row
+c03e3d60 D tcp_reno
+c03e3dc0 D tcp_init_congestion_ops
+c03e3e08 d tcp_cong_list
+c03e3e10 d tcp_cong_list_lock
+c03e3e20 D raw_v4_lock
+c03e3e40 D raw_prot
+c03e46f0 d raw_proc_net_ops
+c03e4700 D udp_hash_lock
+c03e4720 D udp_prot
+c03e4fd0 d udp4_proc_net_ops
+c03e4fe0 d udp4_seq_afinfo
+c03e5000 D udplite_prot
+c03e58b0 d udplite_protocol
+c03e58c4 d udplite4_protosw
+c03e58e0 d udplite4_seq_afinfo
+c03e5900 D arp_broken_ops
+c03e5920 D arp_tbl
+c03e5a40 d arp_direct_ops
+c03e5a5c d arp_hh_ops
+c03e5a78 d arp_generic_ops
+c03e5aa0 d arp_packet_type
+c03e5ac0 d arp_net_ops
+c03e5ad0 d arp_netdev_notifier
+c03e5ae0 D icmp_err_convert
+c03e5b60 D sysctl_icmp_ipod_version
+c03e5b64 D sysctl_icmp_ipod_host
+c03e5b68 D sysctl_icmp_ipod_mask
+c03e5b80 D sysctl_icmp_ipod_key
+c03e5ba4 d icmp_net_ops
+c03e5bc0 d devinet_net_ops
+c03e5bd0 d ip_netdev_notifier
+c03e5be0 d inetaddr_chain
+c03e5c00 d devinet_sysctl
+c03e6140 d ipv4_devconf_template
+c03e61a0 d ipv4_devconf_dflt_template
+c03e6200 d inet_net_ops
+c03e6210 d inet_family_ops
+c03e621c d icmp_protocol
+c03e6230 d udp_protocol
+c03e6244 d tcp_protocol
+c03e6260 d inetsw_array
+c03e62c0 d ip_packet_type
+c03e62e0 d inetsw_lock
+c03e6300 D ipv4_table
+c03e6d00 D multi_ipv4_table
+c03e7070 d tcp_retr1_max
+c03e7074 d ip_local_port_range_min
+c03e707c d ip_local_port_range_max
+c03e7084 d fib_net_ops
+c03e7094 d fib_netdev_notifier
+c03e70a0 d fib_inetaddr_notifier
+c03e70ac d fib_info_lock
+c03e70bc d fib_hash_lock
+c03e70e0 d fib4_rule_table
+c03e7254 d tunnel4_protocol
+c03e7268 d tunnel64_protocol
+c03e727c d tunnel4_mutex
+c03e7298 d nf_ip_afinfo
+c03e72c0 d cubictcp
+c03e7308 d __param_str_fast_convergence
+c03e7323 d __param_str_max_increment
+c03e733b d __param_str_beta
+c03e734a d __param_str_initial_ssthresh
+c03e7365 d __param_str_bic_scale
+c03e7379 d __param_str_tcp_friendliness
+c03e73a0 d xfrm4_policy_afinfo
+c03e77e0 d xfrm4_dst_ops
+c03e7810 d xfrm4_state_afinfo
+c03e7840 D xfrm_cfg_mutex
+c03e785c d xfrm_dev_notifier
+c03e7868 d xfrm_policy_lock
+c03e7878 d xfrm_policy_gc_lock
+c03e7888 d xfrm_policy_afinfo_lock
+c03e7898 d xfrm_hash_work
+c03e78a8 d hash_resize_mutex
+c03e78c4 D km_waitq
+c03e78dc d xfrm_state_net_ops
+c03e78ec d xfrm_state_gc_lock
+c03e78fc d xfrm_state_afinfo_lock
+c03e790c d xfrm_km_lock
+c03e791c d xfrm_km_list
+c03e7924 d xfrm_state_lock
+c03e7934 d acqseq_lock.31437
+c03e7944 d xfrm_hash_work
+c03e7954 d hash_resize_mutex
+c03e7980 d ealg_list
+c03e7a60 d aalg_list
+c03e7b00 d calg_list
+c03e7b60 D unix_table_lock
+c03e7b80 d unix_proto
+c03e8430 d unix_family_ops
+c03e843c d unix_net_ops
+c03e844c d unix_seq_ops
+c03e845c d ordernum.26955
+c03e8460 d unix_gc_sem.25955
+c03e847c d gc_current
+c03e8480 d unix_sysctl
+c03e85a0 d rawv6_protosw
+c03e85bc d inet6_family_ops
+c03e85c8 d inetsw6_lock
+c03e85d8 d ac6_seq_ops
+c03e85e8 d ipv6_sk_ac_lock
+c03e85f8 d ip6_id_lock.31143
+c03e8608 d ipv6_fragmentation_id.31142
+c03e860c d ipv6_dev_notf
+c03e8618 d addrconf_hash_lock
+c03e8628 d addr_chk_timer
+c03e8640 d addrconf_verify_lock
+c03e8650 d inet6addr_chain
+c03e8664 d if6_seq_ops
+c03e8680 D ip6_rt_gc_interval
+c03e86a0 D ip6_null_entry
+c03e8780 D ipv6_route_table
+c03e8980 d ip6_dst_ops
+c03e89b0 d ip6_rt_max_size
+c03e89b4 d ip6_rt_gc_min_interval
+c03e89b8 d ip6_rt_gc_timeout
+c03e89bc d ip6_rt_gc_elasticity
+c03e89c0 d ip6_rt_mtu_expires
+c03e89c4 d ip6_rt_min_advmss
+c03e89c8 d expire.34552
+c03e89e0 d ip6_dst_blackhole_ops
+c03e8a10 d ndisc_lock
+c03e8a20 d ip6_fib_timer
+c03e8a40 d fib6_main_tbl
+c03e8a78 d fib6_walker_lock
+c03e8aa0 d fib6_walker_list
+c03e8ac0 d fib6_gc_lock
+c03e8ae0 D ip6_ra_lock
+c03e8b00 d ipv6_packet_type
+c03e8b20 D nd_tbl
+c03e8c40 d ndisc_direct_ops
+c03e8c5c d ndisc_hh_ops
+c03e8c78 d ndisc_generic_ops
+c03e8c94 d ndisc_netdev_notifier
+c03e8ca0 D udpv6_prot
+c03e9550 d udpv6_protocol
+c03e9564 d udpv6_protosw
+c03e9580 d udp6_seq_afinfo
+c03e95a0 D udplitev6_prot
+c03e9e50 d udplite6_seq_afinfo
+c03e9e68 d udplitev6_protocol
+c03e9e7c d udplite6_protosw
+c03e9ea0 D raw_v6_lock
+c03e9ec0 D rawv6_prot
+c03ea770 d raw6_seq_ops
+c03ea780 d inet6_proto_lock
+c03ea7a0 D ipv6_icmp_table
+c03ea7f8 d icmpv6_protocol
+c03ea80c d igmp6_mcf_seq_ops
+c03ea81c d igmp6_mc_seq_ops
+c03ea82c d mld2_all_mcr
+c03ea83c d ipv6_sk_mc_lock
+c03ea84c d frag_protocol
+c03ea860 d ip6_frag_lock
+c03ea870 d ip6_frag_lru_list
+c03ea880 D tcpv6_prot
+c03eb140 d ipv6_mapped
+c03eb180 d ipv6_specific
+c03eb1b0 d tcpv6_protocol
+c03eb1c4 d tcpv6_protosw
+c03eb1e0 d tcp6_seq_afinfo
+c03eb1f4 d tcp6_timewait_sock_ops
+c03eb204 d tlvprochopopt_lst
+c03eb21c d rthdr_protocol
+c03eb230 d nodata_protocol
+c03eb244 d destopt_protocol
+c03eb258 d tlvprocdestopt_lst
+c03eb260 d ipv6_root_table
+c03eb2c0 d ipv6_net_table
+c03eb320 d ipv6_table
+c03eb4ac d ip6_fl_gc_timer
+c03eb4c4 d ip6_fl_lock
+c03eb4d4 d ip6fl_seq_ops
+c03eb4e4 d ip6_sk_fl_lock
+c03eb500 d xfrm6_policy_afinfo
+c03eb940 d xfrm6_dst_ops
+c03eb970 d xfrm6_state_afinfo
+c03eb988 d nf_ip6_afinfo
+c03eb9a0 d snmp6_ipstats_list
+c03eba60 d snmp6_icmp6_list
+c03ebb60 d snmp6_udp6_list
+c03ebba0 d snmp6_udplite6_list
+c03ebbc8 d xfrm6_transport_mode
+c03ebbd8 d xfrm6_tunnel_mode
+c03ebbe8 d xfrm6_beet_mode
+c03ebbf8 d sit_handler
+c03ebc08 d ipip6_lock
+c03ebc20 d packet_proto
+c03ec4d0 d packet_family_ops
+c03ec4dc d packet_net_ops
+c03ec4ec d packet_netdev_notifier
+c03ec4f8 d packet_seq_ops
+c03ec508 d packet_mmap_ops
+c03ec524 d wireless_nlevent_tasklet
+c03ec540 D net_table
+c03ec5e0 D multi_net_table
+c03ec680 D net_root_table
+c03ed000 D __nosave_begin
+c03ed000 D __nosave_end
+c03ed000 D idt_table
+c03ed800 D cpu_data
+c03ee800 D doublefault_tss
+c03f0a00 D tasklist_lock
+c03f0a80 D mmlist_lock
+c03f0b00 d softirq_vec
+c03f0c00 D jiffies
+c03f0c00 D jiffies_64
+c03f0c80 d pidmap_lock
+c03f0d00 V xtime_lock
+c03f0d80 d acct_globals
+c03f0e00 D irq_desc
+c03f7e00 d dirty_exceeded
+c03f7e80 d kmap_lock
+c03f7f00 D files_lock
+c03f7f80 d nr_files
+c03f8000 D dcache_lock
+c03f8080 d rename_lock
+c03f8100 D vfsmount_lock
+c03f8180 d bdev_lock
+c03f8200 D ide_lock
+c03f8280 D tcp_hashinfo
+c03f8400 D __per_cpu_offset
+c03f8480 d hardirq_ctx
+c03f84c0 d softirq_ctx
+c03f8500 D boot_cpu_data
+c03f8600 d mxcsr_feature_mask
+c03f8604 d cyc2ns_scale
+c03f8680 D movsl_mask
+c03f8700 D x86_cpu_to_apicid
+c03f8710 D cpu_2_logical_apicid
+c03f8720 D cpu_online_map
+c03f8740 D cpu_sibling_map
+c03f8780 D cpu_core_map
+c03f87c0 d irq_vector
+c03f89c0 d ioapic_chip
+c03f8a00 d lapic_chip
+c03f8a40 D vdso_enabled
+c03f8a48 D __supported_pte_mask
+c03f8a50 D nr_cpu_ids
+c03f8a54 D cpu_present_map
+c03f8a58 d ignore_loglevel
+c03f8a5c D prof_on
+c03f8a60 D timer_hook
+c03f8a64 d singlethread_cpu
+c03f8a68 d cpu_singlethread_map
+c03f8a6c d cpu_populated_map
+c03f8a70 d keventd_wq
+c03f8a74 D tick_do_timer_cpu
+c03f8a78 d irqfixup
+c03f8a7c D noirqdebug
+c03f8a80 D node_online_map
+c03f8a84 D node_possible_map
+c03f8a88 D totalram_pages
+c03f8a8c D totalreserve_pages
+c03f8a90 d kswapd_min_order
+c03f8a94 D sysctl_stat_interval
+c03f8a98 D totalhigh_pages
+c03f8a9c D randomize_va_space
+c03f8aa0 D sysctl_max_map_count
+c03f8aa4 d shmem_backing_dev_info
+c03f8ac0 d use_alien_caches
+c03f8ae0 d pipe_mnt
+c03f8ae4 d fasync_cache
+c03f8ae8 d filelock_cache
+c03f8aec D sysctl_vfs_cache_pressure
+c03f8af0 d dentry_cache
+c03f8af4 d d_hash_mask
+c03f8af8 d d_hash_shift
+c03f8afc d dentry_hashtable
+c03f8b00 D names_cachep
+c03f8b04 D filp_cachep
+c03f8b08 d i_hash_mask
+c03f8b0c d i_hash_shift
+c03f8b10 d inode_hashtable
+c03f8b14 d inode_cachep
+c03f8b18 d mount_hashtable
+c03f8b1c d hash_mask
+c03f8b20 d hash_bits
+c03f8b24 d mnt_cache
+c03f8b40 d bvec_slabs
+c03f8b88 d bio_slab
+c03f8b8c D bio_split_pool
+c03f8b90 d bdev_cachep
+c03f8b94 d bd_mnt
+c03f8b98 d watch_cachep
+c03f8b9c d event_cachep
+c03f8ba0 d inotify_mnt
+c03f8ba4 D inotify_max_user_instances
+c03f8ba8 D inotify_max_user_watches
+c03f8bac D inotify_max_queued_events
+c03f8bb0 d epi_cache
+c03f8bb4 d pwq_cache
+c03f8bb8 d anon_inode_mnt
+c03f8bbc D dir_notify_enable
+c03f8bc0 d dn_cache
+c03f8bc4 d dcookie_cache
+c03f8bc8 d dcookie_hashtable
+c03f8bcc d hash_size
+c03f8be0 d blktrace_seq
+c03f8be4 d ddir_act
+c03f8c00 d bio_act
+c03f8c24 d height_to_maxindex
+c03f8c40 d vga_hardscroll_user_enable
+c03f8c44 d vga_init_done
+c03f8c48 d vga_vram_base
+c03f8c4c d vga_vram_end
+c03f8c50 d vga_vram_size
+c03f8c54 d vga_video_port_reg
+c03f8c56 d vga_video_port_val
+c03f8c58 d vga_can_do_color
+c03f8c5c d vga_default_font_height
+c03f8c60 d vga_video_type
+c03f8c61 d vga_hardscroll_enabled
+c03f8c64 d vga_scan_lines
+c03f8c68 d trickle_thresh
+c03f8c6c D __sysrq_enabled
+c03f8c70 d sysrq_always_enabled
+c03f8c74 D pmtmr_ioport
+c03f8c80 d net_families
+c03f8d08 d sock_inode_cachep
+c03f8d0c d sock_mnt
+c03f8d20 D sysctl_wmem_max
+c03f8d24 D sysctl_rmem_max
+c03f8d28 D sysctl_wmem_default
+c03f8d2c D sysctl_rmem_default
+c03f8d30 D sysctl_optmem_max
+c03f8d34 d skbuff_head_cache
+c03f8d38 d skbuff_fclone_cache
+c03f8d40 D netdev_max_backlog
+c03f8d44 D netdev_budget
+c03f8d48 D weight_p
+c03f8d60 d ptype_base
+c03f8de0 d ptype_all
+c03f8e00 d neigh_sysctl_template
+c03f92a8 D net_msg_cost
+c03f92ac D net_msg_burst
+c03f92b0 D net_msg_warn
+c03f92b4 d flow_cachep
+c03f92b8 d nla_attr_minlen
+c03f92e0 D nf_hooks
+c03f9b60 D nf_afinfo
+c03f9be8 d peer_cachep
+c03f9bec D ip_statistics
+c03f9bf4 D sysctl_tcp_fin_timeout
+c03f9bf8 D sysctl_tcp_mem
+c03f9c04 D sysctl_tcp_wmem
+c03f9c10 D sysctl_tcp_rmem
+c03f9c1c D tcp_memory_pressure
+c03f9c20 D tcp_statistics
+c03f9c28 D sysctl_tcp_sack
+c03f9c2c D sysctl_tcp_fack
+c03f9c30 D sysctl_tcp_reordering
+c03f9c34 D sysctl_tcp_dsack
+c03f9c38 D sysctl_tcp_app_win
+c03f9c3c D sysctl_tcp_adv_win_scale
+c03f9c40 D sysctl_tcp_max_orphans
+c03f9c44 D sysctl_tcp_moderate_rcvbuf
+c03f9c48 D sysctl_tcp_stdurg
+c03f9c4c D sysctl_tcp_rfc1337
+c03f9c50 D sysctl_tcp_ecn
+c03f9c54 D sysctl_tcp_frto
+c03f9c58 D sysctl_tcp_frto_response
+c03f9c5c D sysctl_tcp_nometrics_save
+c03f9c60 D sysctl_tcp_abc
+c03f9c64 D sysctl_tcp_retrans_collapse
+c03f9c68 D sysctl_tcp_workaround_signed_windows
+c03f9c6c D sysctl_tcp_tso_win_divisor
+c03f9c70 D sysctl_tcp_mtu_probing
+c03f9c74 D sysctl_tcp_base_mss
+c03f9c78 D sysctl_tcp_slow_start_after_idle
+c03f9c7c D sysctl_tcp_syn_retries
+c03f9c80 D sysctl_tcp_synack_retries
+c03f9c84 D sysctl_tcp_keepalive_time
+c03f9c88 D sysctl_tcp_keepalive_probes
+c03f9c8c D sysctl_tcp_keepalive_intvl
+c03f9c90 D sysctl_tcp_retries1
+c03f9c94 D sysctl_tcp_retries2
+c03f9c98 D sysctl_tcp_orphan_retries
+c03f9c9c D tcp_request_sock_ops
+c03f9cb8 d tcp_socket
+c03f9cbc D sysctl_tcp_tw_reuse
+c03f9cc0 D sysctl_tcp_low_latency
+c03f9cc4 D sysctl_tcp_syncookies
+c03f9cc8 D sysctl_tcp_abort_on_overflow
+c03f9ccc D udp_statistics
+c03f9cd4 D udplite_statistics
+c03f9cdc D sysctl_icmp_echo_ignore_broadcasts
+c03f9ce0 D sysctl_icmp_ignore_bogus_error_responses
+c03f9ce4 D sysctl_icmp_ratelimit
+c03f9ce8 D sysctl_icmp_ratemask
+c03f9cec D icmp_statistics
+c03f9cf4 D sysctl_icmp_echo_ignore_all
+c03f9cf8 D sysctl_icmp_errors_use_inbound_ifaddr
+c03f9cfc D inet_ehash_secret
+c03f9d00 D net_statistics
+c03f9d08 D sysctl_igmp_max_memberships
+c03f9d0c D sysctl_igmp_max_msf
+c03f9d10 d fn_hash_kmem
+c03f9d14 d fn_alias_kmem
+c03f9d18 d fast_convergence
+c03f9d1c d max_increment
+c03f9d20 d beta
+c03f9d24 d bic_scale
+c03f9d28 d tcp_friendliness
+c03f9d2c d initial_ssthresh
+c03f9d30 d cube_rtt_scale
+c03f9d34 d beta_scale
+c03f9d38 d cube_factor
+c03f9d40 d xfrm_policy_hashmax
+c03f9d44 d xfrm_dst_cache
+c03f9d60 d xfrm_policy_bydst
+c03f9d90 d xfrm_policy_byidx
+c03f9d94 d xfrm_idx_hmask
+c03f9d98 d xfrm_state_hashmax
+c03f9d9c d xfrm_state_bydst
+c03f9da0 d xfrm_state_bysrc
+c03f9da4 d xfrm_state_byspi
+c03f9da8 d xfrm_state_hmask
+c03f9dac d secpath_cachep
+c03f9dc0 D sysctl_ipv6_bindv6only
+c03f9de0 D ipv6_devconf
+c03f9e40 d ipv6_devconf_dflt
+c03f9ea0 d addrconf_sysctl
+c03fa47c d fib6_node_kmem
+c03fa480 D ipv6_statistics
+c03fa488 D udp_stats_in6
+c03fa490 D udplite_stats_in6
+c03fa498 d sysctl_icmpv6_time
+c03fa49c D icmpv6_statistics
+c03fa4a4 D sysctl_mld_max_msf
+c03fa4a8 D sysctl_ip6frag_high_thresh
+c03fa4ac D sysctl_ip6frag_low_thresh
+c03fa4b0 D sysctl_ip6frag_time
+c03fa4b4 D sysctl_ip6frag_secret_interval
+c03fa4b8 d tcp6_request_sock_ops
+c03fa4d4 D _edata
+c03fb000 D init_thread_union
+c03fc000 R __smp_locks
+c03ffc6c R __smp_locks_end
+c0400000 T __init_begin
+c0400000 T _sinittext
+c0400000 T startup_32_smp
+c0400080 t checkCPUtype
+c0400101 t is486
+c0400108 t is386
+c0400173 t check_x87
+c040019a t setup_idt
+c04001b7 t rp_sidt
+c040023b t early_divide_err
+c0400241 t early_illegal_opcode
+c040024a t early_protection_fault
+c0400251 t early_page_fault
+c0400258 t early_fault
+c0400280 t hlt_loop
+c0400284 t ignore_int
+c04002c5 t nosmp
+c04002d5 t set_reset_devices
+c04002e5 t debug_kernel
+c04002fb t quiet_kernel
+c0400311 t init_setup
+c040032f t rdinit_setup
+c040034d W smp_setup_processor_id
+c040034e t initcall_debug_setup
+c040035e t loglevel
+c0400377 t maxcpus
+c0400390 t do_early_param
+c04003f3 T parse_early_param
+c0400440 t unknown_bootoption
+c0400642 t kernel_init
+c04008e9 T start_kernel
+c0400bf5 t readonly
+c0400c08 t readwrite
+c0400c1b t root_data_setup
+c0400c26 t fs_names_setup
+c0400c31 t root_delay_setup
+c0400c45 t root_dev_setup
+c0400c5c t load_ramdisk
+c0400c73 T change_floppy
+c0400d85 T mount_block_root
+c0400fb5 T mount_root
+c040100f T prepare_namespace
+c0401151 t ramdisk_start_setup
+c0401165 t prompt_ramdisk
+c040117c t error
+c04011a6 t fill_inbuf
+c0401201 t flush_window
+c04012aa t free
+c04012af t huft_free
+c04012c5 t inflate_codes
+c04016e3 t malloc
+c04016ed t huft_build
+c0401c5c t inflate_dynamic
+c04021b3 t inflate_fixed
+c0402321 T rd_load_image
+c04031e1 T rd_load_disk
+c0403292 t no_initrd
+c04032a2 T initrd_load
+c0403605 t do_linuxrc
+c0403697 t md_setup
+c040384f T md_run_setup
+c0403dad t raid_setup
+c0403eaa t read_into
+c0403f0c t do_start
+c0403f23 t write_buffer
+c0403f4b t flush_window
+c0403ffa t retain_initrd_param
+c0404010 t inflate_codes
+c0404400 t malloc
+c040440a t clean_path
+c0404458 t do_symlink
+c04044d4 t maybe_link
+c04045bc t free
+c04045c1 t huft_free
+c04045d7 t huft_build
+c0404b46 t inflate_fixed
+c0404cb4 t do_name
+c0404e72 t free_initrd
+c0404f05 t do_collect
+c0404f7b t do_skip
+c0405004 t do_copy
+c04050b1 t do_header
+c040529b t inflate_dynamic
+c04057d7 t unpack_to_rootfs
+c04060dd t populate_rootfs
+c04061bd t do_reset
+c040626d t lpj_setup
+c0406281 t parse_apic
+c04062d5 T acpi_madt_oem_check
+c0406335 T mps_oem_check
+c04063a0 T generic_bigsmp_probe
+c04063e4 T generic_apic_probe
+c0406441 t mps_oem_check
+c040647b t acpi_madt_oem_check
+c04064e8 t enable_apic_mode
+c04064ed T setup_unisys
+c0406520 T parse_unisys_oem
+c04065c4 T es7000_sw_apic
+c04066eb T find_unisys_acpi_oem_table
+c0406743 t idle_setup
+c04067ce t set_trap_gate
+c04067ed t set_system_gate
+c040680c T early_trap_init
+c0406848 t code_bytes_setup
+c040686a t kstack_setup
+c040687e T trap_init
+c0406a0f T time_init
+c0406a1f T hpet_time_init
+c0406a32 t parse_vmalloc
+c0406a53 t parse_highmem
+c0406a7b t parse_elfcorehdr
+c0406aa2 t parse_reservetop
+c0406ac3 t parse_mem
+c0406b23 T find_max_low_pfn
+c0406c50 W memory_setup
+c0406c55 T remapped_pgdat_init
+c0406c56 T setup_bootmem_allocator
+c0406d85 T zone_sizes_init
+c0406dce T setup_arch
+c0407136 t i8259A_init_sysfs
+c040714f W init_IRQ
+c040714f T native_init_IRQ
+c04071af T init_ISA_irqs
+c040721b t parity
+c0407235 t sbf_init
+c0407303 t romsignature
+c0407338 t romchecksum
+c040738b t efi_find_max_pfn
+c04073a1 t efi_memory_present_wrapper
+c04073a4 T e820_all_mapped
+c0407456 T print_memory_map
+c0407515 T e820_register_memory
+c04075e2 T add_memory_region
+c0407645 T copy_e820_map
+c0407741 T sanitize_e820_map
+c04079f1 t request_standard_resources
+c0407d15 T limit_regions
+c0407ee1 T find_max_pfn
+c0407f85 t parse_memmap
+c0408058 T register_bootmem_low_pages
+c04080f2 t free_available_memory
+c0408119 t i8237A_init_sysfs
+c0408132 t topology_init
+c040815d t bootonly
+c040816d t debug_alt
+c040817d t setup_noreplace_smp
+c040818d T alternative_instructions
+c0408211 t init_pit_clocksource
+c040826e T setup_pit_timer
+c04082fa t dmi_mark_tsc_unstable
+c040831f t tsc_setup
+c0408335 T unsynchronized_tsc
+c040837d T tsc_init
+c04084af T get_model_name
+c0408574 t x86_sep_setup
+c0408584 T cpu_detect
+c0408619 t x86_serial_nr_setup
+c0408629 t cachesize_setup
+c0408642 T print_cpu_info
+c04086fc t get_cpu_vendor
+c04087ae T early_cpu_init
+c0408817 t identify_cpu
+c0408bb4 T identify_secondary_cpu
+c0408bce T identify_boot_cpu
+c0408be7 t default_init
+c0408c11 t x86_fxsr_setup
+c0408c33 T detect_ht
+c0408d74 T display_cacheinfo
+c0408e37 T cpu_init
+c040907e t no_halt
+c040908b t mca_pentium
+c040909b t no_387
+c04090b1 T check_bugs
+c04091c5 t amd_size_cache
+c04091ed T amd_init_cpu
+c04091fa t init_amd
+c04096d5 t do_cyrix_devid
+c040975f T cyrix_init_cpu
+c040976c T nsc_init_cpu
+c0409779 t init_cyrix
+c0409bad t init_nsc
+c0409bcb t cyrix_identify
+c0409c68 t centaur_size_cache
+c0409c94 T centaur_init_cpu
+c0409ca1 t init_centaur
+c0409f21 t transmeta_identify
+c0409f54 T transmeta_init_cpu
+c0409f61 t init_transmeta
+c040a1a2 T early_intel_workaround
+c040a1bb t intel_size_cache
+c040a1d6 T intel_cpu_init
+c040a1e3 T ppro_with_ram_bug
+c040a217 t init_intel
+c040a424 t cpuid4_cache_lookup
+c040a62f t cacheinfo_cpu_callback
+c040a917 t cache_sysfs_init
+c040a956 T init_intel_cacheinfo
+c040ad92 T rise_init_cpu
+c040ad9f t init_rise
+c040adfc t init_nexgen
+c040ae04 t nexgen_identify
+c040ae37 T nexgen_init_cpu
+c040ae44 T umc_init_cpu
+c040ae51 t mcheck_disable
+c040ae61 t mcheck_enable
+c040ae71 t thermal_throttle_init_device
+c040aee5 t mtrr_init_finialize
+c040af0d T mtrr_bp_init
+c040b13b t mtrr_if_init
+c040b18f T mtrr_state_warn
+c040b1eb T amd_init_mtrr
+c040b1f8 T cyrix_init_mtrr
+c040b205 T centaur_init_mtrr
+c040b212 t acpi_parse_lapic_addr_ovr
+c040b23f t acpi_scan_rsdp
+c040b291 T acpi_find_rsdp
+c040b2ce t parse_acpi_skip_timer_override
+c040b2db t parse_acpi_use_timer_override
+c040b2e8 t acpi_parse_fadt
+c040b333 t acpi_parse_hpet
+c040b38b t acpi_parse_sbf
+c040b3b2 t acpi_parse_nmi_src
+c040b3d5 t acpi_parse_lapic_nmi
+c040b413 t acpi_parse_lapic
+c040b449 t acpi_sci_ioapic_setup
+c040b49b T acpi_boot_init
+c040b6ef t acpi_parse_int_src_ovr
+c040b792 t acpi_parse_ioapic
+c040b7c7 t acpi_parse_madt
+c040b82c T acpi_parse_mcfg
+c040b905 t parse_pci
+c040b93f t setup_acpi_sci
+c040b9f4 t dmi_disable_acpi
+c040ba4e t force_acpi_ht
+c040baa8 T acpi_boot_table_init
+c040bb72 t parse_acpi
+c040bcb3 t disable_acpi_irq
+c040bce1 t disable_acpi_pci
+c040bd19 T acpi_pic_sci_set_trigger
+c040bd93 t nvidia_hpet_check
+c040bd96 T check_acpi_pci
+c040be8d t reboot_setup
+c040bf3e t reboot_init
+c040bf4b t set_bios_reboot
+c040bf79 t parse_maxcpus
+c040bf8a T smp_intr_init
+c040bfc7 T native_smp_cpus_done
+c040bfd1 t smp_store_cpu_info
+c040c085 T native_smp_prepare_cpus
+c040cac8 T native_cpu_up
+c040cb36 T native_smp_prepare_boot_cpu
+c040cb7f t start_secondary
+c040ceb0 T smp_alloc_memory
+c040cee1 t check_tsc_warp
+c040d046 T check_tsc_sync_source
+c040d137 T check_tsc_sync_target
+c040d16e T init_gdt
+c040d1cd t mpf_checksum
+c040d1e6 t ELCR_trigger
+c040d200 t MP_bus_info
+c040d36a T mp_config_acpi_legacy_irqs
+c040d44d T mp_override_legacy_irq
+c040d505 t MP_intsrc_info
+c040d53e t construct_default_ioirq_mptable
+c040d640 t MP_ioapic_info
+c040d6d6 T mp_register_ioapic
+c040d80c t MP_processor_info
+c040d937 T mp_register_lapic
+c040da0c t smp_scan_config
+c040dad7 T find_smp_config
+c040db24 T get_smp_config
+c040df47 T mp_register_lapic_address
+c040df85 t parse_lapic
+c040df92 t parse_nolapic
+c040dfa8 t parse_disable_lapic_timer
+c040dfb5 t parse_lapic_timer_c2_ok
+c040dfc2 t init_lapic_sysfs
+c040dfeb T connect_bsp_APIC
+c040e023 T verify_local_APIC
+c040e151 T apic_intr_init
+c040e192 T setup_boot_APIC_clock
+c040e5cf t apic_set_verbosity
+c040e633 T sync_Arb_IDs
+c040e66b t lapic_cal_handler
+c040e717 T init_bsp_APIC
+c040e792 T init_apic_mappings
+c040e9f4 T APIC_init_uniprocessor
+c040eaf3 t init_lapic_nmi_sysfs
+c040eb20 t setup_nmi_watchdog
+c040eb47 t check_nmi_watchdog
+c040ece1 t nmi_cpu_busy
+c040ecf4 t ioapic_setup
+c040ed04 t find_isa_irq_pin
+c040ed5f t find_isa_irq_apic
+c040edd3 t notimercheck
+c040ede3 t setup_disable_8254_timer
+c040edf3 t setup_enable_8254_timer
+c040ee03 t io_apic_bug_finalize
+c040ee1b t parse_disable_timer_pin_1
+c040ee28 t parse_enable_timer_pin_1
+c040ee35 t parse_noapic
+c040ee42 T io_apic_get_redir_entries
+c040ee79 T print_IO_APIC
+c040f211 t ioapic_pirq_setup
+c040f2a5 T setup_ioapic_dest
+c040f2fc T timer_irq_works
+c040f33b T setup_IO_APIC
+c0410080 t ioapic_init_sysfs
+c0410135 T io_apic_get_unique_id
+c0410333 T io_apic_get_version
+c0410365 t parse_crashkernel
+c04103af t kdump_buf_page_init
+c04103e1 T arch_init_kprobes
+c04103e4 t vdso_setup
+c04103f8 T sysenter_setup
+c04106d2 T efi_initialize_iomem_resources
+c0410858 T efi_enter_virtual_mode
+c04109cb T efi_map_memmap
+c0410a1d T efi_init
+c0410ef4 t early_serial_init
+c0411030 t setup_early_printk
+c04111cc t hpet_setup
+c041120e t hpet_register_sysfs
+c0411253 T hpet_enable
+c04114b0 t add_pcspkr
+c04114e1 T native_pagetable_setup_start
+c04114e2 T native_pagetable_setup_done
+c04114e3 T pgtable_cache_init
+c04114e4 t one_page_table_init
+c041152a t page_table_range_init
+c0411584 t free_new_highpage
+c0411599 T online_page
+c04115d6 T add_one_highpage_init
+c0411611 T mem_init
+c04119a3 T paging_init
+c0411bda t noexec_setup
+c0411c4d T bt_iounmap
+c0411c8a T bt_ioremap
+c0411d0f T boot_ioremap
+c0411d84 T pre_setup_arch_hook
+c0411d85 T trap_init_hook
+c0411d86 t print_ipi_mode
+c0411db2 t no_ipi_broadcast
+c0411df4 T machine_specific_memory_setup
+c0411e92 T time_init_hook
+c0411ea8 T intr_init_hook
+c0411ec6 T pre_intr_init_hook
+c0411ecb t setup_max_cache_size
+c0411ee8 t setup_migration_debug
+c0411f05 t setup_migration_factor
+c0411f3a t migration_cost_setup
+c0411fbd T init_idle
+c0412037 t migration_call
+c0412105 T migration_init
+c041214c t isolated_cpu_setup
+c0412190 T sched_init_smp
+c04121ec T sched_init
+c041237f T proc_caches_init
+c0412494 T fork_init
+c0412529 T fork_idle
+c041257e t pause_on_oops_setup
+c0412592 t panic_setup
+c04125a6 t printk_time_setup
+c04125bc T add_preferred_console
+c0412658 t ignore_loglevel_setup
+c0412678 t log_buf_len_setup
+c041277c t console_setup
+c041281c t profile_nop
+c041281d t create_proc_profile
+c041298c T profile_init
+c04129c4 t profile_setup
+c0412bc0 t cpu_callback
+c0412c52 T spawn_ksoftirqd
+c0412c95 T softirq_init
+c0412cbe t ioresources_init
+c0412cf3 t reserve_setup
+c0412db5 t sysctl_init
+c0412dc4 t timer_cpu_notify
+c0412f34 T init_timers
+c0412f70 t uid_cache_init
+c0412fdd T signals_init
+c0413014 T usermodehelper_init
+c0413033 T init_workqueues
+c0413076 T pidmap_init
+c04130cd T pidhash_init
+c0413162 t rcu_cpu_notify
+c04131c0 T rcu_init
+c04131e0 T sort_main_extable
+c04131ef t kernel_param_sysfs_setup
+c041326e t param_sysfs_init
+c0413425 t init_posix_timers
+c04134b6 t init_posix_cpu_timers
+c0413550 t hrtimer_cpu_notify
+c0413585 T hrtimers_init
+c04135a5 t latency_init
+c04135c1 t nsproxy_cache_init
+c04135f7 t init_network
+c041365a t init_vserver
+c041365d t timekeeping_init_device
+c0413676 T timekeeping_init
+c041377b t clocksource_done_booting
+c0413788 t boot_override_clocksource
+c04137c1 t boot_override_clock
+c041380e t init_clocksource_sysfs
+c041384d t init_jiffies_clocksource
+c0413857 t init_timer_list_procfs
+c041387d T tick_init
+c0413887 t init
+c0413905 t proc_dma_init
+c0413921 T cpu_up
+c0413a54 T register_cpu_notifier
+c0413a7d t kallsyms_init
+c0413a9c t pm_init
+c0413aba t crash_notes_memory_init
+c0413af1 T container_init
+c0413b39 T container_init_early
+c0413c4b t init_kprobes
+c0413c8e t ksysfs_init
+c0413cac t cpu_callback
+c0413d73 T spawn_softlockup_task
+c0413dc2 t irqpoll_setup
+c0413dee t irqfixup_setup
+c0413e1a t relay_init
+c0413e1d t utsname_sysctl_init
+c0413e2a T bootmem_bootmap_pages
+c0413e39 t get_mapsize
+c0413e50 t free_bootmem_core
+c0413ea7 T free_bootmem
+c0413eb2 T free_bootmem_node
+c0413eba t reserve_bootmem_core
+c0413f15 T reserve_bootmem
+c0413f20 T reserve_bootmem_node
+c0413f28 t free_all_bootmem_core
+c0414080 T free_all_bootmem
+c041408a T free_all_bootmem_node
+c041408f t init_bootmem_core
+c0414133 T init_bootmem
+c0414154 T init_bootmem_node
+c0414159 T __alloc_bootmem_core
+c04143d9 T __alloc_bootmem_low_node
+c04143fb T __alloc_bootmem_low
+c0414462 T __alloc_bootmem_nopanic
+c04144af T __alloc_bootmem
+c04144de T __alloc_bootmem_node
+c041451c T memmap_init_zone
+c0414571 t first_active_region_index_in_nid
+c0414599 t next_active_region_index_in_nid
+c04145cd T early_pfn_to_nid
+c041460a T sparse_memory_present_with_active_regions
+c0414622 T push_node_boundaries
+c0414623 T shrink_active_range
+c0414656 t cmp_node_active_region
+c0414666 T find_max_pfn_with_active_regions
+c041468d T set_dma_reserve
+c0414693 T page_alloc_init
+c0414694 T __absent_pages_in_range
+c0414719 T absent_pages_in_range
+c0414727 t build_zonelists_node
+c0414762 T find_min_pfn_for_node
+c04147b1 T find_min_pfn_with_active_regions
+c04147bb T add_active_range
+c0414893 T get_pfn_range_for_nid
+c0414908 T zone_absent_pages_in_node
+c0414946 T zone_spanned_pages_in_node
+c0414988 t init_per_zone_pages_min
+c04149d1 t __build_all_zonelists
+c0414a80 T free_bootmem_with_active_regions
+c0414acc T init_currently_empty_zone
+c0414b50 T free_area_init_node
+c0414f45 T free_area_init
+c0414f68 T build_all_zonelists
+c0414fb4 T alloc_large_system_hash
+c04151d6 T remove_all_active_ranges
+c04151f1 T free_area_init_nodes
+c0415333 T __free_pages_bootmem
+c0415391 T page_writeback_init
+c04153b6 t ratelimit_handler
+c04153be t pdflush_init
+c04153d0 T swap_setup
+c04153e6 t kswapd_init
+c04153fe T setup_vmstat
+c0415438 t vmstat_cpuup_callback
+c0415485 T page_address_init
+c0415501 t disable_randmaps
+c0415511 T anon_vma_init
+c0415545 t init_emergency_pool
+c04155a5 t procswaps_init
+c04155c1 t init_tmpfs
+c041567a t noaliencache_setup
+c041568a t set_up_list3s
+c04156c6 t cpucache_init
+c04156f1 t cpuup_callback
+c041599d T kmem_cache_init
+c0415d12 T files_init
+c0415d7a T unnamed_dev_init
+c0415d84 T chrdev_init
+c0415d99 t init_pipe_fs
+c0415dd4 t fasync_init
+c0415e0a t filelock_init
+c0415e40 t set_dhash_entries
+c0415e63 T vfs_caches_init
+c0415fb0 T vfs_caches_init_early
+c0416026 t set_ihash_entries
+c0416049 T inode_init
+c04160f7 T inode_init_early
+c0416169 T files_defer_init
+c04161c8 T mnt_init
+c0416386 t aio_setup
+c0416402 T buffer_init
+c0416454 t init_bio
+c041651b T bdev_cache_init
+c0416590 t revokefs_init
+c0416611 t inotify_setup
+c041661e t inotify_user_setup
+c04166e0 t eventpoll_init
+c041677f t anon_inode_init
+c0416860 t init_misc_binfmt
+c041688f t init_script_binfmt
+c0416899 t init_elf_binfmt
+c04168a3 t init_mbcache
+c04168ba t dquot_init
+c04169a3 t init_v2_quota_format
+c04169ad t dnotify_init
+c04169e3 T proc_init_inodecache
+c0416a1f T proc_root_init
+c0416ac3 T proc_tty_init
+c0416b34 T proc_misc_init
+c0416cf1 t get_new_element
+c0416d16 t vmcore_init
+c04176de T sysfs_init
+c041777f t init_devpts_fs
+c04177ab t init_ext3_fs
+c0417815 T init_ext3_xattr
+c0417848 T journal_init_revoke_caches
+c04178d3 t journal_init
+c04179a9 t init_ext2_fs
+c0417a13 T init_ext2_xattr
+c0417a46 t init_cramfs_fs
+c0417a6b T init_rootfs
+c0417a75 t init_ramfs_fs
+c0417a7f t init_iso9660_fs
+c0417aeb T zisofs_init
+c0417b4b t init_nls_cp437
+c0417b55 t init_nls_ascii
+c0417b5f t debugfs_init
+c0417b98 t ipc_init
+c0417baa T ipc_init_proc_interface
+c0417c10 T msg_init
+c0417c3f T sem_init
+c0417c6b T shm_init
+c0417c9a t ipc_sysctl_init
+c0417ca7 t init_mqueue_fs
+c0417d65 t elevator_setup
+c0417db8 T blk_dev_init
+c0417ec2 t genhd_device_init
+c0417f0e T printk_all_partitions
+c0418048 t noop_init
+c0418052 t cfq_init
+c0418114 t blk_trace_init
+c04181b3 t kobject_uevent_init
+c0418203 T prio_tree_init
+c0418225 T radix_tree_init
+c0418295 t random32_reseed
+c04182e1 t random32_init
+c041831f t pci_sort_bf_cmp
+c0418350 t pcibus_class_init
+c041835a T pci_sort_breadthfirst
+c04184b6 t quirk_ioapic_rmw
+c04184d5 t quirk_eisa_bridge
+c04184dd t quirk_tc86c001_ide
+c041851d t quirk_alimagik
+c041853e t quirk_disable_all_msi
+c0418554 t quirk_alder_ioapic
+c04185bf t asus_hides_smbus_hostbridge
+c0418756 t quirk_ide_samemode
+c04187b6 t pci_driver_init
+c04187c0 t pci_sysfs_init
+c04187f1 t pci_proc_init
+c041884c t pcie_portdrv_init
+c041888f t aer_service_init
+c0418899 T pci_assign_unassigned_resources
+c04188e1 t acpi_pci_init
+c0418924 t no_scroll
+c0418938 t acpi_parse_apic_instance
+c041895e T acpi_table_init
+c04189d7 T acpi_table_parse
+c0418a42 T acpi_table_parse_entries
+c0418b4c T acpi_table_parse_madt
+c0418b6a T acpi_blacklisted
+c0418ce6 t acpi_os_name_setup
+c0418d42 t acpi_wake_gpes_always_on_setup
+c0418d5f t acpi_serialize_setup
+c0418d7c t acpi_request_region
+c0418dd6 t acpi_reserve_resources
+c0418e9a T acpi_os_get_root_pointer
+c0418ed2 T acpi_os_initialize
+c0418edf t acpi_osi_setup
+c0418fa3 T acpi_initialize_tables
+c041901e T acpi_tb_parse_root_table
+c0419320 T acpi_initialize_subsystem
+c04193a8 T acpi_early_init
+c04194a2 t acpi_init
+c04196a0 t init_acpi_device_notify
+c04196e4 t acpi_scan_init
+c04197e5 t acpi_ec_set_intr_mode
+c0419843 t acpi_ec_init
+c0419894 T acpi_ec_ecdt_probe
+c041992c t acpi_pci_root_init
+c041994d t acpi_irq_nobalance_set
+c041995d T acpi_irq_balance_set
+c041996d t acpi_pci_link_init
+c04199ac t irqrouter_init_sysfs
+c04199d9 t acpi_irq_penalty_update
+c0419a35 t acpi_irq_pci
+c0419a39 t acpi_irq_isa
+c0419a40 T acpi_irq_penalty_init
+c0419ad1 t acpi_power_init
+c0419b36 t acpi_system_init
+c0419cb9 t acpi_event_init
+c0419ced t acpi_cm_sbs_init
+c0419cf0 t pnp_init
+c0419d0a t pnp_setup_reserve_mem
+c0419d37 t pnp_setup_reserve_io
+c0419d64 t pnp_setup_reserve_dma
+c0419d91 t pnp_setup_reserve_irq
+c0419dbe t pnp_system_init
+c0419dc8 t ispnpidacpi
+c0419e23 t pnpidacpi_to_pnpid
+c0419e90 t pnpacpi_setup
+c0419ed2 t pnpacpi_init
+c0419f58 t acpi_pnp_find_device
+c0419f92 t acpi_pnp_match
+c0419fd0 t pnpacpi_add_device_handler
+c041a240 t chr_dev_init
+c041a2c3 t seqgen_init
+c041a2cd t rand_initialize
+c041a2ee t tty_init
+c041a4b6 T console_init
+c041a4d9 t tty_class_init
+c041a4f8 t pty_init
+c041a713 t misc_init
+c041a78b T vcs_init
+c041a816 T console_map_init
+c041a84a T kbd_init
+c041a8cb T vty_init
+c041a996 t con_init
+c041aba8 t vtconsole_class_init
+c041ac59 t sysrq_always_enabled_setup
+c041ac79 t rtc_init
+c041ae2f t hpet_init
+c041ae82 t mod_init
+c041b045 t intel_rng_hw_init
+c041b117 t hangcheck_init
+c041b1ab t hangcheck_parse_dump_tasks
+c041b1d1 t hangcheck_parse_reboot
+c041b1f7 t hangcheck_parse_margin
+c041b21d t hangcheck_parse_tick
+c041b243 T uart_get_console
+c041b29c T uart_parse_options
+c041b2f5 T uart_set_options
+c041b3b3 t serial8250_console_setup
+c041b45d t serial8250_isa_init_ports
+c041b565 T early_serial_setup
+c041b5ae t serial8250_init
+c041b6be t serial8250_console_init
+c041b6d0 T serial8250_start_console
+c041b77a t serial8250_pnp_init
+c041b784 t serial8250_pci_init
+c041b795 t serial_in
+c041b7ac t serial_out
+c041b7c8 t wait_for_xmitr
+c041b7e5 t putc
+c041b7fa t early_uart_console_switch
+c041b873 t early_uart_setup
+c041bb83 t early_uart_write
+c041bbe3 t early_uart_console_init
+c041bc03 T early_serial_console_init
+c041bc48 T devices_init
+c041bc52 T system_bus_init
+c041bc66 T buses_init
+c041bc70 T classes_init
+c041bca7 T platform_bus_init
+c041bcd6 T cpu_dev_init
+c041bcef T firmware_init
+c041bcf9 T driver_init
+c041bd21 T attribute_container_init
+c041bd38 t firmware_class_init
+c041bd9b t topology_sysfs_init
+c041bddf t ramdisk_blocksize
+c041bdf3 t ramdisk_size
+c041be07 t ramdisk_size2
+c041be09 t rd_init
+c041bf89 t probe_list2
+c041bfc6 t net_olddevs_init
+c041c043 t loopback_init
+c041c04d t etun_init
+c041c086 t aec62xx_ide_init
+c041c097 t ali15x3_ide_init
+c041c0a8 t amd74xx_ide_init
+c041c0b9 t atiixp_ide_init
+c041c0ca t cmd64x_ide_init
+c041c0db t cs5520_ide_init
+c041c0ec t cs5530_ide_init
+c041c0fd t cs5535_ide_init
+c041c10e t cy82c693_ide_init
+c041c11f t hpt34x_ide_init
+c041c130 t hpt366_ide_init
+c041c141 t it821x_ide_init
+c041c152 t jmicron_ide_init
+c041c163 t pdc202xx_ide_init
+c041c174 t pdc202new_ide_init
+c041c185 t piix_ide_init
+c041c240 t rz1000_ide_init
+c041c251 t svwks_ide_init
+c041c262 t siimage_ide_init
+c041c273 t sis5513_ide_init
+c041c284 t slc90e66_ide_init
+c041c295 t triflex_ide_init
+c041c2a6 t via_ide_init
+c041c2b7 t generic_ide_init
+c041c2c8 t ide_generic_all_on
+c041c2e8 t stridx
+c041c314 t match_parm
+c041c3da t init_ide_data
+c041c42e t ide_init
+c041c486 t ide_setup
+c041c979 t match_pci_cmd640_device
+c041c99c t secondary_port_responding
+c041ca0d T ide_probe_for_cmd640x
+c041cf5e t ide_scan_pcidev
+c041cfa6 T ide_scan_pcibus
+c041d04d t ide_generic_init
+c041d055 t idedisk_init
+c041d05f t ide_cdrom_init
+c041d069 t idefloppy_init
+c041d083 t cdrom_init
+c041d08b t usb_init
+c041d18e T usb_devio_init
+c041d274 T usbfs_init
+c041d2a8 t usb_usual_init
+c041d2d2 t serio_init
+c041d35a t i8042_init
+c041d68a t input_init
+c041d783 t mousedev_init
+c041d83b t evdev_init
+c041d845 t atkbd_init
+c041d856 t psmouse_init
+c041d8ad T i2c_register_board_info
+c041d931 t linear_init
+c041d93b t md_init
+c041da12 t dm_netlink_init
+c041da15 t dm_init
+c041da49 t local_init
+c041dafc T dm_target_init
+c041db06 T dm_linear_init
+c041db30 T dm_stripe_init
+c041db55 T dm_interface_init
+c041dbcb t dmi_present
+c041dd3a T dmi_scan_machine
+c041ddbf t dmi_string
+c041de46 t dmi_save_ident
+c041de69 t dmi_decode
+c041e09e t efivars_init
+c041e230 t init_cyclone_clocksource
+c041e3a3 t acpi_pm_good_setup
+c041e3b3 t init_acpi_pm_clocksource
+c041e502 t dma_bus_init
+c041e520 t hid_init
+c041e56c t pcibios_assign_resources
+c041e5ed t pcibios_allocate_bus_resources
+c041e693 t pcibios_allocate_resources
+c041e7c7 T pcibios_resource_survey
+c041e7e2 t pci_access_init
+c041e821 T pci_pcbios_init
+c041ea26 T pci_mmcfg_arch_init
+c041ea46 T pci_mmcfg_arch_reachable
+c041ea54 T pci_direct_init
+c041ea85 t pci_sanity_check
+c041eb34 T pci_direct_probe
+c041ecb1 t pci_mmcfg_intel_945
+c041edbd T pci_mmcfg_init
+c041f15e t pci_mmcfg_e7520
+c041f203 t pci_acpi_init
+c041f29c t pci_legacy_init
+c041f39f t via_router_probe
+c041f427 t vlsi_router_probe
+c041f449 t serverworks_router_probe
+c041f473 t sis_router_probe
+c041f494 t cyrix_router_probe
+c041f4b5 t opti_router_probe
+c041f4d7 t ite_router_probe
+c041f4f9 t amd_router_probe
+c041f53f t fix_acer_tm360_irqrouting
+c041f56d t fix_broken_hp_bios_irq9
+c041f59b t ali_router_probe
+c041f5dc t intel_router_probe
+c041f733 t pcibios_irq_init
+c041fbc6 t pcibios_init
+c041fc43 t sock_init
+c041fcab T sk_init
+c041fcfc t proto_init
+c041fd26 T skb_init
+c041fd87 t net_ns_init
+c041fe25 T netdev_boot_setup
+c041fedd t net_dev_init
+c0420051 T dev_mcast_init
+c042005b T dst_init
+c0420065 t neigh_init
+c04200de T rtnetlink_init
+c04201e6 t flow_cache_init
+c042032e t fib_rules_init
+c0420391 t pktsched_init
+c0420459 t blackhole_module_init
+c0420463 t tc_filter_init
+c04204b2 t netlink_proto_init
+c04205c5 t genl_init
+c0420672 T netfilter_init
+c04206db T netfilter_log_init
+c0420703 T netfilter_queue_init
+c042072b t set_rhash_entries
+c042074e T ip_rt_init
+c04209aa T inet_initpeers
+c04209e7 T ip_init
+c04209f1 t set_thash_entries
+c0420a14 T tcp_init
+c0420cb9 T tcp_v4_init
+c0420ce9 T tcp4_proc_init
+c0420cf3 t tcp_congestion_default
+c0420cfd T raw_proc_exit
+c0420d07 T raw_proc_init
+c0420d11 T udp4_proc_init
+c0420d1b T udplite4_register
+c0420d93 T arp_init
+c0420dbb T icmp_init
+c0420dda T devinet_init
+c0420e50 t inet_init
+c042111a T igmp_mc_proc_init
+c042115d T ip_fib_init
+c04211cd T ip_misc_proc_init
+c042125e t tunnel4_init
+c04212bb t cubictcp_register
+c042134a T xfrm4_init
+c0421359 T xfrm4_state_init
+c0421363 T xfrm_init
+c0421439 T xfrm_state_init
+c04214c8 T xfrm_input_init
+c04214fc t af_unix_init
+c0421545 t inet6_init
+c04217d0 T ac6_proc_init
+c04217fa T if6_proc_init
+c0421824 T addrconf_init
+c0421944 T ip6_route_init
+c0421a26 T fib6_init
+c0421aaf T ipv6_packet_init
+c0421ab9 T ndisc_init
+c0421b78 T udpv6_init
+c0421ba5 T udp6_proc_init
+c0421bb4 T udplite6_proc_init
+c0421bc3 T udplitev6_init
+c0421bf9 T raw6_proc_init
+c0421c23 T icmpv6_init
+c0421d04 T igmp6_init
+c0421db3 T ipv6_frag_init
+c0421e3a T tcpv6_init
+c0421e93 T tcp6_proc_init
+c0421ea2 T ipv6_rthdr_init
+c0421ec6 T ipv6_nodata_init
+c0421eea T ipv6_destopt_init
+c0421f0e T xfrm6_init
+c0421f1d T xfrm6_state_init
+c0421f27 T ipv6_netfilter_init
+c0421f31 T ipv6_misc_proc_init
+c0421fbb t xfrm6_transport_init
+c0421fca t xfrm6_tunnel_init
+c0421fd9 t xfrm6_beet_init
+c0421fe8 t ipip6_fb_tunnel_init
+c0422049 t sit_init
+c04220d1 t packet_init
+c0422106 t wireless_nlevent_init
+c042213b T _einittext
+c0423000 t tmp_cmdline.28992
+c0423800 t done.28991
+c0423804 t initcall_debug
+c0423820 T boot_command_line
+c0424020 t __setup_str_nosmp
+c0424026 t __setup_str_maxcpus
+c042402f t __setup_str_set_reset_devices
+c042403d t __setup_str_debug_kernel
+c0424043 t __setup_str_quiet_kernel
+c0424049 t __setup_str_loglevel
+c0424053 t __setup_str_init_setup
+c0424059 t __setup_str_rdinit_setup
+c0424061 t __setup_str_initcall_debug_setup
+c0424080 t saved_root_name
+c04240c0 t root_mount_data
+c04240c4 t root_fs_names
+c04240c8 t root_delay
+c04240cc T root_device_name
+c04240d0 T rd_doload
+c04240d4 t __setup_str_load_ramdisk
+c04240e2 t __setup_str_readonly
+c04240e5 t __setup_str_readwrite
+c04240e8 t __setup_str_root_dev_setup
+c04240ee t __setup_str_root_data_setup
+c04240f9 t __setup_str_fs_names_setup
+c0424105 t __setup_str_root_delay_setup
+c0424110 T rd_prompt
+c0424114 T rd_image_start
+c0424118 t __setup_str_prompt_ramdisk
+c0424128 t __setup_str_ramdisk_start_setup
+c0424138 t mount_initrd
+c042413c t old_fd
+c0424140 t root_fd
+c0424144 t __setup_str_no_initrd
+c0424160 t raid_noautodetect
+c0424164 t raid_autopart
+c0424180 t md_setup_args
+c0425580 t md_setup_ents
+c0425584 t __setup_str_raid_setup
+c042558a t __setup_str_md_setup
+c04255a0 t actions
+c04255c0 t message
+c04255e0 t head
+c0425660 t ino
+c0425664 t major
+c0425668 t minor
+c042566c t nlink
+c0425670 t mode
+c0425674 t body_len
+c0425678 t name_len
+c042567c t uid
+c0425680 t gid
+c0425684 t rdev
+c0425688 t state
+c042568c t next_state
+c0425690 t victim
+c0425694 t count
+c0425698 t this_header
+c04256a0 t next_header
+c04256a8 t dry_run
+c04256ac t collected
+c04256b0 t remains
+c04256b4 t collect
+c04256b8 t header_buf
+c04256bc t symlink_buf
+c04256c0 t name_buf
+c04256c4 t wfd
+c04256c8 t do_retain_initrd
+c04256cc t __setup_str_retain_initrd_param
+c04256da t __setup_str_lpj_setup
+c04256e0 T apic_probe
+c04256f4 t cmdline_apic
+c04256f8 t __setup_str_parse_apic
+c0425700 t __setup_str_idle_setup
+c0425705 t __setup_str_kstack_setup
+c042570d t __setup_str_code_bytes_setup
+c0425780 T init_pg_tables_end
+c0425800 T new_cpu_data
+c0425900 T user_defined_memmap
+c0425920 t command_line
+c0426120 T boot_params
+c0427120 t __setup_str_parse_mem
+c0427124 t __setup_str_parse_elfcorehdr
+c042712f t __setup_str_parse_highmem
+c0427137 t __setup_str_parse_vmalloc
+c042713f t __setup_str_parse_reservetop
+c042714a t __setup_str_check_iommu
+c0427154 T sbf_port
+c0427160 t change_point_list
+c0427d60 t change_point
+c0428160 t overlap_list
+c0428360 t new_bios
+c0428d60 t __setup_str_parse_memmap
+c0428d67 t __setup_str_bootonly
+c0428d74 t __setup_str_debug_alt
+c0428d86 t __setup_str_setup_noreplace_smp
+c0428da0 t bad_tsc_dmi_table
+c0428df8 t __setup_str_tsc_setup
+c0428e00 T cpu_initialized
+c0428e04 t disable_x86_serial_nr
+c0428e08 t cachesize_override
+c0428e0c t this_cpu
+c0428e20 t default_cpu
+c0428f58 t disable_x86_fxsr
+c0428f5c t disable_x86_sep
+c0428f60 t __setup_str_cachesize_setup
+c0428f6b t __setup_str_x86_fxsr_setup
+c0428f72 t __setup_str_x86_sep_setup
+c0428f78 t __setup_str_x86_serial_nr_setup
+c0428f88 t x
+c0428f90 t y
+c0428f98 t __setup_str_no_halt
+c0428f9f t __setup_str_mca_pentium
+c0428fab t __setup_str_no_387
+c0428fc0 t amd_cpu_dev
+c04290f8 T force_mwait
+c0429100 t nsc_cpu_dev
+c0429238 t Cx86_dir0_msb
+c0429240 t Cx486_name
+c0429268 t Cx486D_name
+c0429280 t Cx486S_name
+c0429290 t cyrix_model_mult1
+c0429297 t Cx86_cb
+c04292ab t cyrix_model_mult2
+c04292c0 t Cx86_model
+c0429320 t cyrix_cpu_dev
+c0429460 t centaur_cpu_dev
+c04295a0 t transmeta_cpu_dev
+c04296e0 t intel_cpu_dev
+c0429820 t cacheinfo_cpu_notifier
+c0429840 t cache_table
+c0429920 t rise_cpu_dev
+c0429a60 t nexgen_cpu_dev
+c0429ba0 t umc_cpu_dev
+c0429cd8 t __setup_str_mcheck_disable
+c0429cde t __setup_str_mcheck_enable
+c0429d00 T acpi_ht
+c0429d04 t acpi_force
+c0429d08 t acpi_lapic_addr
+c0429d20 t acpi_dmi_table
+c042a038 T acpi_pci_disabled
+c042a03c T acpi_skip_timer_override
+c042a040 T acpi_use_timer_override
+c042a044 T acpi_sci_flags
+c042a048 T acpi_sci_override_gsi
+c042a04c t __setup_str_parse_acpi
+c042a051 t __setup_str_parse_pci
+c042a055 t __setup_str_parse_acpi_skip_timer_override
+c042a06e t __setup_str_parse_acpi_use_timer_override
+c042a086 t __setup_str_setup_acpi_sci
+c042a0a0 t reboot_dmi_table
+c042a1a8 t __setup_str_reboot_setup
+c042a1c0 T cpu_llc_id
+c042a200 t __setup_str_parse_maxcpus
+c042a208 t sync_lock
+c042a20c t start_count
+c042a210 t stop_count
+c042a218 t last_tsc
+c042a220 t max_warp
+c042a228 t nr_warps
+c042a22c t r_base
+c042a22c T trampoline_data
+c042a256 t boot_gdt_descr
+c042a25c t boot_idt_descr
+c042a262 T trampoline_end
+c042a280 T maxcpus
+c042a2a0 t translation_table
+c042b2a0 T num_processors
+c042b2a8 t enable_local_apic
+c042b2ac t lapic_cal_loops
+c042b2b0 t lapic_cal_t1
+c042b2b4 t lapic_cal_t2
+c042b2b8 t lapic_cal_tsc1
+c042b2c0 t lapic_cal_tsc2
+c042b2c8 t lapic_cal_pm1
+c042b2cc t lapic_cal_pm2
+c042b2d0 t lapic_cal_j1
+c042b2d4 t lapic_cal_j2
+c042b2d8 t __setup_str_parse_lapic
+c042b2de t __setup_str_parse_nolapic
+c042b2e6 t __setup_str_parse_disable_lapic_timer
+c042b2f4 t __setup_str_parse_lapic_timer_c2_ok
+c042b306 t __setup_str_apic_set_verbosity
+c042b30c t endflag
+c042b310 t __setup_str_setup_nmi_watchdog
+c042b320 T timer_over_8254
+c042b324 t disable_timer_pin_1
+c042b328 T no_timer_check
+c042b32c t __setup_str_ioapic_setup
+c042b333 t __setup_str_ioapic_pirq_setup
+c042b339 t __setup_str_notimercheck
+c042b348 t __setup_str_setup_disable_8254_timer
+c042b35b t __setup_str_setup_enable_8254_timer
+c042b36d t __setup_str_parse_disable_timer_pin_1
+c042b381 t __setup_str_parse_enable_timer_pin_1
+c042b394 t __setup_str_parse_noapic
+c042b39b t __setup_str_parse_crashkernel
+c042b3a7 t __setup_str_vdso_setup
+c042b3ad T vsyscall_int80_start
+c042bc21 T vsyscall_int80_end
+c042bc21 T vsyscall_sysenter_start
+c042c4ad T vsyscall_sysenter_end
+c042c4b0 t keep_early
+c042c4b4 t __setup_str_setup_early_printk
+c042c4c0 t __setup_str_hpet_setup
+c042d000 t disable_nx
+c042d004 t __setup_str_noexec_setup
+c042e000 t boot_ioremap_space
+c0432000 t __setup_str_no_ipi_broadcast
+c0432014 t migration_notifier
+c0432020 t __setup_str_isolated_cpu_setup
+c043202a t __setup_str_migration_cost_setup
+c043203a t __setup_str_setup_migration_factor
+c043204c t __setup_str_setup_migration_debug
+c043205d t __setup_str_setup_max_cache_size
+c043206d t __setup_str_panic_setup
+c0432074 t __setup_str_pause_on_oops_setup
+c0432083 t __setup_str_log_buf_len_setup
+c0432090 t __setup_str_ignore_loglevel_setup
+c04320a0 t __setup_str_printk_time_setup
+c04320a5 t __setup_str_console_setup
+c04320ae t kvmstr.18063
+c04320b2 t sleepstr.18062
+c04320b8 t schedstr.18061
+c04320c1 t __setup_str_profile_setup
+c04320cc t cpu_nfb
+c04320d8 t __setup_str_reserve_setup
+c04320e4 t timers_nb
+c04320f0 t rcu_nb
+c04320fc t hrtimers_nb
+c0432108 t __setup_str_boot_override_clocksource
+c0432115 t __setup_str_boot_override_clock
+c043211c t cpu_chain
+c0432120 t cpu_nfb
+c043212c t __setup_str_noirqdebug_setup
+c0432137 t __setup_str_irqfixup_setup
+c0432140 t __setup_str_irqpoll_setup
+c0432160 t dma_reserve
+c0432164 T nr_kernel_pages
+c0432168 T nr_all_pages
+c0432180 T early_node_map
+c0432d80 T nr_nodemap_entries
+c0432d84 T arch_zone_lowest_possible_pfn
+c0432d90 T arch_zone_highest_possible_pfn
+c0432d9c t ratelimit_nb
+c0432da8 t vmstat_notifier
+c0432db4 t __setup_str_disable_randmaps
+c0432dc0 t initarray_cache
+c0432e00 t cache_names
+c0432e98 t cpucache_notifier
+c0432ec0 T initkmem_list3
+c0432f8c t __setup_str_noaliencache_setup
+c0432f9c t dhash_entries
+c0432fa0 t __setup_str_set_dhash_entries
+c0432fb0 t ihash_entries
+c0432fb4 t __setup_str_set_ihash_entries
+c0432fc3 t __setup_str_elevator_setup
+c0432fe0 t __setup_str_pci_setup
+c0432fe4 t __setup_str_no_scroll
+c0433000 t initial_tables
+c0433a00 t acpi_apic_instance
+c0433a04 t __setup_str_acpi_parse_apic_instance
+c0433a20 t acpi_blacklist
+c0433b00 t acpi_osl_dmi_table
+c0433b58 t __setup_str_acpi_os_name_setup
+c0433b66 t __setup_str_acpi_osi_setup
+c0433b70 t __setup_str_acpi_serialize_setup
+c0433b7f t __setup_str_acpi_wake_gpes_always_on_setup
+c0433b98 t __setup_str_acpi_ec_set_intr_mode
+c0433ba1 t __setup_str_acpi_irq_isa
+c0433baf t __setup_str_acpi_irq_pci
+c0433bbd t __setup_str_acpi_irq_nobalance_set
+c0433bd0 t __setup_str_acpi_irq_balance_set
+c0433c00 t __setup_str_pnp_setup_reserve_irq
+c0433c11 t __setup_str_pnp_setup_reserve_dma
+c0433c22 t __setup_str_pnp_setup_reserve_io
+c0433c32 t __setup_str_pnp_setup_reserve_mem
+c0433c60 t acpi_pnp_bus
+c0433c80 t excluded_id_list
+c0433ca4 T pnpacpi_disabled
+c0433ca8 t __setup_str_pnpacpi_setup
+c0433cc0 t __setup_str_sysrq_always_enabled_setup
+c0433ce0 t warning.15949
+c0433e00 t no_fwh_detect
+c0433e04 t __setup_str_hangcheck_parse_tick
+c0433e10 t __setup_str_hangcheck_parse_margin
+c0433e1e t __setup_str_hangcheck_parse_reboot
+c0433e2c t __setup_str_hangcheck_parse_dump_tasks
+c0433e40 t early_uart_console
+c0433e80 t early_device
+c0433f28 t early_uart_registered
+c0433f2c t __setup_str_ramdisk_size
+c0433f35 t __setup_str_ramdisk_size2
+c0433f43 t __setup_str_ramdisk_blocksize
+c0433f58 t m68k_probes
+c0433f60 t eisa_probes
+c0433f68 t mca_probes
+c0433f70 t isa_probes
+c0433f78 t parport_probes
+c0433f80 t __setup_str_ide_generic_all_on
+c0433fa0 t is_chipset_set
+c0433fc8 t __setup_str_ide_setup
+c0433fe0 t i8042_dmi_noloop_table
+c0434100 t i8042_dmi_nomux_table
+c0434418 T _inits
+c0434430 t __setup_str_acpi_pm_good_setup
+c0434440 t pci_mmcfg_probes
+c0434460 t pciirq_dmi_table
+c0434500 t pirq_routers
+c0434560 t pirq_440gx.22194
+c04345b4 t __setup_str_netdev_boot_setup
+c04345bc t __setup_str_netdev_boot_setup
+c04345c4 t rhash_entries
+c04345c8 t __setup_str_set_rhash_entries
+c04345d8 t thash_entries
+c04345dc t __setup_str_set_thash_entries
+c04345f0 t __setup_nosmp
+c04345f0 T __setup_start
+c04345fc t __setup_maxcpus
+c0434608 t __setup_set_reset_devices
+c0434614 t __setup_debug_kernel
+c0434620 t __setup_quiet_kernel
+c043462c t __setup_loglevel
+c0434638 t __setup_init_setup
+c0434644 t __setup_rdinit_setup
+c0434650 t __setup_initcall_debug_setup
+c043465c t __setup_load_ramdisk
+c0434668 t __setup_readonly
+c0434674 t __setup_readwrite
+c0434680 t __setup_root_dev_setup
+c043468c t __setup_root_data_setup
+c0434698 t __setup_fs_names_setup
+c04346a4 t __setup_root_delay_setup
+c04346b0 t __setup_prompt_ramdisk
+c04346bc t __setup_ramdisk_start_setup
+c04346c8 t __setup_no_initrd
+c04346d4 t __setup_raid_setup
+c04346e0 t __setup_md_setup
+c04346ec t __setup_retain_initrd_param
+c04346f8 t __setup_lpj_setup
+c0434704 t __setup_parse_apic
+c0434710 t __setup_idle_setup
+c043471c t __setup_kstack_setup
+c0434728 t __setup_code_bytes_setup
+c0434734 t __setup_parse_mem
+c0434740 t __setup_parse_elfcorehdr
+c043474c t __setup_parse_highmem
+c0434758 t __setup_parse_vmalloc
+c0434764 t __setup_parse_reservetop
+c0434770 t __setup_check_iommu
+c043477c t __setup_parse_memmap
+c0434788 t __setup_bootonly
+c0434794 t __setup_debug_alt
+c04347a0 t __setup_setup_noreplace_smp
+c04347ac t __setup_tsc_setup
+c04347b8 t __setup_cachesize_setup
+c04347c4 t __setup_x86_fxsr_setup
+c04347d0 t __setup_x86_sep_setup
+c04347dc t __setup_x86_serial_nr_setup
+c04347e8 t __setup_no_halt
+c04347f4 t __setup_mca_pentium
+c0434800 t __setup_no_387
+c043480c t __setup_mcheck_disable
+c0434818 t __setup_mcheck_enable
+c0434824 t __setup_parse_acpi
+c0434830 t __setup_parse_pci
+c043483c t __setup_parse_acpi_skip_timer_override
+c0434848 t __setup_parse_acpi_use_timer_override
+c0434854 t __setup_setup_acpi_sci
+c0434860 t __setup_reboot_setup
+c043486c t __setup_parse_maxcpus
+c0434878 t __setup_parse_lapic
+c0434884 t __setup_parse_nolapic
+c0434890 t __setup_parse_disable_lapic_timer
+c043489c t __setup_parse_lapic_timer_c2_ok
+c04348a8 t __setup_apic_set_verbosity
+c04348b4 t __setup_setup_nmi_watchdog
+c04348c0 t __setup_ioapic_setup
+c04348cc t __setup_ioapic_pirq_setup
+c04348d8 t __setup_notimercheck
+c04348e4 t __setup_setup_disable_8254_timer
+c04348f0 t __setup_setup_enable_8254_timer
+c04348fc t __setup_parse_disable_timer_pin_1
+c0434908 t __setup_parse_enable_timer_pin_1
+c0434914 t __setup_parse_noapic
+c0434920 t __setup_parse_crashkernel
+c043492c t __setup_vdso_setup
+c0434938 t __setup_setup_early_printk
+c0434944 t __setup_hpet_setup
+c0434950 t __setup_noexec_setup
+c043495c t __setup_no_ipi_broadcast
+c0434968 t __setup_isolated_cpu_setup
+c0434974 t __setup_migration_cost_setup
+c0434980 t __setup_setup_migration_factor
+c043498c t __setup_setup_migration_debug
+c0434998 t __setup_setup_max_cache_size
+c04349a4 t __setup_panic_setup
+c04349b0 t __setup_pause_on_oops_setup
+c04349bc t __setup_log_buf_len_setup
+c04349c8 t __setup_ignore_loglevel_setup
+c04349d4 t __setup_printk_time_setup
+c04349e0 t __setup_console_setup
+c04349ec t __setup_profile_setup
+c04349f8 t __setup_reserve_setup
+c0434a04 t __setup_boot_override_clocksource
+c0434a10 t __setup_boot_override_clock
+c0434a1c t __setup_noirqdebug_setup
+c0434a28 t __setup_irqfixup_setup
+c0434a34 t __setup_irqpoll_setup
+c0434a40 t __setup_disable_randmaps
+c0434a4c t __setup_noaliencache_setup
+c0434a58 t __setup_set_dhash_entries
+c0434a64 t __setup_set_ihash_entries
+c0434a70 t __setup_elevator_setup
+c0434a7c t __setup_pci_setup
+c0434a88 t __setup_no_scroll
+c0434a94 t __setup_acpi_parse_apic_instance
+c0434aa0 t __setup_acpi_os_name_setup
+c0434aac t __setup_acpi_osi_setup
+c0434ab8 t __setup_acpi_serialize_setup
+c0434ac4 t __setup_acpi_wake_gpes_always_on_setup
+c0434ad0 t __setup_acpi_ec_set_intr_mode
+c0434adc t __setup_acpi_irq_isa
+c0434ae8 t __setup_acpi_irq_pci
+c0434af4 t __setup_acpi_irq_nobalance_set
+c0434b00 t __setup_acpi_irq_balance_set
+c0434b0c t __setup_pnp_setup_reserve_irq
+c0434b18 t __setup_pnp_setup_reserve_dma
+c0434b24 t __setup_pnp_setup_reserve_io
+c0434b30 t __setup_pnp_setup_reserve_mem
+c0434b3c t __setup_pnpacpi_setup
+c0434b48 t __setup_sysrq_always_enabled_setup
+c0434b54 t __setup_hangcheck_parse_tick
+c0434b60 t __setup_hangcheck_parse_margin
+c0434b6c t __setup_hangcheck_parse_reboot
+c0434b78 t __setup_hangcheck_parse_dump_tasks
+c0434b84 t __setup_ramdisk_size
+c0434b90 t __setup_ramdisk_size2
+c0434b9c t __setup_ramdisk_blocksize
+c0434ba8 t __setup_ide_generic_all_on
+c0434bb4 t __setup_ide_setup
+c0434bc0 t __setup_acpi_pm_good_setup
+c0434bcc t __setup_netdev_boot_setup
+c0434bd8 t __setup_netdev_boot_setup
+c0434be4 t __setup_set_rhash_entries
+c0434bf0 t __setup_set_thash_entries
+c0434bfc t __initcall_net_ns_init1
+c0434bfc T __initcall_start
+c0434bfc T __setup_end
+c0434c00 t __initcall_reboot_init1
+c0434c04 t __initcall_sysctl_init1
+c0434c08 t __initcall_init_jiffies_clocksource1
+c0434c0c t __initcall_pm_init1
+c0434c10 t __initcall_ksysfs_init1
+c0434c14 t __initcall_filelock_init1
+c0434c18 t __initcall_init_misc_binfmt1
+c0434c1c t __initcall_init_script_binfmt1
+c0434c20 t __initcall_init_elf_binfmt1
+c0434c24 t __initcall_debugfs_init1
+c0434c28 t __initcall_random32_init1
+c0434c2c t __initcall_sock_init1
+c0434c30 t __initcall_netlink_proto_init1
+c0434c34 t __initcall_kobject_uevent_init2
+c0434c38 t __initcall_pcibus_class_init2
+c0434c3c t __initcall_pci_driver_init2
+c0434c40 t __initcall_tty_class_init2
+c0434c44 t __initcall_vtconsole_class_init2
+c0434c48 t __initcall_init_pit_clocksource3
+c0434c4c t __initcall_mtrr_if_init3
+c0434c50 t __initcall_kdump_buf_page_init3
+c0434c54 t __initcall_acpi_pci_init3
+c0434c58 t __initcall_init_acpi_device_notify3
+c0434c5c t __initcall_init_cyclone_clocksource3
+c0434c60 t __initcall_pci_access_init3
+c0434c64 t __initcall_request_standard_resources4
+c0434c68 t __initcall_topology_init4
+c0434c6c t __initcall_mtrr_init_finialize4
+c0434c70 t __initcall_param_sysfs_init4
+c0434c74 t __initcall_pm_sysrq_init4
+c0434c78 t __initcall_init_bio4
+c0434c7c t __initcall_genhd_device_init4
+c0434c80 t __initcall_acpi_init4
+c0434c84 t __initcall_acpi_scan_init4
+c0434c88 t __initcall_acpi_ec_init4
+c0434c8c t __initcall_acpi_pci_root_init4
+c0434c90 t __initcall_acpi_pci_link_init4
+c0434c94 t __initcall_acpi_power_init4
+c0434c98 t __initcall_acpi_system_init4
+c0434c9c t __initcall_acpi_event_init4
+c0434ca0 t __initcall_acpi_cm_sbs_init4
+c0434ca4 t __initcall_pnp_init4
+c0434ca8 t __initcall_pnpacpi_init4
+c0434cac t __initcall_misc_init4
+c0434cb0 t __initcall_usb_init4
+c0434cb4 t __initcall_serio_init4
+c0434cb8 t __initcall_input_init4
+c0434cbc t __initcall_md_init4
+c0434cc0 t __initcall_dma_bus_init4
+c0434cc4 t __initcall_pci_acpi_init4
+c0434cc8 t __initcall_pci_legacy_init4
+c0434ccc t __initcall_pcibios_irq_init4
+c0434cd0 t __initcall_pcibios_init4
+c0434cd4 t __initcall_proto_init4
+c0434cd8 t __initcall_net_dev_init4
+c0434cdc t __initcall_neigh_init4
+c0434ce0 t __initcall_fib_rules_init4
+c0434ce4 t __initcall_pktsched_init4
+c0434ce8 t __initcall_tc_filter_init4
+c0434cec t __initcall_genl_init4
+c0434cf0 t __initcall_wireless_nlevent_init4
+c0434cf4 t __initcall_clocksource_done_booting5
+c0434cf8 t __initcall_init_pipe_fs5
+c0434cfc t __initcall_eventpoll_init5
+c0434d00 t __initcall_anon_inode_init5
+c0434d04 t __initcall_pnp_system_init5
+c0434d08 t __initcall_chr_dev_init5
+c0434d0c t __initcall_firmware_class_init5
+c0434d10 t __initcall_init_acpi_pm_clocksource5
+c0434d14 t __initcall_pcibios_assign_resources5
+c0434d18 t __initcall_inet_init5
+c0434d1c t __initcall_populate_rootfsrootfs
+c0434d20 t __initcall_i8259A_init_sysfs6
+c0434d24 t __initcall_sbf_init6
+c0434d28 t __initcall_i8237A_init_sysfs6
+c0434d2c t __initcall_cache_sysfs_init6
+c0434d30 t __initcall_thermal_throttle_init_device6
+c0434d34 t __initcall_init_lapic_sysfs6
+c0434d38 t __initcall_ioapic_init_sysfs6
+c0434d3c t __initcall_hpet_register_sysfs6
+c0434d40 t __initcall_add_pcspkr6
+c0434d44 t __initcall_create_proc_profile6
+c0434d48 t __initcall_ioresources_init6
+c0434d4c t __initcall_uid_cache_init6
+c0434d50 t __initcall_init_posix_timers6
+c0434d54 t __initcall_init_posix_cpu_timers6
+c0434d58 t __initcall_latency_init6
+c0434d5c t __initcall_nsproxy_cache_init6
+c0434d60 t __initcall_init_network6
+c0434d64 t __initcall_init_vserver6
+c0434d68 t __initcall_timekeeping_init_device6
+c0434d6c t __initcall_init_clocksource_sysfs6
+c0434d70 t __initcall_init_timer_list_procfs6
+c0434d74 t __initcall_init6
+c0434d78 t __initcall_proc_dma_init6
+c0434d7c t __initcall_percpu_modinit6
+c0434d80 t __initcall_kallsyms_init6
+c0434d84 t __initcall_crash_notes_memory_init6
+c0434d88 t __initcall_init_kprobes6
+c0434d8c t __initcall_relay_init6
+c0434d90 t __initcall_utsname_sysctl_init6
+c0434d94 t __initcall_init_per_zone_pages_min6
+c0434d98 t __initcall_pdflush_init6
+c0434d9c t __initcall_kswapd_init6
+c0434da0 t __initcall_setup_vmstat6
+c0434da4 t __initcall_init_emergency_pool6
+c0434da8 t __initcall_procswaps_init6
+c0434dac t __initcall_init_tmpfs6
+c0434db0 t __initcall_cpucache_init6
+c0434db4 t __initcall_fasync_init6
+c0434db8 t __initcall_aio_setup6
+c0434dbc t __initcall_inotify_setup6
+c0434dc0 t __initcall_inotify_user_setup6
+c0434dc4 t __initcall_init_mbcache6
+c0434dc8 t __initcall_dquot_init6
+c0434dcc t __initcall_init_v2_quota_format6
+c0434dd0 t __initcall_dnotify_init6
+c0434dd4 t __initcall_vmcore_init6
+c0434dd8 t __initcall_init_devpts_fs6
+c0434ddc t __initcall_init_ext3_fs6
+c0434de0 t __initcall_journal_init6
+c0434de4 t __initcall_init_ext2_fs6
+c0434de8 t __initcall_init_cramfs_fs6
+c0434dec t __initcall_init_ramfs_fs6
+c0434df0 t __initcall_init_iso9660_fs6
+c0434df4 t __initcall_init_nls_cp4376
+c0434df8 t __initcall_init_nls_ascii6
+c0434dfc t __initcall_ipc_init6
+c0434e00 t __initcall_ipc_sysctl_init6
+c0434e04 t __initcall_init_mqueue_fs6
+c0434e08 t __initcall_noop_init6
+c0434e0c t __initcall_cfq_init6
+c0434e10 t __initcall_blk_trace_init6
+c0434e14 t __initcall_pci_init6
+c0434e18 t __initcall_pci_proc_init6
+c0434e1c t __initcall_pcie_portdrv_init6
+c0434e20 t __initcall_aer_service_init6
+c0434e24 t __initcall_acpi_reserve_resources6
+c0434e28 t __initcall_irqrouter_init_sysfs6
+c0434e2c t __initcall_rand_initialize6
+c0434e30 t __initcall_tty_init6
+c0434e34 t __initcall_pty_init6
+c0434e38 t __initcall_rtc_init6
+c0434e3c t __initcall_hpet_init6
+c0434e40 t __initcall_mod_init6
+c0434e44 t __initcall_hangcheck_init6
+c0434e48 t __initcall_serial8250_init6
+c0434e4c t __initcall_serial8250_pnp_init6
+c0434e50 t __initcall_serial8250_pci_init6
+c0434e54 t __initcall_topology_sysfs_init6
+c0434e58 t __initcall_rd_init6
+c0434e5c t __initcall_net_olddevs_init6
+c0434e60 t __initcall_loopback_init6
+c0434e64 t __initcall_etun_init6
+c0434e68 t __initcall_aec62xx_ide_init6
+c0434e6c t __initcall_ali15x3_ide_init6
+c0434e70 t __initcall_amd74xx_ide_init6
+c0434e74 t __initcall_atiixp_ide_init6
+c0434e78 t __initcall_cmd64x_ide_init6
+c0434e7c t __initcall_cs5520_ide_init6
+c0434e80 t __initcall_cs5530_ide_init6
+c0434e84 t __initcall_cs5535_ide_init6
+c0434e88 t __initcall_cy82c693_ide_init6
+c0434e8c t __initcall_hpt34x_ide_init6
+c0434e90 t __initcall_hpt366_ide_init6
+c0434e94 t __initcall_it821x_ide_init6
+c0434e98 t __initcall_jmicron_ide_init6
+c0434e9c t __initcall_pdc202xx_ide_init6
+c0434ea0 t __initcall_pdc202new_ide_init6
+c0434ea4 t __initcall_piix_ide_init6
+c0434ea8 t __initcall_rz1000_ide_init6
+c0434eac t __initcall_svwks_ide_init6
+c0434eb0 t __initcall_siimage_ide_init6
+c0434eb4 t __initcall_sis5513_ide_init6
+c0434eb8 t __initcall_slc90e66_ide_init6
+c0434ebc t __initcall_triflex_ide_init6
+c0434ec0 t __initcall_via_ide_init6
+c0434ec4 t __initcall_generic_ide_init6
+c0434ec8 t __initcall_ide_init6
+c0434ecc t __initcall_ide_generic_init6
+c0434ed0 t __initcall_idedisk_init6
+c0434ed4 t __initcall_ide_cdrom_init6
+c0434ed8 t __initcall_idefloppy_init6
+c0434edc t __initcall_cdrom_init6
+c0434ee0 t __initcall_usb_usual_init6
+c0434ee4 t __initcall_i8042_init6
+c0434ee8 t __initcall_mousedev_init6
+c0434eec t __initcall_evdev_init6
+c0434ef0 t __initcall_atkbd_init6
+c0434ef4 t __initcall_psmouse_init6
+c0434ef8 t __initcall_linear_init6
+c0434efc t __initcall_dm_init6
+c0434f00 t __initcall_efivars_init6
+c0434f04 t __initcall_hid_init6
+c0434f08 t __initcall_flow_cache_init6
+c0434f0c t __initcall_blackhole_module_init6
+c0434f10 t __initcall_tunnel4_init6
+c0434f14 t __initcall_ipv4_netfilter_init6
+c0434f18 t __initcall_cubictcp_register6
+c0434f1c t __initcall_af_unix_init6
+c0434f20 t __initcall_inet6_init6
+c0434f24 t __initcall_xfrm6_transport_init6
+c0434f28 t __initcall_xfrm6_tunnel_init6
+c0434f2c t __initcall_xfrm6_beet_init6
+c0434f30 t __initcall_sit_init6
+c0434f34 t __initcall_packet_init6
+c0434f38 t __initcall_check_nmi_watchdog7
+c0434f3c t __initcall_init_lapic_nmi_sysfs7
+c0434f40 t __initcall_io_apic_bug_finalize7
+c0434f44 t __initcall_print_ipi_mode7
+c0434f48 t __initcall_debugfs_kprobe_init7
+c0434f4c t __initcall_revokefs_init7
+c0434f50 t __initcall_random32_reseed7
+c0434f54 t __initcall_pci_sysfs_init7
+c0434f58 t __initcall_acpi_poweroff_init7
+c0434f5c t __initcall_seqgen_init7
+c0434f60 t __initcall_early_uart_console_switch7
+c0434f64 t __initcall_tcp_congestion_default7
+c0434f68 D __con_initcall_start
+c0434f68 d __initcall_con_init
+c0434f68 T __initcall_end
+c0434f6c d __initcall_serial8250_console_init
+c0434f70 d __initcall_early_uart_console_init
+c0434f74 R __alt_instructions
+c0434f74 D __con_initcall_end
+c0434f74 ? __security_initcall_end
+c0434f74 ? __security_initcall_start
+c0437697 R __alt_instructions_end
+c0438138 ? __parainstructions
+c0438138 ? __parainstructions_end
+c0438138 t cache_remove_dev
+c04381bb t exit_vserver
+c04381bc t exit_pipe_fs
+c04381dc t exit_misc_binfmt
+c04381f0 t exit_script_binfmt
+c04381fa t exit_elf_binfmt
+c0438204 t exit_mbcache
+c043820e t exit_v2_quota_format
+c0438218 t exit_devpts_fs
+c0438238 t exit_ext3_fs
+c043824c t journal_exit
+c0438251 t exit_ext2_fs
+c0438265 t exit_cramfs_fs
+c0438274 t exit_ramfs_fs
+c043827e t exit_iso9660_fs
+c0438292 t exit_nls_cp437
+c043829c t exit_nls_ascii
+c04382a6 t debugfs_exit
+c04382c9 t noop_exit
+c04382d3 t cfq_exit
+c0438375 t pcie_portdrv_exit
+c0438384 t aer_service_exit
+c043838e t cleanup_sysctl
+c0438398 t rtc_exit
+c04383f0 t hpet_exit
+c0438412 t mod_exit
+c043842b t hangcheck_exit
+c0438446 t serial8250_exit
+c0438473 t serial8250_pnp_exit
+c043847d t serial8250_pci_exit
+c0438487 t firmware_class_exit
+c0438491 t rd_cleanup
+c04384f4 t idedisk_exit
+c04384fe t ide_cdrom_exit
+c0438508 t idefloppy_exit
+c0438512 t cdrom_exit
+c0438532 t usb_exit
+c0438578 t usb_usual_exit
+c043859f t serio_exit
+c04385b3 t i8042_exit
+c04385d7 t input_exit
+c04385f5 t mousedev_exit
+c043860e t evdev_exit
+c0438618 t atkbd_exit
+c0438622 t psmouse_exit
+c0438636 t md_exit
+c0438718 t dm_exit
+c043872d t efivars_exit
+c043879d t hid_exit
+c04387ac t blackhole_module_exit
+c04387b6 t tunnel4_fini
+c04387f9 t cubictcp_unregister
+c0438803 t xfrm4_policy_fini
+c043880d t af_unix_exit
+c043882b t inet6_exit
+c04388bc T addrconf_cleanup
+c0438986 t xfrm6_transport_exit
+c043899e t xfrm6_tunnel_exit
+c04389b6 t xfrm6_beet_exit
+c04389ce t sit_destroy_tunnels
+c0438a02 t sit_cleanup
+c0438a2a t packet_exit
+c0439000 T __initramfs_start
+c0439086 T __initramfs_end
+c043a000 D __per_cpu_start
+c043a000 D per_cpu__init_tss
+c043d000 D per_cpu__current_task
+c043d004 d per_cpu__cpu_idle_state
+c043d008 D per_cpu__cpu_number
+c043d080 D per_cpu__irq_regs
+c043d100 D per_cpu__irq_stat
+c043e000 D per_cpu__gdt_page
+c043f000 d per_cpu__next_check
+c043f008 d per_cpu__thermal_throttle_count
+c043f00c d per_cpu__nmi_watchdog_ctlblk
+c043f080 D per_cpu__cpu_tlbstate
+c043f100 D per_cpu__cpu_state
+c043f104 D per_cpu__this_cpu_off
+c043f120 d per_cpu__lapic_events
+c043f168 d per_cpu__wd_enabled
+c043f180 D per_cpu__current_kprobe
+c043f1a0 D per_cpu__kprobe_ctlblk
+c043f240 D per_cpu__mmu_gathers
+c043fa80 d per_cpu__runqueues
+c0440440 d per_cpu__cpu_domains
+c0440520 d per_cpu__sched_group_cpus
+c0440540 d per_cpu__core_domains
+c0440620 d per_cpu__sched_group_core
+c0440640 d per_cpu__phys_domains
+c0440720 d per_cpu__sched_group_phys
+c0440740 D per_cpu__kstat
+c0440b00 D per_cpu__process_counts
+c0440b04 d per_cpu__cpu_profile_hits
+c0440b0c d per_cpu__cpu_profile_flip
+c0440b10 d per_cpu__tasklet_hi_vec
+c0440b14 d per_cpu__tasklet_vec
+c0440b18 d per_cpu__ksoftirqd
+c0440b1c d per_cpu__tvec_bases
+c0440b20 D per_cpu__rcu_data
+c0440b60 D per_cpu__rcu_bh_data
+c0440b9c d per_cpu__rcu_tasklet
+c0440bc0 D per_cpu__hrtimer_bases
+c0440c20 D per_cpu__tick_cpu_device
+c0440c28 d per_cpu__kprobe_instance
+c0440c2c d per_cpu__touch_timestamp
+c0440c30 d per_cpu__print_timestamp
+c0440c34 d per_cpu__watchdog_task
+c0440c40 d per_cpu__ratelimits.21761
+c0440c60 d per_cpu__committed_space
+c0440c80 d per_cpu__lru_add_pvecs
+c0440cc0 d per_cpu__lru_add_active_pvecs
+c0440d00 D per_cpu__vm_event_states
+c0440d80 d per_cpu__vmstat_work
+c0440dc0 d per_cpu__reap_work
+c0440de8 D per_cpu__quicklist
+c0440e00 d per_cpu__fdtable_defer_list
+c0440e40 d per_cpu__bh_accounting
+c0440e60 d per_cpu__bh_lrus
+c0440e80 d per_cpu__blk_cpu_done
+c0440e88 d per_cpu__ioc_count
+c0440e90 d per_cpu__blk_trace_cpu_offset
+c0440ea0 D per_cpu__radix_tree_preloads
+c0440ec0 d per_cpu__net_rand_state
+c0440ecc d per_cpu__trickle_count
+c0440ed0 d per_cpu__pcpu_lstats
+c0440f00 d per_cpu__sockets_in_use
+c0440f80 D per_cpu__softnet_data
+c0441600 D per_cpu__netdev_rx_stat
+c0441680 d per_cpu__flow_tables
+c0441700 d per_cpu__flow_hash_info
+c0441780 d per_cpu__flow_flush_tasklets
+c04417a0 d per_cpu__rt_cache_stat
+c04417e0 d per_cpu____icmpv6_socket
+c04417e4 D __per_cpu_end
+c0442000 B __bss_start
+c0442000 B __init_end
+c0442000 B swapper_pg_dir
+c0443000 B empty_zero_page
+c0444000 B system_state
+c0444004 B saved_command_line
+c0444008 B reset_devices
+c044400c B late_time_init
+c0444010 b static_command_line
+c0444014 b execute_command
+c0444018 b ramdisk_execute_command
+c044401c b panic_later
+c0444020 b panic_param
+c0444024 B Version_132630
+c0444040 B ROOT_DEV
+c0444060 b inbuf
+c0444064 b window
+c0444068 b insize
+c044406c b inptr
+c0444070 b outcnt
+c0444074 b exit_code
+c0444078 b unzip_error
+c044407c b bytes_out
+c0444080 b crd_infd
+c0444084 b crd_outfd
+c0444088 b bb
+c044408c b bk
+c0444090 b hufts
+c04440a0 b crc_32_tab
+c04444a0 b crc
+c04444a4 B initrd_below_start_ok
+c04444a8 B initrd_start
+c04444ac B initrd_end
+c04444b0 B real_root_dev
+c04444c0 b inbuf
+c04444c4 b window
+c04444c8 b insize
+c04444cc b inptr
+c04444d0 b outcnt
+c04444d4 b bytes_out
+c04444d8 b bb
+c04444dc b bk
+c04444e0 b hufts
+c0444500 b crc_32_tab
+c0444900 b crc
+c0444904 b preset_lpj
+c0444908 b dmi_bigsmp
+c044490c b id.4926
+c0444910 B psai
+c0444914 B mip_reg
+c0444918 B host_reg
+c044491c B mip_port
+c0444920 B mip_addr
+c0444924 B host_addr
+c0444928 b base
+c0445000 B boot_option_idle_override
+c0445004 B pm_idle
+c0445008 b hlt_counter
+c044500c B ignore_fpu_irq
+c0445010 B panic_on_unrecovered_nmi
+c0445014 b die_counter.19658
+c0446000 B irq_err_count
+c0446004 b __warned.12122
+c0447000 b softirq_stack
+c0457000 b hardirq_stack
+c0467000 B cmos_lock
+c0467004 B cpu_khz
+c0467008 B timer_ack
+c046700c B no_sync_cmos_clock
+c0467020 B disable_pse
+c0467024 B mmu_cr4_features
+c0467028 B machine_id
+c046702c B machine_submodel_id
+c0467030 B BIOS_revision
+c0467034 B mca_pentium_flag
+c0467038 B bootloader_type
+c0467040 B screen_info
+c0467080 B apm_info
+c04670c0 B edd
+c0467300 B edid_info
+c0467380 B ist_info
+c04673a0 B drive_info
+c04673c0 B saved_videomode
+c04673c4 B io_apic_irqs
+c04673c8 b spurious_irq_mask.12460
+c04673cc b i8259A_auto_eoi
+c04673d0 b irq_trigger
+c04673d4 B forbid_dac
+c04673e0 B efi_enabled
+c0467400 B e820
+c0467e20 b cpu_devices
+c04683e0 b noreplace_smp
+c04683e4 b debug_alternative
+c04683e8 b smp_alt_once
+c04683ec B global_clock_event
+c04683f0 b old_jifs.8711
+c04683f4 b old_count.8710
+c04683f8 B tsc_disable
+c04683fc B tsc_khz
+c0468400 b current_tsc_khz
+c0468404 b tsc_enabled
+c0468408 b tsc_unstable
+c0468420 B cpu_devs
+c0468444 b printed.16722
+c0468460 B num_cache_leaves
+c0468464 b is_initialized.11293
+c0468480 b cpuid4_info
+c04684c0 b cache_kobject
+c0468500 b index_kobject
+c0468540 B mce_disabled
+c0468544 B nr_mce_banks
+c0468548 b mce_num_extended_msrs
+c046854c B therm_throt_en
+c0468560 B num_var_ranges
+c0468564 B mtrr_if
+c0468568 B size_or_mask
+c0468570 B size_and_mask
+c0468578 B usage_table
+c0468580 b mtrr_ops
+c04685a4 b mtrr_state
+c04685a8 b proc_root_mtrr
+c04685c0 b cr4
+c04685e0 b mtrr_state
+c0468640 b smp_changes_mask
+c0468644 b mtrr_show
+c0468648 b deftype_lo
+c046864c b deftype_hi
+c0468650 B arr3_protected
+c0468654 b cr4
+c0468658 b ccr3
+c0468660 b centaur_mcr
+c04686a0 b centaur_mcr_reserved
+c04686a1 b centaur_mcr_type
+c04686a4 b wd_ops
+c04686a8 b perfctr_nmi_owner
+c04686b4 b evntsel_nmi_owner
+c04686c0 B acpi_disabled
+c04686c4 B acpi_irq_model
+c04686c8 B acpi_lapic
+c04686cc B acpi_ioapic
+c04686d0 B acpi_noirq
+c04686d4 B acpi_strict
+c04686d8 B pci_mmcfg_config
+c04686dc B pci_mmcfg_config_num
+c04686e0 b warned.18795
+c04686e4 B pm_power_off
+c04686e8 b no_idt
+c04686f0 b reboot_mode
+c04686f4 b reboot_thru_bios
+c04686f8 b flush_cpumask
+c04686fc b flush_mm
+c0468700 b flush_va
+c0468704 b call_data
+c0468720 B cpu_possible_map
+c0468724 B cpu_callout_map
+c0468728 B cpu_callin_map
+c0468740 B apicid_2_node
+c0468840 B xquad_portio
+c0468844 b smp_b_stepping
+c0468848 b smp_commenced_mask
+c046884c b trampoline_base
+c0468850 b trampoline_exec
+c0468854 b init_deasserted
+c0468858 b cpucount
+c046885c b cpu_sibling_setup_map
+c0468860 b boot_cpu_logical_apicid
+c0468880 B def_to_bigsmp
+c0468884 B es7000_plat
+c04688a0 B mp_bus_id_to_type
+c0468cc0 B mp_bus_id_to_node
+c04690e0 B mp_bus_id_to_local
+c0469500 B quad_local_to_mp_bus_id
+c0469540 B smp_found_config
+c0469544 B nr_ioapics
+c0469560 B apic_version
+c0469960 B mp_irq_entries
+c0469980 B mp_irqs
+c046a180 B mp_lapic_addr
+c046a184 B pic_mode
+c046a1a0 B phys_cpu_present_map
+c046a1c0 B mp_ioapics
+c046a3c0 b gsi_to_irq.21809
+c046e3c0 b mp_current_pci_id
+c046e3c4 b mpc_record
+c046e3c8 b mpf_found
+c046e3e0 b mp_ioapic_routing
+c046eae0 B apic_verbosity
+c046eae4 B local_apic_timer_c2_ok
+c046eae8 B local_apic_timer_disabled
+c046eaec b local_apic_timer_verify_ok
+c046eaf0 b calibration_result
+c046eaf4 b enabled_via_apicbase
+c046eb00 b apic_pm_state
+c046eb40 B nmi_active
+c046eb44 B nmi_watchdog_enabled
+c046eb48 B unknown_nmi_panic
+c046eb4c b backtrace_mask
+c046eb50 b nmi_pm_active
+c046eb60 b last_irq_sums
+c046eba0 b alert_counter
+c046ebe0 B nr_ioapic_registers
+c046ece0 B skip_ioapic_setup
+c046ece4 B timer_uses_ioapic_pin_0
+c046ece8 B ioapic_renumber_irq
+c046ecec B irq_mis_count
+c046ecf0 b current_offset.23162
+c046ed00 b apic_id_map.23956
+c046ed20 b __warned.23614
+c046ed24 b __warned.23608
+c046ed40 b irq_2_pin
+c0470240 b pirq_entries
+c0470260 b pirqs_enabled
+c0470280 b mp_ioapic_data
+c0471000 b kexec_pgd
+c0472000 b kexec_pte0
+c0473000 b kexec_pte1
+c0474000 b crashing_cpu
+c0474004 b waiting_for_crash_ipi
+c0474008 b kdump_buf_page
+c0474020 b vdso_mapped.16776
+c0474040 b gate_vma
+c0474094 b syscall_pages
+c04740a0 B efi
+c04740ec B memmap
+c0474120 b efi_phys
+c047416c b efi_rt_eflags
+c0474170 b efi_bak_pg_dir_pointer
+c0474180 b doublefault_stack
+c0475180 b vm86_irqs
+c0475200 b irqbits
+c0475204 b current_xpos
+c0475208 b early_console_initialized
+c047520c b simnow_fd
+c0475220 B hpet_address
+c0475224 b hpet_virt_address
+c0475228 b boot_hpet_disable
+c047522c b hpet_legacy_int_enabled
+c0475230 b hpet_period
+c0475234 b hpet_rtc_flags
+c0475238 b hpet_prev_update_sec
+c0475240 b hpet_alarm_time
+c0475264 b hpet_pie_count
+c0475268 b hpet_t1_cmp
+c047526c b hpet_default_delta
+c0475270 b hpet_pie_delta
+c0475274 b hpet_pie_limit
+c0475280 B nx_enabled
+c0475284 B pmd_cache
+c0475288 B highstart_pfn
+c047528c B highend_pfn
+c0475290 B kmap_pte
+c0475294 B kmap_prot
+c0475298 b kcore_mem
+c04752a4 b kcore_vmalloc
+c04752b0 B pgd_list
+c04752b4 b fixmaps
+c04752c0 b insync.19308
+c0475340 B no_broadcast
+c0475380 B nohz_cpu_mask
+c0475384 B sched_smt_power_savings
+c0475388 B sched_mc_power_savings
+c047538c B max_cache_size
+c0475390 b cpu_isolated_map
+c0475394 b prev_jiffy.33219
+c0475398 b __key.33172
+c0475398 b migration_debug
+c047539c B sighand_cachep
+c04753a0 B fs_cachep
+c04753a4 B total_forks
+c04753a8 B nr_threads
+c04753ac B files_cachep
+c04753b0 B vm_area_cachep
+c04753b4 B max_threads
+c04753b8 b __key.27160
+c04753b8 b __key.27161
+c04753b8 b __key.27162
+c04753b8 b __key.27284
+c04753b8 b __key.27346
+c04753b8 b __key.27567
+c04753b8 b __key.27589
+c04753b8 b __key.27921
+c04753b8 b task_struct_cachep
+c04753bc b signal_cachep
+c04753c0 b mm_cachep
+c04753e0 B panic_blink
+c04753e4 B panic_timeout
+c04753e8 B panic_on_oops
+c04753ec B tainted
+c04753f0 b spin_counter.11972
+c04753f4 b buf.11921
+c0475420 b buf.11895
+c0475820 b pause_on_oops
+c0475824 b pause_on_oops_flag
+c0475840 B oops_in_progress
+c0475844 B console_drivers
+c0475848 b printk_time
+c047584c b missed.25920
+c0475850 b last_msg.25919
+c0475860 b printk_buf.25560
+c0475c60 b __key.25501
+c0475c60 b oops_timestamp.25488
+c0475c64 b console_locked
+c0475c68 b console_suspended
+c0475c6c b log_start
+c0475c70 b con_start
+c0475c74 b log_end
+c0475c80 b console_cmdline
+c0475d00 b console_may_schedule
+c0475d20 b __log_buf
+c0495d20 b logged_chars
+c0495d24 b prof_buffer
+c0495d28 b prof_len
+c0495d2c b prof_shift
+c0495d30 B sys_tz
+c0495d38 b __warned.18398
+c0495d3c b __warned.18358
+c0495d40 b __warned.18352
+c0495d44 b __warned.18318
+c0495d48 b __warned.18312
+c0495d60 b reserve.13494
+c0495df0 b reserved.13493
+c0495e00 B sysctl_legacy_va_layout
+c0495e20 b dev_table
+c0495e4c b minolduid
+c0495e50 b zero
+c0495e60 b binfmt_misc_table
+c0495e8c B securebits
+c0495f00 B boot_tvec_bases
+c0496f80 B avenrun
+c0496f8c b __key.20666
+c0496f8c b boot_done.20654
+c0496f8d b tvec_base_done.20653
+c0496fa0 b uid_cachep
+c0496fa4 b sigqueue_cachep
+c0496fa8 B cad_pid
+c0496fac b __key.26145
+c0496fac b kmod_loop_msg.23944
+c0496fb0 b kmod_concurrent.23943
+c0496fb4 b khelper_wq
+c0496fb8 b __key.11561
+c0496fb8 b pid_hash
+c0496fbc b pidhash_shift
+c0496fc0 b pid_cachep
+c0496fc4 b rcu_barrier_cpu_count
+c0496fc8 b rcu_barrier_completion
+c0496fe4 B module_sysfs_initialized
+c0497000 b __key.19217
+c0497000 b posix_timers_cache
+c0497020 b posix_timers_id
+c0497040 b posix_clocks
+c04972c0 B kthreadd_task
+c04972e0 b kthread_stop_info
+c0497304 b __key.15731
+c0497304 b zero_it.10297
+c0497314 b __key.10296
+c0497314 b __key.11554
+c0497314 b __key.14637
+c0497314 b current_max_latency
+c0497318 b nsproxy_cachep
+c049731c b __key.10315
+c0497320 B vx_global_ctotal
+c0497324 B vx_global_cactive
+c0497328 b __key.16128
+c0497328 b __key.16129
+c0497340 b vx_info_hash
+c0497374 b vx_info_inactive
+c0497378 B vs_global_nsproxy
+c049737c B vs_global_fs
+c0497380 B vs_global_mnt_ns
+c0497384 B vs_global_uts_ns
+c0497388 B vs_global_ipc_ns
+c04973a0 B nx_global_ctotal
+c04973a4 B nx_global_cactive
+c04973c0 B nx_info_hash
+c04973f4 b nx_addr_v4_cachep
+c04973f8 b nx_addr_v6_cachep
+c04973fc B vx_area
+c0497400 B dl_info_hash
+c0497434 b __key.14293
+c0497434 b proc_virtual
+c0497438 b proc_virtnet
+c0497440 B xtime
+c0497450 B wall_to_monotonic
+c0497458 b total_sleep_time
+c049745c b clock
+c0497460 b timekeeping_suspended
+c0497464 b timekeeping_suspend_time
+c0497468 B tick_nsec
+c049746c B time_freq
+c0497470 B time_adjust
+c0497474 b time_state
+c0497478 b tick_length
+c0497480 b tick_length_base
+c0497488 b time_offset
+c0497490 b time_reftime
+c04974a0 b next_clocksource
+c04974a4 b clocksource_override
+c04974c0 b override_name
+c04974e0 b finished_booting
+c04974e4 b watchdog
+c04974e8 b watchdog_timer
+c0497500 b watchdog_last
+c0497508 b watchdog_resumed
+c049750c b clockevents_chain
+c0497510 B tick_next_period
+c0497518 B tick_period
+c0497520 B tick_broadcast_device
+c0497528 b tick_broadcast_mask
+c0497540 b __key.20431
+c0497540 b printk_interval.20178
+c0497560 b futex_queues
+c0499560 b futex_mnt
+c0499564 b __key.10846
+c0499564 b prev_max.10457
+c0499568 b cpu_hotplug_disabled
+c049956c b pcpu_num_used
+c0499570 b pcpu_num_allocated
+c0499574 b pcpu_size
+c0499578 B pm_ops
+c049957c b orig_fgconsole
+c0499580 b orig_kmsg
+c0499584 B pm_active
+c0499588 B kexec_image
+c049958c B kexec_crash_image
+c0499590 B crash_notes
+c0499594 b kexec_lock
+c04995a0 b rootnode
+c049a5fc b root_count
+c049a600 b need_forkexit_callback
+c049a620 b init_css_group
+c049a644 b init_css_group_link
+c049a658 b css_group_count
+c049a65c b __key.14474
+c049a65c b __key.14478
+c049a65c b stopmachine_state
+c049a660 b stopmachine_num_threads
+c049a664 b stopmachine_thread_ack
+c049a680 b kprobe_table
+c049a780 b kretprobe_inst_table
+c049a880 b kprobe_count
+c049a884 b kprobe_enabled
+c049a888 b kprobe_insn_pages
+c049a88c b kprobe_garbage_slots
+c049a890 b did_panic
+c049a894 B no_irq_affinity
+c049a898 b root_irq_dir
+c049a900 B max_low_pfn
+c049a904 B min_low_pfn
+c049a908 B max_pfn
+c049a90c B saved_max_pfn
+c049a910 b __key.19398
+c049a910 B sysctl_panic_on_oom
+c049a914 b count.17066
+c049a920 B hashdist
+c049a924 B nr_swap_pages
+c049a928 B percpu_pagelist_fraction
+c049a92c b __key.22348
+c049a92c b __key.22349
+c049a940 b contig_bootmem_data
+c049a960 B block_dump
+c049a964 B laptop_mode
+c049a968 B nr_pdflush_threads
+c049a96c b last_empty_jifs
+c049a970 B page_cluster
+c049a974 B vm_total_pages
+c049a980 B vm_stat
+c049aa00 B pkmap_page_table
+c049aa04 b __key.20191
+c049aa04 b __key.20195
+c049aa20 b pkmap_count
+c049ba20 b last_pkmap_nr
+c049ba24 b page_address_pool
+c049ba2c b pool_lock
+c049ba80 b page_address_htable
+c049fa80 b page_address_maps
+c04a3a80 B mem_map
+c04a3a84 B max_mapnr
+c04a3a88 B num_physpages
+c04a3a8c B high_memory
+c04a3a90 B vmalloc_earlyreserve
+c04a3a94 b __key.22474
+c04a3a94 B sysctl_overcommit_memory
+c04a3a98 B vm_committed_space
+c04a3a9c B anon_vma_cachep
+c04a3aa0 b __key.18453
+c04a3aa0 B vmlist
+c04a3aa4 b page_pool
+c04a3aa8 b isa_page_pool
+c04a3aac b swap_cache_info
+c04a3ae0 B total_swap_pages
+c04a3ae4 B nr_swapfiles
+c04a3ae8 b least_priority.27335
+c04a3aec b swap_overflow
+c04a3b00 b swap_info
+c04a4380 B swap_token_mm
+c04a4384 b global_faults
+c04a4388 b __key.25898
+c04a4388 b __key.26516
+c04a4388 b shmem_inode_cachep
+c04a438c b shm_mnt
+c04a4390 b __key.18056
+c04a4390 b __key.18790
+c04a4390 b slab_break_gfp_order
+c04a4394 b __key.18997
+c04a4394 b __key.19038
+c04a4394 b __key.19047
+c04a4394 b cache_chain
+c04a439c b g_cpucache_up
+c04a43a0 b __xip_sparse_page
+c04a43c0 b __key.22995
+c04a43c0 b __key.23672
+c04a43c0 b old_max.23667
+c04a43c4 b __key.22677
+c04a43e0 b __key.27005
+c04a43e0 b __key.27006
+c04a43e0 b __key.27007
+c04a43e0 b __key.27008
+c04a43e0 b __key.27009
+c04a43e0 b __key.27010
+c04a43e0 b default_op.27003
+c04a4440 b unnamed_dev_idr
+c04a4460 b cdev_map
+c04a4480 b chrdevs
+c04a487c B suid_dumpable
+c04a4880 B core_uses_pid
+c04a4884 b formats
+c04a48a0 b _buffer.25831
+c04a58a0 b _buffer.25438
+c04a68a0 b __key.25428
+c04a68a0 B inodes_stat
+c04a68c0 b empty_fops.24398
+c04a6940 b empty_iops.24397
+c04a69a0 b empty_aops.24396
+c04a69dc b counter.24746
+c04a69e0 b last_ino.24664
+c04a69e4 b __key.17372
+c04a69e4 b __key.24432
+c04a69e4 b __key.24433
+c04a69e4 b __key.24434
+c04a69e4 b __key.24435
+c04a69e4 b __key.24436
+c04a69e4 b __key.24437
+c04a69e4 b __key.24439
+c04a69e4 b file_systems
+c04a69e8 b __key.26064
+c04a69e8 b event
+c04a69ec b namespace_sem
+c04a6a08 B aio_nr
+c04a6a0c b __key.24229
+c04a6a0c b __key.24230
+c04a6a0c b kiocb_cachep
+c04a6a10 b kioctx_cachep
+c04a6a14 b aio_wq
+c04a6a18 b __key.12125
+c04a6a18 b __key.18067
+c04a6a18 B sysctl_drop_caches
+c04a6a1c B buffer_heads_over_limit
+c04a6a20 b msg_count.23794
+c04a6a24 b bh_cachep
+c04a6a28 b max_buffer_heads
+c04a6a2c b fs_bio_set
+c04a6a30 b bio_dirty_list
+c04a6a34 B blockdev_superblock
+c04a6a38 b __key.20207
+c04a6a38 b __key.20373
+c04a6a38 b revokefs_inode_cache
+c04a6a3c b revokefs_mnt
+c04a6a40 b __key.14847
+c04a6a40 b inotify_cookie
+c04a6a44 b __key.15369
+c04a6a44 b __key.15370
+c04a6a44 b zero
+c04a6a48 b __key.16959
+c04a6a48 b __key.17092
+c04a6a48 b __key.17093
+c04a6a48 b __key.17473
+c04a6a48 b epmutex
+c04a6a64 b psw
+c04a6a80 b anon_inode_inode
+c04a6aa0 b anon_inode_fops
+c04a6b10 b bm_mnt
+c04a6b14 b entry_count
+c04a6b18 b mb_shrinker
+c04a6b20 B dqstats
+c04a6b40 b __key.24837
+c04a6b40 b quota_formats
+c04a6b44 b dquot_cachep
+c04a6b48 b dq_hash_bits
+c04a6b4c b dq_hash_mask
+c04a6b50 b dquot_hash
+c04a6b58 B proc_mnt
+c04a6b5c b proc_inode_cachep
+c04a6b60 B proc_root_fs
+c04a6b64 B proc_bus
+c04a6b68 B proc_root_driver
+c04a6b6c B proc_virtual
+c04a6b70 B maps_protect
+c04a6b74 b proc_tty_ldisc
+c04a6b78 b proc_tty_driver
+c04a6b7c B proc_root_kcore
+c04a6b80 b p.21867
+c04a6b84 b proc_sys_root
+c04a6b88 b proc_net_shadow
+c04a6b8c b kclist
+c04a6b90 B proc_vmcore
+c04a6b94 b elfcorebuf
+c04a6b98 b elfcorebuf_sz
+c04a6ba0 b vmcore_size
+c04a6ba8 B sysfs_sb
+c04a6bac B sysfs_mount
+c04a6bb0 B sysfs_dir_cachep
+c04a6bb4 b __key.12318
+c04a6bb4 b devpts_mnt
+c04a6bb8 b devpts_root
+c04a6bbc b __key.18943
+c04a6bbc b __key.18957
+c04a6bbc b __key.22047
+c04a6bbc b __key.22048
+c04a6bbc b __key.22618
+c04a6bbc b __key.22619
+c04a6bbc b ext3_inode_cachep
+c04a6bc0 b ext3_xattr_cache
+c04a6bc4 b __key.18771
+c04a6bc4 b __key.18875
+c04a6bc4 b revoke_record_cache
+c04a6bc8 b revoke_table_cache
+c04a6bcc B jbd_handle_cache
+c04a6bd0 b last_warning.20256
+c04a6bd4 b __key.19460
+c04a6bd4 b __key.19461
+c04a6bd4 b __key.19462
+c04a6bd4 b __key.19463
+c04a6bd4 b __key.19464
+c04a6bd4 b jbd_slab
+c04a6be8 b journal_head_cache
+c04a6bec b __key.19996
+c04a6bec b __key.20010
+c04a6bec b __key.20701
+c04a6bec b __key.20702
+c04a6bec b __key.21059
+c04a6bec b ext2_inode_cachep
+c04a6bf0 b ext2_xattr_cache
+c04a6c00 b zerotime.19927
+c04a6c20 b read_buffers
+c04aec20 b buffer_blocknr
+c04aec28 b buffer_dev
+c04aec30 b next_buffer
+c04aec40 b stream
+c04aec70 b initialized
+c04aec80 b isofs_inode_cachep
+c04aeca0 b zisofs_sink_page
+c04afca0 b zisofs_zlib_workspace
+c04afcc0 b zisofs_zlib_semaphore
+c04afce0 b initialized
+c04afce4 b debugfs_mount
+c04afce8 b debugfs_mount_count
+c04afd00 b __key.22972
+c04afd00 b __key.23054
+c04afd00 b msg_bytes
+c04afd04 b msg_hdrs
+c04afd20 b init_msg_ids
+c04afd60 b __key.25026
+c04afd60 b init_sem_ids
+c04afda0 b init_shm_ids
+c04afdd0 b __key.28171
+c04afdd0 b __key.28925
+c04afdd0 b mq_lock
+c04afde0 b mqueue_inode_cachep
+c04afde4 b mqueue_mnt
+c04afde8 b queues_count
+c04afdec b mq_sysctl_table
+c04afdf0 b __warned.18910
+c04afdf4 b __warned.18832
+c04afe00 b __key.19848
+c04afe00 b printed.20149
+c04afe04 b chosen_elevator
+c04afe14 B blk_max_low_pfn
+c04afe18 B blk_max_pfn
+c04afe1c b __key.22209
+c04afe1c b __key.22235
+c04afe1c b request_cachep
+c04afe20 b requestq_cachep
+c04afe24 b iocontext_cachep
+c04afe28 b kblockd_workqueue
+c04afe40 b major_names
+c04b023c b bdev_map
+c04b0240 b cfq_pool
+c04b0244 b cfq_ioc_pool
+c04b0248 b ioc_gone
+c04b024c b __key.20196
+c04b024c b blk_tree_root
+c04b0250 b blk_tree_mutex
+c04b026c b root_users
+c04b0270 b __key.8093
+c04b0270 b idr_layer_cache
+c04b0274 b __key.7947
+c04b0278 B uevent_seqnum
+c04b0280 b uevent_sock
+c04b02a0 b index_bits_to_maxindex
+c04b0320 b radix_tree_node_cachep
+c04b0324 b __key.10317
+c04b0324 B debug_locks_silent
+c04b0380 B platform_pci_choose_state
+c04b0384 B platform_pci_set_power_state
+c04b0388 B pci_pci_problems
+c04b038c B pcie_mch_quirk
+c04b0390 B isa_dma_bridge_buggy
+c04b0394 b asus_hides_smbus
+c04b0398 b __key.18482
+c04b0398 b sysfs_initialized
+c04b039c b proc_initialized
+c04b03a0 b proc_bus_pci_dir
+c04b03c0 b errmsg_buff
+c04b0424 b forceload
+c04b0428 b __key.18731
+c04b0428 b ctrlset_buf
+c04b0434 b global_ctrlsets
+c04b0440 b vga_bootup_console.18555
+c04b0444 b cursor_size_lastfrom
+c04b0448 b cursor_size_lastto
+c04b044c b vgacon_xres
+c04b0450 b vgacon_yres
+c04b0460 b state
+c04b0488 b vgacon_uni_pagedir
+c04b0490 b vga_video_num_columns
+c04b0494 b vga_video_num_lines
+c04b0498 b vga_vesa_blanked
+c04b049c b vga_palette_blanked
+c04b04a0 b vga_is_gfx
+c04b04a4 b vga_512_chars
+c04b04a8 b vga_video_font_height
+c04b04ac b vga_rolled_over
+c04b04b0 b vgacon_scrollback
+c04b04b4 b vgacon_scrollback_tail
+c04b04b8 b vgacon_scrollback_size
+c04b04bc b vgacon_scrollback_rows
+c04b04c0 b vgacon_scrollback_cnt
+c04b04c4 b vgacon_scrollback_cur
+c04b04c8 b vgacon_scrollback_save
+c04b04cc b vgacon_scrollback_restore
+c04b04d0 b vga_state
+c04b04e0 B acpi_do_set_cstate_limit
+c04b04e4 B osi_linux
+c04b04e8 b __key.23375
+c04b04e8 b t.23118
+c04b0500 b buffer.23022
+c04b0700 b acpi_irq_irq
+c04b0704 b acpi_irq_handler
+c04b0708 b acpi_irq_context
+c04b070c b kacpid_wq
+c04b0710 b kacpi_notify_wq
+c04b0720 b osi_additional_string
+c04b0760 b acpi_os_name
+c04b07c4 b facs
+c04b07c8 b acpi_ev_global_lock_thread_id
+c04b07cc b acpi_ev_global_lock_acquired
+c04b07d0 b acpi_gbl_depth
+c04b07e0 B acpi_gbl_enable_interpreter_slack
+c04b07e1 B acpi_gbl_all_methods_serialized
+c04b07e4 B acpi_gbl_nesting_level
+c04b07e8 B acpi_gbl_db_terminate_threads
+c04b07e9 B acpi_gbl_abort_method
+c04b07ea B acpi_gbl_method_executing
+c04b07ec B acpi_gbl_startup_flags
+c04b07f0 B acpi_gpe_count
+c04b07f4 B acpi_gbl_original_dbg_level
+c04b07f8 B acpi_gbl_original_dbg_layer
+c04b07fc B acpi_gbl_trace_method_name
+c04b0800 B acpi_gbl_trace_dbg_level
+c04b0804 B acpi_gbl_trace_dbg_layer
+c04b0808 B acpi_gbl_trace_flags
+c04b080c B acpi_gbl_root_table_list
+c04b0820 B acpi_gbl_FADT
+c04b0914 B acpi_gbl_xpm1a_enable
+c04b0920 B acpi_gbl_xpm1b_enable
+c04b092c B acpi_gbl_integer_bit_width
+c04b092d B acpi_gbl_integer_byte_width
+c04b092e B acpi_gbl_integer_nybble_width
+c04b0940 B acpi_gbl_mutex_info
+c04b09a0 B acpi_gbl_global_lock_mutex
+c04b09a4 B acpi_gbl_global_lock_semaphore
+c04b09a8 B _acpi_gbl_gpe_lock
+c04b09b8 B _acpi_gbl_hardware_lock
+c04b09c8 B acpi_gbl_namespace_cache
+c04b09cc B acpi_gbl_state_cache
+c04b09d0 B acpi_gbl_ps_node_cache
+c04b09d4 B acpi_gbl_ps_node_ext_cache
+c04b09d8 B acpi_gbl_operand_cache
+c04b09dc B acpi_gbl_device_notify
+c04b09f4 B acpi_gbl_system_notify
+c04b0a0c B acpi_gbl_exception_handler
+c04b0a10 B acpi_gbl_init_handler
+c04b0a14 B acpi_gbl_breakpoint_walk
+c04b0a18 B acpi_gbl_original_mode
+c04b0a1c B acpi_gbl_rsdp_original_location
+c04b0a20 B acpi_gbl_ns_lookup_count
+c04b0a24 B acpi_gbl_ps_find_count
+c04b0a40 B acpi_gbl_owner_id_mask
+c04b0a60 B acpi_gbl_pm1_enable_register_save
+c04b0a62 B acpi_gbl_global_lock_handle
+c04b0a64 B acpi_gbl_last_owner_id_index
+c04b0a65 B acpi_gbl_next_owner_id_offset
+c04b0a66 B acpi_gbl_debugger_configuration
+c04b0a67 B acpi_gbl_global_lock_acquired
+c04b0a68 B acpi_gbl_step_to_next_call
+c04b0a69 B acpi_gbl_acpi_hardware_present
+c04b0a6a B acpi_gbl_global_lock_present
+c04b0a6b B acpi_gbl_events_initialized
+c04b0a6c B acpi_gbl_system_awake_and_running
+c04b0a70 B acpi_gbl_root_node_struct
+c04b0a84 B acpi_gbl_root_node
+c04b0a88 B acpi_gbl_fadt_gpe_device
+c04b0a8c B acpi_gbl_current_walk_list
+c04b0a90 B acpi_gbl_cm_single_step
+c04b0a91 B acpi_gbl_sleep_type_a
+c04b0a92 B acpi_gbl_sleep_type_b
+c04b0aa0 B acpi_gbl_fixed_event_handlers
+c04b0ac8 B acpi_gbl_gpe_xrupt_list_head
+c04b0acc B acpi_gbl_gpe_fadt_blocks
+c04b0ad4 B acpi_gbl_db_output_flags
+c04b0ad8 b __key.10111
+c04b0ad8 b __key.10112
+c04b0ad8 B acpi_gbl_permanent_mmap
+c04b0adc B acpi_root_dir
+c04b0ae0 B acpi_root
+c04b0ae4 b __key.19457
+c04b0ae4 b boot_ec
+c04b0ae8 b first_ec
+c04b0aec b acpi_ec_dir
+c04b0af0 b sub_driver
+c04b0af4 b acpi_link
+c04b0b00 b acpi_irq_balance
+c04b0b04 b acpi_prt
+c04b0b10 b __key.15927
+c04b0b10 b acpi_power_resource_list
+c04b0b18 b acpi_power_dir
+c04b0b20 b tables_kobj
+c04b0b80 B event_is_open
+c04b0b84 b ptr.18334
+c04b0b88 b chars_remaining.18333
+c04b0ba0 b str.18332
+c04b0bf0 b acpi_ac_dir
+c04b0bf4 b acpi_battery_dir
+c04b0bf8 b lock_ac_dir_cnt
+c04b0bfc b lock_battery_dir_cnt
+c04b0c00 B pnp_platform_devices
+c04b0c04 b num
+c04b0c80 b mem_class
+c04b0d00 b last_value.16747
+c04b0d04 b input_timer_state
+c04b0d20 b irq_timer_state
+c04b1100 b ip_keydata
+c04b1200 b ip_cnt
+c04b1204 b min_write_thresh
+c04b1208 b sysctl_bootid
+c04b1220 b input_pool_data
+c04b1420 b nonblocking_pool_data
+c04b14a0 b blocking_pool_data
+c04b1520 b __key.19306
+c04b1520 b __key.21020
+c04b1520 b __key.21022
+c04b1520 b __key.21023
+c04b1520 b __key.21024
+c04b1520 b __warned.21263
+c04b1540 b tty_ldiscs
+c04b1a4c b redirect
+c04b1a50 b tty_class
+c04b1a60 b tty_cdev
+c04b1ae0 b console_cdev
+c04b1b60 b ptmx_cdev
+c04b1be0 b vc0_cdev
+c04b1c44 B ptm_driver
+c04b1c48 b pts_driver
+c04b1c4c b pty_limit_min
+c04b1c50 b misc_minors
+c04b1c58 b misc_class
+c04b1c5c B vt_dont_switch
+c04b1c60 b vc_class
+c04b1c80 b inv_translate
+c04b1d7c b dflt
+c04b1d80 B sel_cons
+c04b1d84 b sel_end
+c04b1d88 b sel_buffer_lth
+c04b1d8c b sel_buffer
+c04b1da0 B shift_state
+c04b1dc0 B kbd_table
+c04b1efc b releasestart.18986
+c04b1f00 b committing.18985
+c04b1f04 b pressed.18984
+c04b1f08 b committed.18970
+c04b1f0c b chords.18969
+c04b1f20 b key_down
+c04b1f60 b shift_down
+c04b1f6c b dead_key_next
+c04b1f70 b diacr
+c04b1f74 b rep
+c04b1f75 b ledioctl
+c04b1f80 b ledptrs
+c04b1fa4 b sysrq_down
+c04b1fa8 b sysrq_alt_use
+c04b1fac b sysrq_alt
+c04b1fc0 B kmsg_redirect
+c04b1fc4 B conswitchp
+c04b1fe0 B vc_cons
+c04b24cc B fg_console
+c04b24d0 B last_console
+c04b24e0 B con_buf
+c04b34e0 B console_blanked
+c04b34e4 B do_poke_blanked_console
+c04b34e8 B console_blank_hook
+c04b34ec B console_driver
+c04b34f0 b printing.20863
+c04b34f4 b error.20650
+c04b34f8 b oldy.19350
+c04b34fa b oldx.19349
+c04b34fc b old.19348
+c04b3500 b registered_con_driver
+c04b36c0 b con_driver_map
+c04b37bc b printable
+c04b37c0 b default_utf8
+c04b37c4 b ignore_poke
+c04b37c8 b vesa_blank_mode
+c04b37cc b vesa_off_interval
+c04b37d0 b master_display_fg
+c04b37d4 b scrollback_delta
+c04b37d8 b blank_state
+c04b37dc b blank_timer_expired
+c04b37e0 b softcursor_original
+c04b37e4 b vtconsole_class
+c04b37e8 B funcbufleft
+c04b37ec b rtc_freq
+c04b37f0 b rtc_status
+c04b37f4 b rtc_irq_data
+c04b37f8 b rtc_callback
+c04b37fc b rtc_async_queue
+c04b3800 b sysctl_header
+c04b3804 b last.21373
+c04b3808 b hpet_nhpet
+c04b380c b hpets
+c04b3810 b sysctl_header
+c04b3814 b current_rng
+c04b3818 b hangcheck_reboot
+c04b381c b hangcheck_dump_tasks
+c04b3820 b hangcheck_tsc
+c04b3828 b hangcheck_tsc_margin
+c04b3840 b __key.18025
+c04b3840 b __key.18192
+c04b3840 b __key.18239
+c04b3840 b __key.18283
+c04b3840 b __key.18595
+c04b3840 b probe_rsa
+c04b3850 b probe_rsa_count
+c04b3860 b irq_lists
+c04b49e0 b serial8250_ports
+c04b62e0 b serial8250_isa_devs
+c04b6300 B platform_notify
+c04b6304 B platform_notify_remove
+c04b6308 b virtual_dir.8950
+c04b630c b __key.8939
+c04b630c b __key.8984
+c04b630c b probe_count
+c04b6320 b cpu_sys_devices
+c04b6360 b attribute_container_list
+c04b6368 B platform_enable_wakeup
+c04b636c b __key.17082
+c04b636c b topology_dev_map
+c04b6380 b rd_disks
+c04b63c0 b rd_bdev
+c04b6400 b rd_queue
+c04b6480 b m5229_revision
+c04b6481 b chip_is_1543c_e
+c04b6484 b isa_dev
+c04b6488 b amd_config
+c04b648c b amd_chipset
+c04b6490 b amd_80w
+c04b6494 b amd_clock
+c04b6498 b save_mdma_mode
+c04b64a8 b primary
+c04b64ac b it8212_noraid
+c04b64b0 b no_piix_dma
+c04b64b4 b svwks_revision
+c04b64b8 b isa_dev
+c04b64bc b chipset_family
+c04b64c0 b via_clock
+c04b64c4 b ide_generic_all
+c04b6500 B noautodma
+c04b6580 B ide_hwifs
+c04bba80 b tmp_hwif.23020
+c04bc300 b idebus_parameter
+c04bc304 b system_bus_speed
+c04bc308 b ide_scan_direction
+c04bc30c b count.23828
+c04bc310 b last_msgtime.23827
+c04bc314 B cmd640_vlb
+c04bc318 b cmd_hwif0
+c04bc31c b cmd_hwif1
+c04bc320 b cmd_drives
+c04bc330 b cmd640_key
+c04bc334 b __put_cmd640_reg
+c04bc338 b __get_cmd640_reg
+c04bc33c b cmd640_chip_version
+c04bc340 b ignore
+c04bc360 b dum.23366
+c04bc560 b dum.23318
+c04bc760 b initialized.23262
+c04bc764 b banner_printed.20582
+c04bc768 b debug
+c04bc76c b keeplocked
+c04bc770 b autoeject
+c04bc774 b check_media_type
+c04bc778 b topCdromPtr
+c04bc780 b cdrom_sysctl_settings
+c04bcb7c b cdrom_sysctl_header
+c04bcb80 B ksuspend_usb_wq
+c04bcb84 b __key.18870
+c04bcb84 b nousb
+c04bcb88 b blinkenlights
+c04bcb8c b old_scheme_first
+c04bcb90 b __key.16158
+c04bcb90 b __key.17553
+c04bcb90 b __key.17569
+c04bcb90 b khubd_task
+c04bcb94 b highspeed_hubs
+c04bcb98 b busmap
+c04bcba0 b usb_host_class
+c04bcba4 b __key.16567
+c04bcba4 b __key.17107
+c04bcba4 b __key.19142
+c04bcba4 b __key.19153
+c04bcba4 b __key.19165
+c04bcba4 b __key.19915
+c04bcbc0 b usb_minors
+c04bcfc0 b usb_class
+c04bcfc4 b usb_endpoint_major
+c04bcfc8 b ep_class
+c04bcfcc b usbfs_snoop
+c04bcfd0 b __key.24419
+c04bcfd0 b usb_classdev_class
+c04bcfd4 b usbdir
+c04bcfd8 b ignore_mount
+c04bcfdc b usbfs_mount
+c04bcfe0 b usbfs_mount_count
+c04bcfe4 b devices_usbfs_dentry
+c04bcfe8 b num_buses
+c04bcfec b devuid
+c04bcff0 b busuid
+c04bcff4 b listuid
+c04bcff8 b devgid
+c04bcffc b busgid
+c04bd000 b listgid
+c04bd004 b conndiscevcnt
+c04bd008 b total_threads
+c04bd00c b stat
+c04bd020 b __key.12264
+c04bd020 b __key.12265
+c04bd020 b serio_no.12263
+c04bd024 b serio_task
+c04bd040 b last_str.12939
+c04bd044 b last_transmit.12938
+c04bd048 b led.13200
+c04bd04c b last_blink.13199
+c04bd050 b i8042_nokbd
+c04bd054 b i8042_noaux
+c04bd058 b i8042_nomux
+c04bd05c b i8042_unlock
+c04bd060 b i8042_reset
+c04bd064 b i8042_direct
+c04bd068 b i8042_dumbkbd
+c04bd06c b i8042_noloop
+c04bd070 b i8042_nopnp
+c04bd074 b i8042_debug
+c04bd078 b i8042_kbd_irq
+c04bd07c b i8042_aux_irq
+c04bd080 b i8042_pnp_kbd_registered
+c04bd084 b i8042_pnp_kbd_devices
+c04bd088 b i8042_pnp_aux_registered
+c04bd08c b i8042_pnp_aux_devices
+c04bd090 b i8042_pnp_command_reg
+c04bd094 b i8042_pnp_data_reg
+c04bd098 b i8042_pnp_kbd_irq
+c04bd09c b i8042_pnp_aux_irq
+c04bd0a0 b i8042_pnp_kbd_name
+c04bd0c0 b i8042_pnp_aux_name
+c04bd0e0 b i8042_start_time
+c04bd100 b i8042_ports
+c04bd148 b i8042_initial_ctr
+c04bd149 b i8042_ctr
+c04bd14a b i8042_mux_present
+c04bd14b b i8042_kbd_irq_registered
+c04bd14c b i8042_aux_irq_registered
+c04bd14d b i8042_suppress_kbd_ack
+c04bd150 b i8042_platform_device
+c04bd154 b i8042_aux_irq_delivered
+c04bd170 b i8042_irq_being_tested
+c04bd174 b __key.16266
+c04bd180 b input_no.17807
+c04bd184 b __key.17759
+c04bd1a0 b input_table
+c04bd1c0 b proc_bus_input_dir
+c04bd1c4 b input_devices_state
+c04bd1c8 b __key.13369
+c04bd1e0 b __key.16120
+c04bd1e0 b mousedev_table
+c04bd260 b mousedev_mix
+c04bd320 b evdev_table
+c04bd3a0 b __key.16712
+c04bd3a0 b atkbd_reset
+c04bd3a4 b atkbd_softrepeat
+c04bd3a8 b atkbd_scroll
+c04bd3ac b atkbd_extra
+c04bd3b0 b psmouse_resync_time
+c04bd3b4 b kpsmoused_wq
+c04bd3b8 b desired_serio_phys
+c04bd3bc b lifebook_use_6byte_proto
+c04bd3c0 B __i2c_first_dynamic_bus_num
+c04bd3e0 B mdp_major
+c04bd3e4 b __key.21780
+c04bd3e4 b __key.21781
+c04bd3e4 b raid_table_header
+c04bd3e8 b start_readonly
+c04bd3ec b md_event_count
+c04bd3f0 b start_dirty_degraded
+c04bd400 b detected_devices
+c04bd600 b dev_cnt
+c04bd604 b __key.22513
+c04bd620 b major
+c04bd624 b _major
+c04bd628 b __key.21883
+c04bd628 b __key.21884
+c04bd628 b __key.21885
+c04bd628 b _io_cache
+c04bd62c b _tio_cache
+c04bd640 b _name_buckets
+c04bd840 b _uuid_buckets
+c04bda40 b kcopyd_clients
+c04bda44 b __key.20375
+c04bda44 b _kcopyd_wq
+c04bda48 b _kcopyd_work
+c04bda58 b _job_cache
+c04bda5c b _job_pool
+c04bda60 b dmi_ident
+c04bda8c B use_cyclone
+c04bda90 b cyclone_ptr
+c04bda94 b acpi_pm_good
+c04bda98 b __key.18269
+c04bda98 b __key.18279
+c04bda98 b id.17984
+c04bda9c b quirks_param
+c04bdaac b __key.17900
+c04bdaac b __key.17923
+c04bdaac b __key.19116
+c04bdaac b __key.19117
+c04bdaac b __key.19118
+c04bdaac b hid_mousepoll_interval
+c04bdac0 b pci_bios_present
+c04bdac4 b mmcfg_last_accessed_device
+c04bdac8 b mmcfg_last_accessed_cpu
+c04bdae0 B pci_mmcfg_fallback_slots
+c04bdb20 b quirk_aspm_offset
+c04bdbe0 b toshiba_line_size
+c04bdbe4 B pcibios_enable_irq
+c04bdbe8 B pcibios_disable_irq
+c04bdbec b eisa_irq_mask.21876
+c04bdbf0 b broken_hp_bios_irq9
+c04bdbf4 b acer_tm360_irqrouting
+c04bdbf8 b pirq_table
+c04bdbfc b pirq_router
+c04bdc0c b pirq_router_dev
+c04bdc10 B raw_pci_ops
+c04bdc14 B pirq_table_addr
+c04bdc18 B pci_root_bus
+c04bdc1c B pcibios_scanned
+c04bdc20 B pci_routeirq
+c04bdc24 b pci_bf_sort
+c04bdc40 B saved_context_ebx
+c04bdc44 B saved_context_esp
+c04bdc48 B saved_context_ebp
+c04bdc4c B saved_context_esi
+c04bdc50 B saved_context_edi
+c04bdc54 B saved_context_eflags
+c04bdc60 b saved_context
+c04bdd00 b br_ioctl_hook
+c04bdd04 b warned.32462
+c04bdd08 b vlan_ioctl_hook
+c04bdd0c b dlci_ioctl_hook
+c04bdd80 b __key.19540
+c04bdd80 b __key.34859
+c04bdd80 b __key.34910
+c04bdd80 b __key.34911
+c04bdd80 b __key.35351
+c04bdd80 b __key.35352
+c04bdd80 b warncomm.34524
+c04bdd90 b warned.34523
+c04bdd94 b warned.34502
+c04bdd98 b __key.25796
+c04bdda0 b elist
+c04bde80 B init_net
+c04be680 b net_cachep
+c04be6a0 b __key.19191
+c04be6a0 b __key.31153
+c04be6a0 b __key.31176
+c04be6a0 b ifindex.30727
+c04be6a4 b netdev_chain
+c04be6a8 b __key.30750
+c04be6a8 b __key.30751
+c04be6a8 b __key.30752
+c04be6a8 b netstamp_needed
+c04be6c0 b dev_boot_setup
+c04be7c0 b gifconf_list
+c04be848 b dst_garbage_list
+c04be84c b dst_gc_timer_expires
+c04be850 b __key.16600
+c04be850 b __key.25769
+c04be850 b __key.26581
+c04be850 b __key.26847
+c04be850 b neigh_tables
+c04be860 b rtnl_msg_handlers
+c04be8e8 b rta_buf
+c04be8ec b rtattr_max
+c04be8f0 b linkwatch_flags
+c04be8f4 b linkwatch_nextevent
+c04be8f8 b lweventlist
+c04be8fc B flow_cache_genid
+c04be900 b flow_hash_shift
+c04be904 b flow_lwm
+c04be908 b flow_hwm
+c04be90c b flow_hash_rnd_timer
+c04be924 b __key.26355
+c04be940 B tr_table
+c04be96c b __key.19201
+c04be96c b qdisc_base
+c04be970 b qdisc_rtab_list
+c04be974 b tcf_proto_base
+c04be980 b nl_table_users
+c04be984 b __key.27078
+c04be984 b nl_table
+c04be9a0 B genl_sock
+c04be9a4 b id_gen_idx.25887
+c04be9c0 b family_ht
+c04bea40 B ip_ct_attach
+c04bea44 B nf_ct_destroy
+c04bea60 b nf_loggers
+c04beb00 b queue_handler
+c04bec00 B ip_rt_acct
+c04bec04 b equilibrium.35647
+c04bec08 b rover.35646
+c04bec0c b last_gc.35645
+c04bec10 b __key.37510
+c04bec10 b rover.35527
+c04bec14 b ip_fallback_id.35858
+c04bec18 b ip_rt_max_size
+c04bec1c b rt_deadline
+c04bec20 b rt_flush_timer
+c04bec38 b rt_periodic_timer
+c04bec50 b rt_secret_timer
+c04bec68 b rt_hash_locks
+c04bec6c b rt_hash_table
+c04bec70 b rt_hash_mask
+c04bec74 b rt_hash_log
+c04bec78 b rt_hash_rnd
+c04bec7c b flush_delay
+c04bec80 B inet_protos
+c04bf080 b __key.28811
+c04bf080 B ip_ra_chain
+c04bf084 b hint.29382
+c04bf088 B tcp_orphan_count
+c04bf08c B tcp_memory_allocated
+c04bf090 B tcp_sockets_allocated
+c04bf094 b __key.35534
+c04bf094 b __key.35538
+c04bf0a0 b __key.16588
+c04bf0a0 b tcp4_seq_fops
+c04bf110 b __key.16735
+c04bf110 B sysctl_tcp_max_ssthresh
+c04bf120 B raw_v4_htable
+c04bf520 b complained.31787
+c04bf540 B udp_hash
+c04bf740 b udp4_seq_fops
+c04bf7c0 B udplite_hash
+c04bf9c0 b udplite_port_rover
+c04bf9e0 b udplite4_seq_fops
+c04bfa50 B sysctl_icmp_ipod_enabled
+c04bfa60 b inetsw
+c04bfab8 b __key.29416
+c04bfab8 b __key.29464
+c04bfab8 b __key.29465
+c04bfab8 b zero
+c04bfabc b fib_hash_genid
+c04bfac0 b tunnel4_handlers
+c04bfac4 b tunnel64_handlers
+c04bfac8 B ip_nat_decode_session
+c04bfae0 B xfrm_policy_count
+c04bfaf8 b xfrm_policy_gc_list
+c04bfb00 b dummy.32810
+c04bfb20 b idx_generator.31838
+c04bfb24 b __key.31558
+c04bfb40 b xfrm_policy_afinfo
+c04bfbc8 b xfrm_policy_gc_work
+c04bfbd8 b xfrm_policy_inexact
+c04bfc00 B xfrm_nl
+c04bfc04 b xfrm_state_gc_list
+c04bfc08 b acqseq.31436
+c04bfc0c b __key.30758
+c04bfc0c b xfrm_state_num
+c04bfc10 b xfrm_state_genid
+c04bfc20 b xfrm_state_afinfo
+c04bfca8 b xfrm_state_gc_work
+c04bfcc0 B unix_socket_table
+c04c00c4 b unix_nr_socks
+c04c00c8 b __key.26912
+c04c00c8 b __key.26913
+c04c00c8 B unix_tot_inflight
+c04c00cc b __key.16509
+c04c00e0 b inetsw6
+c04c0138 b __key.28881
+c04c0140 b __key.33937
+c04c0140 b __key.34054
+c04c0140 b inet6_addr_lst
+c04c0180 b last_gc.34553
+c04c0184 b ndisc_dst_gc_list
+c04c0188 b flush_delay
+c04c018c B rt6_stats
+c04c01a4 b __key.28790
+c04c01a4 b rt_sernum
+c04c01a8 b fib_table_hash
+c04c01ac b gc_args
+c04c01b4 B ip6_ra_chain
+c04c01b8 b warned.31025
+c04c01bc b warncomm.31024
+c04c01cc b ndisc_socket
+c04c01e0 b udp6_seq_fops
+c04c0260 b udplite6_seq_fops
+c04c02e0 B raw_v6_htable
+c04c06e0 B inet6_protos
+c04c0ae0 b __key.29642
+c04c0ae0 b __key.30040
+c04c0ae0 b __key.30106
+c04c0ae0 b __key.31811
+c04c0ae0 b igmp6_socket
+c04c0b00 B ip6_frag_nqueues
+c04c0b04 B ip6_frag_mem
+c04c0b08 b __key.29150
+c04c0b20 b ip6_frag_hash
+c04c0c20 b ip6_frag_hash_rnd
+c04c0c24 b ip6_frag_secret_timer
+c04c0c40 b __key.16664
+c04c0c40 b tcp6_socket
+c04c0c60 b tcp6_seq_fops
+c04c0cd0 b ipv6_sysctl_header
+c04c0ce0 b fl_size
+c04c0d00 b fl_ht
+c04c1100 b proc_net_devsnmp6
+c04c1120 b ipip6_fb_tunnel_dev
+c04c1140 b tunnels_r_l
+c04c1180 b tunnels_r
+c04c11c0 b tunnels_l
+c04c1200 b tunnels_wc
+c04c1204 b hint.30178
+c04c1208 b __key.29303
+c04c1208 b __key.30074
+c04c1208 b packet_socks_nr
+c04c120c b __key.16600
+c04c120c b wireless_nlevent_queue
+c04c1228 B __bss_stop
+c04c1228 b __key.7773
+c04c1228 B _end
+c04c2000 B pg0
diff -Nurb linux-2.6.22-590/inst/System.map-2.6.22-prep linux-2.6.22-try2-netns/inst/System.map-2.6.22-prep
--- linux-2.6.22-590/inst/System.map-2.6.22-prep	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/System.map-2.6.22-prep	2007-12-21 13:22:23.000000000 -0500
@@ -0,0 +1,24487 @@
+00000400 A __kernel_vsyscall
+00000410 A SYSENTER_RETURN
+00000420 A __kernel_sigreturn
+00000440 A __kernel_rt_sigreturn
+00100000 A phys_startup_32
+c0100000 T _text
+c0100000 T startup_32
+c0101000 T _stext
+c0101000 t run_init_process
+c0101000 T stext
+c0101014 t init_post
+c01010f0 t try_name
+c01012b7 T name_to_dev_t
+c0101524 T calibrate_delay
+c01017c4 T hard_smp_processor_id
+c01017dc t target_cpus
+c01017e2 t check_apicid_used
+c01017e5 t check_apicid_present
+c01017eb t multi_timer_check
+c01017ee t apic_id_registered
+c01017f4 t cpu_to_logical_apicid
+c0101808 t cpu_present_to_apicid
+c010181c t ioapic_phys_id_map
+c0101849 t apicid_to_cpu_present
+c0101875 t setup_portio_remap
+c0101876 t check_phys_apicid_present
+c010187c t enable_apic_mode
+c010187d t get_apic_id
+c0101881 t mpc_oem_bus_info
+c0101882 t mpc_oem_pci_bus
+c0101883 t probe_summit
+c0101886 t send_IPI_mask
+c010188b t mpc_apic_id
+c01018d4 t setup_apic_routing
+c01018ef t phys_pkg_id
+c01018fd t apicid_to_node
+c010190a t mps_oem_check
+c01019be t acpi_madt_oem_check
+c0101a4a t init_apic_ldr
+c0101ace t cpu_mask_to_apicid
+c0101b76 t send_IPI_allbutself
+c0101b9e t send_IPI_all
+c0101bac t apic_id_registered
+c0101bb2 t check_apicid_used
+c0101bb5 t check_apicid_present
+c0101bbb t multi_timer_check
+c0101bbe t apicid_to_node
+c0101bc1 t cpu_present_to_apicid
+c0101bd5 t apicid_to_cpu_present
+c0101c00 t cpu_to_logical_apicid
+c0101c14 t ioapic_phys_id_map
+c0101c41 t setup_portio_remap
+c0101c42 t enable_apic_mode
+c0101c43 t check_phys_apicid_present
+c0101c49 t phys_pkg_id
+c0101c4e t get_apic_id
+c0101c52 t mpc_oem_bus_info
+c0101c53 t mpc_oem_pci_bus
+c0101c54 t mps_oem_check
+c0101c57 t acpi_madt_oem_check
+c0101c5a t send_IPI_mask
+c0101c5f t hp_ht_bigsmp
+c0101c84 t mpc_apic_id
+c0101ccd t setup_apic_routing
+c0101cf1 t target_cpus
+c0101d29 t probe_bigsmp
+c0101d4e t init_apic_ldr
+c0101d8a t cpu_mask_to_apicid
+c0101dac t send_IPI_allbutself
+c0101dd4 t send_IPI_all
+c0101de0 t get_apic_id
+c0101de4 t apic_id_registered
+c0101dea t target_cpus
+c0101df9 t check_apicid_used
+c0101dfc t multi_timer_check
+c0101dff t apicid_to_node
+c0101e02 t cpu_present_to_apicid
+c0101e20 t apicid_to_cpu_present
+c0101e6e t cpu_to_logical_apicid
+c0101e82 t ioapic_phys_id_map
+c0101eaf t setup_portio_remap
+c0101eb0 t phys_pkg_id
+c0101eb5 t mpc_oem_bus_info
+c0101eb6 t mpc_oem_pci_bus
+c0101eb7 t probe_es7000
+c0101eba t send_IPI_mask
+c0101ebf t mpc_apic_id
+c0101f08 t check_apicid_present
+c0101f12 t init_apic_ldr
+c0101f42 t check_phys_apicid_present
+c0101f5c t setup_apic_routing
+c0101faa t cpu_mask_to_apicid
+c0102047 t send_IPI_allbutself
+c010206f t send_IPI_all
+c010207c t get_apic_id
+c0102083 t target_cpus
+c0102089 t ioapic_phys_id_map
+c010209e t multi_timer_check
+c01020a1 t apicid_to_node
+c01020a4 t cpu_to_logical_apicid
+c01020ae t apicid_to_cpu_present
+c01020d9 t setup_portio_remap
+c01020da t cpu_mask_to_apicid
+c01020db t enable_apic_mode
+c01020dc t phys_pkg_id
+c01020e1 t mpc_oem_bus_info
+c01020e2 t mpc_oem_pci_bus
+c01020e3 t mps_oem_check
+c01020e6 t acpi_madt_oem_check
+c01020e9 t probe_default
+c01020ef t send_IPI_all
+c0102113 t send_IPI_allbutself
+c0102166 t send_IPI_mask
+c010216b t mpc_apic_id
+c01021b4 t setup_apic_routing
+c01021d8 t cpu_present_to_apicid
+c01021ee t check_apicid_used
+c01021fa t check_apicid_present
+c0102204 t check_phys_apicid_present
+c010220e t apic_id_registered
+c010222a t init_apic_ldr
+c0102264 t es7000_rename_gsi
+c01022ab T es7000_start_cpu
+c01022d8 T es7000_stop_cpu
+c0103000 T thread_saved_pc
+c010300a T disable_hlt
+c0103011 T enable_hlt
+c0103018 t poll_idle
+c010301b T dump_task_regs
+c0103106 T select_idle_routine
+c010313d T arch_align_stack
+c010316b T sys_vfork
+c010319b T sys_clone
+c01031d6 T sys_fork
+c0103206 T mwait_idle_with_hints
+c0103246 t mwait_idle
+c0103250 T release_thread
+c0103262 T kernel_thread
+c01032f4 T cpu_idle
+c0103363 T cpu_idle_wait
+c0103432 T exit_thread
+c01034d3 T flush_thread
+c010352b T dump_thread
+c010364c T sys_execve
+c01036ca T get_wchan
+c0103732 T sys_set_thread_area
+c01038d7 T sys_get_thread_area
+c0103a00 T show_regs
+c0103b8f T prepare_to_copy
+c0103bd0 T default_idle
+c0103c0f T copy_thread
+c0103dce t __switch_to_xtra
+c0103e30 T __switch_to
+c0103f5c t setup_sigcontext
+c01040e5 T sys_sigaltstack
+c01040f7 t restore_sigcontext
+c0104259 T sys_sigaction
+c0104335 T do_notify_resume
+c0104946 T sys_rt_sigreturn
+c0104a36 T sys_sigsuspend
+c0104acb T sys_sigreturn
+c0104c2c T ret_from_fork
+c0104c48 t ret_from_exception
+c0104c48 t ret_from_intr
+c0104c4f t check_userspace
+c0104c68 T resume_userspace
+c0104c80 T sysenter_entry
+c0104c87 t sysenter_past_esp
+c0104d0c T system_call
+c0104d47 t syscall_call
+c0104d52 t syscall_exit
+c0104d61 t no_singlestep
+c0104d6f t restore_all
+c0104d87 t restore_nocheck
+c0104d87 t restore_nocheck_notrace
+c0104d96 t ldt_ss
+c0104dbc t work_pending
+c0104dc1 t work_resched
+c0104dd7 t work_notifysig
+c0104df0 t work_notifysig_v86
+c0104e08 t syscall_trace_entry
+c0104e38 t syscall_exit_work
+c0104e53 t syscall_fault
+c0104e84 t syscall_badsys
+c0104e94 T irq_entries_start
+c01056d4 t common_interrupt
+c01056fc T reschedule_interrupt
+c010572c T invalidate_interrupt
+c010575c T call_function_interrupt
+c010578c T apic_timer_interrupt
+c01057bc T error_interrupt
+c01057ec T spurious_interrupt
+c010581c T thermal_interrupt
+c010584c T coprocessor_error
+c0105858 T simd_coprocessor_error
+c0105864 T device_not_available
+c0105896 t device_not_available_emulate
+c01058a8 T overflow
+c01058b4 T bounds
+c01058c0 T invalid_op
+c01058cc T coprocessor_segment_overrun
+c01058d8 T invalid_TSS
+c01058e4 T segment_not_present
+c01058f0 T stack_segment
+c01058fc T alignment_check
+c0105908 T divide_error
+c0105914 T machine_check
+c0105924 T spurious_interrupt_bug
+c0105930 T kernel_thread_helper
+c0105940 t print_trace_stack
+c0105943 T do_spurious_interrupt_bug
+c0105944 T patch_espfix_desc
+c0105a0f T set_intr_gate
+c0105a2e t print_trace_warning
+c0105a49 T math_state_restore
+c0105a78 T math_error
+c0105b66 T do_coprocessor_error
+c0105b75 t print_trace_address
+c0105b9f T dump_trace
+c0105c32 t show_trace_log_lvl
+c0105c5e t show_stack_log_lvl
+c0105d03 T show_registers
+c0105f94 T die
+c01061bc T do_iret_error
+c0106247 T do_alignment_check
+c01062d2 T do_stack_segment
+c0106337 T do_segment_not_present
+c010639c T do_invalid_TSS
+c0106401 T do_coprocessor_segment_overrun
+c0106466 T do_invalid_op
+c01064f0 T do_bounds
+c0106555 T do_overflow
+c01065ba T do_divide_error
+c0106641 T show_stack
+c010666c T show_trace
+c010667d T is_valid_bugaddr
+c01066ba T dump_stack
+c01066ce T do_simd_coprocessor_error
+c0106836 T math_emulate
+c0106878 t print_trace_warning_symbol
+c01068a4 T irq_ctx_exit
+c01068b0 T show_interrupts
+c0106b34 T irq_ctx_init
+c0106bc2 T ack_bad_irq
+c0106bf2 T do_softirq
+c0106c9b T do_IRQ
+c0106d6c t putreg
+c0106de5 t getreg
+c0106e30 t clear_singlestep
+c0106e56 T send_sigtrap
+c0106ebe T ptrace_disable
+c0106eda T arch_ptrace
+c01075d2 T do_syscall_trace
+c01076ac T rtc_cmos_read
+c01076f3 T rtc_cmos_write
+c0107742 T notify_arch_cmos_timer
+c010775d t sync_cmos_clock
+c0107954 T read_persistent_clock
+c0107a7b T timer_interrupt
+c0107aaf T profile_pc
+c0107afc T sys_iopl
+c0107b6e T sys_ioperm
+c0107cf4 T destroy_context
+c0107d40 t alloc_ldt
+c0107ee5 t write_ldt
+c010809d T sys_modify_ldt
+c01081bb t flush_ldt
+c0108241 T init_new_context
+c0108314 t i8259A_suspend
+c010832e t math_error_irq
+c010835b T init_8259A
+c01083ea t i8259A_resume
+c010840e T make_8259A_irq
+c0108449 T disable_8259A_irq
+c010848b T enable_8259A_irq
+c01084cd t i8259A_shutdown
+c01084d6 T i8259A_irq_pending
+c0108518 t mask_and_ack_8259A
+c01085e4 T kernel_execve
+c01085fc T old_select
+c010864e T sys_mmap2
+c0108705 T old_mmap
+c010876b T sys_pipe
+c010879e T sys_ipc
+c0108959 T sys_uname
+c01089a3 T sys_olduname
+c0108b48 t check_iommu
+c0108b78 t via_no_dac
+c0108ba9 T dma_release_declared_memory
+c0108bd7 T dma_free_coherent
+c0108c2a T dma_alloc_coherent
+c0108d08 T dma_mark_declared_memory_occupied
+c0108d55 T dma_declare_coherent_memory
+c0108e30 T dump_task_extended_fpu
+c0108eaa t convert_fxsr_from_user
+c0108f90 t convert_fxsr_to_user
+c01090d4 T get_fpu_cwd
+c01090f2 T get_fpu_swd
+c0109110 T get_fpu_mxcsr
+c010912d T get_fpregs
+c010916d T set_fpregs
+c01091af T get_fpxregs
+c01091f6 T set_fpxregs
+c0109248 T init_fpu
+c01092bf T mxcsr_feature_mask_init
+c0109313 T save_i387
+c010945e T restore_i387
+c010952f T kernel_fpu_begin
+c0109566 T dump_task_fpu
+c0109616 T dump_fpu
+c01096c4 T e820_any_mapped
+c0109734 t quirk_intel_irqbalance
+c0109808 t i8237A_suspend
+c010980b t i8237A_resume
+c01098ac T arch_register_cpu
+c01098bc t nop_out
+c010991d t alternatives_smp_unlock
+c0109956 T apply_alternatives
+c01099e7 T alternatives_smp_switch
+c0109afc T alternatives_smp_module_del
+c0109ba8 T alternatives_smp_module_add
+c0109cd0 t init_pit_timer
+c0109d47 t pit_next_event
+c0109d76 t pit_read
+c0109e04 T native_calculate_cpu_khz
+c0109ec9 T recalibrate_cpu_khz
+c0109ecf t read_tsc
+c0109ed2 T mark_tsc_unstable
+c0109f26 T sched_clock
+c0109f74 T idle_regs
+c0109f91 T switch_to_new_gdt
+c0109fc0 t c_start
+c0109fdd t c_next
+c0109fe8 t c_stop
+c0109fe9 t show_cpuinfo
+c010a344 t vide
+c010a348 t show
+c010a36f t store
+c010a372 t show_type
+c010a3ba t show_size
+c010a3db t show_number_of_sets
+c010a3fa t show_ways_of_associativity
+c010a41d t show_physical_line_partition
+c010a444 t show_coherency_line_size
+c010a468 t show_level
+c010a48b t show_shared_cpu_map
+c010a4c6 t free_cache_attributes
+c010a4e2 t cpuid4_cache_sysfs_exit
+c010a518 t unexpected_machine_check
+c010a534 T mcheck_init
+c010a590 t k7_machine_check
+c010a706 T amd_mcheck_init
+c010a7b8 t unexpected_thermal_interrupt
+c010a7dd T smp_thermal_interrupt
+c010a7f3 t intel_thermal_interrupt
+c010a812 t intel_machine_check
+c010aa92 T intel_p4_mcheck_init
+c010ac64 t pentium_machine_check
+c010acc0 T intel_p5_mcheck_init
+c010ad1c t intel_machine_check
+c010aeaf T intel_p6_mcheck_init
+c010af60 T winchip_mcheck_init
+c010afb6 t winchip_machine_check
+c010afd0 t therm_throt_sysdev_show_count
+c010b012 T therm_throt_process
+c010b0d4 T set_mtrr_ops
+c010b0e8 t set_mtrr
+c010b1cc t mtrr_restore
+c010b212 t mtrr_save
+c010b26e T mtrr_save_state
+c010b2a2 t mtrr_check
+c010b2ea T mtrr_del_page
+c010b43d T mtrr_del
+c010b470 T mtrr_add_page
+c010b7bb T mtrr_add
+c010b802 T mtrr_ap_init
+c010b821 t ipi_handler
+c010b878 T mtrr_attrib_to_str
+c010b88c t mtrr_close
+c010b8eb t mtrr_open
+c010b916 t mtrr_file_del
+c010b96e t mtrr_file_add
+c010ba03 t mtrr_ioctl
+c010bd45 t mtrr_write
+c010bfa5 t mtrr_seq_show
+c010c08c t get_fixed_ranges
+c010c0e1 T mtrr_save_fixed_ranges
+c010c0f3 T generic_get_free_region
+c010c143 t generic_have_wrcomb
+c010c150 T positive_have_wrcomb
+c010c156 T generic_validate_add_page
+c010c207 T mtrr_wrmsr
+c010c275 t post_set
+c010c2b8 t prepare_set
+c010c314 t print_fixed
+c010c371 T get_mtrr_state
+c010c5b7 t generic_get_mtrr
+c010c652 t generic_set_mtrr
+c010c723 t generic_set_all
+c010c974 T set_mtrr_prepare_save
+c010c9e4 T set_mtrr_cache_disable
+c010ca21 T set_mtrr_done
+c010ca88 t amd_set_mtrr
+c010cafc t amd_validate_add_page
+c010cb23 t amd_get_mtrr
+c010cb94 t cyrix_get_arr
+c010cc87 t cyrix_get_free_region
+c010cd5b t prepare_set
+c010cda1 t post_set
+c010cdce t cyrix_set_arr
+c010ceb2 t cyrix_set_all
+c010cf1c t centaur_get_free_region
+c010cf7f T mtrr_centaur_report_mcr
+c010cf8e t centaur_get_mcr
+c010cffa t centaur_set_mcr
+c010d062 t centaur_validate_add_page
+c010d0a0 t adjust_for_32bit_ctr
+c010d117 t write_watchdog_counter
+c010d162 t write_watchdog_counter32
+c010d1a2 t single_msr_rearm
+c010d1ae T lapic_watchdog_stop
+c010d1bb T lapic_adjust_nmi_hz
+c010d1e1 T lapic_wd_event
+c010d21f T lapic_watchdog_ok
+c010d22c T lapic_watchdog_init
+c010d310 T release_evntsel_nmi
+c010d366 T reserve_evntsel_nmi
+c010d3c6 T release_perfctr_nmi
+c010d41c t p4_unreserve
+c010d443 t single_msr_unreserve
+c010d45d T reserve_perfctr_nmi
+c010d4bd t p4_reserve
+c010d518 t single_msr_reserve
+c010d553 T disable_lapic_nmi_watchdog
+c010d598 T enable_lapic_nmi_watchdog
+c010d5eb T avail_to_resrv_perfctr_nmi
+c010d64a T avail_to_resrv_perfctr_nmi_bit
+c010d665 t single_msr_stop_watchdog
+c010d67c t stop_p4_watchdog
+c010d69e t setup_intel_arch_watchdog
+c010d76d t setup_k7_watchdog
+c010d7e5 t setup_p6_watchdog
+c010d86c t p6_rearm
+c010d88a t setup_p4_watchdog
+c010d966 t p4_rearm
+c010d9ac T acpi_gsi_to_irq
+c010d9b1 T acpi_register_ioapic
+c010d9b7 T acpi_unregister_ioapic
+c010d9bd T __acpi_release_global_lock
+c010d9da T __acpi_map_table
+c010da68 T __acpi_acquire_global_lock
+c010da8e T acpi_register_gsi
+c010dac8 W mach_reboot_fixups
+c010dac9 t native_machine_halt
+c010daca T machine_power_off
+c010dad1 T machine_shutdown
+c010dad8 t native_machine_power_off
+c010daed T machine_emergency_restart
+c010daf4 t native_machine_restart
+c010dafe T machine_restart
+c010db05 T machine_halt
+c010db0c T machine_real_restart
+c010dbaf t native_machine_shutdown
+c010dc04 t native_machine_emergency_restart
+c010dd18 T safe_smp_processor_id
+c010dd60 t native_smp_send_reschedule
+c010dd7b t stop_this_cpu
+c010dda6 T unlock_ipi_call_lock
+c010ddb0 T lock_ipi_call_lock
+c010ddba T flush_tlb_all
+c010ddd7 T native_flush_tlb_others
+c010de6a T __send_IPI_shortcut
+c010de9c T send_IPI_self
+c010dea8 t do_flush_tlb_all
+c010deff t native_smp_send_stop
+c010df87 T send_IPI_mask_sequence
+c010e001 t native_smp_call_function_mask
+c010e100 T smp_call_function_interrupt
+c010e154 T smp_reschedule_interrupt
+c010e165 T smp_invalidate_interrupt
+c010e1d5 T flush_tlb_page
+c010e249 T flush_tlb_current_task
+c010e287 T flush_tlb_mm
+c010e2fb T send_IPI_mask_bitmask
+c010e38c T cpu_coregroup_map
+c010e3b0 t map_cpu_to_logical_apicid
+c010e3d9 T __cpu_disable
+c010e3df T __cpu_die
+c010e3e3 T initialize_secondary
+c010e3f8 T smp_call_function_single
+c010e45f T smp_call_function
+c010e480 t mp_find_ioapic
+c010e4c1 T mp_register_gsi
+c010e634 t modern_apic
+c010e666 T apic_wait_icr_idle
+c010e67c T get_physical_broadcast
+c010e68e T lapic_get_maxlvt
+c010e6ac t __setup_APIC_LVTT
+c010e71f t lapic_timer_setup
+c010e768 t lapic_timer_broadcast
+c010e77a T setup_profiling_timer
+c010e780 T clear_local_APIC
+c010e8df T disable_local_APIC
+c010e928 T setup_local_APIC
+c010ebb7 t setup_APIC_timer
+c010ebff T setup_secondary_APIC_clock
+c010ec01 T lapic_shutdown
+c010ec26 t lapic_next_event
+c010ec37 T safe_apic_wait_icr_idle
+c010ec6b T smp_error_interrupt
+c010eccc t lapic_suspend
+c010ed91 t lapic_resume
+c010ef63 T smp_spurious_interrupt
+c010efa8 T disconnect_bsp_APIC
+c010f034 T smp_apic_timer_interrupt
+c010f0b4 T enable_NMI_through_LVT0
+c010f0dc t __acpi_nmi_disable
+c010f0ed T __trigger_all_cpu_backtrace
+c010f119 T proc_nmi_enabled
+c010f1d6 T do_nmi_callback
+c010f214 T touch_nmi_watchdog
+c010f248 T stop_apic_nmi_watchdog
+c010f288 t lapic_nmi_suspend
+c010f2a9 T setup_apic_nmi_watchdog
+c010f31c t lapic_nmi_resume
+c010f334 T acpi_nmi_disable
+c010f360 T acpi_nmi_enable
+c010f38c t __acpi_nmi_enable
+c010f3a0 t io_apic_base
+c010f3bf t __ioapic_write_entry
+c010f3e8 t __modify_IO_APIC_irq
+c010f442 t __unmask_IO_APIC_irq
+c010f44b t find_irq_entry
+c010f498 t ack_apic
+c010f4a9 t unmask_lapic_irq
+c010f4bf t pin_2_irq
+c010f5a7 t MPBIOS_trigger
+c010f662 T IO_APIC_get_PCI_irq_vector
+c010f770 t unmask_IO_APIC_irq
+c010f795 t mask_IO_APIC_irq
+c010f7c1 t ioapic_write_entry
+c010f807 t ioapic_read_entry
+c010f868 t ioapic_suspend
+c010f890 t clear_IO_APIC_pin
+c010f8e8 t clear_IO_APIC
+c010f911 t add_pin_to_irq
+c010f967 t __assign_irq_vector
+c010f9f0 t assign_irq_vector
+c010fa1a t ioapic_register_intr
+c010fad0 T io_apic_set_pci_routing
+c010fc36 t ioapic_retrigger_irq
+c010fc48 t set_ioapic_affinity_irq
+c010fce0 t startup_ioapic_irq
+c010fd28 T arch_setup_ht_irq
+c010fdd4 T destroy_irq
+c010fdfa T arch_teardown_msi_irq
+c010fdff T create_irq
+c010fe71 T arch_setup_msi_irq
+c010ff40 t setup_nmi
+c010ff87 T disable_IO_APIC
+c0110010 t mask_lapic_irq
+c0110026 t ack_ioapic_irq
+c011003c t ack_ioapic_quirk_irq
+c01100c2 t ioapic_resume
+c011015a t set_msi_irq_affinity
+c01101d5 t set_ht_irq_affinity
+c011023c T machine_kexec_prepare
+c011023f T machine_kexec_cleanup
+c0110240 T machine_kexec
+c0111000 T relocate_kernel
+c0111064 t relocate_new_kernel
+c011108f t identity_mapped
+c0111118 T machine_crash_shutdown
+c01111b5 t crash_nmi_callback
+c0111234 T copy_oldmem_page
+c01112d8 T module_frob_arch_sections
+c01112db T module_arch_cleanup
+c01112eb T apply_relocate_add
+c011130d T apply_relocate
+c01113a2 T module_free
+c01113a9 T module_alloc
+c01113b5 T module_finalize
+c01114fc W arch_vma_name
+c0111517 T get_gate_vma
+c011153d T in_gate_area
+c011155d T in_gate_area_no_task
+c0111560 T enable_sep_cpu
+c01115b2 T arch_setup_additional_pages
+c01116d4 T is_available_memory
+c01116ff t virt_efi_get_time
+c0111718 t virt_efi_set_time
+c011172c t virt_efi_get_wakeup_time
+c011174c t virt_efi_set_wakeup_time
+c011176b t virt_efi_get_variable
+c011179d t virt_efi_get_next_variable
+c01117bd t virt_efi_set_variable
+c01117ef t virt_efi_get_next_high_mono_count
+c0111803 t virt_efi_reset_system
+c011182d T efi_mem_type
+c0111897 T efi_mem_attributes
+c0111906 t efi_call_phys_prelog
+c0111980 T efi_set_rtc_mmss
+c01119bf t efi_call_phys_epilog
+c0111a17 T efi_get_time
+c0111aa1 T efi_memmap_walk
+c0111bb4 T efi_call_phys
+c0111c20 t doublefault_fn
+c0111d04 T release_vm86_irqs
+c0111d58 t irq_handler
+c0111dce t copy_vm86_regs_from_user
+c0111dff t do_sys_vm86
+c0111fba T save_v86_state
+c01120f4 t do_int
+c011229a T handle_vm86_trap
+c0112380 T sys_vm86old
+c01123f5 T sys_vm86
+c0112611 T handle_vm86_fault
+c0112d10 t early_serial_putc
+c0112d42 t early_serial_write
+c0112d70 t simnow
+c0112d8c t simnow_write
+c0112da6 T early_printk
+c0112dee t early_vga_write
+c0112ef8 T is_hpet_enabled
+c0112f1a t hpet_start_counter
+c0112f44 t hpet_enable_int
+c0112f5f t read_hpet
+c0112f6e T hpet_rtc_timer_init
+c011300c T hpet_mask_rtc_irq_bit
+c0113028 T hpet_set_rtc_irq_bit
+c011305a T hpet_set_alarm_time
+c0113096 T hpet_set_periodic_freq
+c011310c T hpet_rtc_dropped_irq
+c0113111 t hpet_resume
+c011312f T hpet_rtc_interrupt
+c011327b t hpet_suspend
+c011328e t hpet_set_mode
+c0113339 t hpet_next_event
+c0113368 T free_init_pages
+c01133ed T free_initrd_mem
+c01133fb T free_initmem
+c011340f T mark_rodata_ro
+c0113463 t do_test_wp_bit
+c011347d T zap_low_mappings
+c0113497 T page_is_ram
+c0113574 T __set_fixmap
+c01135e3 T check_pgt_cache
+c0113600 T pgd_free
+c0113618 T pte_alloc_one_kernel
+c0113624 T pgd_alloc
+c0113666 T pgd_dtor
+c01136a1 T pgd_ctor
+c0113713 T pte_alloc_one
+c0113724 T reserve_top_address
+c0113763 T set_pmd_pfn
+c01137a4 T pmd_ctor
+c01137ab T show_mem
+c01139b0 T vmalloc_sync_all
+c0113aa0 t __is_prefetch
+c0113cc8 t force_sig_info_fault
+c0113cf0 T unregister_page_fault_notifier
+c0113cfc T register_page_fault_notifier
+c0113d14 T iounmap
+c0113def T __ioremap
+c0113ed1 T ioremap_nocache
+c0113f48 T fixup_exception
+c0113f68 T lookup_address
+c0113faf t flush_kernel_map
+c0113fe3 T global_flush_tlb
+c011407a t set_pmd_pte
+c01140bf T change_page_attr
+c0114344 T arch_pick_mmap_layout
+c01143e0 T kmap_atomic_pfn
+c011441d T kmap_atomic_to_page
+c0114477 T kmap_atomic_prot
+c01144fd T kmap_atomic
+c0114508 T kunmap
+c0114546 T kunmap_atomic
+c01145a9 T kmap
+c01145fd t static_prio_timeslice
+c011462c T task_curr
+c011464d T weighted_cpuload
+c0114662 t __wake_up_common
+c01146b7 T __wake_up_locked
+c01146d8 T task_prio
+c01146e3 T task_nice
+c01146ee T idle_cpu
+c011470d T idle_task
+c0114722 T sys_sched_get_priority_max
+c011474b T sys_sched_get_priority_min
+c0114774 t touch_cache
+c0114817 t cpu_to_cpu_group
+c0114832 t sched_smt_power_savings_show
+c0114853 t sched_mc_power_savings_show
+c0114874 t sd_degenerate
+c01148ac t schedstat_open
+c0114922 t init_sched_build_groups
+c01149f0 t find_busiest_queue
+c0114a5b t find_busiest_group
+c0114f93 T nr_iowait
+c0114fd2 T nr_context_switches
+c0115018 T nr_running
+c0115054 T nr_onhold
+c0115093 t show_schedstat
+c0115307 T nr_active
+c0115356 T nr_uninterruptible
+c011539c t resched_task
+c01153f5 t effective_prio
+c01154c2 t recalc_task_prio
+c0115555 t set_load_weight
+c01155e3 T complete_all
+c011562c T complete
+c0115674 T __wake_up_sync
+c01156c5 T __wake_up
+c0115708 t double_rq_lock
+c011573e t task_rq_lock
+c0115796 t double_rq_unlock
+c01157b6 t dequeue_task
+c01157e6 t __deactivate_task
+c0115809 t __setscheduler
+c01158fe t requeue_task
+c0115931 t enqueue_task
+c0115974 T set_user_nice
+c0115a45 T rt_mutex_setprio
+c0115ad3 t task_running_tick
+c0115d55 t __activate_task
+c0115d7e T __might_sleep
+c0115e2f t domain_distance
+c0115ed7 t double_lock_balance
+c0115f1f t move_tasks
+c0116255 T in_sched_functions
+c0116283 t cpu_to_phys_group
+c01162bf t cpu_to_core_group
+c01162f9 t init_sched_groups_power
+c01163b2 t cpu_attach_domain
+c0116461 T sched_create_sysfs_power_savings_entries
+c011649e t sched_balance_self
+c01166d3 t migrate_task
+c011673a T sched_getaffinity
+c01167b2 T sys_sched_getaffinity
+c01167f3 T sys_sched_rr_get_interval
+c0116880 T can_nice
+c01168b2 T sched_setscheduler
+c0116af3 t do_sched_setscheduler
+c0116b55 T sys_sched_setparam
+c0116b64 T sys_sched_setscheduler
+c0116b81 t try_to_wake_up
+c0116fb6 T default_wake_function
+c0116fc2 T wake_up_state
+c0116fcd T wake_up_process
+c0116fdd t run_rebalance_domains
+c0117394 t __cond_resched
+c01173d0 T sys_sched_yield
+c011746e T set_cpus_allowed
+c01174fe t measure_one
+c0117663 t arch_init_sched_domains
+c01182e0 T arch_reinit_sched_domains
+c0118336 t sched_power_savings_store
+c0118380 t sched_smt_power_savings_store
+c011838f t sched_mc_power_savings_store
+c011839b T sched_setaffinity
+c011846b T sys_sched_setaffinity
+c01184ac T account_steal_time
+c0118518 T account_user_time
+c011859a T current_sched_time
+c01185de T account_system_time
+c01186aa T schedule_tail
+c0118739 T sched_exec
+c01187d1 T scheduler_tick
+c01188be T sys_nice
+c011895a t migration_thread
+c0118bc3 T sched_fork
+c0118c6f T show_state_filter
+c0118dcd T normalize_rt_tasks
+c0118f0c T kick_process
+c0118f3f T cond_resched_lock
+c0118f7b T wait_task_inactive
+c0118fd7 T sched_exit
+c0119050 T wake_up_new_task
+c0119236 T sys_sched_getscheduler
+c0119282 T sys_sched_getparam
+c011931a T __cleanup_signal
+c0119326 T __cleanup_sighand
+c011933d T copy_fs_struct
+c0119419 t sighand_ctor
+c0119442 t dup_fd
+c01196d7 t copy_files
+c0119728 t mm_init
+c011981f T mm_release
+c01198a6 T __mmdrop
+c01198ee T mmput
+c0119963 T free_task
+c01199b9 t copy_process
+c011ad2e T nr_processes
+c011ad65 T __put_task_struct
+c011ae43 T mm_alloc
+c011ae7f T unshare_files
+c011aebe T sys_set_tid_address
+c011aedc T do_fork
+c011b13c T sys_unshare
+c011b46d T get_task_mm
+c011b4a4 T get_exec_domain_list
+c011b520 T __set_personality
+c011b693 T unregister_exec_domain
+c011b6df T register_exec_domain
+c011b738 t default_handler
+c011b78a T sys_personality
+c011b7c8 t no_blink
+c011b7cb T add_taint
+c011b7dc T oops_may_print
+c011b7e9 t spin_msec
+c011b808 t do_oops_enter_exit
+c011b8b9 T oops_exit
+c011b8be T oops_enter
+c011b8c8 T print_tainted
+c011b9b6 T panic
+c011baa4 t __call_console_drivers
+c011baff t _call_console_drivers
+c011bb58 t emit_log_char
+c011bbb8 T is_console_locked
+c011bbbe T tty_write_message
+c011bbe8 T printk_timed_ratelimit
+c011bc18 T wake_up_klogd
+c011bc4d T release_console_sem
+c011bdea T resume_console
+c011bdf9 T acquire_console_sem
+c011be72 T unregister_console
+c011bedf T console_start
+c011bef7 T console_stop
+c011bf0f T console_device
+c011bf48 T console_unblank
+c011bfad W printk_clock
+c011bfb2 T vprintk
+c011c287 T printk
+c011c2a6 T __printk_ratelimit
+c011c346 T printk_ratelimit
+c011c356 T register_console
+c011c56e T console_print
+c011c584 T suspend_console
+c011c5a4 T do_syslog
+c011c8e1 T sys_syslog
+c011c8f2 T try_acquire_console_sem
+c011c928 T register_timer_hook
+c011c940 t __profile_flip_buffers
+c011c960 T profile_hits
+c011ca50 T create_prof_cpu_mask
+c011ca7b t write_profile
+c011cb6a t read_profile
+c011ccd9 t prof_cpu_mask_write_proc
+c011cd0b t prof_cpu_mask_read_proc
+c011cd51 T profile_tick
+c011cdaf T unregister_timer_hook
+c011cdf5 T profile_event_unregister
+c011ce15 T profile_event_register
+c011ce35 T task_handoff_unregister
+c011ce41 T task_handoff_register
+c011ce4d T profile_munmap
+c011ce5b T profile_task_exit
+c011ce69 T profile_handoff_task
+c011ce80 t will_become_orphaned_pgrp
+c011ceee t has_stopped_jobs
+c011cf14 t eligible_child
+c011cfb3 t wait_noreap_copyout
+c011d064 t delayed_put_task_struct
+c011d080 t exit_mm
+c011d157 T exit_fs
+c011d201 T put_fs_struct
+c011d279 t reparent_thread
+c011d3e0 T put_files_struct
+c011d4a3 T exit_files
+c011d4de T reset_files_struct
+c011d511 T __set_special_pids
+c011d5a1 T session_of_pgrp
+c011d5d1 T release_task
+c011d868 t do_wait
+c011e255 T sys_wait4
+c011e289 T sys_waitpid
+c011e2b4 T sys_waitid
+c011e315 T do_exit
+c011eb9c T do_group_exit
+c011ec09 T sys_exit_group
+c011ec16 T sys_exit
+c011ec23 T complete_and_exit
+c011ec36 T is_current_pgrp_orphaned
+c011ec6a T disallow_signal
+c011ecc9 T daemonize
+c011ef10 T allow_signal
+c011ef88 T get_files_struct
+c011efb4 t itimer_get_remtime
+c011efe0 T do_setitimer
+c011f2d3 T sys_setitimer
+c011f352 T alarm_setitimer
+c011f3b0 T do_getitimer
+c011f51c T sys_getitimer
+c011f55b T it_real_fn
+c011f570 T current_kernel_time
+c011f5a7 T jiffies_to_msecs
+c011f5a8 T jiffies_to_usecs
+c011f5af T timespec_trunc
+c011f5dc T mktime
+c011f65a T set_normalized_timespec
+c011f67e T msecs_to_jiffies
+c011f68b T timespec_to_jiffies
+c011f6e2 T timeval_to_jiffies
+c011f73a T jiffies_to_timeval
+c011f76b T jiffies_to_clock_t
+c011f79f T clock_t_to_jiffies
+c011f7af T jiffies_64_to_clock_t
+c011f7f2 T nsec_to_clock_t
+c011f81f T get_jiffies_64
+c011f852 T ns_to_timespec
+c011f8bd T ns_to_timeval
+c011f8e9 T sys_adjtimex
+c011f934 T sys_stime
+c011f975 T do_sys_settimeofday
+c011fa1c T sys_settimeofday
+c011fa8d T sys_gettimeofday
+c011fae0 T sys_time
+c011fb0e T jiffies_to_timespec
+c011fb2c T current_fs_time
+c011fb74 T usecs_to_jiffies
+c011fb98 T open_softirq
+c011fba7 T tasklet_init
+c011fbc2 T on_each_cpu
+c011fbe9 T raise_softirq_irqoff
+c011fc38 T tasklet_kill
+c011fc86 T _local_bh_enable
+c011fd2a T __local_bh_enable
+c011fddd T local_bh_enable
+c011fe66 T local_bh_enable_ip
+c011fea6 T irq_exit
+c011fedc t ksoftirqd
+c011ff63 T __do_softirq
+c0120024 T irq_enter
+c0120033 t tasklet_action
+c01200c3 t tasklet_hi_action
+c0120153 T local_bh_disable
+c0120162 T raise_softirq
+c01201b8 T __tasklet_schedule
+c0120221 T __tasklet_hi_schedule
+c012028c t r_next
+c01202a9 t __request_resource
+c0120323 t devm_region_match
+c012035e t iomem_open
+c0120384 t ioports_open
+c01203aa t r_show
+c012043d t r_stop
+c0120447 t r_start
+c0120499 T adjust_resource
+c012055a T insert_resource
+c01206a9 T allocate_resource
+c012083b T release_resource
+c0120880 T request_resource
+c01208b2 T __release_region
+c01209b1 T __devm_release_region
+c0120a37 t devm_region_release
+c0120a5d T __request_region
+c0120aed T __devm_request_region
+c0120b7e T __check_region
+c0120bc0 t sysctl_set_parent
+c0120bea t fixup_table_addr
+c0120c0a t table_fixup
+c0120c7c t count_table_entries
+c0120ca7 t copy_table_entries
+c0120cf6 t do_proc_dointvec_conv
+c0120d25 t do_proc_dointvec_bset_conv
+c0120d74 t do_proc_dointvec_minmax_conv
+c0120dcb t do_proc_dointvec_jiffies_conv
+c0120e2c T sysctl_intvec
+c0120eab T sysctl_jiffies
+c0120f44 T sysctl_string
+c012101f T sysctl_data
+c01210bb t do_proc_doulongvec_minmax
+c0121373 T proc_doulongvec_ms_jiffies_minmax
+c01213a8 T proc_doulongvec_minmax
+c01213dd t __do_proc_dointvec
+c012168c t proc_do_cad_pid
+c0121710 t do_proc_dointvec
+c0121756 T proc_dointvec_ms_jiffies
+c012178b T proc_dointvec_userhz_jiffies
+c01217c0 T proc_dointvec_jiffies
+c01217f5 T proc_dointvec_minmax
+c012183a T proc_dointvec
+c012186f T proc_dostring
+c0121984 t proc_dointvec_taint
+c01219ea T proc_dointvec_bset
+c0121a5f T sysctl_ms_jiffies
+c0121af0 t do_proc_dointvec_ms_jiffies_conv
+c0121b35 t do_proc_dointvec_userhz_jiffies_conv
+c0121b8c t sysctl_net_init
+c0121be3 t __register_sysctl_table
+c0121c4c T register_net_sysctl_table
+c0121c87 T register_sysctl_table
+c0121c93 T unregister_sysctl_table
+c0121d12 T unregister_net_sysctl_table
+c0121d17 T sysctl_perm
+c0121d57 T do_sysctl_strategy
+c0121e0f t unuse_table
+c0121e29 T sysctl_head_next
+c0121eae T sysctl_head_finish
+c0121ed3 T do_sysctl
+c0121fdc T sys_sysctl
+c0122038 T __capable
+c0122053 T capable
+c0122060 T sys_capget
+c0122168 T sys_capset
+c0122430 T ptrace_get_task_struct
+c0122479 T ptrace_traceme
+c01224c9 T ptrace_request
+c01226b9 T ptrace_writedata
+c0122751 T ptrace_readdata
+c01227eb t may_attach
+c01228f4 T ptrace_may_attach
+c012291f T ptrace_check_attach
+c01229bf T ptrace_untrace
+c0122a0a T __ptrace_unlink
+c0122a87 T ptrace_detach
+c0122ada T __ptrace_link
+c0122b3d T ptrace_attach
+c0122c22 T sys_ptrace
+c0122cd8 T __round_jiffies
+c0122d1e T __round_jiffies_relative
+c0122d34 T round_jiffies
+c0122d40 T round_jiffies_relative
+c0122d4c T init_timer
+c0122d65 T init_timer_deferrable
+c0122d73 t internal_add_timer
+c0122e00 t cascade
+c0122e4f t run_timer_softirq
+c0122fac T do_sysinfo
+c01230dd T sys_sysinfo
+c0123107 t process_timeout
+c012310c T sys_alarm
+c0123115 T do_timer
+c01231ba T run_local_timers
+c01231c9 t lock_timer_base
+c01231fe T try_to_del_timer_sync
+c0123248 T del_timer_sync
+c012325c T __mod_timer
+c01232f8 T msleep
+c012330a T msleep_interruptible
+c0123338 T update_process_times
+c0123396 T sys_getppid
+c01233d7 T sys_getuid
+c01233e4 T sys_geteuid
+c01233f1 T sys_getgid
+c01233fe T sys_getegid
+c012340b T sys_gettid
+c0123418 T mod_timer
+c0123437 T del_timer
+c012347e T add_timer_on
+c01234ca T sys_getpid
+c0123504 T free_uid
+c0123544 T switch_uid
+c012358d T find_user
+c01235ff T alloc_uid
+c012372c T next_signal
+c012375b T unhandled_signal
+c0123787 T do_no_restart_syscall
+c0123790 T do_sigpending
+c0123825 T sys_sigpending
+c0123833 T sys_rt_sigpending
+c0123840 t recalc_sigpending_tsk
+c01238a0 T recalc_sigpending
+c01238bd T sigprocmask
+c012397a t sig_ignored
+c01239c6 t __sigqueue_free
+c01239f5 t rm_from_queue
+c0123a50 t rm_from_queue_full
+c0123ab6 t __dequeue_signal
+c0123bd2 T flush_sigqueue
+c0123c01 t check_kill_permission
+c0123cc3 T lock_task_sighand
+c0123cff T flush_signals
+c0123d4b T ignore_signals
+c0123d72 t __sigqueue_alloc
+c0123dcb t send_signal
+c0123ec3 T copy_siginfo_to_user
+c0124045 T signal_wake_up
+c0124071 t __group_complete_signal
+c012428e T __group_send_sig_info
+c012430d t do_notify_parent_cldstop
+c012440b t finish_stop
+c012446f t ptrace_stop
+c01245b7 t handle_stop_signal
+c0124736 T send_group_sigqueue
+c0124805 T do_notify_parent
+c0124965 T group_send_sig_info
+c01249bb T send_group_sig_info
+c01249eb T kill_pid_info
+c0124a67 T kill_pid
+c0124a7b T kill_proc_info
+c0124ad4 T sys_rt_sigqueueinfo
+c0124b22 T kill_proc
+c0124b36 T __kill_pgrp_info
+c0124b85 T kill_pgrp_info
+c0124bb5 T kill_pgrp
+c0124bc9 t specific_send_sig_info
+c0124c5a t do_tkill
+c0124d24 T sys_tkill
+c0124d3d T sys_tgkill
+c0124d5c T send_sig_info
+c0124dc4 T send_sig
+c0124dd6 T recalc_sigpending_and_wake
+c0124dee T do_sigaction
+c0124f3b T sys_signal
+c0124f78 T sys_rt_sigaction
+c0124fef T force_sig_info
+c0125072 T force_sig
+c012507e T force_sigsegv
+c01250c8 T force_sig_specific
+c01250d4 T dequeue_signal
+c01251f3 T sys_restart_syscall
+c0125202 T block_all_signals
+c0125260 T unblock_all_signals
+c01252b7 T sigqueue_alloc
+c01252d2 T sigqueue_free
+c0125322 T ptrace_notify
+c01253b0 T get_signal_to_deliver
+c0125794 T sys_kill
+c01258c0 T do_sigaltstack
+c01259b9 T sys_sgetmask
+c01259c6 T sys_ssetmask
+c0125a24 T sys_pause
+c0125a3b T sys_rt_sigsuspend
+c0125b03 T flush_signal_handlers
+c0125b3e T sys_rt_sigprocmask
+c0125bf7 T sys_sigprocmask
+c0125cfe T sys_rt_sigtimedwait
+c0125f63 T kill_pid_info_as_uid
+c0126024 T zap_other_threads
+c012608a T send_sigqueue
+c012614c t notifier_chain_register
+c012616b t notifier_chain_unregister
+c012618a T raw_notifier_chain_register
+c012618c T raw_notifier_chain_unregister
+c012618e T __raw_notifier_call_chain
+c0126195 T raw_notifier_call_chain
+c01261af T groups_search
+c0126205 T sys_getcpu
+c012627a t argv_cleanup
+c012627f T getrusage
+c01263fa T __blocking_notifier_call_chain
+c0126441 T blocking_notifier_call_chain
+c012645b T groups_free
+c012648e T set_current_groups
+c01265d4 T groups_alloc
+c012668b t set_user
+c012670f T ctrl_alt_del
+c0126736 T blocking_notifier_chain_unregister
+c0126770 T unregister_reboot_notifier
+c012677c T blocking_notifier_chain_register
+c01267b6 T register_reboot_notifier
+c01267c2 T kernel_shutdown_prepare
+c01267e8 t kernel_restart_prepare
+c0126808 T kernel_power_off
+c0126827 T orderly_poweroff
+c01268cc T kernel_halt
+c01268eb T kernel_restart
+c0126922 t deferred_cad
+c0126929 T emergency_restart
+c012692e t set_one_prio
+c01269d0 T srcu_init_notifier_head
+c01269fb T __srcu_notifier_call_chain
+c0126a4a T srcu_notifier_call_chain
+c0126a64 T srcu_notifier_chain_register
+c0126a9e T srcu_notifier_chain_unregister
+c0126ae0 T atomic_notifier_chain_register
+c0126b09 T atomic_notifier_chain_unregister
+c0126b37 T sys_setgroups
+c0126c11 T sys_reboot
+c0126de4 T sys_getresuid
+c0126e21 T sys_getresgid
+c0126e5e T sys_setfsgid
+c0126ec6 T sys_times
+c0126f9b T sys_setsid
+c0127046 T sys_getgroups
+c01270ed T in_group_p
+c012710e T in_egroup_p
+c012712f T sys_setrlimit
+c0127332 T sys_getrusage
+c0127353 T sys_umask
+c012736d T sys_prctl
+c0127492 T sys_getpgrp
+c01274a5 T sys_getsid
+c01274f8 T sys_newuname
+c012753b T sys_sethostname
+c0127603 T sys_gethostname
+c0127672 T sys_setdomainname
+c0127740 T sys_setregid
+c012782b T sys_setgid
+c01278d2 T sys_setresgid
+c01279d0 T sys_setfsuid
+c0127a50 T sys_setpgid
+c0127c13 T sys_getpgid
+c0127cd9 T sys_getrlimit
+c0127d51 T sys_old_getrlimit
+c0127ded T sys_setreuid
+c0127f32 T sys_setuid
+c0127ff7 T sys_setresuid
+c0128156 T sys_setpriority
+c0128317 T sys_getpriority
+c01284c4 T call_usermodehelper_setkeys
+c01284c8 T call_usermodehelper_setcleanup
+c01284cc T call_usermodehelper_stdinpipe
+c0128505 T call_usermodehelper_setup
+c0128548 t __call_usermodehelper
+c0128593 T call_usermodehelper_freeinfo
+c01285ad T call_usermodehelper_exec
+c012863a T call_usermodehelper_pipe
+c012867a t wait_for_helper
+c01286ef T request_module
+c01287d9 t ____call_usermodehelper
+c01288f8 T keventd_up
+c0128905 T current_is_keventd
+c0128931 t wq_per_cpu
+c0128944 t try_to_grab_pending
+c01289a7 t run_workqueue
+c0128aa4 t insert_work
+c0128af7 t insert_wq_barrier
+c0128b37 t flush_cpu_workqueue
+c0128b99 T destroy_workqueue
+c0128c1a t wq_barrier_func
+c0128c22 t init_cpu_workqueue
+c0128c53 t create_workqueue_thread
+c0128c9f t start_workqueue_thread
+c0128cbc T __create_workqueue
+c0128dd5 t __queue_work
+c0128dfd T delayed_work_timer_fn
+c0128e19 T queue_work
+c0128e55 T schedule_work
+c0128e61 T execute_in_process_context
+c0128e99 t wait_on_work
+c0128f37 T cancel_rearming_delayed_work
+c0128f63 T flush_workqueue
+c0128fb1 T flush_scheduled_work
+c0128fbb T queue_delayed_work_on
+c0129055 T schedule_delayed_work_on
+c012906a T queue_delayed_work
+c0129088 T schedule_delayed_work
+c0129096 T cancel_work_sync
+c01290b6 T schedule_on_each_cpu
+c012913f t worker_thread
+c0129204 T find_pid
+c012923d T attach_pid
+c0129263 T transfer_pid
+c01292ae T pid_task
+c01292d6 T get_pid_task
+c01292e4 T find_get_pid
+c01292f1 T free_pid_ns
+c01292f6 T copy_pid_ns
+c012930c T find_ge_pid
+c012937f T put_pid
+c012939f t delayed_put_pid
+c01293a7 T free_pid
+c012940b T detach_pid
+c0129453 T find_task_by_pid_type
+c01294e0 T alloc_pid
+c0129712 T get_task_pid
+c0129724 T rcu_batches_completed
+c012972a T rcu_batches_completed_bh
+c0129730 t __rcu_pending
+c0129764 T rcu_pending
+c01297a2 T rcu_needs_cpu
+c01297dc t rcu_init_percpu_data
+c012982e t wakeme_after_rcu
+c0129836 t rcu_barrier_callback
+c012984f t rcu_start_batch
+c0129888 t __rcu_process_callbacks
+c01299fa t rcu_process_callbacks
+c0129a28 t force_quiescent_state
+c0129a7d T call_rcu
+c0129ac7 T synchronize_rcu
+c0129af6 t rcu_barrier_func
+c0129b1d T call_rcu_bh
+c0129b67 T rcu_check_callbacks
+c0129bec T rcu_barrier
+c0129c58 T core_kernel_text
+c0129c81 T kernel_text_address
+c0129ca4 T __kernel_text_address
+c0129cc7 T search_exception_tables
+c0129cec T param_set_bool
+c0129d32 T param_set_invbool
+c0129d75 T param_array_get
+c0129dd7 t param_attr_show
+c0129e0d t param_attr_store
+c0129e2a t module_attr_show
+c0129e48 t module_attr_store
+c0129e71 t uevent_filter
+c0129e8d T param_set_copystring
+c0129ef8 t param_sysfs_setup
+c0129fc0 T module_param_sysfs_setup
+c0129fe7 T module_param_sysfs_remove
+c012a013 T param_get_string
+c012a020 T param_array_set
+c012a0ff T param_get_bool
+c012a128 T param_get_invbool
+c012a162 T param_get_charp
+c012a182 T param_get_ulong
+c012a1a2 T param_get_long
+c012a1c2 T param_get_uint
+c012a1e2 T param_get_int
+c012a202 T param_get_ushort
+c012a223 T param_get_short
+c012a244 T param_get_byte
+c012a265 T param_set_ulong
+c012a294 T param_set_uint
+c012a2c3 T param_set_ushort
+c012a2f8 T param_set_byte
+c012a32e T param_set_long
+c012a35d T param_set_int
+c012a38c T param_set_short
+c012a3c1 T param_set_charp
+c012a41e T parse_args
+c012a618 T do_posix_clock_nosettime
+c012a61e T do_posix_clock_nonanosleep
+c012a624 t posix_ktime_get_ts
+c012a62e T clock_nanosleep_restart
+c012a657 T sys_clock_nanosleep
+c012a714 t release_posix_timer
+c012a776 T exit_itimers
+c012a830 t lock_timer
+c012a8ab t common_timer_get
+c012a9a5 T register_posix_clock
+c012a9d4 T posix_timer_event
+c012ab05 T sys_timer_create
+c012adee T sys_clock_settime
+c012ae6b T sys_clock_gettime
+c012aee9 T sys_clock_getres
+c012af69 T do_schedule_next_timer
+c012b012 t posix_timer_fn
+c012b0a4 T sys_timer_gettime
+c012b11b T sys_timer_getoverrun
+c012b148 T sys_timer_settime
+c012b397 T sys_timer_delete
+c012b480 T kthread_should_stop
+c012b493 T kthread_stop
+c012b4ff T kthread_bind
+c012b55c T kthreadd
+c012b661 T kthread_create
+c012b705 t kthread
+c012b764 T bit_waitqueue
+c012b7ac T __wake_up_bit
+c012b7df T wake_up_bit
+c012b7f5 T autoremove_wake_function
+c012b82a T wake_bit_function
+c012b866 T finish_wait
+c012b8ae T prepare_to_wait_exclusive
+c012b8f0 T add_wait_queue_exclusive
+c012b91b T prepare_to_wait
+c012b95a T add_wait_queue
+c012b982 T remove_wait_queue
+c012b9a4 T init_waitqueue_head
+c012b9c4 T kfifo_free
+c012b9d6 T kfifo_init
+c012ba29 T kfifo_alloc
+c012ba9c T __kfifo_put
+c012bb0f T __kfifo_get
+c012bb88 W compat_sys_futex
+c012bb88 W compat_sys_get_mempolicy
+c012bb88 W compat_sys_get_robust_list
+c012bb88 W compat_sys_ipc
+c012bb88 W compat_sys_kexec_load
+c012bb88 W compat_sys_keyctl
+c012bb88 W compat_sys_mbind
+c012bb88 W compat_sys_migrate_pages
+c012bb88 W compat_sys_move_pages
+c012bb88 W compat_sys_mq_getsetattr
+c012bb88 W compat_sys_mq_notify
+c012bb88 W compat_sys_mq_open
+c012bb88 W compat_sys_mq_timedreceive
+c012bb88 W compat_sys_mq_timedsend
+c012bb88 W compat_sys_set_mempolicy
+c012bb88 W compat_sys_set_robust_list
+c012bb88 W compat_sys_signalfd
+c012bb88 W compat_sys_socketcall
+c012bb88 W compat_sys_sysctl
+c012bb88 W compat_sys_timerfd
+c012bb88 W ppc_rtas
+c012bb88 W sys32_ipc
+c012bb88 W sys32_sysctl
+c012bb88 W sys_add_key
+c012bb88 W sys_get_mempolicy
+c012bb88 W sys_keyctl
+c012bb88 W sys_mbind
+c012bb88 W sys_migrate_pages
+c012bb88 W sys_move_pages
+c012bb88 W sys_nfsservctl
+c012bb88 T sys_ni_syscall
+c012bb88 W sys_pciconfig_iobase
+c012bb88 W sys_pciconfig_read
+c012bb88 W sys_pciconfig_write
+c012bb88 W sys_request_key
+c012bb88 W sys_set_mempolicy
+c012bb88 W sys_spu_create
+c012bb88 W sys_spu_run
+c012bb88 W sys_timerfd
+c012bb90 t bump_cpu_timer
+c012bcc0 t cleanup_timers
+c012bd8b T posix_cpu_timers_exit
+c012bdbd T posix_cpu_timers_exit_group
+c012be0d t process_cpu_nsleep_restart
+c012be13 t thread_cpu_nsleep
+c012be19 t thread_cpu_nsleep_restart
+c012be1f t process_timer_rebalance
+c012bfa0 t sample_to_timespec
+c012bfd3 t cpu_clock_sample_group_locked
+c012c0bf T set_process_cpu_timer
+c012c173 t cpu_clock_sample
+c012c1c8 t clear_dead_task
+c012c210 t cpu_clock_sample_group
+c012c255 t arm_timer
+c012c485 T posix_cpu_timer_schedule
+c012c587 t cpu_timer_fire
+c012c5d7 T run_posix_cpu_timers
+c012ccc4 T posix_cpu_timer_set
+c012d07a T posix_cpu_timer_create
+c012d160 t thread_cpu_timer_create
+c012d16c t process_cpu_timer_create
+c012d178 t do_cpu_nanosleep
+c012d2b7 T posix_cpu_nsleep_restart
+c012d33e T posix_cpu_nsleep
+c012d3f0 t process_cpu_nsleep
+c012d3fa T posix_cpu_clock_get
+c012d4de t thread_cpu_clock_get
+c012d4e8 t process_cpu_clock_get
+c012d4f2 t check_clock
+c012d564 T posix_cpu_clock_set
+c012d574 T posix_cpu_clock_getres
+c012d5a2 t thread_cpu_clock_getres
+c012d5ac t process_cpu_clock_getres
+c012d5b6 T posix_cpu_timer_get
+c012d79c T posix_cpu_timer_del
+c012d83c t __mutex_trylock_slowpath
+c012d871 T __mutex_init
+c012d898 T ktime_divns
+c012d90d T hrtimer_init
+c012d94a T hrtimer_init_sleeper
+c012d955 T hrtimer_get_res
+c012d97f T hrtimer_forward
+c012da4d t hrtimer_wakeup
+c012da65 t __remove_hrtimer
+c012da8c t enqueue_hrtimer
+c012dafe T hrtimer_run_queues
+c012dc49 t lock_hrtimer_base
+c012dc78 T hrtimer_get_remaining
+c012dcac T hrtimer_try_to_cancel
+c012dd0d T hrtimer_cancel
+c012dd21 T hrtimer_start
+c012ddff T hrtimer_nanosleep
+c012dedb T sys_nanosleep
+c012df34 T ktime_get_real
+c012df55 T ktime_get_ts
+c012df9b T ktime_get
+c012dfbc T down_read_trylock
+c012dfd9 T down_write_trylock
+c012dff4 T up_read
+c012e003 T up_write
+c012e014 T downgrade_write
+c012e023 T down_write
+c012e04b T down_read
+c012e06c T system_latency_constraint
+c012e072 T unregister_latency_notifier
+c012e07e T register_latency_notifier
+c012e08a T synchronize_acceptable_latency
+c012e09c T remove_acceptable_latency
+c012e141 T set_acceptable_latency
+c012e234 T modify_acceptable_latency
+c012e2a0 t create_new_namespaces
+c012e3e3 T free_nsproxy
+c012e448 T copy_nsproxy
+c012e4a1 T unshare_nsproxy_namespaces
+c012e51d T get_task_namespaces
+c012e52b T copy_namespaces
+c012e5b4 T srcu_read_lock
+c012e5ce T srcu_read_unlock
+c012e5e1 T srcu_batches_completed
+c012e5e4 t srcu_readers_active_idx
+c012e61f T synchronize_srcu
+c012e673 T srcu_readers_active
+c012e693 T cleanup_srcu_struct
+c012e6e1 T init_srcu_struct
+c012e720 T unregister_die_notifier
+c012e72c T register_die_notifier
+c012e741 T notify_die
+c012e778 T free_uts_ns
+c012e784 T copy_utsname
+c012e7e8 T sys_vserver
+c012f51c T vx_mask_cap_bset
+c012f538 T vx_set_init
+c012f557 T vx_exit_init
+c012f565 T vx_set_persistent
+c012f572 t do_get_caps
+c012f59b t do_set_caps
+c012f5fe T vc_set_badness
+c012f62e T vc_set_bcaps
+c012f692 T vc_set_ccaps
+c012f6f2 T vc_get_badness
+c012f721 T vc_get_bcaps
+c012f769 T vc_get_ccaps
+c012f7b1 T vc_get_cflags
+c012f7f8 T vc_ctx_stat
+c012f827 T vc_vx_info
+c012f856 T xid_is_hashed
+c012f8a7 t __dealloc_vx_info
+c012fa08 T vx_set_reaper
+c012fa36 T vx_migrate_user
+c012fa97 T free_vx_info
+c012fb0f T unhash_vx_info
+c012fc1b T vx_clear_persistent
+c012fc58 T vx_update_persistent
+c012fc7f T vx_migrate_task
+c012fed1 T get_xid_list
+c012ff6c T vc_task_xid
+c012ffb4 T vc_ctx_migrate
+c0130039 T vc_set_cflags
+c0130160 T lookup_vx_info
+c01301d5 T exit_vx_info
+c0130222 T exit_vx_info_early
+c013025c T vc_ctx_create
+c0130838 T vc_get_space_mask
+c0130854 T vs_mix_nsproxy
+c013091f T vx_set_space
+c0130a87 T vc_set_space
+c0130ac7 T vx_enter_space
+c0130c43 T vc_enter_space
+c0130c84 T vx_update_sched_param
+c0130d00 t do_set_sched
+c0130f15 T vc_set_sched
+c0130f44 T vc_set_sched_v4
+c0130fc2 T vx_tokens_recalc
+c013110f T vc_get_sched
+c013121e T vc_sched_info
+c01312d4 T nx_set_persistent
+c01312e1 T vc_set_ncaps
+c0131334 T vc_get_ncaps
+c0131374 T vc_get_nflags
+c01313bb T vc_nx_info
+c01313e2 T vc_net_remove_ipv6
+c013143e T do_add_v6_addr
+c01314e1 T vc_net_add_ipv6
+c0131546 T do_add_v4_addr
+c01315e6 T vc_net_add_ipv4
+c0131675 T vc_net_add
+c013171b T nid_is_hashed
+c013176c T unhash_nx_info
+c01317d2 T __nx_set_lback
+c01317e5 t __dealloc_nx_info
+c0131839 T free_nx_info
+c013185c T nx_clear_persistent
+c0131899 T nx_update_persistent
+c01318c0 T vc_set_nflags
+c013197c T nx_migrate_task
+c0131a97 T vc_net_migrate
+c0131aa4 T vc_net_remove_ipv4
+c0131b00 T get_nid_list
+c0131b9c T vc_task_nid
+c0131be4 T lookup_nx_info
+c0131c59 T vc_net_remove
+c0131cb5 T vc_net_create
+c0131ee0 t __vc_get_iattr
+c0131fe5 t __dx_parse_remove
+c0132015 T dx_parse_tag
+c01320f9 T vc_fget_iattr
+c013218a t __vc_set_iattr
+c0132360 T vc_fset_iattr
+c01323f1 T vc_set_iattr
+c0132480 T vc_get_iattr
+c0132518 T vc_reset_minmax
+c0132537 T vx_badness
+c01325cc T vc_set_rlimit
+c0132665 T vc_rlimit_stat
+c013279d T vc_get_rlimit_mask
+c01327b9 T vc_get_rlimit
+c0132839 T vx_vsi_meminfo
+c01328e2 T vx_vsi_swapinfo
+c01329a8 T vx_idle_jiffies
+c01329b6 t vx_vhi_name
+c01329fe T vc_virt_stat
+c0132ad1 T vc_get_vhi_name
+c0132b30 T vc_set_vhi_name
+c0132b77 T vx_vsi_uptime
+c0132bbf T vx_do_syslog
+c0132c98 T vx_update_load
+c0132e84 T vc_sock_stat
+c0132f1c T vc_wait_exit
+c0132fdf T vx_info_kill
+c01330c9 T vc_ctx_kill
+c0133124 t do_vshelper
+c013318d T vs_net_change
+c0133274 T vs_state_change
+c013335b T vs_reboot_helper
+c0133527 T vs_reboot
+c013359c T locate_dl_info
+c01335df T vx_vsi_statfs
+c01337c7 T vc_get_dlimit
+c01338fb T vc_set_dlimit
+c0133ab2 t __dealloc_dl_info
+c0133adf t do_addrem_dlimit
+c0133ce8 T vc_rem_dlimit
+c0133d24 T vc_add_dlimit
+c0133d60 T rcu_free_dl_info
+c0133da4 T dx_migrate_task
+c0133dd3 T vc_tag_migrate
+c0133de4 T vc_task_tag
+c0133e2c T nx_v4_addr_conflict
+c0133ebf T nx_v6_addr_conflict
+c0133f56 T v6_dev_in_nx_info
+c0134021 T v4_dev_in_nx_info
+c0134102 T dev_in_nx_info
+c0134145 T ip_v4_find_src
+c01343e4 T proc_nxi_status
+c0134427 t proc_virtnet_status
+c0134452 T proc_vxi_status
+c01344aa T proc_vxi_info
+c01344e3 t proc_virtual_status
+c0134540 t proc_vci
+c0134577 t proc_virtnet_info
+c0134579 t proc_virtual_info
+c013457b T proc_vxi_limit
+c0134b54 T proc_vxi_cacct
+c0134cd2 T proc_pid_vx_info
+c0134dc5 T proc_vx_init
+c0134e0c t proc_virtnet_getattr
+c0134e28 t proc_virtual_getattr
+c0134e44 t proc_fill_cache
+c0134f4e t vs_proc_instantiate
+c0135005 t proc_nid_instantiate
+c0135013 t proc_virtnet_lookup
+c01350a2 t proc_xid_instantiate
+c01350b0 T proc_virtnet_readdir
+c0135282 T proc_vxi_cvirt
+c013538e T proc_vxi_sched
+c013555b T proc_vxi_nsproxy
+c0135700 T proc_nxi_info
+c0135a72 T proc_pid_nx_info
+c0135ef5 t proc_nid_revalidate
+c0135f63 t proc_vs_info_read
+c0136009 t proc_xid_lookup
+c0136052 t proc_nid_lookup
+c013609b t proc_virtual_lookup
+c013612a t proc_xid_readdir
+c013625a t proc_nid_readdir
+c013638a T proc_virtual_readdir
+c013655c t proc_xid_revalidate
+c01365ca t proc_nx_info_read
+c013669c t proc_vx_info_read
+c0136770 T timekeeping_is_continuous
+c01367a2 T monotonic_to_bootbased
+c01367ab T getboottime
+c01367c6 T do_gettimeofday
+c013689c T update_wall_time
+c0136f4d t timekeeping_suspend
+c0136f97 T do_settimeofday
+c0137087 t timekeeping_resume
+c0137129 T getnstimeofday
+c01371e8 t ntp_update_frequency
+c0137295 T ntp_clear
+c01372ea T current_tick_length
+c01372f7 T do_adjtimex
+c01377e9 T second_overflow
+c01379fc t select_clocksource
+c0137a23 T clocksource_get_next
+c0137a62 t sysfs_show_available_clocksources
+c0137acd t sysfs_show_current_clocksources
+c0137b21 t clocksource_enqueue
+c0137bae T clocksource_change_rating
+c0137bec T clocksource_register
+c0137d69 T clocksource_resume
+c0137daf t sysfs_override_clocksource
+c0137e9b t clocksource_watchdog
+c0138108 t jiffies_read
+c0138110 t timer_list_open
+c013811e t print_name_offset
+c013818f t print_tickdevice
+c0138429 t timer_list_show
+c01388d5 T sysrq_timer_list_show
+c01388e0 T clockevent_delta2ns
+c013894e T clockevents_set_mode
+c0138966 T clockevents_program_event
+c0138a09 t clockevents_handle_noop
+c0138a0a t clockevents_do_notify
+c0138a18 T clockevents_notify
+c0138a55 t clockevents_notify_released
+c0138a89 T clockevents_exchange_device
+c0138adb T clockevents_release_device
+c0138b01 T clockevents_request_device
+c0138b67 T clockevents_register_device
+c0138ba4 T clockevents_unregister_notifier
+c0138bc8 T clockevents_register_notifier
+c0138bf4 T tick_get_device
+c0138c03 T tick_is_oneshot_available
+c0138c26 T tick_setup_periodic
+c0138cb6 t tick_notify
+c0138f3f t tick_periodic
+c0138fac T tick_handle_periodic
+c0139014 T tick_get_broadcast_device
+c013901a T tick_get_broadcast_mask
+c0139020 T tick_is_broadcast_device
+c0139034 T tick_set_periodic_handler
+c0139047 t tick_broadcast_start_periodic
+c013905c T tick_resume_broadcast
+c01390af T tick_device_uses_broadcast
+c01390fb T tick_suspend_broadcast
+c0139131 t tick_do_broadcast_on_off
+c0139209 T tick_do_broadcast
+c013926a t tick_do_periodic_broadcast
+c013928e t tick_handle_periodic_broadcast
+c01392e9 T tick_broadcast_on_off
+c013934a T tick_check_broadcast_device
+c013938c T tick_shutdown_broadcast
+c01393d8 t hash_futex
+c0139462 T get_futex_key_refs
+c013948e t futex_poll
+c01394bd t futexfs_get_sb
+c01394d1 t wake_futex
+c0139516 t futex_handle_fault
+c01395b3 T drop_futex_key_refs
+c01395e9 t unqueue_me
+c013966d t futex_close
+c0139686 T get_futex_key
+c01397a8 t futex_lock_pi
+c013a0c5 t futex_wait
+c013a379 t futex_requeue
+c013a5ad t futex_wake
+c013a660 T do_futex
+c013b026 T sys_futex
+c013b0fa T handle_futex_death
+c013b180 T exit_pi_state_list
+c013b28e t futex_wait_restart
+c013b2c9 T sys_set_robust_list
+c013b2e9 T sys_get_robust_list
+c013b371 T exit_robust_list
+c013b428 t rt_mutex_set_owner
+c013b43e t fixup_rt_mutex_waiters
+c013b44d T rt_mutex_proxy_unlock
+c013b453 T rt_mutex_getprio
+c013b478 T rt_mutex_next_owner
+c013b499 T __rt_mutex_init
+c013b4c6 T rt_mutex_init_proxy_locked
+c013b4e0 T rt_mutex_destroy
+c013b519 t __rt_mutex_adjust_prio
+c013b532 t try_to_take_rt_mutex
+c013b65c t rt_mutex_adjust_prio
+c013b683 T rt_mutex_timed_lock
+c013b6d0 t rt_mutex_adjust_prio_chain
+c013b95f T rt_mutex_adjust_pi
+c013b9b7 t rt_mutex_slowtrylock
+c013b9f0 t proc_dma_open
+c013b9fe t proc_dma_show
+c013ba3e T free_dma
+c013ba75 T request_dma
+c013baa4 T in_lock_functions
+c013babc T sys_setfsgid16
+c013bad8 T sys_setfsuid16
+c013baf4 T sys_setresgid16
+c013bb34 T sys_setresuid16
+c013bb74 T sys_setuid16
+c013bb90 T sys_setreuid16
+c013bbbd T sys_setgid16
+c013bbd9 T sys_setregid16
+c013bc06 T sys_fchown16
+c013bc3c T sys_lchown16
+c013bc72 T sys_chown16
+c013bca8 T sys_setgroups16
+c013bd74 T sys_getresuid16
+c013bdfe T sys_getresgid16
+c013be88 T sys_getgroups16
+c013bf52 T sys_getuid16
+c013bf74 T sys_geteuid16
+c013bf96 T sys_getgid16
+c013bfb8 T sys_getegid16
+c013bfdc t find_sec
+c013c023 t lookup_symbol
+c013c052 t find_module
+c013c093 t modinfo_version_exists
+c013c0a1 t modinfo_srcversion_exists
+c013c0af T module_refcount
+c013c0c8 t get_offset
+c013c0ee t get_modinfo
+c013c172 t get_ksymbol
+c013c34c t mod_find_symname
+c013c3a3 t m_next
+c013c3b8 t taint_flags
+c013c3e6 T __module_text_address
+c013c442 t m_show
+c013c5ae t m_stop
+c013c5b8 T print_modules
+c013c61c t printk_unused_warning
+c013c64a t __find_symbol
+c013c834 t percpu_modinit
+c013c899 t free_sect_attrs
+c013c8bf t free_modinfo_srcversion
+c013c8d9 t free_modinfo_version
+c013c8f3 t make_driver_name
+c013c957 T module_remove_driver
+c013c9b0 t module_sect_show
+c013c9ce t show_initstate
+c013ca18 t show_modinfo_srcversion
+c013ca39 t show_modinfo_version
+c013ca5a T module_add_driver
+c013cae2 T module_text_address
+c013cb0c T __symbol_get
+c013cb77 t percpu_modfree
+c013cc2a t setup_modinfo_srcversion
+c013cc41 t setup_modinfo_version
+c013cc58 t __link_module
+c013cc68 t __unlink_module
+c013cc73 T mod_sysfs_init
+c013cce3 T module_remove_modinfo_attrs
+c013cd1d T module_add_modinfo_attrs
+c013cd95 T mod_sysfs_setup
+c013ce23 T module_put
+c013ce4a T __symbol_put
+c013ce96 t module_unload_free
+c013cf00 t free_module
+c013cfaa T sys_init_module
+c013e617 T symbol_put_addr
+c013e63a T __module_put_and_exit
+c013e649 T unregister_module_notifier
+c013e655 T register_module_notifier
+c013e661 T module_get_kallsym
+c013e738 T module_kallsyms_lookup_name
+c013e7ae t m_start
+c013e7ea T search_module_extables
+c013e852 T is_module_address
+c013e8bb T module_address_lookup
+c013e942 T lookup_module_symbol_name
+c013e9eb T lookup_module_symbol_attrs
+c013eacb t __try_stop_module
+c013eb0a t show_refcnt
+c013eb41 T sys_delete_module
+c013ed7c t kallsyms_expand_symbol
+c013edf4 t get_symbol_offset
+c013ee24 t get_symbol_pos
+c013eee8 t reset_iter
+c013ef08 t s_stop
+c013ef09 t s_show
+c013efc2 t update_iter
+c013f07c t s_start
+c013f099 t s_next
+c013f0c6 t kallsyms_open
+c013f118 t is_ksym_addr
+c013f131 T lookup_symbol_attrs
+c013f19b T lookup_symbol_name
+c013f1d8 T kallsyms_lookup
+c013f259 T sprint_symbol
+c013f306 T __print_symbol
+c013f330 T kallsyms_lookup_size_offset
+c013f371 T kallsyms_lookup_name
+c013f3c4 T pm_valid_only_mem
+c013f3ce W arch_suspend_disable_irqs
+c013f3d0 W arch_suspend_enable_irqs
+c013f3d2 t state_show
+c013f435 T suspend_enter
+c013f492 t enter_state
+c013f601 T pm_suspend
+c013f618 T pm_set_ops
+c013f636 t state_store
+c013f71c t thaw_tasks
+c013f7ff T thaw_processes
+c013f832 t cancel_freezing
+c013f879 t try_to_freeze_tasks
+c013fafa T freeze_processes
+c013fb51 T refrigerator
+c013fc18 T pm_restore_console
+c013fc37 T pm_prepare_console
+c013fca0 t pm_send
+c013fcfb T pm_send_all
+c013fd8b T pm_register
+c013fddc t pm_sysrq_init
+c013fdee t handle_poweroff
+c013fdf8 t do_poweroff
+c013fe00 t acct_timeout
+c013fe0b t encode_comp_t
+c013fe3d T acct_init_pacct
+c013fe5f t do_acct_process
+c0140426 T acct_process
+c014046e t acct_file_reopen
+c014053a T acct_auto_close
+c014056a T acct_auto_close_mnt
+c0140597 T sys_acct
+c014068e T acct_collect
+c01407cc T kexec_should_crash
+c01407fe t kimage_is_destination_range
+c0140839 T crash_save_cpu
+c01409d0 t do_kimage_alloc
+c0140b18 t kimage_alloc_pages
+c0140b76 t kimage_alloc_page
+c0140d04 t kimage_add_entry
+c0140d72 t kimage_free_pages
+c0140d9c t kimage_free_entry
+c0140daa t kimage_free_page_list
+c0140dd0 t kimage_free
+c0140e6e T kimage_alloc_control_pages
+c0140fc4 T sys_kexec_load
+c01414d4 T crash_kexec
+c0141584 T container_is_removed
+c014158a T container_is_releasable
+c0141599 T notify_on_release
+c01415a2 t container_file_release
+c01415ba t container_advance_iter
+c01415e9 T container_iter_next
+c014161d t cmppid
+c0141622 t container_read_releasable
+c014162b T container_fork_callbacks
+c0141655 t containerstats_open
+c0141663 t container_open
+c0141676 T container_lock
+c0141680 T container_set_release_agent_path
+c01416aa T container_unlock
+c01416b4 t container_tasks_release
+c01416d3 t get_first_subsys
+c014170f T container_is_descendant
+c014175b t init_container_root
+c01417ac t check_for_release
+c0141827 t pid_array_to_buf
+c014187d t container_get_dentry
+c01418bd t allocate_cg_links
+c014190f t unlink_css_group
+c014195d t rebind_subsystems
+c0141abf t attach_task
+c0141e06 T container_exit
+c0141e8c t parse_containerfs_options
+c0141f4f t container_tasks_read
+c0141f79 t container_common_file_read
+c014202a t container_clear_directory
+c01420ac t container_rename
+c01420f3 t container_new_inode
+c0142164 t container_create_file
+c0142201 T container_add_file
+c0142256 T container_add_files
+c0142280 t container_populate_dir
+c01422ee t container_remount
+c0142360 t container_mkdir
+c0142523 T container_iter_start
+c0142543 t container_init_subsys
+c0142646 T container_iter_end
+c0142650 T container_task_count
+c0142682 T container_path
+c01426f0 t container_release_agent
+c01427ca t container_fill_super
+c014285e t container_show_options
+c01428ab t proc_containerstats_show
+c0142a02 t container_put_super
+c0142abe t container_rmdir
+c0142c3e t container_get_sb
+c0142e4f t container_diput
+c0142e80 t release_css_group
+c0142ec9 t release_css_group_taskexit
+c0142f22 t container_read_notify_on_release
+c0142f2c T css_put
+c0142f6c t container_file_write
+c0142fb2 t container_file_read
+c0143042 t container_file_open
+c0143078 t container_common_file_write
+c0143232 t container_tasks_open
+c0143395 t proc_container_show
+c01434f2 T container_fork
+c0143537 T container_clone
+c0143794 t cpuacct_populate
+c01437a5 t cpuusage_update
+c0143892 t load_read
+c01438f6 t cpuacct_create
+c0143992 T cpuacct_charge
+c01439e1 t cpuacct_destroy
+c01439e9 t cpuusage_read
+c0143a48 t ns_can_attach
+c0143a95 t ns_destroy
+c0143a9d t ns_create
+c0143af9 T ns_container_clone
+c0143b04 t stopmachine_set_state
+c0143b25 T __stop_machine_run
+c0143bcc T stop_machine_run
+c0143bde t stopmachine
+c0143c6a t do_stop
+c0143d78 t write_enabled_file_bool
+c0143eb5 t read_enabled_file_bool
+c0143ef8 t kexec_crash_loaded_show
+c0143f1f t kexec_loaded_show
+c0143f46 t uevent_helper_show
+c0143f65 t uevent_seqnum_show
+c0143f92 t uevent_helper_store
+c0143fe4 t softlock_panic
+c0143ff1 t get_timestamp
+c0143ffe T touch_softlockup_watchdog
+c0144017 T softlockup_tick
+c01440e7 T touch_all_softlockup_watchdogs
+c014411a t watchdog
+c0144164 t noop
+c0144165 t noop_ret
+c0144168 T no_action
+c014416b t ack_bad
+c014435a T handle_IRQ_event
+c0144399 T __do_IRQ
+c014444c T handle_bad_irq
+c014463c T synchronize_irq
+c0144658 T irq_can_set_affinity
+c0144671 T can_request_irq
+c01446b0 T compat_irq_chip_set_default_handler
+c01446bf T set_irq_wake
+c014477f T disable_irq_nosync
+c01447cc T disable_irq
+c01447f3 T free_irq
+c01448ef T setup_irq
+c0144a78 T request_irq
+c0144b10 T enable_irq
+c0144bb2 T irq_set_affinity
+c0144bdc T noirqdebug_setup
+c0144bfc t __report_bad_irq
+c0144c71 T note_interrupt
+c0144e50 T check_irq_resend
+c0144e90 t default_enable
+c0144eab t default_disable
+c0144eac t default_startup
+c0144ebd T irq_chip_set_defaults
+c0144f0b T __set_irq_handler
+c0145044 T set_irq_chip_data
+c0145099 T set_irq_msi
+c01450f3 T set_irq_data
+c0145140 T set_irq_type
+c01451b9 T handle_percpu_irq
+c014520e T handle_edge_irq
+c014530d T handle_fasteoi_irq
+c01453b8 T handle_simple_irq
+c0145458 T set_irq_chip
+c01454e6 T set_irq_chip_and_handler_name
+c0145508 T set_irq_chip_and_handler
+c014552c T dynamic_irq_cleanup
+c01455f6 T dynamic_irq_init
+c01456b6 T handle_level_irq
+c0145774 t devm_irq_match
+c014578c t devm_irq_release
+c0145798 T devm_free_irq
+c01457f9 T devm_request_irq
+c0145870 T probe_irq_off
+c01458e6 T probe_irq_mask
+c0145956 T probe_irq_on
+c0145a6c T unregister_handler_proc
+c0145a85 T register_irq_proc
+c0145b25 T init_irq_proc
+c0145b4f t irq_affinity_write_proc
+c0145bc8 t irq_affinity_read_proc
+c0145c17 T register_handler_proc
+c0145d00 T move_masked_irq
+c0145d5f T move_native_irq
+c0145d95 T set_pending_irq
+c0145dcc t relay_file_mmap_close
+c0145de0 T relay_mmap_buf
+c0145e24 T relay_buf_empty
+c0145e31 T relay_buf_full
+c0145e44 t buf_mapped_default_callback
+c0145e45 t buf_unmapped_default_callback
+c0145e46 t create_buf_file_default_callback
+c0145e49 t remove_buf_file_default_callback
+c0145e4f T relay_subbufs_consumed
+c0145e73 t relay_file_mmap
+c0145e7e t relay_file_read_consume
+c0145f1b t subbuf_send_actor
+c0145f9c t relay_file_read_subbufs
+c01461ca t relay_file_sendfile
+c0146206 t relay_file_read
+c0146242 t relay_file_release
+c0146258 t relay_file_open
+c0146275 t subbuf_read_actor
+c01462a9 t relay_close_buf
+c01462cb T relay_close
+c014636c T relay_switch_subbuf
+c0146452 T relay_flush
+c01464b7 T relay_destroy_channel
+c01464bf t __relay_reset
+c014654d T relay_reset
+c01465b2 t wakeup_readers
+c01465d0 T relay_destroy_buf
+c0146629 T relay_remove_buf
+c0146643 T relay_create_buf
+c01467dd T relay_open
+c0146a43 t relay_buf_nopage
+c0146a96 t relay_file_poll
+c0146ad0 t subbuf_start_default_callback
+c0146ae4 t get_uts
+c0146b06 t put_uts
+c0146b1e t sysctl_uts_string
+c0146bab t proc_do_uts_string
+c0146c14 t page_waitqueue
+c0146c42 t shrink_readahead_size_eio
+c0146c50 T file_send_actor
+c0146ca3 T generic_segment_checks
+c0146d32 T __filemap_copy_from_user_iovec_inatomic
+c0146d85 T generic_write_checks
+c0146f59 T __remove_suid
+c0146f6d T should_remove_suid
+c0146fb4 T remove_suid
+c0146fce T generic_file_mmap
+c014700c T generic_file_readonly_mmap
+c0147026 T sys_readahead
+c01470be T file_read_actor
+c0147199 T find_get_pages_tag
+c0147219 T find_get_page
+c0147260 T __lock_page_nosync
+c01472be T __lock_page
+c014731c t __sleep_on_page_lock
+c0147324 t sync_page
+c0147365 T unlock_page
+c0147388 T find_lock_page
+c014740b T end_page_writeback
+c0147447 T wait_on_page_bit
+c01474ad T add_to_page_cache
+c0147523 T add_to_page_cache_lru
+c014754b T read_cache_page_async
+c0147687 t page_cache_read
+c0147727 T filemap_populate
+c014798e T filemap_fault
+c0147c2d T filemap_nopage
+c0147c65 T do_generic_mapping_read
+c01480f1 T generic_file_sendfile
+c0148151 T grab_cache_page_nowait
+c01481cd T wait_on_page_writeback_range
+c01482c5 T filemap_fdatawait
+c014830f T __filemap_fdatawrite_range
+c014837f T filemap_write_and_wait_range
+c01483f0 t filemap_fdatawrite_range
+c0148417 T sync_page_range_nolock
+c01484b3 T sync_page_range
+c0148582 T filemap_fdatawrite
+c01485a9 T filemap_write_and_wait
+c01485d2 t generic_file_direct_IO
+c01486e8 T generic_file_direct_write
+c0148821 T generic_file_buffered_write
+c0148dee t __generic_file_aio_write_nolock
+c01492d1 T generic_file_aio_write
+c0149387 T generic_file_aio_write_nolock
+c0149419 T filemap_flush
+c0149440 T __remove_from_page_cache
+c014946a T remove_from_page_cache
+c0149495 T read_cache_page
+c01494d4 T try_to_release_page
+c0149516 T find_get_pages
+c0149576 T find_get_pages_contig
+c01495e6 T find_or_create_page
+c014966c T generic_file_aio_read
+c0149804 T mempool_free_pages
+c0149809 t remove_element
+c0149821 t add_element
+c014983e T mempool_alloc_pages
+c014986f T mempool_kfree
+c0149874 t free_pool
+c014989c T mempool_destroy
+c01498ae T mempool_kzalloc
+c01498b9 T mempool_alloc_slab
+c01498c4 T mempool_kmalloc
+c01498cf T mempool_free_slab
+c01498da T mempool_free
+c0149946 T mempool_alloc
+c0149a17 T mempool_create_node
+c0149ad6 T mempool_create
+c0149af2 T mempool_resize
+c0149c44 T out_of_memory
+c0149c92 T badness
+c0149e10 T sys_fadvise64_64
+c0149fa7 T sys_fadvise64
+c0149fe4 T split_page
+c014a00c T zone_watermark_ok
+c014a0b2 t nr_free_zone_pages
+c014a0e4 T nr_free_buffer_pages
+c014a0eb T nr_free_pagecache_pages
+c014a0f2 T zone_init_free_lists
+c014a11c T setup_pageset
+c014a18f T set_pageblock_flags_group
+c014a1eb t calculate_totalreserve_pages
+c014a258 t setup_per_zone_lowmem_reserve
+c014a303 T lowmem_reserve_ratio_sysctl_handler
+c014a32f T percpu_pagelist_fraction_sysctl_handler
+c014a3d9 T setup_per_zone_pages_min
+c014a4d6 T min_free_kbytes_sysctl_handler
+c014a50a T mark_free_pages
+c014a58b t bad_page
+c014a619 t destroy_compound_page
+c014a698 t __rmqueue
+c014a75d t __free_pages_ok
+c014a9a7 t free_compound_page
+c014a9c3 t free_pages_bulk
+c014ab46 t free_hot_cold_page
+c014ac74 T __pagevec_free
+c014ac96 T free_cold_page
+c014aca0 T free_hot_page
+c014aca7 T __free_pages
+c014acc7 T free_pages
+c014ace2 t get_page_from_freelist
+c014afae T __alloc_pages
+c014b245 T __get_free_pages
+c014b27f T get_zeroed_page
+c014b2b9 T drain_local_pages
+c014b33d T si_meminfo
+c014b3ad T show_free_areas
+c014b6d4 T get_pageblock_flags_group
+c014b73c t __writepage
+c014b75d T mapping_tagged
+c014b78f T set_page_dirty
+c014b7e1 T clear_page_dirty_for_io
+c014b846 T set_page_dirty_lock
+c014b880 T __set_page_dirty_nobuffers
+c014b93b T redirty_page_for_writepage
+c014b945 T write_cache_pages
+c014bbd0 T generic_writepages
+c014bbf6 T do_writepages
+c014bc26 T laptop_io_completion
+c014bc3c t laptop_timer_fn
+c014bc48 t wb_timer_fn
+c014bc6f T writeback_set_ratelimit
+c014bcc4 T laptop_sync_completion
+c014bcce t laptop_flush
+c014bcd3 T dirty_writeback_centisecs_handler
+c014bd21 t get_dirty_limits
+c014be3b T balance_dirty_pages_ratelimited_nr
+c014bfc9 T __set_page_dirty_no_writeback
+c014bfd9 T throttle_vm_writeout
+c014c052 t background_writeout
+c014c0ed T wakeup_pdflush
+c014c117 t wb_kupdate
+c014c1f6 T test_set_page_writeback
+c014c2b0 T set_page_dirty_balance
+c014c2ea T test_clear_page_writeback
+c014c382 T write_one_page
+c014c440 t start_one_pdflush_thread
+c014c472 t pdflush
+c014c611 T pdflush_operation
+c014c698 T default_unplug_io_fn
+c014c699 T file_ra_state_init
+c014c6a9 T handle_ra_miss
+c014c6bd t __do_page_cache_readahead
+c014c88b t blockable_page_cache_readahead
+c014c92a t make_ahead_window
+c014c9c3 T page_cache_readahead
+c014cb67 T do_page_cache_readahead
+c014cbb0 T force_page_cache_readahead
+c014cc1b T read_cache_pages
+c014ccbe T max_sane_readahead
+c014cce4 T vm_acct_memory
+c014cd10 T pagevec_lookup_tag
+c014cd3b t put_compound_page
+c014cd5f T release_pages
+c014ce79 T __pagevec_lru_add_active
+c014cf0a T __pagevec_lru_add
+c014cf96 T lru_add_drain
+c014cfcd T lru_add_drain_all
+c014cfd5 T activate_page
+c014d054 T put_page
+c014d0db T put_pages_list
+c014d0fd T rotate_reclaimable_page
+c014d1a1 T mark_page_accessed
+c014d1d1 T __pagevec_release
+c014d1ee T __pagevec_release_nonlru
+c014d23d T pagevec_strip
+c014d27c T pagevec_lookup
+c014d29e T lru_cache_add_active
+c014d2df T lru_cache_add
+c014d320 T do_invalidatepage
+c014d338 T invalidate_inode_pages2_range
+c014d559 T invalidate_inode_pages2
+c014d563 T cancel_dirty_page
+c014d58d t truncate_complete_page
+c014d5cc T truncate_inode_pages_range
+c014d8ac T truncate_inode_pages
+c014d8c6 T invalidate_mapping_pages
+c014d998 t count_lru_pages
+c014d9b2 T kswapd_run
+c014da28 T raise_kswapd_order
+c014da50 t isolate_lru_pages
+c014dadb t shrink_active_list
+c014de4c T wakeup_kswapd
+c014debc T remove_mapping
+c014df71 t shrink_inactive_list
+c014e666 t shrink_zone
+c014e758 T shrink_slab
+c014e890 T remove_shrinker
+c014e8b7 T set_shrinker
+c014e90c T shrink_all_memory
+c014eb93 T try_to_free_pages
+c014ed7d t kswapd
+c014f18c T vma_prio_tree_add
+c014f207 T vma_prio_tree_insert
+c014f231 T vma_prio_tree_next
+c014f271 T vma_prio_tree_remove
+c014f338 T kmemdup
+c014f36b T __kzalloc
+c014f39f T kstrdup
+c014f3e1 T kstrndup
+c014f429 T strndup_user
+c014f480 T first_online_pgdat
+c014f486 T next_online_pgdat
+c014f489 T next_zone
+c014f4a8 T vm_events_fold_cpu
+c014f4da t frag_stop
+c014f4db t vmstat_next
+c014f506 t vmstat_show
+c014f532 t vmstat_stop
+c014f546 T all_vm_events
+c014f5ac t vmstat_start
+c014f612 t frag_next
+c014f620 t frag_start
+c014f646 T refresh_cpu_vm_stats
+c014f6b6 t __refresh_cpu_vm_stats
+c014f6c1 t refresh_zone_stat_thresholds
+c014f747 t start_cpu_timer
+c014f786 t vmstat_update
+c014f7aa T refresh_vm_stats
+c014f7c4 T __dec_zone_state
+c014f82a T __dec_zone_page_state
+c014f83f T __inc_zone_state
+c014f89e T __mod_zone_page_state
+c014f8ed T dec_zone_page_state
+c014f8fa T mod_zone_page_state
+c014f907 T inc_zone_state
+c014f914 T inc_zone_page_state
+c014f931 t frag_show
+c014f9e7 T __inc_zone_page_state
+c014f9fc t zoneinfo_show
+c014fc7c T set_bdi_congested
+c014fc8a T congestion_end
+c014fcba T congestion_wait
+c014fd1e T congestion_wait_interruptible
+c014fd9a T clear_bdi_congested
+c014fdd8 t zap_pte
+c014fe4f T install_file_pte
+c014fee4 T sys_remap_file_pages
+c015012b T install_page
+c01502e8 t page_slot
+c01502fa T page_address
+c0150386 T set_page_address
+c01504a4 T kunmap_high
+c0150534 t flush_all_zero_pkmaps
+c0150593 T kmap_high
+c01506ee T kmap_flush_unused
+c0150707 T nr_free_highpages
+c0150734 T sys_madvise
+c0150bb0 T vmalloc_to_page
+c0150c0a T vmalloc_to_pfn
+c0150c1f T pmd_clear_bad
+c0150c52 T pud_clear_bad
+c0150c7b T pgd_clear_bad
+c0150ca4 T print_bad_pte
+c0150cfc T vm_normal_page
+c0150d4d t __do_fault
+c015108a t do_wp_page
+c015149c T swapin_readahead
+c01514f4 T follow_page
+c015163e T unmap_vmas
+c0151b23 T zap_page_range
+c0151bed t unmap_mapping_range_vma
+c0151c83 T unmap_mapping_range
+c0151e8c T vmtruncate_range
+c0151f8a T __pte_alloc_kernel
+c0151fd4 T __pte_alloc
+c015205a T apply_to_page_range
+c01521d6 T get_locked_pte
+c015223f T vm_insert_page
+c0152328 T zeromap_page_range
+c01524a9 T copy_page_range
+c015289c T free_pgd_range
+c0152a31 t do_no_pfn
+c0152b01 T __handle_mm_fault
+c015336e T get_user_pages
+c01535f5 T access_process_vm
+c015371d T make_pages_present
+c01537ad T vmtruncate
+c01538f5 T free_pgtables
+c0153971 T vm_insert_pfn
+c01539d7 T remap_pfn_range
+c0153b40 t mincore_page
+c0153b64 T sys_mincore
+c0153e34 T user_shm_unlock
+c0153e63 T user_shm_lock
+c0153ed7 T can_do_mlock
+c0153f05 t mlock_fixup
+c015400b t do_mlockall
+c0154090 t do_mlock
+c0154158 T sys_munlock
+c01541b2 T sys_mlockall
+c01542ca T sys_munlockall
+c0154300 T sys_mlock
+c0154424 T vm_get_page_prot
+c015442f t find_vma_prepare
+c0154498 t can_vma_merge_before
+c01544de t can_vma_merge_after
+c015452d T vm_stat_account
+c015456d T arch_unmap_area
+c0154585 T arch_unmap_area_topdown
+c0154599 T find_vma
+c01545ec T arch_get_unmapped_area
+c01546d3 T find_vma_prev
+c0154728 T may_expand_vm
+c01547b6 t special_mapping_close
+c01547b7 T get_unmapped_area
+c0154829 t special_mapping_nopage
+c0154881 t unmap_region
+c015497a t remove_vma
+c01549bf T expand_stack
+c0154adf T find_extend_vma
+c0154b28 t __remove_shared_vm_struct
+c0154b6f T unlink_file_vma
+c0154ba7 T __unlink_file_vma
+c0154bb5 T __vma_link_rb
+c0154bdd t __vma_link
+c0154c2c T vma_adjust
+c0154fcf T split_vma
+c0155084 T do_munmap
+c015525a T sys_munmap
+c0155298 T vma_merge
+c0155410 t vma_link
+c01554d7 T copy_vma
+c01555f0 T insert_vm_struct
+c01556f6 T install_special_mapping
+c0155791 T do_brk
+c0155a75 T sys_brk
+c0155b42 T arch_get_unmapped_area_topdown
+c0155c69 T find_mergeable_anon_vma
+c0155d19 T exit_mmap
+c0155e77 T __vm_enough_memory
+c0155f46 T do_mmap_pgoff
+c01565c4 T sys_mprotect
+c0156a3c t move_page_tables
+c0156ca1 T do_mremap
+c0157258 T sys_mremap
+c01572ac T sys_msync
+c0157404 t page_lock_anon_vma
+c0157425 t page_unlock_anon_vma
+c015742a T page_check_address
+c01574c9 t page_referenced_one
+c015758a t page_referenced_file
+c0157622 T page_remove_rmap
+c015772c t try_to_unmap_one
+c01578c4 T try_to_unmap
+c0157ce0 T page_add_file_rmap
+c0157cfa t __page_set_anon_rmap
+c0157d25 T page_add_new_anon_rmap
+c0157d49 t anon_vma_ctor
+c0157d66 T __anon_vma_merge
+c0157d7a T anon_vma_unlink
+c0157db9 T anon_vma_link
+c0157de5 T page_add_anon_rmap
+c0157dfd T page_address_in_vma
+c0157e5d T page_referenced
+c0157f26 T page_mkclean
+c015807f T anon_vma_prepare
+c0158132 T __anon_vma_link
+c0158149 T vwrite
+c01581c8 T vread
+c0158243 t __get_vm_area_node
+c01583b9 T get_vm_area_node
+c015840a T __get_vm_area
+c015842f T get_vm_area
+c015846e T map_vm_area
+c0158594 T unmap_kernel_range
+c015866a T remove_vm_area
+c01586b4 t __vunmap
+c0158785 T vunmap
+c01587a4 T vmap
+c01587e1 T vfree
+c0158803 T __vmalloc_area_node
+c0158917 t __vmalloc_node
+c0158971 T vmalloc_node
+c0158989 T __vmalloc
+c015899a T vmalloc_32_user
+c01589df T vmalloc_32
+c01589ef T vmalloc_exec
+c01589ff T vmalloc
+c0158a0f T __vmalloc_area
+c0158a20 T vmalloc_user
+c0158a65 T remap_vmalloc_range
+c0158b2c T init_emergency_isa_pool
+c0158b79 t mempool_alloc_pages_isa
+c0158b81 T blk_queue_bounce
+c0158e0e t bounce_end_io
+c0158e8e t __bounce_end_io_read
+c0158f53 t bounce_end_io_read_isa
+c0158f6e t bounce_end_io_read
+c0158f89 t bounce_end_io_write_isa
+c0158fa4 t bounce_end_io_write
+c0158fc0 t get_swap_bio
+c015903d T swap_readpage
+c015909a T end_swap_bio_read
+c0159115 t end_swap_bio_write
+c0159190 T swap_writepage
+c0159220 T lookup_swap_cache
+c0159245 t __add_to_swap_cache
+c01592d8 T read_swap_cache_async
+c0159384 T free_pages_and_swap_cache
+c0159408 T move_to_swap_cache
+c0159462 T __delete_from_swap_cache
+c01594c8 T delete_from_swap_cache
+c01594fa T move_from_swap_cache
+c0159534 T show_swap_cache_info
+c01595ad T add_to_swap
+c0159613 T free_page_and_swap_cache
+c0159644 t swap_entry_free
+c01596a4 t swap_next
+c01596e2 T get_swap_info_struct
+c01596eb t swaps_open
+c01596f7 t swap_show
+c01597b1 t swap_stop
+c01597bb t swap_start
+c015980c T valid_swaphandles
+c0159887 T swap_duplicate
+c0159937 t swap_info_get
+c01599d2 T swap_free
+c01599f8 T map_swap_page
+c0159a3b t add_swap_extent
+c0159acd t destroy_swap_extents
+c0159aef t unuse_mm
+c0159d29 T can_share_swap_page
+c0159d85 T si_swapinfo
+c0159e0e T get_swap_page_of_type
+c0159fe7 T free_swap_and_cache
+c015a0a7 T swap_unplug_io_fn
+c015a13f T remove_exclusive_swap_page
+c015a22e T sys_swapoff
+c015a9d2 T sys_swapon
+c015b394 T get_swap_page
+c015b5e0 T __put_swap_token
+c015b60c T grab_swap_token
+c015b710 t shmem_match
+c015b764 t shmem_get_sb
+c015b775 t shmem_free_blocks
+c015b7ba t shmem_recalc_inode
+c015b7f5 t shmem_free_swp
+c015b851 t shmem_swp_map
+c015b85b t shmem_dir_map
+c015b865 t shmem_swp_entry
+c015b972 t shmem_truncate_range
+c015c00b t shmem_truncate
+c015c02b t shmem_alloc_inode
+c015c046 t shmem_parse_options
+c015c300 t shmem_remount_fs
+c015c3e7 t shmem_get_inode
+c015c586 t shmem_mknod
+c015c614 t shmem_create
+c015c624 t shmem_swp_set
+c015c64f t shmem_swp_alloc
+c015c847 t shmem_getpage
+c015cdd8 t shmem_prepare_write
+c015ce05 t shmem_fault
+c015ceb0 t shmem_unlink
+c015cf33 t do_shmem_file_read
+c015d10d t shmem_file_sendfile
+c015d158 t shmem_file_read
+c015d1d2 t shmem_mmap
+c015d1f8 t shmem_put_super
+c015d212 t init_once
+c015d21a T shmem_file_setup
+c015d38b T shmem_zero_setup
+c015d3d8 t shmem_file_write
+c015d675 t shmem_encode_fh
+c015d6dd t shmem_fill_super
+c015d877 t shmem_mkdir
+c015d896 t shmem_rmdir
+c015d8c3 t shmem_rename
+c015d95e t shmem_follow_link
+c015d9aa t shmem_get_parent
+c015d9b0 t shmem_get_dentry
+c015d9f7 t shmem_decode_fh
+c015da26 t shmem_notify_change
+c015dade T shmem_lock
+c015db47 t shmem_symlink
+c015dcc6 t shmem_follow_link_inline
+c015dcd6 t shmem_destroy_inode
+c015dce3 t shmem_delete_inode
+c015ddbb t shmem_statfs
+c015de33 t shmem_put_link
+c015de5b t shmem_link
+c015defc t shmem_writepage
+c015e034 T shmem_unuse
+c015e2a0 T slab_is_available
+c015e2ad t slab_mgmt_size
+c015e2b6 t cache_estimate
+c015e338 T kmem_cache_size
+c015e33c T kmem_cache_name
+c015e340 t s_next
+c015e35b t s_stop
+c015e365 t s_start
+c015e3e6 t start_cpu_timer
+c015e444 T ksize
+c015e490 T kmem_ptr_validate
+c015e4ef t kmem_freepages
+c015e58b t kmem_list3_init
+c015e5dc t cache_flusharray
+c015e67c T kfree
+c015e738 T kmem_cache_free
+c015e7f3 t __kmem_cache_destroy
+c015e84e t slab_destroy
+c015e88e t free_block
+c015e971 t drain_array
+c015ea26 t drain_freelist
+c015ea9e t __cache_shrink
+c015eb28 t kmem_rcu_free
+c015eb4e T kmem_cache_destroy
+c015ebe6 T kmem_cache_alloc
+c015ec37 t cache_alloc_refill
+c015f068 T __kmalloc
+c015f0e0 T krealloc
+c015f1a6 T kmem_cache_zalloc
+c015f21a t init_list
+c015f2e4 t alloc_arraycache
+c015f32d t do_tune_cpucache
+c015f560 T slabinfo_write
+c015f6ae t enable_cpucache
+c015f752 t cache_reap
+c015f840 t s_show
+c015fa5c T kmem_cache_shrink
+c015fa98 t do_drain
+c015fae1 t do_ccupdate_local
+c015fb04 T kmem_cache_create
+c015fe88 t __xip_unmap
+c015ffa0 t do_xip_mapping_read
+c0160145 T xip_file_sendfile
+c01601a5 T xip_file_mmap
+c01601e0 T xip_file_read
+c016025a T xip_file_write
+c01605e5 T xip_truncate_page
+c01606b2 t xip_file_fault
+c016081c T percpu_depopulate
+c0160836 T __percpu_depopulate_mask
+c0160863 T percpu_free
+c0160880 T percpu_populate
+c01608c8 T __percpu_populate_mask
+c016092d T __percpu_alloc_mask
+c0160984 T quicklist_total_size
+c01609cb T quicklist_trim
+c0160a64 t __put_unused_fd
+c0160a95 T generic_file_open
+c0160ae2 T nonseekable_open
+c0160aef T sys_vhangup
+c0160b1c T put_unused_fd
+c0160b4d T fd_install
+c0160b96 T filp_close
+c0160bee T get_unused_fd
+c0160cc2 t __dentry_open
+c0160e3a T dentry_open
+c0160e90 T nameidata_to_filp
+c0160ec3 t do_filp_open
+c0160efc T do_sys_open
+c0160fbf T sys_openat
+c0160fdc T sys_open
+c0160ffa T sys_creat
+c016101d T filp_open
+c0161033 T sys_fallocate
+c016112e t chown_common
+c0161229 T sys_fchown
+c0161267 T sys_fchmod
+c016131f T sys_fchmodat
+c01614aa T sys_chmod
+c01614ce T sys_lchown
+c01615f9 T sys_faccessat
+c0161739 T sys_access
+c016175c T do_truncate
+c01617d5 t do_sys_ftruncate
+c0161919 T sys_ftruncate64
+c0161936 T sys_ftruncate
+c0161951 t do_sys_truncate
+c0161b07 T sys_truncate64
+c0161b18 T sys_truncate
+c0161b2a T vfs_statfs
+c0161ba3 t vfs_statfs64
+c0161bc4 T sys_fstatfs64
+c0161c24 T sys_statfs64
+c0161ca4 t vfs_statfs_native
+c0161d6e T sys_fstatfs
+c0161dc2 T sys_statfs
+c0161e33 T sys_chdir
+c0161e87 T sys_fchdir
+c0161ef1 T sys_chroot
+c0161f5d T sys_close
+c0161ff6 T lookup_instantiate_filp
+c016205c T sys_chown
+c016218a T sys_fchownat
+c01622d0 T no_llseek
+c01622d9 T vfs_llseek
+c0162313 T iov_shorten
+c0162340 T do_loop_readv_writev
+c016238c T rw_copy_check_uvector
+c0162436 t wait_on_retry_sync_kiocb
+c0162466 T do_sync_readv_writev
+c0162564 T do_sync_write
+c016266e T do_sync_read
+c0162778 T rw_verify_area
+c016280c t do_sendfile
+c01629ea T sys_sendfile64
+c0162a7f T sys_sendfile
+c0162b13 t do_readv_writev
+c0162c77 T vfs_writev
+c0162cbf T vfs_readv
+c0162d04 T vfs_write
+c0162e10 T vfs_read
+c0162f1a T default_llseek
+c0162fb7 T generic_file_llseek
+c0163057 T sys_writev
+c01630be T remote_llseek
+c0163178 T sys_lseek
+c01631de T sys_llseek
+c0163263 T sys_read
+c01632ca T sys_write
+c0163331 T sys_pread64
+c0163390 T sys_pwrite64
+c01633ef T sys_readv
+c0163458 T get_max_files
+c016345e T fs_may_remount_ro
+c01634c6 T file_kill
+c01634f3 T file_move
+c0163529 t file_free_rcu
+c0163535 T __fput
+c01636bc T fput
+c01636d1 T put_filp
+c016372c T fget_light
+c0163796 T fget
+c01637df T proc_nr_files
+c016382f T get_empty_filp
+c016399c t set_bdev_super
+c01639aa t test_bdev_super
+c01639b7 t compare_single
+c01639bd T set_anon_super
+c0163a58 T emergency_remount
+c0163a64 T lock_super
+c0163a7a T unlock_super
+c0163a90 T __put_super
+c0163abb t put_super
+c0163ada T drop_super
+c0163aea T __put_super_and_need_restart
+c0163b10 T user_get_super
+c0163b87 T sys_ustat
+c0163c12 T sget
+c0163ed6 T __fsync_super
+c0163f37 T fsync_super
+c0163f4b T do_remount_sb
+c016404d t do_emergency_remount
+c01640e6 T generic_shutdown_super
+c016419f T kill_block_super
+c01641ba T kill_anon_super
+c01641ea T kill_litter_super
+c0164201 T deactivate_super
+c016426b T vfs_kern_mount
+c01643b0 T kern_mount
+c01643c5 T do_kern_mount
+c016448c T sync_supers
+c016451d T sync_filesystems
+c01645f3 T get_super
+c0164673 T get_sb_bdev
+c016478c T get_sb_nodev
+c0164810 T get_sb_single
+c01648b0 t exact_match
+c01648b3 t base_probe
+c01648f0 T cdev_init
+c016492d t cdev_purge
+c0164981 t cdev_default_release
+c0164983 T cd_forget
+c01649c2 t cdev_dynamic_release
+c01649d2 T cdev_alloc
+c0164a03 T cdev_del
+c0164a1e T cdev_add
+c0164a50 T cdev_put
+c0164a67 t cdev_get
+c0164a9f t exact_lock
+c0164aac T chrdev_open
+c0164be3 t __unregister_chrdev_region
+c0164c3e T unregister_chrdev
+c0164c68 T unregister_chrdev_region
+c0164ca0 t __register_chrdev_region
+c0164dc2 T chrdev_show
+c0164e1f T register_chrdev
+c0164ef8 T register_chrdev_region
+c0164f80 T alloc_chrdev_region
+c0164fb0 T generic_fillattr
+c016505d T vfs_getattr
+c016508d T inode_set_bytes
+c01650ad T inode_get_bytes
+c01650e4 T inode_sub_bytes
+c0165188 T inode_add_bytes
+c01651e2 t cp_new_stat64
+c01652f0 t cp_new_stat
+c0165455 T sys_readlinkat
+c01654ce T sys_readlink
+c01654f9 T vfs_lstat_fd
+c0165536 T sys_newlstat
+c016555e T vfs_lstat
+c016556c T sys_lstat64
+c016558f T vfs_stat_fd
+c01655cf T sys_fstatat64
+c0165617 T sys_newstat
+c016563f T vfs_stat
+c016564d T sys_stat64
+c0165670 t cp_old_stat
+c01657a9 T sys_lstat
+c01657d1 T sys_stat
+c01657f9 T vfs_fstat
+c016582a T sys_fstat64
+c016584d T sys_newfstat
+c0165870 T sys_fstat
+c0165894 T set_dumpable
+c01658d3 T get_dumpable
+c01658e8 t zap_process
+c016594b t count
+c016598c t copy_strings
+c0165b4a T copy_strings_kernel
+c0165b71 T search_binary_handler
+c0165d34 T remove_arg_zero
+c0165dd0 T set_task_comm
+c0165e02 T kernel_read
+c0165e4a T prepare_binprm
+c0165f10 T open_exec
+c0165fb5 T install_arg_page
+c016607e T unregister_binfmt
+c01660c7 T register_binfmt
+c0166123 T setup_arg_pages
+c01662cf T flush_old_exec
+c0166aa4 T compute_creds
+c0166b30 T set_binfmt
+c0166b83 T sys_uselib
+c0166caa T do_execve
+c0166e59 T get_task_comm
+c0166e8f T do_coredump
+c0167488 t iov_fault_in_pages_read
+c01674e4 T generic_pipe_buf_pin
+c01674e7 t bad_pipe_r
+c01674ed t bad_pipe_w
+c01674f3 t pipe_poll
+c0167570 t pipefs_delete_dentry
+c0167577 t pipefs_get_sb
+c016758b T generic_pipe_buf_get
+c01675a3 t pipe_rdwr_open
+c01675e2 t pipe_write_open
+c0167608 t pipe_read_open
+c016762e t pipe_rdwr_fasync
+c01676aa t pipe_write_fasync
+c01676fc t pipe_read_fasync
+c016774e t pipe_ioctl
+c01677a5 T generic_pipe_buf_map
+c01677c2 T generic_pipe_buf_unmap
+c01677e2 t pipe_iov_copy_from_user
+c016783d T create_read_pipe
+c01678b8 t pipefs_dname
+c01678e3 T __free_pipe_info
+c016791c T free_pipe_info
+c0167936 T free_write_pipe
+c0167967 t pipe_release
+c01679f5 t pipe_rdwr_release
+c0167a1c t pipe_write_release
+c0167a38 t pipe_read_release
+c0167a54 T alloc_pipe_info
+c0167a88 T create_write_pipe
+c0167be2 T generic_pipe_buf_steal
+c0167c2c T pipe_wait
+c0167c9f t pipe_write
+c0168094 t anon_pipe_buf_release
+c01680c5 t pipe_read
+c01683e6 T do_pipe
+c0168480 T __page_symlink
+c01685d1 T page_symlink
+c01685ef T page_put_link
+c0168607 t page_getlink
+c016863d T page_follow_link_light
+c016865e T unlock_rename
+c016869a T lock_rename
+c016872c T path_release_on_umount
+c016873f T path_release
+c016875f T vfs_readlink
+c01687a2 T page_readlink
+c01687ed T generic_readlink
+c016885b t cached_lookup
+c01688c1 T dentry_unhash
+c016892e T deny_write_access
+c016896a T get_write_access
+c01689a2 t follow_mount
+c01689f4 t __follow_mount
+c0168a54 T generic_permission
+c0168b11 t do_lookup
+c0168de8 T permission
+c0169031 T vfs_link
+c0169192 T vfs_symlink
+c0169262 T vfs_mkdir
+c0169338 T vfs_mknod
+c0169436 T vfs_create
+c0169521 t may_delete
+c0169620 T vfs_rename
+c01699db T vfs_unlink
+c0169a93 T vfs_rmdir
+c0169b68 t lookup_hash
+c0169bf9 T lookup_create
+c0169c63 T file_permission
+c0169c70 T vfs_permission
+c0169c7c T may_open
+c0169ed9 T release_open_intent
+c0169eec T getname
+c0169f7b T lookup_one_len_kern
+c016a036 T lookup_one_len_nd
+c016a110 T follow_up
+c016a189 T follow_down
+c016a1da t __link_path_walk
+c016adb8 T link_path_walk
+c016ae6b T path_walk
+c016ae81 t __emul_lookup_dentry
+c016af91 t do_path_lookup
+c016b10e T sys_renameat
+c016b2e2 T sys_rename
+c016b30d T sys_symlinkat
+c016b3d5 T sys_symlink
+c016b3f8 t do_unlinkat
+c016b52c T sys_unlink
+c016b53a t do_rmdir
+c016b5fb T sys_unlinkat
+c016b624 T sys_rmdir
+c016b632 T sys_mkdirat
+c016b6fc T sys_mkdir
+c016b71f T sys_mknodat
+c016b8a5 T sys_mknod
+c016b8d0 T __user_walk_fd
+c016b915 T sys_linkat
+c016ba1a T sys_link
+c016ba4d T __user_walk
+c016ba63 t __path_lookup_intent_open
+c016bad8 T __user_path_lookup_open
+c016bb2c T path_lookup_open
+c016bb51 T path_lookup
+c016bb67 T cow_break_link
+c016bf78 T set_fs_altroot
+c016bfd3 T open_namei
+c016c582 T vfs_follow_link
+c016c690 T f_getown
+c016c6c3 T fasync_helper
+c016c782 T send_sigurg
+c016c816 T send_sigio
+c016c930 T __kill_fasync
+c016c97b T kill_fasync
+c016c9af T set_close_on_exec
+c016c9ed t dupfd
+c016cb66 T sys_dup
+c016cb80 t f_modown
+c016cbea T f_delown
+c016cc11 T __f_setown
+c016cc45 T f_setown
+c016cc75 t do_fcntl
+c016cebe T sys_fcntl64
+c016cf2b T sys_dup2
+c016d041 T sys_fcntl
+c016d080 t do_ioctl
+c016d11f T vfs_ioctl
+c016d36a T sys_ioctl
+c016d3b4 t filldir64
+c016d47c t filldir
+c016d535 T vfs_readdir
+c016d5ac T sys_getdents64
+c016d652 T old_readdir
+c016d6a0 t fillonedir
+c016d777 T sys_getdents
+c016d814 T poll_initwait
+c016d830 t free_poll_entry
+c016d846 T poll_freewait
+c016d892 T do_sys_poll
+c016dbb9 T sys_poll
+c016dbf0 T do_select
+c016dfb9 t core_sys_select
+c016e2a1 T sys_pselect7
+c016e4b0 T sys_pselect6
+c016e52b t __pollwait
+c016e5d7 T sys_select
+c016e75f T sys_ppoll
+c016e964 t wake_up_partner
+c016e985 t wait_for_partner
+c016e9b3 t fifo_open
+c016eb5c t locks_release_private
+c016eb93 t locks_copy_private
+c016ebce t __locks_copy_lock
+c016ec16 T locks_copy_lock
+c016ec4d t flock_to_posix_lock
+c016ed5b t flock64_to_posix_lock
+c016ee9c t lease_mylease_callback
+c016eea9 t lease_init
+c016ef1b t posix_same_owner
+c016ef4d t __locks_delete_block
+c016ef7e t posix_locks_conflict
+c016efd2 T vfs_cancel_lock
+c016eff0 T lock_may_write
+c016f05f T lock_may_read
+c016f0d5 T posix_unblock_lock
+c016f0fb T posix_test_lock
+c016f152 T vfs_test_lock
+c016f175 t locks_delete_block
+c016f18a t lock_get_status
+c016f3c2 t move_lock_status
+c016f41c t locks_wake_up_blocks
+c016f46b t locks_free_lock
+c016f4c9 t locks_delete_lock
+c016f540 T lease_modify
+c016f56f t time_out_leases
+c016f5b4 T fcntl_getlease
+c016f5fd t locks_alloc_lock
+c016f671 T fcntl_getlk64
+c016f782 T fcntl_getlk
+c016f8b7 t locks_insert_lock
+c016f8e4 t __setlease
+c016fa58 t locks_insert_block
+c016fa8f t __posix_lock_file
+c016ff66 T posix_lock_file
+c016ff80 T vfs_lock_file
+c016ffb1 T flock_lock_file_wait
+c0170202 t lease_break_callback
+c0170214 t lease_release_private_callback
+c017022f T lease_get_mtime
+c0170267 T locks_init_lock
+c01702e1 t init_once
+c01702e6 T get_locks_status
+c01703f9 T locks_mandatory_locked
+c017043f T __break_lease
+c0170718 T fcntl_setlk64
+c0170912 T locks_remove_posix
+c01709ac T locks_remove_flock
+c0170a81 T setlease
+c0170aee T fcntl_setlease
+c0170bee T sys_flock
+c0170d25 T posix_lock_file_wait
+c0170ddc T locks_mandatory_area
+c0170f48 T fcntl_setlk
+c0171144 T dget_locked
+c0171189 t __d_find_alias
+c0171269 t __d_rehash
+c0171286 t _d_rehash
+c01712be T is_subdir
+c0171304 T d_rehash
+c0171336 T d_find_alias
+c0171368 t dentry_iput
+c017140c t __d_free
+c017142d t d_free
+c017145b t d_kill
+c017148d t d_callback
+c0171495 t __d_path
+c01715eb t switch_names
+c017165b T dynamic_dname
+c01716b8 t shrink_dcache_for_umount_subtree
+c017189b t d_move_locked
+c01719fc T d_move
+c0171a21 T __d_lookup
+c0171b2c T d_lookup
+c0171b69 T d_hash_and_lookup
+c0171bc4 t __d_instantiate_unique
+c0171c61 T d_instantiate
+c0171ca5 T d_validate
+c0171d7b T d_alloc
+c0171f76 T d_alloc_root
+c0171fac T d_alloc_name
+c0171ffe T dput
+c0172110 T find_inode_number
+c017212f T d_alloc_anon
+c0172203 t prune_one_dentry
+c01722bd T shrink_dcache_sb
+c017237b t prune_dcache
+c01724b2 t shrink_dcache_memory
+c01724e6 T shrink_dcache_parent
+c01725c5 T shrink_dcache_for_umount
+c01725fb T d_genocide
+c0172652 T d_invalidate
+c0172707 T have_submounts
+c017276c T d_instantiate_unique
+c01727b7 T d_prune_aliases
+c0172891 T d_materialise_unique
+c0172afa T d_path
+c0172bdb T sys_getcwd
+c0172d90 T d_splice_alias
+c0172e41 T d_delete
+c0172f18 t hash
+c0172f3f T bmap
+c0172f66 T inode_needs_sync
+c0172fac T init_special_inode
+c0173029 T inode_double_lock
+c0173076 T remove_inode_hash
+c01730ad T __insert_inode_hash
+c01730ef T inode_double_unlock
+c017311c T __iget
+c0173155 T igrab
+c0173184 T wake_up_inode
+c0173199 T unlock_new_inode
+c01731a5 T inode_wait
+c01731ad T iput
+c017320f t __wait_on_freeing_inode
+c017329a t find_inode_fast
+c01732dc T iunique
+c017333e t find_inode
+c0173394 t ifind_fast
+c0173414 T ilookup
+c0173437 t ifind
+c01734c5 T ilookup5
+c01734fd T ilookup5_nowait
+c0173535 T destroy_inode
+c0173568 t alloc_inode
+c017369d T iget_locked
+c01737a9 T iget5_locked
+c01738e8 T new_inode
+c0173954 T clear_inode
+c0173a64 T generic_delete_inode
+c0173b58 T generic_drop_inode
+c0173c79 t dispose_list
+c0173d30 t shrink_icache_memory
+c0173ed1 T invalidate_inodes
+c0173f96 T inode_init_once
+c01740f9 t init_once
+c01740fe T file_update_time
+c0174168 T touch_atime
+c0174224 T inode_setattr
+c017436e T inode_change_ok
+c01745aa T notify_change
+c0174838 t bad_file_llseek
+c0174841 t bad_file_read
+c0174847 t bad_file_write
+c017484d t bad_file_aio_read
+c0174853 t bad_file_aio_write
+c0174859 t bad_file_readdir
+c017485f t bad_file_poll
+c0174865 t bad_file_ioctl
+c017486b t bad_file_unlocked_ioctl
+c0174871 t bad_file_compat_ioctl
+c0174877 t bad_file_mmap
+c017487d t bad_file_open
+c0174883 t bad_file_flush
+c0174889 t bad_file_release
+c017488f t bad_file_fsync
+c0174895 t bad_file_aio_fsync
+c017489b t bad_file_fasync
+c01748a1 t bad_file_lock
+c01748a7 t bad_file_sendfile
+c01748ad t bad_file_sendpage
+c01748b3 t bad_file_get_unmapped_area
+c01748b9 t bad_file_check_flags
+c01748bf t bad_file_dir_notify
+c01748c5 t bad_file_flock
+c01748cb t bad_file_splice_write
+c01748d1 t bad_file_splice_read
+c01748d7 t bad_inode_create
+c01748dd t bad_inode_lookup
+c01748e3 t bad_inode_link
+c01748e9 t bad_inode_unlink
+c01748ef t bad_inode_symlink
+c01748f5 t bad_inode_mkdir
+c01748fb t bad_inode_rmdir
+c0174901 t bad_inode_mknod
+c0174907 t bad_inode_rename
+c017490d t bad_inode_readlink
+c0174913 t bad_inode_permission
+c0174919 t bad_inode_getattr
+c017491f t bad_inode_setattr
+c0174925 t bad_inode_setxattr
+c017492b t bad_inode_getxattr
+c0174931 t bad_inode_listxattr
+c0174937 t bad_inode_removexattr
+c017493d T is_bad_inode
+c017494e T make_bad_inode
+c0174998 t free_fdtable_work
+c01749eb T expand_files
+c0174cbf T free_fdtable_rcu
+c0174d34 t find_filesystem
+c0174d85 T get_filesystem_list
+c0174df3 T unregister_filesystem
+c0174e3f T put_filesystem
+c0174e47 T sys_sysfs
+c0174f8e T get_filesystem
+c0174fb7 T register_filesystem
+c017502e T get_fs_type
+c0175128 T __lookup_mnt
+c017517b t detach_mnt
+c01751bc t next_mnt
+c01751e0 t m_next
+c01751fc T may_umount_tree
+c0175239 t mnt_is_reachable
+c01752a8 T mnt_unpin
+c01752cd T mnt_pin
+c01752e8 T mnt_set_mountpoint
+c017530a t m_stop
+c0175314 t m_start
+c0175358 t attach_mnt
+c01753b6 t touch_mnt_namespace
+c01753e8 t commit_tree
+c01754ae T copy_mount_options
+c01755b7 T free_vfsmnt
+c01755cf t attach_recursive_mnt
+c01756bc t graft_tree
+c0175751 T may_umount
+c017577f T umount_tree
+c0175862 T mntput_no_expire
+c01758c5 T set_fs_pwd
+c017593c T set_fs_root
+c01759b3 T do_add_mount
+c0175aac T release_mounts
+c0175b1e T __put_mnt_ns
+c0175b8f t expire_mount_list
+c0175cb0 T shrink_submounts
+c0175d5d T sys_umount
+c0175f8b T sys_oldumount
+c0175fa5 T alloc_vfsmnt
+c0176059 t clone_mnt
+c017613a T copy_tree
+c01762b6 T copy_mnt_ns
+c017648b T do_mount
+c0176be7 T sys_mount
+c0176c9a T lookup_mnt
+c0176cd1 T mark_mounts_for_expiry
+c0176d48 T sys_pivot_root
+c0177121 T simple_set_mnt
+c017713d t show_vfsmnt
+c017730b t show_vfsstat
+c0177464 t aio_fdsync
+c0177484 t aio_fsync
+c01774a1 t aio_setup_single_vector
+c01774c4 t aio_rw_vect_retry
+c01775c4 t aio_cancel_all
+c0177632 t aio_queue_work
+c017765b t __aio_put_req
+c0177765 T aio_put_req
+c017778f t timeout_func
+c017779e t aio_read_evt
+c017785b t __aio_get_req
+c0177941 t aio_setup_vectored_rw
+c017798b t wait_for_all_aios
+c0177a14 t aio_free_ring
+c0177a81 T aio_complete
+c0177c1a t aio_run_iocb
+c0177d22 t __aio_run_iocbs
+c0177d83 T kick_iocb
+c0177e09 t aio_wake_function
+c0177e2d T lookup_ioctx
+c0177e80 T __put_ioctx
+c0177f1c T sys_io_getevents
+c01781c3 t io_destroy
+c017825c t aio_fput_routine
+c0178349 T io_submit_one
+c01785df T sys_io_setup
+c0178945 T sys_io_destroy
+c0178961 t aio_kick_handler
+c0178b8c T exit_aio
+c0178c11 T sys_io_submit
+c0178ce3 T sys_io_cancel
+c0178e01 T wait_on_sync_kiocb
+c0178e38 t single_start
+c0178e44 t single_next
+c0178e4e t single_stop
+c0178e4f T seq_putc
+c0178e6c T seq_puts
+c0178eb1 T seq_release
+c0178eca T seq_release_private
+c0178ef2 T single_release
+c0178f10 T seq_path
+c0178fcb T seq_printf
+c0179016 T seq_lseek
+c01792b4 T seq_open
+c0179325 T single_open
+c0179390 T seq_escape
+c0179434 T seq_read
+c01796b4 T vfs_listxattr
+c01796d7 t xattr_resolve_name
+c017971b T generic_getxattr
+c0179762 T generic_listxattr
+c0179808 T generic_setxattr
+c0179864 T generic_removexattr
+c01798b0 t listxattr
+c0179937 T sys_flistxattr
+c017996b T sys_llistxattr
+c01799af T sys_listxattr
+c01799f6 t xattr_permission
+c0179b4e T vfs_getxattr
+c0179bb8 t getxattr
+c0179c79 T sys_fgetxattr
+c0179cb8 T sys_lgetxattr
+c0179d03 T sys_getxattr
+c0179d51 T vfs_removexattr
+c0179e23 t removexattr
+c0179e72 T sys_fremovexattr
+c0179ea5 T sys_lremovexattr
+c0179ee9 T sys_removexattr
+c0179f30 T vfs_setxattr
+c017a039 t setxattr
+c017a123 T sys_fsetxattr
+c017a173 T sys_lsetxattr
+c017a1ce T sys_setxattr
+c017a22c T simple_statfs
+c017a245 t simple_delete_dentry
+c017a24b T simple_sync_file
+c017a24e T generic_read_dir
+c017a254 T simple_attr_write
+c017a2dc T simple_attr_close
+c017a2ea T simple_attr_open
+c017a364 T simple_transaction_release
+c017a374 T simple_empty
+c017a3c6 T simple_read_from_buffer
+c017a453 T simple_attr_read
+c017a4e8 T simple_transaction_read
+c017a51b T simple_release_fs
+c017a560 T simple_unlink
+c017a597 T dcache_dir_close
+c017a5a5 T simple_fill_super
+c017a760 T simple_commit_write
+c017a7b4 T dcache_dir_open
+c017a7d4 T dcache_readdir_filter
+c017a9cd T dcache_dir_lseek
+c017aac8 T simple_getattr
+c017aaf3 T simple_readpage
+c017ab33 T simple_prepare_write
+c017abb3 T simple_link
+c017ac00 T simple_rmdir
+c017ac2f T simple_rename
+c017acba T simple_transaction_get
+c017ad42 T simple_pin_fs
+c017adcc T get_sb_pseudo
+c017af01 T simple_lookup
+c017af2d T dcache_readdir
+c017b110 T writeback_acquire
+c017b120 T writeback_in_progress
+c017b127 T writeback_release
+c017b13f t set_sb_syncing
+c017b16b t __writeback_single_inode
+c017b443 T sync_inode
+c017b46d T write_inode_now
+c017b531 T generic_osync_inode
+c017b606 t sync_sb_inodes
+c017b82a T sync_inodes_sb
+c017b8be t __sync_inodes
+c017b94c T sync_inodes
+c017b975 T __mark_inode_dirty
+c017bad1 T writeback_inodes
+c017bb90 t propagation_next
+c017bbd6 T propagate_umount
+c017bc49 T change_mnt_propagation
+c017bdae T propagate_mount_busy
+c017be1a T propagate_mnt
+c017bf7c T drop_slab
+c017bf96 T drop_pagecache_sb
+c017bfeb T drop_pagecache
+c017c05b T drop_caches_sysctl_handler
+c017c0a8 t pipe_to_sendpage
+c017c109 t do_splice_to
+c017c16d t do_splice_from
+c017c1d0 t user_page_pipe_buf_steal
+c017c1e9 t page_cache_pipe_buf_release
+c017c1f9 T __splice_from_pipe
+c017c3b9 T splice_from_pipe
+c017c410 T generic_splice_sendpage
+c017c435 t splice_to_pipe
+c017c619 T generic_file_splice_write
+c017c717 t pipe_to_file
+c017c97b T generic_file_splice_write_nolock
+c017ca1f t page_cache_pipe_buf_pin
+c017ca79 T do_splice_direct
+c017cbd8 T generic_file_splice_read
+c017d054 T sys_vmsplice
+c017d2d6 T sys_splice
+c017d4da T sys_tee
+c017d838 t page_cache_pipe_buf_steal
+c017d904 T do_sync_mapping_range
+c017d9c1 T sys_sync_file_range
+c017dadb T sys_sync_file_range2
+c017db0c T do_fsync
+c017db95 t __do_fsync
+c017dbc0 T sys_fdatasync
+c017dbcb T sys_fsync
+c017dbd3 T file_fsync
+c017dc1a T emergency_sync
+c017dc26 t do_sync
+c017dc81 T sys_sync
+c017dc90 T do_utimes
+c017df21 T sys_futimesat
+c017dfa9 T sys_utimes
+c017dfcc T sys_utimensat
+c017e052 T sys_utime
+c017e0b8 T fsstack_copy_inode_size
+c017e0fd T fsstack_copy_attr_all
+c017e168 T init_buffer
+c017e16f T mark_buffer_async_write
+c017e17c T inode_has_buffers
+c017e18f T generic_block_bmap
+c017e1e7 t init_page_buffers
+c017e24e T block_sync_page
+c017e286 t recalc_bh_state
+c017e2f8 T free_buffer_head
+c017e324 T alloc_buffer_head
+c017e374 T sys_bdflush
+c017e3d0 T __brelse
+c017e419 T __bforget
+c017e464 t invalidate_bh_lru
+c017e498 t drop_buffers
+c017e570 T try_to_free_buffers
+c017e5ef T submit_bh
+c017e6e4 t __generic_cont_expand
+c017e7d2 T generic_cont_expand_simple
+c017e804 T generic_cont_expand
+c017e83f t buffer_io_error
+c017e874 t __find_get_block_slow
+c017e998 T set_bh_page
+c017e9e5 T invalidate_bh_lrus
+c017ea02 t free_more_memory
+c017ea41 T alloc_page_buffers
+c017eafc T create_empty_buffers
+c017eb82 T __find_get_block
+c017eccb T __getblk
+c017ef62 T mark_buffer_dirty
+c017ef7e t __block_commit_write
+c017f008 T generic_commit_write
+c017f07f T block_commit_write
+c017f099 T invalidate_bdev
+c017f0bd T thaw_bdev
+c017f123 T sync_blockdev
+c017f138 T freeze_bdev
+c017f1aa T fsync_bdev
+c017f1d5 T __wait_on_buffer
+c017f1fc T unmap_underlying_metadata
+c017f25f t sync_buffer
+c017f293 T unlock_buffer
+c017f2a2 t end_buffer_async_read
+c017f37b T __lock_buffer
+c017f3a7 T ll_rw_block
+c017f44b t __block_prepare_write
+c017f8a1 T block_prepare_write
+c017f8d1 t __block_write_full_page
+c017fbe2 T block_write_full_page
+c017fcba T sync_dirty_buffer
+c017fd8c T nobh_commit_write
+c017fde4 t end_bio_bh_io_sync
+c017fe1d T block_invalidatepage
+c017fed4 T sync_mapping_buffers
+c0180109 T mark_buffer_dirty_inode
+c0180173 T nobh_writepage
+c018024d t end_buffer_read_nobh
+c0180262 T __bread
+c01802f8 T write_boundary_block
+c018033b T end_buffer_read_sync
+c018035b T end_buffer_write_sync
+c01803b9 T __set_page_dirty_buffers
+c0180491 T __breadahead
+c01804cd t end_buffer_async_write
+c01805b7 T cont_prepare_write
+c01807fc T nobh_truncate_page
+c01808f1 T block_truncate_page
+c0180b0d T block_read_full_page
+c0180e05 T nobh_prepare_write
+c0181179 T invalidate_inode_buffers
+c0181214 T remove_inode_buffers
+c01812c8 T bio_init
+c018132e T bioset_free
+c018135d T bioset_create
+c01813e7 t bio_free_map_data
+c01813f9 T bio_put
+c018141d t bio_map_kern_endio
+c0181432 T bio_split
+c01815bf T bio_alloc_bioset
+c01816b2 T bio_alloc
+c01816c9 T bio_free
+c01816f5 t bio_fs_destructor
+c0181700 T bio_endio
+c0181763 T bio_pair_release
+c0181795 t bio_pair_end_2
+c01817b9 t bio_pair_end_1
+c01817d8 T bio_release_pages
+c01817ff T bio_set_pages_dirty
+c018182f t bio_dirty_fn
+c018187a T bio_unmap_user
+c01818b7 T bio_uncopy_user
+c0181969 t __bio_add_page
+c0181adc T bio_add_pc_page
+c0181b04 T bio_map_kern
+c0181bd9 T bio_map_user_iov
+c0181e58 T bio_map_user
+c0181e85 T __bio_clone
+c0181f0f T bio_clone
+c0181f3c T bio_hw_segments
+c0181f50 T bio_phys_segments
+c0181f64 T zero_fill_bio
+c0182000 T bio_check_pages_dirty
+c018207c T bio_copy_user
+c018228b T bio_get_nr_vecs
+c01822bc T bio_add_page
+c01822f4 T I_BDEV
+c01822fa t max_block
+c018236f t bdev_set
+c018237a T bd_set_size
+c01823df T bd_release
+c018241e T bd_claim
+c0182479 T nr_blockdev_pages
+c01824b6 t block_llseek
+c0182573 t kill_bdev
+c018259f T set_blocksize
+c0182615 T sb_set_blocksize
+c0182649 T sb_min_blocksize
+c0182677 t block_ioctl
+c0182692 t blkdev_commit_write
+c018269f t blkdev_prepare_write
+c01826b4 t blkdev_readpage
+c01826c0 t blkdev_writepage
+c01826cc T __invalidate_device
+c0182700 T check_disk_change
+c018275c t del_symlink
+c018276c t free_bd_holder
+c0182771 T bd_release_from_disk
+c0182827 t add_symlink
+c0182839 T bd_claim_by_disk
+c01829b4 T bd_forget
+c0182a51 T bdput
+c0182a59 t __blkdev_put
+c0182b5c T blkdev_put
+c0182b63 T close_bdev_excl
+c0182b73 T bdget
+c0182c61 t do_open
+c0182eb6 t __blkdev_get
+c0182f1c T blkdev_get
+c0182f30 t bd_acquire
+c0182fc0 T lookup_bdev
+c0183031 t blkdev_open
+c018307e t bd_get_sb
+c0183095 t bdev_alloc_inode
+c01830b3 T ioctl_by_bdev
+c01830ea t init_once
+c018315b T open_by_devnum
+c0183193 T open_bdev_excl
+c01831f5 t bdev_destroy_inode
+c018320f t bdev_test
+c018321e t blkdev_get_block
+c0183264 t blkdev_get_blocks
+c0183319 t blkdev_direct_IO
+c0183375 t block_fsync
+c0183387 t blkdev_close
+c01833aa t bdev_clear_inode
+c0183410 t dio_complete
+c01834cc t dio_get_page
+c0183625 t dio_cleanup
+c0183646 t dio_bio_complete
+c01836d2 t dio_new_bio
+c01837d0 t dio_bio_end_io
+c0183831 t dio_bio_end_aio
+c01838d9 t dio_bio_add_page
+c0183959 t dio_bio_submit
+c01839b0 t dio_send_cur_page
+c0183a42 t submit_page_section
+c0183b3a t dio_zero_block
+c0183bb8 T __blockdev_direct_IO
+c01847a8 t mpage_alloc
+c0184821 t mpage_bio_submit
+c018483e t __mpage_writepage
+c0184e4e T mpage_writepage
+c0184e9a T mpage_writepages
+c0184eff t do_mpage_readpage
+c01854fd T mpage_readpage
+c018555b t mpage_end_io_read
+c01855bf t mpage_end_io_write
+c0185624 T mpage_readpages
+c0185734 T ioprio_best
+c0185768 t set_task_ioprio
+c01857cd T sys_ioprio_set
+c01859b4 T sys_ioprio_get
+c0185b4c t revokefs_get_sb
+c0185b63 t revokefs_destroy_inode
+c0185b70 t revokefs_alloc_inode
+c0185b8b t revokefs_init_inode
+c0185b99 T generic_file_revoke
+c0185bc8 t free_fset
+c0185bfd t inode_fds
+c0185cb6 t revoke_mm
+c0185d9e t do_revoke
+c01864c5 T sys_frevoke
+c01864f6 T sys_revokeat
+c0186538 t revoked_file_llseek
+c0186541 t revoked_file_read
+c0186547 t revoked_special_file_read
+c018654a t revoked_file_write
+c0186550 t revoked_file_aio_read
+c0186556 t revoked_file_aio_write
+c018655c t revoked_file_readdir
+c0186562 t revoked_file_poll
+c0186568 t revoked_file_ioctl
+c018656e t revoked_file_unlocked_ioctl
+c0186574 t revoked_file_compat_ioctl
+c018657a t revoked_file_mmap
+c0186580 t revoked_file_open
+c0186586 t revoked_file_release
+c018658c t revoked_file_fsync
+c0186592 t revoked_file_aio_fsync
+c0186598 t revoked_file_fasync
+c018659e t revoked_file_lock
+c01865a4 t revoked_file_sendfile
+c01865aa t revoked_file_sendpage
+c01865b0 t revoked_file_get_unmapped_area
+c01865b6 t revoked_file_check_flags
+c01865bc t revoked_file_dir_notify
+c01865c2 t revoked_file_flock
+c01865c8 t revoked_file_splice_write
+c01865ce t revoked_file_splice_read
+c01865d4 t revoked_inode_create
+c01865da t revoked_inode_lookup
+c01865e0 t revoked_inode_link
+c01865e6 t revoked_inode_unlink
+c01865ec t revoked_inode_symlink
+c01865f2 t revoked_inode_mkdir
+c01865f8 t revoked_inode_rmdir
+c01865fe t revoked_inode_mknod
+c0186604 t revoked_inode_rename
+c018660a t revoked_inode_readlink
+c0186610 t revoked_inode_permission
+c0186616 t revoked_inode_getattr
+c018661c t revoked_inode_setattr
+c0186622 t revoked_inode_setxattr
+c0186628 t revoked_inode_getxattr
+c018662e t revoked_inode_listxattr
+c0186634 t revoked_inode_removexattr
+c018663a t revoked_readpage
+c0186640 t revoked_writepage
+c0186646 t revoked_prepare_write
+c018664c t revoked_commit_write
+c0186652 t revoked_direct_IO
+c0186658 T make_revoked_inode
+c01866dd t revoked_file_flush
+c01866e4 T get_inotify_watch
+c01866e9 t inode_find_handle
+c018671f T inotify_get_cookie
+c018672e T inotify_find_update_watch
+c01867b0 t set_dentry_child_flags
+c01868dc T inotify_add_watch
+c01869c7 t remove_watch_no_event
+c0186a02 T inotify_inode_queue_event
+c0186ad2 T inotify_remove_watch_locked
+c0186b10 T inotify_inode_is_dead
+c0186b7c T inotify_unmount_inodes
+c0186d01 T put_inotify_watch
+c0186d41 T inotify_rm_wd
+c0186dcb T inotify_rm_watch
+c0186dd3 T inotify_init
+c0186e2d T inotify_d_instantiate
+c0186e9f T inotify_d_move
+c0186eba T inotify_dentry_parent_queue_event
+c0186f4b T inotify_init_watch
+c0186f65 T inotify_find_watch
+c0186fbe T inotify_destroy
+c018705c t inotify_ioctl
+c018707e t inotify_get_sb
+c0187092 t remove_kevent
+c01870c5 t free_inotify_user_watch
+c0187107 t inotify_release
+c0187167 T sys_inotify_rm_watch
+c01871b9 t kernel_event
+c01872e5 t inotify_poll
+c0187328 t inotify_read
+c018747a t inotify_dev_queue_event
+c018758f T sys_inotify_init
+c01876f2 T sys_inotify_add_watch
+c018783c t ep_poll_safewake
+c01878dd t ep_unregister_pollwait
+c018791f t ep_remove
+c01879b0 T eventpoll_release_file
+c0187a0f t ep_free
+c0187a7f t ep_eventpoll_release
+c0187a91 T sys_epoll_wait
+c0187e3c T sys_epoll_pwait
+c0187f1f T sys_epoll_ctl
+c01882b3 t ep_ptable_queue_proc
+c0188318 T sys_epoll_create
+c01883dc t ep_eventpoll_poll
+c018841d t ep_poll_callback
+c01884ac t anon_inodefs_delete_dentry
+c01884b6 t anon_inodefs_get_sb
+c01884ca T anon_inode_getfd
+c0188614 T signalfd_deliver
+c0188692 t signalfd_unlock
+c01886a7 t signalfd_lock
+c0188704 t signalfd_read
+c0188a2b t signalfd_cleanup
+c0188a57 t signalfd_release
+c0188a65 t signalfd_poll
+c0188adf T sys_signalfd
+c0188c58 t eventfd_release
+c0188c66 t eventfd_poll
+c0188ccd T sys_eventfd
+c0188d40 t eventfd_write
+c0188eaa T eventfd_signal
+c0188f45 T eventfd_fget
+c0188f68 t eventfd_read
+c01890b4 t scanarg
+c01890f0 t unquote
+c0189181 t bm_get_sb
+c0189192 t bm_fill_super
+c01891b1 t bm_clear_inode
+c01891bc t parse_command
+c0189227 t kill_node
+c01892d3 t bm_status_write
+c0189363 t bm_status_read
+c01893b9 t bm_entry_read
+c018961b t load_misc_binary
+c0189936 t bm_entry_write
+c01899b8 t bm_register_write
+c0189f00 t load_script
+c018a0bc t dump_write
+c018a0dd t maydump
+c018a11b t notesize
+c018a143 t alignfile
+c018a1db t writenote
+c018a27e t fill_prstatus
+c018a352 t dump_seek
+c018a3e8 t set_brk
+c018a462 t elf_map
+c018a50a t padzero
+c018a52e t load_elf_library
+c018a73d t load_elf_binary
+c018bb95 t elf_core_dump
+c018c6b4 t __mb_cache_entry_unhash
+c018c6db t __mb_cache_entry_forget
+c018c722 t __mb_cache_entry_release_unlock
+c018c7a6 t __mb_cache_entry_find
+c018c8b7 T mb_cache_entry_find_next
+c018c920 T mb_cache_entry_free
+c018c93c T mb_cache_entry_release
+c018c951 T mb_cache_entry_alloc
+c018c98c T mb_cache_entry_insert
+c018ca6b T mb_cache_entry_get
+c018cba4 T mb_cache_entry_find_first
+c018cbff T mb_cache_destroy
+c018ccd9 t mb_cache_shrink_fn
+c018cd94 T mb_cache_shrink
+c018ce11 T mb_cache_create
+c018cf80 T posix_acl_valid
+c018d03d T posix_acl_equiv_mode
+c018d0d9 T posix_acl_create_masq
+c018d1e8 T posix_acl_chmod_masq
+c018d277 T posix_acl_clone
+c018d29a T posix_acl_alloc
+c018d2b8 T posix_acl_from_mode
+c018d31f T posix_acl_permission
+c018d418 T posix_acl_to_xattr
+c018d46c T posix_acl_from_xattr
+c018d540 T mark_info_dirty
+c018d551 T unregister_quota_format
+c018d582 T register_quota_format
+c018d5ab t shrink_dqcache_memory
+c018d655 T vfs_get_dqinfo
+c018d6ed T dquot_commit_info
+c018d726 t dqput
+c018d89f t dqget
+c018dade T vfs_set_dqblk
+c018dc9a T vfs_get_dqblk
+c018dd72 T dquot_drop
+c018ddbe T dquot_initialize
+c018de45 t put_quota_format
+c018de4d t vfs_quota_on_inode
+c018e225 T vfs_quota_on_mount
+c018e285 T dquot_mark_dquot_dirty
+c018e2c4 T vfs_quota_off
+c018e6b3 t check_bdq
+c018e85c t check_idq
+c018e98a t print_warning
+c018eab4 T dquot_transfer
+c018edf0 T dquot_acquire
+c018eea9 T dquot_release
+c018ef33 T vfs_quota_sync
+c018f068 T vfs_quota_on
+c018f0bb T dquot_commit
+c018f16b T dquot_free_inode
+c018f276 T dquot_free_space
+c018f3ff T dquot_alloc_space
+c018f545 T dquot_alloc_inode
+c018f64c T vfs_set_dqinfo
+c018f6fc t v2_read_file_info
+c018f784 t v2_check_quota_file
+c018f7f4 t getdqbuf
+c018f81e t put_free_dqblk
+c018f890 t remove_free_dqentry
+c018fa71 t remove_tree
+c018ff09 t v2_release_dquot
+c018ff49 t get_free_dqblk
+c0190042 t find_tree_dqentry
+c019024c t do_insert_tree
+c0190619 t v2_write_file_info
+c01906c1 t v2_write_dquot
+c019080f t v2_read_dquot
+c01909d4 t quota_sync_sb
+c0190a80 T sync_dquots
+c0190b7c T sys_quotactl
+c0191224 t redo_inode_mask
+c0191249 T __inode_dir_notify
+c01912cd T dnotify_parent
+c019132a T dnotify_flush
+c019139e T fcntl_dirnotify
+c0191504 T get_vmalloc_info
+c01915f8 T task_vsize
+c01915ff t vma_stop
+c019161d t m_next
+c0191653 t add_to_pagemap
+c01916be t pagemap_fill
+c01916e0 t pagemap_pte_range
+c0191789 t pad_len_spaces
+c01917bd t show_map
+c01919e9 t m_start
+c0191aeb t do_maps_open
+c0191b45 t smaps_open
+c0191b4c t maps_open
+c0191b53 t clear_refs_pte_range
+c0191be4 T task_mem
+c0191cba T task_statm
+c0191d06 t smaps_pte_range
+c0191df0 t show_smap
+c0191ea2 t pagemap_read
+c0192173 T proc_exe_link
+c01922b4 t m_stop
+c01922db t clear_refs_write
+c0192478 T de_get
+c0192481 t proc_remount
+c019248a t proc_read_inode
+c01924ac t proc_destroy_inode
+c01924b9 t proc_alloc_inode
+c019250e T proc_get_inode
+c01925e0 t init_once
+c01925e8 T de_put
+c0192649 t proc_delete_inode
+c019268a T proc_fill_super
+c019271c t proc_root_readdir
+c0192775 t proc_root_getattr
+c0192799 t proc_root_lookup
+c01927bf t proc_get_sb
+c0192818 T mem_lseek
+c0192850 t name_to_int
+c0192891 t proc_pid_schedstat
+c01928bd t proc_fill_cache
+c01929c7 t mounts_poll
+c0192a0d t get_fs_struct
+c0192a37 t proc_base_instantiate
+c0192b2e t mounts_release
+c0192b61 t proc_pid_auxv
+c0192bba t proc_pid_environ
+c0192c25 t task_dumpable
+c0192c64 t proc_pid_make_inode
+c0192cee t get_nr_threads
+c0192d23 t proc_oom_score
+c0192d70 t proc_pid_wchan
+c0192dbd t proc_setattr
+c0192de5 t next_tgid
+c0192e1e t proc_pident_readdir
+c0193037 t proc_tid_base_readdir
+c0193051 t proc_tgid_base_readdir
+c019306b t proc_readfd_common
+c01932ae t proc_readfdinfo
+c01932bf t proc_readfd
+c01932d0 t proc_lookupfd_common
+c01933b8 t proc_lookupfdinfo
+c01933c2 t proc_lookupfd
+c01933cc t tid_fd_revalidate
+c019354f t proc_fd_info
+c01936e9 t proc_fd_link
+c01936fa t pid_revalidate
+c01938a7 t proc_task_instantiate
+c0193912 t proc_pid_instantiate
+c019397d t proc_pident_instantiate
+c0193a01 t proc_pident_lookup
+c0193b76 t proc_tid_base_lookup
+c0193b8c t proc_tgid_base_lookup
+c0193ba2 t proc_fd_access_allowed
+c0193c4d t proc_task_getattr
+c0193d19 t proc_fdinfo_read
+c0193d64 t proc_pid_cmdline
+c0193e45 t mem_open
+c0193e5a t proc_fd_permission
+c0193e85 t proc_fdinfo_instantiate
+c0193ee3 t proc_pid_follow_link
+c0193f19 t proc_pid_readlink
+c0193ff5 t proc_self_readlink
+c0194067 t proc_self_follow_link
+c01940ca t pid_getattr
+c0194122 t pid_delete_dentry
+c0194133 T proc_flush_task
+c0194311 t proc_fd_instantiate
+c0194426 t proc_cwd_link
+c0194525 t proc_root_link
+c0194624 t mounts_open
+c019477e t mountstats_open
+c01948a7 t proc_info_read
+c01949ca t mem_read
+c0194c4a t oom_adjust_read
+c0194d45 t oom_adjust_write
+c0194eb9 t proc_coredump_filter_read
+c0194fed t proc_coredump_filter_write
+c0195146 t proc_base_revalidate
+c019524e T proc_pid_lookup
+c01953ad T proc_pid_readdir
+c01955b3 t proc_task_lookup
+c0195780 t proc_task_readdir
+c0195acc t proc_file_lseek
+c0195b02 t proc_delete_dentry
+c0195b08 t proc_match
+c0195b2e t xlate_proc_name
+c0195bc4 T free_proc_entry
+c0195c24 T remove_proc_entry
+c0195da2 t proc_getattr
+c0195dc1 t proc_create
+c0195eab t proc_register
+c0195fab T create_proc_entry
+c019604b T proc_mkdir_mode
+c019609f T proc_mkdir
+c01960ab T proc_readdir
+c01962ec T proc_symlink
+c019637a t proc_file_read
+c01965b1 t proc_file_write
+c01965e5 t proc_notify_change
+c0196626 t proc_follow_link
+c0196639 T proc_lookup
+c019677c T proc_pid_statm
+c0196823 t collect_sigign_sigcatch
+c0196854 t render_sigset_t
+c0196925 t do_task_stat
+c01973a8 T proc_tgid_stat
+c01973b2 T proc_tid_stat
+c01973b9 T proc_pid_status
+c0197a40 t t_next
+c0197a5e T proc_tty_register_driver
+c0197ab9 t tty_drivers_open
+c0197ac5 t show_tty_range
+c0197c59 t show_tty_driver
+c0197e1d t t_stop
+c0197e27 t t_start
+c0197e6a t tty_ldiscs_read_proc
+c0197f18 T proc_tty_unregister_driver
+c0197f40 t proc_calc_metrics
+c0197f77 t devinfo_start
+c0197f8c t devinfo_next
+c0197faf t devinfo_stop
+c0197fb0 t int_seq_start
+c0197fc5 t int_seq_next
+c0197fe8 t int_seq_stop
+c0197fe9 T create_seq_entry
+c0197fff t execdomains_read_proc
+c0198037 t locks_read_proc
+c019805c t cmdline_read_proc
+c01980ac t filesystems_read_proc
+c01980e4 t write_sysrq_trigger
+c019810d t interrupts_open
+c0198119 t slabinfo_open
+c0198125 t modules_open
+c0198131 t diskstats_open
+c019813d t partitions_open
+c0198149 t vmstat_open
+c0198155 t devinfo_open
+c0198161 t cpuinfo_open
+c019816d t zoneinfo_open
+c0198179 t fragmentation_open
+c0198185 t stat_open
+c01981fc t show_stat
+c019886e t devinfo_show
+c01988c6 t loadavg_read_proc
+c0198a05 t uptime_read_proc
+c0198ad4 t meminfo_read_proc
+c0198ea6 t version_read_proc
+c0198f30 t proc_sys_refresh_inode
+c0198f71 T proc_sys_init
+c0198f99 t proc_sys_lookup_table_one
+c0198fdb t proc_sys_lookup_table
+c0199024 t do_proc_sys_lookup
+c0199061 t proc_sys_revalidate
+c0199094 t proc_sys_make_inode
+c01990fd t proc_sys_readdir
+c01993f9 t proc_sys_write
+c0199485 t proc_sys_read
+c019950e t proc_sys_setattr
+c0199536 t proc_sys_permission
+c01995cb t proc_sys_lookup
+c0199624 t proc_net_ns_exit
+c0199642 t proc_net_ns_init
+c0199699 T proc_net_init
+c01996c2 t proc_net_shadow_dentry
+c0199727 t proc_net_setattr
+c0199771 t proc_net_lookup
+c01997b9 t proc_net_follow_link
+c01997f0 t notesize
+c0199818 t open_kcore
+c0199828 t storenote
+c01998a7 T kclist_add
+c01998d2 t read_kcore
+c0199efc t open_vmcore
+c0199eff t read_from_oldmem
+c0199f8e t read_vmcore
+c019a1e8 t kmsg_poll
+c019a212 t kmsg_read
+c019a248 t kmsg_release
+c019a256 t kmsg_open
+c019a264 t part_attr_show
+c019a27d t part_attr_store
+c019a29c t part_stat_read
+c019a2df t part_size_read
+c019a306 t part_start_read
+c019a32c t part_dev_read
+c019a36a t part_uevent_store
+c019a37e t part_release
+c019a386 t make_block_name
+c019a405 T read_dev_sector
+c019a474 T delete_partition
+c019a4ff T del_gendisk
+c019a600 T disk_name
+c019a688 T bdevname
+c019a6a1 T add_partition
+c019a7dd T __bdevname
+c019a815 T register_disk
+c019a9f0 T rescan_partitions
+c019ac58 t parse_solaris_x86
+c019ac59 t parse_freebsd
+c019ac5a t parse_netbsd
+c019ac5b t parse_openbsd
+c019ac5c t parse_unixware
+c019ac5d t parse_minix
+c019ac5e T msdos_partition
+c019b1e0 T sysfs_hash_and_remove
+c019b264 T sysfs_instantiate
+c019b293 T sysfs_init_inode
+c019b347 T sysfs_get_inode
+c019b375 T sysfs_setattr
+c019b4f0 t subsys_attr_store
+c019b518 t sysfs_poll
+c019b57f t sysfs_open_file
+c019b695 t sysfs_write_file
+c019b792 T sysfs_schedule_callback
+c019b822 t sysfs_schedule_callback_work
+c019b848 T sysfs_remove_file_from_group
+c019b882 T sysfs_remove_file
+c019b890 T sysfs_add_file
+c019b914 T sysfs_create_file
+c019b941 T sysfs_notify
+c019b9b1 t subsys_attr_show
+c019b9d3 t sysfs_release
+c019ba12 T sysfs_add_file_to_group
+c019ba51 T sysfs_chmod_file
+c019baff T sysfs_update_file
+c019bbee t sysfs_read_file
+c019bce4 T sysfs_unlink_sibling
+c019bd07 t sysfs_ilookup_test
+c019bd14 T sysfs_find_dirent
+c019bd46 T sysfs_remove_one
+c019bd7c t sysfs_empty_dir
+c019bdb5 t __remove_dir
+c019bdcd T sysfs_get_active
+c019bdf7 T sysfs_link_sibling
+c019be10 T sysfs_add_one
+c019be6e t sysfs_attach_dentry
+c019bee5 t sysfs_free_ino
+c019bf09 T sysfs_addrm_start
+c019bf8d T release_sysfs_dirent
+c019bff5 t sysfs_dir_close
+c019c022 T sysfs_addrm_finish
+c019c224 t remove_dir
+c019c24b T sysfs_remove_dir
+c019c2bd T sysfs_remove_subdir
+c019c2c2 T sysfs_new_dirent
+c019c3a8 T sysfs_resolve_for_create
+c019c4de t sysfs_dir_open
+c019c573 t create_dir
+c019c61b T sysfs_create_dir
+c019c675 T sysfs_create_subdir
+c019c68b T sysfs_put_active
+c019c6a9 T sysfs_put_active_two
+c019c6c0 T sysfs_get_active_two
+c019c6f0 T sysfs_get_dentry
+c019c87f T sysfs_enable_shadowing
+c019c8ea t sysfs_lookup
+c019ca14 t sysfs_readdir
+c019cb99 t sysfs_dir_lseek
+c019cc59 T sysfs_resolve_for_remove
+c019cc8f T sysfs_get_dirent
+c019ccf4 T sysfs_move_dir
+c019cebc t sysfs_d_iput
+c019cf05 T sysfs_rename_dir
+c019d101 t sysfs_shadow_follow_link
+c019d180 t sysfs_put_link
+c019d196 t sysfs_follow_link
+c019d2b7 T sysfs_remove_link
+c019d2c1 T sysfs_delete_link
+c019d2cf T sysfs_create_link
+c019d433 T sysfs_rename_link
+c019d454 t sysfs_get_sb
+c019d465 t sysfs_fill_super
+c019d510 t release
+c019d554 t open
+c019d646 t mmap
+c019d6c3 t write
+c019d804 t read
+c019d94a T sysfs_remove_bin_file
+c019d986 T sysfs_create_bin_file
+c019d9b4 t remove_files
+c019d9d8 T sysfs_remove_group
+c019da71 T sysfs_create_group
+c019db58 t devpts_get_sb
+c019db69 t devpts_readdir
+c019db7a t devpts_remount
+c019dc77 t get_node
+c019dcc1 t devpts_filter
+c019dcf5 t devpts_fill_super
+c019ddd6 t devpts_permission
+c019de0e T devpts_pty_new
+c019df74 T devpts_get_tty
+c019dfab T devpts_pty_kill
+c019dfec T dcookie_unregister
+c019e0b3 T get_dcookie
+c019e14b T dcookie_register
+c019e232 T sys_lookup_dcookie
+c019e324 t goal_in_my_reservation
+c019e371 t ext3_group_sparse
+c019e3bf T ext3_get_group_desc
+c019e465 t ext3_has_free_blocks
+c019e605 t read_block_bitmap
+c019e666 t ext3_test_allocatable
+c019e6c2 t bitmap_search_next_usable_block
+c019e742 t ext3_try_to_allocate
+c019e9cb t rsv_window_remove
+c019e9f5 t __rsv_window_dump
+c019eae6 T ext3_free_blocks_sb
+c019ee71 T ext3_free_blocks
+c019ef98 T ext3_rsv_window_add
+c019effe t ext3_try_to_allocate_with_rsv
+c019f433 T ext3_new_blocks
+c019fbe5 T ext3_new_block
+c019fc0a T ext3_should_retry_alloc
+c019fc3d T ext3_count_free_blocks
+c019fc79 T ext3_bg_has_super
+c019fc9e T ext3_bg_num_gdb
+c019fd11 T ext3_init_block_alloc_info
+c019fd74 T ext3_discard_reservation
+c019fdc8 t get_dtype
+c019fde7 T ext3_check_dir_entry
+c019fe9e t free_rb_tree_fname
+c019ff0b T ext3_htree_free_dir_info
+c019ff1b t ext3_release_dir
+c019ff2d t call_filldir
+c019fff6 T ext3_htree_store_dirent
+c01a00c4 t ext3_readdir
+c01a06c8 t ext3_file_write
+c01a0757 t ext3_release_file
+c01a07b8 T ext3_sync_file
+c01a0874 T ext3_count_dirs
+c01a08a6 t read_inode_bitmap
+c01a0909 T ext3_count_free_inodes
+c01a0940 T ext3_orphan_get
+c01a0afe T ext3_new_inode
+c01a15aa T ext3_free_inode
+c01a18e4 t ext3_inode_is_fast_symlink
+c01a1922 t blocks_for_truncate
+c01a1979 t verify_chain
+c01a1999 t walk_page_buffers
+c01a19fd t bget_one
+c01a1a04 t bput_one
+c01a1a0b T ext3_set_aops
+c01a1a8d T ext3_set_inode_flags
+c01a1b07 T ext3_get_inode_flags
+c01a1b4f t start_transaction
+c01a1b89 T ext3_mark_iloc_dirty
+c01a1ecd t __ext3_get_inode_loc
+c01a21c9 T ext3_get_inode_loc
+c01a21da T ext3_reserve_inode_write
+c01a2237 T ext3_mark_inode_dirty
+c01a2271 t try_to_extend_transaction
+c01a2297 t ext3_journal_test_restart
+c01a22ab t ext3_block_to_path
+c01a23c9 t ext3_get_branch
+c01a2494 t ext3_journalled_set_page_dirty
+c01a249e t ext3_writepage_trans_blocks
+c01a2521 t ext3_readpages
+c01a2536 t ext3_readpage
+c01a2542 T ext3_journal_dirty_data
+c01a2574 t journal_dirty_data_fn
+c01a2586 T ext3_get_blocks_handle
+c01a2db4 T ext3_getblk
+c01a3009 t ext3_get_block
+c01a30d9 T ext3_forget
+c01a3196 t ext3_clear_blocks
+c01a3284 t ext3_free_data
+c01a3355 t ext3_free_branches
+c01a3503 T ext3_truncate
+c01a3d65 t commit_write_fn
+c01a3d8f T ext3_bread
+c01a3e0f t do_journal_get_write_access
+c01a3e34 t ext3_invalidatepage
+c01a3e61 t ext3_releasepage
+c01a3ed3 t ext3_bmap
+c01a3f43 T ext3_change_inode_journal_flag
+c01a3ffc t ext3_ordered_commit_write
+c01a40cf t ext3_journalled_commit_write
+c01a41d6 T ext3_write_inode
+c01a4209 t ext3_writeback_commit_write
+c01a42f4 T ext3_delete_inode
+c01a43ae t ext3_prepare_write
+c01a44ff t ext3_ordered_writepage
+c01a4688 t ext3_writeback_writepage
+c01a4757 t ext3_journalled_writepage
+c01a4896 t ext3_direct_IO
+c01a4a30 T ext3_sync_flags
+c01a4b10 T ext3_setattr
+c01a4d16 T ext3_dirty_inode
+c01a4d83 T ext3_read_inode
+c01a509c T ext3_ioctl
+c01a5630 t ext3_update_dx_flag
+c01a564f t ext3_append
+c01a56d0 t ext3_delete_entry
+c01a577b t dx_insert_block
+c01a582e t empty_dir
+c01a5aa4 t add_dirent_to_buf
+c01a5cf3 t do_split
+c01a6121 t ext3_htree_next_block
+c01a61e1 t dx_release
+c01a620f t dx_probe
+c01a64ca t ext3_add_entry
+c01a6c46 t ext3_find_entry
+c01a71dc t ext3_add_nondir
+c01a7216 T ext3_orphan_add
+c01a7369 t htree_dirblock_to_tree
+c01a748d T ext3_htree_fill_tree
+c01a7647 t ext3_create
+c01a7729 t ext3_mknod
+c01a7809 t ext3_symlink
+c01a79a3 t ext3_link
+c01a7a74 T ext3_get_parent
+c01a7b5e t ext3_mkdir
+c01a7db5 T ext3_orphan_del
+c01a7f09 t ext3_rmdir
+c01a80ab t ext3_unlink
+c01a8233 t ext3_rename
+c01a865a t ext3_lookup
+c01a8720 t ext3_get_sb
+c01a8745 t ext3_init_journal_params
+c01a878a t ext3_decode_error
+c01a87fd T ext3_journal_abort_handle
+c01a885b t ext3_commit_super
+c01a88a9 t ext3_mark_recovery_complete
+c01a8902 t ext3_write_super
+c01a891b t ext3_alloc_inode
+c01a8958 t parse_options
+c01a8eb3 t ext3_blkdev_put
+c01a8ec3 t ext3_blkdev_remove
+c01a8eea t ext3_get_journal
+c01a8fb8 t destroy_inodecache
+c01a8fc2 T ext3_warning
+c01a9012 t ext3_clear_journal_err
+c01a90ab T ext3_update_dynamic_rev
+c01a90f9 t ext3_setup_super
+c01a9268 t ext3_handle_error
+c01a930c T __ext3_std_error
+c01a9367 T ext3_error
+c01a93c1 T __ext3_journal_stop
+c01a93f5 t init_once
+c01a943c T ext3_abort
+c01a94fc T ext3_journal_start_sb
+c01a9543 t ext3_write_dquot
+c01a95a4 t ext3_write_info
+c01a95f0 t ext3_show_options
+c01a96cd T ext3_force_commit
+c01a96ed t ext3_sync_fs
+c01a972f t ext3_write_super_lockfs
+c01a977e t ext3_unlockfs
+c01a97c9 t ext3_remount
+c01a9a46 t ext3_statfs
+c01a9b68 t ext3_mark_dquot_dirty
+c01a9b9d t ext3_quota_on
+c01a9c52 t ext3_destroy_inode
+c01a9c62 t ext3_clear_inode
+c01a9cd8 t ext3_get_dentry
+c01a9d6d t ext3_put_super
+c01a9f24 t ext3_fill_super
+c01ab38f t ext3_quota_read
+c01ab4f7 t ext3_quota_write
+c01ab72d t ext3_dquot_initialize
+c01ab787 t ext3_dquot_drop
+c01ab7db t ext3_acquire_dquot
+c01ab83c t ext3_release_dquot
+c01ab8a0 t ext3_follow_link
+c01ab8b4 t str2hashbuf
+c01ab949 T ext3fs_dirhash
+c01abb10 t ext3_list_backups
+c01abb5d t verify_reserved_gdb
+c01abc0e t mark_bitmap_end
+c01abc57 t update_backups
+c01abe7f t bclean
+c01abf1c T ext3_group_extend
+c01ac21d T ext3_group_add
+c01ad544 T __ext3_journal_dirty_metadata
+c01ad57e T __ext3_journal_get_create_access
+c01ad5b8 T __ext3_journal_revoke
+c01ad5f6 T __ext3_journal_forget
+c01ad630 T __ext3_journal_get_write_access
+c01ad66a T __ext3_journal_get_undo_access
+c01ad6a4 t ext3_xattr_check_names
+c01ad6c5 t ext3_xattr_list_entries
+c01ad73a t ext3_xattr_rehash
+c01ad7b9 T exit_ext3_xattr
+c01ad7d2 T ext3_xattr_put_super
+c01ad7dd t ext3_xattr_release_block
+c01ad9eb t ext3_xattr_find_entry
+c01ada9a t ext3_xattr_set_entry
+c01add58 t ext3_xattr_ibody_set
+c01addc1 t ext3_xattr_cache_insert
+c01ade1b t ext3_xattr_block_set
+c01ae740 T ext3_xattr_set_handle
+c01aebb9 T ext3_xattr_set
+c01aec5f T ext3_xattr_list
+c01aedf0 T ext3_listxattr
+c01aedf8 T ext3_xattr_get
+c01af02f T ext3_xattr_delete_inode
+c01af104 t ext3_xattr_user_set
+c01af16e t ext3_xattr_user_list
+c01af1c5 t ext3_xattr_user_get
+c01af228 t ext3_xattr_trusted_set
+c01af27c t ext3_xattr_trusted_get
+c01af2c7 t ext3_xattr_trusted_list
+c01af324 t ext3_xattr_list_acl_default
+c01af363 t ext3_set_acl
+c01af5c1 t ext3_xattr_set_acl
+c01af6d1 t ext3_xattr_set_acl_default
+c01af711 t ext3_get_acl
+c01af9e7 t ext3_xattr_get_acl
+c01afa4d T ext3_permission
+c01afa57 t ext3_xattr_get_acl_access
+c01afa97 t ext3_xattr_get_acl_default
+c01afad7 t ext3_xattr_set_acl_access
+c01afb17 t ext3_xattr_list_acl_access
+c01afb55 t ext3_check_acl
+c01afba2 T ext3_init_acl
+c01afcef T ext3_acl_chmod
+c01afe3c t ext3_xattr_security_set
+c01afe90 T ext3_init_security
+c01afe93 t ext3_xattr_security_get
+c01afede t ext3_xattr_security_list
+c01aff1c T journal_release_buffer
+c01aff1d t __journal_temp_unlink_buffer
+c01b009b T __journal_file_buffer
+c01b02a0 T __journal_unfile_buffer
+c01b02b1 T __journal_refile_buffer
+c01b0394 T journal_refile_buffer
+c01b03f3 t __dispose_buffer
+c01b0435 T journal_stop
+c01b060c t do_get_write_access
+c01b0ac8 T journal_get_write_access
+c01b0aee T journal_unlock_updates
+c01b0b66 T journal_lock_updates
+c01b0c2a t start_this_handle
+c01b0f62 T journal_start
+c01b103f T journal_force_commit
+c01b105a T journal_invalidatepage
+c01b13b1 T journal_extend
+c01b143f T journal_restart
+c01b1557 T journal_get_create_access
+c01b16c4 T journal_get_undo_access
+c01b17c0 T journal_dirty_data
+c01b19a9 T journal_dirty_metadata
+c01b1b60 T journal_forget
+c01b1d60 T journal_unfile_buffer
+c01b1db2 T journal_try_to_free_buffers
+c01b1ef5 T journal_file_buffer
+c01b1f54 t inverted_lock
+c01b1f7b t journal_do_submit_data
+c01b1fa6 t journal_end_buffer_io_sync
+c01b1fbb T journal_commit_transaction
+c01b2fc0 t journal_brelse_array
+c01b2fde t jread
+c01b31ce t do_one_pass
+c01b35f1 T journal_skip_recovery
+c01b364f T journal_recover
+c01b36dc T __journal_drop_transaction
+c01b39ab T __journal_remove_checkpoint
+c01b3a35 t journal_clean_one_cp_list
+c01b3b0d t jbd_sync_bh
+c01b3b4e T cleanup_journal_tail
+c01b3c43 t __flush_batch
+c01b3c7a T log_do_checkpoint
+c01b4070 T __journal_insert_checkpoint
+c01b411e T __log_wait_for_space
+c01b41ab T __journal_clean_checkpoint_list
+c01b4218 T journal_switch_revoke_table
+c01b4258 T journal_clear_revoke
+c01b42a2 t find_revoke_record
+c01b431e T journal_test_revoke
+c01b433a t insert_revoke_hash
+c01b43c2 t flush_descriptor
+c01b4400 T journal_revoke
+c01b451a T journal_destroy_revoke_caches
+c01b4543 T journal_destroy_revoke
+c01b4638 T journal_write_revoke_records
+c01b4761 T journal_cancel_revoke
+c01b47fe T journal_set_revoke
+c01b4834 T journal_init_revoke
+c01b4a3c T journal_check_available_features
+c01b4a6f T journal_blocks_per_page
+c01b4a88 t journal_destroy_caches
+c01b4b0f t journal_fail_superblock
+c01b4b27 T journal_check_used_features
+c01b4b76 t journal_free_journal_head
+c01b4b82 T jbd_slab_free
+c01b4b9d t __journal_remove_journal_head
+c01b4d26 T __log_space_left
+c01b4d4a T journal_put_journal_head
+c01b4dd4 T jbd_slab_alloc
+c01b4dee T journal_add_journal_head
+c01b4f2e T __jbd_kmalloc
+c01b4f44 T journal_ack_err
+c01b4f64 T journal_clear_err
+c01b4f93 T journal_errno
+c01b4fbc t journal_get_superblock
+c01b50df t load_superblock
+c01b5128 T journal_update_format
+c01b51b0 T journal_update_superblock
+c01b5253 T journal_wipe
+c01b52ff T __log_start_commit
+c01b5333 T __journal_abort_hard
+c01b53a1 t __journal_abort_soft
+c01b53d1 T journal_abort
+c01b53d3 T journal_start_commit
+c01b542d T log_start_commit
+c01b5456 T log_wait_commit
+c01b553c T journal_flush
+c01b572c T journal_force_commit_nested
+c01b578b T journal_destroy
+c01b595f t journal_reset
+c01b5a59 t commit_timeout
+c01b5a5e t journal_init_common
+c01b5b63 T journal_bmap
+c01b5bd1 T journal_init_inode
+c01b5cf9 T journal_next_log_block
+c01b5d89 T journal_create
+c01b5eef T journal_load
+c01b5fd0 T journal_set_features
+c01b6022 t kjournald
+c01b620e T journal_grab_journal_head
+c01b6251 T journal_remove_journal_head
+c01b6287 T journal_write_metadata_buffer
+c01b653d T journal_init_dev
+c01b6624 T journal_get_descriptor_buffer
+c01b66b4 t ext2_group_sparse
+c01b66fa T ext2_get_group_desc
+c01b678c t release_blocks
+c01b67a7 t group_release_blocks
+c01b6802 t group_reserve_blocks
+c01b684f t read_block_bitmap
+c01b68b0 t grab_block
+c01b6957 T ext2_count_free_blocks
+c01b6989 T ext2_bg_has_super
+c01b69ae T ext2_bg_num_gdb
+c01b69da T ext2_free_blocks
+c01b6cea T ext2_new_block
+c01b7618 t ext2_last_byte
+c01b762f t ext2_get_page
+c01b786e t ext2_commit_chunk
+c01b78c3 T ext2_find_entry
+c01b7a79 T ext2_make_empty
+c01b7bd0 T ext2_dotdot
+c01b7bf9 t ext2_readdir
+c01b7ea6 T ext2_inode_by_name
+c01b7ed1 T ext2_delete_entry
+c01b8024 T ext2_empty_dir
+c01b810f T ext2_set_link
+c01b8207 T ext2_add_link
+c01b84d8 t ext2_release_file
+c01b84e8 T ext2_sync_file
+c01b8524 T ext2_count_dirs
+c01b8556 T ext2_count_free_inodes
+c01b8588 t read_inode_bitmap
+c01b85eb T ext2_free_inode
+c01b8814 T ext2_new_inode
+c01b9394 T ext2_set_inode_flags
+c01b940e T ext2_get_inode_flags
+c01b9456 t ext2_nobh_prepare_write
+c01b946b t ext2_nobh_writepage
+c01b9477 t ext2_direct_IO
+c01b94d9 t ext2_bmap
+c01b94ea t ext2_prepare_write
+c01b94ff t ext2_readpages
+c01b9514 t ext2_writepages
+c01b951e t ext2_readpage
+c01b952a t ext2_writepage
+c01b9536 T ext2_setattr
+c01b95d3 T ext2_sync_inode
+c01b95ff t ext2_get_inode
+c01b970d t ext2_update_inode
+c01b9a25 T ext2_write_inode
+c01b9a2a t ext2_block_to_path
+c01b9b4c T ext2_discard_prealloc
+c01b9ba5 t ext2_get_branch
+c01b9ca6 t ext2_free_branches
+c01b9e0b T ext2_truncate
+c01ba2bc t ext2_alloc_block
+c01ba35e T ext2_put_inode
+c01ba374 T ext2_sync_flags
+c01ba3e9 T ext2_get_block
+c01ba908 T ext2_read_inode
+c01bac98 T ext2_delete_inode
+c01bad08 T ext2_ioctl
+c01baee8 t ext2_unlink
+c01baf33 T ext2_get_parent
+c01bafb9 t ext2_rmdir
+c01bb016 t ext2_link
+c01bb084 t ext2_mkdir
+c01bb179 t ext2_rename
+c01bb3c7 t ext2_create
+c01bb482 t ext2_mknod
+c01bb4f2 t ext2_symlink
+c01bb60c t ext2_lookup
+c01bb670 t ext2_get_sb
+c01bb695 t ext2_sync_super
+c01bb6d8 t ext2_alloc_inode
+c01bb714 t parse_options
+c01bb87f t ext2_quota_write
+c01bba83 t init_once
+c01bbabb t destroy_inodecache
+c01bbac5 T ext2_write_super
+c01bbb38 t ext2_setup_super
+c01bbc42 T ext2_warning
+c01bbc92 T ext2_error
+c01bbd3d T ext2_update_dynamic_rev
+c01bbd8b t ext2_show_options
+c01bbde5 t ext2_remount
+c01bbf9f t ext2_statfs
+c01bc0ac t ext2_destroy_inode
+c01bc0bc t ext2_clear_inode
+c01bc11f t ext2_get_dentry
+c01bc1b4 t ext2_put_super
+c01bc246 t ext2_fill_super
+c01bcd71 t ext2_quota_read
+c01bcf0c t ext2_follow_link
+c01bcf20 T exit_ext2_xattr
+c01bcf2a T ext2_xattr_put_super
+c01bcf35 t ext2_xattr_cache_insert
+c01bcfa1 t ext2_xattr_set2
+c01bd732 T ext2_listxattr
+c01bd88c T ext2_xattr_delete_inode
+c01bdb1f T ext2_xattr_get
+c01bdcde T ext2_xattr_set
+c01be3ac t ext2_xattr_user_set
+c01be416 t ext2_xattr_user_list
+c01be46d t ext2_xattr_user_get
+c01be4d0 t ext2_xattr_trusted_set
+c01be524 t ext2_xattr_trusted_get
+c01be56f t ext2_xattr_trusted_list
+c01be5cc t ext2_xattr_list_acl_default
+c01be60b t ext2_set_acl
+c01be888 t ext2_xattr_set_acl
+c01be92b t ext2_xattr_set_acl_default
+c01be96b t ext2_get_acl
+c01bec57 t ext2_xattr_get_acl
+c01becbd T ext2_permission
+c01becc7 t ext2_xattr_get_acl_access
+c01bed07 t ext2_xattr_get_acl_default
+c01bed47 t ext2_xattr_set_acl_access
+c01bed87 t ext2_xattr_list_acl_access
+c01bedc5 t ext2_check_acl
+c01bee12 T ext2_init_acl
+c01bef51 T ext2_acl_chmod
+c01bf004 t ext2_xattr_security_set
+c01bf058 T ext2_init_security
+c01bf05b t ext2_xattr_security_get
+c01bf0a6 t ext2_xattr_security_list
+c01bf0e4 T ext2_get_xip_page
+c01bf1c2 T ext2_xip_verify_sb
+c01bf211 T ext2_clear_xip_target
+c01bf258 t cramfs_remount
+c01bf25e t cramfs_get_sb
+c01bf283 t cramfs_put_super
+c01bf29d t cramfs_read
+c01bf45d t get_cramfs_inode
+c01bf4b8 t cramfs_iget5_set
+c01bf5da t cramfs_readdir
+c01bf793 t cramfs_readpage
+c01bf8d2 t cramfs_fill_super
+c01bfad3 t cramfs_iget5_test
+c01bfb5a t cramfs_statfs
+c01bfbc6 t cramfs_lookup
+c01bfd0c T cramfs_uncompress_exit
+c01bfd30 T cramfs_uncompress_init
+c01bfd8c T cramfs_uncompress_block
+c01bfe3c t rootfs_get_sb
+c01bfe53 T ramfs_get_sb
+c01bfe64 T ramfs_get_inode
+c01bff64 t ramfs_fill_super
+c01bffd1 t ramfs_mknod
+c01c004f t ramfs_create
+c01c005f t ramfs_mkdir
+c01c007e t ramfs_symlink
+c01c011c T isofs_lookup
+c01c048c t isofs_remount
+c01c0492 t isofs_hash_common
+c01c04dc t isofs_hashi_common
+c01c0543 t isofs_dentry_cmp_common
+c01c05a3 t isofs_hash
+c01c05aa t isofs_hashi
+c01c05b1 t isofs_dentry_cmp
+c01c05c2 t isofs_hash_ms
+c01c05cc t isofs_hashi_ms
+c01c05d6 t isofs_dentry_cmp_ms
+c01c05e7 t isofs_iget5_set
+c01c05f5 t isofs_get_sb
+c01c061a t isofs_dentry_cmpi_common
+c01c066e t isofs_dentry_cmpi_ms
+c01c067f t isofs_dentry_cmpi
+c01c0690 t _isofs_bmap
+c01c06a1 t isofs_readpage
+c01c06ad t isofs_alloc_inode
+c01c06c8 t init_once
+c01c06d0 t destroy_inodecache
+c01c06da T isofs_iget
+c01c0742 T isofs_get_blocks
+c01c09b3 t isofs_get_block
+c01c09f1 t isofs_put_super
+c01c0a22 t isofs_statfs
+c01c0a99 t isofs_destroy_inode
+c01c0aa6 t isofs_iget5_test
+c01c0ac2 T isofs_bread
+c01c0b29 t isofs_fill_super
+c01c1427 t isofs_read_inode
+c01c1a90 T isofs_name_translate
+c01c1afc T get_acorn_filename
+c01c1bcf t isofs_readdir
+c01c2034 T iso_date
+c01c210c t check_sp
+c01c2134 t setup_rock_ridge
+c01c219d t init_rock_state
+c01c21b6 t rock_check_overflow
+c01c22a0 t rock_continue
+c01c23be t parse_rock_ridge_inode_internal
+c01c2859 T parse_rock_ridge_inode
+c01c2895 T get_rock_ridge_filename
+c01c2aa5 t rock_ridge_symlink_readpage
+c01c2de8 t isofs_export_decode_fh
+c01c2e6e t isofs_export_get_dentry
+c01c2ed8 t isofs_export_encode_fh
+c01c2f7c t isofs_export_get_parent
+c01c3050 T get_joliet_filename
+c01c3154 T zisofs_cleanup
+c01c3184 t zisofs_readpage
+c01c3930 T utf8_mbtowc
+c01c3990 T utf8_mbstowcs
+c01c39dc T utf8_wctomb
+c01c3a32 T utf8_wcstombs
+c01c3a77 t uni2char
+c01c3ab0 t char2uni
+c01c3ac8 T unload_nls
+c01c3ad0 T unregister_nls
+c01c3b15 T register_nls
+c01c3b70 t find_nls
+c01c3bf8 T load_nls
+c01c3c42 T load_nls_default
+c01c3c58 t uni2char
+c01c3c91 t char2uni
+c01c3cac t uni2char
+c01c3ce5 t char2uni
+c01c3d00 t debug_get_sb
+c01c3d11 t debug_fill_super
+c01c3d20 T debugfs_remove
+c01c3df2 t debugfs_mknod
+c01c3edf T debugfs_create_file
+c01c40b5 T debugfs_create_symlink
+c01c4103 T debugfs_create_dir
+c01c4124 t default_read_file
+c01c4127 t default_write_file
+c01c412a t default_open
+c01c413d t debugfs_follow_link
+c01c4150 t debugfs_u8_set
+c01c4153 t debugfs_u8_get
+c01c4159 t debugfs_u16_set
+c01c415d t debugfs_u16_get
+c01c4163 t debugfs_u32_set
+c01c4166 t debugfs_u32_get
+c01c416b t debugfs_u64_set
+c01c4171 t debugfs_u64_get
+c01c4177 T debugfs_create_blob
+c01c4196 T debugfs_create_bool
+c01c41b5 T debugfs_create_u64
+c01c41d4 T debugfs_create_u32
+c01c41f3 T debugfs_create_u16
+c01c4212 T debugfs_create_u8
+c01c4231 t read_file_blob
+c01c425e t read_file_bool
+c01c42a2 t write_file_bool
+c01c42ff t fops_u64_open
+c01c431e t fops_u8_open
+c01c433d t fops_u16_open
+c01c435c t fops_u32_open
+c01c437c T ipc_findkey
+c01c43a6 T ipc_rcu_getref
+c01c43aa T kernel_to_ipc64_perm
+c01c43d6 T ipc64_perm_to_ipc_perm
+c01c4453 T ipc_get
+c01c4479 T ipc_buildid
+c01c4480 T ipc_checkid
+c01c449c T ipc_parse_version
+c01c44b1 T ipc_unlock
+c01c44b6 T ipc_lock_by_ptr
+c01c44bb T ipc_lock
+c01c44fe t sysvipc_proc_next
+c01c456b T ipc_rmid
+c01c45be T ipc_rcu_putref
+c01c45e4 t ipc_immediate_free
+c01c45e9 t ipc_schedule_free
+c01c460a t ipc_do_vfree
+c01c460f T ipc_free
+c01c4621 T ipc_rcu_alloc
+c01c4666 t sysvipc_proc_release
+c01c468c t sysvipc_proc_show
+c01c46ac t sysvipc_proc_stop
+c01c46d3 t sysvipc_proc_start
+c01c4755 t sysvipc_proc_open
+c01c47c7 T ipc_init_ids
+c01c484f T free_ipc_ns
+c01c4874 T ipc_addid
+c01c49b7 T ipcperms
+c01c4a29 T ipc_alloc
+c01c4a3f T copy_ipcs
+c01c4adc T free_msg
+c01c4afa T store_msg
+c01c4b66 T load_msg
+c01c4c74 t testmsg
+c01c4cb1 t expunge_all
+c01c4ce6 t ss_wakeup
+c01c4d0f T do_msgrcv
+c01c4f6f T sys_msgrcv
+c01c4fc0 T do_msgsnd
+c01c51fd T sys_msgsnd
+c01c523c t freeque
+c01c529f t newque
+c01c5377 t __msg_init_ns
+c01c539d t sysvipc_msg_proc_show
+c01c5417 T msg_exit_ns
+c01c5477 T msg_init_ns
+c01c54a1 T sys_msgget
+c01c5564 T sys_msgctl
+c01c5a40 t try_atomic_semop
+c01c5b52 t lookup_undo
+c01c5b82 t update_queue
+c01c5bff T exit_sem
+c01c5d49 T copy_semundo
+c01c5dbe T sys_semtimedop
+c01c63e6 T sys_semop
+c01c6411 t copy_semid_to_user
+c01c6466 t freeary
+c01c6502 T sem_exit_ns
+c01c6562 t newary
+c01c6680 t __sem_init_ns
+c01c66b4 T sem_init_ns
+c01c66de t sysvipc_sem_proc_show
+c01c673c T sys_semget
+c01c683d T sys_semctl
+c01c6fe8 t shm_fault
+c01c6ff8 t shm_fsync
+c01c701c T is_file_shm_hugepages
+c01c701f T sys_shmdt
+c01c712b t shm_open
+c01c716c t shm_mmap
+c01c71aa t shm_destroy
+c01c7279 t do_shm_rmid
+c01c729c T shm_exit_ns
+c01c72fa t shm_get_unmapped_area
+c01c730a t shm_release
+c01c7337 T do_shmat
+c01c769f T sys_shmat
+c01c76c5 t newseg
+c01c78f0 t __shm_init_ns
+c01c791d t sysvipc_shm_proc_show
+c01c7997 T shm_init_ns
+c01c79c1 T sys_shmget
+c01c7aa3 t shm_close
+c01c7b15 T sys_shmctl
+c01c8134 t sysctl_ipc_data
+c01c81cf t proc_ipc_doulongvec_minmax
+c01c8222 t proc_ipc_dointvec
+c01c8278 t msg_insert
+c01c82cb t mqueue_get_sb
+c01c82dc t mqueue_alloc_inode
+c01c82f7 t mqueue_unlink
+c01c8336 t remove_notification
+c01c8385 t mqueue_get_inode
+c01c8667 t mqueue_create
+c01c872f t mqueue_fill_super
+c01c8782 t init_once
+c01c878a T sys_mq_getsetattr
+c01c888b t prepare_timeout
+c01c891d t wq_sleep
+c01c8a05 t do_open
+c01c8a90 t mqueue_destroy_inode
+c01c8a9d t mqueue_delete_inode
+c01c8b94 t mqueue_read_file
+c01c8cc6 t mqueue_flush_file
+c01c8d03 t mqueue_poll_file
+c01c8d5c T sys_mq_timedreceive
+c01c8f3c T sys_mq_unlink
+c01c901d T sys_mq_timedsend
+c01c92c5 T sys_mq_notify
+c01c958c T sys_mq_open
+c01c97d8 T cap_netlink_recv
+c01c97ea T cap_capable
+c01c9862 T cap_capget
+c01c9883 T cap_capset_set
+c01c98a0 T cap_task_reparent_to_init
+c01c98c6 T cap_vm_enough_memory
+c01c98e8 T cap_inode_removexattr
+c01c9922 T cap_settime
+c01c9932 T cap_ptrace
+c01c995c T cap_inode_setxattr
+c01c9996 T cap_netlink_send
+c01c99f1 T cap_bprm_set_security
+c01c9a5c T cap_bprm_secureexec
+c01c9a8a T cap_task_post_setuid
+c01c9ba0 T cap_syslog
+c01c9bed T cap_capset_check
+c01c9c2f T cap_bprm_apply_creds
+c01c9d78 T crypto_mod_get
+c01c9da0 t crypto_exit_ops
+c01c9dde T crypto_shoot_alg
+c01c9dfa T __crypto_alloc_tfm
+c01c9f00 T crypto_mod_put
+c01c9f2a T crypto_free_tfm
+c01c9f86 t crypto_larval_wait
+c01c9fc8 t crypto_larval_destroy
+c01c9fec T __crypto_alg_lookup
+c01ca0df t crypto_alg_lookup
+c01ca10f T crypto_alg_mod_lookup
+c01ca2d1 T crypto_has_alg
+c01ca2ec T crypto_alloc_base
+c01ca34c T scatterwalk_map
+c01ca395 T scatterwalk_start
+c01ca3aa t scatterwalk_pagedone
+c01ca3e5 T scatterwalk_copychunks
+c01ca4b1 T scatterwalk_done
+c01ca4c4 t setkey
+c01ca4f9 T crypto_exit_cipher_ops
+c01ca4fa t cipher_crypt_unaligned
+c01ca571 t cipher_encrypt_unaligned
+c01ca5a8 t cipher_decrypt_unaligned
+c01ca5df T crypto_init_cipher_ops
+c01ca624 t init
+c01ca632 t setkey
+c01ca644 T crypto_init_digest_ops
+c01ca6a4 T crypto_exit_digest_ops
+c01ca6a5 t update2
+c01ca7f9 t final
+c01ca84d t digest
+c01ca8db t update
+c01ca944 t nosetkey
+c01ca950 t crypto_compress
+c01ca972 t crypto_decompress
+c01ca994 T crypto_init_compress_ops
+c01ca9a5 T crypto_exit_compress_ops
+c01ca9a8 t elv_iosched_allow_merge
+c01ca9cd T elv_rq_merge_ok
+c01caa15 t elevator_find
+c01caa51 t elevator_init_queue
+c01caa57 t elv_rqhash_del
+c01caa84 T elv_rb_find
+c01caac0 T elv_queue_empty
+c01caade T elv_latter_request
+c01caaf5 T elv_former_request
+c01cab0c T elv_set_request
+c01cab2e T elv_put_request
+c01cab3f T elv_may_queue
+c01cab56 T elv_rb_latter_request
+c01cab6a T elv_rb_former_request
+c01cab7e T elv_iosched_show
+c01cac38 t elv_drain_elevator
+c01cac90 T elv_dequeue_request
+c01cacc8 t elv_rqhash_add
+c01cad11 t elv_rqhash_reposition
+c01cad3f T elv_merge_requests
+c01cad79 T elv_merged_request
+c01cada9 t elevator_get
+c01cadf1 t elevator_put
+c01cadf9 t elevator_release
+c01cae17 t elv_attr_store
+c01cae6b t elv_attr_show
+c01caebb T elevator_exit
+c01caeed t elevator_alloc
+c01cafad T elevator_init
+c01cb086 t __elv_unregister_queue
+c01cb0a0 T elv_unregister_queue
+c01cb0aa T elv_unregister
+c01cb13e T elv_register_queue
+c01cb18f T elv_completed_request
+c01cb1fd T elv_next_request
+c01cb3a8 T elv_insert
+c01cb592 T __elv_add_request
+c01cb614 T elv_add_request
+c01cb657 T elv_requeue_request
+c01cb69c T elv_rb_del
+c01cb6ca T elv_rb_add
+c01cb737 T elv_register
+c01cb7dd T elv_iosched_store
+c01cb96a T elv_dispatch_sort
+c01cba16 T elv_merge
+c01cbbc5 T elv_dispatch_add_tail
+c01cbc0c t blk_queue_congestion_threshold
+c01cbc42 T blk_queue_prep_rq
+c01cbc46 T blk_queue_merge_bvec
+c01cbc4a T blk_queue_softirq_done
+c01cbc4e t rq_init
+c01cbce0 T blk_queue_issue_flush_fn
+c01cbce4 T blk_ordered_cur_seq
+c01cbcfa T blk_queue_hardsect_size
+c01cbd02 T blk_queue_dma_alignment
+c01cbd09 t blk_phys_contig_segment
+c01cbd9f t ioc_set_batching
+c01cbdcf T blkdev_issue_flush
+c01cbdff T disk_round_stats
+c01cbe61 t drive_stat_acct
+c01cbea6 t blk_done_softirq
+c01cbef5 T swap_io_context
+c01cbf00 T blk_unregister_queue
+c01cbf3e T blk_put_queue
+c01cbf48 T blk_register_queue
+c01cbfb2 T blk_recount_segments
+c01cc16d t blk_hw_contig_segment
+c01cc1fe T blk_ordered_req_seq
+c01cc264 T blk_queue_find_tag
+c01cc283 t current_io_context
+c01cc2eb T put_io_context
+c01cc339 T copy_io_context
+c01cc35b T kblockd_flush_work
+c01cc360 T kblockd_schedule_work
+c01cc36c T ll_back_merge_fn
+c01cc4c7 T blk_rq_bio_prep
+c01cc54c t init_request_from_bio
+c01cc623 T blk_dump_rq_flags
+c01cc700 T blk_queue_end_tag
+c01cc79d T blk_queue_segment_boundary
+c01cc7d7 T blk_queue_max_segment_size
+c01cc811 T blk_queue_max_hw_segments
+c01cc84b T blk_queue_max_phys_segments
+c01cc885 T blk_queue_max_sectors
+c01cc8df T blk_queue_ordered
+c01cc942 t ordered_bio_endio
+c01cc9a3 t __end_that_request_first
+c01ccdc0 T end_that_request_chunk
+c01ccdc5 T end_that_request_first
+c01ccdcd t handle_bad_sector
+c01cce68 T generic_make_request
+c01cd1a6 t blk_unplug_timeout
+c01cd220 t __freed_request
+c01cd295 t freed_request
+c01cd2cc T __blk_put_request
+c01cd341 T end_that_request_last
+c01cd3ee T end_request
+c01cd420 T blk_ordered_complete_seq
+c01cd497 t post_flush_end_io
+c01cd4b8 t bar_end_io
+c01cd4d9 t pre_flush_end_io
+c01cd4fa T blk_end_sync_rq
+c01cd51d T blk_put_request
+c01cd553 T blk_rq_map_kern
+c01cd5c9 t __blk_rq_unmap_user
+c01cd5e2 T blk_rq_unmap_user
+c01cd61a T blk_rq_map_user
+c01cd7d4 T blk_requeue_request
+c01cd88a t get_request
+c01cdb3c t attempt_merge
+c01cdce4 T blk_alloc_queue_node
+c01cdd7b T blk_alloc_queue
+c01cdd83 t queue_var_store
+c01cdda5 t queue_max_sectors_store
+c01cde12 t queue_ra_store
+c01cde4a t queue_var_show
+c01cde65 t queue_max_hw_sectors_show
+c01cde6f t queue_max_sectors_show
+c01cde79 t queue_ra_show
+c01cde84 t queue_requests_show
+c01cde8c t queue_attr_store
+c01cdeea t __blk_free_tags
+c01cdf3f T blk_free_tags
+c01cdf4d T blk_cleanup_queue
+c01cdf83 T blk_sync_queue
+c01cdf8d t blk_release_queue
+c01cdfdb T blk_remove_plug
+c01ce039 T __generic_unplug_device
+c01ce058 T blk_execute_rq_nowait
+c01ce0e4 T blk_execute_rq
+c01ce1c9 T blk_start_queueing
+c01ce1e2 T blk_insert_request
+c01ce25f t get_request_wait
+c01ce3cb T blk_get_request
+c01ce428 T generic_unplug_device
+c01ce449 T blk_plug_device
+c01ce4f6 T blk_run_queue
+c01ce559 t init_tag_map
+c01ce5e8 T blk_queue_resize_tags
+c01ce6ac t __blk_queue_init_tags
+c01ce6ff T blk_init_tags
+c01ce705 T blk_queue_bounce_limit
+c01ce741 T blk_queue_make_request
+c01ce817 T blk_init_queue_node
+c01ce96b T blk_init_queue
+c01ce973 t queue_flush
+c01ce9da t flush_dry_bio_endio
+c01cea4a T blk_stop_queue
+c01cea5d T blk_queue_free_tags
+c01cea67 T blk_queue_stack_limits
+c01ceb35 T blk_get_queue
+c01ceb56 t queue_attr_show
+c01cebb0 T blk_complete_request
+c01cebeb T blk_start_queue
+c01cec62 T blk_rq_map_sg
+c01ced9c T blk_queue_init_tags
+c01cee13 T get_io_context
+c01cee20 T blk_queue_invalidate_tags
+c01cee9f T exit_io_context
+c01cef0a T submit_bio
+c01cefc5 T blk_get_backing_dev_info
+c01cefd8 T blk_rq_map_user_iov
+c01cf058 T blk_do_ordered
+c01cf29d T blk_queue_start_tag
+c01cf37c t __make_request
+c01cf86e t blk_backing_dev_unplug
+c01cf8e9 t blk_unplug_work
+c01cf961 t queue_requests_store
+c01cfa9c T compat_blkdev_ioctl
+c01cfae4 T blkdev_driver_ioctl
+c01cfb42 T blkdev_ioctl
+c01d01bc t exact_match
+c01d01c0 t part_next
+c01d01d8 t disk_attr_show
+c01d01f4 t disk_attr_store
+c01d0213 t diskstats_next
+c01d022b T set_device_ro
+c01d0243 T set_disk_ro
+c01d026a T bdev_read_only
+c01d028b t disk_capability_read
+c01d02a9 t disk_size_read
+c01d02d0 t disk_removable_read
+c01d02f1 t disk_range_read
+c01d030f t disk_dev_read
+c01d0340 t disk_stats_read
+c01d0607 t disk_uevent_store
+c01d061b t block_uevent
+c01d07dd t disk_release
+c01d0809 t diskstats_show
+c01d0b98 t diskstats_stop
+c01d0ba2 t part_stop
+c01d0bac t diskstats_start
+c01d0bed T unregister_blkdev
+c01d0c63 T blkdev_show
+c01d0cc0 t base_probe
+c01d0cfd T invalidate_partition
+c01d0d31 T put_disk
+c01d0d3e T get_disk
+c01d0d84 t exact_lock
+c01d0d91 T alloc_disk_node
+c01d0e79 T alloc_disk
+c01d0e81 t media_change_notify_thread
+c01d0ed2 T genhd_media_change_notify
+c01d0eeb T get_gendisk
+c01d0f05 T blk_unregister_region
+c01d0f13 T unlink_gendisk
+c01d0f2c T blk_register_region
+c01d0f60 T add_disk
+c01d0fa1 t part_start
+c01d0fe2 t block_uevent_filter
+c01d100b t show_partition
+c01d1113 T register_blkdev
+c01d11f0 t __blk_send_generic
+c01d1286 t verify_command
+c01d12e8 t sg_io
+c01d15d7 T sg_scsi_ioctl
+c01d1879 T scsi_cmd_ioctl
+c01d1be8 t noop_former_request
+c01d1bf7 t noop_latter_request
+c01d1c05 t noop_exit_queue
+c01d1c15 t noop_init_queue
+c01d1c34 t noop_add_request
+c01d1c48 t noop_merged_requests
+c01d1c58 t noop_dispatch
+c01d1c86 t noop_queue_empty
+c01d1c98 t cfq_queue_empty
+c01d1ca9 t cfq_choose_req
+c01d1eb2 t cfq_activate_request
+c01d1eed t cfq_var_store
+c01d1f0f t cfq_slice_async_rq_store
+c01d1f33 t cfq_slice_async_store
+c01d1f65 t cfq_slice_sync_store
+c01d1f97 t cfq_slice_idle_store
+c01d1fbc t cfq_back_seek_penalty_store
+c01d1fe0 t cfq_back_seek_max_store
+c01d1ffa t cfq_fifo_expire_async_store
+c01d202c t cfq_fifo_expire_sync_store
+c01d205e t cfq_quantum_store
+c01d2082 t cfq_var_show
+c01d209d t cfq_slice_async_rq_show
+c01d20a8 t cfq_slice_async_show
+c01d20be t cfq_slice_sync_show
+c01d20d4 t cfq_slice_idle_show
+c01d20ea t cfq_back_seek_penalty_show
+c01d20f5 t cfq_back_seek_max_show
+c01d2100 t cfq_fifo_expire_async_show
+c01d2119 t cfq_fifo_expire_sync_show
+c01d2132 t cfq_quantum_show
+c01d2140 t cfq_rb_erase
+c01d2161 t cfq_rb_first
+c01d2177 t cfq_free_io_context
+c01d220b t cfq_drop_dead_cic
+c01d227c t cfq_cic_rb_lookup
+c01d22c7 t cfq_deactivate_request
+c01d2308 t cfq_service_tree_add
+c01d24ca t cfq_resort_rr_list
+c01d24d8 t __cfq_slice_expired
+c01d253a t cfq_put_queue
+c01d25ab t cfq_put_request
+c01d25f2 t cfq_exit_cfqq
+c01d261b t __cfq_exit_single_io_context
+c01d2669 t cfq_shutdown_timer_wq
+c01d2684 t cfq_exit_queue
+c01d26ff t cfq_kick_queue
+c01d2727 t cfq_idle_class_timer
+c01d2775 t cfq_init_prio_data
+c01d281c t cfq_get_queue
+c01d2983 t cfq_exit_io_context
+c01d29d0 t cfq_remove_request
+c01d2b07 t cfq_dispatch_insert
+c01d2b39 t cfq_add_rq_rb
+c01d2ba4 t cfq_merged_request
+c01d2bd5 t cfq_insert_request
+c01d2fe1 t cfq_merge
+c01d3050 t cfq_slab_kill
+c01d306d t cfq_init_queue
+c01d3156 t cfq_merged_requests
+c01d3188 t cfq_dispatch_requests
+c01d33ff t cfq_may_queue
+c01d34aa t cfq_allow_merge
+c01d3504 t cfq_completed_request
+c01d376e t cfq_set_request
+c01d3a46 t cfq_idle_slice_timer
+c01d3ab0 t blk_dropped_open
+c01d3abf t blk_check_time
+c01d3b0e t blk_trace_check_cpu_time
+c01d3b2d t trace_note
+c01d3be9 t blk_trace_startstop
+c01d3c79 t blk_remove_buf_file_callback
+c01d3c81 t blk_remove_tree
+c01d3cc7 t blk_trace_remove
+c01d3d12 T blk_trace_shutdown
+c01d3d2c t blk_create_buf_file_callback
+c01d3d42 t blk_subbuf_start_callback
+c01d3d65 t blk_dropped_read
+c01d3dc9 T blk_trace_ioctl
+c01d40bb T __blk_add_trace
+c01d42b8 t skip_sep
+c01d42d2 t skip_arg
+c01d42ec T argv_free
+c01d430b T argv_split
+c01d439c T __bitmap_empty
+c01d43f6 T __bitmap_full
+c01d4453 T __bitmap_equal
+c01d44b9 T __bitmap_complement
+c01d4513 T __bitmap_and
+c01d4549 T __bitmap_or
+c01d457f T __bitmap_xor
+c01d45b5 T __bitmap_andnot
+c01d45ed T __bitmap_intersects
+c01d464e T __bitmap_subset
+c01d46bb t __reg_op
+c01d4782 T bitmap_find_free_region
+c01d47da T bitmap_release_region
+c01d47eb T bitmap_allocate_region
+c01d4827 T __bitmap_weight
+c01d488b T __bitmap_shift_left
+c01d49b1 T __bitmap_parse
+c01d4b6e T __bitmap_shift_right
+c01d4cb3 t bitmap_ord_to_pos
+c01d4d06 t bitmap_pos_to_ord
+c01d4d65 T bitmap_bitremap
+c01d4de4 T bitmap_parse_user
+c01d4e2d T bitmap_scnprintf
+c01d4ef3 T bitmap_scnlistprintf
+c01d4fe5 T bitmap_remap
+c01d50d9 T bitmap_parselist
+c01d51a4 T find_bug
+c01d5204 T report_bug
+c01d52ad T module_bug_cleanup
+c01d52b7 T module_bug_finalize
+c01d535c T memparse
+c01d53ac T get_option
+c01d53f6 T get_options
+c01d5470 T __first_cpu
+c01d548a T __next_cpu
+c01d54ab T __any_online_cpu
+c01d54d8 T _atomic_dec_and_lock
+c01d5520 t cmp_ex
+c01d5530 T search_extable
+c01d5565 T sort_extable
+c01d558c t idr_mark_full
+c01d55b7 T idr_find
+c01d55f3 t free_bitmap
+c01d5628 t free_layer
+c01d5651 t alloc_layer
+c01d5686 T idr_destroy
+c01d56a6 T ida_destroy
+c01d56b7 t idr_get_empty_slot
+c01d588d T ida_get_new_above
+c01d59f1 T ida_get_new
+c01d59fa t idr_get_new_above_int
+c01d5a38 T idr_get_new
+c01d5a5e T idr_get_new_above
+c01d5a84 T idr_pre_get
+c01d5ab3 T ida_pre_get
+c01d5b00 T idr_init
+c01d5b5f T ida_init
+c01d5b79 T idr_remove
+c01d5cbc T ida_remove
+c01d5d7b t idr_cache_ctor
+c01d5d89 T idr_replace
+c01d5df4 T int_sqrt
+c01d5e20 T ioremap_page_range
+c01d5ee8 t dir_release
+c01d5eed T kobject_get_path
+c01d5f6e T kobject_put
+c01d5f80 T kobject_cleanup
+c01d5fd4 t kobject_release
+c01d5fdc t unlink
+c01d6015 T kobject_get
+c01d6028 T subsys_create_file
+c01d6069 T kobject_del
+c01d607f T kobject_unregister
+c01d60a1 T kset_unregister
+c01d60ae T subsystem_unregister
+c01d60b3 T kobject_move
+c01d61ad T kobject_add
+c01d632c T kset_add
+c01d6334 T kobject_init
+c01d6373 T kset_init
+c01d639c T subsystem_init
+c01d63a1 T kset_register
+c01d63bc T subsystem_register
+c01d63c1 T kobject_register
+c01d63f1 T kset_find_obj
+c01d6458 T kobject_set_name
+c01d64ea T kobject_kset_add_dir
+c01d655f T kobject_add_dir
+c01d656a T kobject_rename
+c01d6634 T add_uevent_var
+c01d66aa T kobject_uevent_env
+c01d6acd T kobject_uevent
+c01d6ad4 T kref_init
+c01d6ae1 T kref_put
+c01d6b4e T kref_get
+c01d6b8c T walk_page_range
+c01d6d2c t get_index
+c01d6d5b t prio_tree_parent
+c01d6da1 t prio_tree_right
+c01d6e3d t prio_tree_left
+c01d6ebf T prio_tree_replace
+c01d6f12 T prio_tree_remove
+c01d6fad T prio_tree_insert
+c01d7190 T prio_tree_next
+c01d72a8 T radix_tree_tagged
+c01d72ba t radix_tree_node_ctor
+c01d72c8 T radix_tree_tag_clear
+c01d737b t radix_tree_node_rcu_free
+c01d7388 T radix_tree_preload
+c01d7409 t radix_tree_node_alloc
+c01d7479 T radix_tree_lookup_slot
+c01d74c5 T radix_tree_lookup
+c01d7515 T radix_tree_gang_lookup
+c01d7649 T radix_tree_gang_lookup_tag
+c01d780c T radix_tree_insert
+c01d7965 T radix_tree_tag_set
+c01d79ea T radix_tree_delete
+c01d7b84 t __rb_rotate_left
+c01d7bd4 t __rb_rotate_right
+c01d7c24 T rb_insert_color
+c01d7cd1 T rb_first
+c01d7ce3 T rb_last
+c01d7cf5 T rb_next
+c01d7d27 T rb_prev
+c01d7d59 T rb_erase
+c01d7f88 T rb_replace_node
+c01d7fd8 T reciprocal_value
+c01d8010 T rwsem_downgrade_wake
+c01d80ae t rwsem_down_failed_common
+c01d8203 T __init_rwsem
+c01d8229 T rwsem_wake
+c01d8324 T strnchr
+c01d8342 T strstrip
+c01d8389 T strspn
+c01d83b3 T strcspn
+c01d83db T strpbrk
+c01d8402 T strsep
+c01d8422 T memcmp
+c01d8444 T strlcat
+c01d84b0 T strlcpy
+c01d84f2 T strnicmp
+c01d8568 T strcasecmp
+c01d85ac T strncasecmp
+c01d85f8 T simple_strtoul
+c01d86bf T simple_strtol
+c01d86d2 T simple_strtoull
+c01d87e3 T simple_strtoll
+c01d87fb t skip_atoi
+c01d8827 t number
+c01d8a78 T vsscanf
+c01d8e68 T sscanf
+c01d8e81 T vsnprintf
+c01d930d T kvasprintf
+c01d9355 T kasprintf
+c01d936e T sprintf
+c01d9391 T vsprintf
+c01d93a5 T scnprintf
+c01d93d3 T snprintf
+c01d93f5 T vscnprintf
+c01d9414 T find_next_bit
+c01d947d T find_next_zero_bit
+c01d950c T csum_partial
+c01d962c T csum_partial_copy_generic
+c01d9730 t delay_loop
+c01d9754 T use_tsc_delay
+c01d975f T read_current_timer
+c01d9777 T __delay
+c01d977e T __const_udelay
+c01d979f t delay_tsc
+c01d97b2 T __udelay
+c01d97d6 T __ndelay
+c01d97f8 T __get_user_1
+c01d980c T __get_user_2
+c01d9824 T __get_user_4
+c01d983b t bad_get_user
+c01d9844 T memcpy
+c01d986c T memmove
+c01d988e T memset
+c01d98a4 T __put_user_1
+c01d98b8 T __put_user_2
+c01d98d4 T __put_user_4
+c01d98ec T __put_user_8
+c01d9907 t bad_put_user
+c01d9910 T strstr
+c01d9940 T __copy_to_user_ll
+c01d9a0f T __copy_from_user_ll
+c01d9add T __copy_from_user_ll_nozero
+c01d9bab T __copy_from_user_ll_nocache_nozero
+c01d9c91 T __clear_user
+c01d9cbd T __strncpy_from_user
+c01d9cee T copy_from_user
+c01d9d47 T __copy_from_user_ll_nocache
+c01d9e2d T strncpy_from_user
+c01d9e79 T clear_user
+c01d9ecf T strnlen_user
+c01d9f13 T copy_to_user
+c01d9f58 W __div64_32
+c01da01e T div64_64
+c01da094 t u32_swap
+c01da09f t generic_swap
+c01da0b7 T sort
+c01da204 T match_strcpy
+c01da236 T match_strdup
+c01da25c t match_number
+c01da2df T match_hex
+c01da2e9 T match_octal
+c01da2f3 T match_int
+c01da2fa T match_token
+c01da4e0 T half_md4_transform
+c01da7a8 T debug_locks_off
+c01da7dc t __random32
+c01da837 t __set_random32
+c01da889 T random32
+c01da89c T srandom32
+c01da8b0 W bust_spinlocks
+c01da8d4 T hex_dump_to_buffer
+c01daae6 T print_hex_dump
+c01dac1a T print_hex_dump_bytes
+c01dac58 T ioport_map
+c01dac6a T ioport_unmap
+c01dac6b t bad_io_access
+c01dacc3 T pci_iounmap
+c01dace2 T iowrite32_rep
+c01dad1b T iowrite16_rep
+c01dad57 T iowrite8_rep
+c01dad8f T ioread32_rep
+c01dadc7 T ioread16_rep
+c01dae02 T ioread8_rep
+c01dae38 T iowrite8
+c01dae67 T ioread8
+c01dae91 T ioread16be
+c01daeca T iowrite16be
+c01daf0f T ioread32be
+c01daf36 T iowrite32be
+c01daf63 T iowrite16
+c01daf94 T ioread16
+c01dafc0 T iowrite32
+c01dafeb T ioread32
+c01db00f T pci_iomap
+c01db094 W __iowrite32_copy
+c01db0ac W __iowrite64_copy
+c01db0b4 t devm_ioremap_match
+c01db0bc t devm_ioport_map_match
+c01db0c4 t pcim_iomap_release
+c01db0e6 T pcim_iomap_table
+c01db135 T pcim_iounmap
+c01db19e T pcim_iounmap_regions
+c01db1dc T pcim_iomap
+c01db216 T pcim_iomap_regions
+c01db2f8 t devm_ioport_map_release
+c01db2ff T devm_ioport_unmap
+c01db35b T devm_ioport_map
+c01db3b1 T devm_iounmap
+c01db40d t devm_ioremap_release
+c01db414 T devm_ioremap_nocache
+c01db46a T devm_ioremap
+c01db4c4 T __spin_lock_init
+c01db4e0 T __rwlock_init
+c01db4fc T _raw_spin_trylock
+c01db522 T _raw_read_trylock
+c01db537 T _raw_write_trylock
+c01db569 t rwlock_bug
+c01db5c3 T _raw_write_unlock
+c01db61e T _raw_read_unlock
+c01db639 T _raw_read_lock
+c01db65e t spin_bug
+c01db73d T _raw_spin_unlock
+c01db7a7 T _raw_spin_lock
+c01db883 T _raw_write_lock
+c01db8ec T hweight32
+c01db929 T hweight16
+c01db962 T hweight8
+c01db984 T hweight64
+c01db9a4 T plist_del
+c01db9f6 T plist_add
+c01dba7c T list_del
+c01dbad9 T __list_add
+c01dbb35 T list_add
+c01dbb3c T bitrev32
+c01dbb88 T crc32_le
+c01dbc33 T crc32_be
+c01dbce4 T inflate_fast
+c01dc17c T zlib_inflate_workspacesize
+c01dc182 T zlib_inflateReset
+c01dc210 T zlib_inflateInit2
+c01dc261 T zlib_inflateEnd
+c01dc275 t zlib_updatewindow
+c01dc323 T zlib_inflateIncomp
+c01dc4c3 T zlib_inflate
+c01dd5cc T zlib_inflate_table
+c01ddaa8 T textsearch_find_continuous
+c01ddae2 T textsearch_destroy
+c01ddb08 t get_linear_data
+c01ddb2b T textsearch_unregister
+c01ddb81 T textsearch_register
+c01ddc24 T textsearch_prepare
+c01ddd2c T percpu_counter_sum
+c01ddd81 T percpu_counter_mod
+c01dddc8 t __rdmsr_on_cpu
+c01ddddb t __rdmsr_safe_on_cpu
+c01dddf5 t __wrmsr_on_cpu
+c01dde17 t __wrmsr_safe_on_cpu
+c01dde53 t _wrmsr_on_cpu
+c01ddf06 T wrmsr_safe_on_cpu
+c01ddf22 T wrmsr_on_cpu
+c01ddf3e t _rdmsr_on_cpu
+c01ddfdf T rdmsr_safe_on_cpu
+c01ddffb T rdmsr_on_cpu
+c01de018 T pci_unblock_user_cfg_access
+c01de08d T pci_block_user_cfg_access
+c01de0cd T pci_bus_write_config_dword
+c01de127 T pci_bus_write_config_word
+c01de186 T pci_bus_write_config_byte
+c01de1dd T pci_bus_read_config_dword
+c01de248 T pci_bus_read_config_word
+c01de2b4 T pci_bus_read_config_byte
+c01de315 t pci_wait_ucfg
+c01de385 T pci_user_write_config_dword
+c01de3e4 T pci_user_write_config_word
+c01de444 T pci_user_write_config_byte
+c01de49f T pci_user_read_config_dword
+c01de511 T pci_user_read_config_word
+c01de584 T pci_user_read_config_byte
+c01de5ec T pci_walk_bus
+c01de68b T pci_enable_bridges
+c01de6ca T pci_bus_add_device
+c01de715 T pci_bus_add_devices
+c01de80f T pci_bus_alloc_resource
+c01de8d8 T pci_remove_legacy_files
+c01de8d9 t pci_size
+c01de905 t pci_release_bus_bridge_dev
+c01de90a t pci_release_dev
+c01de912 t release_pcibus_dev
+c01de930 t pci_bus_show_cpuaffinity
+c01de965 t pci_alloc_bus
+c01de994 T pci_add_new_bus
+c01deac0 T pci_create_bus
+c01dec6f t pci_read_irq
+c01decbb t pci_read_bases
+c01df11a T pci_device_add
+c01df18d T alloc_pci_dev
+c01df1be T pci_cfg_space_size
+c01df232 T pci_scan_single_device
+c01df665 T pci_scan_slot
+c01df6a9 t pci_fixup_parent_subordinate_busnr
+c01df6f7 T pci_scan_bridge
+c01dfa92 T pci_scan_child_bus
+c01dfb0a T pci_scan_bus_parented
+c01dfb2d T pci_do_scan_bus
+c01dfb44 T pci_read_bridge_bases
+c01dfdd0 t pci_stop_dev
+c01dfe1b T pci_stop_bus_device
+c01dfe48 T pci_remove_bus
+c01dfea0 T pci_remove_bus_device
+c01dff26 T pci_remove_behind_bridge
+c01dff54 T pci_bus_max_busnr
+c01dff90 T pci_find_parent_resource
+c01e0006 W pcibios_set_pcie_reset_state
+c01e000c T pci_set_pcie_reset_state
+c01e0011 T pci_get_interrupt_pin
+c01e0044 T pci_set_consistent_dma_mask
+c01e0074 T pci_select_bars
+c01e00a1 t pci_init
+c01e00c9 t __pci_bus_find_cap_start
+c01e00fe t find_pci_dr
+c01e0128 T pci_intx
+c01e01a9 T pci_disable_device
+c01e0214 t __pci_find_next_cap_ttl
+c01e028f t __pci_find_next_ht_cap
+c01e0319 T pci_find_ht_capability
+c01e0344 T pci_find_next_ht_capability
+c01e034a t __pci_find_next_cap
+c01e0372 T pci_bus_find_capability
+c01e03bb T pci_find_capability
+c01e03ec T pci_choose_state
+c01e0444 T pci_find_next_capability
+c01e0460 T pci_request_region
+c01e0646 T pci_release_region
+c01e0767 T pci_request_selected_regions
+c01e07b9 T pci_request_regions
+c01e07c5 T pci_release_selected_regions
+c01e07eb T pci_release_regions
+c01e07f5 t pcim_release
+c01e0868 T pcim_pin_device
+c01e08b1 T pci_restore_bars
+c01e08fb T pci_set_power_state
+c01e0ac4 t do_pci_enable_device
+c01e0af8 T pci_enable_device_bars
+c01e0b26 T pci_enable_device
+c01e0b30 T pcim_enable_device
+c01e0bd7 T __pci_reenable_device
+c01e0bed t pci_setup
+c01e0d0f T pci_set_dma_mask
+c01e0d39 T pci_restore_state
+c01e0ea7 T pci_enable_wake
+c01e0fa2 T pci_set_master
+c01e0ff7 T pci_set_mwi
+c01e10ea T pci_clear_mwi
+c01e1134 T pci_msi_off
+c01e11cc T pci_find_ext_capability
+c01e1257 T pci_save_state
+c01e13ec t quirk_mellanox_tavor
+c01e13f4 t quirk_citrine
+c01e13ff t quirk_s3_64M
+c01e1458 t quirk_via_bridge
+c01e14d3 t quirk_dunord
+c01e14fc t quirk_transparent_bridge
+c01e1504 t quirk_pcie_mch
+c01e150f t quirk_intel_pcie_pm
+c01e1521 T pci_fixup_device
+c01e1599 t fixup_rev1_53c810
+c01e15bb t quirk_netmos
+c01e1638 t quirk_natoma
+c01e1659 t quirk_vsfx
+c01e167a t quirk_viaetbf
+c01e169b t quirk_triton
+c01e16bc t quirk_nopcipci
+c01e16dd t quirk_isa_dma_hangs
+c01e1701 t msi_ht_cap_enabled
+c01e1790 t quirk_nvidia_ck804_msi_ht_cap
+c01e17fd t quirk_sis_96x_smbus
+c01e1854 t piix4_mem_quirk
+c01e18c9 t piix4_io_quirk
+c01e193c t quirk_pcie_pxh
+c01e195d t quirk_io_region
+c01e19e4 t quirk_vt82c586_acpi
+c01e1a4a t quirk_ati_exploding_mce
+c01e1aad t quirk_nvidia_ck804_pcie_aer_ext_cap
+c01e1b0b t quirk_disable_msi
+c01e1b45 t quirk_msi_ht_cap
+c01e1b88 t quirk_nopciamd
+c01e1bbf t quirk_amd_ioapic
+c01e1bfb t quirk_via_acpi
+c01e1c35 t quirk_passive_release
+c01e1cae t quirk_vialatency
+c01e1d79 t quirk_via_ioapic
+c01e1dcd t quirk_via_vt8237_bypass_apic_deassert
+c01e1e1e t quirk_amd_8131_ioapic
+c01e1e9b t quirk_via_vlink
+c01e1f46 t quirk_mediagx_master
+c01e1fa1 t quirk_sb600_sata
+c01e203d t quirk_svwks_csb5ide
+c01e2088 t k8t_sound_hostbridge
+c01e2110 t asus_hides_ac97_lpc
+c01e21a2 t quirk_ali7101_acpi
+c01e2219 t quirk_vt8235_acpi
+c01e22a8 t quirk_vt82c598_id
+c01e22de t quirk_sis_503
+c01e2371 t quirk_e100_interrupt
+c01e2498 t quirk_p64h2_1k_io
+c01e2539 t quirk_p64h2_1k_io_fix_iobl
+c01e25d6 t quirk_disable_pxb
+c01e264a t asus_hides_smbus_lpc
+c01e26d4 t quirk_piix4_acpi
+c01e282e t quirk_ich4_lpc_acpi
+c01e28a3 t quirk_ich6_lpc_acpi
+c01e2918 t quirk_vt82c686_acpi
+c01e29a7 t asus_hides_smbus_lpc_ich6
+c01e2a08 t quirk_cardbus_legacy
+c01e2a2d t quirk_amd_ordering
+c01e2abc t quirk_jmicron_ata
+c01e2be8 T pci_match_id
+c01e2c5e t pci_device_shutdown
+c01e2c72 T pci_dev_driver
+c01e2c99 t pci_device_resume
+c01e2cd9 t pci_device_resume_early
+c01e2d03 t pci_device_suspend_late
+c01e2d32 t pci_device_suspend
+c01e2d79 T pci_dev_put
+c01e2d86 t pci_device_remove
+c01e2dbb T pci_dev_get
+c01e2dce T pci_match_device
+c01e2e72 t pci_bus_match
+c01e2e88 t pci_device_probe
+c01e2edf T pci_unregister_driver
+c01e2f2b t pci_driver_attr_store
+c01e2f6b t pci_driver_attr_show
+c01e2fa7 T __pci_register_driver
+c01e3026 t store_new_id
+c01e3160 t pci_do_find_bus
+c01e31a0 T pci_find_present
+c01e3288 T pci_dev_present
+c01e3296 T pci_find_device
+c01e3344 T pci_find_slot
+c01e3376 T pci_find_next_bus
+c01e33e7 T pci_find_bus
+c01e3419 T pci_get_class
+c01e34a8 T pci_get_subsys
+c01e3592 T pci_get_device
+c01e35ab T pci_get_bus_and_slot
+c01e35dd T pci_get_slot
+c01e3662 T pci_get_device_reverse
+c01e3714 t broken_parity_status_store
+c01e374f t pci_write_rom
+c01e378f t msi_bus_store
+c01e382d t msi_bus_show
+c01e385e t is_enabled_show
+c01e387f t modalias_show
+c01e38d6 t broken_parity_status_show
+c01e38fd t irq_show
+c01e391e t class_show
+c01e393c t subsystem_device_show
+c01e395b t subsystem_vendor_show
+c01e397a t device_show
+c01e3999 t vendor_show
+c01e39b8 t is_enabled_store
+c01e3a13 t local_cpus_show
+c01e3a5b t pci_remove_resource_files
+c01e3a8b T pci_remove_sysfs_dev_files
+c01e3b21 t pci_write_config
+c01e3c8f t pci_read_config
+c01e3e42 t pci_mmap_resource
+c01e3ea5 T pci_create_sysfs_dev_files
+c01e411e t pci_read_rom
+c01e41c4 t resource_show
+c01e4240 T pci_cleanup_rom
+c01e4284 t pci_disable_rom
+c01e42c3 T pci_remove_rom
+c01e4323 T pci_unmap_rom
+c01e434c T pci_map_rom
+c01e4520 T pci_map_rom_copy
+c01e45c4 T pdev_sort_resources
+c01e4722 T pci_update_resource
+c01e4859 T pci_claim_resource
+c01e496e T pci_assign_resource
+c01e4afc t pci_seq_next
+c01e4b10 t pci_seq_start
+c01e4b3f t proc_bus_pci_dev_open
+c01e4b4b t pci_seq_stop
+c01e4b57 T pci_proc_detach_bus
+c01e4b6f T pci_proc_detach_device
+c01e4b9f T pci_proc_attach_device
+c01e4c5f t proc_bus_pci_release
+c01e4c7b t proc_bus_pci_open
+c01e4caf t proc_bus_pci_mmap
+c01e4cf9 t proc_bus_pci_lseek
+c01e4d78 t show_device
+c01e4ef5 t proc_bus_pci_read
+c01e505e t proc_bus_pci_write
+c01e5179 t proc_bus_pci_ioctl
+c01e51d4 t pcie_port_shutdown_service
+c01e51d5 t pcie_port_suspend_service
+c01e51f7 t pcie_port_resume_service
+c01e5219 t suspend_iter
+c01e5240 t resume_iter
+c01e5265 t remove_iter
+c01e5299 T pcie_port_service_unregister
+c01e52a1 T pcie_port_service_register
+c01e52e7 t pcie_port_remove_service
+c01e533b t pcie_port_probe_service
+c01e53a1 T pcie_port_bus_unregister
+c01e53ab T pcie_port_bus_register
+c01e53b5 T pcie_port_device_resume
+c01e53c4 T pcie_port_device_suspend
+c01e53db T pcie_port_device_remove
+c01e542b t release_pcie_device
+c01e5454 T pcie_port_device_register
+c01e57e8 T pcie_port_device_probe
+c01e5834 t slot_reset_iter
+c01e5885 t resume_iter
+c01e58b6 t pcie_portdrv_err_resume
+c01e58c5 t pcie_portdrv_mmio_enabled
+c01e58e3 t pcie_portdrv_error_detected
+c01e5907 t pcie_portdrv_restore_config
+c01e5929 t pcie_portdrv_slot_reset
+c01e5956 t pcie_portdrv_resume
+c01e5966 t pcie_portdrv_save_config
+c01e596b t pcie_portdrv_suspend
+c01e597e t pcie_portdrv_remove
+c01e5992 t pcie_portdrv_probe
+c01e5a1f t error_detected_iter
+c01e5a73 t mmio_enabled_iter
+c01e5ac4 t pcie_port_bus_match
+c01e5b15 t pcie_port_bus_suspend
+c01e5b37 t pcie_port_bus_resume
+c01e5b5c T aer_print_error
+c01e5e38 t report_slot_reset
+c01e5e72 t report_resume
+c01e5e91 t find_aer_service_iter
+c01e5ecb T aer_init
+c01e5f1b t get_e_source
+c01e5f75 T pci_find_aer_capability
+c01e5fd2 T aer_delete_rootport
+c01e6035 T pci_cleanup_aer_uncorrect_error_status
+c01e60a6 t broadcast_error_message
+c01e6132 T aer_isr
+c01e64fd t report_error_detected
+c01e657f t report_mmio_enabled
+c01e65b9 t find_device_iter
+c01e6645 T pci_enable_pcie_error_reporting
+c01e66a3 T pci_disable_pcie_error_reporting
+c01e6704 T aer_enable_rootport
+c01e6860 t aer_suspend
+c01e6863 t aer_resume
+c01e6866 t aer_error_detected
+c01e686c t aer_remove
+c01e6912 t aer_probe
+c01e6a56 t aer_error_resume
+c01e6af4 t aer_irq
+c01e6bf0 t aer_root_reset
+c01e6cdc T aer_osc_setup
+c01e6d44 T pci_uevent
+c01e6f2c T pci_no_msi
+c01e6f37 T pci_msi_init_pci_dev
+c01e6f47 W arch_msi_check_device
+c01e6f4e W arch_teardown_msi_irqs
+c01e6f75 t msix_flush_writes
+c01e6fb2 t msi_free_irqs
+c01e7055 t msix_free_all_irqs
+c01e705a T msi_remove_pci_irq_vectors
+c01e7088 t pci_msi_check_device
+c01e70ea t msix_set_enable
+c01e7151 T pci_disable_msix
+c01e718e t msi_set_enable
+c01e71f3 T pci_disable_msi
+c01e7263 t alloc_msi_entry
+c01e7294 T write_msi_msg
+c01e735c t msi_set_mask_bit
+c01e740f T pci_restore_msi_state
+c01e757a T unmask_msi_irq
+c01e758c T mask_msi_irq
+c01e75a1 W arch_setup_msi_irqs
+c01e75d9 T pci_enable_msix
+c01e7886 T pci_enable_msi
+c01e7a64 T read_msi_msg
+c01e7b14 T fetch_ht_irq_msg
+c01e7b29 T ht_destroy_irq
+c01e7b58 T __ht_create_irq
+c01e7c4e T ht_create_irq
+c01e7c55 T write_ht_irq_msg
+c01e7d1e T unmask_ht_irq
+c01e7d46 T mask_ht_irq
+c01e7d70 t find_free_bus_resource
+c01e7daf t pbus_size_mem
+c01e7f6a T pci_setup_cardbus
+c01e80f8 T pci_bus_size_bridges
+c01e84c2 T pci_bus_assign_resources
+c01e8860 t acpi_pci_choose_state
+c01e8866 t acpi_pci_find_root_bridge
+c01e88b7 t acpi_pci_find_device
+c01e88ee t acpi_pci_set_power_state
+c01e890a T pci_osc_control_set
+c01e8a89 t acpi_query_osc
+c01e8bc2 T pci_osc_support_set
+c01e8c34 T fb_notifier_call_chain
+c01e8c42 T fb_unregister_client
+c01e8c4e T fb_register_client
+c01e8c5c t dummycon_startup
+c01e8c62 t dummycon_dummy
+c01e8c65 t dummycon_init
+c01e8c90 t vgacon_scrollback_init
+c01e8cd3 t vgacon_build_attr
+c01e8d8b t vgacon_invert_region
+c01e8dea t vga_set_palette
+c01e8ec9 t vgacon_set_palette
+c01e8ef7 t vgacon_dummy
+c01e8efa t vgacon_save_screen
+c01e8f53 t vgacon_restore_screen
+c01e8fac t vgacon_set_origin
+c01e901e t vgacon_doresize
+c01e91b8 t vgacon_resize
+c01e9206 t vgacon_set_cursor_size
+c01e92d2 t vgacon_cursor
+c01e9475 t vgacon_do_font_op
+c01e9803 t vgacon_font_get
+c01e9853 t vgacon_font_set
+c01e9a20 t vgacon_init
+c01e9ad8 t vgacon_switch
+c01e9b9c t vgacon_blank
+c01ea160 t vgacon_scroll
+c01ea3b1 t vgacon_startup
+c01ea6fc t vgacon_scrolldelta
+c01ea8ca t vgacon_deinit
+c01ea938 T acpi_table_print_madt_entry
+c01eab60 T acpi_os_table_override
+c01eab77 t acpi_irq
+c01eab8b T acpi_os_read_port
+c01eabc9 T acpi_os_write_port
+c01eabfb T acpi_os_delete_lock
+c01eabfc T acpi_os_signal_semaphore
+c01eac25 T acpi_set_cstate_limit
+c01eac36 T acpi_os_validate_address
+c01eac39 T acpi_os_validate_interface
+c01eacae t enable_osi_linux
+c01eace5 t dmi_osi_linux
+c01ead0a T acpi_os_signal
+c01ead21 T acpi_os_get_timer
+c01ead5b T acpi_os_release_object
+c01ead63 T acpi_os_delete_cache
+c01ead6b T acpi_os_purge_cache
+c01ead73 T acpi_os_create_cache
+c01eada9 T acpi_os_release_lock
+c01eadae T acpi_os_acquire_lock
+c01eadb3 T acpi_os_delete_semaphore
+c01eadc6 t acpi_os_execute_notify
+c01eadf1 T acpi_os_create_semaphore
+c01eae49 T acpi_os_create_lock
+c01eae5d T acpi_os_wait_events_complete
+c01eae67 t acpi_os_execute_deferred
+c01eae97 T acpi_os_write_pci_configuration
+c01eaf1f T acpi_os_read_pci_configuration
+c01eafac t acpi_os_derive_pci_id_2
+c01eb0e0 T acpi_os_derive_pci_id
+c01eb10f T acpi_os_unmap_memory
+c01eb11e T acpi_os_write_memory
+c01eb163 T acpi_os_stall
+c01eb18c T acpi_os_sleep
+c01eb196 T acpi_os_remove_interrupt_handler
+c01eb1bb T acpi_os_install_interrupt_handler
+c01eb248 T acpi_os_predefined_override
+c01eb2ab T acpi_os_vprintf
+c01eb2d3 T acpi_os_printf
+c01eb2e8 T acpi_os_terminate
+c01eb313 T acpi_os_initialize1
+c01eb379 T acpi_os_execute
+c01eb406 T acpi_os_wait_semaphore
+c01eb4d2 T acpi_os_map_memory
+c01eb4e7 T acpi_os_read_memory
+c01eb534 T acpi_evaluate_reference
+c01eb625 T acpi_evaluate_integer
+c01eb6d0 T acpi_extract_package
+c01eb944 t acpi_ds_get_field_names
+c01ebad0 T acpi_ds_create_index_field
+c01ebb94 T acpi_ds_create_bank_field
+c01ebcba T acpi_ds_create_field
+c01ebd4d T acpi_ds_init_field_objects
+c01ebe24 T acpi_ds_create_buffer_field
+c01ebf38 T acpi_ds_method_data_init
+c01ebfb2 T acpi_ds_method_data_get_node
+c01ec067 t acpi_ds_method_data_set_value
+c01ec09b T acpi_ds_store_object_to_local
+c01ec1ad T acpi_ds_method_data_init_args
+c01ec1ee T acpi_ds_method_data_get_value
+c01ec336 T acpi_ds_method_data_delete_all
+c01ec388 T acpi_ds_exec_end_control_op
+c01ec58d T acpi_ds_exec_begin_control_op
+c01ec5eb T acpi_ds_eval_data_object_operands
+c01ec6da T acpi_ds_eval_region_operands
+c01ec75e t acpi_ds_init_buffer_field
+c01ec9bf T acpi_ds_eval_buffer_field_operands
+c01eca92 T acpi_ds_initialize_region
+c01eca9e t acpi_ds_execute_arguments
+c01ecbd8 T acpi_ds_get_region_arguments
+c01ecc63 T acpi_ds_get_package_arguments
+c01eccb9 T acpi_ds_get_buffer_arguments
+c01ecd0f T acpi_ds_get_buffer_field_arguments
+c01ecd4c T acpi_ds_exec_begin_op
+c01ece4f T acpi_ds_get_predicate_value
+c01ecfc5 T acpi_ds_exec_end_op
+c01ed394 T acpi_ds_scope_stack_pop
+c01ed3b9 T acpi_ds_scope_stack_clear
+c01ed3d9 T acpi_ds_scope_stack_push
+c01ed46c t acpi_ds_create_method_mutex
+c01ed4bd T acpi_ds_terminate_control_method
+c01ed57f T acpi_ds_restart_control_method
+c01ed5d8 T acpi_ds_begin_method_execution
+c01ed730 T acpi_ds_call_control_method
+c01ed87d T acpi_ds_method_error
+c01ed8dc T acpi_ds_init_object_from_op
+c01edac4 t acpi_ds_build_internal_object
+c01edbb3 T acpi_ds_create_node
+c01edc08 T acpi_ds_build_internal_package_obj
+c01edd08 T acpi_ds_build_internal_buffer_obj
+c01ede20 T acpi_ds_create_operand
+c01edff8 T acpi_ds_create_operands
+c01ee066 T acpi_ds_clear_operands
+c01ee095 T acpi_ds_clear_implicit_return
+c01ee0bc T acpi_ds_resolve_operands
+c01ee0ea T acpi_ds_do_implicit_return
+c01ee13a T acpi_ds_is_result_used
+c01ee232 T acpi_ds_delete_result_if_not_used
+c01ee28c T acpi_ds_init_callbacks
+c01ee2f8 T acpi_ds_load2_end_op
+c01ee5cd T acpi_ds_load2_begin_op
+c01ee86d T acpi_ds_load1_end_op
+c01ee9ac T acpi_ds_load1_begin_op
+c01eebdc T acpi_ds_get_current_walk_state
+c01eebe8 T acpi_ds_push_walk_state
+c01eebf1 T acpi_ds_pop_walk_state
+c01eec02 T acpi_ds_obj_stack_pop
+c01eec66 T acpi_ds_obj_stack_push
+c01eecb8 T acpi_ds_result_push
+c01eed76 T acpi_ds_result_pop_from_bottom
+c01eee3e T acpi_ds_result_pop
+c01eeec3 T acpi_ds_delete_walk_state
+c01eef8d T acpi_ds_init_aml_walk
+c01ef08b T acpi_ds_obj_stack_pop_and_delete
+c01ef109 T acpi_ds_result_stack_pop
+c01ef12b T acpi_ds_result_stack_push
+c01ef151 T acpi_ds_create_walk_state
+c01ef1dc T acpi_ds_initialize_objects
+c01ef273 t acpi_ds_init_one_object
+c01ef308 T acpi_ev_fixed_event_detect
+c01ef3bb T acpi_ev_install_xrupt_handlers
+c01ef41c T acpi_ev_install_fadt_gpes
+c01ef45b T acpi_ev_initialize_events
+c01ef4ec T acpi_ev_execute_reg_methods
+c01ef522 T acpi_ev_install_space_handler
+c01ef704 T acpi_ev_attach_region
+c01ef727 T acpi_ev_initialize_op_regions
+c01ef763 T acpi_ev_install_region_handlers
+c01ef7cc T acpi_ev_address_space_dispatch
+c01ef976 T acpi_ev_execute_reg_method
+c01efa8a t acpi_ev_reg_run
+c01efac8 T acpi_ev_detach_region
+c01efbfa t acpi_ev_install_handler
+c01efc78 T acpi_ev_remove_sci_handler
+c01efc89 T acpi_ev_gpe_xrupt_handler
+c01efc8e t acpi_ev_sci_xrupt_handler
+c01efca7 T acpi_ev_install_sci_handler
+c01efcc0 T acpi_remove_gpe_block
+c01efd26 T acpi_install_gpe_block
+c01efe26 T acpi_clear_gpe
+c01efe7b T acpi_clear_event
+c01efe9a T acpi_disable_event
+c01eff0e T acpi_enable_event
+c01eff85 T acpi_disable_gpe
+c01effda T acpi_enable_gpe
+c01f0034 T acpi_set_gpe_type
+c01f0067 T acpi_disable
+c01f00ab T acpi_enable
+c01f00fc T acpi_ev_is_notify_object
+c01f011e T acpi_ev_terminate
+c01f0203 t acpi_ev_global_lock_handler
+c01f0257 T acpi_ev_release_global_lock
+c01f02f9 T acpi_ev_init_global_lock_handler
+c01f035e t acpi_ev_notify_dispatch
+c01f03b0 T acpi_ev_queue_notify_request
+c01f0463 T acpi_ev_acquire_global_lock
+c01f04ec T acpi_ev_io_space_region_setup
+c01f04fb t acpi_ev_match_pci_root_bridge
+c01f055b T acpi_ev_pci_bar_region_setup
+c01f055e T acpi_ev_cmos_region_setup
+c01f0561 T acpi_ev_default_region_setup
+c01f0570 T acpi_ev_initialize_region
+c01f068f T acpi_ev_pci_config_region_setup
+c01f08b0 T acpi_ev_system_memory_region_setup
+c01f0920 T acpi_release_global_lock
+c01f0936 T acpi_acquire_global_lock
+c01f0976 T acpi_remove_gpe_handler
+c01f0a43 T acpi_install_gpe_handler
+c01f0b49 T acpi_remove_notify_handler
+c01f0d41 T acpi_install_notify_handler
+c01f0f03 T acpi_remove_fixed_event_handler
+c01f0f7c T acpi_install_fixed_event_handler
+c01f102c T acpi_remove_address_space_handler
+c01f10eb T acpi_install_address_space_handler
+c01f1168 T acpi_ev_update_gpe_enable_masks
+c01f11e2 T acpi_ev_disable_gpe
+c01f123b T acpi_ev_gpe_dispatch
+c01f1391 T acpi_ev_set_gpe_type
+c01f13c8 T acpi_ev_enable_gpe
+c01f142e t acpi_ev_asynch_execute_gpe_method
+c01f1534 T acpi_ev_gpe_detect
+c01f160c T acpi_ev_get_gpe_event_info
+c01f1688 T acpi_ev_valid_gpe_event
+c01f16c5 T acpi_ev_initialize_gpe_block
+c01f174a t acpi_ev_match_prw_and_gpe
+c01f1806 T acpi_ev_delete_gpe_handlers
+c01f185a T acpi_ev_walk_gpe_list
+c01f18ae T acpi_ev_create_gpe_block
+c01f1c18 T acpi_ev_gpe_initialize
+c01f1db4 t acpi_ev_save_method_info
+c01f1e31 T acpi_ev_delete_gpe_block
+c01f1f24 T acpi_ex_unload_table
+c01f1f61 t acpi_ex_add_table
+c01f1fca T acpi_ex_load_op
+c01f20a0 T acpi_ex_load_table_op
+c01f223c T acpi_ex_read_data_from_field
+c01f2375 T acpi_ex_write_data_to_field
+c01f259c t acpi_ex_allocate_name_string
+c01f2640 t acpi_ex_name_segment
+c01f270e T acpi_ex_get_name_string
+c01f28d0 t acpi_ex_do_match
+c01f296c T acpi_ex_opcode_6A_0T_1R
+c01f2b60 T acpi_ex_resolve_multiple
+c01f2d67 T acpi_ex_resolve_to_value
+c01f2fac T acpi_ex_store_string_to_string
+c01f3054 T acpi_ex_store_buffer_to_buffer
+c01f3110 t acpi_ex_convert_to_ascii
+c01f3219 T acpi_ex_convert_to_string
+c01f3373 T acpi_ex_convert_to_buffer
+c01f3401 T acpi_ex_convert_to_integer
+c01f3509 T acpi_ex_convert_to_target_type
+c01f35f8 t acpi_ex_register_overflow
+c01f3629 T acpi_ex_access_region
+c01f383f t acpi_ex_field_datum_io
+c01f39e6 T acpi_ex_extract_from_field
+c01f3c1c T acpi_ex_write_with_update_rule
+c01f3d50 T acpi_ex_insert_into_field
+c01f400c T acpi_ex_opcode_1A_0T_1R
+c01f4507 T acpi_ex_opcode_1A_1T_1R
+c01f4a65 T acpi_ex_opcode_1A_1T_0R
+c01f4ab3 T acpi_ex_opcode_1A_0T_0R
+c01f4b4f T acpi_ex_opcode_0A_0T_1R
+c01f4be4 T acpi_ex_prep_common_field_object
+c01f4cb3 T acpi_ex_prep_field_value
+c01f4e68 t acpi_ex_check_object_type
+c01f4ed5 T acpi_ex_resolve_operands
+c01f5430 T acpi_ex_system_reset_event
+c01f545d T acpi_ex_system_signal_event
+c01f5471 T acpi_ex_system_do_suspend
+c01f548f T acpi_ex_system_do_stall
+c01f54cc T acpi_ex_system_wait_mutex
+c01f550b T acpi_ex_system_wait_semaphore
+c01f554a T acpi_ex_system_wait_event
+c01f5560 T acpi_ex_create_method
+c01f5600 T acpi_ex_create_power_resource
+c01f566a T acpi_ex_create_processor
+c01f56db T acpi_ex_create_alias
+c01f5733 T acpi_ex_create_table_region
+c01f581e T acpi_ex_create_region
+c01f58ee T acpi_ex_create_mutex
+c01f5965 T acpi_ex_create_event
+c01f59c8 T acpi_ex_do_math_op
+c01f5aec T acpi_ex_do_logical_numeric_op
+c01f5b3f T acpi_ex_do_logical_op
+c01f5c72 T acpi_ex_get_object_reference
+c01f5d47 T acpi_ex_concat_template
+c01f5e12 T acpi_ex_do_concatenate
+c01f5ff8 T acpi_ex_opcode_2A_0T_1R
+c01f6132 T acpi_ex_opcode_2A_1T_1R
+c01f64b7 T acpi_ex_opcode_2A_2T_1R
+c01f65e0 T acpi_ex_opcode_2A_0T_0R
+c01f6678 T acpi_ex_cmos_space_handler
+c01f667b T acpi_ex_pci_bar_space_handler
+c01f667e T acpi_ex_data_table_space_handler
+c01f66a9 T acpi_ex_pci_config_space_handler
+c01f6705 T acpi_ex_system_io_space_handler
+c01f6746 T acpi_ex_system_memory_space_handler
+c01f6968 T acpi_ex_store_object_to_node
+c01f6a13 t acpi_ex_do_debug_object
+c01f6a8b T acpi_ex_store
+c01f6cc4 T acpi_ex_truncate_for32bit_table
+c01f6ce3 T acpi_ex_unsigned_integer_to_string
+c01f6d7f T acpi_ex_eisa_id_to_string
+c01f6df7 T acpi_ex_release_global_lock
+c01f6e2c T acpi_ex_acquire_global_lock
+c01f6e6f T acpi_ex_exit_interpreter
+c01f6e9e T acpi_ex_relinquish_interpreter
+c01f6ead T acpi_ex_enter_interpreter
+c01f6edc T acpi_ex_reacquire_interpreter
+c01f6eec T acpi_ex_unlink_mutex
+c01f6f17 T acpi_ex_release_all_mutexes
+c01f6f6b T acpi_ex_release_mutex
+c01f70dd T acpi_ex_acquire_mutex
+c01f720c T acpi_ex_opcode_3A_0T_0R
+c01f72a7 T acpi_ex_opcode_3A_1T_1R
+c01f7464 T acpi_ex_resolve_node_to_value
+c01f7680 T acpi_ex_store_object_to_object
+c01f7790 T acpi_ex_resolve_object
+c01f7864 T acpi_hw_get_mode
+c01f7894 T acpi_hw_set_mode
+c01f7988 T acpi_hw_enable_all_wakeup_gpes
+c01f7992 T acpi_hw_enable_all_runtime_gpes
+c01f799c T acpi_hw_disable_all_gpes
+c01f79b0 t acpi_hw_enable_wakeup_gpe_block
+c01f79ea T acpi_hw_enable_runtime_gpe_block
+c01f7a24 T acpi_hw_clear_gpe_block
+c01f7a56 T acpi_hw_disable_gpe_block
+c01f7a88 T acpi_hw_clear_gpe
+c01f7aaf T acpi_hw_write_gpe_enable_reg
+c01f7ad0 T acpi_hw_low_level_write
+c01f7b46 T acpi_hw_get_bit_register_info
+c01f7b7e T acpi_hw_low_level_read
+c01f7bf9 T acpi_hw_register_read
+c01f7d4f T acpi_hw_register_write
+c01f7e9a T acpi_get_register
+c01f7ee5 T acpi_set_register
+c01f804d T acpi_get_sleep_type_data
+c01f820b T acpi_hw_clear_acpi_status
+c01f8274 T acpi_enter_sleep_state_prep
+c01f8390 T acpi_leave_sleep_state
+c01f85d7 T acpi_enter_sleep_state_s4bios
+c01f8649 T acpi_set_firmware_waking_vector
+c01f8686 T acpi_enter_sleep_state
+c01f883c T acpi_ns_lookup
+c01f8b50 T acpi_ns_root_initialize
+c01f8e38 T acpi_ns_load_table
+c01f8eb4 T acpi_ns_search_one_scope
+c01f8eeb T acpi_ns_search_and_enter
+c01f9064 T acpi_get_data
+c01f90bc T acpi_detach_data
+c01f910a T acpi_attach_data
+c01f9162 T acpi_get_devices
+c01f91cd T acpi_walk_namespace
+c01f9241 t acpi_ns_get_device_callback
+c01f9390 T acpi_evaluate_object
+c01f9554 T acpi_ns_install_node
+c01f958d T acpi_ns_delete_children
+c01f9602 T acpi_ns_delete_namespace_subtree
+c01f9659 T acpi_ns_delete_node
+c01f96b2 T acpi_ns_delete_namespace_by_owner
+c01f9773 T acpi_ns_create_node
+c01f97ac T acpi_ns_evaluate
+c01f989c T acpi_ns_get_pathname_length
+c01f98c4 T acpi_ns_build_external_path
+c01f9957 T acpi_ns_handle_to_pathname
+c01f9998 T acpi_ns_valid_root_prefix
+c01f99a1 T acpi_ns_get_internal_name_length
+c01f9a00 T acpi_ns_build_internal_name
+c01f9ad0 T acpi_ns_map_handle_to_node
+c01f9aea T acpi_ns_convert_entry_to_handle
+c01f9aeb T acpi_ns_get_parent_node
+c01f9aff T acpi_ns_get_next_valid_node
+c01f9b0d T acpi_ns_opens_scope
+c01f9b50 T acpi_ns_local
+c01f9b93 T acpi_ns_get_type
+c01f9bc3 T acpi_ns_terminate
+c01f9be6 T acpi_ns_externalize_name
+c01f9dc0 T acpi_ns_internalize_name
+c01f9e37 T acpi_ns_get_node
+c01f9eca T acpi_ns_print_node_pathname
+c01f9f35 T acpi_ns_report_method_error
+c01f9fae T acpi_ns_report_error
+c01fa054 T acpi_get_name
+c01fa0ed T acpi_get_handle
+c01fa19a T acpi_get_object_info
+c01fa330 T acpi_ns_initialize_devices
+c01fa407 t acpi_ns_init_one_device
+c01fa4b4 t acpi_ns_find_ini_methods
+c01fa50d T acpi_ns_initialize_objects
+c01fa576 t acpi_ns_init_one_object
+c01fa6b0 T acpi_ns_get_secondary_object
+c01fa6c9 T acpi_ns_get_attached_data
+c01fa6e7 T acpi_ns_detach_data
+c01fa71c T acpi_ns_detach_object
+c01fa754 T acpi_ns_attach_data
+c01fa7c1 T acpi_ns_get_attached_object
+c01fa804 T acpi_ns_attach_object
+c01fa8e8 T acpi_ns_get_next_node
+c01fa91c T acpi_ns_walk_namespace
+c01faa38 T acpi_get_next_object
+c01faabc T acpi_get_type
+c01fab17 T acpi_get_id
+c01fab60 T acpi_get_parent
+c01fabcc T acpi_ns_one_complete_parse
+c01fac9e T acpi_ns_parse_table
+c01facc0 t acpi_ps_get_next_package_length
+c01fad06 T acpi_ps_get_next_package_end
+c01fad14 T acpi_ps_get_next_namestring
+c01fad65 T acpi_ps_get_next_simple_arg
+c01fae4f T acpi_ps_get_next_namepath
+c01fb002 T acpi_ps_get_next_arg
+c01fb228 T acpi_ps_get_opcode_size
+c01fb233 T acpi_ps_peek_opcode
+c01fb248 T acpi_ps_parse_aml
+c01fb47f T acpi_ps_next_parse_state
+c01fb58c T acpi_ps_complete_this_op
+c01fb6d0 t acpi_ps_complete_op
+c01fb8a9 T acpi_ps_parse_loop
+c01fbfe0 T acpi_ps_get_arg
+c01fc013 T acpi_ps_append_arg
+c01fc088 T acpi_ps_delete_parse_tree
+c01fc0cc T acpi_ps_get_opcode_info
+c01fc10a T acpi_ps_get_opcode_name
+c01fc110 T acpi_ps_get_parent_scope
+c01fc117 T acpi_ps_has_completed_scope
+c01fc134 T acpi_ps_cleanup_scope
+c01fc152 T acpi_ps_pop_scope
+c01fc1a7 T acpi_ps_init_scope
+c01fc1e2 T acpi_ps_push_scope
+c01fc23c T acpi_ps_init_op
+c01fc245 T acpi_ps_is_leading_char
+c01fc25e T acpi_ps_is_prefix_char
+c01fc274 T acpi_ps_set_name
+c01fc27e T acpi_ps_free_op
+c01fc297 T acpi_ps_alloc_op
+c01fc313 T acpi_ps_create_scope_op
+c01fc32c T acpi_debug_trace
+c01fc385 t acpi_ps_update_parameter_list
+c01fc3b5 T acpi_ps_execute_method
+c01fc570 T acpi_rs_set_address_common
+c01fc5ad T acpi_rs_get_address_common
+c01fc5fc T acpi_rs_create_aml_resources
+c01fc636 T acpi_rs_create_pci_routing_table
+c01fc93e T acpi_rs_create_resource_list
+c01fc998 T acpi_rs_convert_resources_to_aml
+c01fca50 T acpi_rs_convert_aml_to_resources
+c01fcae4 T acpi_rs_convert_resource_to_aml
+c01fccce T acpi_rs_convert_aml_to_resource
+c01fcffc t acpi_rs_match_vendor_resource
+c01fd07d T acpi_walk_resources
+c01fd10d T acpi_get_vendor_resource
+c01fd156 t acpi_rs_validate_parameters
+c01fd18f T acpi_set_current_resources
+c01fd1c3 T acpi_get_current_resources
+c01fd1e1 T acpi_get_irq_routing_table
+c01fd1ff T acpi_resource_to_address64
+c01fd338 t acpi_rs_count_set_bits
+c01fd34d t acpi_rs_stream_option_length
+c01fd35f T acpi_rs_get_pci_routing_table_length
+c01fd3ea T acpi_rs_get_list_length
+c01fd4fe T acpi_rs_get_aml_length
+c01fd5ac T acpi_rs_decode_bitmask
+c01fd5d3 T acpi_rs_encode_bitmask
+c01fd604 T acpi_rs_set_resource_source
+c01fd62e T acpi_rs_get_resource_source
+c01fd6c7 T acpi_rs_move_data
+c01fd74a T acpi_rs_set_srs_method_data
+c01fd82e T acpi_rs_get_method_data
+c01fd869 T acpi_rs_get_crs_method_data
+c01fd8a9 T acpi_rs_get_prt_method_data
+c01fd8e9 T acpi_rs_set_resource_length
+c01fd914 T acpi_rs_set_resource_header
+c01fd924 T acpi_get_table
+c01fd9b1 T acpi_get_table_by_index
+c01fda18 T acpi_load_tables
+c01fdb98 T acpi_unload_table_id
+c01fdbe0 T acpi_load_table
+c01fdc37 T acpi_allocate_root_table
+c01fdc48 T acpi_reallocate_root_table
+c01fdcc3 T acpi_get_table_header
+c01fdd58 T acpi_tb_set_table_loaded_flag
+c01fdda3 T acpi_tb_is_table_loaded
+c01fdde5 T acpi_tb_get_owner_id
+c01fde25 T acpi_tb_release_owner_id
+c01fde63 T acpi_tb_allocate_owner_id
+c01fdea0 T acpi_tb_delete_namespace_by_owner
+c01fdedf T acpi_tb_delete_table
+c01fdf14 T acpi_tb_terminate
+c01fdf79 T acpi_tb_resize_root_table_list
+c01fe051 T acpi_tb_store_table
+c01fe0f2 T acpi_tb_verify_table
+c01fe138 T acpi_tb_add_table
+c01fe280 T acpi_tb_tables_loaded
+c01fe28d T acpi_tb_checksum
+c01fe29f T acpi_tb_verify_checksum
+c01fe2eb T acpi_tb_print_table_header
+c01fe3d6 T acpi_tb_install_table
+c01fe4b8 T acpi_tb_find_table
+c01fe584 T acpi_tb_create_local_fadt
+c01fe8a1 T acpi_tb_parse_fadt
+c01fe918 T acpi_ut_validate_buffer
+c01fe935 T acpi_ut_delete_caches
+c01fe99c T acpi_ut_create_caches
+c01fea38 T acpi_ut_initialize_buffer
+c01fead8 T acpi_ut_dump_buffer2
+c01fec31 T acpi_ut_dump_buffer
+c01fec54 T acpi_osi_invalidate
+c01fec92 t acpi_ut_translate_one_cid
+c01fece4 T acpi_ut_evaluate_object
+c01fee6b T acpi_ut_execute_sxds
+c01feec6 T acpi_ut_execute_STA
+c01fef0d T acpi_ut_execute_UID
+c01fef78 T acpi_ut_execute_CID
+c01ff058 T acpi_ut_evaluate_numeric_object
+c01ff097 T acpi_ut_osi_implementation
+c01ff13f T acpi_ut_execute_HID
+c01ff1a8 T acpi_ut_subsystem_shutdown
+c01ff244 T acpi_ut_validate_exception
+c01ff2b8 T acpi_ut_is_aml_table
+c01ff2dd T acpi_ut_dword_byte_swap
+c01ff305 T acpi_ut_set_integer_width
+c01ff335 T acpi_ut_valid_acpi_char
+c01ff362 T acpi_ut_valid_acpi_name
+c01ff390 T acpi_ut_repair_name
+c01ff3c1 T acpi_ut_print_string
+c01ff4fb T acpi_ut_info
+c01ff52a T acpi_ut_warning
+c01ff572 T acpi_ut_error
+c01ff5ba T acpi_ut_exception
+c01ff60f T acpi_ut_walk_package_tree
+c01ff6cb T acpi_ut_create_update_state_and_push
+c01ff6f4 T acpi_ut_strtoul64
+c01ff931 T acpi_ut_release_owner_id
+c01ff9db T acpi_ut_allocate_owner_id
+c01ffaff T acpi_ut_strupr
+c01ffb24 T acpi_purge_cached_objects
+c01ffb4f T acpi_terminate
+c01ffb5e T acpi_initialize_objects
+c01ffb98 T acpi_enable_subsystem
+c01ffc28 t acpi_ut_copy_isimple_to_esimple
+c01ffd0f T acpi_ut_copy_iobject_to_eobject
+c01ffd9f t acpi_ut_copy_ielement_to_eelement
+c01ffe1b T acpi_ut_copy_eobject_to_iobject
+c01fff65 t acpi_ut_copy_simple_object
+c0200057 T acpi_ut_copy_iobject_to_iobject
+c020012b t acpi_ut_copy_ielement_to_ielement
+c02001d0 t acpi_ut_delete_internal_obj
+c0200315 t acpi_ut_update_ref_count
+c02003b5 T acpi_ut_update_object_reference
+c02004d2 T acpi_ut_remove_reference
+c02004f7 T acpi_ut_delete_internal_object_list
+c0200516 T acpi_ut_add_reference
+c0200530 T acpi_ut_hex_to_ascii_char
+c0200549 T acpi_ut_get_region_name
+c0200568 T acpi_ut_get_event_name
+c020057c T acpi_ut_get_type_name
+c0200590 T acpi_ut_get_descriptor_name
+c02005b2 T acpi_ut_valid_object_type
+c02005bc T acpi_ut_init_globals
+c0200740 T acpi_ut_get_node_name
+c0200787 T acpi_format_exception
+c02007c1 T acpi_ut_get_object_type_name
+c02007e4 T acpi_ut_divide
+c0200975 T acpi_ut_short_divide
+c02009e0 T acpi_ut_valid_internal_object
+c02009f4 t acpi_ut_get_simple_object_size
+c0200aca T acpi_ut_get_object_size
+c0200b30 t acpi_ut_get_element_length
+c0200b73 T acpi_ut_delete_object_desc
+c0200bbe T acpi_ut_allocate_object_desc_dbg
+c0200c1e T acpi_ut_create_internal_object_dbg
+c0200c85 T acpi_ut_create_string_object
+c0200d09 T acpi_ut_create_package_object
+c0200d6e T acpi_ut_create_buffer_object
+c0200dfc T acpi_ut_push_generic_state
+c0200e03 T acpi_ut_pop_generic_state
+c0200e12 T acpi_ut_delete_generic_state
+c0200e23 T acpi_ut_create_generic_state
+c0200e5d T acpi_ut_create_control_state
+c0200e71 T acpi_ut_create_pkg_state
+c0200e9d T acpi_ut_create_update_state
+c0200ebb T acpi_ut_create_thread_state
+c0200f08 T acpi_ut_create_pkg_state_and_push
+c0200f2c T acpi_ut_release_mutex
+c0200f8f T acpi_ut_mutex_terminate
+c0200fce T acpi_ut_mutex_initialize
+c0201046 T acpi_ut_acquire_mutex
+c02010c0 T acpi_ut_get_resource_type
+c02010ce T acpi_ut_get_resource_length
+c02010df T acpi_ut_validate_resource
+c0201167 T acpi_ut_get_resource_header_length
+c0201172 T acpi_ut_get_descriptor_length
+c020118c T acpi_ut_walk_aml_resources
+c0201233 T acpi_ut_get_resource_end_tag
+c0201254 t acpi_poweroff_init
+c02012a2 T acpi_power_off
+c02012c9 T acpi_sleep_prepare
+c02012df t acpi_shutdown
+c0201304 T acpi_gpe_sleep_prepare
+c0201340 T acpi_bus_get_status
+c02013c9 t acpi_bus_check_device
+c020142c T acpi_bus_get_device
+c020145a t acpi_bus_notify
+c02014a0 T acpi_bus_get_power
+c020154f T acpi_bus_set_power
+c02016de T acpi_bus_generate_event
+c020179e T acpi_bus_receive_event
+c020188c t acpi_glue_data_handler
+c020188d t acpi_platform_notify
+c020199b T acpi_get_physical_device
+c02019be t acpi_platform_notify_remove
+c0201a1d T acpi_get_child
+c0201a6a t do_acpi_find_child
+c0201ab3 T unregister_acpi_bus_type
+c0201b0b T register_acpi_bus_type
+c0201b74 t acpi_device_suspend
+c0201b93 t acpi_device_resume
+c0201bb2 t acpi_device_shutdown
+c0201bce t acpi_start_single_object
+c0201c09 T acpi_bus_data_handler
+c0201c0a t acpi_device_release
+c0201c23 T acpi_bus_get_ejd
+c0201c90 t acpi_device_path_show
+c0201ce9 t acpi_device_hid_show
+c0201d09 t acpi_device_unregister
+c0201dac t acpi_device_remove
+c0201e0a t acpi_device_probe
+c0201e86 t acpi_device_uevent
+c0201f67 t acpi_bus_remove
+c0201fbd T acpi_bus_trim
+c0202086 t acpi_eject_store
+c02021a7 T acpi_match_ids
+c02021f8 t acpi_add_single_object
+c0202c9a t acpi_bus_scan
+c0202e25 t acpi_bus_match
+c0202e3b T acpi_bus_unregister_driver
+c0202e45 T acpi_bus_register_driver
+c0202e7d T acpi_bus_add
+c0202eba T acpi_bus_start
+c0202eec t acpi_ec_space_setup
+c0202efe t ec_parse_io_ports
+c0202f2c t acpi_ec_stop
+c0202f7d t acpi_ec_gpe_handler
+c0202fde t acpi_ec_wait
+c0203137 t acpi_ec_transaction
+c020332c T ec_transaction
+c0203373 t acpi_ec_write
+c02033af T ec_write
+c02033cb t acpi_ec_read
+c020340d t acpi_ec_space_handler
+c020350b T ec_read
+c020353e T acpi_ec_burst_disable
+c0203570 T ec_burst_disable
+c0203584 T acpi_ec_burst_enable
+c02035b6 T ec_burst_enable
+c02035ca t ec_install_handlers
+c0203648 t acpi_ec_start
+c0203678 t acpi_ec_remove
+c0203726 t make_acpi_ec
+c0203773 t acpi_ec_info_open_fs
+c0203789 t acpi_ec_read_info
+c02037f9 T acpi_ec_add_query_handler
+c0203856 t acpi_ec_register_query_methods
+c02038aa t acpi_ec_add
+c0203a5d T acpi_ec_remove_query_handler
+c0203aab t acpi_ec_gpe_query
+c0203b84 t acpi_pci_bridge_scan
+c0203bcd t acpi_pci_root_start
+c0203bfb t acpi_pci_root_remove
+c0203c17 t get_root_bridge_busnr_callback
+c0203c4f T acpi_pci_register_driver
+c0203c94 T acpi_pci_unregister_driver
+c0203cdc T acpi_get_pci_rootbridge_handle
+c0203d0e t acpi_pci_root_add
+c0203fc8 T acpi_penalize_isa_irq
+c0203fe4 t acpi_pci_link_remove
+c0204020 t acpi_pci_link_check_current
+c020407a t acpi_pci_link_check_possible
+c020416b t acpi_pci_link_get_current
+c0204234 t acpi_pci_link_set
+c02043ef t irqrouter_resume
+c020444e T acpi_pci_link_free_irq
+c02044e2 T acpi_pci_link_allocate_irq
+c02046e7 t acpi_pci_link_add
+c02048c8 W acpi_unregister_gsi
+c02048c9 t acpi_pci_irq_lookup
+c020495b t acpi_pci_irq_derive
+c02049fb T acpi_pci_irq_disable
+c0204aa2 t acpi_pci_free_irq
+c0204ab4 t acpi_pci_allocate_irq
+c0204b01 T acpi_pci_irq_del_prt
+c0204b86 T acpi_pci_irq_enable
+c0204d63 T acpi_pci_irq_add_prt
+c0204f68 t acpi_pci_data_handler
+c0204f69 T acpi_get_pci_id
+c0205019 T acpi_pci_bind
+c0205278 T acpi_pci_unbind
+c020538f T acpi_pci_bind_root
+c02054b0 t acpi_power_get_state
+c0205506 t acpi_power_get_context
+c0205557 T acpi_power_get_inferred_state
+c02055f7 t acpi_power_on
+c0205708 t acpi_power_resume
+c020576f T acpi_enable_wakeup_device_power
+c0205822 t acpi_power_remove
+c02058a8 t acpi_power_off_device
+c0205982 T acpi_power_transition
+c0205a72 T acpi_disable_wakeup_device_power
+c0205b25 t acpi_power_open_fs
+c0205b3b t acpi_power_seq_show
+c0205bda t acpi_power_add
+c0205d84 t acpi_table_show
+c0205e0f t param_get_acpica_version
+c0205e30 t acpi_system_poll_event
+c0205e59 t acpi_system_close_event
+c0205e7a t acpi_system_open_event
+c0205eb4 t acpi_system_read_event
+c0205f94 T acpi_unlock_battery_dir
+c0205fe2 T acpi_unlock_ac_dir
+c0206030 T acpi_lock_battery_dir
+c0206072 T acpi_lock_ac_dir
+c02060b4 T __pnp_remove_device
+c02060e9 T pnp_unregister_protocol
+c0206112 T __pnp_add_device
+c02061ca T pnp_add_device
+c020622e t pnp_release_device
+c0206267 T pnp_alloc
+c02062af T pnp_register_protocol
+c0206364 t card_remove
+c020636f T pnp_add_card_id
+c02063a7 t card_suspend
+c02063c2 t card_resume
+c02063de T pnp_unregister_card_driver
+c0206407 t pnp_release_card
+c020642e T pnp_release_card_device
+c0206455 t card_probe
+c020655c T pnp_register_card_driver
+c02065f8 T pnp_request_card_device
+c02066b1 T pnp_remove_card_device
+c02066e5 T pnp_remove_card
+c0206742 t pnp_show_card_ids
+c020677c t pnp_show_card_name
+c020679c T pnp_add_card
+c02068eb T pnp_add_card_device
+c02069a0 t card_remove_first
+c02069e8 T pnp_add_id
+c0206a20 t pnp_bus_resume
+c0206a66 t pnp_bus_suspend
+c0206acb T pnp_unregister_driver
+c0206ad3 T pnp_register_driver
+c0206ae7 T pnp_device_detach
+c0206b19 t pnp_device_remove
+c0206b46 T pnp_device_attach
+c0206b85 T compare_pnp_id
+c0206c1c t match_device
+c0206c49 t pnp_bus_match
+c0206c5e t pnp_device_probe
+c0206ce0 T pnp_register_dma_resource
+c0206d0b T pnp_register_port_resource
+c0206d36 T pnp_register_mem_resource
+c0206d61 t pnp_test_handler
+c0206d67 T pnp_check_dma
+c0206ea1 T pnp_check_irq
+c0207011 T pnp_check_mem
+c02071a2 T pnp_check_port
+c0207333 T pnp_free_option
+c020739a T pnp_register_irq_resource
+c02073e6 t pnp_build_option
+c0207410 T pnp_register_dependent_option
+c0207448 T pnp_register_independent_option
+c0207480 T pnp_init_resource_table
+c02075fd t pnp_clean_resource_table
+c0207774 T pnp_resource_change
+c0207799 T pnp_stop_dev
+c02077fb T pnp_disable_dev
+c0207870 T pnp_start_dev
+c02078d8 t pnp_assign_port
+c02079f3 t pnp_assign_mem
+c0207b36 t pnp_assign_irq
+c0207c46 t pnp_assign_dma
+c0207d13 t pnp_assign_resources
+c0207f74 T pnp_auto_config_dev
+c0207ff8 T pnp_activate_dev
+c020803a T pnp_manual_config_dev
+c0208188 T pnp_is_active
+c020821c T pnp_interface_attach_device
+c0208271 t pnp_show_current_ids
+c02082ab t pnp_printf
+c02082fd t pnp_show_current_resources
+c020857b t pnp_print_option
+c0208982 t pnp_show_options
+c0208a0d t pnp_set_current_resources
+c0208ef0 t quirk_smc_fir_enabled
+c0208f4e T pnp_fixup_device
+c0208f88 t quirk_sb16audio_resources
+c0208fda t quirk_smc_enable
+c02091cc t quirk_cmi8330_resources
+c0209213 t quirk_awe32_resources
+c02092ac t reserve_range
+c02093ba t system_pnp_probe
+c0209498 t pnpacpi_resume
+c02094a5 t pnpacpi_suspend
+c02094b5 t pnpacpi_disable_resources
+c02094dd t pnpacpi_set_resources
+c020952f t pnpacpi_get_resources
+c020954c t irq_flags
+c020956a t decode_irq_flags
+c02095af t pnpacpi_parse_allocated_ioresource
+c0209658 t pnpacpi_parse_allocated_memresource
+c02096f3 t pnpacpi_type_resources
+c020971b T pnpacpi_encode_resources
+c0209982 t dma_flags
+c02099f6 T pnpacpi_build_resource_template
+c0209aa0 T pnpacpi_parse_resource_option_data
+c0209ae7 t pnpacpi_option_resource
+c0209e9d T pnpacpi_parse_allocated_resource
+c0209ec5 t pnpacpi_parse_allocated_irqresource
+c0209f8b t pnpacpi_allocated_resource
+c020a1dd t pnpacpi_count_resources
+c020a1f8 t read_null
+c020a1fb t write_null
+c020a1fe t pipe_to_null
+c020a201 t write_full
+c020a207 t null_lseek
+c020a21a t memory_open
+c020a2cf t read_oldmem
+c020a3a8 t write_mem
+c020a42f t kmsg_write
+c020a48e t mmap_zero
+c020a4c4 t read_zero
+c020a685 t splice_write_null
+c020a6aa t write_kmem
+c020a82a t read_kmem
+c020a921 t open_port
+c020a931 t mmap_mem
+c020a9b1 t mmap_kmem
+c020a9d9 t memory_lseek
+c020aa4e t read_port
+c020aac1 t write_port
+c020ab50 t read_mem
+c020abd4 t twothirdsMD4Transform
+c020af5b t credit_entropy_store
+c020afa3 t __add_entropy_words
+c020b127 t account
+c020b1f0 t add_timer_randomness
+c020b2fb T add_disk_randomness
+c020b31f T add_interrupt_randomness
+c020b33f T add_input_randomness
+c020b36e t extract_buf
+c020b440 t extract_entropy
+c020b4c9 T get_random_bytes
+c020b4ec t rekey_seq_generator
+c020b535 T generate_random_uuid
+c020b558 t uuid_strategy
+c020b5d7 t proc_do_uuid
+c020b6ea t xfer_secondary_pool
+c020b7bf t extract_entropy_user
+c020b883 t urandom_read
+c020b88d t write_pool
+c020b8ed t init_std_data
+c020b963 t random_ioctl
+c020baa8 t random_write
+c020baf8 T secure_ip_id
+c020bb39 T get_random_int
+c020bb50 T randomize_range
+c020bb82 T rand_initialize_disk
+c020bba0 T secure_ipv6_port_ephemeral
+c020bbe9 t random_poll
+c020bc31 T secure_tcpv6_sequence_number
+c020bc9f T secure_tcp_sequence_number
+c020bd0f T secure_ipv4_port_ephemeral
+c020bd54 t random_read
+c020be61 T rand_initialize_irq
+c020be94 T tty_name
+c020beb4 t tty_ldisc_assign
+c020becd t hung_up_tty_read
+c020bed0 t hung_up_tty_write
+c020bed6 t hung_up_tty_poll
+c020bedc t hung_up_tty_ioctl
+c020bef0 t hung_up_tty_compat_ioctl
+c020bf04 T tty_hung_up_p
+c020bf12 t tty_default_put_char
+c020bf2c T tty_set_operations
+c020c004 T tty_devnum
+c020c016 t tty_set_termios_ldisc
+c020c039 T tty_paranoia_check
+c020c0a0 T put_tty_driver
+c020c0a5 t tty_buffer_free_all
+c020c0f4 t alloc_tty_struct
+c020c103 t release_one_tty
+c020c1d1 t release_tty
+c020c1fe t check_tty_count
+c020c292 T stop_tty
+c020c300 t tty_ldisc_enable
+c020c329 T proc_clear_tty
+c020c35d t session_clear_tty
+c020c380 t __proc_set_tty
+c020c402 T tty_ldisc_deref
+c020c466 t tty_ldisc_try
+c020c499 T tty_ldisc_ref
+c020c4ae T tty_wakeup
+c020c4fe T start_tty
+c020c578 T tty_ldisc_put
+c020c5bf T tty_ldisc_get
+c020c617 t initialize_tty_struct
+c020c7e6 T tty_unregister_ldisc
+c020c828 T tty_register_ldisc
+c020c885 T tty_schedule_flip
+c020c8c1 T get_current_tty
+c020c91f t tty_buffer_free
+c020c98d t flush_to_ldisc
+c020ca95 T tty_flip_buffer_push
+c020cae1 t tty_buffer_flush
+c020cb26 T tty_ldisc_flush
+c020cb4d t tty_line_name
+c020cb72 T tty_register_device
+c020cc38 t init_dev
+c020d0d2 T tty_buffer_request_room
+c020d1e4 T tty_prepare_flip_string_flags
+c020d21b T alloc_tty_driver
+c020d250 T tty_ldisc_ref_wait
+c020d2d6 t tty_poll
+c020d339 t tty_fasync
+c020d3ee t release_dev
+c020d9dd t tty_release
+c020d9f5 t do_tty_hangup
+c020dd24 T tty_vhangup
+c020dd2e t tty_write
+c020defa T tty_register_driver
+c020e0a6 T tty_unregister_device
+c020e0bd T tty_unregister_driver
+c020e19d T do_SAK
+c020e1ac T tty_hangup
+c020e1b6 T __do_SAK
+c020e373 t do_SAK_work
+c020e37d T disassociate_ctty
+c020e55e T no_tty
+c020e584 t send_break
+c020e5f2 T redirected_tty_write
+c020e66b T tty_check_change
+c020e702 t tty_read
+c020e7b1 T tty_insert_flip_string_flags
+c020e83b T tty_insert_flip_string
+c020e8cb T tty_prepare_flip_string
+c020e912 T tty_ioctl
+c020f4c5 t tty_open
+c020f772 t ptmx_open
+c020f938 t n_tty_set_room
+c020f967 t put_tty_queue_nolock
+c020f9a1 t check_unthrottle
+c020f9cd t opost
+c020fb79 t echo_char
+c020fbde t n_tty_set_termios
+c020fdaa t n_tty_write_wakeup
+c020fdd1 T is_ignored
+c020fe04 t n_tty_chars_in_buffer
+c020fe5f t reset_buffer_flags
+c020fed3 t put_tty_queue
+c020ff07 t n_tty_flush_buffer
+c020ff4a t copy_from_read_buf
+c020fff4 t n_tty_close
+c0210019 t n_tty_open
+c02100a1 t write_chan
+c0210330 t n_tty_receive_buf
+c021104a t normal_poll
+c0211164 t read_chan
+c02116a4 T tty_termios_baud_rate
+c02116e2 T tty_termios_input_baud_rate
+c0211730 T tty_termios_encode_baud_rate
+c0211850 T tty_get_baud_rate
+c0211893 t send_prio_char
+c021191d T tty_wait_until_sent
+c02119d2 t set_termios
+c0211cef T n_tty_ioctl
+c0212178 t pty_write
+c02121b1 t pty_write_room
+c02121ce t pty_chars_in_buffer
+c0212201 t pty_set_termios
+c0212216 t pty_unix98_ioctl
+c0212270 t pty_flush_buffer
+c02122bc t pty_close
+c02123da t pty_unthrottle
+c02123f7 t pty_open
+c0212454 t misc_seq_next
+c021246c t misc_seq_stop
+c0212476 t misc_seq_open
+c0212482 t misc_seq_show
+c02124b4 T misc_deregister
+c021251a t misc_seq_start
+c021255b T misc_register
+c0212649 t misc_open
+c02127b4 T reset_vc
+c021282a t complete_change_console
+c02128e6 T change_console
+c0212955 T vc_SAK
+c0212980 T vt_waitactive
+c0212a14 T vt_ioctl
+c0213eac T vcs_make_sysfs
+c0213f1a t vcs_open
+c0213f38 t vcs_size
+c0213f84 t vcs_lseek
+c0214006 T vcs_remove_sysfs
+c0214037 t vcs_read
+c0214375 t vcs_write
+c0214798 T set_translate
+c02147ab T inverse_translate
+c02147e4 T con_get_unimap
+c02148fb T con_protect_unimap
+c021490e T conv_uni_to_pc
+c021498f t con_release_unimap
+c0214a03 T con_free_unimap
+c0214a38 T con_copy_unimap
+c0214a7f T con_clear_unimap
+c0214b29 t con_insert_unipair
+c0214bba t set_inverse_transl
+c0214c37 t update_user_maps
+c0214c8b t con_unify_unimap
+c0214d98 T con_set_default_unimap
+c0214e98 T con_set_unimap
+c0215038 T con_get_trans_new
+c021507c T con_set_trans_old
+c02150cc T con_get_trans_old
+c0215130 T con_set_trans_new
+c0215178 T clear_selection
+c02151be t sel_pos
+c02151db T sel_loadlut
+c02151f8 T paste_selection
+c02152d6 T set_selection
+c02156e8 t fn_caps_toggle
+c02156fb t fn_caps_on
+c021570e t fn_bare_num
+c0215721 t fn_compose
+c021572c t k_ignore
+c021572d t k_spec
+c021575e t k_ascii
+c0215794 t k_lock
+c02157b7 T getledstate
+c02157bf t kbd_bh
+c02158d9 t kd_nosound
+c021594b t kbd_disconnect
+c0215962 T compute_shiftstate
+c0215a10 t fn_null
+c0215a15 t puts_queue
+c0215ab7 t applkey
+c0215ad8 t k_cur
+c0215b01 t put_queue
+c0215b93 t k_meta
+c0215bc8 t to_utf8
+c0215c16 t k_shift
+c0215cde t handle_diacr
+c0215d8b t k_deadunicode
+c0215dac t k_dead
+c0215dbf t k_dead2
+c0215dcb t k_unicode
+c0215e2a t k_brlcommit
+c0215e86 t k_self
+c0215e95 t fn_send_intr
+c0215f28 t k_brl
+c021605f t k_fn
+c021607e t k_lowercase
+c021608f t k_cons
+c021609c t fn_lastcons
+c02160a6 t fn_spawn_con
+c02160eb t fn_inc_console
+c0216126 t fn_dec_console
+c0216161 t fn_SAK
+c0216172 t fn_boot_it
+c0216177 t fn_scroll_back
+c021617e t fn_scroll_forw
+c0216185 t fn_hold
+c02161ac t fn_show_state
+c02161b3 t fn_show_mem
+c02161b8 t fn_show_ptregs
+c02161c8 T setledstate
+c0216202 t kbd_connect
+c0216282 T getkeycode
+c02162d0 T setkeycode
+c0216319 T kd_mksound
+c02163b1 T kbd_rate
+c0216433 t kbd_start
+c02164c7 t fn_enter
+c021652d t fn_num
+c0216555 t k_pad
+c0216665 t k_slock
+c02166af t kbd_event
+c0216ba0 t do_update_region
+c0216cb5 t build_attr
+c0216dc1 t update_attr
+c0216e81 t insert_char
+c0216f4a t add_softcursor
+c0216fef t clear_buffer_attributes
+c021702c T vc_cons_allocated
+c0217045 t gotoxy
+c02170ad t gotoxay
+c02170bb t csi_J
+c02171cd t default_attr
+c02171e6 T mouse_reporting
+c02171ff t save_cur
+c02172cb t vt_console_device
+c02172e3 t con_write_room
+c02172f5 t con_chars_in_buffer
+c02172f8 t con_throttle
+c02172f9 T con_is_bound
+c0217313 T screen_pos
+c021733a T getconsxy
+c0217346 T vcs_scr_readw
+c021735d T vcs_scr_writew
+c0217375 t vtconsole_init_device
+c02173d0 t show_name
+c0217413 t hide_cursor
+c0217470 t set_cursor
+c02174cc T putconsxy
+c02174eb t con_flush_chars
+c021751a t scrdown
+c02175c8 t scrup
+c0217694 t lf
+c02176d1 t blank_screen_t
+c0217704 T schedule_console_callback
+c021770e T set_console
+c021775a T scrollfront
+c021776e T scrollback
+c0217782 T register_con_driver
+c0217895 t visual_init
+c0217967 t reset_terminal
+c0217b02 t restore_cur
+c0217bc5 t set_palette
+c0217c1e T reset_palette
+c0217c5d t set_get_cmap
+c0217da9 T con_get_cmap
+c0217dc5 T con_set_cmap
+c0217de4 t set_origin
+c0217e6f t vc_init
+c0217efc T invert_screen
+c0218059 t set_mode
+c0218260 T update_region
+c02182dc T con_font_op
+c0218653 T do_blank_screen
+c021886b T unregister_con_driver
+c0218913 T give_up_console
+c0218918 t con_unthrottle
+c021893e t respond_string
+c02189d5 T mouse_report
+c0218a22 t con_close
+c0218a7d T vc_allocate
+c0218baf t con_open
+c0218c2b T redraw_screen
+c0218db1 T do_unblank_screen
+c0218ecb T unblank_screen
+c0218ed2 T poke_blanked_console
+c0218f8d t do_con_write
+c021a6f1 t con_put_char
+c021a71b t con_write
+c021a732 T take_over_console
+c021aa15 T vc_resize
+c021ad02 T vc_lock_resize
+c021ad28 t store_bind
+c021ad38 t show_bind
+c021ad6c T complement_pos
+c021ae88 T screen_glyph
+c021aeb4 T vc_deallocate
+c021af53 t con_start
+c021af8f t con_stop
+c021afe1 t vt_console_print
+c021b20f t console_callback
+c021b2d4 T tioclinux
+c021b460 T sysrq_on
+c021b47b t sysrq_handle_unraw
+c021b48e t sysrq_key_table_key2index
+c021b4b8 T __sysrq_get_key_op
+c021b4ce t sysrq_handle_loglevel
+c021b4f9 t __sysrq_swap_key_ops
+c021b54d T unregister_sysrq_key
+c021b553 T register_sysrq_key
+c021b557 T __handle_sysrq
+c021b660 t sysrq_handle_showstate_blocked
+c021b66a t sysrq_handle_showstate
+c021b671 t sysrq_handle_mountro
+c021b676 t sysrq_handle_sync
+c021b67b t sysrq_handle_show_timers
+c021b680 t sysrq_handle_showregs
+c021b690 t sysrq_handle_unrt
+c021b695 t sysrq_handle_showmem
+c021b69a t sysrq_handle_moom
+c021b6a4 t sysrq_handle_SAK
+c021b6b5 t send_sig_all
+c021b6ef t sysrq_handle_kill
+c021b704 t sysrq_handle_term
+c021b719 t moom_callback
+c021b72a t sysrq_handle_reboot
+c021b730 t sysrq_handle_crashdump
+c021b73b T handle_sysrq
+c021b758 t get_rtc_alm_time
+c021b7e1 t rtc_poll
+c021b821 t rtc_open
+c021b863 t rtc_fasync
+c021b874 t mask_rtc_irq_bit_locked
+c021b8b1 t mask_rtc_irq_bit
+c021b8d1 t rtc_release
+c021b975 t rtc_dropped_irq
+c021ba54 T rtc_get_rtc_time
+c021bbd1 t set_rtc_irq_bit_locked
+c021bc0c t rtc_do_ioctl
+c021c2af T rtc_control
+c021c314 t rtc_ioctl
+c021c321 t rtc_proc_open
+c021c32f t rtc_proc_show
+c021c4fe T rtc_unregister
+c021c5aa T rtc_register
+c021c623 T rtc_interrupt
+c021c707 t rtc_read
+c021c7f0 t hpet_acpi_remove
+c021c7f6 t hpet_fasync
+c021c814 t hpet_poll
+c021c854 t hpet_open
+c021c8e3 t hpet_mmap
+c021c971 t hpet_ioctl_common
+c021cdab T hpet_control
+c021ce34 t hpet_ioctl
+c021ce51 T hpet_alloc
+c021d1f7 t hpet_acpi_add
+c021d26f t hpet_read
+c021d353 t hpet_interrupt
+c021d426 T hpet_register
+c021d52f t hpet_release
+c021d5ee T hpet_unregister
+c021d6a2 t hpet_resources
+c021d790 t rng_dev_open
+c021d7a6 t hwrng_attr_current_show
+c021d800 t hwrng_attr_available_show
+c021d911 T hwrng_unregister
+c021d9ba t hwrng_attr_current_store
+c021da67 T hwrng_register
+c021db97 t rng_dev_read
+c021dcdc t intel_rng_data_present
+c021dce6 t intel_rng_data_read
+c021dcf7 t intel_rng_cleanup
+c021dd1f t intel_rng_init
+c021dd50 t hangcheck_fire
+c021de14 t __uart_start
+c021de44 T uart_update_timeout
+c021de98 T uart_get_divisor
+c021dec7 t uart_change_speed
+c021df1e t uart_write_room
+c021df34 t uart_chars_in_buffer
+c021df49 t uart_type
+c021df63 T uart_console_write
+c021df96 t uart_change_pm
+c021dfbe T uart_console_device
+c021dfcb T uart_match_port
+c021e015 T uart_remove_one_port
+c021e0ea t uart_send_xchar
+c021e12e t uart_put_char
+c021e18b t uart_start
+c021e1b5 t uart_flush_chars
+c021e1b7 t uart_stop
+c021e1de T uart_unregister_driver
+c021e205 t uart_tiocmget
+c021e268 t uart_read_proc
+c021e76a t uart_wait_until_sent
+c021e82d t uart_write
+c021e928 t uart_flush_buffer
+c021e99c t uart_tasklet_action
+c021e9a6 t uart_shutdown
+c021ea53 t uart_startup
+c021eb5f t uart_open
+c021eed9 T uart_register_driver
+c021eff6 T uart_resume_port
+c021f0f2 T uart_suspend_port
+c021f196 T uart_get_baud_rate
+c021f234 T uart_write_wakeup
+c021f256 T uart_add_one_port
+c021f4de t uart_break_ctl
+c021f520 t uart_ioctl
+c021fe14 t uart_close
+c021ffb0 t uart_hangup
+c0220050 t uart_throttle
+c02200ad t uart_unthrottle
+c0220116 t uart_tiocmset
+c0220198 t uart_set_termios
+c02202fc t serial_in
+c0220363 t serial_out
+c0220401 t serial_out_sync
+c0220444 t serial_icr_write
+c0220468 t serial_icr_read
+c02204b3 t __enable_rsa
+c02204f6 t autoconfig_read_divisor_id
+c02205a7 t serial8250_stop_tx
+c02205ee t serial8250_stop_rx
+c022060a t serial8250_enable_ms
+c0220636 t serial8250_set_mctrl
+c0220693 t serial8250_pm
+c0220745 t serial8250_verify_port
+c0220774 t serial8250_type
+c022078c t size_fifo
+c0220918 t serial8250_suspend
+c0220951 T serial8250_suspend_port
+c0220967 t serial8250_request_rsa_resource
+c02209c0 t serial8250_release_rsa_resource
+c0220a06 t serial8250_request_std_resource
+c0220ae8 t serial8250_break_ctl
+c0220b28 t serial8250_tx_empty
+c0220b57 t serial8250_release_std_resource
+c0220be2 t serial8250_config_port
+c022155c t serial8250_request_port
+c022158a t serial8250_release_port
+c02215a2 t serial8250_set_termios
+c022186a t serial_do_unlink
+c02218aa t serial8250_shutdown
+c0221a01 t receive_chars
+c0221c34 t check_modem_status
+c0221d2d t serial8250_get_mctrl
+c0221d61 t transmit_chars
+c0221e23 t serial8250_start_tx
+c0221ecd t serial8250_find_match_or_unused
+c0221f52 T serial8250_unregister_port
+c0221fb8 T serial8250_unregister_by_port
+c0221fcd t serial8250_remove
+c0221ffe T serial8250_register_port
+c02220b2 t serial8250_probe
+c02221cf T serial8250_resume_port
+c0222231 t serial8250_resume
+c0222267 t serial8250_console_write
+c0222385 t serial8250_backup_timeout
+c022246e t serial8250_startup
+c0222974 t serial8250_console_putchar
+c02229ea t serial8250_interrupt
+c0222b04 t serial8250_timeout
+c0222b88 t check_resources
+c0222bcb t serial_pnp_resume
+c0222be5 t check_name
+c0222c10 t serial_pnp_probe
+c0222d2d t serial_pnp_remove
+c0222d3e t serial_pnp_suspend
+c0222d58 t pci_hp_diva_init
+c0222db0 t pci_timedia_init
+c0222de1 t pci_netmos_init
+c0222df1 t find_quirk
+c0222e43 t serial_pci_guess_board
+c0222f9a t moan_device
+c0222fdb T pciserial_resume_ports
+c0223007 t pciserial_resume_one
+c0223036 T pciserial_suspend_ports
+c0223054 T pciserial_remove_ports
+c02230a6 t pci_xircom_init
+c02230b3 t setup_port
+c0223196 t pci_default_setup
+c0223285 t titan_400l_800l_setup
+c02232cf t pci_timedia_setup
+c0223322 t pci_siig_setup
+c0223363 t sbs_setup
+c02233b6 t pci_hp_diva_setup
+c022342e t afavlab_setup
+c0223474 t sbs_exit
+c02234d4 t pci_siig_init
+c02235fb t pci_inteli960ni_init
+c0223642 T pciserial_init_ports
+c0223772 t pciserial_remove_one
+c0223792 t pciserial_suspend_one
+c02237c5 t pciserial_init_one
+c02238d0 t pci_plx9050_init
+c022394b t pci_plx9050_exit
+c0223986 t sbs_init
+c0223a0c T dev_driver_string
+c0223a35 t dev_attr_show
+c0223a50 t dev_attr_store
+c0223a7c t dev_uevent_filter
+c0223ac0 t dev_uevent_name
+c0223ae2 t device_release
+c0223b60 T get_device
+c0223b79 t klist_children_get
+c0223b81 t get_device_parent
+c0223c89 t device_move_class_links
+c0223cc4 t next_device
+c0223cd5 T device_find_child
+c0223d20 T device_for_each_child
+c0223d5c T put_device
+c0223d6b T device_move
+c0223e4e t klist_children_put
+c0223e56 t store_uevent
+c0223eab t show_dev
+c0223edb t show_uevent
+c0223fb3 t device_remove_groups
+c0223fd6 t device_add_groups
+c022402a T device_initialize
+c02240bd T device_schedule_callback_owner
+c02240d6 T device_remove_bin_file
+c02240e5 T device_create_bin_file
+c02240f9 T device_remove_file
+c0224121 t device_remove_attributes
+c0224142 t device_remove_attrs
+c0224181 T device_del
+c02243c3 T device_unregister
+c02243d3 T device_destroy
+c022445a T device_create_file
+c0224488 T device_add
+c0224903 T device_register
+c0224913 t dev_uevent
+c0224af6 t device_create_release
+c0224afb T device_rename
+c0224bcc T device_create
+c0224c68 t sysdev_show
+c0224c84 t sysdev_store
+c0224ca6 t sysdev_class_show
+c0224cc2 t sysdev_class_store
+c0224ce4 t __sysdev_resume
+c0224d37 T sysdev_class_remove_file
+c0224d3f T sysdev_remove_file
+c0224d47 T sysdev_class_create_file
+c0224d4f T sysdev_create_file
+c0224d57 T sysdev_class_register
+c0224d72 T sysdev_class_unregister
+c0224d7a T sysdev_shutdown
+c0224e3a T sysdev_suspend
+c0225009 T sysdev_resume
+c0225050 T sysdev_driver_unregister
+c02250d4 T sysdev_register
+c02251b0 T sysdev_unregister
+c0225237 T sysdev_driver_register
+c02252d8 t drv_attr_show
+c02252f4 t drv_attr_store
+c0225316 t driver_release
+c0225317 t bus_attr_show
+c0225330 t bus_attr_store
+c022534f t driver_helper
+c0225374 t store_drivers_autoprobe
+c0225390 T bus_unregister_notifier
+c022539a T bus_register_notifier
+c02253a4 t show_drivers_autoprobe
+c02253ca t bus_rescan_devices_helper
+c0225437 t klist_devices_put
+c022543f t klist_devices_get
+c0225447 T put_bus
+c022544f T get_bus
+c022546c T device_reprobe
+c02254d6 t device_remove_attrs
+c0225505 T bus_attach_device
+c0225578 T bus_for_each_drv
+c02255d0 t next_device
+c02255e1 T bus_find_device
+c022563c t store_drivers_probe
+c0225671 T bus_for_each_dev
+c02256c6 T bus_rescan_devices
+c02256db T bus_remove_file
+c0225700 t remove_probe_files
+c022571c T bus_unregister
+c0225768 T bus_create_file
+c0225796 T bus_add_device
+c022587a T bus_remove_device
+c02258e6 T bus_add_driver
+c0225a56 T bus_remove_driver
+c0225acb T bus_register
+c0225cc7 t driver_unbind
+c0225d72 t driver_bind
+c0225e68 T driver_probe_done
+c0225e77 t driver_sysfs_remove
+c0225ea7 t __device_release_driver
+c0225f35 T driver_attach
+c0225f4d t driver_sysfs_add
+c0225fa9 t driver_bound
+c0226012 T driver_probe_device
+c0226171 t __device_attach
+c0226176 T device_bind_driver
+c0226191 T device_attach
+c0226212 t __driver_attach
+c02262b3 T device_release_driver
+c02262f6 T driver_detach
+c02263c8 T driver_find
+c02263e0 T driver_unregister
+c02263e5 T driver_register
+c022644c T put_driver
+c0226454 T get_driver
+c0226468 T driver_remove_file
+c022648d T driver_create_file
+c02264bb t next_device
+c02264cc T driver_find_device
+c0226525 T driver_for_each_device
+c0226578 t class_attr_show
+c0226594 t class_attr_store
+c02265b6 T class_device_put
+c02265c3 t class_put
+c02265d0 T class_device_get
+c02265e4 t class_get
+c0226601 t store_uevent
+c0226615 t show_dev
+c0226642 t class_device_remove_groups
+c0226668 T class_device_initialize
+c0226681 T class_device_remove_bin_file
+c022668e T class_device_create_bin_file
+c02266a0 T class_device_remove_file
+c02266ad t class_device_remove_attrs
+c02266dd T class_device_del
+c02267d9 T class_device_unregister
+c02267e9 T class_remove_file
+c02267f6 T class_device_create_file
+c0226808 T class_device_add
+c0226af2 T class_device_register
+c0226b02 T class_device_create
+c0226b9b T class_create_file
+c0226bad T class_unregister
+c0226bdf T class_register
+c0226d02 t class_release
+c0226d12 t class_create_release
+c0226d17 t class_device_create_release
+c0226d1c t class_device_create_uevent
+c0226d1f t class_uevent
+c0226f0e T class_interface_unregister
+c0226fcb t class_device_attr_store
+c0226fea t class_dev_release
+c022704e t class_uevent_filter
+c0227072 t class_uevent_name
+c0227078 t class_device_attr_show
+c0227091 T class_destroy
+c02270a2 T class_device_destroy
+c022710b T class_interface_register
+c02271e3 T class_create
+c022723c T platform_get_resource
+c0227293 T platform_get_irq
+c02272ad T platform_get_resource_byname
+c0227310 T platform_get_irq_byname
+c022732a t platform_drv_probe
+c0227337 t platform_drv_probe_fail
+c022733d t platform_drv_remove
+c022734a t platform_drv_shutdown
+c0227357 t platform_drv_suspend
+c0227364 t platform_drv_resume
+c0227371 t platform_match
+c022739b t platform_suspend
+c02273b5 t platform_suspend_late
+c02273cf t platform_resume_early
+c02273e9 t platform_resume
+c0227403 t platform_uevent
+c0227431 t modalias_show
+c0227467 T platform_driver_unregister
+c022746f T platform_driver_register
+c02274cd T platform_driver_probe
+c0227537 T platform_device_del
+c0227574 T platform_device_add
+c0227690 T platform_device_register
+c02276a3 T platform_device_add_resources
+c02276fd T platform_device_add_data
+c0227747 T platform_device_alloc
+c02277aa t platform_device_release
+c02277ce T platform_device_put
+c02277db T platform_device_register_simple
+c0227825 T platform_device_unregister
+c0227835 T platform_add_devices
+c0227873 T dma_get_required_mask
+c02278d4 T get_cpu_sysdev
+c02278e5 T register_cpu
+c022791f t show_crash_notes
+c0227954 T firmware_register
+c0227960 T firmware_unregister
+c0227968 T kobj_map_init
+c02279d7 T kobj_unmap
+c0227a7e T kobj_lookup
+c0227b8c T kobj_map
+c0227c7c t group_open_release
+c0227c7d t group_close_release
+c0227c7e t node_to_group
+c0227c99 t find_dr
+c0227cea t find_group
+c0227d2c t devm_kzalloc_release
+c0227d2d t devm_kzalloc_match
+c0227d35 T devres_remove
+c0227d9e T devres_find
+c0227deb T devres_free
+c0227e03 T devres_destroy
+c0227e28 T devm_kfree
+c0227e71 t release_nodes
+c0227f98 T devres_release_group
+c022801c T devres_release_all
+c0228046 t add_dr
+c0228060 T devres_close_group
+c02280cc T devres_get
+c022812d T devres_add
+c022815d T devm_kzalloc
+c02281ae T devres_open_group
+c0228223 T devres_remove_group
+c02282b1 T devres_alloc
+c02282f4 T attribute_container_classdev_to_container
+c02282f8 T attribute_container_find_class_device
+c022833b T attribute_container_remove_attrs
+c0228360 T attribute_container_class_device_del
+c0228370 T attribute_container_add_attrs
+c022839b T attribute_container_add_class_device
+c02283b1 T attribute_container_add_class_device_adapter
+c02283b8 T attribute_container_trigger
+c02283ff t attribute_container_release
+c0228413 T attribute_container_unregister
+c0228459 t internal_container_klist_put
+c0228461 t internal_container_klist_get
+c0228469 T attribute_container_device_trigger
+c02284f2 T attribute_container_register
+c0228536 T attribute_container_add_device
+c0228640 T attribute_container_remove_device
+c02286e8 t anon_transport_dummy_function
+c02286eb t transport_setup_classdev
+c0228705 t transport_configure
+c022871f T transport_destroy_device
+c0228729 t transport_destroy_classdev
+c0228740 T transport_remove_device
+c022874a T transport_configure_device
+c0228754 T transport_add_device
+c022875e t transport_remove_classdev
+c022879e t transport_add_class_device
+c02287c3 T transport_setup_device
+c02287cd T anon_transport_class_unregister
+c02287d7 T anon_transport_class_register
+c0228809 T transport_class_unregister
+c022880e T transport_class_register
+c0228814 T device_shutdown
+c022886c T device_pm_remove
+c02288d7 T device_pm_set_parent
+c02288f8 T device_pm_add
+c0228974 T __suspend_report_result
+c02289b2 T device_power_down
+c0228a68 T suspend_device
+c0228be4 T device_suspend
+c0228d50 T dpm_power_up
+c0228d9f T device_power_up
+c0228da9 T resume_device
+c0228e9d T dpm_resume
+c0228f64 T device_resume
+c0228fb0 t runtime_resume
+c0228fd1 T dpm_runtime_suspend
+c022903f T dpm_runtime_resume
+c0229084 T dpm_sysfs_remove
+c0229093 t wake_show
+c02290d8 T dpm_sysfs_add
+c02290e7 t wake_store
+c0229180 T dmam_release_declared_memory
+c02291ca t dmam_match
+c022921d t dmam_coherent_decl_release
+c0229222 T dmam_declare_coherent_memory
+c022928b T dmam_free_noncoherent
+c02292f5 T dmam_free_coherent
+c022935f t dmam_noncoherent_release
+c0229376 t dmam_coherent_release
+c022938d T dmam_alloc_noncoherent
+c02293ff T dmam_alloc_coherent
+c0229474 t dmam_pool_match
+c022947c T dma_pool_free
+c02295b4 T dma_pool_destroy
+c02296ac T dmam_pool_destroy
+c0229707 t dmam_pool_release
+c022970e T dma_pool_create
+c0229827 T dmam_pool_create
+c0229892 t show_pools
+c022995b T dma_pool_alloc
+c0229ad4 t firmware_timeout_store
+c0229af6 t firmware_timeout_show
+c0229b16 t fw_dev_release
+c0229b33 T release_firmware
+c0229b4c t fw_load_abort
+c0229b5a t firmware_class_timeout
+c0229b5c t _request_firmware
+c0229dfd t request_firmware_work_func
+c0229e82 T request_firmware
+c0229e93 t firmware_uevent
+c0229f45 t firmware_loading_show
+c0229f6e t firmware_loading_store
+c022a020 t firmware_data_read
+c022a0ba t firmware_data_write
+c022a1f8 T request_firmware_nowait
+c022a2e4 t show_core_id
+c022a30b t show_physical_package_id
+c022a332 t show_core_siblings
+c022a373 t show_thread_siblings
+c022a3b4 t ramdisk_writepages
+c022a3b7 t ramdisk_set_page_dirty
+c022a3c6 t rd_ioctl
+c022a411 t rd_open
+c022a4c4 t ramdisk_commit_write
+c022a4ce t make_page_uptodate
+c022a543 t ramdisk_writepage
+c022a572 t ramdisk_readpage
+c022a58d t ramdisk_prepare_write
+c022a59d t rd_make_request
+c022a7f0 t always_on
+c022a7f6 t loopback_net_exit
+c022a800 t loopback_net_init
+c022a8ac t loopback_xmit
+c022a90d t get_stats
+c022a95c t etun_get_stats
+c022a966 t etun_get_settings
+c022a99f t etun_get_strings
+c022a9b5 t etun_get_stats_count
+c022a9bb t etun_get_ethtool_stats
+c022a9cd t etun_get_rx_csum
+c022a9de t etun_set_rx_csum
+c022a9f1 t etun_get_tx_csum
+c022a9fb t etun_set_tx_csum
+c022aa11 t etun_change_mtu
+c022aa26 t etun_set_multicast_list
+c022aa27 t etun_ioctl
+c022aa2d t is_valid_name
+c022aa4d t etun_noget
+c022aa50 t etun_unregister_pair
+c022ab03 t etun_cleanup
+c022ab33 t etun_delif
+c022abc8 t etun_stop
+c022abf2 t etun_alloc
+c022acfc t etun_open
+c022ad33 t etun_xmit
+c022ae28 t etun_get_drvinfo
+c022ae57 t etun_newif
+c022afbc t pci_bus_clock_list
+c022afd5 t pci_bus_clock_list_ultra
+c022afee t aec62xx_init_one
+c022affe t init_setup_aec62xx
+c022b003 t aec62xx_irq_timeout
+c022b02c t aec62xx_tune_chipset
+c022b286 t aec62xx_tune_drive
+c022b2b0 t aec62xx_config_drive_xfer_rate
+c022b2df t init_setup_aec6x80
+c022b33a t init_hwif_aec62xx
+c022b43d t init_chipset_aec62xx
+c022b56a t init_dma_aec62xx
+c022b648 t alim15x3_init_one
+c022b676 t init_dma_ali15x3
+c022b6a9 t ali15x3_dma_setup
+c022b6d6 t ali_udma_filter
+c022b717 t ali15x3_tune_pio
+c022b8e0 t ali15x3_tune_drive
+c022b8fa t ali15x3_config_drive_for_dma
+c022b91c t init_hwif_ali15x3
+c022bbfd t ali15x3_tune_chipset
+c022bd61 t init_chipset_ali15x3
+c022be9c t ide_find_best_mode
+c022c001 t ide_timing_merge
+c022c0e6 t ide_timing_compute
+c022c344 t init_hwif_amd74xx
+c022c458 t amd74xx_probe
+c022c4c6 t amd_set_drive
+c022c815 t amd74xx_ide_dma_check
+c022c896 t amd74xx_tune_drive
+c022c8c4 t init_chipset_amd74xx
+c022cb18 t atiixp_init_one
+c022cb27 t init_hwif_atiixp
+c022cc43 t atiixp_dma_host_off
+c022ccbf t atiixp_tuneproc
+c022cdd2 t atiixp_speedproc
+c022cfa2 t atiixp_dma_check
+c022d035 t atiixp_dma_host_on
+c022d0c8 t quantize_timing
+c022d0d5 t cmd64x_init_one
+c022d100 t init_setup_cmd64x
+c022d105 t init_setup_cmd646
+c022d143 t init_hwif_cmd64x
+c022d2f9 t program_cycle_times
+c022d3a5 t cmd64x_tune_pio
+c022d4ab t cmd64x_tune_drive
+c022d4cf t cmd64x_config_drive_for_dma
+c022d4fe t cmd648_ide_dma_end
+c022d536 t cmd648_ide_dma_test_irq
+c022d572 t cmd646_1_ide_dma_end
+c022d5c8 t cmd64x_ide_dma_test_irq
+c022d631 t cmd64x_tune_chipset
+c022d7ca t cmd64x_ide_dma_end
+c022d837 t init_chipset_cmd64x
+c022d9e0 t cs5520_dma_on
+c022d9e7 t init_hwif_cs5520
+c022da7f t cs5520_tune_chipset
+c022dbc0 t cs5520_tune_drive
+c022dbea t cs5520_config_drive_xfer_rate
+c022dbf7 t cs5520_init_setup_dma
+c022dc21 t cs5520_init_one
+c022dd0c t cs5530_tunepio
+c022dd59 t cs5530_init_one
+c022dd63 t cs5530_config_dma
+c022dd71 t cs5530_udma_filter
+c022dddb t cs5530_set_xfer_mode
+c022de0e t cs5530_tuneproc
+c022de51 t cs5530_tune_chipset
+c022df39 t init_hwif_cs5530
+c022e044 t init_chipset_cs5530
+c022e184 t cs5535_init_one
+c022e18e t init_hwif_cs5535
+c022e255 t cs5535_set_speed
+c022e3d9 t cs5535_tuneproc
+c022e42c t cs5535_set_drive
+c022e454 t cs5535_dma_check
+c022e4a4 t calc_clk
+c022e4cd t cy82c693_dma_enable
+c022e518 t init_hwif_cy82c693
+c022e5ae t init_iops_cy82c693
+c022e5d6 t cy82c693_init_one
+c022e610 t cy82c693_ide_dma_on
+c022e658 t init_chipset_cy82c693
+c022e674 t cy82c693_tune_drive
+c022e82c t hpt34x_tune_chipset
+c022e934 t hpt34x_tune_drive
+c022e95e t hpt34x_config_drive_xfer_rate
+c022e98a t hpt34x_init_one
+c022e9e2 t init_chipset_hpt34x
+c022eb60 t init_hwif_hpt34x
+c022ec30 t check_in_drive_list
+c022ec60 t get_speed_setting
+c022ec81 t hpt3xx_intrproc
+c022ec9c t hpt3xxn_rw_disk
+c022ed94 t hpt366_init_one
+c022edbf t hpt370_clear_engine
+c022edf0 t hpt370_irq_timeout
+c022ee6c t hpt370_ide_dma_timeout
+c022ee7c t hpt370_ide_dma_end
+c022eebd t hpt370_ide_dma_start
+c022eecd t hpt3xx_quirkproc
+c022eefa t hpt3xx_tune_chipset
+c022f0c5 t hpt3xx_tune_drive
+c022f0ef t hpt366_config_drive_xfer_rate
+c022f122 t hpt3xx_udma_filter
+c022f1c7 t init_setup_hpt374
+c022f25c t init_setup_hpt372n
+c022f26b t init_dma_hpt366
+c022f329 t init_setup_hpt372a
+c022f379 t init_setup_hpt302
+c022f3c9 t init_setup_hpt366
+c022f550 t hpt3xx_maskproc
+c022f608 t hpt366_ide_dma_lostirq
+c022f6cf t hpt374_ide_dma_end
+c022f75c t init_setup_hpt371
+c022f7ed t hpt374_ide_dma_test_irq
+c022f862 t init_chipset_hpt366
+c022fe0f t hpt3xx_busproc
+c022ff81 t init_hwif_hpt366
+c0230290 t it821x_init_one
+c02302a2 t it821x_fixups
+c0230460 t it821x_program_udma
+c02304e4 t it821x_program
+c0230527 t it821x_clock_strategy
+c0230662 t it821x_tunepio
+c0230718 t it821x_tuneproc
+c0230740 t it821x_config_drive_for_dma
+c023075e t init_chipset_it821x
+c023085b t it821x_dma_start
+c023089f t it821x_dma_end
+c02308df t it821x_tune_chipset
+c0230adb t init_hwif_it821x
+c0230c54 t jmicron_tuneproc
+c0230c55 t jmicron_init_one
+c0230c67 t init_hwif_jmicron
+c0230dce t jmicron_config_drive_for_dma
+c0230e08 t jmicron_tune_chipset
+c0230e20 t pdc_old_disable_66MHz_clock
+c0230e48 t pdc202xx_init_one
+c0230e58 t init_setup_pdc202xx
+c0230e5d t init_setup_pdc20265
+c0230e9f t init_hwif_pdc202xx
+c0231020 t pdc202xx_ide_dma_timeout
+c023103c t pdc202xx_ide_dma_lostirq
+c0231058 t pdc202xx_tune_chipset
+c02312fd t pdc202xx_reset_host
+c023137c t pdc202xx_quirkproc
+c02313ab t pdc202xx_tune_drive
+c02313d5 t pdc202xx_reset
+c02313f6 t pdc202xx_config_drive_xfer_rate
+c0231429 t init_chipset_pdc202xx
+c0231482 t pdc202xx_old_ide_dma_end
+c02314e4 t pdc202xx_old_ide_dma_test_irq
+c0231505 t init_dma_pdc202xx
+c0231591 t pdc202xx_old_ide_dma_start
+c023163f t init_setup_pdc202ata4
+c02316d0 t read_counter
+c023177d t init_hwif_pdc202new
+c023185b t pdc202new_init_one
+c023186b t pdcnew_reset
+c0231898 t init_setup_pdc20276
+c02318da t init_setup_pdcnew
+c02318df t init_setup_pdc20270
+c023196f t pdcnew_tune_chipset
+c0231b75 t pdcnew_quirkproc
+c0231ba4 t pdcnew_tune_drive
+c0231bce t pdcnew_config_drive_xfer_rate
+c0231c01 t init_chipset_pdcnew
+c0231e70 t piix_dma_clear_irq
+c0231e91 t piix_init_one
+c0231ea0 t init_hwif_piix
+c0232094 t piix_tune_pio
+c023222b t piix_tune_drive
+c0232264 t piix_config_drive_xfer_rate
+c0232297 t piix_tune_chipset
+c02325cc t init_chipset_piix
+c0232680 t rz1000_init_one
+c023268a t init_hwif_rz1000
+c023271c t init_hwif_svwks
+c02328c3 t svwks_init_one
+c02328d3 t init_setup_csb6
+c023291a t init_setup_svwks
+c023291f t svwks_tune_chipset
+c0232d58 t svwks_tune_drive
+c0232d82 t svwks_config_drive_xfer_rate
+c0232db5 t svwks_udma_filter
+c0232eeb t init_chipset_svwks
+c0233154 t siimage_selreg
+c0233188 t siimage_init_one
+c0233197 t proc_reports_siimage
+c0233204 t siimage_tuneproc
+c02333b8 t config_siimage_chipset_for_pio
+c0233490 t siimage_config_drive_for_dma
+c02334bf t init_iops_siimage
+c023367b t siimage_mmio_ide_dma_test_irq
+c023372b t siimage_reset_poll
+c0233776 t siimage_pre_reset
+c02337a6 t siimage_fixup
+c023387a t init_hwif_siimage
+c0233a2f t sil_udma_filter
+c0233ad9 t siimage_io_ide_dma_test_irq
+c0233b2c t siimage_busproc
+c0233bca t siimage_tune_chipset
+c0233f58 t siimage_reset
+c023407c t init_chipset_siimage
+c02344c8 t sis5513_init_one
+c02344d2 t init_hwif_sis5513
+c023467b t sis5513_tune_drive
+c02348f4 t sis5513_tuneproc
+c02348fc t sis5513_config_xfer_rate
+c023493b t sis5513_tune_chipset
+c0234b84 t init_chipset_sis5513
+c0234f9c t slc90e66_init_one
+c0234fa6 t init_hwif_slc90e66
+c02350b9 t slc90e66_tune_pio
+c0235250 t slc90e66_tune_drive
+c0235289 t slc90e66_config_drive_xfer_rate
+c02352bc t slc90e66_tune_chipset
+c0235538 t init_hwif_triflex
+c0235595 t triflex_init_one
+c023559f t triflex_tune_chipset
+c023568d t triflex_tune_drive
+c02356b7 t triflex_config_drive_xfer_rate
+c02356d8 t ide_find_best_mode
+c023583d t ide_timing_merge
+c0235922 t ide_timing_compute
+c0235b80 t init_hwif_via82cxxx
+c0235c9f t via_set_drive
+c0235fa8 t via82cxxx_tune_drive
+c0235fd6 t via_config_find
+c0236042 t via_init_one
+c0236099 t via82cxxx_ide_dma_check
+c023611e t init_chipset_via82cxxx
+c0236414 t init_hwif_generic
+c0236491 t generic_init_one
+c0236568 T set_io_32bit
+c0236580 t ide_bus_match
+c0236586 t generic_ide_probe
+c02365a6 t generic_ide_remove
+c02365c3 t generic_ide_shutdown
+c02365df t modalias_show
+c0236635 t drivename_show
+c0236655 t ide_system_bus_speed
+c02366c0 T system_bus_clock
+c02366cc t init_hwif_data
+c02367c4 t init_hwif_default
+c02368b3 T set_pio_mode
+c023690c T ide_spin_wait_hwgroup
+c023696f t set_unmaskirq
+c02369a9 T set_using_dma
+c0236a64 t set_ksettings
+c0236a96 T ide_hwif_release_regions
+c0236b28 T ide_unregister
+c0237098 T ide_register_hw_with_fixup
+c02371fe T ide_register_hw
+c023720f t hwif_request_region
+c0237265 T ide_hwif_request_regions
+c0237339 T ide_setup_ports
+c0237397 t generic_ide_suspend
+c0237432 t generic_ide_resume
+c02374e0 T generic_ide_ioctl
+c0237a19 t media_show
+c0237a6f t ide_uevent
+c0237bcc t ide_complete_power_step
+c0237c1b T ide_init_sg_cmd
+c0237c42 T ide_stall_queue
+c0237c62 T ide_init_drive_cmd
+c0237c87 t ide_cmd
+c0237ce9 t ide_complete_pm_request
+c0237d47 T ide_end_drive_cmd
+c0238015 T ide_map_sg
+c0238086 T ide_get_error_location
+c0238157 T ide_end_request
+c023821d t ide_kill_rq
+c0238246 t ide_do_request
+c0238b2e T ide_do_drive_cmd
+c0238c4b T ide_intr
+c0238e0c T do_ide_request
+c0238e20 T __ide_abort
+c0238e32 T ide_abort
+c0238e82 T __ide_error
+c023901d T ide_error
+c023908e T ide_timer_expiry
+c02392fb T ide_end_dequeued_request
+c02393b3 t drive_cmd_intr
+c0239460 t ide_inb
+c0239467 t ide_inw
+c023946f t ide_insw
+c0239479 t ide_insl
+c0239482 t ide_outbsync
+c0239488 t ide_outw
+c023948e t ide_outsw
+c0239498 t ide_outsl
+c02394a1 T default_hwif_iops
+c02394fc t ide_mm_inb
+c0239502 t ide_mm_inw
+c0239509 t ide_mm_insw
+c023951f t ide_mm_insl
+c0239533 t ide_mm_outbsync
+c0239539 t ide_mm_outw
+c0239540 t ide_mm_outsw
+c0239556 t ide_mm_outsl
+c023956a T default_hwif_mmiops
+c02395c5 T ide_read_24
+c0239613 T SELECT_DRIVE
+c0239639 T SELECT_INTERRUPT
+c023965b T SELECT_MASK
+c0239671 T QUIRK_LIST
+c023968a t ata_vlb_sync
+c02396b4 t ata_input_data
+c0239718 t atapi_input_bytes
+c0239757 t atapi_output_bytes
+c0239796 T default_hwif_transport
+c02397bf T ide_fix_driveid
+c02397c0 T drive_is_ready
+c02397eb T set_transfer
+c023981f T ide_wait_not_busy
+c0239865 t check_dma_crc
+c0239903 t pre_reset
+c0239996 T eighty_ninty_three
+c0239a08 T ide_ata66_check
+c0239a46 T wait_for_ready
+c0239ac0 t __ide_set_handler
+c0239b33 t do_reset1
+c0239cca T ide_do_reset
+c0239cd1 T ide_set_handler
+c0239d12 t reset_pollfunc
+c0239e91 t atapi_reset_pollfunc
+c0239f47 T ide_execute_command
+c0239fec T ide_fixstring
+c023a068 T ide_config_drive_speed
+c023a3a2 t ata_output_data
+c023a406 T ide_wait_stat
+c023a4f5 t ide_mm_outb
+c023a4fb t ide_outb
+c023a4fd T ide_driveid_update
+c023a634 T ide_xfer_verbose
+c023a73b T ide_use_fast_pio
+c023a762 T ide_get_best_pio_mode
+c023a8a9 T ide_set_xfer_rate
+c023a8c5 t ide_dump_opcode
+c023a95f T ide_dump_status
+c023ae5e T ide_toggle_bounce
+c023aea3 T ide_rate_filter
+c023af10 t ata_lock
+c023af13 t exact_match
+c023af1a t save_match
+c023af7d T ide_undecoded_slave
+c023b001 t try_to_identify
+c023b44d t do_probe
+c023b64e t probe_hwif
+c023bd09 t hwif_release_dev
+c023bd13 t init_irq
+c023c141 t hwif_init
+c023c42c T ideprobe_init
+c023c54b T probe_hwif_init_with_fixup
+c023c5c9 T probe_hwif_init
+c023c5d0 T ide_register_region
+c023c600 t ata_probe
+c023c680 t drive_release_dev
+c023c729 T ide_init_disk
+c023c77f T ide_unregister_region
+c023c791 t exact_lock
+c023c7a0 t ata_bswap_data
+c023c7d6 T flagged_taskfile
+c023c9db T do_rw_taskfile
+c023cb7f T ide_task_ioctl
+c023cbea t ide_diag_taskfile
+c023cc91 T ide_raw_taskfile
+c023cca0 T ide_wait_cmd
+c023cd40 T ide_cmd_ioctl
+c023cf16 t task_error
+c023cf94 T recal_intr
+c023cfc3 T task_no_data_intr
+c023d026 t task_end_request
+c023d081 t ide_pio_sector
+c023d1a3 t ide_pio_datablock
+c023d1ff t task_out_intr
+c023d29b T task_in_intr
+c023d36b T pre_task_out_intr
+c023d410 T set_geometry_intr
+c023d49b T set_multmode_intr
+c023d4dd T taskfile_lib_get_identify
+c023d543 T ide_taskfile_ioctl
+c023d864 t get_cmd640_reg_vlb
+c023d880 t display_clocks
+c023d8dd t program_drive_counts
+c023d9d1 t set_prefetch_mode
+c023da64 t put_cmd640_reg
+c023da9a t get_cmd640_reg
+c023dac7 t cmd640_tune_drive
+c023dce4 t put_cmd640_reg_pci2
+c023dd0e t put_cmd640_reg_vlb
+c023dd2c t get_cmd640_reg_pci1
+c023dd5a t get_cmd640_reg_pci2
+c023dd86 t put_cmd640_reg_pci1
+c023ddb4 t ide_pci_check_iomem
+c023de1c T ide_setup_pci_noise
+c023de3e T __ide_pci_register_driver
+c023de65 T ide_pci_setup_ports
+c023e3eb t do_ide_setup_pci_device
+c023e7bc T ide_setup_pci_devices
+c023e846 T ide_setup_pci_device
+c023e8cc T ide_dma_host_off
+c023e909 T ide_dma_host_on
+c023e94e T ide_dma_start
+c023e97b T ide_set_dma
+c023e9b9 T __ide_dma_timeout
+c023e9f3 T __ide_dma_lostirq
+c023ea0e t __ide_dma_test_irq
+c023ea55 T ide_dma_off
+c023ea7a t dma_timer_expiry
+c023eae0 T ide_destroy_dmatable
+c023eaf1 T __ide_dma_end
+c023eb6a t ide_dma_exec_cmd
+c023eb8c T ide_release_dma
+c023ec26 T ide_setup_dma
+c023efab T ide_dma_verbose
+c023f0d0 T ide_max_dma_mode
+c023f1c5 T ide_dma_off_quietly
+c023f1e0 T ide_build_sglist
+c023f2aa T ide_build_dmatable
+c023f3e9 T ide_dma_setup
+c023f476 T ide_dma_intr
+c023f50f T ide_in_drive_list
+c023f572 T __ide_dma_good_drive
+c023f57f T __ide_dma_check
+c023f5dd T __ide_dma_bad_drive
+c023f61a T ide_tune_dma
+c023f65e T __ide_dma_on
+c023f68c t sectors_to_MB
+c023f6c8 t idedisk_prepare_flush
+c023f731 t set_lba_addressing
+c023f783 t idedisk_getgeo
+c023f7a1 t idedisk_media_changed
+c023f7bf t ide_cacheflush_p
+c023f848 t ide_device_shutdown
+c023f88a t idedisk_check_hpa
+c023fd1d t init_idedisk_capacity
+c023fe70 t ide_disk_resume
+c023fe8b t ide_disk_put
+c023feb2 t idedisk_release
+c023ff2e t ide_disk_remove
+c023ff4d t ide_disk_release
+c023ff74 t write_cache
+c02400ac t idedisk_issue_flush
+c024012d t set_nowerr
+c024016b t set_multcount
+c02401d6 t ide_disk_probe
+c0240564 t ide_do_rw_disk
+c02409f3 t set_acoustic
+c0240a5c t idedisk_open
+c0240b09 t idedisk_ioctl
+c0240c9d t idedisk_revalidate_disk
+c0240cc8 t msf_from_bcd
+c0240d05 t cdrom_get_toc_entry
+c0240d60 t ide_cdrom_open_real
+c0240d63 t ide_cdrom_release_real
+c0240d77 t ide_cdrom_prep_fn
+c0240e9b t ide_cd_put
+c0240ec2 t cdrom_timer_expiry
+c0240f13 t ide_cd_release
+c0240f9d t idecd_media_changed
+c0240faa t ide_cdrom_get_capabilities
+c024103d t idecd_ioctl
+c0241196 t idecd_release
+c02411bc t ide_cdrom_update_speed
+c024126e t idecd_open
+c02412fa t cdrom_prepare_request
+c0241318 t cdrom_queue_request_sense
+c0241373 t cdrom_queue_packet_command
+c024142c t ide_cdrom_select_speed
+c02414e0 t ide_cdrom_get_mcn
+c0241575 t cdrom_read_tocentry
+c0241613 t cdrom_lockdoor
+c02416e0 t ide_cdrom_lock_door
+c02416ea t ide_cdrom_tray_move
+c02417a3 t ide_cdrom_reset
+c02417fe t cdrom_check_status
+c024185d t ide_cdrom_check_media_change_real
+c0241891 t ide_cdrom_drive_status
+c0241925 t cdrom_read_toc
+c0241da3 t ide_cd_probe
+c02427c6 t idecd_revalidate_disk
+c02427dc t ide_cdrom_get_last_session
+c0242818 t ide_cdrom_audio_ioctl
+c02429f0 t cdrom_start_packet_command
+c0242b3a t ide_dump_status_no_sense
+c0242b47 t cdrom_analyze_sense_data
+c0242f35 t cdrom_end_request
+c0243040 t cdrom_write_check_ireason
+c02430b5 t ide_do_rw_cdrom
+c02435d0 t cdrom_read_check_ireason
+c0243658 t cdrom_decode_status
+c0243913 t cdrom_write_intr
+c0243ada t cdrom_newpc_intr
+c0243db8 t cdrom_pc_intr
+c0243fa7 t cdrom_seek_intr
+c0243ffb t cdrom_read_intr
+c024430d t cdrom_transfer_packet_command
+c02443eb t cdrom_do_newpc_cont
+c0244417 t cdrom_start_write_cont
+c0244434 t cdrom_do_pc_continuation
+c0244460 t ide_cdrom_packet
+c02444ff t cdrom_start_seek_continuation
+c024459f t cdrom_start_read_continuation
+c0244678 t ide_cd_remove
+c024468c t idefloppy_discard_data
+c02446a9 t idefloppy_next_pc_storage
+c02446d9 t idefloppy_init_pc
+c0244719 t idefloppy_create_request_sense_cmd
+c0244738 t idefloppy_transfer_pc2
+c0244754 t idefloppy_create_prevent_cmd
+c024476a t idefloppy_create_read_capacity_cmd
+c0244786 t idefloppy_create_start_stop_cmd
+c024479c t idefloppy_getgeo
+c02447ba t idefloppy_media_changed
+c02447e3 t idefloppy_revalidate_disk
+c0244806 t ide_floppy_put
+c024482d t ide_floppy_remove
+c024483e t ide_floppy_release
+c0244865 t idefloppy_queue_pc_tail
+c02448a6 t idefloppy_create_mode_sense_cmd
+c024490d t idefloppy_get_capacity
+c0244d13 t ide_floppy_probe
+c0244f4c t idefloppy_do_end_request
+c0244fa5 t idefloppy_rw_callback
+c0244fae t idefloppy_pc_callback
+c0244fc2 t idefloppy_request_sense_callback
+c024502b t idefloppy_do_request
+c0245472 t idefloppy_transfer_pc1
+c024550c t idefloppy_transfer_pc
+c02455b9 t idefloppy_ioctl
+c02459a2 t idefloppy_pc_intr
+c0245f56 t idefloppy_open
+c0246086 t idefloppy_release
+c02460e4 t cdrom_dummy_generic_packet
+c0246110 t media_changed
+c024617d T cdrom_media_changed
+c02461a9 t sanitize_format
+c02461fe t setup_report_key
+c0246250 t setup_send_key
+c0246292 T cdrom_mode_sense
+c02462f0 T cdrom_mode_select
+c024633b t cdrom_read_block
+c02463f5 t cdrom_switch_blocksize
+c0246484 t cdrom_sysctl_register
+c02464d9 t cdrom_sysctl_handler
+c024663b t cdrom_sysctl_info
+c0246d2c t cdrom_count_tracks
+c0246e93 t check_for_audio_disc
+c0247004 T init_cdrom_command
+c0247058 t cdrom_get_disc_info
+c02470db t cdrom_get_track_info
+c0247183 T cdrom_get_last_written
+c0247289 t cdrom_load_unload
+c0247329 t cdrom_read_mech_status
+c02473b4 T cdrom_release
+c0247590 t cdrom_get_random_writable
+c02475e8 t cdrom_mrw_exit
+c0247694 T cdrom_get_media_event
+c0247717 t dvd_read_struct
+c0247b68 T cdrom_number_of_slots
+c0247bca t cdrom_read_cdda_old
+c0247cce t cdrom_read_cdda
+c0247f3a t mmc_ioctl
+c0248eed T cdrom_ioctl
+c0249a2f T cdrom_open
+c024a34b T unregister_cdrom
+c024a3eb T register_cdrom
+c024a5a4 T usb_ifnum_to_if
+c024a5d6 T usb_altnum_to_altsetting
+c024a611 t __find_interface
+c024a638 T usb_disabled
+c024a63e T __usb_get_extra_descriptor
+c024a695 t ksuspend_usb_cleanup
+c024a69f T usb_buffer_unmap_sg
+c024a6a0 T usb_buffer_map_sg
+c024a74d T usb_buffer_free
+c024a765 T usb_buffer_alloc
+c024a77b T usb_get_current_frame_number
+c024a780 T usb_lock_device_for_reset
+c024a816 T usb_put_intf
+c024a823 T usb_put_dev
+c024a830 T usb_get_intf
+c024a843 T usb_get_dev
+c024a856 t match_device
+c024a8fe T usb_find_device
+c024a99a T usb_find_interface
+c024a9c6 T usb_alloc_dev
+c024ab80 t usb_release_dev
+c024abc0 t recursively_mark_NOTATTACHED
+c024abf8 T usb_port_suspend
+c024abfb T usb_port_resume
+c024abfe t locktree
+c024acaa t set_port_feature
+c024acf7 t set_port_led
+c024ad0c t clear_port_feature
+c024ad59 t clear_hub_feature
+c024ada5 t ep0_reinit
+c024adcc t hub_power_on
+c024ae10 t hub_port_status
+c024aefa t hub_hub_status
+c024afd9 T usb_root_hub_lost_power
+c024b061 T usb_set_device_state
+c024b0ea t hub_port_reset
+c024b2fd t hub_port_disable
+c024b36b t hub_port_init
+c024b8ae t kick_khubd
+c024b90f T usb_reset_device
+c024bc3d T usb_reset_composite_device
+c024bd72 T usb_hub_cleanup
+c024bd86 t hub_activate
+c024be07 t led_work
+c024bf1d t hub_quiesce
+c024bf70 t hub_ioctl
+c024bfde T usb_new_device
+c024c0bb T usb_disconnect
+c024c1b0 t hub_pre_reset
+c024c203 t hub_disconnect
+c024c2b7 T usb_hub_tt_clear_buffer
+c024c383 t hub_tt_kevent
+c024c498 t hub_thread
+c024ce9e t hub_irq
+c024cf69 t hub_probe
+c024d589 t hub_resume
+c024d5c2 t hub_post_reset
+c024d5d8 t hub_suspend
+c024d642 T usb_kick_khubd
+c024d656 T usb_hub_init
+c024d6e4 T usb_enable_root_hub_irq
+c024d701 T usb_calc_bus_time
+c024d82c T usb_hcd_platform_shutdown
+c024d844 t usb_deregister_bus
+c024d8b0 T usb_remove_hcd
+c024d983 T usb_put_hcd
+c024d995 t hcd_release
+c024d99d T usb_get_hcd
+c024d9b0 t hcd_resume_work
+c024d9f4 T usb_hc_died
+c024da5d t urb_unlink
+c024da8d T usb_hcd_giveback_urb
+c024dacd T usb_hcd_resume_root_hub
+c024db04 t unlink1
+c024db84 T usb_hcd_poll_rh_status
+c024dcd3 t rh_timer_func
+c024dcd8 T usb_host_cleanup
+c024dce2 T usb_host_init
+c024dd01 T usb_hcd_irq
+c024dd4f T usb_hcd_endpoint_disable
+c024de4c T hcd_bus_suspend
+c024de7f T hcd_bus_resume
+c024deca T usb_create_hcd
+c024dfa9 T usb_add_hcd
+c024e508 T usb_hcd_get_frame_number
+c024e527 T usb_hcd_unlink_urb
+c024e683 T usb_hcd_submit_urb
+c024ed9c T usb_unlink_urb
+c024edc4 T usb_kill_urb
+c024ee88 T usb_submit_urb
+c024f03f T usb_get_urb
+c024f04f T usb_free_urb
+c024f05e t urb_destroy
+c024f063 T usb_init_urb
+c024f094 T usb_alloc_urb
+c024f0cc t usb_enable_interface
+c024f14f t usb_if_uevent
+c024f390 T usb_driver_set_configuration
+c024f3e2 T usb_release_interface
+c024f3fe T usb_disable_endpoint
+c024f441 T usb_disable_device
+c024f4fc T usb_disable_interface
+c024f52b T usb_sg_cancel
+c024f5d6 t sg_complete
+c024f787 t usb_api_blocking_completion
+c024f78f t sg_clean
+c024f7eb t usb_start_wait_urb
+c024f872 T usb_bulk_msg
+c024f9a4 T usb_interrupt_msg
+c024f9ab T usb_control_msg
+c024fa8c T usb_clear_halt
+c024fb11 t usb_get_string
+c024fb89 t usb_string_sub
+c024fc66 T usb_string
+c024fdc5 T usb_cache_string
+c024fe55 T usb_set_configuration
+c025024f t driver_set_config_work
+c02502af T usb_get_descriptor
+c025035e T usb_reset_configuration
+c025045a T usb_sg_wait
+c0250563 T usb_set_interface
+c02506c7 T usb_sg_init
+c02508f6 T usb_get_device_descriptor
+c0250972 T usb_get_status
+c02509fc t usb_unbind_device
+c0250a0b T usb_match_device
+c0250a96 T usb_match_one_id
+c0250b07 T usb_match_id
+c0250b43 t usb_resume_device
+c0250b79 T usb_autosuspend_work
+c0250b7a t usb_match_dynamic_id
+c0250bcf t usb_resume_interface
+c0250c93 T usb_external_resume_device
+c0250d6a t usb_resume
+c0250d8f T usb_external_suspend_device
+c0250f74 T usb_deregister_device_driver
+c0250fa8 T usb_deregister
+c025102d T usb_register_device_driver
+c02510c7 T usb_register_driver
+c02511a6 T usb_driver_release_interface
+c025121c T usb_store_new_id
+c02512db t store_new_id
+c02512f3 t usb_probe_device
+c025132a t usb_uevent
+c0251510 t usb_suspend
+c0251527 t usb_device_match
+c0251578 t usb_probe_interface
+c02515f6 t usb_unbind_interface
+c0251655 T usb_driver_claim_interface
+c02516d0 t find_next_descriptor
+c025170e T usb_release_interface_cache
+c025173d T usb_destroy_configuration
+c02517f9 T usb_get_configuration
+c0252608 T usb_deregister_dev
+c02526a1 t release_usb_class
+c02526c3 T usb_register_dev
+c0252898 T usb_major_cleanup
+c02528a7 T usb_major_init
+c02528e8 t usb_open
+c02529b4 T hcd_buffer_free
+c0252a12 T hcd_buffer_destroy
+c0252a3c T hcd_buffer_create
+c0252abc T hcd_buffer_alloc
+c0252b1c t show_modalias
+c0252b9e t show_bInterfaceProtocol
+c0252bc0 t show_bInterfaceSubClass
+c0252be2 t show_bInterfaceClass
+c0252c04 t show_bNumEndpoints
+c0252c26 t show_bAlternateSetting
+c0252c48 t show_bInterfaceNumber
+c0252c6a t show_bMaxPacketSize0
+c0252c8c t show_bNumConfigurations
+c0252cae t show_bDeviceProtocol
+c0252cd0 t show_bDeviceSubClass
+c0252cf2 t show_bDeviceClass
+c0252d14 t show_bcdDevice
+c0252d36 t show_idProduct
+c0252d58 t show_idVendor
+c0252d7a t show_quirks
+c0252d9b t show_maxchild
+c0252dbc t show_version
+c0252de8 t show_devnum
+c0252e06 t show_busnum
+c0252e27 t show_speed
+c0252e6d t show_serial
+c0252e8e t show_manufacturer
+c0252eaf t show_product
+c0252ed0 t show_bConfigurationValue
+c0252efb t show_configuration_string
+c0252f2b t show_bMaxPower
+c0252f58 t show_bmAttributes
+c0252f83 t show_bNumInterfaces
+c0252fae t show_interface_string
+c0252fef T usb_remove_sysfs_intf_files
+c0253035 T usb_remove_sysfs_dev_files
+c025307c T usb_create_sysfs_intf_files
+c0253103 T usb_create_sysfs_dev_files
+c0253191 t set_bConfigurationValue
+c0253224 t show_ep_direction
+c025325e t show_ep_interval
+c0253330 t show_ep_type
+c0253383 t show_ep_wMaxPacketSize
+c02533aa t show_ep_bInterval
+c02533cc t show_ep_bmAttributes
+c02533ee t show_ep_bEndpointAddress
+c0253410 t show_ep_bLength
+c0253431 t destroy_endpoint_class
+c0253445 T usb_remove_ep_files
+c02534ad t release_endpoint_class
+c02534e0 t endpoint_free_minor
+c02534f0 T usb_create_ep_files
+c02537a7 t ep_device_release
+c02537bc t driver_probe
+c02537c2 t findintfep
+c0253870 t __match_minor
+c0253885 t usbdev_poll
+c02538cc t releaseintf
+c025390b t free_async
+c025393c t destroy_async
+c02539ce t destroy_async_on_interface
+c0253a45 t snoop_urb
+c0253b82 t driver_disconnect
+c0253be0 t processcompl
+c0253ca0 t claimintf
+c0253cef t checkintf
+c0253d79 t check_ctrlrecip
+c0253dce t proc_submiturb
+c025450f t async_completed
+c02545ec t proc_reapurb
+c0254712 t proc_ioctl_default
+c02548e6 t usbdev_lseek
+c0254942 T usb_devio_cleanup
+c025496f t usb_classdev_notify
+c02549ef t usbdev_open
+c0254b32 t usbdev_ioctl
+c0255d59 t usbdev_read
+c0255f7f t usbdev_release
+c0256030 T usb_notify_remove_bus
+c0256041 T usb_notify_add_bus
+c0256052 T usb_notify_add_device
+c0256063 T usb_notify_remove_device
+c025608c T usb_unregister_notify
+c0256098 T usb_register_notify
+c02560a4 t generic_resume
+c02560a9 t generic_suspend
+c02560ae t generic_disconnect
+c02560d1 t generic_probe
+c02562b0 T usb_detect_quirks
+c02562f4 T usb_hcd_pci_shutdown
+c0256310 T usb_hcd_pci_resume
+c02563ea T usb_hcd_pci_remove
+c0256489 T usb_hcd_pci_suspend
+c02565d0 T usb_hcd_pci_probe
+c02568fc t default_read_file
+c02568ff t default_write_file
+c0256902 t default_open
+c0256915 T usbfs_cleanup
+c0256943 t usb_get_sb
+c0256954 t default_file_lseek
+c02569b4 t remount
+c0256d21 T usbfs_update_special
+c0256d51 t usbfs_get_inode
+c0256e04 t usbfs_fill_super
+c0256e63 t usbfs_mknod
+c0256ea1 t fs_create_file
+c0256ffe t fs_remove_file
+c025712c t usbfs_notify
+c025745c t class_decode
+c0257479 t usb_device_open
+c0257486 t usb_device_release
+c02574a2 t usb_device_lseek
+c02574fe t usb_device_poll
+c0257594 t usb_device_dump
+c0257f02 t usb_device_read
+c025803c T usbfs_conn_disc_event
+c0258064 t mmio_resource_enabled
+c02580a8 T uhci_reset_hc
+c025811c T uhci_check_and_reset_hc
+c0258177 t quirk_usb_early_handoff
+c025852c T usb_usual_check_type
+c025855f t usu_disconnect
+c0258560 t usu_get_bias
+c025858d T usb_usual_clear_present
+c02585bb T usb_usual_set_present
+c02585e9 t usu_set_bias
+c0258675 t usu_probe_thread
+c025871f t usu_probe
+c02587e4 t serio_match_port
+c0258830 t serio_bus_match
+c025884f t serio_driver_show_bind_mode
+c025887b t serio_driver_show_description
+c02588a3 t serio_show_bind_mode
+c02588cf t serio_show_id_extra
+c02588ee t serio_show_id_id
+c025890d t serio_show_id_proto
+c025892c t serio_show_id_type
+c025894b t serio_show_modalias
+c0258987 t serio_show_description
+c02589a7 t serio_cleanup
+c02589d3 t serio_suspend
+c02589fc t serio_shutdown
+c0258a03 t serio_disconnect_driver
+c0258a29 t serio_driver_remove
+c0258a36 t serio_reconnect_driver
+c0258a6c t serio_connect_driver
+c0258a96 t serio_driver_probe
+c0258aa6 t serio_find_driver
+c0258ade t serio_set_drv
+c0258afc T serio_close
+c0258b0f T serio_open
+c0258b38 t serio_release_port
+c0258b49 t serio_free_event
+c0258b5c t serio_remove_pending_events
+c0258bb2 t serio_destroy_port
+c0258cac t serio_disconnect_port
+c0258ced T serio_unregister_child_port
+c0258d19 T serio_unregister_port
+c0258d3f t serio_reconnect_port
+c0258d65 t serio_uevent
+c0258f12 T serio_unregister_driver
+c0258f76 t serio_queue_event
+c0259072 T __serio_register_driver
+c02590f1 T serio_reconnect
+c02590fd T serio_rescan
+c0259106 T serio_interrupt
+c025916b t serio_resume
+c025919f T __serio_register_port
+c0259262 t serio_rebind_driver
+c0259406 t serio_set_bind_mode
+c0259479 t serio_driver_set_bind_mode
+c02594e5 t serio_thread
+c025979c t i8042_start
+c02597ab t i8042_flush
+c0259842 t i8042_controller_check
+c0259866 t i8042_wait_write
+c0259898 t __i8042_command
+c0259a69 t i8042_command
+c0259a99 t i8042_controller_selftest
+c0259afa t i8042_toggle_aux
+c0259b5f t i8042_set_mux_mode
+c0259c07 t i8042_controller_reset
+c0259c55 t i8042_shutdown
+c0259c57 t i8042_suspend
+c0259c7a t i8042_enable_aux_port
+c0259cb5 t i8042_enable_mux_ports
+c0259cea t i8042_enable_kbd_port
+c0259d25 t i8042_aux_write
+c0259d4b t i8042_interrupt
+c0259f58 t i8042_resume
+c025a03f t i8042_free_irqs
+c025a080 t i8042_remove
+c025a0b2 t i8042_create_aux_port
+c025a197 t i8042_stop
+c025a1ab t i8042_free_aux_ports
+c025a1cd t i8042_probe
+c025a6d0 t i8042_pnp_exit
+c025a70b t i8042_pnp_aux_probe
+c025a844 t i8042_pnp_kbd_probe
+c025a97d t i8042_aux_test_irq
+c025a9cf t i8042_kbd_write
+c025aa38 t i8042_panic_blink
+c025ab68 T ps2_is_keyboard_id
+c025ab89 T ps2_cmd_aborted
+c025abc2 T ps2_handle_response
+c025ac32 T ps2_handle_ack
+c025acd6 T ps2_init
+c025acfb T ps2_schedule_command
+c025ada3 T ps2_sendbyte
+c025ae6a T ps2_command
+c025b18b t ps2_execute_scheduled_command
+c025b1a4 T ps2_drain
+c025b28c T input_grab_device
+c025b2a8 T input_release_device
+c025b2f2 T input_flush_device
+c025b30e t input_fetch_keycode
+c025b340 t input_default_getkeycode
+c025b36a t input_match_device
+c025b485 t input_proc_devices_poll
+c025b4ae t list_get_nth_element
+c025b4dc t list_get_next_element
+c025b4f0 t input_devices_seq_start
+c025b4f7 t input_devices_seq_next
+c025b4fe t input_devices_seq_stop
+c025b4ff t input_handlers_seq_start
+c025b50b t input_handlers_seq_next
+c025b51a t input_handlers_seq_stop
+c025b51b t input_attach_handler
+c025b58a t input_proc_exit
+c025b5ba t input_proc_handlers_open
+c025b5c6 t input_proc_devices_open
+c025b5d2 t input_handlers_seq_show
+c025b62b t input_seq_print_bitmap
+c025b6bf t input_dev_release
+c025b6de t input_print_bitmap
+c025b796 t input_add_uevent_bm_var
+c025b834 t input_dev_show_cap_sw
+c025b86f t input_dev_show_cap_ff
+c025b8aa t input_dev_show_cap_snd
+c025b8e5 t input_dev_show_cap_led
+c025b920 t input_dev_show_cap_msc
+c025b95b t input_dev_show_cap_abs
+c025b996 t input_dev_show_cap_rel
+c025b9d1 t input_dev_show_cap_key
+c025ba0c t input_dev_show_cap_ev
+c025ba47 t input_print_modalias_bits
+c025bad6 t input_print_modalias
+c025bcd7 t input_dev_show_modalias
+c025bd09 T input_free_device
+c025bd18 t input_dev_show_id_version
+c025bd42 t input_dev_show_id_product
+c025bd6c t input_dev_show_id_vendor
+c025bd96 t input_dev_show_id_bustype
+c025bdc0 t input_dev_show_uniq
+c025bdf3 t input_dev_show_phys
+c025be26 t input_dev_show_name
+c025be59 T input_close_device
+c025be9f T input_open_device
+c025bef3 T input_event
+c025c322 T input_inject_event
+c025c352 t input_default_setkeycode
+c025c412 T input_set_capability
+c025c480 t input_dev_uevent
+c025c92c t input_devices_seq_show
+c025cb6d T input_allocate_device
+c025cbd9 T input_unregister_handler
+c025cc82 T input_unregister_handle
+c025ccad t input_open_file
+c025cd69 T input_register_handle
+c025cda2 T input_register_device
+c025cf1a T input_unregister_device
+c025d016 T input_register_handler
+c025d0b1 t input_repeat_key
+c025d11c t check_effect_access
+c025d145 t erase_effect
+c025d18d T input_ff_destroy
+c025d1ce t flush_effects
+c025d20f T input_ff_erase
+c025d259 T input_ff_event
+c025d2ea T input_ff_create
+c025d3c9 T input_ff_upload
+c025d574 t mousedev_poll
+c025d5ae t mousedev_fasync
+c025d5cc t mousedev_free
+c025d5df t mousedev_release
+c025d67d t mousedev_packet
+c025d7e8 t mousedev_write
+c025d9a1 t mousedev_notify_readers
+c025db49 t mousedev_disconnect
+c025dc05 t mousedev_event
+c025e020 t mousedev_read
+c025e162 t mousedev_open
+c025e282 t mousedev_connect
+c025e428 t evdev_poll
+c025e46c t evdev_fasync
+c025e490 t evdev_free
+c025e4a3 t evdev_release
+c025e50d t evdev_flush
+c025e52e t str_to_user
+c025e56d t bits_to_user
+c025e598 t evdev_ioctl
+c025eaa0 t evdev_disconnect
+c025eb51 t evdev_connect
+c025eca3 t evdev_event
+c025edd2 t evdev_write
+c025ee46 t evdev_read
+c025ef84 t evdev_open
+c025f028 t atkbd_compat_scancode
+c025f061 t atkbd_set_keycode_table
+c025f164 t atkbd_select_set
+c025f26a t atkbd_set_leds
+c025f344 t atkbd_set_repeat_rate
+c025f3ca t atkbd_attr_show_helper
+c025f416 t atkbd_do_show_err_count
+c025f41f t atkbd_do_show_softraw
+c025f428 t atkbd_do_show_softrepeat
+c025f431 t atkbd_do_show_set
+c025f43a t atkbd_do_show_scroll
+c025f443 t atkbd_do_show_extra
+c025f44f t atkbd_show_err_count
+c025f470 t atkbd_show_softraw
+c025f498 t atkbd_show_softrepeat
+c025f4c0 t atkbd_show_set
+c025f4e2 t atkbd_show_scroll
+c025f50a t atkbd_show_extra
+c025f532 t atkbd_attr_set_helper
+c025f5ba t atkbd_do_set_softraw
+c025f5cd t atkbd_do_set_softrepeat
+c025f5e0 t atkbd_do_set_set
+c025f5f3 t atkbd_do_set_scroll
+c025f606 t atkbd_do_set_extra
+c025f619 t atkbd_set_device_attrs
+c025f7c6 t atkbd_set_softraw
+c025f878 t atkbd_set_softrepeat
+c025f962 t atkbd_set_scroll
+c025fa25 t atkbd_schedule_event_work
+c025fa72 t atkbd_event
+c025faa9 t atkbd_activate
+c025fb14 t atkbd_set_set
+c025fc21 t atkbd_set_extra
+c025fd23 t atkbd_probe
+c025fdf2 t atkbd_reconnect
+c025fea6 t atkbd_event_work
+c025feeb t atkbd_cleanup
+c025fefd t atkbd_disconnect
+c025ff5e t atkbd_connect
+c0260121 t atkbd_interrupt
+c0260638 T touchkit_ps2_detect
+c026063e t ps2bare_detect
+c026065f t psmouse_protocol_by_name
+c0260703 t psmouse_set_maxproto
+c0260741 t psmouse_poll
+c0260756 t psmouse_initialize
+c026078e t psmouse_set_rate
+c02607cd T psmouse_set_resolution
+c026081d t psmouse_probe
+c0260888 t thinking_detect
+c0260929 t intellimouse_detect
+c02609ce t im_explorer_detect
+c0260ad4 t genius_detect
+c0260b85 T psmouse_reset
+c0260bb4 T psmouse_sliced_command
+c0260c0c t psmouse_set_state
+c0260c4a t psmouse_deactivate
+c0260c85 t psmouse_activate
+c0260cc3 t psmouse_attr_set_resolution
+c0260cf7 t psmouse_attr_set_rate
+c0260d2b t psmouse_set_int_attr
+c0260d5e t psmouse_show_int_attr
+c0260d7c t psmouse_protocol_by_type
+c0260dd7 t psmouse_get_maxproto
+c0260e03 t psmouse_attr_show_protocol
+c0260e2e t psmouse_extensions
+c0260fc4 t psmouse_switch_protocol
+c026111a t psmouse_attr_set_protocol
+c026131a t psmouse_handle_byte
+c02613ed t psmouse_resync
+c026155f t psmouse_cleanup
+c02615e1 t psmouse_reconnect
+c02616c4 t psmouse_disconnect
+c02617bb t psmouse_connect
+c02619a6 t psmouse_interrupt
+c0261baf T psmouse_attr_set_helper
+c0261c78 t psmouse_process_byte
+c0261eab T psmouse_attr_show_helper
+c0261efc t synaptics_validate_byte
+c0261f66 t synaptics_send_cmd
+c0261f97 t synaptics_query_hardware
+c02620f6 T synaptics_detect
+c0262174 t synaptics_mode_cmd
+c02621ac t synaptics_pt_activate
+c02621f0 t synaptics_set_rate
+c026221e t synaptics_set_absolute_mode
+c0262252 t synaptics_reconnect
+c02622e7 T synaptics_reset
+c02622ee t synaptics_disconnect
+c0262305 T synaptics_init
+c02625ff t synaptics_process_byte
+c0262d4f t synaptics_pt_write
+c0262d90 t alps_get_model
+c0262f1e T alps_detect
+c0262f64 t alps_passthrough_mode
+c0262fce t alps_hw_init
+c026318d t alps_reconnect
+c02631a7 t alps_poll
+c0263246 t alps_disconnect
+c026325d t alps_process_packet
+c0263713 t alps_process_byte
+c026376b T alps_init
+c0263950 t ps2pp_attr_show_smartscroll
+c0263978 t ps2pp_cmd
+c02639a9 t ps2pp_set_smartscroll
+c0263a0f T ps2pp_init
+c0263d41 t ps2pp_attr_set_smartscroll
+c0263d83 t ps2pp_disconnect
+c0263d95 t ps2pp_set_resolution
+c0263dfb t ps2pp_process_byte
+c0264044 t lifebook_set_serio_phys
+c026404f t lifebook_set_6byte_proto
+c0264059 t lifebook_set_resolution
+c02640ab t lifebook_disconnect
+c02640c2 t lifebook_absolute_mode
+c02640fb T lifebook_detect
+c0264153 T lifebook_init
+c026430a t lifebook_process_byte
+c02645c0 t trackpoint_start_protocol
+c02645fd t trackpoint_toggle_bit
+c0264665 t trackpoint_set_bit_attr
+c02646cd t trackpoint_write
+c026472b t trackpoint_set_int_attr
+c026477e t trackpoint_read
+c02647b5 t trackpoint_sync
+c026496e t trackpoint_reconnect
+c0264990 t trackpoint_show_int_attr
+c02649c4 T trackpoint_detect
+c0264ae9 t trackpoint_disconnect
+c0264b10 t linear_mergeable_bvec
+c0264c1b t linear_congested
+c0264c66 t linear_exit
+c0264c70 t linear_conf
+c0264fdc t linear_add
+c0265040 t linear_status
+c0265071 t linear_stop
+c026509c t linear_run
+c0265113 t linear_make_request
+c026533e t linear_unplug
+c0265372 t linear_issue_flush
+c02653c8 t calc_dev_size
+c02653f7 t md_csum_fold
+c0265408 t calc_sb_csum
+c0265448 t calc_sb_1_csum
+c02654ac t cmd_match
+c02654de t rdev_attr_show
+c02654fa t level_store
+c0265559 t null_show
+c026555f t update_raid_disks
+c02655ab t md_getgeo
+c02655d1 t md_media_changed
+c02655db t md_revalidate
+c02655eb t mdstat_poll
+c0265623 T md_autodetect_dev
+c026563d t get_ro
+c026565e t reshape_position_show
+c02656ab t suspend_hi_show
+c02656d8 t suspend_lo_show
+c0265705 t sync_speed_show
+c0265768 t mismatch_cnt_show
+c0265795 t metadata_show
+c02657d4 t size_show
+c0265801 t resync_start_show
+c026582e t chunk_size_show
+c026588f t raid_disks_show
+c02658f8 t layout_show
+c0265959 t level_show
+c02659ab t safe_delay_show
+c02659ec t rdev_size_show
+c0265a13 t offset_show
+c0265a3a t slot_show
+c0265a71 t errors_show
+c0265a92 t set_ro
+c0265aca t sync_max_store
+c0265b47 t chunk_size_store
+c0265bb0 t raid_disks_store
+c0265c2d t layout_store
+c0265c96 t errors_store
+c0265cda t print_desc
+c0265d0f T unregister_md_personality
+c0265d55 t restore_bitmap_write_access
+c0265d7c t bitmap_store
+c0265e1b t reshape_position_store
+c0265e9c t suspend_hi_store
+c0265f45 t suspend_lo_store
+c0265fca t resync_start_store
+c0266029 t rdev_size_store
+c02660a3 t offset_store
+c02660fe T md_wakeup_thread
+c0266126 t restart_array
+c02661ac t md_safemode_timeout
+c02661c1 t md_free
+c02661c9 t rdev_free
+c02661d1 t super_show
+c0266217 t delayed_delete
+c026621f t free_disk_sb
+c026625a t md_fail_request
+c026626c t mddev_put
+c02662ca t md_seq_stop
+c02662dd t md_print_devices
+c0266634 T md_error
+c02666c7 t unlock_rdev
+c026670c t export_rdev
+c0266789 t unbind_rdev_from_array
+c0266836 t kick_rdev_from_array
+c0266846 t export_array
+c02668cd t md_seq_open
+c026691d t safe_delay_store
+c0266a02 t md_release
+c0266a1e t rdev_attr_store
+c0266a59 t md_import_device
+c0266cb4 t bind_rdev_to_array
+c0266eac t update_size
+c0266fd7 t mddev_find
+c0267156 t md_probe
+c0267291 t is_mddev_idle
+c026735f T md_write_end
+c02673a1 T register_md_personality
+c02673ee T md_unregister_thread
+c0267401 T md_register_thread
+c0267494 T md_super_wait
+c0267539 T sync_page_io
+c02675cc t read_disk_sb
+c0267660 t super_1_load
+c0267984 t super_90_load
+c0267ccb t bi_complete
+c0267ce3 T md_super_write
+c0267d9b t md_update_sb
+c02680e4 T md_allow_write
+c0268158 t size_store
+c02681f7 t super_written
+c02682ac T md_new_event
+c02682e7 t do_md_stop
+c02685c8 t do_md_run
+c0268d68 t autostart_arrays
+c02690a2 T md_done_sync
+c02690ed t state_store
+c026919c t array_state_store
+c026931b t super_written_barrier
+c02693d7 t state_show
+c02694a1 t action_show
+c0269514 t action_store
+c0269647 t sync_completed_show
+c026968e t slot_store
+c0269731 t sync_min_store
+c02697ae t super_90_validate
+c0269ac4 t super_1_validate
+c0269d51 t super_90_sync
+c026a0bd t super_1_sync
+c026a306 t array_state_show
+c026a392 t metadata_store
+c026a456 T md_write_start
+c026a53b t sync_min_show
+c026a573 t sync_max_show
+c026a5ab t md_seq_start
+c026a644 t md_seq_next
+c026a6b7 T md_do_sync
+c026b0bd t md_notify_reboot
+c026b176 t md_open
+c026b1c6 t md_seq_show
+c026b9d1 T md_check_recovery
+c026be4c t md_attr_show
+c026be9d t md_attr_store
+c026bf04 t md_ioctl
+c026d193 t md_thread
+c026d262 t new_dev_store
+c026d37c t bitmap_file_set_bit
+c026d403 T bitmap_print_sb
+c026d556 t free_buffers
+c026d594 t read_page
+c026d78c t bitmap_mask_state
+c026d7ee t end_bitmap_write
+c026d839 t read_sb_page
+c026d959 t write_page
+c026db73 T bitmap_update_sb
+c026dc0f t bitmap_free_page
+c026dc16 t bitmap_count_page
+c026dc8f t bitmap_get_counter
+c026de71 t bitmap_set_memory_bits
+c026df1f T bitmap_dirty_bits
+c026df69 T bitmap_end_sync
+c026e03a T bitmap_close_sync
+c026e08b T bitmap_start_sync
+c026e10f T bitmap_endwrite
+c026e23f t bitmap_file_put
+c026e375 t bitmap_free
+c026e3cc T bitmap_destroy
+c026e3f6 T file_path
+c026e424 t bitmap_file_kick
+c026e4ae T bitmap_daemon_work
+c026e760 T bitmap_flush
+c026e79a T bitmap_startwrite
+c026e901 T bitmap_write_all
+c026e92e T bitmap_unplug
+c026ea75 T bitmap_create
+c026f2d4 t dm_netlink_exit
+c026f2d5 T dm_get_mapinfo
+c026f2e7 T dm_open_count
+c026f2eb T dm_get_geometry
+c026f301 T dm_get_xid
+c026f305 t __noflush_suspending
+c026f30f t max_io_len
+c026f3a0 T dm_get_mdptr
+c026f3a7 T dm_set_mdptr
+c026f3ae T dm_get
+c026f3b3 T dm_device_name
+c026f3b7 T dm_get_event_nr
+c026f3be T dm_disk
+c026f3c2 T dm_suspended
+c026f3cb T dm_set_geometry
+c026f46c t local_exit
+c026f4bb t clone_bio
+c026f52a t dm_bio_destructor
+c026f532 t event_callback
+c026f559 t dec_pending
+c026f6d2 t __map_bio
+c026f7f4 t clone_endio
+c026f8bb t unlock_fs
+c026f8e8 t __unbind
+c026f92b t free_minor
+c026f94f T dm_create
+c026fd01 T dm_get_table
+c026fd2c T dm_put
+c026fe36 T dm_noflush_suspending
+c026fe54 t dm_blk_close
+c026fe6c t dm_any_congested
+c026fea1 t dm_unplug_all
+c026fec2 t dm_flush_all
+c026feed t __split_bio
+c0270304 t __flush_deferred_io
+c0270324 t dm_blk_ioctl
+c02703c5 T dm_resume
+c02704bf T dm_wait_event
+c027054d T dm_swap_table
+c02706bc T dm_suspend
+c0270952 t dm_request
+c0270a40 t dm_blk_open
+c0270ab4 T dm_get_md
+c0270b26 T dm_lock_for_deletion
+c0270b56 t dm_blk_getgeo
+c0270b74 T dm_table_get
+c0270b79 T dm_set_device_limits
+c0270c57 T dm_table_get_size
+c0270c7e T dm_table_get_target
+c0270c96 T dm_table_find_target
+c0270cf0 T dm_table_get_num_targets
+c0270cf7 T dm_table_get_devices
+c0270cfd T dm_table_get_mode
+c0270d04 t suspend_targets
+c0270d3b T dm_table_presuspend_targets
+c0270d44 T dm_table_postsuspend_targets
+c0270d50 T dm_table_resume_targets
+c0270daf T dm_table_get_md
+c0270dbd T dm_table_set_restrictions
+c0270e2c T dm_table_event
+c0270e6a T dm_table_event_callback
+c0270e96 T dm_table_put
+c0270f43 t realloc_argv
+c0270fac T dm_split_args
+c0271074 t close_dev
+c027109f T dm_put_device
+c02710cb t open_dev
+c0271121 T dm_get_device
+c02713b1 T dm_vcalloc
+c02713f1 T dm_table_complete
+c02715aa t alloc_targets
+c0271690 T dm_table_add_target
+c0271900 T dm_table_create
+c027198b T dm_create_error_table
+c0271a3d T dm_table_any_congested
+c0271a85 T dm_table_flush_all
+c0271aed T dm_table_unplug_all
+c0271b18 t io_err_ctr
+c0271b1b t io_err_dtr
+c0271b1c t io_err_map
+c0271b22 T dm_unregister_target
+c0271bb3 T dm_target_exit
+c0271bd2 T dm_register_target
+c0271c86 T dm_target_iterate
+c0271cca T dm_put_target_type
+c0271cff t get_target_type
+c0271d80 T dm_get_target_type
+c0271db4 t linear_map
+c0271ddf T dm_linear_exit
+c0271e03 t linear_ioctl
+c0271e81 t linear_status
+c0271ece t linear_dtr
+c0271ee1 t linear_ctr
+c0271fb4 t stripe_map
+c027207a T dm_stripe_exit
+c0272099 t stripe_status
+c027215c t stripe_dtr
+c0272188 t stripe_ctr
+c02723e8 t init_buckets
+c02723f9 t hash_str
+c0272418 t get_result_buffer
+c0272440 t invalid_str
+c0272455 t check_name
+c027248f t __get_uuid_cell
+c027251f t __get_name_cell
+c02725a7 t __find_device_hash_cell
+c0272636 t find_device
+c02726ba t __dev_status
+c0272754 t dev_status
+c027277f t dev_set_geometry
+c027288a t target_message
+c02729b3 t free_cell
+c02729d4 t list_versions
+c0272a53 t retrieve_status
+c0272bb2 t table_status
+c0272c08 t table_deps
+c0272d1a t table_clear
+c0272d92 t table_load
+c0272f3d t dev_wait
+c0272fa5 t dev_suspend
+c02730fc t dev_rename
+c0273263 t __hash_remove
+c02732b7 t dev_remove
+c0273352 t dm_hash_remove_all
+c02733e0 t dm_hash_exit
+c02733e7 T dm_interface_exit
+c0273407 t dev_create
+c02735be t list_version_get_needed
+c02735dc t list_version_get_info
+c0273675 t ctl_ioctl
+c0273905 t remove_all
+c0273940 t list_devices
+c0273af4 t list_get_page
+c0273b11 t list_next_page
+c0273b21 t bvec_get_page
+c0273b39 t bvec_next_page
+c0273b3e t vm_next_page
+c0273b55 t km_get_page
+c0273b82 t km_next_page
+c0273b99 t vm_get_page
+c0273bc3 t dm_bio_destructor
+c0273bd1 t dec_count
+c0273c1a t dispatch_io
+c0273dd1 t endio
+c0273e22 T dm_io
+c027406b T dm_io_client_destroy
+c0274085 T dm_io_client_resize
+c027409c T dm_io_client_create
+c0274118 t drop_pages
+c027413a t client_free_pages
+c0274168 t jobs_exit
+c02741c1 t kcopyd_exit
+c02741fd T kcopyd_client_destroy
+c0274297 t process_jobs
+c027434e t do_work
+c027437b t run_io_job
+c02743ed t dispatch_job
+c0274437 t kcopyd_put_pages
+c027446b t run_pages_job
+c027450f t run_complete_job
+c0274588 T kcopyd_client_create
+c02747b2 t segment_complete
+c0274942 T kcopyd_copy
+c0274a58 t complete_io
+c0274afc T dmi_get_system_info
+c0274b04 T dmi_find_device
+c0274b53 T dmi_name_in_vendors
+c0274b87 T dmi_check_system
+c0274bdb T dmi_get_year
+c0274c34 t utf8_strlen
+c0274c47 t dummy
+c0274c4d t efivar_release
+c0274c57 t get_var_data
+c0274cbe t efivar_show_raw
+c0274cef t systab_read
+c0274df5 t efivar_size_read
+c0274e3f t efivar_attr_read
+c0274ec6 t efivar_guid_read
+c0274fa1 t efivar_attr_store
+c0274fdc t efivar_attr_show
+c0275013 t efivar_create_sysfs_entry
+c02751e6 t efivar_data_read
+c0275232 t efivar_store_raw
+c027533b t efivar_create
+c02754af t efivar_delete
+c027562c t read_cyclone
+c0275638 t acpi_pm_check_graylist
+c0275666 T acpi_pm_read_verified
+c02756ab t acpi_pm_read_slow
+c02756b3 t acpi_pm_read
+c02756c2 t acpi_pm_check_blacklist
+c0275710 t show_bytes_transferred
+c0275767 t show_memcpy_count
+c02757be t dma_chan_free_rcu
+c0275812 T dma_chan_cleanup
+c0275838 t dma_class_dev_release
+c0275848 t dma_async_device_cleanup
+c0275850 T dma_async_device_unregister
+c0275963 t dma_client_chan_alloc
+c0275a1f T dma_async_client_chan_request
+c0275a3e T dma_sync_wait
+c0275aa0 T dma_async_client_unregister
+c0275b66 t show_in_use
+c0275bb7 T dma_async_tx_descriptor_init
+c0275be3 T dma_async_memcpy_buf_to_pg
+c0275cb0 T dma_async_memcpy_pg_to_pg
+c0275d55 T dma_async_memcpy_buf_to_buf
+c0275e52 T dma_async_device_register
+c0276051 T dma_async_client_register
+c0276080 t num_pages_spanned
+c027609e T dma_memcpy_pg_to_iovec
+c02761af T dma_memcpy_to_iovec
+c02762ef T dma_unpin_iovec_pages
+c027634c T dma_pin_iovec_pages
+c02764e4 t hid_lookup_collection
+c0276521 t hid_add_usage
+c0276560 t hid_parser_reserved
+c0276563 t snto32
+c02765a2 t s32ton
+c02765d5 T hid_set_field
+c0276613 T hid_output_report
+c02768e2 T hid_free_device
+c0276967 t hid_process_event
+c02769ba T hid_input_field
+c0276c99 T hid_input_report
+c0276d68 t hid_add_field
+c0276f50 T hid_parse_report
+c0277191 t hid_parser_main
+c027731e t hid_parser_local
+c027741c t hid_parser_global
+c0277668 t hidinput_find_key
+c027771f t hidinput_getkeycode
+c0277740 t hidinput_close
+c027774b T hidinput_disconnect
+c0277782 T hidinput_connect
+c027a2b4 T hidinput_hid_event
+c027a502 t hidinput_setkeycode
+c027a55b T hidinput_report_event
+c027a593 T hidinput_find_field
+c027a615 t hidinput_open
+c027a620 t hid_find_max_report
+c027a670 t hid_set_idle
+c027a6c8 t hid_start_in
+c027a72f t hid_resume
+c027a754 t hid_post_reset
+c027a77e t hid_suspend
+c027a7be t hid_pre_reset
+c027a7c2 T usbhid_close
+c027a7e2 t hid_free_buffers
+c027a84d t hid_disconnect
+c027a8fe t hid_submit_out
+c027a994 t hid_submit_ctrl
+c027ab5a T usbhid_submit_report
+c027acc8 t usb_hidinput_input_event
+c027ad3b t hid_io_error
+c027ae0e T usbhid_open
+c027ae2b T usbhid_wait_io
+c027aedc T usbhid_init_reports
+c027af97 t hid_probe
+c027bbc4 t hid_irq_in
+c027bcfe t hid_irq_out
+c027be0d t hid_ctrl
+c027bf4e t hid_retry_timeout
+c027bf64 t hid_reset
+c027c08c T usbhid_lookup_quirk
+c027c137 T usbhid_quirks_exit
+c027c17b T usbhid_modify_dquirk
+c027c22f T usbhid_quirks_init
+c027c2a8 T pcibios_align_resource
+c027c2e4 T pci_mmap_page_range
+c027c32f T pcibios_set_master
+c027c3ba T pcibios_enable_resources
+c027c4b8 T pcibios_set_irq_routing
+c027c4f6 t pci_bios_write
+c027c5a4 t pci_bios_read
+c027c653 T pcibios_get_irq_routing_table
+c027c741 T pcibios_sort
+c027c898 t get_base_addr
+c027c8fb t pci_exp_set_dev_base
+c027c93d t pci_mmcfg_read
+c027ca3f t pci_mmcfg_write
+c027cb44 t pci_conf2_read
+c027cc25 t pci_conf2_write
+c027cd07 T pci_conf1_write
+c027cdae T pci_conf1_read
+c027ce5c t pci_fixup_latency
+c027ce67 t pci_fixup_piix4_acpi
+c027ce72 t pci_fixup_transparent_bridge
+c027ce99 t quirk_pcie_aspm_read
+c027cec7 t quirk_pcie_aspm_write
+c027cf25 t pci_siemens_interrupt_controller
+c027cf2d t pci_early_fixup_cyrix_5530
+c027cf72 t pci_pre_fixup_toshiba_ohci1394
+c027cfa7 t pcie_rootport_aspm_quirk
+c027d056 t pci_fixup_umc_ide
+c027d08a t pci_fixup_ncr53c810
+c027d0b7 t pci_fixup_i450gx
+c027d123 t pci_fixup_via_northbridge_bug
+c027d208 t pci_fixup_nforce2
+c027d268 t pci_post_fixup_toshiba_ohci1394
+c027d2e4 t pci_fixup_video
+c027d373 t pci_fixup_i450nx
+c027d454 T pci_acpi_scan_root
+c027d474 t pirq_get_info
+c027d4bf T eisa_set_level_irq
+c027d52d t read_config_nybble
+c027d569 t pirq_amd756_get
+c027d5bb t pirq_vlsi_get
+c027d5e6 t pirq_cyrix_get
+c027d5f4 t pirq_opti_get
+c027d601 t pirq_ite_get
+c027d612 t pirq_via586_get
+c027d623 t pirq_via_get
+c027d63a t pirq_ali_get
+c027d64d t write_config_nybble
+c027d6b3 t pirq_amd756_set
+c027d708 t pirq_vlsi_set
+c027d744 t pirq_cyrix_set
+c027d763 t pirq_opti_set
+c027d781 t pirq_ite_set
+c027d7a3 t pirq_via586_set
+c027d7c5 t pirq_via_set
+c027d7ed t pirq_ali_set
+c027d81d t pirq_bios_set
+c027d839 t pcibios_lookup_irq
+c027db90 T pcibios_penalize_isa_irq
+c027dbbc t pirq_serverworks_get
+c027dbce t pirq_serverworks_set
+c027dbe9 t pirq_enable_irq
+c027dd75 t pirq_piix_get
+c027dd9d t pirq_sis_get
+c027ddd9 t pirq_sis_set
+c027de3b t pirq_piix_set
+c027de5c t pci_read
+c027de8a t pci_write
+c027deb9 T pcibios_assign_all_busses
+c027dec5 T pcibios_disable_device
+c027dedb t assign_all_busses
+c027df00 t set_bf_sort
+c027df2e T pcibios_enable_device
+c027df4f T pcibios_scan_root
+c027dfa5 T pcibios_fixup_bus
+c027e06a T pcibios_setup
+c027e3d8 T write_pci_config_byte
+c027e412 T early_pci_allowed
+c027e424 T read_pci_config
+c027e459 T read_pci_config_byte
+c027e49a T read_pci_config_16
+c027e4dc T write_pci_config
+c027e518 T __restore_processor_state
+c027e67a T restore_processor_state
+c027e684 T __save_processor_state
+c027e6c6 T save_processor_state
+c027e6d0 t sockfs_delete_dentry
+c027e6d7 t sock_no_open
+c027e6dd t sock_sendpage
+c027e71f t sock_poll
+c027e730 t sock_mmap
+c027e741 t sock_pernet_init
+c027e74e T kernel_bind
+c027e757 T kernel_listen
+c027e75e T kernel_connect
+c027e774 T kernel_getsockname
+c027e788 T kernel_getpeername
+c027e79c t sockfs_get_sb
+c027e7b3 t sock_destroy_inode
+c027e7c0 t sock_alloc_inode
+c027e80e t init_once
+c027e816 T kernel_sendpage
+c027e85c T socket_seq_show
+c027e8b6 T sock_unregister
+c027e8fd T sock_register
+c027e972 T move_addr_to_kernel
+c027e9a0 t sock_aio_dtor
+c027e9a8 t alloc_sock_iocb
+c027e9db t sock_aio_write
+c027eb64 t sock_aio_read
+c027eca1 t sock_fasync
+c027edb7 t sock_ioctl
+c027ef91 T dlci_ioctl_set
+c027efaf T vlan_ioctl_set
+c027efcd T brioctl_set
+c027efeb t sockfd_lookup_light
+c027f030 T sys_shutdown
+c027f075 T sys_getsockopt
+c027f0f5 T sys_setsockopt
+c027f17e T sys_connect
+c027f21a T sys_listen
+c027f274 T sys_bind
+c027f303 t sock_alloc
+c027f34f t sock_alloc_fd
+c027f382 t sock_attach_fd
+c027f437 T sock_map_fd
+c027f481 t sockfs_dname
+c027f4ac T sock_wake_async
+c027f505 T sock_recvmsg
+c027f655 T sock_sendmsg
+c027f7e5 T sys_sendmsg
+c027f9de T sys_sendto
+c027fb1a T sys_send
+c027fb55 T __sock_recv_timestamp
+c027fbf9 T sock_release
+c027fc58 t __sock_create
+c027fe17 T sock_create_kern
+c027fe43 T sock_create
+c027fe7d T sys_socketpair
+c027fff2 T sys_socket
+c028003a t sock_close
+c0280069 T sock_create_lite
+c028008c T kernel_accept
+c02800e0 T sockfd_lookup
+c028011c T move_addr_to_user
+c028016c T sys_recvmsg
+c028033b T sys_recvfrom
+c0280469 T sys_recv
+c02804a4 T sys_getpeername
+c0280546 T sys_getsockname
+c02805e8 T sys_accept
+c0280795 T sys_socketcall
+c02809d7 T kernel_sendmsg
+c0280a0c T kernel_recvmsg
+c0280a4c T kernel_getsockopt
+c0280ab0 T kernel_setsockopt
+c0280b14 T kernel_sock_ioctl
+c0280b3c T sock_no_bind
+c0280b42 T sock_no_connect
+c0280b48 T sock_no_socketpair
+c0280b4e T sock_no_accept
+c0280b54 T sock_no_getname
+c0280b5a T sock_no_poll
+c0280b5d T sock_no_ioctl
+c0280b63 T sock_no_listen
+c0280b69 T sock_no_shutdown
+c0280b6f T sock_no_setsockopt
+c0280b75 T sock_no_getsockopt
+c0280b7b T sock_no_sendmsg
+c0280b81 T sock_no_recvmsg
+c0280b87 T sock_no_mmap
+c0280b8d T sock_common_getsockopt
+c0280baf T sock_common_recvmsg
+c0280c03 T sock_common_setsockopt
+c0280c25 t proto_seq_next
+c0280c4e t proto_seq_open
+c0280c5a t proto_seq_show
+c0280fef t proto_seq_stop
+c0280ff9 t proto_seq_start
+c0281053 T sock_i_ino
+c028107f T proto_unregister
+c0281120 t sock_def_destruct
+c028112b T sock_kfree_s
+c0281142 t sk_filter_rcu_free
+c028114a t sock_warn_obsolete_bsdism
+c02811b7 T sock_enable_timestamp
+c02811d1 T sock_get_timestampns
+c028124e T release_sock
+c02812e2 T lock_sock_nested
+c0281380 T sk_stop_timer
+c0281399 T sk_reset_timer
+c02813af T sk_send_sigurg
+c02813f1 T sock_no_sendpage
+c028145a T sock_rmalloc
+c02814ab T sock_alloc_send_skb
+c0281650 T sk_setup_caps
+c02816f2 T sk_alloc
+c02817eb T sk_free
+c0281910 T sk_common_release
+c02819a4 t sock_set_timeout
+c0281a81 T sock_rfree
+c0281a94 t sock_def_wakeup
+c0281ad6 T sk_wait_data
+c0281b79 T sock_i_uid
+c0281ba5 T sock_getsockopt
+c0281ee0 T sock_get_timestamp
+c0281f5d T sock_kmalloc
+c0281f9b T proto_register
+c0282168 T sock_setsockopt
+c02826af T sk_clone
+c028297e T sock_init_data
+c0282bd2 t sock_def_error_report
+c0282c35 t sock_def_readable
+c0282c9b t sock_def_write_space
+c0282d29 T sock_wmalloc
+c0282d81 T sk_dst_check
+c0282e7d T __sk_dst_check
+c0282ee8 T sk_receive_skb
+c0282fc9 T sock_wfree
+c0283002 T sock_queue_rcv_skb
+c02830dc T reqsk_queue_destroy
+c028318d T reqsk_queue_alloc
+c0283248 t copy_skb_header
+c02833b4 T skb_prepare_seq_read
+c02833db T skb_find_text
+c0283443 T skb_to_sgvec
+c0283648 T skb_truesize_bug
+c0283674 T skb_under_panic
+c02836d1 T skb_over_panic
+c028372e T skb_pull_rcsum
+c028379b T skb_abort_seq_read
+c02837b2 t skb_ts_finish
+c02837ba T skb_seq_read
+c028390e t skb_ts_get_next_block
+c028391a T skb_checksum
+c0283bbf T skb_store_bits
+c0283dc9 T skb_copy_bits
+c0283fdf T skb_insert
+c0284010 T skb_append
+c0284040 T skb_unlink
+c0284077 T skb_queue_tail
+c02840a4 T skb_queue_head
+c02840d0 T skb_dequeue_tail
+c0284119 T skb_dequeue
+c0284158 T skb_copy_and_csum_bits
+c0284459 T skb_clone
+c0284643 T kfree_skbmem
+c02846a6 T __kfree_skb
+c028477f T kfree_skb
+c02847ac T skb_queue_purge
+c02847c3 t skb_drop_list
+c02847df t skb_release_data
+c0284860 T pskb_expand_head
+c0284993 T __pskb_pull_tail
+c0284bc3 T ___pskb_trim
+c0284d7a T __alloc_skb
+c0284e82 T skb_copy_expand
+c0284f3f T pskb_copy
+c02850c7 T skb_copy
+c0285187 T skb_append_datato_frags
+c02852d5 T skb_split
+c02854fb T skb_realloc_headroom
+c028555e T skb_pad
+c028566e T skb_cow_data
+c028587c T __netdev_alloc_skb
+c02858b1 T skb_segment
+c0285c79 T skb_copy_and_csum_dev
+c0285d30 T memcpy_fromiovecend
+c0285d84 T memcpy_fromiovec
+c0285dce T csum_partial_copy_fromiovecend
+c0285f99 T memcpy_toiovec
+c0285fe3 T verify_iovec
+c0286050 t skb_copy_and_csum_datagram
+c02863bc T __skb_checksum_complete_head
+c028640d T __skb_checksum_complete
+c0286419 T skb_copy_datagram_iovec
+c02865f5 T skb_copy_and_csum_datagram_iovec
+c02866c4 T skb_kill_datagram
+c0286729 T skb_free_datagram
+c0286730 T datagram_poll
+c02867ed T skb_recv_datagram
+c02869a4 T __sk_stream_mem_reclaim
+c02869f1 T sk_stream_error
+c0286a39 T sk_stream_write_space
+c0286aba T sk_stream_rfree
+c0286af4 T sk_stream_wait_memory
+c0286c7e T sk_stream_mem_schedule
+c0286dc4 T sk_stream_kill_queues
+c0286ed6 T sk_stream_wait_connect
+c0287000 T sk_stream_wait_close
+c02870a8 T scm_fp_dup
+c02870ed T put_cmsg
+c028716c T __scm_destroy
+c02871a0 T __scm_send
+c02873c2 T scm_detach_fds
+c02874c4 T gnet_stats_start_copy_compat
+c028755b T gnet_stats_start_copy
+c028757e T gnet_stats_copy_basic
+c02875e6 T gnet_stats_copy_rate_est
+c0287644 T gnet_stats_copy_queue
+c02876ae T gnet_stats_copy_app
+c028770f T gnet_stats_finish_copy
+c02877bc T gen_kill_estimator
+c0287857 t __gen_kill_estimator
+c028785f T gen_new_estimator
+c028798a T gen_replace_estimator
+c02879b0 t est_timer
+c0287acc t setup_net
+c0287b32 T net_lock
+c0287b3c T net_unlock
+c0287b46 t unregister_pernet_operations
+c0287b7a T unregister_pernet_device
+c0287ba8 T unregister_pernet_subsys
+c0287bc7 t register_pernet_operations
+c0287c45 T register_pernet_device
+c0287c8b T register_pernet_subsys
+c0287cb4 t net_free
+c0287ce5 T __put_net
+c0287d04 t cleanup_net
+c0287d66 T copy_net_ns
+c0287e0c T __dev_get_by_name
+c0287e9d T __dev_get_by_index
+c0287ec9 T dev_valid_name
+c0287f3e T net_enable_timestamp
+c0287f46 T net_disable_timestamp
+c0287f4e T register_gifconf
+c0287f64 t softnet_seq_stop
+c0287f65 t ptype_get_idx
+c0288019 t ptype_seq_start
+c0288035 t ptype_seq_stop
+c0288036 T dev_get_flags
+c028808f t dev_new_index
+c02880bc t internal_stats
+c02880c0 T netdev_compute_features
+c0288114 t netdev_exit
+c028812e t softnet_get_online
+c0288175 t softnet_seq_next
+c0288180 t softnet_seq_start
+c0288184 t ptype_seq_open
+c0288190 t softnet_seq_open
+c028819c t dev_seq_open
+c02881ce t softnet_seq_show
+c028822a t ptype_seq_show
+c028835c t dev_seq_release
+c0288387 t dev_seq_show
+c0288484 t net_dma_rebalance
+c02885b3 t netdev_dma_event
+c0288638 T __netif_rx_schedule
+c028869c T __dev_getfirstbyhwtype
+c028870c t __dev_alloc_name
+c02888a1 t unlist_netdevice
+c028893f t list_netdevice
+c0288a31 T dev_set_mac_address
+c0288a7f T dev_set_mtu
+c0288ad8 T call_netdevice_notifiers
+c0288ae6 T netdev_features_change
+c0288af7 T synchronize_net
+c0288b0b T free_netdev
+c0288b45 T alloc_netdev
+c0288bd6 T register_netdevice
+c0288e88 t dev_gso_skb_destructor
+c0288eae t default_rebuild_header
+c0288ee1 T dev_seq_start
+c0288f5d T dev_seq_stop
+c0288f67 T dev_set_allmulti
+c0288faa T dev_set_promiscuity
+c028901b T dev_change_flags
+c0289118 T netdev_set_master
+c02891c0 T netdev_state_change
+c02891ee T netif_receive_skb
+c0289392 T netif_rx
+c0289457 T netif_rx_ni
+c0289481 T netdev_rx_csum_fault
+c02894b6 T skb_gso_segment
+c028961e T dev_hard_start_xmit
+c0289845 T skb_checksum_help
+c028990c T __netif_schedule
+c0289941 T netif_device_attach
+c0289974 T dev_kfree_skb_any
+c02899cd T unregister_netdevice_notifier
+c02899ec T dev_close
+c0289a53 T dev_change_net_namespace
+c0289be8 T unregister_netdevice
+c0289d3e t default_device_exit
+c0289db7 T unregister_netdev
+c0289dcc T dev_load
+c0289e1b T dev_alloc_name
+c0289e55 T register_netdev
+c0289e9e T dev_change_name
+c028a062 t dev_ifsioc
+c028a3f8 T netdev_boot_base
+c028a46c T __dev_remove_pack
+c028a4e4 T dev_remove_pack
+c028a4ee T dev_open
+c028a556 t ptype_seq_next
+c028a5c3 t net_tx_action
+c028a693 T dev_ioctl
+c028ab53 T netdev_boot_setup_check
+c028abc0 T dev_getbyhwaddr
+c028ac45 T register_netdevice_notifier
+c028acd5 T dev_add_pack
+c028ad36 T dev_seq_next
+c028ad7c T netdev_run_todo
+c028af75 T netif_device_detach
+c028af91 t process_backlog
+c028b05d t net_rx_action
+c028b17e T dev_get_by_name
+c028b1b3 T dev_get_by_index
+c028b1e8 T dev_getfirstbyhwtype
+c028b214 T dev_get_by_flags
+c028b276 t netdev_init
+c028b321 t dev_proc_net_exit
+c028b351 t dev_proc_net_init
+c028b3ed T dev_queue_xmit
+c028b650 T ethtool_op_get_link
+c028b65c T ethtool_op_get_tx_csum
+c028b667 T ethtool_op_set_tx_csum
+c028b678 T ethtool_op_set_tx_hw_csum
+c028b689 T ethtool_op_get_sg
+c028b690 T ethtool_op_set_sg
+c028b6a1 T ethtool_op_get_tso
+c028b6a9 T ethtool_op_set_tso
+c028b6c0 T ethtool_op_get_ufo
+c028b6ca T ethtool_op_set_ufo
+c028b6e1 t __ethtool_set_sg
+c028b732 T ethtool_op_get_perm_addr
+c028b771 t ethtool_get_eeprom
+c028b862 t ethtool_get_regs
+c028b919 T dev_ethtool
+c028c3c4 t __dev_mc_upload
+c028c3e5 t dev_mc_seq_next
+c028c406 t dev_mc_net_exit
+c028c413 t dev_mc_seq_release
+c028c43e t dev_mc_seq_open
+c028c470 t dev_mc_seq_show
+c028c51c t dev_mc_seq_stop
+c028c526 t dev_mc_seq_start
+c028c581 t dev_mc_net_init
+c028c5a5 T dev_mc_upload
+c028c5dc T dev_mc_delete
+c028c692 T dev_mc_add
+c028c7dc T dev_mc_discard
+c028c850 t ___dst_free
+c028c875 t dst_dev_event
+c028c943 t dst_discard
+c028c94b T dst_destroy
+c028c9fa T __dst_free
+c028ca5d t dst_run_gc
+c028cb8d T dst_alloc
+c028cbec T call_netevent_notifiers
+c028cbfa T unregister_netevent_notifier
+c028cc06 T register_netevent_notifier
+c028cc14 t neigh_get_next
+c028cca1 t neigh_get_idx
+c028cd7e t pneigh_get_first
+c028cdb2 t pneigh_get_next
+c028cdfc t neigh_stat_seq_stop
+c028cdfd T neigh_seq_start
+c028ce97 T neigh_seq_next
+c028ceee T neigh_seq_stop
+c028cefe T neigh_for_each
+c028cf51 t neigh_stat_seq_next
+c028cf90 t neigh_dump_info
+c028d342 t neightbl_fill_parms
+c028d661 T neigh_sysctl_unregister
+c028d68c T neigh_parms_destroy
+c028d699 t neigh_rcu_free_parms
+c028d6af T neigh_sysctl_register
+c028d8ab T neigh_connected_output
+c028d948 t neigh_blackhole
+c028d953 t pneigh_queue_purge
+c028d979 t neigh_hash_free
+c028d99c t neigh_stat_seq_open
+c028d9c5 t neigh_stat_seq_show
+c028da4e t neigh_hash_alloc
+c028da78 T __neigh_event_send
+c028dba3 T pneigh_enqueue
+c028dc9c T neigh_rand_reach_time
+c028dcb5 T neigh_table_init_no_netlink
+c028de81 T neigh_table_init
+c028dee6 T neigh_parms_alloc
+c028dfb2 T neigh_parms_alloc_default
+c028dfe3 T pneigh_delete
+c028e0ab T neigh_lookup
+c028e148 T neigh_destroy
+c028e242 t neigh_del_timer
+c028e27d T neigh_update
+c028e5e8 t neigh_flush_dev
+c028e6a4 T neigh_ifdown
+c028e74d T neigh_table_clear
+c028e80a T neigh_changeaddr
+c028e831 T neigh_create
+c028ec5e T neigh_event_ns
+c028ecd4 T __neigh_for_each_release
+c028ed64 T pneigh_lookup
+c028eed8 t neigh_stat_seq_start
+c028ef2c T neigh_lookup_nodev
+c028efd0 t neigh_proxy_process
+c028f08c T neigh_parms_release
+c028f10a t neightbl_dump_info
+c028f720 t neightbl_set
+c028f9ee T neigh_compat_output
+c028fa76 T neigh_resolve_output
+c028fc9a t neigh_periodic_timer
+c028fdec t neigh_delete
+c028ff23 t neigh_add
+c0290161 t neigh_timer_handler
+c02903e4 t rtnl_link_ops_get
+c0290420 t rtnl_link_get_size
+c0290469 t rtnetlink_net_exit
+c0290496 t rtnetlink_net_init
+c02904ed T rtnl_lock
+c02904f7 T __rtnl_unlock
+c0290501 t rtnetlink_rcv
+c029053e T rtattr_parse
+c02905a5 t rtnetlink_rcv_msg
+c029075b t set_operstate
+c02907ba t do_setlink
+c0290a35 T rtnl_unregister_all
+c0290a5a T rtnl_unregister
+c0290a9f t rtnl_fill_ifinfo
+c029107a t rtnl_dump_ifinfo
+c029113e T rtnl_put_cacheinfo
+c02911d1 T rtnl_set_sk_err
+c02911e8 T rtnl_notify
+c029122d T rtmsg_ifinfo
+c0291352 t rtnetlink_event
+c0291394 T rtnl_unicast
+c02913ba t rtnl_getlink
+c02914f9 T rtnetlink_send
+c0291566 T __rtnl_link_unregister
+c029156b T __rtnl_link_register
+c029157e T __rtnl_register
+c02915e0 T rtnl_register
+c0291615 T rtnl_trylock
+c029161f T rtnl_unlock
+c0291674 T rtnl_link_unregister
+c0291689 T rtnl_link_register
+c02916a3 T __rtattr_parse_nested_compat
+c029170b T __rta_fill
+c02917ae T rtattr_strlcpy
+c0291830 t rtnl_dump_all
+c02918b9 t rtnl_setlink
+c02919b0 t rtnl_dellink
+c0291a4a t rtnl_newlink
+c0291e8b T rtnetlink_put_metrics
+c0291fc8 T in4_pton
+c0292106 T in6_pton
+c02923db T in_aton
+c029242b T net_ratelimit
+c029243c t linkwatch_urgent_event
+c0292462 t linkwatch_add_event
+c029248e t linkwatch_schedule_work
+c029250e T linkwatch_fire_event
+c0292545 t __linkwatch_run_queue
+c02926c1 t linkwatch_event
+c02926e3 T linkwatch_run_queue
+c02926ec t __load_pointer
+c029272d T sk_chk_filter
+c029292c T sk_attach_filter
+c0292a11 t sk_filter_rcu_free
+c0292a19 T sk_run_filter
+c0292fd8 t flow_cache_flush_tasklet
+c029304a T flow_cache_flush
+c02930be t flow_cache_flush_per_cpu
+c02930e8 t __flow_cache_shrink
+c0293169 T flow_cache_lookup
+c029349a t flow_cache_new_hashrnd
+c02934f4 t change_tx_queue_len
+c02934fd t change_weight
+c0293506 t net_current_tag
+c0293516 t net_kobject_tag
+c029351d T netdev_sysfs_init
+c0293527 t netdev_store
+c0293589 t store_weight
+c02935a5 t store_tx_queue_len
+c02935c1 t store_flags
+c02935dd t store_mtu
+c02935f9 t wireless_show
+c029364f t show_iw_beacon
+c0293658 t show_iw_retries
+c0293661 t show_iw_misc
+c029366a t show_iw_fragment
+c0293673 t show_iw_crypt
+c029367f t show_iw_nwid
+c029368b t show_iw_noise
+c0293697 t show_iw_level
+c02936a3 t show_iw_link
+c02936af t show_iw_status
+c02936bb t netdev_show
+c02936f8 t show_weight
+c0293709 t show_tx_queue_len
+c029371a t show_flags
+c029372b t show_mtu
+c029373c t show_link_mode
+c029374d t show_type
+c029375e t show_features
+c029376f t show_ifindex
+c0293780 t show_iflink
+c0293791 t show_addr_len
+c02937a2 t format_iw_beacon
+c02937c0 t format_iw_retries
+c02937de t format_iw_misc
+c02937fc t format_iw_fragment
+c029381a t format_iw_crypt
+c0293838 t format_iw_nwid
+c0293856 t format_iw_noise
+c0293875 t format_iw_level
+c0293894 t format_iw_link
+c02938b3 t format_iw_status
+c02938d1 t format_weight
+c02938f2 t format_tx_queue_len
+c0293913 t format_flags
+c0293934 t format_mtu
+c0293955 t show_operstate
+c02939c8 t format_addr
+c0293a22 t show_broadcast
+c0293a4d t format_link_mode
+c0293a6f t format_type
+c0293a91 t format_features
+c0293aaf t format_ifindex
+c0293acd t format_iflink
+c0293aeb t format_addr_len
+c0293b0d t change_flags
+c0293b12 t change_mtu
+c0293b17 t netdev_release
+c0293b3a t netdev_uevent
+c0293be7 T netdev_register_sysfs
+c0293c5d t netstat_show
+c0293cfa t show_tx_compressed
+c0293d0b t show_rx_compressed
+c0293d1c t show_tx_window_errors
+c0293d2d t show_tx_heartbeat_errors
+c0293d3e t show_tx_fifo_errors
+c0293d4f t show_tx_carrier_errors
+c0293d60 t show_tx_aborted_errors
+c0293d71 t show_rx_missed_errors
+c0293d82 t show_rx_fifo_errors
+c0293d93 t show_rx_frame_errors
+c0293da4 t show_rx_crc_errors
+c0293db5 t show_rx_over_errors
+c0293dc6 t show_rx_length_errors
+c0293dd7 t show_collisions
+c0293de8 t show_multicast
+c0293df9 t show_tx_dropped
+c0293e0a t show_rx_dropped
+c0293e1b t show_tx_errors
+c0293e2c t show_rx_errors
+c0293e3d t show_tx_bytes
+c0293e4e t show_rx_bytes
+c0293e5f t show_tx_packets
+c0293e70 t show_rx_packets
+c0293e81 T netdev_unregister_sysfs
+c0293e9a t show_carrier
+c0293edc t show_dormant
+c0293f1c t show_address
+c0293f6c T dma_skb_copy_datagram_iovec
+c0294164 t flush_route_cache
+c029416e t validate_rulemsg
+c02941d8 t lookup_rules_ops
+c029422b t fib_rules_net_init
+c0294251 t fib_nl_fill_rule
+c029448b t rules_ops_put
+c0294498 t dump_rules
+c029450d t notify_rule_change
+c0294613 t fib_rule_put_rcu
+c029461b T fib_rules_register
+c02946af t fib_nl_dumprule
+c0294767 t fib_rules_event
+c0294862 T fib_rules_unregister
+c0294915 t fib_nl_delrule
+c0294b26 T fib_rules_lookup
+c0294bc0 t fib_nl_newrule
+c0294e94 t eth_change_mtu
+c0294eb2 T ether_setup
+c0294f46 T alloc_etherdev
+c0294f55 t eth_mac_addr
+c0294f8c T eth_rebuild_header
+c0294fee t eth_header_parse
+c0295009 T eth_header_cache
+c0295086 T eth_header_cache_update
+c02950aa T eth_header
+c0295199 T eth_type_trans
+c0295290 t noop_dequeue
+c0295293 t pfifo_fast_requeue
+c02952ca T qdisc_reset
+c02952db t noop_requeue
+c029530d t noop_enqueue
+c0295318 T __netdev_watchdog_up
+c0295361 T qdisc_lock_tree
+c029537d T qdisc_unlock_tree
+c0295399 T dev_init_scheduler
+c02953e8 T dev_deactivate
+c0295485 t pfifo_fast_dump
+c02954ec t pfifo_fast_init
+c0295526 T qdisc_destroy
+c0295581 T dev_shutdown
+c02955e3 t __qdisc_destroy
+c02955ee T qdisc_alloc
+c029566f T qdisc_create_dflt
+c02956b4 T dev_activate
+c029575a T netif_carrier_off
+c0295770 T netif_carrier_on
+c0295797 T __qdisc_run
+c0295902 t dev_watchdog
+c02959bd t pfifo_fast_dequeue
+c0295a09 t pfifo_fast_reset
+c0295a38 t pfifo_fast_enqueue
+c0295aa0 T qdisc_lookup
+c0295ad6 t qdisc_leaf
+c0295b0c T qdisc_tree_decrease_qlen
+c0295b5b t check_loop
+c0295bad t check_loop_fn
+c0295bdb T tc_classify
+c0295c15 t psched_open
+c0295c2b t psched_show
+c0295c64 t tc_dump_tclass
+c0295d8c t tc_fill_tclass
+c0295f51 t qdisc_class_dump
+c0295f93 t tclass_notify
+c029603f t tc_ctl_tclass
+c029624f t tc_fill_qdisc
+c029641b t qdisc_notify
+c0296517 t qdisc_lookup_ops
+c0296597 t dev_graft_qdisc
+c0296632 t qdisc_graft
+c02966b5 T tcf_destroy
+c02966d1 T tcf_destroy_chain
+c02966e3 T qdisc_put_rtab
+c0296724 t qdisc_create
+c02968ad T qdisc_watchdog_cancel
+c02968be T qdisc_watchdog_schedule
+c02968df T qdisc_watchdog_init
+c02968fe t qdisc_watchdog
+c0296919 T qdisc_get_rtab
+c02969b1 T unregister_qdisc
+c02969f4 T register_qdisc
+c0296a77 t tc_dump_qdisc
+c0296b81 t tc_get_qdisc
+c0296d4a t tc_modify_qdisc
+c02970fc t blackhole_dequeue
+c02970ff t blackhole_enqueue
+c0297110 T tcf_exts_destroy
+c0297111 T tcf_exts_validate
+c0297139 T tcf_exts_change
+c029713a T tcf_exts_dump
+c029713d T tcf_exts_dump_stats
+c0297140 t tcf_fill_node
+c02972c1 t tcf_node_dump
+c0297303 t tcf_proto_lookup_ops
+c0297383 t tfilter_notify
+c029742f t tc_ctl_tfilter
+c0297894 T unregister_tcf_proto_ops
+c02978d1 T register_tcf_proto_ops
+c029792a t tc_dump_tfilter
+c0297b3c t qdisc_requeue
+c0297b5e t qdisc_dequeue_head
+c0297b95 t qdisc_queue_drop
+c0297bd8 t fifo_dump
+c0297c23 t qdisc_reset_queue
+c0297c37 t pfifo_enqueue
+c0297c83 t fifo_init
+c0297cd1 t bfifo_enqueue
+c0297d20 t nl_pid_hashfn
+c0297d96 t netlink_update_listeners
+c0297de3 t netlink_update_subscriptions
+c0297e3c t netlink_overrun
+c0297e60 T netlink_set_nonroot
+c0297e74 t netlink_seq_socket_idx
+c0297f17 t netlink_net_exit
+c0297f24 t netlink_seq_release
+c0297f51 t netlink_seq_show
+c0297fd8 t netlink_seq_stop
+c0297fe2 t netlink_seq_start
+c0298018 T netlink_set_err
+c02980a3 t netlink_seq_open
+c02980fe t netlink_net_init
+c0298122 t netlink_queue_skip
+c0298147 t netlink_alloc_groups
+c02981e1 t __netlink_create
+c029826f t netlink_destroy_callback
+c0298285 t netlink_dump
+c02983e9 t netlink_table_grab
+c0298477 T netlink_sendskb
+c02984aa t nl_pid_hash_rehash
+c02985e9 t netlink_insert
+c0298702 t netlink_autobind
+c02987ee T netlink_unregister_notifier
+c02987fa T netlink_register_notifier
+c0298806 T netlink_broadcast
+c0298ab6 T netlink_attachskb
+c0298bf8 T netlink_unicast
+c0298dc0 T netlink_ack
+c0298f5d T nlmsg_notify
+c0298fc4 T netlink_getsockbyfilp
+c0298ff6 T netlink_run_queue
+c02990d1 t netlink_seq_next
+c0299179 t netlink_sock_destruct
+c0299253 T netlink_has_listeners
+c0299280 t netlink_getsockopt
+c02992ec t netlink_sendmsg
+c0299533 t netlink_data_ready
+c0299585 T netlink_kernel_create
+c02996c2 t netlink_recvmsg
+c02998f5 t netlink_create
+c0299a43 t netlink_connect
+c0299ae1 t netlink_bind
+c0299c0b t netlink_setsockopt
+c0299d46 t netlink_release
+c0299f46 T netlink_detachskb
+c0299f65 T netlink_dump_start
+c029a09c t netlink_getname
+c029a0f8 T nla_find
+c029a12f t validate_nla
+c029a21f T __nla_reserve_nohdr
+c029a27a T __nla_put_nohdr
+c029a29c T nla_put_nohdr
+c029a2d9 T __nla_reserve
+c029a352 T __nla_put
+c029a377 T nla_strcmp
+c029a39f T nla_reserve_nohdr
+c029a3d0 T nla_put
+c029a418 T nla_reserve
+c029a44c T nla_strlcpy
+c029a4ce T nla_memcpy
+c029a4f3 T nla_memcmp
+c029a50b T nla_validate
+c029a552 T nla_parse
+c029a600 t genl_family_find_byid
+c029a637 t genl_family_find_byname
+c029a691 t genl_get_cmd
+c029a6c8 t genl_lock
+c029a6d2 t ctrl_fill_info
+c029aa0d t genl_unlock
+c029aa35 t ctrl_build_msg
+c029aaa7 t ctrl_getfamily
+c029ab1f t genl_rcv
+c029ab68 t genl_ctrl_event
+c029abc5 T genl_unregister_family
+c029ac5a T genl_register_family
+c029ad69 T genl_register_ops
+c029addc T genl_unregister_ops
+c029ae32 t genl_rcv_msg
+c029af85 t ctrl_dumpfamily
+c029b060 T nf_iterate
+c029b0ca T nf_ct_attach
+c029b0dd t netfilter_proc_exit
+c029b0ea t netfilter_proc_init
+c029b112 T nf_conntrack_destroy
+c029b123 T skb_make_writable
+c029b1ee T nf_hook_slow
+c029b2a3 T nf_unregister_hook
+c029b2d1 T nf_unregister_hooks
+c029b2ef T nf_register_hook
+c029b34d T nf_register_hooks
+c029b38e T nf_register_afinfo
+c029b3b7 T nf_unregister_afinfo
+c029b3e2 T nf_proto_csum_replace4
+c029b4a8 t seq_start
+c029b4ba t seq_next
+c029b4db t seq_stop
+c029b4dc t nflog_open
+c029b4e8 t seq_show
+c029b53c T nf_log_packet
+c029b5d7 T nf_log_unregister
+c029b610 T nf_log_unregister_pf
+c029b63f T nf_log_register
+c029b690 t seq_start
+c029b6a2 t seq_next
+c029b6c3 t seq_stop
+c029b6c4 t nfqueue_open
+c029b6d0 t seq_show
+c029b740 t __nf_queue
+c029b8ab T nf_queue
+c029b983 T nf_unregister_queue_handlers
+c029b9b7 T nf_unregister_queue_handler
+c029b9e7 T nf_register_queue_handler
+c029ba32 T nf_reinject
+c029bb80 t nf_sockopt
+c029bc62 T nf_getsockopt
+c029bc87 T nf_setsockopt
+c029bcac T nf_unregister_sockopt
+c029bcf8 T nf_register_sockopt
+c029bd74 t path_free
+c029bd8f T nf_unregister_sysctl_table
+c029bda2 T nf_register_sysctl_table
+c029be18 t rt_hash_code
+c029be8f t rt_cpu_seq_stop
+c029be90 t rt_may_expire
+c029befe t ipv4_dst_check
+c029bf01 t set_class_tag
+c029bf28 t ipv4_rt_blackhole_update_pmtu
+c029bf29 t ipv4_link_failure
+c029bf6d t rt_del
+c029c014 t ipv4_negative_advice
+c029c09b t dst_rcu_free
+c029c0ba t ipv4_dst_ifdown
+c029c103 t ip_handle_martian_source
+c029c214 t rt_garbage_collect
+c029c489 t rt_run_flush
+c029c515 t ip_rt_net_exit
+c029c547 t ip_rt_net_init
+c029c5b7 t rt_cpu_seq_open
+c029c5c3 t rt_cpu_seq_show
+c029c670 t rt_cpu_seq_next
+c029c6a8 t rt_cache_seq_release
+c029c6d5 t fib_rule_put_rcu
+c029c6dd t rt_cache_seq_stop
+c029c6e8 t rt_cache_get_next
+c029c71e t rt_cache_get_first
+c029c752 t rt_cache_seq_next
+c029c76f t rt_cache_seq_start
+c029c7b8 t ip_rt_acct_read
+c029c88d t ipv4_blackhole_output
+c029c895 t ip_error
+c029c91d t rt_fill_info
+c029cc7a t rt_check_expire
+c029cdd2 t rt_set_nexthop
+c029ced6 t rt_intern_hash
+c029d21e T __ip_route_output_key
+c029d926 T ip_route_output_flow
+c029db15 T ip_route_output_key
+c029db28 T ip_route_input
+c029e783 T rt_bind_peer
+c029e7db T rt_cache_flush
+c029e888 t ipv4_sysctl_rtcache_flush_strategy
+c029e8b4 t ipv4_sysctl_rtcache_flush
+c029e8f2 T ip_rt_multicast_event
+c029e8f9 t rt_secret_rebuild
+c029e91a t rt_cpu_seq_start
+c029e96b T __ip_select_ident
+c029ea23 T ip_rt_get_source
+c029eac8 t inet_rtm_getroute
+c029ece6 t rt_cache_seq_show
+c029ee57 T ip_rt_frag_needed
+c029efff t ip_rt_update_pmtu
+c029f05a t ip_rt_bug
+c029f0d9 T ip_rt_dump
+c029f23f T ip_rt_redirect
+c029f86b T ip_rt_send_redirect
+c029fa12 t ipv4_dst_destroy
+c029fa64 t rt_cache_seq_open
+c029facc t peer_avl_rebalance
+c029fc21 T inet_putpeer
+c029fc74 t unlink_from_unused
+c029fcbf t cleanup_once
+c029fe36 t inet_peers_net_exit
+c029fe40 t peer_check_expire
+c029ff1f T inet_getpeer
+c02a0094 t inet_peers_net_init
+c02a017c T inet_add_protocol
+c02a01b4 T inet_del_protocol
+c02a01f4 t ip_rcv_finish
+c02a049c t ip_local_deliver_finish
+c02a062b T ip_call_ra_chain
+c02a06f2 T ip_rcv
+c02a0bc3 T ip_local_deliver
+c02a0dd4 t ipqhashfn
+c02a0e59 T ipfrag_init
+c02a0e63 t ipq_kill
+c02a0ec6 t ip_frag_destroy
+c02a0f86 t ip_evictor
+c02a1035 t ipfrag_net_exit
+c02a106b t ipfrag_net_init
+c02a1166 t ipfrag_secret_rebuild
+c02a123b T ip_defrag
+c02a1c7d t ip_expire
+c02a1d2c t ip_forward_finish
+c02a1d5a T ip_forward
+c02a2020 t ip_options_get_alloc
+c02a2049 T ip_options_compile
+c02a24df t ip_options_get_finish
+c02a252a T ip_options_get_from_user
+c02a257c T ip_options_get
+c02a25c1 T ip_options_undo
+c02a2664 T ip_options_build
+c02a27c3 T ip_options_fragment
+c02a282c T ip_options_echo
+c02a2b1f T ip_forward_options
+c02a2c76 T ip_options_rcv_srr
+c02a2e40 t dst_output
+c02a2e47 T ip_send_check
+c02a2e87 t ip_reply_glue_bits
+c02a2ef7 T ip_push_pending_frames
+c02a32ad T ip_append_data
+c02a3c20 t ip_copy_metadata
+c02a3d17 T ip_fragment
+c02a43e3 t ip_finish_output
+c02a4606 t ip_finish_output2
+c02a47d0 t ip_dev_loopback_xmit
+c02a484d T ip_generic_getfrag
+c02a48e3 T ip_append_page
+c02a4d09 T ip_send_reply
+c02a4f08 T ip_queue_xmit
+c02a526d T ip_flush_pending_frames
+c02a5317 T ip_build_and_send_pkt
+c02a5506 T ip_mc_output
+c02a58c7 T ip_output
+c02a5b84 T ip_getsockopt
+c02a60da T ip_ra_control
+c02a61cb T ip_cmsg_send
+c02a6260 T ip_cmsg_recv
+c02a63bd T ip_recv_error
+c02a657a T ip_local_error
+c02a66d1 T ip_setsockopt
+c02a710f T ip_icmp_error
+c02a722c T inet_bind_hash
+c02a7259 T inet_bind_bucket_destroy
+c02a727b T inet_put_port
+c02a72e6 t __inet_check_established
+c02a7601 T inet_listen_wlock
+c02a768b T inet_bind_bucket_create
+c02a76d5 T __inet_lookup_listener
+c02a7927 T inet_hash_connect
+c02a7db8 T inet_twsk_schedule
+c02a7f07 T inet_twsk_alloc
+c02a7fcb T __inet_twsk_kill
+c02a80ad T inet_twdr_twcal_tick
+c02a823e t inet_twdr_do_twkill_work
+c02a8330 T inet_twdr_twkill_work
+c02a83b9 T inet_twdr_hangman
+c02a844f T __inet_twsk_hashdance
+c02a853a T inet_twsk_deschedule
+c02a85f4 T inet_csk_ctl_sock_create
+c02a8642 T inet_csk_destroy_sock
+c02a876b T inet_csk_reset_keepalive_timer
+c02a877e T inet_csk_delete_keepalive_timer
+c02a8789 T inet_csk_listen_stop
+c02a88c8 T ipv4_rcv_saddr_equal
+c02a8a9f T inet_csk_bind_conflict
+c02a8b2b T inet_csk_route_req
+c02a8c4c T inet_csk_addr2sockaddr
+c02a8c65 T inet_csk_accept
+c02a8e6d T inet_csk_init_xmit_timers
+c02a8ed1 T inet_csk_clear_xmit_timers
+c02a8f0f T inet_csk_reqsk_queue_hash_add
+c02a9001 T inet_csk_reqsk_queue_prune
+c02a91c9 T inet_csk_clone
+c02a9223 T inet_csk_listen_start
+c02a9334 T inet_csk_get_port
+c02a951d T inet_csk_search_req
+c02a960c T tcp_enter_memory_pressure
+c02a9650 t tcp_net_init
+c02a967b t tcp_close_state
+c02a978c T tcp_done
+c02a987f T tcp_get_info
+c02a9a26 T tcp_getsockopt
+c02a9c6c T tcp_shutdown
+c02a9c97 t tcp_prequeue_process
+c02a9cf9 T tcp_cleanup_rbuf
+c02a9de7 T tcp_setsockopt
+c02aa0fa T tcp_poll
+c02aa220 T tcp_tso_segment
+c02aa45d T tcp_ioctl
+c02aa574 T tcp_sendpage
+c02aab29 T tcp_sendmsg
+c02ab54a T tcp_read_sock
+c02ab6bb T tcp_close
+c02abc07 T tcp_recvmsg
+c02ac610 T tcp_disconnect
+c02aca00 t tcp_incr_quickack
+c02aca47 T tcp_enter_quickack_mode
+c02aca62 t tcp_init_buffer_space
+c02acbb7 T tcp_initialize_rcv_mss
+c02acbfb t tcp_rcv_rtt_update
+c02acc3d T tcp_rcv_space_adjust
+c02acd4a t tcp_rtt_estimator
+c02ace45 T tcp_update_metrics
+c02acfb7 T tcp_init_cwnd
+c02acff2 T tcp_enter_cwr
+c02ad0a9 t tcp_init_metrics
+c02ad20d t tcp_update_reordering
+c02ad2ab T tcp_clear_retrans
+c02ad2f2 t tcp_check_reno_reordering
+c02ad342 t tcp_cwnd_down
+c02ad3d9 t tcp_undo_cwr
+c02ad4c3 t tcp_try_undo_recovery
+c02ad5cf t tcp_try_undo_dsack
+c02ad611 t tcp_ack_saw_tstamp
+c02ad654 t tcp_cong_avoid
+c02ad685 t tcp_ratehalving_spur_to_response
+c02ad68c t tcp_dsack_set
+c02ad712 t tcp_dsack_extend
+c02ad752 t tcp_check_space
+c02ad816 t tcp_disordered_ack
+c02ad8b1 t tcp_reset
+c02ad901 t tcp_send_dupack
+c02ad966 t tcp_mark_head_lost
+c02ada85 t tcp_add_reno_sack
+c02adad2 T tcp_enter_loss
+c02adce2 t tcp_enter_frto_loss
+c02adeb9 t tcp_sacktag_write_queue
+c02ae68e t tcp_ack
+c02afe82 t tcp_urg
+c02b000a t tcp_fin
+c02b01c3 t tcp_event_data_recv
+c02b0484 t tcp_collapse
+c02b07df t tcp_prune_queue
+c02b0a1a t tcp_data_queue
+c02b147c t __tcp_ack_snd_check
+c02b14e8 t __tcp_checksum_complete_user
+c02b1515 T tcp_parse_options
+c02b16fc t tcp_fast_parse_options
+c02b1761 T tcp_cwnd_application_limited
+c02b17e4 T tcp_enter_frto
+c02b19a9 T tcp_use_frto
+c02b1a04 T tcp_rcv_state_process
+c02b24d7 T tcp_rcv_established
+c02b2cb4 T tcp_select_initial_window
+c02b2da1 t tcp_set_skb_tso_segs
+c02b2e1e T tcp_mtu_to_mss
+c02b2e5c T tcp_mss_to_mtu
+c02b2e7f T tcp_mtup_init
+c02b2edb T tcp_sync_mss
+c02b2f4d T tcp_current_mss
+c02b3014 t tcp_window_allows
+c02b3032 t tcp_init_tso_segs
+c02b3073 t tcp_snd_test
+c02b314e T tcp_may_send_now
+c02b319f T __tcp_select_window
+c02b32ab t update_send_head
+c02b333b t tcp_syn_build_options
+c02b33a8 t tcp_transmit_skb
+c02b3a3a t tcp_xmit_probe_skb
+c02b3ae4 T tcp_send_ack
+c02b3bd3 t tcp_cwnd_validate
+c02b3c2b t __pskb_trim_head
+c02b3cf3 T tcp_trim_head
+c02b3da9 T tcp_fragment
+c02b41b3 T tcp_write_wakeup
+c02b42d0 T tcp_retransmit_skb
+c02b4856 T tcp_xmit_retransmit_queue
+c02b4ada t tso_fragment
+c02b4c7c T __tcp_push_pending_frames
+c02b544a T tcp_send_active_reset
+c02b552f T tcp_make_synack
+c02b5824 T tcp_send_delayed_ack
+c02b58dd T tcp_push_one
+c02b59ba T tcp_simple_retransmit
+c02b5b36 T tcp_connect
+c02b5e65 T tcp_send_probe0
+c02b5f2c T tcp_send_synack
+c02b609d T tcp_send_fin
+c02b61d4 t tcp_orphan_retries
+c02b61fc T tcp_init_xmit_timers
+c02b6217 t tcp_write_err
+c02b6258 t tcp_out_of_resources
+c02b6321 T tcp_set_keepalive
+c02b6361 t tcp_keepalive_timer
+c02b6513 t tcp_delack_timer
+c02b66a2 t tcp_write_timer
+c02b6ca0 t tcp_v4_get_port
+c02b6cbb t tcp_v4_hash
+c02b6e37 t tcp_v4_send_ack
+c02b6f8b t tcp_v4_send_reset
+c02b70c6 t tcp_v4_send_synack
+c02b71b9 T tcp4_proc_exit
+c02b71c3 t tcp4_seq_show
+c02b77f9 T tcp_proc_unregister
+c02b7825 t tcp4_proc_net_exit
+c02b782f T tcp_proc_register
+c02b789d t tcp4_proc_net_init
+c02b78a7 t tcp_seq_release
+c02b78d4 t tcp_seq_open
+c02b7968 t tcp_seq_stop
+c02b79d9 t established_get_next
+c02b7ae0 t established_get_first
+c02b7bb5 t listening_get_next
+c02b7d62 t tcp_get_idx
+c02b7e12 t tcp_seq_start
+c02b7e4a T tcp_v4_tw_remember_stamp
+c02b7e9c T tcp_v4_do_rcv
+c02b81ce T tcp_unhash
+c02b826c t tcp_v4_reqsk_destructor
+c02b8274 t tcp_v4_reqsk_send_ack
+c02b829f T tcp_v4_remember_stamp
+c02b8344 t tcp_v4_init_sock
+c02b8485 T tcp_twsk_unique
+c02b84e4 T tcp_v4_syn_recv_sock
+c02b87d1 T tcp_v4_send_check
+c02b8887 t tcp_seq_next
+c02b890a T tcp_v4_conn_request
+c02b8cb8 T tcp_v4_destroy_sock
+c02b8e26 T tcp_v4_connect
+c02b93d4 T tcp_v4_gso_send_check
+c02b9461 T tcp_v4_err
+c02b999a T tcp_v4_rcv
+c02ba28c T tcp_twsk_destructor
+c02ba28d T tcp_child_process
+c02ba313 T tcp_create_openreq_child
+c02ba689 T tcp_check_req
+c02ba970 T tcp_time_wait
+c02bab6b T tcp_timewait_state_process
+c02baf54 t tcp_ca_find
+c02baf90 T tcp_slow_start
+c02bb026 T tcp_reno_min_cwnd
+c02bb02f T tcp_get_default_congestion_control
+c02bb059 T tcp_set_allowed_congestion_control
+c02bb12d T tcp_unregister_congestion_control
+c02bb156 T tcp_register_congestion_control
+c02bb1eb T tcp_set_default_congestion_control
+c02bb27a T tcp_cleanup_congestion_control
+c02bb29d T tcp_set_congestion_control
+c02bb353 T tcp_get_available_congestion_control
+c02bb3b8 T tcp_get_allowed_congestion_control
+c02bb425 T tcp_reno_cong_avoid
+c02bb4f3 T tcp_reno_ssthresh
+c02bb507 T tcp_init_congestion_control
+c02bb56c T ip4_datagram_connect
+c02bb898 t dst_output
+c02bb89f T __raw_v4_lookup
+c02bb9db t raw_get_next
+c02bba2f t raw_get_first
+c02bba8e t raw_seq_next
+c02bbaab t raw_v4_unhash
+c02bbb2a t raw_rcv_skb
+c02bbb48 t raw_getsockopt
+c02bbbc6 t raw_setsockopt
+c02bbc21 t raw_ioctl
+c02bbc88 t raw_close
+c02bbc9c t raw_proc_net_exit
+c02bbca9 t raw_seq_release
+c02bbcd6 t raw_seq_show
+c02bbe5f t raw_seq_stop
+c02bbe69 t raw_seq_start
+c02bbebe t raw_seq_open
+c02bbf24 t raw_proc_net_init
+c02bbf4b T raw_rcv
+c02bc008 T raw_v4_input
+c02bc146 t raw_init
+c02bc15d t raw_v4_hash
+c02bc1bf t raw_bind
+c02bc379 t raw_recvmsg
+c02bc4f8 T raw_err
+c02bc5f2 t raw_sendmsg
+c02bcde0 t udp_lib_hash
+c02bcde4 T __udp_lib_get_port
+c02bcfd3 T udp_get_port
+c02bcff6 t udp_v4_get_port
+c02bd003 t udp_get_next
+c02bd058 t udp_get_idx
+c02bd0f1 t udp_seq_next
+c02bd112 t udp_lib_close
+c02bd117 T udp4_proc_exit
+c02bd121 T udp4_seq_show
+c02bd2cf T udp_proc_unregister
+c02bd2fb t udp4_proc_net_exit
+c02bd305 T udp_proc_register
+c02bd373 t udp4_proc_net_init
+c02bd37d t udp_seq_release
+c02bd3aa t udp_seq_open
+c02bd43c t udp_seq_stop
+c02bd446 t udp_seq_start
+c02bd47c t __udp4_lib_lookup
+c02bd62c T udp_poll
+c02bd707 T udp_lib_getsockopt
+c02bd79d T udp_getsockopt
+c02bd7de t udp_push_pending_frames
+c02bdab8 T udp_lib_setsockopt
+c02bdba2 T udp_setsockopt
+c02bdbec t udp_flush_pending_frames
+c02bdc0e T udp_destroy_sock
+c02bdc2a T udp_queue_rcv_skb
+c02bdf92 T __udp4_lib_rcv
+c02bea1c T udp_rcv
+c02bea2b T udp_disconnect
+c02beb09 T udp_sendmsg
+c02bf110 t udplite_getfrag
+c02bf11d T __udp4_lib_err
+c02bf26e T udp_err
+c02bf278 T udp_ioctl
+c02bf2e2 t udp_lib_unhash
+c02bf36a T udp_recvmsg
+c02bf569 T udp_sendpage
+c02bf6a0 t udp_lib_hash
+c02bf6a4 t udplite_sk_init
+c02bf6ae t udp_lib_unhash
+c02bf736 t udp_lib_close
+c02bf73b t udplite_err
+c02bf75c t udplite_rcv
+c02bf78b T udplite_get_port
+c02bf7a9 t udplite_v4_get_port
+c02bf7b8 t arp_hash
+c02bf834 t arp_state_to_flags
+c02bf84e T arp_mc_map
+c02bf94f t arp_error_report
+c02bf973 t arp_ignore
+c02bf9f2 T arp_bind_neighbour
+c02bfa56 t arp_netdev_event
+c02bfa7d t arp_proc_exit
+c02bfa8a t arp_net_exit
+c02bfaad t arp_seq_release
+c02bfada t arp_seq_show
+c02bfcbd t arp_seq_start
+c02bfcd3 t arp_seq_open
+c02bfd2e t arp_net_init
+c02bfdbf T arp_xmit
+c02bfe10 T arp_ifdown
+c02bfe1c T arp_ioctl
+c02c03aa T arp_create
+c02c05a1 T arp_send
+c02c0605 t arp_process
+c02c0b51 t arp_rcv
+c02c0c54 t parp_redo
+c02c0c59 t arp_constructor
+c02c0d68 t arp_solicit
+c02c0efd T arp_find
+c02c1080 T xrlim_allow
+c02c10b3 t icmp_out_count
+c02c111e t icmp_address
+c02c111f t icmp_discard
+c02c1120 t icmp_net_exit
+c02c117b t icmp_net_init
+c02c1263 t icmp_push_reply
+c02c13e1 t icmp_glue_bits
+c02c145f t icmp_xmit_unlock
+c02c147e t icmp_reply
+c02c1649 t icmp_ping_of_death
+c02c176a T icmp_rcv
+c02c189b t icmp_address_reply
+c02c19e6 t icmp_echo
+c02c1a33 t icmp_timestamp
+c02c1af6 T icmp_send
+c02c1eaf t icmp_unreach
+c02c21a5 t icmp_redirect
+c02c2224 t confirm_addr_indev
+c02c22b8 T in_dev_finish_destroy
+c02c2344 t in_dev_rcu_put
+c02c2360 t inet_alloc_ifa
+c02c2382 t inet_fill_ifaddr
+c02c255b t rtmsg_ifa
+c02c2657 t __inet_insert_ifa
+c02c2766 t inet_insert_ifa
+c02c276f t inet_dump_ifaddr
+c02c2933 t __inet_del_ifa
+c02c2b26 t inet_del_ifa
+c02c2b40 t devinet_sysctl_unregister
+c02c2b69 t devinet_net_exit
+c02c2b80 t devinet_sysctl_register
+c02c2c7e t devinet_net_init
+c02c2d02 t devinet_copy_dflt_conf
+c02c2d68 t devinet_conf_proc
+c02c2dc6 t devinet_conf_sysctl
+c02c2e91 T ipv4_doint_and_flush_strategy
+c02c2ece T ipv4_doint_and_flush
+c02c2f15 T inet_forward_change
+c02c2f8d t devinet_sysctl_forward
+c02c3000 T inetdev_by_index
+c02c303c t inet_rtm_newaddr
+c02c31d8 T unregister_inetaddr_notifier
+c02c31e4 T register_inetaddr_notifier
+c02c31f0 T inet_addr_onlink
+c02c322f T inet_ifa_byprefix
+c02c3294 T inet_select_addr
+c02c334e T inet_confirm_addr
+c02c33f1 t inetdev_event
+c02c38bc t inet_rtm_deladdr
+c02c39d8 t inet_gifconf
+c02c3b1c t inet_rcu_free_ifa
+c02c3b41 T devinet_ioctl
+c02c4250 t inet_net_init
+c02c4267 t inet_net_exit
+c02c4268 t inet_autobind
+c02c42d9 T inet_shutdown
+c02c4395 T snmp_mib_free
+c02c43be T snmp_mib_init
+c02c4419 T snmp_fold_field
+c02c4465 T inet_unregister_protosw
+c02c44b6 T inet_register_protosw
+c02c454a T inet_ioctl
+c02c45e7 T build_ehash_secret
+c02c4623 t inet_create
+c02c4906 T inet_dgram_connect
+c02c4954 T inet_sendmsg
+c02c4999 t inet_sendpage
+c02c4a1c T inet_sk_rebuild_header
+c02c4d79 T inet_getname
+c02c4e4a t inet_gso_send_check
+c02c4f0a t inet_gso_segment
+c02c50a4 T inet_release
+c02c50e9 T inet_listen
+c02c5147 T inet_bind
+c02c53f7 T inet_stream_connect
+c02c55f6 T inet_accept
+c02c5697 T inet_sock_destruct
+c02c5858 T ip_mc_rejoin_group
+c02c5859 T ip_check_mc
+c02c58d6 t igmp_mcf_get_next
+c02c5996 t igmp_mcf_seq_start
+c02c5aa9 t igmp_mcf_seq_next
+c02c5b7d t igmp_mc_get_next
+c02c5c0c t igmp_mc_seq_start
+c02c5cff t igmp_mc_seq_next
+c02c5d99 t ip_ma_put
+c02c5dc5 t igmp_mcf_seq_stop
+c02c5e1b t igmp_mcf_seq_open
+c02c5e64 t igmp_mc_seq_show
+c02c5f17 t ip_mc_del1_src
+c02c5f7b t ip_mc_add_src
+c02c60bf t ip_mc_del_src
+c02c6189 t ip_mc_leave_src
+c02c620b t ip_mc_find_dev
+c02c62dd t igmp_group_dropped
+c02c6373 T ip_mc_dec_group
+c02c640b T ip_mc_leave_group
+c02c64af T ip_mc_down
+c02c6509 T ip_mc_destroy_dev
+c02c6582 t igmp_group_added
+c02c65cd T ip_mc_init_dev
+c02c6631 T ip_mc_inc_group
+c02c6753 T ip_mc_up
+c02c67ac t igmp_mcf_seq_show
+c02c6841 T ip_mc_join_group
+c02c6902 T ip_mc_source
+c02c6bd8 T ip_mc_msfilter
+c02c6de1 T ip_mc_msfget
+c02c6ed4 T ip_mc_gsfget
+c02c6ff8 T ip_mc_sf_allow
+c02c7071 T ip_mc_drop_socket
+c02c70ec t igmp_mc_seq_stop
+c02c712c t igmp_mc_seq_open
+c02c7178 t ipv4_sysctl_forward_strategy
+c02c7216 t ipv4_sysctl_forward
+c02c7266 t strategy_allowed_congestion_control
+c02c7307 t sysctl_tcp_congestion_control
+c02c7381 t proc_tcp_congestion_control
+c02c73ea t proc_tcp_available_congestion_control
+c02c7468 t proc_allowed_congestion_control
+c02c74f8 T fib_get_table
+c02c7526 t put_rtax
+c02c753c t fib_flush
+c02c7584 t fib_disable_ip
+c02c75bb t nl_fib_lookup_exit
+c02c75e8 t ip_fib_net_exit
+c02c7645 t fib_net_exit
+c02c7660 t fib_rule_put_rcu
+c02c7668 t fib_net_init
+c02c7735 t nl_fib_input
+c02c788e T inet_addr_type
+c02c794c t inet_dump_fib
+c02c7a31 t rtm_to_fib_config
+c02c7b76 t inet_rtm_delroute
+c02c7baf T fib_new_table
+c02c7c00 t fib_magic
+c02c7cb0 T fib_add_ifaddr
+c02c7de1 t fib_netdev_event
+c02c7e46 t fib_inetaddr_event
+c02c8007 t inet_rtm_newroute
+c02c8040 T ip_rt_ioctl
+c02c83c5 T ip_dev_find
+c02c8474 T fib_validate_source
+c02c86c0 T fib_nh_match
+c02c86f8 T fib_info_exit
+c02c8703 t fib_rule_put_rcu
+c02c870b T fib_info_init
+c02c872d T free_fib_info
+c02c877b T fib_dump_info
+c02c89eb T __fib_res_prefsrc
+c02c8a02 t fib_hash_alloc
+c02c8a29 t fib_hash_free
+c02c8a4e T fib_detect_death
+c02c8ac4 T rtmsg_fib
+c02c8c14 T fib_find_alias
+c02c8c56 T fib_semantic_match
+c02c8d05 T fib_sync_down
+c02c8e16 T fib_release_info
+c02c8ec5 T ip_fib_check_default
+c02c8f3b T fib_create_info
+c02c969c T fib_proc_exit
+c02c96a9 t fib_seq_release
+c02c96d6 t fib_seq_show
+c02c98b8 t fib_get_first
+c02c997a t fib_get_next
+c02c9a7a t fib_seq_next
+c02c9a8e t fib_seq_stop
+c02c9a98 t fib_seq_start
+c02c9b30 t fib_find_node
+c02c9b74 t fib_seq_open
+c02c9bcf T fib_proc_init
+c02c9c00 T fib_hash_init
+c02c9cc9 t fn_hash_flush
+c02c9df9 T fib_hash_exit
+c02c9e0f t fn_hash_delete
+c02c9fc0 t fz_hash_alloc
+c02c9fea t fn_hash_dump
+c02ca1ac t fn_hash_lookup
+c02ca260 t fn_hash_insert
+c02ca8a8 t fn_hash_select_default
+c02caa4c t netstat_seq_open
+c02caa5a t snmp_seq_open
+c02caa68 t sockstat_seq_open
+c02caa76 t fold_prot_inuse
+c02caaae t sockstat_seq_show
+c02cab9e t netstat_seq_show
+c02cac97 t snmp_seq_show
+c02caf20 T fib_rules_tclass
+c02caf2d t fib4_rule_match
+c02caf64 t fib4_rule_default_pref
+c02caf7f T fib4_rules_exit
+c02caf9d t fib4_rule_flush_cache
+c02cafa5 t fib4_rule_fill
+c02cb04e T fib_select_default
+c02cb08f t fib4_rule_action
+c02cb0d9 T fib_lookup
+c02cb11f t fib4_rule_nlmsg_payload
+c02cb125 t fib4_rule_compare
+c02cb197 t fib4_rule_configure
+c02cb27d T fib4_rules_init
+c02cb2f4 t tunnel4_err
+c02cb328 t tunnel64_rcv
+c02cb38f T xfrm4_tunnel_register
+c02cb3e6 T xfrm4_tunnel_deregister
+c02cb43a t tunnel4_rcv
+c02cb4b0 t ipv4_netfilter_fini
+c02cb4ba t ipv4_netfilter_init
+c02cb4c4 T nf_ip_checksum
+c02cb5a4 T ip_xfrm_me_harder
+c02cb6c2 T ip_route_me_harder
+c02cb96e t nf_ip_saveroute
+c02cb994 t nf_ip_reroute
+c02cb9e8 t bictcp_acked
+c02cba0e t bictcp_undo_cwnd
+c02cba24 t bictcp_state
+c02cba89 t bictcp_cong_avoid
+c02cbe1e t bictcp_recalc_ssthresh
+c02cbe7b t bictcp_init
+c02cbeec t xfrm4_garbage_collect
+c02cbf06 t xfrm4_update_pmtu
+c02cbf13 t xfrm4_dst_ifdown
+c02cbf80 t xfrm4_dst_lookup
+c02cbf85 t __xfrm4_find_bundle
+c02cc00f t __xfrm4_bundle_create
+c02cc3f0 t xfrm4_dst_destroy
+c02cc49a t xfrm4_get_saddr
+c02cc528 t _decode_session4
+c02cc6f0 t xfrm4_init_flags
+c02cc703 t __xfrm4_init_tempsel
+c02cc808 T xfrm4_rcv_encap
+c02ccbfb T xfrm4_rcv
+c02ccc1f t xfrm4_rcv_encap_finish
+c02ccc78 t dst_output
+c02ccc7f t xfrm4_output_finish2
+c02ccefc t xfrm4_output_finish
+c02ccf91 T xfrm4_output
+c02ccff4 t xfrm_gen_index
+c02cd049 t __xfrm_policy_unlink
+c02cd09f T xfrm_dst_ifdown
+c02cd0c9 t xfrm_link_failure
+c02cd0ca t unused_bundle
+c02cd0d8 T xfrm_spd_getinfo
+c02cd12f t prune_one_bundle
+c02cd186 t xfrm_prune_bundles
+c02cd255 t xfrm_dev_event
+c02cd273 t __xfrm_garbage_collect
+c02cd27d t xfrm_policy_unlock_afinfo
+c02cd287 t xfrm_policy_lock_afinfo
+c02cd2b6 T xfrm_unregister_mode
+c02cd2fe T xfrm_register_mode
+c02cd343 T xfrm_unregister_type
+c02cd37d T xfrm_register_type
+c02cd3b4 T xfrm_policy_unregister_afinfo
+c02cd436 T xfrm_policy_register_afinfo
+c02cd4d5 t xfrm_negative_advice
+c02cd528 t policy_hash_bysel
+c02cd59c T xfrm_selector_match
+c02cd820 T xfrm_bundle_ok
+c02cda2b t stale_bundle
+c02cda53 t xfrm_dst_check
+c02cda6c t xfrm_sk_policy_lookup
+c02cdab0 t xfrm_policy_match
+c02cdae4 t xfrm_policy_put_afinfo
+c02cdaee t xfrm_policy_get_afinfo
+c02cdb1f T xfrm_decode_session
+c02cdb50 T xfrm_dst_lookup
+c02cdb8f t xfrm_tmpl_resolve
+c02cde64 T __xfrm_policy_destroy
+c02cde99 T __xfrm_lookup
+c02ce345 T xfrm_lookup
+c02ce3af T __xfrm_route_forward
+c02ce3ec t xfrm_policy_gc_task
+c02ce48b t __xfrm_policy_link
+c02ce518 t xfrm_policy_kill
+c02ce5b5 T xfrm_policy_delete
+c02ce5fb T xfrm_policy_alloc
+c02ce664 t clone_policy
+c02ce74f T __xfrm_sk_clone_policy
+c02ce7a5 T xfrm_put_mode
+c02ce7ad T xfrm_put_type
+c02ce7b5 T xfrm_get_mode
+c02ce839 T xfrm_policy_walk
+c02ce9a0 T xfrm_policy_byid
+c02ceaa1 T xfrm_policy_flush
+c02cec29 T xfrm_sk_policy_insert
+c02cecad T xfrm_init_pmtu
+c02cece7 t xfrm_hash_resize
+c02cef10 T xfrm_policy_insert
+c02cf24a T xfrm_policy_bysel_ctx
+c02cf34f t xfrm_policy_lookup
+c02cf4e9 T xfrm_get_type
+c02cf574 T __xfrm_policy_check
+c02cfa22 t xfrm_policy_timer
+c02cfc0c t __xfrm_find_acq_byseq
+c02cfc5c t xfrm_state_pernet_init
+c02cfc7d T xfrm_state_mtu
+c02cfcc7 T xfrm_get_acqseq
+c02cfcfd T xfrm_find_acq_byseq
+c02cfd21 T xfrm_sad_getinfo
+c02cfd50 t xfrm_state_gc_task
+c02cfe28 T xfrm_state_put_afinfo
+c02cfe32 T xfrm_state_get_afinfo
+c02cfe63 T xfrm_init_state
+c02cfefb T km_query
+c02cff60 T km_state_notify
+c02cffa3 T km_state_expired
+c02cffe6 T km_policy_notify
+c02d0035 T km_policy_expired
+c02d007c T xfrm_state_unregister_afinfo
+c02d00d2 T xfrm_state_register_afinfo
+c02d011c T xfrm_unregister_km
+c02d013e T xfrm_register_km
+c02d016b t __xfrm_state_lookup_byaddr
+c02d025f T xfrm_state_lookup_byaddr
+c02d029e t __xfrm_state_lookup
+c02d0364 T xfrm_state_lookup
+c02d03a3 T xfrm_user_policy
+c02d0498 T xfrm_replay_notify
+c02d056b T xfrm_replay_advance
+c02d05e5 T xfrm_state_check_expire
+c02d06bf t xfrm_hash_grow_check
+c02d06e7 t __xfrm_state_insert
+c02d0886 t xfrm_hash_resize
+c02d0ae0 T xfrm_state_check
+c02d0b33 t __xfrm_state_bump_genids
+c02d0c1e T xfrm_state_insert
+c02d0c44 T __xfrm_state_delete
+c02d0ce3 T xfrm_state_delete
+c02d0d06 t xfrm_timer_handler
+c02d0ee4 T __xfrm_state_destroy
+c02d0f54 T xfrm_state_delete_tunnel
+c02d0f98 T xfrm_state_alloc
+c02d10b1 t __find_acq_core
+c02d13d3 T xfrm_find_acq
+c02d1431 T xfrm_replay_check
+c02d148f T xfrm_state_walk
+c02d1547 T km_new_mapping
+c02d15aa T km_migrate
+c02d1624 T km_report
+c02d168b t xfrm_replay_timer_handler
+c02d16d7 T xfrm_state_flush
+c02d17a5 T xfrm_state_find
+c02d1c67 T xfrm_state_add
+c02d1dea T xfrm_state_update
+c02d1fdf T xfrm_alloc_spi
+c02d2134 T xfrm_hash_free
+c02d2162 T xfrm_hash_alloc
+c02d21d8 T secpath_dup
+c02d222a T __secpath_destroy
+c02d225c T xfrm_parse_spi
+c02d2330 t xfrm_alg_id_match
+c02d233d T xfrm_count_auth_supported
+c02d235b T xfrm_count_enc_supported
+c02d2379 T skb_icv_walk
+c02d255c t xfrm_find_algo
+c02d25bf T xfrm_calg_get_byname
+c02d25d8 T xfrm_ealg_get_byname
+c02d25f1 T xfrm_aalg_get_byname
+c02d260a T xfrm_calg_get_byid
+c02d2627 T xfrm_ealg_get_byid
+c02d2644 T xfrm_aalg_get_byid
+c02d2661 t xfrm_alg_name_match
+c02d26b8 T xfrm_aalg_get_byidx
+c02d26cb T xfrm_ealg_get_byidx
+c02d26de T xfrm_probe_algs
+c02d27dc t unix_poll
+c02d2873 t unix_net_exit
+c02d2889 t unix_seq_release
+c02d28b6 t unix_seq_show
+c02d29d5 t unix_seq_stop
+c02d29df t unix_ioctl
+c02d2a8e t unix_peer_get
+c02d2ab9 t unix_seq_start
+c02d2bc9 t unix_state_double_unlock
+c02d2bf1 t unix_state_double_lock
+c02d2c2d t __unix_insert_socket
+c02d2c7e t unix_copy_addr
+c02d2cba t unix_seq_open
+c02d2d1c t unix_net_init
+c02d2d4e t unix_detach_fds
+c02d2d84 t unix_mkname
+c02d2df8 t __unix_find_socket_byname
+c02d2e69 t __unix_remove_socket
+c02d2ec3 t unix_autobind
+c02d300d t unix_attach_fds
+c02d3041 t unix_dgram_disconnected
+c02d309e t unix_wait_for_peer
+c02d3138 t unix_find_other
+c02d32cb t unix_dgram_sendmsg
+c02d3712 t unix_stream_recvmsg
+c02d3b7e t unix_accept
+c02d3c59 t unix_release_sock
+c02d3e33 t unix_release
+c02d3e4d t unix_create1
+c02d3f47 t unix_create
+c02d3fae t unix_listen
+c02d4076 t unix_socketpair
+c02d40fe t unix_seq_next
+c02d422e t unix_seqpacket_sendmsg
+c02d4289 t unix_sock_destructor
+c02d4361 t unix_bind
+c02d45f1 t unix_dgram_recvmsg
+c02d47b4 t unix_destruct_fds
+c02d47ec t unix_stream_sendmsg
+c02d4ae3 t unix_dgram_connect
+c02d4c4d t unix_stream_connect
+c02d4fc4 t unix_getname
+c02d5052 t unix_write_space
+c02d50c9 t unix_shutdown
+c02d5204 t unix_get_socket
+c02d5233 t maybe_unmark_and_push
+c02d5254 T unix_inflight
+c02d526c T unix_notinflight
+c02d5284 T unix_gc
+c02d5678 T unix_sysctl_unregister
+c02d5692 T unix_sysctl_register
+c02d56f4 T ipv6_opt_accepted
+c02d5759 t cleanup_ipv6_mibs
+c02d5781 T inet6_register_protosw
+c02d5810 T inet6_unregister_protosw
+c02d5861 T inet6_ioctl
+c02d58fe T inet6_release
+c02d5928 t inet6_create
+c02d5c2d T inet6_destroy_sock
+c02d5c67 T inet6_getname
+c02d5d2c T inet6_sk_rebuild_header
+c02d5e7c T inet6_bind
+c02d61d8 T ac6_proc_exit
+c02d61e8 t ac6_get_next
+c02d6279 t ac6_seq_next
+c02d628a t ipv6_chk_acast_dev
+c02d6308 t ac6_seq_stop
+c02d633b t ac6_seq_start
+c02d6415 T ipv6_chk_acast_addr
+c02d6470 t ac6_seq_open
+c02d64b9 t aca_put
+c02d6532 T __ipv6_dev_ac_dec
+c02d665d t ipv6_dev_ac_dec
+c02d6692 T ipv6_dev_ac_inc
+c02d685d t ac6_seq_show
+c02d696e T ipv6_sock_ac_close
+c02d69fe T ipv6_sock_ac_drop
+c02d6aba T ipv6_sock_ac_join
+c02d6d44 t dst_output
+c02d6d4b t ip6_forward_finish
+c02d6d52 T ip6_find_1stfragopt
+c02d6db8 t ip6_output_finish
+c02d6eab t ip6_dst_lookup_tail
+c02d6f54 T ip6_dst_lookup
+c02d6f5f t ip6_copy_metadata
+c02d7050 t ip6_dev_loopback_xmit
+c02d70cd t ip6_output2
+c02d73c3 T ip6_flush_pending_frames
+c02d74f1 T ip6_output
+c02d8007 T ip6_sk_dst_lookup
+c02d8110 T ip6_push_pending_frames
+c02d8518 T ip6_xmit
+c02d88f0 T ip6_forward
+c02d8fce T ip6_nd_hdr
+c02d906a T ip6_append_data
+c02d9acc T ip6_input
+c02d9df6 T ip6_mc_input
+c02d9e65 t ip6_input_finish
+c02da141 T ip6_rcv_finish
+c02da162 T ipv6_rcv
+c02da454 t ipv6_generate_eui64
+c02da533 t if6_get_next
+c02da551 t if6_seq_next
+c02da562 t put_ifaddrmsg
+c02da580 t addrconf_del_timer
+c02da595 t put_cacheinfo
+c02da611 t inet6_fill_ifaddr
+c02da7ac t addrconf_join_anycast
+c02da824 t addrconf_leave_anycast
+c02da89a t addrconf_mod_timer
+c02da8f3 t in6_dev_finish_destroy_rcu
+c02da8fd T addrconf_join_solict
+c02da938 t ipv6_add_addr
+c02dab77 t addrconf_add_mroute
+c02dabdf t addrconf_prefix_route
+c02dac5a t addrconf_add_lroute
+c02daca0 t if6_seq_start
+c02dacf6 t if6_seq_stop
+c02dad00 T ipv6_get_ifaddr
+c02dad8e T ipv6_get_lladdr
+c02dadee t addrconf_dad_kick
+c02dae31 t addrconf_sysctl_register
+c02daf0b t dev_forward_change
+c02daf8e t addrconf_forward_change
+c02daff2 t addrconf_sysctl_forward_strategy
+c02db0f4 t addrconf_sysctl_forward
+c02db17c t addrconf_sysctl_unregister
+c02db1a7 t extract_addr
+c02db1d4 t snmp6_fill_stats
+c02db29e t inet6_fill_ifinfo
+c02db655 T inet6_ifinfo_notify
+c02db72a T unregister_inet6addr_notifier
+c02db736 T register_inet6addr_notifier
+c02db742 t if6_seq_open
+c02db78b T addrconf_leave_solict
+c02db7c8 t __ipv6_ifa_notify
+c02db93b t ipv6_ifa_notify
+c02db95f t addrconf_dad_completed
+c02dba04 T in6_dev_finish_destroy
+c02dbaaf t inet6_dump_addr
+c02dc0d5 t inet6_dump_ifacaddr
+c02dc0f5 t inet6_dump_ifmcaddr
+c02dc115 t inet6_dump_ifaddr
+c02dc132 T inet6_ifa_finish_destroy
+c02dc226 t addrconf_ifdown
+c02dc440 T ipv6_dev_get_saddr
+c02dca53 T ipv6_get_saddr
+c02dca78 t ipv6_del_addr
+c02dcd89 t addrconf_verify
+c02dcf20 t inet6_addr_del
+c02dcfc5 T addrconf_del_ifaddr
+c02dd016 t addrconf_dad_stop
+c02dd05a t addrconf_dad_start
+c02dd11b t addrconf_add_linklocal
+c02dd181 T addrconf_dad_failure
+c02dd1af t inet6_rtm_getaddr
+c02dd307 t ipv6_add_dev
+c02dd50d t ipv6_find_idev
+c02dd574 t addrconf_add_dev
+c02dd5cd t inet6_addr_add
+c02dd746 T addrconf_add_ifaddr
+c02dd7b2 T addrconf_set_dstaddr
+c02dd8ad t if6_seq_show
+c02dda6a T ipv6_chk_addr
+c02ddafd t inet6_dump_ifinfo
+c02ddbef t addrconf_notify
+c02de37f T ipv6_rcv_saddr_equal
+c02de621 T if6_proc_exit
+c02de631 t inet6_rtm_deladdr
+c02de699 t addrconf_rs_timer
+c02de776 t addrconf_dad_timer
+c02de853 t inet6_rtm_newaddr
+c02dea6b T addrconf_prefix_rcv
+c02df074 t ip6_rt_blackhole_update_pmtu
+c02df075 t ip6_dst_check
+c02df08b t fib6_ifdown
+c02df0a3 t ipv6_get_mtu
+c02df0d3 T ipv6_get_hoplimit
+c02df104 t ipv6_sysctl_rtcache_flush
+c02df14b t ip6_dst_gc
+c02df1c7 t ip6_blackhole_output
+c02df1cf t ip6_pkt_discard_out
+c02df26c t rt6_stats_seq_open
+c02df27a t rt6_stats_seq_show
+c02df2d9 t rt6_fill_node
+c02df61f T rt6_dump_route
+c02df689 t rtm_to_fib6_config
+c02df7d1 t find_match
+c02df89c t rt6_select
+c02df96d T rt6_get_dflt_router
+c02dfa00 t __ip6_del_rt
+c02dfa7c t ip6_route_del
+c02dfb54 t inet6_rtm_delroute
+c02dfb8c T ip6_del_rt
+c02dfbb3 T rt6_purge_dflt_routers
+c02dfc10 t rt6_proc_info
+c02dfca2 T rt6_mtu_change
+c02dfcbd T rt6_ifdown
+c02dfccb t ip6_rt_copy
+c02dfd88 t rt6_alloc_cow
+c02dfe5c T ip6_route_output
+c02dfe96 T ip6_route_input
+c02dff23 T rt6_lookup
+c02dffcc t __ip6_ins_rt
+c02e0000 T ip6_route_add
+c02e055e t inet6_rtm_newroute
+c02e0596 T ipv6_route_ioctl
+c02e06ac T ip6_ins_rt
+c02e06d3 t rt6_info_route
+c02e09e7 t ip6_rt_update_pmtu
+c02e0a24 t rt6_mtu_change_route
+c02e0a86 t ip6_pol_route_lookup
+c02e0b57 t __ip6_route_redirect
+c02e0c1b t ip6_link_failure
+c02e0c9c T rt6_pmtu_discovery
+c02e0e28 T inet6_rt_notify
+c02e0f62 T rt6_add_dflt_router
+c02e0fcc t inet6_rtm_getroute
+c02e1187 T addrconf_dst_alloc
+c02e12e9 t ip6_pol_route_input
+c02e1493 t ip6_pol_route_output
+c02e163d t ip6_negative_advice
+c02e1697 T rt6_redirect
+c02e18ab t ip6_dst_destroy
+c02e18d2 t ip6_dst_ifdown
+c02e190f t ip6_pkt_discard
+c02e1a2c T ip6_route_cleanup
+c02e1a67 T ndisc_dst_alloc
+c02e1b71 T ip6_dst_blackhole
+c02e1ca6 T ndisc_dst_gc
+c02e1d14 T fib6_get_table
+c02e1d1a T fib6_rule_lookup
+c02e1d2a t fib6_find_prefix
+c02e1d4e t fib6_prune_clone
+c02e1d61 t fib6_age
+c02e1dc0 T fib6_gc_cleanup
+c02e1dd4 t fib6_walk_continue
+c02e1eb5 t fib6_walk
+c02e1f23 t fib6_clean_tree
+c02e1f4d t fib6_prune_clones
+c02e1f64 T fib6_clean_all
+c02e1fb0 t fib6_dump_end
+c02e1fd5 t inet6_dump_fib
+c02e21a4 t fib6_dump_done
+c02e21bb t fib6_dump_node
+c02e221f T fib6_force_start_gc
+c02e223f T fib6_run_gc
+c02e22f8 T fib6_del
+c02e270d t fib6_clean_node
+c02e27a5 T fib6_locate
+c02e284a T fib6_lookup
+c02e293b T fib6_add
+c02e2dea T fib6_new_table
+c02e2df0 T ipv6_packet_cleanup
+c02e2dfa t ipv6_gso_pull_exthdrs
+c02e2e99 T ipv6_getsockopt
+c02e34d7 T ip6_ra_control
+c02e35ca t ipv6_gso_segment
+c02e36ad t ipv6_gso_send_check
+c02e372b T ipv6_setsockopt
+c02e4268 t dst_output
+c02e426f t ndisc_parse_options
+c02e42e7 t ndisc_hash
+c02e436c t ndisc_error_report
+c02e4390 t ndisc_warn_deprecated_sysctl
+c02e4416 T ndisc_mc_map
+c02e4595 t ndisc_fill_addr_option
+c02e464a t __ndisc_send
+c02e4b30 T ndisc_send_rs
+c02e4b80 t ndisc_send_na
+c02e4c75 t ndisc_recv_ns
+c02e50e0 t pndisc_redo
+c02e50f0 T ndisc_cleanup
+c02e5123 t ndisc_netdev_event
+c02e515e t ndisc_ifinfo_sysctl_strategy
+c02e526d T ndisc_send_ns
+c02e52ed T ndisc_rcv
+c02e5d86 t ndisc_solicit
+c02e5f45 t pndisc_constructor
+c02e5f8e t pndisc_destructor
+c02e5fce t ndisc_constructor
+c02e6130 T ndisc_send_redirect
+c02e677e T ndisc_ifinfo_sysctl_change
+c02e68ac t udp_lib_hash
+c02e68b0 t udp_v6_get_port
+c02e68bd t udp_lib_close
+c02e68c2 T udp6_proc_exit
+c02e68d1 T udp6_seq_show
+c02e6a2b T udpv6_getsockopt
+c02e6a6c T udpv6_setsockopt
+c02e6ab6 t udp_v6_push_pending_frames
+c02e6c89 t udp_v6_flush_pending_frames
+c02e6cab T udpv6_destroy_sock
+c02e6cce t udplite_getfrag
+c02e6cdb t __udp6_lib_lookup
+c02e6ef8 t udp_v6_mcast_next
+c02e7023 T udpv6_queue_rcv_skb
+c02e71cd T __udp6_lib_rcv
+c02e76f6 t udpv6_rcv
+c02e7705 T __udp6_lib_err
+c02e77d7 t udpv6_err
+c02e7804 t udp_lib_unhash
+c02e788c T udpv6_recvmsg
+c02e7ae8 T udpv6_sendmsg
+c02e83cc t udp_lib_hash
+c02e83d0 t udplite_sk_init
+c02e83da t udplite_v6_get_port
+c02e83e7 t udp_lib_unhash
+c02e846f t udp_lib_close
+c02e8474 T udplite6_proc_exit
+c02e8483 t udplitev6_err
+c02e84b0 t udplitev6_rcv
+c02e84c0 t dst_output
+c02e84c7 t rawv6_init_sk
+c02e850a t raw6_get_first
+c02e8549 t raw6_get_next
+c02e8580 t raw6_seq_next
+c02e859d t raw_v6_unhash
+c02e861c t rawv6_rcv_skb
+c02e865f t rawv6_ioctl
+c02e86cf T raw6_proc_exit
+c02e86df t raw6_seq_show
+c02e880f t raw6_seq_stop
+c02e8819 t raw6_seq_start
+c02e886e t raw6_seq_open
+c02e88b7 T rawv6_rcv
+c02e8a86 T __raw_v6_lookup
+c02e8b90 t raw_v6_hash
+c02e8bf2 t rawv6_setsockopt
+c02e8cbf t rawv6_getsockopt
+c02e8dcf t rawv6_close
+c02e8def T ipv6_raw_deliver
+c02e8f69 T rawv6_err
+c02e901c t rawv6_sendmsg
+c02e9b98 t rawv6_recvmsg
+c02e9d7c t rawv6_bind
+c02e9ea4 T inet6_add_protocol
+c02e9edc T inet6_del_protocol
+c02e9f1c T icmpv6_err_convert
+c02e9f73 T icmpv6_cleanup
+c02e9fb7 t icmpv6_push_pending_frames
+c02ea0bb t icmpv6_getfrag
+c02ea132 t icmpv6_notify
+c02ea29d T icmpv6_send
+c02ea938 T icmpv6_param_prob
+c02ea960 t icmpv6_rcv
+c02eb214 t is_in
+c02eb2d3 t sf_markstate
+c02eb309 t ip6_mc_clear_src
+c02eb357 t ip6_mc_del1_src
+c02eb430 t mld_clear_zeros
+c02eb460 t igmp6_mcf_get_next
+c02eb520 t igmp6_mcf_seq_next
+c02eb5f4 t igmp6_mc_get_next
+c02eb685 t igmp6_mc_seq_next
+c02eb696 t ma_put
+c02eb6c3 t igmp6_mcf_seq_stop
+c02eb719 t igmp6_mcf_seq_start
+c02eb82c t igmp6_mc_seq_start
+c02eb906 t igmp6_mcf_seq_open
+c02eb94f t mld_clear_delrec
+c02eb9eb t mld_newpack
+c02ebb61 t add_grhead
+c02ebc0b t igmp6_send
+c02ec24f t mld_sendpack
+c02ec5c1 t add_grec
+c02ec94b t mld_send_report
+c02eca01 t mld_dev_queue_xmit
+c02ecabe t mld_dev_queue_xmit2
+c02ecb31 t igmp6_group_queried
+c02ecbc0 t mld_ifc_start_timer
+c02ecbee t mld_ifc_event
+c02ecc22 t igmp6_group_dropped
+c02ecdbc T ipv6_mc_down
+c02ece17 T __ipv6_dev_mc_dec
+c02ece9a T ipv6_mc_destroy_dev
+c02ecf3c t mld_ifc_timer_expire
+c02ed131 T ipv6_mc_init_dev
+c02ed19f t igmp6_group_added
+c02ed2bc T ipv6_mc_up
+c02ed2e6 t igmp6_timer_handler
+c02ed351 t sf_setstate
+c02ed49a t ip6_mc_add_src
+c02ed6a2 T ipv6_dev_mc_inc
+c02ed97f t ip6_mc_del_src
+c02edafc t ip6_mc_find_dev
+c02edbc0 t ip6_mc_leave_src
+c02edc3c T ipv6_sock_mc_drop
+c02edd4f t igmp6_mc_seq_show
+c02ede98 t igmp6_mcf_seq_show
+c02ee140 t mld_gq_timer_expire
+c02ee154 T inet6_mc_check
+c02ee24b T ipv6_sock_mc_join
+c02ee418 T igmp6_cleanup
+c02ee44c T ipv6_sock_mc_close
+c02ee515 T ip6_mc_source
+c02ee8d2 T ip6_mc_msfilter
+c02eeb8e T ip6_mc_msfget
+c02eed36 T ipv6_dev_mc_dec
+c02eed6b T ipv6_chk_mcast_addr
+c02eeea2 T igmp6_event_report
+c02eefbc t igmp6_mc_seq_stop
+c02eeffc t igmp6_mc_seq_open
+c02ef045 T ipv6_is_mld
+c02ef097 T igmp6_event_query
+c02ef574 t ip6qhashfn
+c02ef6d3 t ip6_frag_destroy
+c02ef783 t ip6_frag_secret_rebuild
+c02ef82d t ipv6_frag_rcv
+c02f06c4 t ip6_frag_expire
+c02f0814 t tcp_v6_remember_stamp
+c02f0817 t tcp_v6_send_ack
+c02f0a79 t tcp_v6_send_reset
+c02f0ce4 t tcp_v6_send_synack
+c02f0f68 t tcp_v6_get_port
+c02f0f83 t tcp_v6_do_rcv
+c02f1308 t tcp_v6_destroy_sock
+c02f1318 t tcp_v6_init_sock
+c02f1459 T tcp6_proc_exit
+c02f1468 t tcp6_seq_show
+c02f1993 t tcp_v6_hash
+c02f19cc t tcp_v6_reqsk_send_ack
+c02f19f7 t tcp_v6_reqsk_destructor
+c02f1a09 t tcp_v6_conn_request
+c02f1cb9 t tcp_v6_syn_recv_sock
+c02f21dd t tcp_v6_send_check
+c02f22b9 t tcp_v6_connect
+c02f28b1 t tcp_v6_gso_send_check
+c02f2960 t tcp_v6_err
+c02f2d80 t tcp_v6_rcv
+c02f34e0 T ipv6_fixup_options
+c02f352c t ipv6_renew_option
+c02f35b1 t ipv6_push_exthdr
+c02f3628 T ipv6_push_frag_opts
+c02f364b T ipv6_push_nfrag_opts
+c02f375a t ipv6_nodata_rcv
+c02f3764 t ip6_parse_tlv
+c02f386c T ipv6_dup_options
+c02f38c9 T ipv6_invert_rthdr
+c02f3988 T ipv6_renew_options
+c02f3bec T ipv6_find_tlv
+c02f3c52 t ipv6_hop_ra
+c02f3ca6 t ipv6_hop_jumbo
+c02f3e8b t ipv6_destopt_rcv
+c02f4044 T ipv6_parse_hopopts
+c02f40e8 t ipv6_rthdr_rcv
+c02f45e0 T ipv6_sysctl_unregister
+c02f45ea T ipv6_sysctl_register
+c02f45fc T datagram_recv_ctl
+c02f4994 T datagram_send_ctl
+c02f4da7 T ipv6_local_error
+c02f4f0e T ip6_datagram_connect
+c02f5322 T ipv6_recv_error
+c02f55cf T ipv6_icmp_error
+c02f56e8 T fl6_merge_options
+c02f5750 t ip6fl_get_first
+c02f5775 t ip6fl_get_next
+c02f5795 t ip6fl_seq_next
+c02f57b2 t fl_free
+c02f57c9 t ip6_fl_gc
+c02f5875 T ip6_flowlabel_cleanup
+c02f588f t ip6fl_seq_stop
+c02f5899 t ip6fl_seq_start
+c02f58ee t fl_lookup
+c02f592e t ip6fl_seq_open
+c02f5977 T ip6_flowlabel_init
+c02f5998 t check_linger
+c02f59c4 t fl6_renew
+c02f5a15 t ipv6_hdr_cmp
+c02f5a48 t fl_release
+c02f5abc T ipv6_flowlabel_opt
+c02f614a t ip6fl_seq_show
+c02f6306 T fl6_sock_lookup
+c02f6338 T fl6_free_socklist
+c02f6360 t inet6_synq_hash
+c02f6455 T inet6_csk_reqsk_queue_hash_add
+c02f64f9 T inet6_csk_bind_conflict
+c02f6551 T inet6_csk_addr2sockaddr
+c02f65a4 T inet6_csk_xmit
+c02f6773 T inet6_csk_search_req
+c02f6868 t xfrm6_garbage_collect
+c02f6882 t xfrm6_update_pmtu
+c02f688f T xfrm6_fini
+c02f689e t xfrm6_dst_ifdown
+c02f690b t xfrm6_dst_lookup
+c02f696a t __xfrm6_bundle_create
+c02f6e07 t xfrm6_dst_destroy
+c02f6e91 t xfrm6_get_saddr
+c02f6f34 t _decode_session6
+c02f70cb t __xfrm6_find_bundle
+c02f7278 T xfrm6_state_fini
+c02f7282 t __xfrm6_tmpl_sort
+c02f72f4 t __xfrm6_state_sort
+c02f73a0 t __xfrm6_init_tempsel
+c02f74c0 T xfrm6_rcv_spi
+c02f786d T xfrm6_rcv
+c02f7876 T xfrm6_input_addr
+c02f79e0 t dst_output
+c02f79e7 t xfrm6_output_finish2
+c02f7c88 t xfrm6_output_finish
+c02f7d02 T xfrm6_output
+c02f7d5b T xfrm6_find_1stfragopt
+c02f7d64 T ipv6_netfilter_fini
+c02f7d6e T ip6_route_me_harder
+c02f7f31 t nf_ip6_saveroute
+c02f7f66 t nf_ip6_reroute
+c02f7fd5 T nf_ip6_checksum
+c02f8120 T snmp6_unregister_dev
+c02f815d t snmp6_seq_open
+c02f8173 t sockstat6_seq_open
+c02f8181 t fold_prot_inuse
+c02f81b9 t sockstat6_seq_show
+c02f8260 T snmp6_register_dev
+c02f82ac T ipv6_misc_proc_exit
+c02f82dc t snmp6_seq_show
+c02f84a0 t xfrm6_transport_input
+c02f84ff t xfrm6_transport_output
+c02f8578 t xfrm6_tunnel_input
+c02f8706 t xfrm6_tunnel_output
+c02f883c t xfrm6_beet_input
+c02f8918 t xfrm6_beet_output
+c02f89c0 t dst_output
+c02f89c7 t ipip6_tunnel_lookup
+c02f8a75 t __ipip6_bucket
+c02f8ab6 t ipip6_tunnel_change_mtu
+c02f8ad7 t ipip6_tunnel_setup
+c02f8b45 t ipip6_tunnel_link
+c02f8b72 t ipip6_tunnel_unlink
+c02f8bac t ipip6_tunnel_locate
+c02f8c9f t ipip6_tunnel_ioctl
+c02f8f11 t ipip6_tunnel_get_stats
+c02f8f17 t ipip6_tunnel_init
+c02f9064 t ipip6_tunnel_uninit
+c02f90a3 t ipip6_err
+c02f9141 t ipip6_rcv
+c02f92db t ipip6_tunnel_xmit
+c02f9910 T __ipv6_addr_type
+c02f99c8 T ipv6_ext_hdr
+c02f99f1 T ipv6_skip_exthdr
+c02f9b00 t __inet6_check_established
+c02f9e99 T inet6_lookup_listener
+c02fa02c T __inet6_lookup_established
+c02fa218 T __inet6_hash
+c02fa34c T inet6_lookup
+c02fa3d1 T inet6_hash_connect
+c02fa694 t packet_seq_next
+c02fa6b9 t packet_seq_start
+c02fa70d t packet_seq_stop
+c02fa71a t packet_dev_mc
+c02fa777 t packet_net_exit
+c02fa784 t packet_seq_release
+c02fa7af t packet_seq_open
+c02fa7e1 t packet_seq_show
+c02fa87b t packet_net_init
+c02fa8c2 t packet_do_bind
+c02fa99f t free_pg_vec
+c02fa9cb t packet_set_ring
+c02faca5 t packet_ioctl
+c02fad78 t tpacket_rcv
+c02fb15b t packet_sendmsg
+c02fb39a t packet_release
+c02fb50d t packet_bind_spkt
+c02fb561 t packet_bind
+c02fb5c3 t packet_create
+c02fb746 t packet_recvmsg
+c02fb8d4 t packet_getname_spkt
+c02fb93a t packet_getname
+c02fb9d4 t packet_setsockopt
+c02fbcd6 t packet_getsockopt
+c02fbdd9 t packet_notifier
+c02fbf2d t packet_poll
+c02fbf8f t packet_mm_open
+c02fbfa7 t packet_mm_close
+c02fbfbf t packet_mmap
+c02fc0ac t packet_sock_destruct
+c02fc134 t packet_sendmsg_spkt
+c02fc2ea t packet_rcv
+c02fc607 t packet_rcv_spkt
+c02fc744 t get_wireless_stats
+c02fc75b t call_commit_handler
+c02fc78f t wireless_nlevent_process
+c02fc7dd T wireless_send_event
+c02fcad3 t iw_send_thrspy_event
+c02fcb2f T wireless_spy_update
+c02fcc01 t ioctl_standard_call
+c02fcecc T wext_handle_ioctl
+c02fd24a T wext_proc_exit
+c02fd257 t wireless_seq_release
+c02fd282 t wireless_seq_open
+c02fd2b4 t wireless_seq_show
+c02fd3f6 T wext_proc_init
+c02fd41d t iw_handler_get_iwstats
+c02fd456 t iw_handler_get_private
+c02fd4af T iw_handler_set_spy
+c02fd517 T iw_handler_get_spy
+c02fd59e T iw_handler_set_thrspy
+c02fd5d4 T iw_handler_get_thrspy
+c02fd600 T klist_node_attached
+c02fd60a T klist_iter_init_node
+c02fd622 T klist_iter_init
+c02fd629 t klist_dec_and_del
+c02fd636 T klist_next
+c02fd6a3 T klist_del
+c02fd6de T klist_iter_exit
+c02fd6f6 t klist_release
+c02fd712 T klist_remove
+c02fd725 t klist_node_init
+c02fd75b T klist_add_tail
+c02fd78a T klist_add_head
+c02fd7b6 T klist_init
+c02fd7e4 T __down_trylock
+c02fd828 T __up
+c02fd848 T sha_init
+c02fd86b T sha_transform
+c02fda64 t rest_init
+c02fdaa3 t alloc_node_mem_map
+c02fdb2f t zone_wait_table_init
+c02fdbd7 t setup_cpu_cache
+c02fdd00 T __sched_text_start
+c02fdd00 T schedule
+c02fe7d6 T cond_resched_softirq
+c02fe817 T yield
+c02fe82b T wait_for_completion
+c02fe8be T io_schedule_timeout
+c02fe8e6 T sleep_on_timeout
+c02fe959 T io_schedule
+c02fe980 T cond_resched
+c02fe9b1 T wait_for_completion_interruptible_timeout
+c02fea81 T wait_for_completion_timeout
+c02feb30 T wait_for_completion_interruptible
+c02febe2 T interruptible_sleep_on
+c02fec4b T interruptible_sleep_on_timeout
+c02fecbe T sleep_on
+c02fed27 T console_conditional_schedule
+c02fed36 T schedule_timeout
+c02fedc3 T schedule_timeout_uninterruptible
+c02fedd5 T schedule_timeout_interruptible
+c02fede7 T __wait_on_bit_lock
+c02fee39 T out_of_line_wait_on_bit_lock
+c02feea4 T __wait_on_bit
+c02feefc T out_of_line_wait_on_bit
+c02fef67 T mutex_unlock
+c02fef72 T mutex_trylock
+c02fef8e T mutex_lock_interruptible
+c02fefb3 T mutex_lock
+c02fefd7 t __mutex_lock_interruptible_slowpath
+c02ff074 t __mutex_unlock_slowpath
+c02ff0a4 t __mutex_lock_slowpath
+c02ff11b t do_nanosleep
+c02ff187 T hrtimer_nanosleep_restart
+c02ff22f T rt_mutex_unlock
+c02ff251 T rt_mutex_trylock
+c02ff272 T rt_mutex_lock_interruptible
+c02ff2bb t rt_mutex_slowlock
+c02ff701 t rt_mutex_slowunlock
+c02ff89d T rt_mutex_lock
+c02ff8dc T rwsem_down_write_failed
+c02ff8fb T rwsem_down_read_failed
+c02ff91c T __down_failed
+c02ff928 T __down_failed_interruptible
+c02ff934 T __down_failed_trylock
+c02ff940 T __up_wakeup
+c02ff94c T __write_lock_failed
+c02ff968 T __read_lock_failed
+c02ff978 T call_rwsem_down_read_failed
+c02ff984 T call_rwsem_down_write_failed
+c02ff98c T call_rwsem_wake
+c02ff998 T call_rwsem_downgrade_wake
+c02ff9a2 T __down_interruptible
+c02ffa92 T __down
+c02ffb4a T __sched_text_end
+c02ffb50 T __lock_text_start
+c02ffb50 T _spin_trylock
+c02ffb5e T _spin_trylock_bh
+c02ffb85 T _write_unlock_bh
+c02ffb92 T _write_unlock_irq
+c02ffb99 T _write_unlock
+c02ffb9e T _read_unlock_bh
+c02ffbab T _read_unlock
+c02ffbb0 T _spin_unlock_bh
+c02ffbbd T _spin_unlock
+c02ffbc2 T _write_lock
+c02ffbc7 T _write_lock_bh
+c02ffbd7 T _write_lock_irq
+c02ffbdd T _write_lock_irqsave
+c02ffbea T _spin_lock
+c02ffbef T _spin_lock_bh
+c02ffbff T _read_lock_bh
+c02ffc0f T _read_lock
+c02ffc14 T _write_trylock
+c02ffc22 T _read_trylock
+c02ffc30 T _write_unlock_irqrestore
+c02ffc3c T _spin_lock_irq
+c02ffc42 T _read_lock_irq
+c02ffc48 T _spin_unlock_irq
+c02ffc4f T _read_unlock_irq
+c02ffc56 T _spin_lock_irqsave
+c02ffc63 T _read_lock_irqsave
+c02ffc70 T _spin_unlock_irqrestore
+c02ffc7c T _read_unlock_irqrestore
+c02ffc88 T unlock_kernel
+c02ffcb7 T lock_kernel
+c02ffcef T __release_kernel_lock
+c02ffd04 T __reacquire_kernel_lock
+c02ffd4a T __lock_text_end
+c02ffd50 T __kprobes_text_start
+c02ffd50 T page_fault
+c02ffd58 t error_code
+c02ffdd0 T debug
+c02ffde1 t debug_esp_fix_insn
+c02ffdf0 t debug_stack_correct
+c02ffe1c T nmi
+c02ffe4d t nmi_stack_correct
+c02ffe78 t nmi_stack_fixup
+c02ffe91 t nmi_debug_stack_check
+c02ffec4 t nmi_espfix_stack
+c02fff38 T int3
+c02fff64 T general_protection
+c02fff6e t do_trap
+c030002b T do_int3
+c0300097 T do_general_protection
+c030026d T die_nmi
+c0300345 T do_debug
+c0300418 T do_nmi
+c0300640 T nmi_watchdog_tick
+c03007a5 T arch_arm_kprobe
+c03007ac T arch_disarm_kprobe
+c03007b5 t restore_previous_kprobe
+c03007e7 t set_current_kprobe
+c0300828 t prepare_singlestep
+c0300848 T arch_prepare_kretprobe
+c0300856 T kretprobe_trampoline
+c0300856 T kretprobe_trampoline_holder
+c0300885 T arch_trampoline_kprobe
+c0300888 T kprobe_exceptions_notify
+c0300c1f T arch_remove_kprobe
+c0300c48 T arch_prepare_kprobe
+c0300d9d T longjmp_break_handler
+c0300e70 T trampoline_handler
+c0300fa3 T setjmp_pre_handler
+c030100e T jprobe_return
+c0301022 T jprobe_return_end
+c0301025 T do_page_fault
+c0301621 t notifier_call_chain
+c0301673 T __atomic_notifier_call_chain
+c030167a T atomic_notifier_call_chain
+c0301694 T get_kprobe
+c03016bc t aggr_fault_handler
+c03016ed t aggr_break_handler
+c0301730 T recycle_rp_inst
+c03017a1 T kretprobe_inst_table_head
+c03017b2 t add_new_kprobe
+c0301813 t kprobe_seq_start
+c0301825 t kprobe_seq_next
+c0301846 t kprobe_seq_stop
+c0301847 t debugfs_kprobe_init
+c03018c7 t kprobes_open
+c03018d3 t report_probe
+c0301965 t __register_kprobe
+c0301bce T register_jprobe
+c0301be4 T register_kprobe
+c0301bec T unregister_kprobe
+c0301d58 T unregister_kretprobe
+c0301dd6 T unregister_jprobe
+c0301ddb t collect_one_slot
+c0301e5e t collect_garbage_slots
+c0301eba T free_insn_slot
+c0301f39 T kprobes_inc_nmissed_count
+c0301f62 t show_kprobe_addr
+c0302028 T kprobe_flush_task
+c03020a8 t pre_handler_kretprobe
+c030213d t aggr_pre_handler
+c030219a t aggr_post_handler
+c03021ef T register_kretprobe
+c03022e5 T get_insn_slot
+c03023cd T __kprobes_text_end
+c03026e2 t iret_exc
+c0302fac T _etext
+c0302fb0 R __start___ex_table
+c0303eb8 R __start___bug_table
+c0303eb8 R __stop___ex_table
+c0308058 R __stop___bug_table
+c0308058 ? __tracedata_end
+c0308058 ? __tracedata_start
+c0309000 R __start_rodata
+c0309000 R linux_banner
+c0309080 R linux_proc_banner
+c0309100 r p.13756
+c0309140 r border
+c03091a0 r mask_bits
+c03091e0 r cplens
+c0309220 r cplext
+c0309260 r cpdist
+c03092a0 r cpdext
+c0309300 r p.13560
+c0309340 r border
+c03093a0 r mask_bits
+c03093e0 r cplens
+c0309420 r cplext
+c0309460 r cpdist
+c03094a0 r cpdext
+c03094dc r __func__.4939
+c03094ef r __func__.4978
+c0309520 R sys_call_table
+c0309a3c r __func__.12125
+c0309a47 r __func__.12034
+c0309b78 r noptypes
+c0309b90 r __func__.10528
+c0309bac r __func__.10500
+c0309bc8 r __func__.10418
+c0309be0 r x86_power_flags.8979
+c0309c20 r x86_cap_flags.8978
+c0309ff4 r types
+c0309ff7 r levels
+c030a000 r assocs
+c030a020 r __func__.8816
+c030a040 r mtrr_fops
+c030a0b0 r mtrr_strings
+c030a0e0 r fixed_range_blocks
+c030a100 r ccr_state
+c030a120 r arr_state
+c030a180 r __func__.18534
+c030a19e r __func__.18227
+c030a1b4 r C.254.18943
+c030a1c0 r C.253.18942
+c030a1cc r __func__.7759
+c030a1fc r __func__.23611
+c030a220 r twobyte_is_boostable.15580
+c030a2d8 r C.222.19038
+c030a2e8 r C.221.19036
+c030a2f8 r C.220.19034
+c030a308 r C.219.19032
+c030a318 r C.218.19030
+c030a328 r C.217.19024
+c030a338 r bases.4584
+c030a3a0 R proc_schedstat_operations
+c030a410 r __func__.32894
+c030a428 r __func__.32455
+c030a438 r __func__.32585
+c030a444 r stat_nam
+c030a44c r __func__.29958
+c030a45c r VLA_RSS
+c030a46c r __func__.26988
+c030a4c0 r proc_profile_operations
+c030a530 r __func__.18185
+c030a546 r __func__.29739
+c030a54e r __func__.18405
+c030a55e r __func__.18355
+c030a56f r __func__.18315
+c030a5a0 r proc_ioports_operations
+c030a620 r proc_iomem_operations
+c030a690 r resource_op
+c030a6a0 r __func__.13482
+c030a6b6 r __func__.20656
+c030a708 r __func__.27640
+c030a71c r C.296.24105
+c030a72c r __func__.11247
+c030a74f r __func__.10496
+c030a75c r __func__.10355
+c030a770 r C.182.16234
+c030a780 R space_mask
+c030a788 R vlimit_mask
+c030a794 r VLA_RSS
+c030a7bc r __func__.24911
+c030a7c8 r __func__.30572
+c030a7da r __func__.30505
+c030a7ec r __func__.30536
+c030a800 r type.29492
+c030a818 r VLA_RSS
+c030a89c r __func__.19818
+c030a8c0 r futex_fops
+c030a930 r __func__.19540
+c030a93e r __func__.19990
+c030a94c r __func__.19469
+c030a95c r __func__.19383
+c030a96b r __func__.19863
+c030a980 r __func__.19838
+c030a98e r __func__.19431
+c030a9a1 r __func__.10834
+c030a9b2 r __func__.10582
+c030a9c5 r __func__.10624
+c030a9e0 r proc_dma_operations
+c030aa50 r __func__.14655
+c030aa60 R modules_op
+c030aa80 r vermagic
+c030aac0 r masks.19173
+c030aae0 r modinfo_attrs
+c030ab00 r kallsyms_operations
+c030ab70 r kallsyms_op
+c030ab80 r pm_states
+c030ab90 r subsys
+c030ab98 r __func__.11838
+c030aba1 r __func__.11745
+c030abae r __func__.11715
+c030abb9 r __func__.11721
+c030abc6 r __func__.11701
+c030abda r __func__.11686
+c030abeb r __func__.11556
+c030ac00 R relay_file_operations
+c030ac98 r zone_names
+c030aca4 r __func__.21103
+c030acac r __func__.21016
+c030ad18 R fragmentation_op
+c030ad28 R zoneinfo_op
+c030ad38 R vmstat_op
+c030ad60 r vmstat_text
+c030ae14 r VLA_RSS
+c030ae84 r __func__.24288
+c030ae90 r VLA_RSS
+c030aea0 r __func__.17702
+c030aea9 r __func__.17471
+c030aeb8 r __func__.17384
+c030aee0 r swap_aops
+c030af20 r proc_swaps_operations
+c030af90 r swaps_op
+c030afa0 r Bad_file
+c030afb5 r Unused_offset
+c030afcf r Bad_offset
+c030afe6 r Unused_file
+c030affe r __func__.26545
+c030b020 r shmem_ops
+c030b080 r shmem_aops
+c030b0c0 r shmem_special_inode_operations
+c030b120 r shmem_inode_operations
+c030b180 r shmem_file_operations
+c030b200 r shmem_dir_inode_operations
+c030b260 r shmem_symlink_inline_operations
+c030b2c0 r shmem_symlink_inode_operations
+c030b368 R slabinfo_op
+c030b378 r __func__.19636
+c030b38b r __func__.19420
+c030b3a0 R generic_ro_fops
+c030b420 R def_chr_fops
+c030b4a0 R read_fifo_fops
+c030b520 R write_fifo_fops
+c030b5a0 R rdwr_fifo_fops
+c030b610 r anon_pipe_buf_ops
+c030b640 r read_pipe_fops
+c030b6c0 r write_pipe_fops
+c030b740 r rdwr_pipe_fops
+c030b7e0 R page_symlink_inode_operations
+c030b83c r band_table
+c030b854 r __func__.23953
+c030b860 R def_fifo_fops
+c030b8d0 r anonstring.25567
+c030b8dc r name.25542
+c030b900 r bad_inode_ops
+c030b960 r bad_file_ops
+c030b9d0 r __func__.26069
+c030ba00 R simple_dir_operations
+c030ba80 R simple_dir_inode_operations
+c030bae0 r simple_super_operations
+c030bb34 r __func__.17934
+c030bb46 r __func__.20012
+c030bb60 r user_page_pipe_buf_ops
+c030bb7c r page_cache_pipe_buf_ops
+c030bb98 r __func__.25270
+c030bbb2 r __func__.22237
+c030bbc7 r __func__.23711
+c030bbd9 r __func__.22845
+c030bbf1 r __func__.23536
+c030bc05 r __func__.22944
+c030bc1b r __func__.23097
+c030bc30 r __func__.22517
+c030bc3d r __func__.22560
+c030bc46 r __func__.20691
+c030bc60 R def_blk_aops
+c030bca0 R def_blk_fops
+c030bd20 r bdev_sops
+c030bd80 r revoked_special_file_ops
+c030be00 r revoked_file_ops
+c030be80 r revoked_aops
+c030bebc r __func__.14586
+c030bed3 r __func__.14673
+c030bf00 r inotify_fops
+c030bf70 r inotify_user_ops
+c030bf80 r eventpoll_fops
+c030c000 r signalfd_fops
+c030c080 r eventfd_fops
+c030c100 r s_ops
+c030c160 r bm_entry_operations
+c030c1e0 r bm_status_operations
+c030c260 r bm_register_operations
+c030c2d0 r buf.25804
+c030c2ec r quotatypes
+c030c2f8 r module_names
+c030c310 r quota_versions.11846
+c030c318 r quota_magics.11845
+c030c360 R proc_maps_operations
+c030c3e0 R proc_smaps_operations
+c030c460 R proc_clear_refs_operations
+c030c4e0 R proc_pagemap_operations
+c030c560 r proc_sops
+c030c5c0 r proc_root_inode_operations
+c030c620 r proc_root_operations
+c030c6a0 r proc_base_stuff
+c030c6c0 r proc_tgid_base_inode_operations
+c030c720 r proc_tgid_base_operations
+c030c7a0 r tgid_base_stuff
+c030ca20 r proc_pid_link_inode_operations
+c030ca80 r proc_fdinfo_file_operations
+c030cb00 r proc_tid_base_inode_operations
+c030cb60 r proc_tid_base_operations
+c030cbe0 r tid_base_stuff
+c030ce00 r proc_def_inode_operations
+c030ce60 r proc_self_inode_operations
+c030cec0 r proc_task_inode_operations
+c030cf20 r proc_task_operations
+c030cfa0 r proc_fd_inode_operations
+c030d000 r proc_fd_operations
+c030d080 r proc_fdinfo_inode_operations
+c030d0e0 r proc_fdinfo_operations
+c030d160 r proc_info_file_operations
+c030d1e0 r proc_mem_operations
+c030d260 r proc_mounts_operations
+c030d2e0 r proc_mountstats_operations
+c030d360 r proc_oom_adjust_operations
+c030d3e0 r proc_coredump_filter_operations
+c030d460 r __func__.17467
+c030d480 r proc_dir_operations
+c030d500 r proc_dir_inode_operations
+c030d560 r proc_link_inode_operations
+c030d5c0 r proc_file_operations
+c030d640 r proc_file_inode_operations
+c030d6a0 r proc_tty_drivers_operations
+c030d720 r proc_devinfo_operations
+c030d7a0 r proc_cpuinfo_operations
+c030d820 r proc_partitions_operations
+c030d8a0 r proc_stat_operations
+c030d920 r proc_interrupts_operations
+c030d9a0 r proc_slabinfo_operations
+c030da20 r fragmentation_file_operations
+c030daa0 r proc_vmstat_file_operations
+c030db20 r proc_zoneinfo_file_operations
+c030dba0 r proc_diskstats_operations
+c030dc20 r proc_modules_operations
+c030dca0 r proc_sysrq_trigger_operations
+c030dd20 r proc_sys_file_operations
+c030dda0 r proc_net_dir_operations
+c030de20 R proc_kcore_operations
+c030dea0 R proc_vmcore_operations
+c030df20 R proc_kmsg_operations
+c030dfa0 r block_str.20512
+c030dfa4 r check_part
+c030dfc0 r subtypes
+c030e000 r sysfs_aops
+c030e040 r sysfs_inode_operations
+c030e0a0 R sysfs_file_operations
+c030e110 r __func__.14993
+c030e120 R sysfs_dir_inode_operations
+c030e180 R sysfs_dir_operations
+c030e1f0 r __func__.12013
+c030e1fc r C.128.12158
+c030e220 R sysfs_symlink_inode_operations
+c030e27c r __func__.11934
+c030e2a0 r sysfs_ops
+c030e2f4 r __func__.17687
+c030e320 R bin_fops
+c030e390 r __func__.12175
+c030e39a r __func__.12370
+c030e3b0 r __func__.8338
+c030e3c0 r devpts_sops
+c030e420 r __func__.20488
+c030e430 r __func__.20365
+c030e44e r __func__.20017
+c030e462 r __func__.19950
+c030e480 R ext3_dir_operations
+c030e4f0 r ext3_filetype_table
+c030e500 R ext3_file_operations
+c030e580 R ext3_file_inode_operations
+c030e5dc r __func__.19546
+c030e5eb r __func__.20509
+c030e5fb r __func__.20384
+c030e60a r __func__.20161
+c030e620 r __func__.22661
+c030e63f r __func__.22646
+c030e650 r __func__.22625
+c030e669 r __func__.22385
+c030e67e r __func__.22516
+c030e68b r __func__.22236
+c030e69b r __func__.21994
+c030e6a9 r __func__.20754
+c030e6bb r __func__.21780
+c030e6d4 r __func__.21233
+c030e6e3 r __func__.21928
+c030e6f2 r __func__.21905
+c030e704 r __func__.21947
+c030e720 r ext3_ordered_aops
+c030e760 r ext3_writeback_aops
+c030e7a0 r ext3_journalled_aops
+c030e7dc r __func__.21484
+c030e7f9 r __func__.21398
+c030e809 r __func__.21618
+c030e823 r __func__.21338
+c030e83f r __func__.21449
+c030e85b r __func__.21591
+c030e874 r __func__.21720
+c030e883 r __func__.21687
+c030e894 r __func__.21418
+c030e8ae r __func__.21361
+c030e8c1 r __func__.21557
+c030e8d8 r __func__.21391
+c030e8f0 r __func__.21261
+c030e8fc r __func__.21151
+c030e913 r __func__.21014
+c030e925 r __func__.21087
+c030e938 r __func__.20786
+c030e94a r __func__.20724
+c030e956 r __func__.19512
+c030e980 R ext3_dir_inode_operations
+c030e9e0 R ext3_special_inode_operations
+c030ea3c r __func__.22336
+c030ea48 r __func__.22000
+c030ea52 r __func__.21689
+c030ea64 r __func__.20768
+c030ea6d r __func__.21064
+c030ea7d r __func__.21408
+c030ea86 r __func__.21559
+c030ea97 r __func__.20575
+c030eaa3 r __func__.21483
+c030eab5 r ext3_type_by_mode
+c030eac4 r __func__.21163
+c030ead4 r __func__.21230
+c030eae7 r __func__.21775
+c030eaf9 r __func__.21873
+c030eb04 r __func__.22142
+c030eb0f r __func__.21931
+c030eb1a r __func__.22228
+c030eb27 r __func__.22183
+c030eb33 r __func__.22299
+c030eb3d r __func__.21820
+c030eb49 r __func__.22104
+c030eb59 r __func__.22058
+c030ec40 r ext3_sops
+c030ec94 r __func__.23585
+c030eca4 r __func__.23543
+c030ecb7 r __func__.23509
+c030ecca r __func__.23484
+c030ecdb r __func__.23455
+c030eceb r __func__.23421
+c030ed01 r __func__.23700
+c030ed12 r __func__.23284
+c030ed1f r __func__.23203
+c030ed36 r __func__.21998
+c030ed45 r __func__.22513
+c030ed59 r __func__.21930
+c030ed71 r __func__.21786
+c030eda0 R ext3_symlink_inode_operations
+c030ee00 R ext3_fast_symlink_inode_operations
+c030ee5c r __func__.20099
+c030ee6e r __func__.19933
+c030ee7d r __func__.19992
+c030ee8c r __func__.19449
+c030ee9f r __func__.19574
+c030eeb6 r __func__.19518
+c030eebd r __func__.19832
+c030eed0 r __func__.19691
+c030eee4 r __func__.19730
+c030ef00 r __func__.19486
+c030ef20 r __func__.19477
+c030ef41 r __func__.19468
+c030ef57 r __func__.19458
+c030ef80 r __func__.19449
+c030efa0 r __func__.19440
+c030efc0 r __func__.20928
+c030efd8 r __func__.20438
+c030eff1 r __func__.20909
+c030f000 r __func__.20846
+c030f016 r __func__.20613
+c030f02c r __func__.20652
+c030f041 r __func__.21034
+c030f057 r __func__.20417
+c030f078 r ext3_xattr_handler_map
+c030f094 r __func__.20345
+c030f0aa r __func__.20212
+c030f0bf r __func__.20008
+c030f0d2 r __func__.19903
+c030f148 r __func__.19477
+c030f160 r __func__.19255
+c030f17d r __func__.19419
+c030f193 r __func__.19397
+c030f1aa r __func__.19361
+c030f1bf r __func__.19321
+c030f1db r __func__.19176
+c030f1e8 r __func__.19149
+c030f1f7 r __func__.19112
+c030f20e r __func__.19082
+c030f221 r __func__.19058
+c030f239 r __func__.18962
+c030f24d r __func__.19033
+c030f267 r __func__.18927
+c030f27e r __func__.18893
+c030f28e r __func__.18796
+c030f2a0 r __func__.18772
+c030f2b0 r __func__.18848
+c030f2be r __func__.18900
+c030f2d9 r __func__.18937
+c030f2e5 r __func__.19007
+c030f300 r __func__.18990
+c030f31c r __func__.18925
+c030f331 r __func__.18872
+c030f342 r __func__.18932
+c030f351 r __func__.18906
+c030f368 r __func__.18862
+c030f380 r __func__.20241
+c030f3a0 r __func__.20249
+c030f3c3 r __func__.20338
+c030f3dc r __func__.20315
+c030f3fa r __func__.20287
+c030f413 r __func__.20263
+c030f42e r __func__.20105
+c030f43b r __func__.19712
+c030f452 r __func__.20081
+c030f460 r __func__.19885
+c030f470 r jbd_slab_names
+c030f484 r __func__.19599
+c030f493 r __func__.19517
+c030f4a6 r __func__.19458
+c030f4ba r __func__.19489
+c030f4cb r __func__.19425
+c030f4d8 r __func__.19406
+c030f4ef r __func__.19269
+c030f520 r __func__.19027
+c030f560 R ext2_dir_operations
+c030f5d0 r __func__.18132
+c030f5dd r __func__.18481
+c030f5ec r ext2_type_by_mode
+c030f5fb r __func__.18399
+c030f60d r __func__.18319
+c030f61b r __func__.18212
+c030f640 R ext2_file_operations
+c030f6c0 R ext2_xip_file_operations
+c030f740 R ext2_file_inode_operations
+c030f7a0 R ext2_aops
+c030f7e0 R ext2_aops_xip
+c030f820 R ext2_nobh_aops
+c030f860 R ext2_dir_inode_operations
+c030f8c0 R ext2_special_inode_operations
+c030f9a0 r ext2_sops
+c030f9f4 r __func__.21061
+c030fa04 r __func__.21436
+c030fa11 r __func__.20653
+c030fa40 R ext2_symlink_inode_operations
+c030faa0 R ext2_fast_symlink_inode_operations
+c030fafc r ext2_xattr_handler_map
+c030fb18 r __func__.18778
+c030fb40 r cramfs_ops
+c030fba0 r cramfs_aops
+c030fbe0 r cramfs_dir_inode_operations
+c030fc40 r cramfs_directory_operations
+c030fcc0 r ramfs_ops
+c030fd20 r ramfs_dir_inode_operations
+c030fd80 R ramfs_aops
+c030fdc0 R ramfs_file_operations
+c030fe40 R ramfs_file_inode_operations
+c030ff00 r isofs_sops
+c030ff60 r isofs_aops
+c030ffa0 R isofs_dir_operations
+c0310020 R isofs_dir_inode_operations
+c0310080 r C.220.18441
+c03100c0 R isofs_symlink_aops
+c0310100 R zisofs_aops
+c0310140 r charset2uni
+c0310340 r page_uni2charset
+c0310740 r charset2uni
+c0310940 r page_uni2charset
+c0310d40 r charset2uni
+c0310f40 r page_uni2charset
+c0311340 R debugfs_file_operations
+c03113c0 R debugfs_link_operations
+c0311420 r fops_blob
+c03114a0 r fops_bool
+c0311520 r sysvipc_proc_fops
+c0311620 r shm_file_operations
+c03116a0 r mqueue_file_operations
+c0311720 r mqueue_dir_inode_operations
+c031177c r oflag2acc.28602
+c0311788 r __func__.18913
+c031178f r __func__.18835
+c03117a0 r __func__.20278
+c03117b1 r __func__.20184
+c03117bc r __func__.23248
+c03117d8 r C.355.22660
+c03117e8 r __func__.22637
+c03117fe r __func__.22109
+c031180e r __func__.22034
+c031181e r __func__.22008
+c031182e r __func__.21471
+c0311848 r __func__.21431
+c031185c r __func__.21398
+c031186e r __func__.21300
+c031187b r __func__.21228
+c0311896 r __func__.21149
+c03118b1 r __func__.21140
+c03118cb r __func__.21131
+c03118e7 r __func__.21121
+c03118fd r __func__.21037
+c031190c r __func__.20189
+c031191e R scsi_command_size
+c0311928 r __func__.19529
+c0311937 r __func__.20449
+c0311949 r __func__.20410
+c031195e r __func__.20697
+c0311974 r __func__.20007
+c0311988 r __func__.19836
+c031199f r __func__.19849
+c03119b2 r __func__.20086
+c03119c4 r C.304.21178
+c03119e0 r blk_dropped_fops
+c0311a50 r __func__.7934
+c0311a65 r __func__.7800
+c0311a8c r __func__.7720
+c0311a95 r __func__.7708
+c0311aa0 r __func__.7936
+c0311ac0 r large_digits.7862
+c0311b00 r small_digits.7861
+c0311b40 r __func__.15710
+c0311b4e r __func__.15861
+c0311b5b r __func__.15789
+c0311b6d r __func__.15749
+c0311b7a r __func__.4131
+c0311ba0 R byte_rev_table
+c0311ca0 r crc32table_be
+c03120a0 r crc32table_le
+c0312520 r order.2234
+c0312560 r distfix.2170
+c03125e0 r lenfix.2169
+c0312de0 r dext.2094
+c0312e20 r dbase.2093
+c0312e60 r lext.2092
+c0312ea0 r lbase.2091
+c0312ee0 r __func__.18389
+c0312efc r __func__.16450
+c0312f0c r __func__.16434
+c0312f1f r __func__.16160
+c0312f6c r __func__.18382
+c0312f84 r __func__.18364
+c0312f97 r __func__.18950
+c0312fa8 r __func__.18927
+c0312fb6 r __func__.18898
+c0312fcd r __func__.18852
+c0312fdc r __func__.18805
+c0312fec r __func__.18762
+c0312ff9 r __func__.18730
+c0313020 r proc_bus_pci_dev_operations
+c03130a0 r proc_bus_pci_operations
+c0313120 r __func__.15859
+c0313136 r C.225.15879
+c0313160 r __func__.16197
+c0313173 r device_name
+c03131a0 r port_pci_ids
+c03131e0 r aer_error_severity_string
+c03131ec r aer_error_layer
+c03131f8 r aer_agent_string
+c0313220 r aer_correctable_error_string
+c03132a0 r aer_uncorrectable_error_string
+c0313320 r __func__.22020
+c0313329 r __func__.21963
+c031333c r __func__.18762
+c0313348 r C.229.18734
+c0313358 r __func__.19436
+c0313368 r __func__.19320
+c0313378 r state_conv.19225
+c03133a0 R dummy_con
+c0313440 R vga_con
+c03134e4 r mps_inti_flags_trigger
+c03134f4 r mps_inti_flags_polarity
+c031355c r _acpi_module_name
+c0313560 r _acpi_module_name
+c0313564 r _acpi_module_name
+c03135ac r _acpi_module_name
+c03135c0 r acpi_gbl_op_type_dispatch
+c03135f0 r _acpi_module_name
+c03135f4 r _acpi_module_name
+c03135f8 r _acpi_module_name
+c03135fc r _acpi_module_name
+c031363c r _acpi_module_name
+c0313640 r _acpi_module_name
+c0313644 r _acpi_module_name
+c0313648 r _acpi_module_name
+c031366c r _acpi_module_name
+c0313670 r acpi_gbl_default_address_spaces
+c0313674 r _acpi_module_name
+c0313678 r _acpi_module_name
+c031367c r _acpi_module_name
+c0313680 r _acpi_module_name
+c0313684 r _acpi_module_name
+c0313688 r _acpi_module_name
+c031368c r _acpi_module_name
+c0313690 r _acpi_module_name
+c0313694 r _acpi_module_name
+c03136b0 r _acpi_module_name
+c03136fc r _acpi_module_name
+c031371c r _acpi_module_name
+c0313720 r _acpi_module_name
+c031374c r _acpi_module_name
+c0313768 r _acpi_module_name
+c03137c4 r _acpi_module_name
+c03137c8 r _acpi_module_name
+c03137cc r _acpi_module_name
+c0313808 r _acpi_module_name
+c031380c r _acpi_module_name
+c0313810 r _acpi_module_name
+c0313814 r _acpi_module_name
+c0313818 r _acpi_module_name
+c031381c r _acpi_module_name
+c0313820 r _acpi_module_name
+c0313878 r _acpi_module_name
+c031387c r _acpi_module_name
+c0313880 r _acpi_module_name
+c03138cc r _acpi_module_name
+c03138d0 r _acpi_module_name
+c03138d4 r _acpi_module_name
+c03138d8 r _acpi_module_name
+c03138dc r _acpi_module_name
+c03138e0 r _acpi_module_name
+c03138e4 r _acpi_module_name
+c03138e8 r _acpi_module_name
+c03138ec r _acpi_module_name
+c03138f0 r _acpi_module_name
+c031398c r _acpi_module_name
+c03139b4 r _acpi_module_name
+c03139b8 r _acpi_module_name
+c03139bc r _acpi_module_name
+c03139c0 R acpi_gbl_aml_op_info
+c03141c0 r acpi_gbl_short_op_index
+c03142c0 r acpi_gbl_long_op_index
+c031434c r _acpi_module_name
+c0314350 R acpi_gbl_aml_resource_sizes
+c0314361 R acpi_gbl_resource_struct_sizes
+c0314380 r _acpi_module_name
+c0314428 r _acpi_module_name
+c0314454 r _acpi_module_name
+c0314460 r _acpi_module_name
+c0314464 r _acpi_module_name
+c0314468 r _acpi_module_name
+c0314480 r _acpi_module_name
+c03144a0 r fadt_info_table
+c03144e0 r _acpi_module_name
+c0314500 r acpi_interfaces_supported
+c0314520 r _acpi_module_name
+c0314524 r _acpi_module_name
+c0314528 r _acpi_module_name
+c031452c r _acpi_module_name
+c03145a8 r _acpi_module_name
+c03145c0 R acpi_gbl_pre_defined_names
+c0314638 R acpi_gbl_ns_properties
+c0314657 r acpi_gbl_bad_type
+c0314680 r acpi_gbl_desc_type_names
+c03146c0 r acpi_gbl_ns_type_names
+c031473c r acpi_gbl_event_types
+c0314750 r acpi_gbl_hex_to_ascii
+c0314760 r _acpi_module_name
+c0314764 r _acpi_module_name
+c0314768 r _acpi_module_name
+c031476c r _acpi_module_name
+c0314770 r _acpi_module_name
+c0314774 R acpi_gbl_resource_aml_sizes
+c0314790 r acpi_gbl_resource_types
+c03147ac r __func__.15813
+c03147bc r __func__.18272
+c03147c8 r _acpi_module_name
+c03147e8 r __func__.16443
+c03147fc r _acpi_module_name
+c0314800 r _acpi_module_name
+c0314804 r _acpi_module_name
+c0314808 r _acpi_module_name
+c031480c r _acpi_module_name
+c0314820 r acpi_power_fops
+c03148a0 r acpi_system_event_ops
+c0314920 r xtab.8829
+c0314940 r xtab.8872
+c0314960 r pnp_dev_table
+c0314aa0 r memory_fops
+c0314b20 r devlist
+c0314bc0 r mem_fops
+c0314c40 r kmem_fops
+c0314cc0 r null_fops
+c0314d40 r port_fops
+c0314dc0 r zero_fops
+c0314e40 r full_fops
+c0314ec0 r kmsg_fops
+c0314f40 r oldmem_fops
+c0314fc0 R random_fops
+c0315040 R urandom_fops
+c03150c0 r twist_table.16590
+c0315180 r tty_fops
+c0315200 r console_fops
+c0315280 r ptmx_fops
+c0315300 r hung_up_tty_fops
+c0315370 r __func__.19333
+c0315380 r __func__.21266
+c0315390 r ptychar
+c03153c0 r baud_table
+c0315440 r baud_bits
+c03154c0 r pty_ops
+c0315520 r misc_proc_fops
+c03155a0 r misc_fops
+c0315620 r vcs_fops
+c0315700 R max_vals
+c031573c R NR_TYPES
+c0315740 r k_handler
+c0315780 r cur_chars.18837
+c0315785 r ret_diacr.18814
+c031578b r app_map.18851
+c03157a1 r pad_chars.18850
+c03157c0 r fn_handler
+c0315820 r x86_keycodes
+c0315a20 r kbd_ids
+c0315e1c r __func__.19550
+c0315e27 r __func__.19583
+c0315e33 r __func__.21603
+c0315e3f r __func__.21623
+c0315e4c r __func__.21579
+c0315e61 r __func__.21536
+c0315e73 r __func__.21502
+c0315ea0 r con_ops
+c0315f00 r utf8_length_changes.20654
+c0315f20 r double_width.20625
+c0315f80 r __func__.19836
+c0315f8e r __func__.19751
+c0315f98 r __func__.19688
+c0315fa4 r __func__.19624
+c0315fb2 r __func__.19352
+c0315fc1 r __func__.19292
+c0315fcf r __func__.19193
+c0315fe0 r rtc_proc_fops
+c0316050 r days_in_mo
+c0316060 r rtc_fops
+c03160e0 r __func__.21009
+c03160ea r __func__.21494
+c03160f8 r __func__.21454
+c0316107 r __func__.21376
+c0316120 r hpet_fops
+c03161a0 r rng_chrdev_ops
+c0316220 r pci_tbl
+c03165c0 r uart_ops
+c0316620 r __func__.17092
+c0316632 r __func__.17029
+c0316640 r baud_rates
+c03166e0 r old_serial_port
+c0316760 r uart_config
+c0316880 r pnp_dev_table
+c0316fa0 r timedia_data
+c0316fc0 r timedia_single_port
+c0316fe0 r timedia_dual_port
+c0317020 r timedia_quad_port
+c031704e r timedia_eight_port
+c0317068 r __func__.17007
+c0317080 r __func__.8634
+c031708f r __func__.8863
+c031709e r __func__.8775
+c03170b0 r __func__.11133
+c03170bd r __func__.11088
+c03170ca r __func__.8774
+c03170dc r __func__.8765
+c03170e7 r __func__.8721
+c03170fc r __func__.8699
+c0317110 r __func__.8680
+c0317123 r __func__.8557
+c0317137 r __func__.8517
+c0317146 r enabled
+c031714e r disabled
+c0317157 r __func__.14771
+c0317174 r __func__.14740
+c031718a r __func__.14671
+c0317195 r __func__.14709
+c03171a8 r __func__.17312
+c03171c0 r __func__.12050
+c03171d4 r __func__.12008
+c03171ef r __func__.11955
+c0317201 r __func__.11935
+c0317211 r __func__.11775
+c0317240 r firmware_attr_data_tmpl
+c0317260 r __func__.11910
+c0317273 r __func__.11831
+c03172a0 r ramdisk_aops
+c03172e0 r loopback_ethtool_ops
+c031737c r __func__.23388
+c03173a0 r aec6xxx_33_base
+c03173e0 r aec6xxx_34_base
+c0317410 r C.309.22445
+c0317420 r amd_cyc2udma
+c0317430 r amd_dma
+c0317444 r mdma_timing
+c031744a r pio_timing
+c0317460 r cmd64x_chipsets
+c0317540 r drwtim_regs.22235
+c0317544 r recovery_values.22234
+c0317555 r arttim_regs.22263
+c0317559 r setup_values.22262
+c0317560 r cs5520_pio_clocks
+c03175a0 r cs5530_pio_timings
+c03175c8 r cs5535_pio_cmd_timings
+c03175dc r cs5535_pio_dta_timings
+c03175f0 r cs5535_udma_timings
+c0317604 r cs5535_mwdma_timings
+c0317610 r chipset_names.22325
+c0317618 r C.291.22283
+c0317628 r C.290.22282
+c0317640 r hpt366_chipsets
+c0317790 r __func__.22472
+c03177a7 r __func__.22540
+c03177bf r xfer_speeds
+c03177d0 r info.22928
+c03177ec r chipset_names.22927
+c0317808 r pio_want.22324
+c031780e r pio.22323
+c0317818 r mwdma_want.22362
+c031781c r dma.22361
+c0317822 r udma_want.22396
+c031782a r udma.22395
+c0317838 r mode.22599
+c0317840 r udma_timings
+c0317855 r mwdma_timings
+c031785b r pio_timings
+c031786a r timings.22255
+c0317874 r drive_pci2.22282
+c0317878 r drive_pci.22281
+c031787c r pio_modes.22280
+c0317881 r dma_modes.22279
+c0317884 r udma_modes.22278
+c031788a r __func__.22512
+c03178a8 r C.296.22409
+c03178af r __func__.22595
+c0317900 r cycle_time_value
+c0317940 r cvs_time_value
+c0317978 r cycle_time_range
+c031797f r cycle_time_offset
+c03179a0 r ini_time_value
+c03179e0 r act_time_value
+c0317a20 r rco_time_value
+c0317a60 r SiSHostChipInfo
+c0317b40 r chipset_capability
+c0317b60 r timings.22250
+c0317bd8 r via_dma
+c0317c90 r ide_hwif_to_major
+c0317ca0 r C.323.23602
+c0317cdc r hex.23501
+c0317ce0 r decimal.23500
+c0317ce4 r C.320.23911
+c0317d40 R ide_pio_timings
+c0317d88 r __func__.23032
+c0317d96 r __func__.22518
+c0317da4 r __func__.22683
+c0317dbf r __func__.22670
+c0317dd2 r __func__.22572
+c0317de0 r __func__.22548
+c0317ded r ven_dev.22319
+c0317df1 r arttim_regs
+c0317df5 r drwtim_regs
+c0317df9 r prefetch_regs
+c0317dfd r prefetch_masks
+c0317e04 r __func__.22639
+c0317e14 r ata_index.22487
+c0317e20 r __func__.22571
+c0317e33 r xfer_mode_bases
+c0317e40 r drive_whitelist
+c0317e80 r drive_blacklist
+c0317f78 r __func__.18176
+c0317fbc r __func__.25023
+c0317fe0 r sense_key_texts
+c0318020 r sense_data_texts
+c0318420 r packet_command_texts
+c03186f0 r mrw_format_status
+c0318700 r __func__.18205
+c0318728 r __func__.17896
+c0318738 r __func__.17485
+c0318747 r __func__.16294
+c0318755 r usb2_rh_dev_descriptor
+c0318767 r usb11_rh_dev_descriptor
+c0318779 r hs_rh_config_descriptor
+c0318792 r fs_rh_config_descriptor
+c03187ab r __func__.20011
+c03187b9 r __func__.19859
+c03187e0 r usb_fops
+c0318850 r pool_max
+c0318860 R usbdev_file_operations
+c03188d0 r __func__.25200
+c03188dd r __func__.18071
+c0318900 r usb_quirk_list
+c0318950 r __func__.19787
+c03189c0 r default_file_operations
+c0318a40 R usbfs_devices_fops
+c0318ab0 r format_topo
+c0318ab4 r format_bandwidth
+c0318ab8 r format_device1
+c0318abc r format_device2
+c0318ac0 r clas_info
+c0318b38 r format_string_manufacturer
+c0318b3c r format_string_product
+c0318b40 r format_string_serialnumber
+c0318b44 r format_config
+c0318b48 r format_iface
+c0318b4c r format_endpt
+c0318b50 r bias_names
+c0318b5c r __func__.16147
+c0318b68 r keyboard_ids.16111
+c0318b6e r __func__.16085
+c0318c40 r input_fops
+c0318cc0 r input_devices_fileops
+c0318d40 r input_handlers_fileops
+c0318db0 r __func__.17938
+c0318dc9 r __func__.17869
+c0318e00 r mousedev_imex_seq
+c0318e06 r mousedev_imps_seq
+c0318e20 r mousedev_fops
+c0318ea0 r mousedev_ids
+c0319180 r evdev_fops
+c0319200 r evdev_ids
+c0319300 r atkbd_unxlate_table
+c0319380 r atkbd_scroll_keys
+c031938e r delay.16438
+c03193a0 r period.16437
+c03193e0 r xl_table
+c0319400 r psmouse_protocols
+c0319508 r seq.16579
+c0319511 r __func__.16634
+c031952a r rates.16699
+c0319532 r params.16685
+c0319537 r oldabs_rslt.16585
+c031953c r oldabs_mask.16584
+c0319541 r newabs_rslt.16583
+c0319546 r newabs_rel_mask.16582
+c031954b r newabs_mask.16581
+c0319560 r alps_model_data
+c03195c0 r rates.16266
+c03195e0 r ps2pp_list.16284
+c0319680 r params.16314
+c03196c0 r super_types
+c0319700 r md_seq_fops
+c0319770 r __func__.21913
+c0319780 r _name
+c0319784 r __func__.22079
+c031978c r _claim_ptr.20300
+c03197a0 r _ioctls.21363
+c0319820 r _ctl_fops
+c0319890 r __func__.20325
+c0319898 r __func__.20356
+c03198c0 r fields.17392
+c03198e4 r var_subsys_attrs
+c03198f0 r efi_subsys_attrs
+c03198f8 r __func__.14447
+c0319964 r __func__.15602
+c031996e r __func__.15580
+c0319978 r dispatch_type.15501
+c0319a80 r hid_keyboard
+c0319b80 r hid_hat_to_axis
+c0319be0 r hid_types
+c0319c04 r __func__.18059
+c0319c12 r __func__.19045
+c0319c40 r hid_blacklist
+c031a178 r pirqmap.22008
+c031a18c r pirqmap.21997
+c031a1a0 r pirqmap.22030
+c031a1a4 r pirqmap.22018
+c031a1a8 r irqmap.21950
+c031a1b8 r irqmap.21938
+c031a240 R bad_sock_fops
+c031a2b0 r nargs
+c031a2e0 r socket_file_ops
+c031a480 r proto_seq_fops
+c031a4f0 r proto_seq_ops
+c031a500 r mask.35512
+c031a50b r mask.35509
+c031a51b r __func__.24663
+c031a527 r __func__.34895
+c031a52f r __func__.19946
+c031a53a r __func__.31045
+c031a546 r __func__.25169
+c031a560 r __func__.31215
+c031a580 r dev_seq_fops
+c031a600 r softnet_seq_fops
+c031a680 r ptype_seq_fops
+c031a6f0 r ptype_seq_ops
+c031a700 r softnet_seq_ops
+c031a710 r dev_seq_ops
+c031a720 r __func__.30948
+c031a735 r __func__.29404
+c031a860 r dev_mc_seq_fops
+c031a8d0 r dev_mc_seq_ops
+c031a920 r nl_neightbl_policy
+c031a960 r nl_ntbl_parm_policy
+c031a9a0 r __func__.17006
+c031a9c0 r neigh_stat_seq_fops
+c031aa30 r neigh_stat_seq_ops
+c031aa40 r __func__.22819
+c031aaa0 r rta_max
+c031aae0 r rtm_min
+c031ab20 r ifla_policy
+c031ab6c r ifla_info_policy
+c031ab7c r __func__.19449
+c031ab87 r __func__.30893
+c031ab94 r __func__.30949
+c031aba1 r __func__.26523
+c031abb7 r __func__.28241
+c031abc8 r fmt_dec
+c031abcc r fmt_ulong
+c031abd1 r fmt_hex
+c031abd8 r operstates
+c031abf4 r fmt_long_hex
+c031abfa r __func__.26400
+c031ac08 r net_shadow_dir_operations
+c031ac10 r __func__.17361
+c031ac1b r __func__.26262
+c031ac40 r prio2band
+c031ac60 r psched_fops
+c031acd0 r __func__.19607
+c031acdb r __func__.19607
+c031ad00 r netlink_seq_fops
+c031ad80 r netlink_ops
+c031add4 r __func__.25764
+c031ae04 r __func__.16912
+c031ae10 r ctrl_policy
+c031ae40 r nflog_file_ops
+c031aec0 r nfqueue_file_ops
+c031af40 r __func__.25305
+c031af60 r rt_cache_seq_fops
+c031afe0 r rt_cpu_seq_fops
+c031b050 r rt_cpu_seq_ops
+c031b060 r rt_cache_seq_ops
+c031b070 r __func__.17296
+c031b07c r mtu_plateau
+c031b090 r __func__.24497
+c031b09c r __func__.25163
+c031b0a8 r __func__.19772
+c031b234 r __func__.24685
+c031b240 R inet_csk_timer_bug_msg
+c031b263 r __func__.24675
+c031b2d4 r __func__.25963
+c031b2e0 r new_state
+c031b2f0 r __func__.20260
+c031b344 r __func__.34563
+c031b34c r __func__.16989
+c031b357 r __func__.24510
+c031b363 r __func__.24613
+c031b380 r __func__.31848
+c031b3a3 r __func__.24692
+c031b3c0 r __func__.24795
+c031b3d1 r __func__.24536
+c031b3e0 r raw_seq_fops
+c031b450 r raw_seq_ops
+c031b460 r __func__.25109
+c031b471 r __func__.24850
+c031b47d r __func__.24845
+c031b48e r __func__.28515
+c031b4a0 r __func__.25188
+c031b4c0 r arp_seq_fops
+c031b530 r arp_seq_ops
+c031b540 r icmp_pointers
+c031b670 r __func__.25417
+c031b6cc r __func__.30186
+c031b6d6 r __func__.19535
+c031b700 r ifa_ipv4_policy
+c031b720 R inet_stream_ops
+c031b780 R inet_dgram_ops
+c031b7d4 r __func__.35823
+c031b7eb r __func__.25447
+c031b800 r inet_sockraw_ops
+c031b860 r igmp_mc_seq_fops
+c031b8e0 r igmp_mcf_seq_fops
+c031b950 r igmp_mcf_seq_ops
+c031b960 r igmp_mc_seq_ops
+c031b970 r __func__.25098
+c031b9c0 R rtm_ipv4_policy
+c031ba00 r __func__.17084
+c031ba20 r fib_props
+c031ba80 r __func__.32407
+c031baa0 r fib_seq_fops
+c031bb10 r fib_seq_ops
+c031bb20 r type2flags.32931
+c031bb60 r netstat_seq_fops
+c031bbe0 r snmp_seq_fops
+c031bc60 r sockstat_seq_fops
+c031bce0 r snmp4_ipstats_list
+c031bd80 r snmp4_icmp_list
+c031be60 r snmp4_tcp_list
+c031bee0 r snmp4_udp_list
+c031bf20 r snmp4_net_list
+c031c140 r snmp4_ipextstats_list
+c031c180 r fib4_rule_policy
+c031c1c4 r __func__.23409
+c031c1e0 r v.31755
+c031c220 r __func__.24844
+c031c22c r __func__.25019
+c031c238 r __func__.25019
+c031c244 r __func__.24957
+c031c250 r __func__.31621
+c031c261 r __func__.31899
+c031c274 r xfrm_calg_list
+c031c284 r xfrm_ealg_list
+c031c294 r xfrm_aalg_list
+c031c2c0 r __func__.27922
+c031c2e0 r unix_seq_fops
+c031c360 r unix_stream_ops
+c031c3c0 r unix_dgram_ops
+c031c420 r unix_seqpacket_ops
+c031c474 r __func__.24799
+c031c4a0 R inet6_stream_ops
+c031c500 R inet6_dgram_ops
+c031c560 r inet6_sockraw_ops
+c031c5c0 r ac6_seq_fops
+c031c630 r __func__.24469
+c031c63c r __func__.24532
+c031c648 r __func__.17006
+c031c688 R in6addr_any
+c031c698 R in6addr_loopback
+c031c6a8 r __func__.24689
+c031c6b4 r __func__.35853
+c031c6c5 r __func__.17006
+c031c6e0 r ifa_ipv6_policy
+c031c700 r __func__.35821
+c031c712 r __func__.36098
+c031c740 r if6_fops
+c031c7b0 r __func__.36181
+c031c7e0 r __func__.24896
+c031c800 r rt6_stats_seq_fops
+c031c880 r rtm_ipv6_policy
+c031c8c0 r __func__.17025
+c031c8cb r __func__.35420
+c031c8dc r C.510.34697
+c031c8e8 r C.484.34261
+c031c8f4 r C.425.29285
+c031cb18 r __func__.24756
+c031cb38 r __func__.29905
+c031cb45 r __func__.24695
+c031cb51 r __func__.30154
+c031cb5f r __func__.30520
+c031cb76 r __func__.30749
+c031cb8a r __func__.24940
+c031cb9b r __func__.24681
+c031cba7 r __func__.24845
+c031cbb8 r __func__.29281
+c031cbe0 r __func__.25349
+c031cbf1 r __func__.25090
+c031cc00 r raw6_seq_fops
+c031cc80 r tab_unreach
+c031cca8 r __func__.25060
+c031cce0 r igmp6_mc_seq_fops
+c031cd60 r igmp6_mcf_seq_fops
+c031cdd0 r __func__.24861
+c031cddc r __func__.25040
+c031cde8 r __func__.24486
+c031ce00 r ip6fl_seq_fops
+c031ce70 r __func__.24866
+c031ce7c r __func__.24982
+c031ce88 r __func__.24982
+c031ce94 r __func__.24659
+c031cea0 r snmp6_seq_fops
+c031cf20 r sockstat6_seq_fops
+c031cf90 r __func__.24804
+c031cf9c r tunnels
+c031d000 r packet_seq_fops
+c031d080 r packet_ops
+c031d0e0 r packet_ops_spkt
+c031d134 r __func__.25112
+c031d145 r __func__.24853
+c031d160 r standard_ioctl
+c031d400 r standard_event
+c031d480 r event_type_size
+c031d4ac r __func__.17006
+c031d4b7 r iw_priv_type_size
+c031d4c0 r wireless_seq_fops
+c031d530 r wireless_seq_ops
+c031d540 R kallsyms_addresses
+c03353b0 R kallsyms_num_syms
+c03353b4 R kallsyms_names
+c0377490 R kallsyms_markers
+c0377610 R kallsyms_token_table
+c037797c R kallsyms_token_index
+c03abc30 r __pci_fixup_PCI_VENDOR_ID_SERVERWORKSPCI_DEVICE_ID_SERVERWORKS_CSB5IDEquirk_svwks_csb5ide
+c03abc30 R __start_pci_fixups_early
+c03abc38 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801CA_10quirk_ide_samemode
+c03abc40 r __pci_fixup_PCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB360quirk_jmicron_ata
+c03abc48 r __pci_fixup_PCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB361quirk_jmicron_ata
+c03abc50 r __pci_fixup_PCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB363quirk_jmicron_ata
+c03abc58 r __pci_fixup_PCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB365quirk_jmicron_ata
+c03abc60 r __pci_fixup_PCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB366quirk_jmicron_ata
+c03abc68 r __pci_fixup_PCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB368quirk_jmicron_ata
+c03abc70 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_PXHD_0quirk_pcie_pxh
+c03abc78 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_PXHD_1quirk_pcie_pxh
+c03abc80 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_PXH_0quirk_pcie_pxh
+c03abc88 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_PXH_1quirk_pcie_pxh
+c03abc90 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_PXHVquirk_pcie_pxh
+c03abc98 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_ANY_IDquirk_e100_interrupt
+c03abca0 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82371AB_3acpi_pm_check_blacklist
+c03abca8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801DB_0acpi_pm_check_graylist
+c03abcb0 r __pci_fixup_PCI_VENDOR_ID_SERVERWORKSPCI_DEVICE_ID_SERVERWORKS_LEacpi_pm_check_graylist
+c03abcb8 r __pci_fixup_PCI_VENDOR_ID_CYRIXPCI_DEVICE_ID_CYRIX_5530_LEGACYpci_early_fixup_cyrix_5530
+c03abcc0 R __end_pci_fixups_early
+c03abcc0 r __pci_fixup_PCI_VENDOR_ID_IBMPCI_DEVICE_ID_IBM_CITRINEquirk_citrine
+c03abcc0 R __start_pci_fixups_header
+c03abcc8 r __pci_fixup_PCI_VENDOR_ID_S3PCI_DEVICE_ID_S3_868quirk_s3_64M
+c03abcd0 r __pci_fixup_PCI_VENDOR_ID_S3PCI_DEVICE_ID_S3_968quirk_s3_64M
+c03abcd8 r __pci_fixup_PCI_VENDOR_ID_ALPCI_DEVICE_ID_AL_M7101quirk_ali7101_acpi
+c03abce0 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82371AB_3quirk_piix4_acpi
+c03abce8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82443MX_3quirk_piix4_acpi
+c03abcf0 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801AA_0quirk_ich4_lpc_acpi
+c03abcf8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801AB_0quirk_ich4_lpc_acpi
+c03abd00 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801BA_0quirk_ich4_lpc_acpi
+c03abd08 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801BA_10quirk_ich4_lpc_acpi
+c03abd10 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801CA_0quirk_ich4_lpc_acpi
+c03abd18 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801CA_12quirk_ich4_lpc_acpi
+c03abd20 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801DB_0quirk_ich4_lpc_acpi
+c03abd28 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801DB_12quirk_ich4_lpc_acpi
+c03abd30 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801EB_0quirk_ich4_lpc_acpi
+c03abd38 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ESB_1quirk_ich4_lpc_acpi
+c03abd40 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH6_0quirk_ich6_lpc_acpi
+c03abd48 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH6_1quirk_ich6_lpc_acpi
+c03abd50 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH7_0quirk_ich6_lpc_acpi
+c03abd58 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH7_1quirk_ich6_lpc_acpi
+c03abd60 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH7_31quirk_ich6_lpc_acpi
+c03abd68 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH8_0quirk_ich6_lpc_acpi
+c03abd70 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH8_2quirk_ich6_lpc_acpi
+c03abd78 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH8_3quirk_ich6_lpc_acpi
+c03abd80 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C586_3quirk_vt82c586_acpi
+c03abd88 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C686_4quirk_vt82c686_acpi
+c03abd90 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8235quirk_vt8235_acpi
+c03abd98 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C586_3quirk_via_acpi
+c03abda0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C686_4quirk_via_acpi
+c03abda8 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C686quirk_via_bridge
+c03abdb0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8231quirk_via_bridge
+c03abdb8 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8233_0quirk_via_bridge
+c03abdc0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8233Aquirk_via_bridge
+c03abdc8 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8233C_0quirk_via_bridge
+c03abdd0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8235quirk_via_bridge
+c03abdd8 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237quirk_via_bridge
+c03abde0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237Aquirk_via_bridge
+c03abde8 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C597_0quirk_vt82c598_id
+c03abdf0 r __pci_fixup_PCI_VENDOR_ID_DUNORDPCI_DEVICE_ID_DUNORD_I3000quirk_dunord
+c03abdf8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82380FBquirk_transparent_bridge
+c03abe00 r __pci_fixup_PCI_VENDOR_ID_TOSHIBA0x605quirk_transparent_bridge
+c03abe08 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_IXP600_SATAquirk_sb600_sata
+c03abe10 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_IXP700_SATAquirk_sb600_sata
+c03abe18 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82375quirk_eisa_bridge
+c03abe20 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237k8t_sound_hostbridge
+c03abe28 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82845_HBasus_hides_smbus_hostbridge
+c03abe30 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82845G_HBasus_hides_smbus_hostbridge
+c03abe38 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82850_HBasus_hides_smbus_hostbridge
+c03abe40 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82865_HBasus_hides_smbus_hostbridge
+c03abe48 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_7205_0asus_hides_smbus_hostbridge
+c03abe50 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_E7501_MCHasus_hides_smbus_hostbridge
+c03abe58 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82855PM_HBasus_hides_smbus_hostbridge
+c03abe60 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82855GM_HBasus_hides_smbus_hostbridge
+c03abe68 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82915GM_HBasus_hides_smbus_hostbridge
+c03abe70 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801DB_0asus_hides_smbus_lpc
+c03abe78 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801BA_0asus_hides_smbus_lpc
+c03abe80 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801CA_0asus_hides_smbus_lpc
+c03abe88 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801CA_12asus_hides_smbus_lpc
+c03abe90 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801DB_12asus_hides_smbus_lpc
+c03abe98 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801EB_0asus_hides_smbus_lpc
+c03abea0 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH6_1asus_hides_smbus_lpc_ich6
+c03abea8 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_961quirk_sis_96x_smbus
+c03abeb0 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_962quirk_sis_96x_smbus
+c03abeb8 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_963quirk_sis_96x_smbus
+c03abec0 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_LPCquirk_sis_96x_smbus
+c03abec8 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_503quirk_sis_503
+c03abed0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237asus_hides_ac97_lpc
+c03abed8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_EESSCquirk_alder_ioapic
+c03abee0 r __pci_fixup_PCI_VENDOR_ID_TOSHIBA_2PCI_DEVICE_ID_TOSHIBA_TC86C001_IDEquirk_tc86c001_ide
+c03abee8 r __pci_fixup_PCI_VENDOR_ID_NETMOSPCI_ANY_IDquirk_netmos
+c03abef0 r __pci_fixup_PCI_VENDOR_ID_NCRPCI_DEVICE_ID_NCR_53C810fixup_rev1_53c810
+c03abef8 r __pci_fixup_PCI_VENDOR_ID_INTEL0x1460quirk_p64h2_1k_io
+c03abf00 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82451NXpci_fixup_i450nx
+c03abf08 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82454GXpci_fixup_i450gx
+c03abf10 r __pci_fixup_PCI_VENDOR_ID_UMCPCI_DEVICE_ID_UMC_UM8886BFpci_fixup_umc_ide
+c03abf18 r __pci_fixup_PCI_VENDOR_ID_NCRPCI_DEVICE_ID_NCR_53C810pci_fixup_ncr53c810
+c03abf20 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_5597pci_fixup_latency
+c03abf28 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_5598pci_fixup_latency
+c03abf30 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82371AB_3pci_fixup_piix4_acpi
+c03abf38 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8363_0pci_fixup_via_northbridge_bug
+c03abf40 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8622pci_fixup_via_northbridge_bug
+c03abf48 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8361pci_fixup_via_northbridge_bug
+c03abf50 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8367_0pci_fixup_via_northbridge_bug
+c03abf58 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_ANY_IDpci_fixup_transparent_bridge
+c03abf60 r __pci_fixup_PCI_VENDOR_ID_NVIDIAPCI_DEVICE_ID_NVIDIA_NFORCE2pci_fixup_nforce2
+c03abf68 r __pci_fixup_PCI_VENDOR_ID_TI0x8032pci_pre_fixup_toshiba_ohci1394
+c03abf70 r __pci_fixup_PCI_VENDOR_ID_SIEMENS0x0015pci_siemens_interrupt_controller
+c03abf78 R __end_pci_fixups_header
+c03abf78 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_ANY_IDvia_no_dac
+c03abf78 R __start_pci_fixups_final
+c03abf80 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_E7320_MCHquirk_intel_irqbalance
+c03abf88 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_E7525_MCHquirk_intel_irqbalance
+c03abf90 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_E7520_MCHquirk_intel_irqbalance
+c03abf98 r __pci_fixup_PCI_VENDOR_ID_MELLANOXPCI_DEVICE_ID_MELLANOX_TAVORquirk_mellanox_tavor
+c03abfa0 r __pci_fixup_PCI_VENDOR_ID_MELLANOXPCI_DEVICE_ID_MELLANOX_TAVOR_BRIDGEquirk_mellanox_tavor
+c03abfa8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82441quirk_passive_release
+c03abfb0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C586_0quirk_isa_dma_hangs
+c03abfb8 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C596quirk_isa_dma_hangs
+c03abfc0 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82371SB_0quirk_isa_dma_hangs
+c03abfc8 r __pci_fixup_PCI_VENDOR_ID_ALPCI_DEVICE_ID_AL_M1533quirk_isa_dma_hangs
+c03abfd0 r __pci_fixup_PCI_VENDOR_ID_NECPCI_DEVICE_ID_NEC_CBUS_1quirk_isa_dma_hangs
+c03abfd8 r __pci_fixup_PCI_VENDOR_ID_NECPCI_DEVICE_ID_NEC_CBUS_2quirk_isa_dma_hangs
+c03abfe0 r __pci_fixup_PCI_VENDOR_ID_NECPCI_DEVICE_ID_NEC_CBUS_3quirk_isa_dma_hangs
+c03abfe8 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_5597quirk_nopcipci
+c03abff0 r __pci_fixup_PCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_496quirk_nopcipci
+c03abff8 r __pci_fixup_PCI_VENDOR_ID_AMDPCI_DEVICE_ID_AMD_8151_0quirk_nopciamd
+c03ac000 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82437quirk_triton
+c03ac008 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82437VXquirk_triton
+c03ac010 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82439quirk_triton
+c03ac018 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82439TXquirk_triton
+c03ac020 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8363_0quirk_vialatency
+c03ac028 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8371_1quirk_vialatency
+c03ac030 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8361quirk_vialatency
+c03ac038 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C597_0quirk_viaetbf
+c03ac040 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C576quirk_vsfx
+c03ac048 r __pci_fixup_PCI_VENDOR_ID_ALPCI_DEVICE_ID_AL_M1647quirk_alimagik
+c03ac050 r __pci_fixup_PCI_VENDOR_ID_ALPCI_DEVICE_ID_AL_M1651quirk_alimagik
+c03ac058 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82441quirk_natoma
+c03ac060 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82443LX_0quirk_natoma
+c03ac068 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82443LX_1quirk_natoma
+c03ac070 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82443BX_0quirk_natoma
+c03ac078 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82443BX_1quirk_natoma
+c03ac080 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82443BX_2quirk_natoma
+c03ac088 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_RS100quirk_ati_exploding_mce
+c03ac090 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C686quirk_via_ioapic
+c03ac098 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237quirk_via_vt8237_bypass_apic_deassert
+c03ac0a0 r __pci_fixup_PCI_VENDOR_ID_AMDPCI_DEVICE_ID_AMD_VIPER_7410quirk_amd_ioapic
+c03ac0a8 r __pci_fixup_PCI_VENDOR_ID_SIPCI_ANY_IDquirk_ioapic_rmw
+c03ac0b0 r __pci_fixup_PCI_VENDOR_ID_AMDPCI_DEVICE_ID_AMD_8131_BRIDGEquirk_amd_8131_ioapic
+c03ac0b8 r __pci_fixup_PCI_ANY_IDPCI_ANY_IDquirk_cardbus_legacy
+c03ac0c0 r __pci_fixup_PCI_VENDOR_ID_AMDPCI_DEVICE_ID_AMD_FE_GATE_700Cquirk_amd_ordering
+c03ac0c8 r __pci_fixup_PCI_VENDOR_ID_CYRIXPCI_DEVICE_ID_CYRIX_PCI_MASTERquirk_mediagx_master
+c03ac0d0 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82454NXquirk_disable_pxb
+c03ac0d8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_E7520_MCHquirk_pcie_mch
+c03ac0e0 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_E7320_MCHquirk_pcie_mch
+c03ac0e8 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_E7525_MCHquirk_pcie_mch
+c03ac0f0 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25e2quirk_intel_pcie_pm
+c03ac0f8 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25e3quirk_intel_pcie_pm
+c03ac100 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25e4quirk_intel_pcie_pm
+c03ac108 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25e5quirk_intel_pcie_pm
+c03ac110 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25e6quirk_intel_pcie_pm
+c03ac118 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25e7quirk_intel_pcie_pm
+c03ac120 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25f7quirk_intel_pcie_pm
+c03ac128 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25f8quirk_intel_pcie_pm
+c03ac130 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25f9quirk_intel_pcie_pm
+c03ac138 r __pci_fixup_PCI_VENDOR_ID_INTEL0x25faquirk_intel_pcie_pm
+c03ac140 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2601quirk_intel_pcie_pm
+c03ac148 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2602quirk_intel_pcie_pm
+c03ac150 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2603quirk_intel_pcie_pm
+c03ac158 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2604quirk_intel_pcie_pm
+c03ac160 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2605quirk_intel_pcie_pm
+c03ac168 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2606quirk_intel_pcie_pm
+c03ac170 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2607quirk_intel_pcie_pm
+c03ac178 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2608quirk_intel_pcie_pm
+c03ac180 r __pci_fixup_PCI_VENDOR_ID_INTEL0x2609quirk_intel_pcie_pm
+c03ac188 r __pci_fixup_PCI_VENDOR_ID_INTEL0x260aquirk_intel_pcie_pm
+c03ac190 r __pci_fixup_PCI_VENDOR_ID_INTEL0x260bquirk_intel_pcie_pm
+c03ac198 r __pci_fixup_PCI_VENDOR_ID_INTEL0x1460quirk_p64h2_1k_io_fix_iobl
+c03ac1a0 r __pci_fixup_PCI_VENDOR_ID_NVIDIAPCI_DEVICE_ID_NVIDIA_CK804_PCIEquirk_nvidia_ck804_pcie_aer_ext_cap
+c03ac1a8 r __pci_fixup_PCI_VENDOR_ID_SERVERWORKSPCI_DEVICE_ID_SERVERWORKS_GCNB_LEquirk_disable_all_msi
+c03ac1b0 r __pci_fixup_PCI_VENDOR_ID_SERVERWORKSPCI_DEVICE_ID_SERVERWORKS_HT1000_PCIXquirk_disable_all_msi
+c03ac1b8 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_RS400_200quirk_disable_all_msi
+c03ac1c0 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_RS480quirk_disable_all_msi
+c03ac1c8 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_RD580quirk_disable_all_msi
+c03ac1d0 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_RX790quirk_disable_all_msi
+c03ac1d8 r __pci_fixup_PCI_VENDOR_ID_ATIPCI_DEVICE_ID_ATI_RS690quirk_disable_all_msi
+c03ac1e0 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_VT3351quirk_disable_all_msi
+c03ac1e8 r __pci_fixup_PCI_VENDOR_ID_AMDPCI_DEVICE_ID_AMD_8131_BRIDGEquirk_disable_msi
+c03ac1f0 r __pci_fixup_PCI_VENDOR_ID_SERVERWORKSPCI_DEVICE_ID_SERVERWORKS_HT2000_PCIEquirk_msi_ht_cap
+c03ac1f8 r __pci_fixup_PCI_VENDOR_ID_NVIDIAPCI_DEVICE_ID_NVIDIA_CK804_PCIEquirk_nvidia_ck804_msi_ht_cap
+c03ac200 r __pci_fixup_PCI_ANY_IDPCI_ANY_IDquirk_usb_early_handoff
+c03ac208 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_MCH_PApcie_rootport_aspm_quirk
+c03ac210 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_MCH_PA1pcie_rootport_aspm_quirk
+c03ac218 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_MCH_PBpcie_rootport_aspm_quirk
+c03ac220 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_MCH_PB1pcie_rootport_aspm_quirk
+c03ac228 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_MCH_PCpcie_rootport_aspm_quirk
+c03ac230 r __pci_fixup_PCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_MCH_PC1pcie_rootport_aspm_quirk
+c03ac238 r __pci_fixup_PCI_ANY_IDPCI_ANY_IDpci_fixup_video
+c03ac240 R __end_pci_fixups_final
+c03ac240 r __pci_fixup_PCI_VENDOR_ID_VIAPCI_ANY_IDquirk_via_vlink
+c03ac240 R __start_pci_fixups_enable
+c03ac248 r __pci_fixup_PCI_VENDOR_ID_TI0x8032pci_post_fixup_toshiba_ohci1394
+c03ac250 R __end_pci_fixups_enable
+c03ac250 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82441quirk_passive_release
+c03ac250 R __start_pci_fixups_resume
+c03ac258 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8363_0quirk_vialatency
+c03ac260 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8371_1quirk_vialatency
+c03ac268 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8361quirk_vialatency
+c03ac270 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_82C686quirk_via_ioapic
+c03ac278 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237quirk_via_vt8237_bypass_apic_deassert
+c03ac280 r __pci_fixup_resumePCI_VENDOR_ID_AMDPCI_DEVICE_ID_AMD_8131_BRIDGEquirk_amd_8131_ioapic
+c03ac288 r __pci_fixup_resumePCI_ANY_IDPCI_ANY_IDquirk_cardbus_legacy
+c03ac290 r __pci_fixup_resumePCI_VENDOR_ID_AMDPCI_DEVICE_ID_AMD_FE_GATE_700Cquirk_amd_ordering
+c03ac298 r __pci_fixup_resumePCI_VENDOR_ID_CYRIXPCI_DEVICE_ID_CYRIX_PCI_MASTERquirk_mediagx_master
+c03ac2a0 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82454NXquirk_disable_pxb
+c03ac2a8 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237k8t_sound_hostbridge
+c03ac2b0 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801DB_0asus_hides_smbus_lpc
+c03ac2b8 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801BA_0asus_hides_smbus_lpc
+c03ac2c0 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801CA_0asus_hides_smbus_lpc
+c03ac2c8 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801CA_12asus_hides_smbus_lpc
+c03ac2d0 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801DB_12asus_hides_smbus_lpc
+c03ac2d8 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_82801EB_0asus_hides_smbus_lpc
+c03ac2e0 r __pci_fixup_resumePCI_VENDOR_ID_INTELPCI_DEVICE_ID_INTEL_ICH6_1asus_hides_smbus_lpc_ich6
+c03ac2e8 r __pci_fixup_resumePCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_961quirk_sis_96x_smbus
+c03ac2f0 r __pci_fixup_resumePCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_962quirk_sis_96x_smbus
+c03ac2f8 r __pci_fixup_resumePCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_963quirk_sis_96x_smbus
+c03ac300 r __pci_fixup_resumePCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_LPCquirk_sis_96x_smbus
+c03ac308 r __pci_fixup_resumePCI_VENDOR_ID_SIPCI_DEVICE_ID_SI_503quirk_sis_503
+c03ac310 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8237asus_hides_ac97_lpc
+c03ac318 r __pci_fixup_resumePCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB360quirk_jmicron_ata
+c03ac320 r __pci_fixup_resumePCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB361quirk_jmicron_ata
+c03ac328 r __pci_fixup_resumePCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB363quirk_jmicron_ata
+c03ac330 r __pci_fixup_resumePCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB365quirk_jmicron_ata
+c03ac338 r __pci_fixup_resumePCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB366quirk_jmicron_ata
+c03ac340 r __pci_fixup_resumePCI_VENDOR_ID_JMICRONPCI_DEVICE_ID_JMICRON_JMB368quirk_jmicron_ata
+c03ac348 r __pci_fixup_resumePCI_VENDOR_ID_NVIDIAPCI_DEVICE_ID_NVIDIA_CK804_PCIEquirk_nvidia_ck804_pcie_aer_ext_cap
+c03ac350 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8363_0pci_fixup_via_northbridge_bug
+c03ac358 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8622pci_fixup_via_northbridge_bug
+c03ac360 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8361pci_fixup_via_northbridge_bug
+c03ac368 r __pci_fixup_resumePCI_VENDOR_ID_VIAPCI_DEVICE_ID_VIA_8367_0pci_fixup_via_northbridge_bug
+c03ac370 r __pci_fixup_resumePCI_VENDOR_ID_NVIDIAPCI_DEVICE_ID_NVIDIA_NFORCE2pci_fixup_nforce2
+c03ac378 r __pci_fixup_resumePCI_VENDOR_ID_CYRIXPCI_DEVICE_ID_CYRIX_5530_LEGACYpci_early_fixup_cyrix_5530
+c03ac380 R __end_pci_fixups_resume
+c03ac380 ? __end_rio_route_ops
+c03ac380 r __ksymtab_init_mm
+c03ac380 R __start___ksymtab
+c03ac380 ? __start_rio_route_ops
+c03ac388 r __ksymtab_init_task
+c03ac390 r __ksymtab_system_state
+c03ac398 r __ksymtab_reset_devices
+c03ac3a0 r __ksymtab_loops_per_jiffy
+c03ac3a8 r __ksymtab___per_cpu_offset
+c03ac3b0 r __ksymtab_boot_option_idle_override
+c03ac3b8 r __ksymtab_per_cpu__current_task
+c03ac3c0 r __ksymtab_per_cpu__cpu_number
+c03ac3c8 r __ksymtab_pm_idle
+c03ac3d0 r __ksymtab_disable_hlt
+c03ac3d8 r __ksymtab_enable_hlt
+c03ac3e0 r __ksymtab_kernel_thread
+c03ac3e8 r __ksymtab_dump_thread
+c03ac3f0 r __ksymtab_dump_trace
+c03ac3f8 r __ksymtab_dump_stack
+c03ac400 r __ksymtab_per_cpu__irq_stat
+c03ac408 r __ksymtab_per_cpu__irq_regs
+c03ac410 r __ksymtab_do_softirq
+c03ac418 r __ksymtab_cpu_khz
+c03ac420 r __ksymtab_rtc_lock
+c03ac428 r __ksymtab_cmos_lock
+c03ac430 r __ksymtab_rtc_cmos_read
+c03ac438 r __ksymtab_rtc_cmos_write
+c03ac440 r __ksymtab_profile_pc
+c03ac448 r __ksymtab_boot_cpu_data
+c03ac450 r __ksymtab_drive_info
+c03ac458 r __ksymtab_screen_info
+c03ac460 r __ksymtab_apm_info
+c03ac468 r __ksymtab_edd
+c03ac470 r __ksymtab_dma_alloc_coherent
+c03ac478 r __ksymtab_dma_free_coherent
+c03ac480 r __ksymtab_dma_declare_coherent_memory
+c03ac488 r __ksymtab_dma_release_declared_memory
+c03ac490 r __ksymtab_dma_mark_declared_memory_occupied
+c03ac498 r __ksymtab_forbid_dac
+c03ac4a0 r __ksymtab___down_failed
+c03ac4a8 r __ksymtab___down_failed_interruptible
+c03ac4b0 r __ksymtab___down_failed_trylock
+c03ac4b8 r __ksymtab___up_wakeup
+c03ac4c0 r __ksymtab_csum_partial_copy_generic
+c03ac4c8 r __ksymtab___get_user_1
+c03ac4d0 r __ksymtab___get_user_2
+c03ac4d8 r __ksymtab___get_user_4
+c03ac4e0 r __ksymtab___put_user_1
+c03ac4e8 r __ksymtab___put_user_2
+c03ac4f0 r __ksymtab___put_user_4
+c03ac4f8 r __ksymtab___put_user_8
+c03ac500 r __ksymtab_strstr
+c03ac508 r __ksymtab___write_lock_failed
+c03ac510 r __ksymtab___read_lock_failed
+c03ac518 r __ksymtab_csum_partial
+c03ac520 r __ksymtab_dump_fpu
+c03ac528 r __ksymtab_efi_enabled
+c03ac530 r __ksymtab_pci_mem_start
+c03ac538 r __ksymtab_i8253_lock
+c03ac540 r __ksymtab_recalibrate_cpu_khz
+c03ac548 r __ksymtab_mtrr_add
+c03ac550 r __ksymtab_mtrr_del
+c03ac558 r __ksymtab_avail_to_resrv_perfctr_nmi
+c03ac560 r __ksymtab_avail_to_resrv_perfctr_nmi_bit
+c03ac568 r __ksymtab_reserve_perfctr_nmi
+c03ac570 r __ksymtab_release_perfctr_nmi
+c03ac578 r __ksymtab_reserve_evntsel_nmi
+c03ac580 r __ksymtab_release_evntsel_nmi
+c03ac588 r __ksymtab_acpi_disabled
+c03ac590 r __ksymtab_acpi_strict
+c03ac598 r __ksymtab_acpi_register_gsi
+c03ac5a0 r __ksymtab_acpi_register_ioapic
+c03ac5a8 r __ksymtab_acpi_unregister_ioapic
+c03ac5b0 r __ksymtab_pm_power_off
+c03ac5b8 r __ksymtab_flush_tlb_page
+c03ac5c0 r __ksymtab_smp_num_siblings
+c03ac5c8 r __ksymtab_cpu_sibling_map
+c03ac5d0 r __ksymtab_cpu_core_map
+c03ac5d8 r __ksymtab_cpu_online_map
+c03ac5e0 r __ksymtab_cpu_callout_map
+c03ac5e8 r __ksymtab_cpu_possible_map
+c03ac5f0 r __ksymtab_cpu_data
+c03ac5f8 r __ksymtab_x86_cpu_to_apicid
+c03ac600 r __ksymtab_per_cpu__this_cpu_off
+c03ac608 r __ksymtab_smp_call_function
+c03ac610 r __ksymtab_smp_call_function_single
+c03ac618 r __ksymtab_touch_nmi_watchdog
+c03ac620 r __ksymtab_nmi_active
+c03ac628 r __ksymtab_nmi_watchdog
+c03ac630 r __ksymtab_IO_APIC_get_PCI_irq_vector
+c03ac638 r __ksymtab_efi
+c03ac640 r __ksymtab___PAGE_KERNEL
+c03ac648 r __ksymtab___FIXADDR_TOP
+c03ac650 r __ksymtab___ioremap
+c03ac658 r __ksymtab_ioremap_nocache
+c03ac660 r __ksymtab_iounmap
+c03ac668 r __ksymtab_change_page_attr
+c03ac670 r __ksymtab_global_flush_tlb
+c03ac678 r __ksymtab_kmap
+c03ac680 r __ksymtab_kunmap
+c03ac688 r __ksymtab_kmap_atomic
+c03ac690 r __ksymtab_kunmap_atomic
+c03ac698 r __ksymtab_kmap_atomic_to_page
+c03ac6a0 r __ksymtab_wake_up_process
+c03ac6a8 r __ksymtab_per_cpu__kstat
+c03ac6b0 r __ksymtab_schedule
+c03ac6b8 r __ksymtab_default_wake_function
+c03ac6c0 r __ksymtab___wake_up
+c03ac6c8 r __ksymtab_complete
+c03ac6d0 r __ksymtab_complete_all
+c03ac6d8 r __ksymtab_wait_for_completion
+c03ac6e0 r __ksymtab_wait_for_completion_timeout
+c03ac6e8 r __ksymtab_wait_for_completion_interruptible
+c03ac6f0 r __ksymtab_wait_for_completion_interruptible_timeout
+c03ac6f8 r __ksymtab_interruptible_sleep_on
+c03ac700 r __ksymtab_interruptible_sleep_on_timeout
+c03ac708 r __ksymtab_sleep_on
+c03ac710 r __ksymtab_sleep_on_timeout
+c03ac718 r __ksymtab_set_user_nice
+c03ac720 r __ksymtab_cpu_present_map
+c03ac728 r __ksymtab_cond_resched
+c03ac730 r __ksymtab_cond_resched_lock
+c03ac738 r __ksymtab_cond_resched_softirq
+c03ac740 r __ksymtab_yield
+c03ac748 r __ksymtab_io_schedule
+c03ac750 r __ksymtab_nr_cpu_ids
+c03ac758 r __ksymtab___might_sleep
+c03ac760 r __ksymtab_free_task
+c03ac768 r __ksymtab_unshare_files
+c03ac770 r __ksymtab_register_exec_domain
+c03ac778 r __ksymtab_unregister_exec_domain
+c03ac780 r __ksymtab___set_personality
+c03ac788 r __ksymtab_panic_notifier_list
+c03ac790 r __ksymtab_panic_blink
+c03ac798 r __ksymtab_panic
+c03ac7a0 r __ksymtab_add_taint
+c03ac7a8 r __ksymtab_oops_in_progress
+c03ac7b0 r __ksymtab_printk
+c03ac7b8 r __ksymtab_vprintk
+c03ac7c0 r __ksymtab_acquire_console_sem
+c03ac7c8 r __ksymtab_try_acquire_console_sem
+c03ac7d0 r __ksymtab_release_console_sem
+c03ac7d8 r __ksymtab_console_conditional_schedule
+c03ac7e0 r __ksymtab_console_print
+c03ac7e8 r __ksymtab_console_stop
+c03ac7f0 r __ksymtab_console_start
+c03ac7f8 r __ksymtab_register_console
+c03ac800 r __ksymtab_unregister_console
+c03ac808 r __ksymtab___printk_ratelimit
+c03ac810 r __ksymtab_printk_ratelimit
+c03ac818 r __ksymtab_printk_timed_ratelimit
+c03ac820 r __ksymtab_allow_signal
+c03ac828 r __ksymtab_disallow_signal
+c03ac830 r __ksymtab_daemonize
+c03ac838 r __ksymtab_put_files_struct
+c03ac840 r __ksymtab_reset_files_struct
+c03ac848 r __ksymtab_complete_and_exit
+c03ac850 r __ksymtab_sys_tz
+c03ac858 r __ksymtab_current_kernel_time
+c03ac860 r __ksymtab_current_fs_time
+c03ac868 r __ksymtab_jiffies_to_msecs
+c03ac870 r __ksymtab_jiffies_to_usecs
+c03ac878 r __ksymtab_timespec_trunc
+c03ac880 r __ksymtab_mktime
+c03ac888 r __ksymtab_ns_to_timespec
+c03ac890 r __ksymtab_ns_to_timeval
+c03ac898 r __ksymtab_msecs_to_jiffies
+c03ac8a0 r __ksymtab_usecs_to_jiffies
+c03ac8a8 r __ksymtab_timespec_to_jiffies
+c03ac8b0 r __ksymtab_jiffies_to_timespec
+c03ac8b8 r __ksymtab_timeval_to_jiffies
+c03ac8c0 r __ksymtab_jiffies_to_timeval
+c03ac8c8 r __ksymtab_jiffies_to_clock_t
+c03ac8d0 r __ksymtab_clock_t_to_jiffies
+c03ac8d8 r __ksymtab_jiffies_64_to_clock_t
+c03ac8e0 r __ksymtab_get_jiffies_64
+c03ac8e8 r __ksymtab_jiffies
+c03ac8f0 r __ksymtab_local_bh_disable
+c03ac8f8 r __ksymtab__local_bh_enable
+c03ac900 r __ksymtab_local_bh_enable
+c03ac908 r __ksymtab_local_bh_enable_ip
+c03ac910 r __ksymtab_raise_softirq_irqoff
+c03ac918 r __ksymtab___tasklet_schedule
+c03ac920 r __ksymtab___tasklet_hi_schedule
+c03ac928 r __ksymtab_tasklet_init
+c03ac930 r __ksymtab_tasklet_kill
+c03ac938 r __ksymtab_on_each_cpu
+c03ac940 r __ksymtab_ioport_resource
+c03ac948 r __ksymtab_iomem_resource
+c03ac950 r __ksymtab_request_resource
+c03ac958 r __ksymtab_release_resource
+c03ac960 r __ksymtab_allocate_resource
+c03ac968 r __ksymtab_adjust_resource
+c03ac970 r __ksymtab___request_region
+c03ac978 r __ksymtab___check_region
+c03ac980 r __ksymtab___release_region
+c03ac988 r __ksymtab___devm_request_region
+c03ac990 r __ksymtab___devm_release_region
+c03ac998 r __ksymtab_proc_dointvec
+c03ac9a0 r __ksymtab_proc_dointvec_jiffies
+c03ac9a8 r __ksymtab_proc_dointvec_minmax
+c03ac9b0 r __ksymtab_proc_dointvec_userhz_jiffies
+c03ac9b8 r __ksymtab_proc_dointvec_ms_jiffies
+c03ac9c0 r __ksymtab_proc_dostring
+c03ac9c8 r __ksymtab_proc_doulongvec_minmax
+c03ac9d0 r __ksymtab_proc_doulongvec_ms_jiffies_minmax
+c03ac9d8 r __ksymtab_register_sysctl_table
+c03ac9e0 r __ksymtab_sysctl_intvec
+c03ac9e8 r __ksymtab_sysctl_jiffies
+c03ac9f0 r __ksymtab_sysctl_ms_jiffies
+c03ac9f8 r __ksymtab_sysctl_string
+c03aca00 r __ksymtab_sysctl_data
+c03aca08 r __ksymtab_unregister_sysctl_table
+c03aca10 r __ksymtab_securebits
+c03aca18 r __ksymtab_cap_bset
+c03aca20 r __ksymtab___capable
+c03aca28 r __ksymtab_capable
+c03aca30 r __ksymtab_jiffies_64
+c03aca38 r __ksymtab_boot_tvec_bases
+c03aca40 r __ksymtab_init_timer
+c03aca48 r __ksymtab_init_timer_deferrable
+c03aca50 r __ksymtab___mod_timer
+c03aca58 r __ksymtab_mod_timer
+c03aca60 r __ksymtab_del_timer
+c03aca68 r __ksymtab_try_to_del_timer_sync
+c03aca70 r __ksymtab_del_timer_sync
+c03aca78 r __ksymtab_avenrun
+c03aca80 r __ksymtab_schedule_timeout
+c03aca88 r __ksymtab_schedule_timeout_interruptible
+c03aca90 r __ksymtab_schedule_timeout_uninterruptible
+c03aca98 r __ksymtab_msleep
+c03acaa0 r __ksymtab_msleep_interruptible
+c03acaa8 r __ksymtab_kill_pgrp
+c03acab0 r __ksymtab_kill_pid
+c03acab8 r __ksymtab_recalc_sigpending
+c03acac0 r __ksymtab_flush_signals
+c03acac8 r __ksymtab_force_sig
+c03acad0 r __ksymtab_kill_proc
+c03acad8 r __ksymtab_ptrace_notify
+c03acae0 r __ksymtab_send_sig
+c03acae8 r __ksymtab_send_sig_info
+c03acaf0 r __ksymtab_sigprocmask
+c03acaf8 r __ksymtab_block_all_signals
+c03acb00 r __ksymtab_unblock_all_signals
+c03acb08 r __ksymtab_overflowuid
+c03acb10 r __ksymtab_overflowgid
+c03acb18 r __ksymtab_fs_overflowuid
+c03acb20 r __ksymtab_fs_overflowgid
+c03acb28 r __ksymtab_cad_pid
+c03acb30 r __ksymtab_register_reboot_notifier
+c03acb38 r __ksymtab_unregister_reboot_notifier
+c03acb40 r __ksymtab_groups_alloc
+c03acb48 r __ksymtab_groups_free
+c03acb50 r __ksymtab_set_current_groups
+c03acb58 r __ksymtab_in_group_p
+c03acb60 r __ksymtab_in_egroup_p
+c03acb68 r __ksymtab_uts_sem
+c03acb70 r __ksymtab_request_module
+c03acb78 r __ksymtab_call_usermodehelper_freeinfo
+c03acb80 r __ksymtab_call_usermodehelper_setup
+c03acb88 r __ksymtab_call_usermodehelper_setkeys
+c03acb90 r __ksymtab_call_usermodehelper_setcleanup
+c03acb98 r __ksymtab_call_usermodehelper_stdinpipe
+c03acba0 r __ksymtab_call_usermodehelper_exec
+c03acba8 r __ksymtab_call_usermodehelper_pipe
+c03acbb0 r __ksymtab_cancel_rearming_delayed_work
+c03acbb8 r __ksymtab_schedule_work
+c03acbc0 r __ksymtab_schedule_delayed_work
+c03acbc8 r __ksymtab_schedule_delayed_work_on
+c03acbd0 r __ksymtab_flush_scheduled_work
+c03acbd8 r __ksymtab_find_task_by_pid_type
+c03acbe0 r __ksymtab_param_set_byte
+c03acbe8 r __ksymtab_param_get_byte
+c03acbf0 r __ksymtab_param_set_short
+c03acbf8 r __ksymtab_param_get_short
+c03acc00 r __ksymtab_param_set_ushort
+c03acc08 r __ksymtab_param_get_ushort
+c03acc10 r __ksymtab_param_set_int
+c03acc18 r __ksymtab_param_get_int
+c03acc20 r __ksymtab_param_set_uint
+c03acc28 r __ksymtab_param_get_uint
+c03acc30 r __ksymtab_param_set_long
+c03acc38 r __ksymtab_param_get_long
+c03acc40 r __ksymtab_param_set_ulong
+c03acc48 r __ksymtab_param_get_ulong
+c03acc50 r __ksymtab_param_set_charp
+c03acc58 r __ksymtab_param_get_charp
+c03acc60 r __ksymtab_param_set_bool
+c03acc68 r __ksymtab_param_get_bool
+c03acc70 r __ksymtab_param_set_invbool
+c03acc78 r __ksymtab_param_get_invbool
+c03acc80 r __ksymtab_param_array_set
+c03acc88 r __ksymtab_param_array_get
+c03acc90 r __ksymtab_param_set_copystring
+c03acc98 r __ksymtab_param_get_string
+c03acca0 r __ksymtab_kthread_should_stop
+c03acca8 r __ksymtab_kthread_create
+c03accb0 r __ksymtab_kthread_bind
+c03accb8 r __ksymtab_kthread_stop
+c03accc0 r __ksymtab_init_waitqueue_head
+c03accc8 r __ksymtab_add_wait_queue
+c03accd0 r __ksymtab_add_wait_queue_exclusive
+c03accd8 r __ksymtab_remove_wait_queue
+c03acce0 r __ksymtab_prepare_to_wait
+c03acce8 r __ksymtab_prepare_to_wait_exclusive
+c03accf0 r __ksymtab_finish_wait
+c03accf8 r __ksymtab_autoremove_wake_function
+c03acd00 r __ksymtab_wake_bit_function
+c03acd08 r __ksymtab___wait_on_bit
+c03acd10 r __ksymtab_out_of_line_wait_on_bit
+c03acd18 r __ksymtab___wait_on_bit_lock
+c03acd20 r __ksymtab_out_of_line_wait_on_bit_lock
+c03acd28 r __ksymtab___wake_up_bit
+c03acd30 r __ksymtab_wake_up_bit
+c03acd38 r __ksymtab_bit_waitqueue
+c03acd40 r __ksymtab_kfifo_init
+c03acd48 r __ksymtab_kfifo_alloc
+c03acd50 r __ksymtab_kfifo_free
+c03acd58 r __ksymtab___kfifo_put
+c03acd60 r __ksymtab___kfifo_get
+c03acd68 r __ksymtab___mutex_init
+c03acd70 r __ksymtab_mutex_lock
+c03acd78 r __ksymtab_mutex_unlock
+c03acd80 r __ksymtab_mutex_lock_interruptible
+c03acd88 r __ksymtab_mutex_trylock
+c03acd90 r __ksymtab_down_read
+c03acd98 r __ksymtab_down_read_trylock
+c03acda0 r __ksymtab_down_write
+c03acda8 r __ksymtab_down_write_trylock
+c03acdb0 r __ksymtab_up_read
+c03acdb8 r __ksymtab_up_write
+c03acdc0 r __ksymtab_downgrade_write
+c03acdc8 r __ksymtab_xtime_lock
+c03acdd0 r __ksymtab_xtime
+c03acdd8 r __ksymtab_getnstimeofday
+c03acde0 r __ksymtab_do_gettimeofday
+c03acde8 r __ksymtab_do_settimeofday
+c03acdf0 r __ksymtab_getboottime
+c03acdf8 r __ksymtab_monotonic_to_bootbased
+c03ace00 r __ksymtab_clocksource_register
+c03ace08 r __ksymtab_request_dma
+c03ace10 r __ksymtab_free_dma
+c03ace18 r __ksymtab_dma_spin_lock
+c03ace20 r __ksymtab__spin_trylock
+c03ace28 r __ksymtab__read_trylock
+c03ace30 r __ksymtab__write_trylock
+c03ace38 r __ksymtab__read_lock
+c03ace40 r __ksymtab__spin_lock_irqsave
+c03ace48 r __ksymtab__spin_lock_irq
+c03ace50 r __ksymtab__spin_lock_bh
+c03ace58 r __ksymtab__read_lock_irqsave
+c03ace60 r __ksymtab__read_lock_irq
+c03ace68 r __ksymtab__read_lock_bh
+c03ace70 r __ksymtab__write_lock_irqsave
+c03ace78 r __ksymtab__write_lock_irq
+c03ace80 r __ksymtab__write_lock_bh
+c03ace88 r __ksymtab__spin_lock
+c03ace90 r __ksymtab__write_lock
+c03ace98 r __ksymtab__spin_unlock
+c03acea0 r __ksymtab__write_unlock
+c03acea8 r __ksymtab__read_unlock
+c03aceb0 r __ksymtab__spin_unlock_irqrestore
+c03aceb8 r __ksymtab__spin_unlock_irq
+c03acec0 r __ksymtab__spin_unlock_bh
+c03acec8 r __ksymtab__read_unlock_irqrestore
+c03aced0 r __ksymtab__read_unlock_irq
+c03aced8 r __ksymtab__read_unlock_bh
+c03acee0 r __ksymtab__write_unlock_irqrestore
+c03acee8 r __ksymtab__write_unlock_irq
+c03acef0 r __ksymtab__write_unlock_bh
+c03acef8 r __ksymtab__spin_trylock_bh
+c03acf00 r __ksymtab_in_lock_functions
+c03acf08 r __ksymtab_register_module_notifier
+c03acf10 r __ksymtab_unregister_module_notifier
+c03acf18 r __ksymtab___module_put_and_exit
+c03acf20 r __ksymtab_module_refcount
+c03acf28 r __ksymtab___symbol_put
+c03acf30 r __ksymtab_module_put
+c03acf38 r __ksymtab_module_add_driver
+c03acf40 r __ksymtab_module_remove_driver
+c03acf48 r __ksymtab___print_symbol
+c03acf50 r __ksymtab_pm_suspend
+c03acf58 r __ksymtab_refrigerator
+c03acf60 r __ksymtab_pm_register
+c03acf68 r __ksymtab_pm_send_all
+c03acf70 r __ksymtab_pm_active
+c03acf78 r __ksymtab_touch_softlockup_watchdog
+c03acf80 r __ksymtab_touch_all_softlockup_watchdogs
+c03acf88 r __ksymtab_synchronize_irq
+c03acf90 r __ksymtab_disable_irq_nosync
+c03acf98 r __ksymtab_disable_irq
+c03acfa0 r __ksymtab_enable_irq
+c03acfa8 r __ksymtab_set_irq_wake
+c03acfb0 r __ksymtab_free_irq
+c03acfb8 r __ksymtab_request_irq
+c03acfc0 r __ksymtab_set_irq_chip
+c03acfc8 r __ksymtab_set_irq_type
+c03acfd0 r __ksymtab_set_irq_data
+c03acfd8 r __ksymtab_set_irq_chip_data
+c03acfe0 r __ksymtab_devm_request_irq
+c03acfe8 r __ksymtab_devm_free_irq
+c03acff0 r __ksymtab_probe_irq_on
+c03acff8 r __ksymtab_probe_irq_mask
+c03ad000 r __ksymtab_probe_irq_off
+c03ad008 r __ksymtab_filemap_fdatawrite
+c03ad010 r __ksymtab_filemap_flush
+c03ad018 r __ksymtab_sync_page_range
+c03ad020 r __ksymtab_sync_page_range_nolock
+c03ad028 r __ksymtab_filemap_fdatawait
+c03ad030 r __ksymtab_filemap_write_and_wait
+c03ad038 r __ksymtab_add_to_page_cache
+c03ad040 r __ksymtab_wait_on_page_bit
+c03ad048 r __ksymtab_unlock_page
+c03ad050 r __ksymtab_end_page_writeback
+c03ad058 r __ksymtab___lock_page
+c03ad060 r __ksymtab_find_get_page
+c03ad068 r __ksymtab_find_lock_page
+c03ad070 r __ksymtab_find_or_create_page
+c03ad078 r __ksymtab_find_get_pages_contig
+c03ad080 r __ksymtab_find_get_pages_tag
+c03ad088 r __ksymtab_grab_cache_page_nowait
+c03ad090 r __ksymtab_do_generic_mapping_read
+c03ad098 r __ksymtab_generic_segment_checks
+c03ad0a0 r __ksymtab_generic_file_aio_read
+c03ad0a8 r __ksymtab_generic_file_sendfile
+c03ad0b0 r __ksymtab_filemap_fault
+c03ad0b8 r __ksymtab_filemap_nopage
+c03ad0c0 r __ksymtab_filemap_populate
+c03ad0c8 r __ksymtab_generic_file_mmap
+c03ad0d0 r __ksymtab_generic_file_readonly_mmap
+c03ad0d8 r __ksymtab_read_cache_page_async
+c03ad0e0 r __ksymtab_read_cache_page
+c03ad0e8 r __ksymtab_should_remove_suid
+c03ad0f0 r __ksymtab_remove_suid
+c03ad0f8 r __ksymtab_generic_write_checks
+c03ad100 r __ksymtab_generic_file_direct_write
+c03ad108 r __ksymtab_generic_file_buffered_write
+c03ad110 r __ksymtab_generic_file_aio_write_nolock
+c03ad118 r __ksymtab_generic_file_aio_write
+c03ad120 r __ksymtab_try_to_release_page
+c03ad128 r __ksymtab_mempool_create
+c03ad130 r __ksymtab_mempool_create_node
+c03ad138 r __ksymtab_mempool_resize
+c03ad140 r __ksymtab_mempool_destroy
+c03ad148 r __ksymtab_mempool_alloc
+c03ad150 r __ksymtab_mempool_free
+c03ad158 r __ksymtab_mempool_alloc_slab
+c03ad160 r __ksymtab_mempool_free_slab
+c03ad168 r __ksymtab_mempool_kmalloc
+c03ad170 r __ksymtab_mempool_kzalloc
+c03ad178 r __ksymtab_mempool_kfree
+c03ad180 r __ksymtab_mempool_alloc_pages
+c03ad188 r __ksymtab_mempool_free_pages
+c03ad190 r __ksymtab_node_online_map
+c03ad198 r __ksymtab_node_possible_map
+c03ad1a0 r __ksymtab_totalram_pages
+c03ad1a8 r __ksymtab___alloc_pages
+c03ad1b0 r __ksymtab___get_free_pages
+c03ad1b8 r __ksymtab_get_zeroed_page
+c03ad1c0 r __ksymtab___free_pages
+c03ad1c8 r __ksymtab_free_pages
+c03ad1d0 r __ksymtab_si_meminfo
+c03ad1d8 r __ksymtab_contig_page_data
+c03ad1e0 r __ksymtab_laptop_mode
+c03ad1e8 r __ksymtab_balance_dirty_pages_ratelimited_nr
+c03ad1f0 r __ksymtab_write_cache_pages
+c03ad1f8 r __ksymtab_generic_writepages
+c03ad200 r __ksymtab_write_one_page
+c03ad208 r __ksymtab___set_page_dirty_nobuffers
+c03ad210 r __ksymtab_redirty_page_for_writepage
+c03ad218 r __ksymtab_set_page_dirty
+c03ad220 r __ksymtab_set_page_dirty_lock
+c03ad228 r __ksymtab_clear_page_dirty_for_io
+c03ad230 r __ksymtab_test_set_page_writeback
+c03ad238 r __ksymtab_mapping_tagged
+c03ad240 r __ksymtab_default_unplug_io_fn
+c03ad248 r __ksymtab_read_cache_pages
+c03ad250 r __ksymtab_put_page
+c03ad258 r __ksymtab_put_pages_list
+c03ad260 r __ksymtab_mark_page_accessed
+c03ad268 r __ksymtab___pagevec_release
+c03ad270 r __ksymtab___pagevec_lru_add
+c03ad278 r __ksymtab_pagevec_lookup
+c03ad280 r __ksymtab_pagevec_lookup_tag
+c03ad288 r __ksymtab_cancel_dirty_page
+c03ad290 r __ksymtab_truncate_inode_pages_range
+c03ad298 r __ksymtab_truncate_inode_pages
+c03ad2a0 r __ksymtab_invalidate_mapping_pages
+c03ad2a8 r __ksymtab_set_shrinker
+c03ad2b0 r __ksymtab_remove_shrinker
+c03ad2b8 r __ksymtab___kzalloc
+c03ad2c0 r __ksymtab_kstrdup
+c03ad2c8 r __ksymtab_kstrndup
+c03ad2d0 r __ksymtab_kmemdup
+c03ad2d8 r __ksymtab_strndup_user
+c03ad2e0 r __ksymtab_per_cpu__vm_event_states
+c03ad2e8 r __ksymtab_vm_stat
+c03ad2f0 r __ksymtab___mod_zone_page_state
+c03ad2f8 r __ksymtab_mod_zone_page_state
+c03ad300 r __ksymtab___inc_zone_page_state
+c03ad308 r __ksymtab___dec_zone_page_state
+c03ad310 r __ksymtab_inc_zone_page_state
+c03ad318 r __ksymtab_dec_zone_page_state
+c03ad320 r __ksymtab_refresh_vm_stats
+c03ad328 r __ksymtab_clear_bdi_congested
+c03ad330 r __ksymtab_set_bdi_congested
+c03ad338 r __ksymtab_congestion_wait
+c03ad340 r __ksymtab_congestion_wait_interruptible
+c03ad348 r __ksymtab_congestion_end
+c03ad350 r __ksymtab_install_page
+c03ad358 r __ksymtab_kmap_high
+c03ad360 r __ksymtab_kunmap_high
+c03ad368 r __ksymtab_page_address
+c03ad370 r __ksymtab_max_mapnr
+c03ad378 r __ksymtab_mem_map
+c03ad380 r __ksymtab_num_physpages
+c03ad388 r __ksymtab_high_memory
+c03ad390 r __ksymtab_vmalloc_earlyreserve
+c03ad398 r __ksymtab_get_user_pages
+c03ad3a0 r __ksymtab_vm_insert_page
+c03ad3a8 r __ksymtab_vm_insert_pfn
+c03ad3b0 r __ksymtab_remap_pfn_range
+c03ad3b8 r __ksymtab_unmap_mapping_range
+c03ad3c0 r __ksymtab_vmtruncate
+c03ad3c8 r __ksymtab_vmalloc_to_page
+c03ad3d0 r __ksymtab_vmalloc_to_pfn
+c03ad3d8 r __ksymtab_can_do_mlock
+c03ad3e0 r __ksymtab_vm_get_page_prot
+c03ad3e8 r __ksymtab___vm_enough_memory
+c03ad3f0 r __ksymtab_do_mmap_pgoff
+c03ad3f8 r __ksymtab_get_unmapped_area
+c03ad400 r __ksymtab_find_vma
+c03ad408 r __ksymtab_do_munmap
+c03ad410 r __ksymtab_do_brk
+c03ad418 r __ksymtab_vfree
+c03ad420 r __ksymtab_vunmap
+c03ad428 r __ksymtab_vmap
+c03ad430 r __ksymtab___vmalloc
+c03ad438 r __ksymtab_vmalloc
+c03ad440 r __ksymtab_vmalloc_user
+c03ad448 r __ksymtab_vmalloc_node
+c03ad450 r __ksymtab_vmalloc_32
+c03ad458 r __ksymtab_vmalloc_32_user
+c03ad460 r __ksymtab_remap_vmalloc_range
+c03ad468 r __ksymtab_blk_queue_bounce
+c03ad470 r __ksymtab_malloc_sizes
+c03ad478 r __ksymtab_kmem_cache_create
+c03ad480 r __ksymtab_kmem_cache_shrink
+c03ad488 r __ksymtab_kmem_cache_destroy
+c03ad490 r __ksymtab_kmem_cache_alloc
+c03ad498 r __ksymtab_kmem_cache_zalloc
+c03ad4a0 r __ksymtab___kmalloc
+c03ad4a8 r __ksymtab_krealloc
+c03ad4b0 r __ksymtab_kmem_cache_free
+c03ad4b8 r __ksymtab_kfree
+c03ad4c0 r __ksymtab_kmem_cache_size
+c03ad4c8 r __ksymtab_vfs_statfs
+c03ad4d0 r __ksymtab_filp_open
+c03ad4d8 r __ksymtab_dentry_open
+c03ad4e0 r __ksymtab_get_unused_fd
+c03ad4e8 r __ksymtab_put_unused_fd
+c03ad4f0 r __ksymtab_fd_install
+c03ad4f8 r __ksymtab_filp_close
+c03ad500 r __ksymtab_sys_close
+c03ad508 r __ksymtab_generic_file_open
+c03ad510 r __ksymtab_nonseekable_open
+c03ad518 r __ksymtab_generic_ro_fops
+c03ad520 r __ksymtab_generic_file_llseek
+c03ad528 r __ksymtab_remote_llseek
+c03ad530 r __ksymtab_no_llseek
+c03ad538 r __ksymtab_default_llseek
+c03ad540 r __ksymtab_vfs_llseek
+c03ad548 r __ksymtab_do_sync_read
+c03ad550 r __ksymtab_vfs_read
+c03ad558 r __ksymtab_do_sync_write
+c03ad560 r __ksymtab_vfs_write
+c03ad568 r __ksymtab_vfs_readv
+c03ad570 r __ksymtab_vfs_writev
+c03ad578 r __ksymtab_get_empty_filp
+c03ad580 r __ksymtab_fput
+c03ad588 r __ksymtab_fget
+c03ad590 r __ksymtab_deactivate_super
+c03ad598 r __ksymtab_lock_super
+c03ad5a0 r __ksymtab_unlock_super
+c03ad5a8 r __ksymtab_generic_shutdown_super
+c03ad5b0 r __ksymtab_sget
+c03ad5b8 r __ksymtab_drop_super
+c03ad5c0 r __ksymtab_get_super
+c03ad5c8 r __ksymtab_set_anon_super
+c03ad5d0 r __ksymtab_kill_anon_super
+c03ad5d8 r __ksymtab_kill_litter_super
+c03ad5e0 r __ksymtab_get_sb_bdev
+c03ad5e8 r __ksymtab_kill_block_super
+c03ad5f0 r __ksymtab_get_sb_nodev
+c03ad5f8 r __ksymtab_get_sb_single
+c03ad600 r __ksymtab_kern_mount
+c03ad608 r __ksymtab_register_chrdev_region
+c03ad610 r __ksymtab_unregister_chrdev_region
+c03ad618 r __ksymtab_alloc_chrdev_region
+c03ad620 r __ksymtab_cdev_init
+c03ad628 r __ksymtab_cdev_alloc
+c03ad630 r __ksymtab_cdev_del
+c03ad638 r __ksymtab_cdev_add
+c03ad640 r __ksymtab_register_chrdev
+c03ad648 r __ksymtab_unregister_chrdev
+c03ad650 r __ksymtab_directly_mappable_cdev_bdi
+c03ad658 r __ksymtab_generic_fillattr
+c03ad660 r __ksymtab_vfs_getattr
+c03ad668 r __ksymtab_vfs_stat
+c03ad670 r __ksymtab_vfs_lstat
+c03ad678 r __ksymtab_vfs_fstat
+c03ad680 r __ksymtab_inode_add_bytes
+c03ad688 r __ksymtab_inode_sub_bytes
+c03ad690 r __ksymtab_inode_get_bytes
+c03ad698 r __ksymtab_inode_set_bytes
+c03ad6a0 r __ksymtab_suid_dumpable
+c03ad6a8 r __ksymtab_register_binfmt
+c03ad6b0 r __ksymtab_unregister_binfmt
+c03ad6b8 r __ksymtab_copy_strings_kernel
+c03ad6c0 r __ksymtab_setup_arg_pages
+c03ad6c8 r __ksymtab_open_exec
+c03ad6d0 r __ksymtab_kernel_read
+c03ad6d8 r __ksymtab_flush_old_exec
+c03ad6e0 r __ksymtab_prepare_binprm
+c03ad6e8 r __ksymtab_compute_creds
+c03ad6f0 r __ksymtab_remove_arg_zero
+c03ad6f8 r __ksymtab_search_binary_handler
+c03ad700 r __ksymtab_set_binfmt
+c03ad708 r __ksymtab___user_walk
+c03ad710 r __ksymtab___user_walk_fd
+c03ad718 r __ksymtab_follow_down
+c03ad720 r __ksymtab_follow_up
+c03ad728 r __ksymtab_get_write_access
+c03ad730 r __ksymtab_getname
+c03ad738 r __ksymtab_lock_rename
+c03ad740 r __ksymtab_lookup_one_len_nd
+c03ad748 r __ksymtab_page_follow_link_light
+c03ad750 r __ksymtab_page_put_link
+c03ad758 r __ksymtab_page_readlink
+c03ad760 r __ksymtab___page_symlink
+c03ad768 r __ksymtab_page_symlink
+c03ad770 r __ksymtab_page_symlink_inode_operations
+c03ad778 r __ksymtab_path_lookup
+c03ad780 r __ksymtab_path_release
+c03ad788 r __ksymtab_path_walk
+c03ad790 r __ksymtab_permission
+c03ad798 r __ksymtab_vfs_permission
+c03ad7a0 r __ksymtab_file_permission
+c03ad7a8 r __ksymtab_unlock_rename
+c03ad7b0 r __ksymtab_vfs_create
+c03ad7b8 r __ksymtab_vfs_follow_link
+c03ad7c0 r __ksymtab_vfs_link
+c03ad7c8 r __ksymtab_vfs_mkdir
+c03ad7d0 r __ksymtab_vfs_mknod
+c03ad7d8 r __ksymtab_generic_permission
+c03ad7e0 r __ksymtab_vfs_readlink
+c03ad7e8 r __ksymtab_vfs_rename
+c03ad7f0 r __ksymtab_vfs_rmdir
+c03ad7f8 r __ksymtab_vfs_symlink
+c03ad800 r __ksymtab_vfs_unlink
+c03ad808 r __ksymtab_dentry_unhash
+c03ad810 r __ksymtab_generic_readlink
+c03ad818 r __ksymtab___f_setown
+c03ad820 r __ksymtab_f_setown
+c03ad828 r __ksymtab_fasync_helper
+c03ad830 r __ksymtab___kill_fasync
+c03ad838 r __ksymtab_kill_fasync
+c03ad840 r __ksymtab_vfs_readdir
+c03ad848 r __ksymtab_poll_initwait
+c03ad850 r __ksymtab_poll_freewait
+c03ad858 r __ksymtab_locks_init_lock
+c03ad860 r __ksymtab_locks_copy_lock
+c03ad868 r __ksymtab_posix_test_lock
+c03ad870 r __ksymtab_posix_lock_file
+c03ad878 r __ksymtab_posix_lock_file_wait
+c03ad880 r __ksymtab_locks_mandatory_area
+c03ad888 r __ksymtab_lease_modify
+c03ad890 r __ksymtab___break_lease
+c03ad898 r __ksymtab_lease_get_mtime
+c03ad8a0 r __ksymtab_setlease
+c03ad8a8 r __ksymtab_flock_lock_file_wait
+c03ad8b0 r __ksymtab_locks_remove_posix
+c03ad8b8 r __ksymtab_posix_unblock_lock
+c03ad8c0 r __ksymtab_lock_may_read
+c03ad8c8 r __ksymtab_lock_may_write
+c03ad8d0 r __ksymtab_dcache_lock
+c03ad8d8 r __ksymtab_d_instantiate_unique
+c03ad8e0 r __ksymtab_d_genocide
+c03ad8e8 r __ksymtab_d_alloc
+c03ad8f0 r __ksymtab_d_alloc_anon
+c03ad8f8 r __ksymtab_d_alloc_root
+c03ad900 r __ksymtab_d_delete
+c03ad908 r __ksymtab_d_find_alias
+c03ad910 r __ksymtab_d_instantiate
+c03ad918 r __ksymtab_d_invalidate
+c03ad920 r __ksymtab_d_lookup
+c03ad928 r __ksymtab_d_move
+c03ad930 r __ksymtab_d_path
+c03ad938 r __ksymtab_d_prune_aliases
+c03ad940 r __ksymtab_d_rehash
+c03ad948 r __ksymtab_d_splice_alias
+c03ad950 r __ksymtab_d_validate
+c03ad958 r __ksymtab_dget_locked
+c03ad960 r __ksymtab_dput
+c03ad968 r __ksymtab_find_inode_number
+c03ad970 r __ksymtab_have_submounts
+c03ad978 r __ksymtab_names_cachep
+c03ad980 r __ksymtab_shrink_dcache_parent
+c03ad988 r __ksymtab_shrink_dcache_sb
+c03ad990 r __ksymtab_inode_init_once
+c03ad998 r __ksymtab_clear_inode
+c03ad9a0 r __ksymtab_invalidate_inodes
+c03ad9a8 r __ksymtab_new_inode
+c03ad9b0 r __ksymtab_unlock_new_inode
+c03ad9b8 r __ksymtab_iunique
+c03ad9c0 r __ksymtab_igrab
+c03ad9c8 r __ksymtab_ilookup5_nowait
+c03ad9d0 r __ksymtab_ilookup5
+c03ad9d8 r __ksymtab_ilookup
+c03ad9e0 r __ksymtab_iget5_locked
+c03ad9e8 r __ksymtab_iget_locked
+c03ad9f0 r __ksymtab___insert_inode_hash
+c03ad9f8 r __ksymtab_remove_inode_hash
+c03ada00 r __ksymtab_generic_delete_inode
+c03ada08 r __ksymtab_iput
+c03ada10 r __ksymtab_bmap
+c03ada18 r __ksymtab_touch_atime
+c03ada20 r __ksymtab_file_update_time
+c03ada28 r __ksymtab_inode_needs_sync
+c03ada30 r __ksymtab_inode_double_lock
+c03ada38 r __ksymtab_inode_double_unlock
+c03ada40 r __ksymtab_init_special_inode
+c03ada48 r __ksymtab_inode_change_ok
+c03ada50 r __ksymtab_inode_setattr
+c03ada58 r __ksymtab_notify_change
+c03ada60 r __ksymtab_make_bad_inode
+c03ada68 r __ksymtab_is_bad_inode
+c03ada70 r __ksymtab_register_filesystem
+c03ada78 r __ksymtab_unregister_filesystem
+c03ada80 r __ksymtab_get_fs_type
+c03ada88 r __ksymtab_simple_set_mnt
+c03ada90 r __ksymtab_mntput_no_expire
+c03ada98 r __ksymtab_mnt_pin
+c03adaa0 r __ksymtab_mnt_unpin
+c03adaa8 r __ksymtab_may_umount_tree
+c03adab0 r __ksymtab_may_umount
+c03adab8 r __ksymtab_kick_iocb
+c03adac0 r __ksymtab_aio_complete
+c03adac8 r __ksymtab_aio_put_req
+c03adad0 r __ksymtab_wait_on_sync_kiocb
+c03adad8 r __ksymtab_seq_open
+c03adae0 r __ksymtab_seq_read
+c03adae8 r __ksymtab_seq_lseek
+c03adaf0 r __ksymtab_seq_release
+c03adaf8 r __ksymtab_seq_escape
+c03adb00 r __ksymtab_seq_printf
+c03adb08 r __ksymtab_seq_path
+c03adb10 r __ksymtab_single_open
+c03adb18 r __ksymtab_single_release
+c03adb20 r __ksymtab_seq_release_private
+c03adb28 r __ksymtab_seq_putc
+c03adb30 r __ksymtab_seq_puts
+c03adb38 r __ksymtab_generic_getxattr
+c03adb40 r __ksymtab_generic_listxattr
+c03adb48 r __ksymtab_generic_setxattr
+c03adb50 r __ksymtab_generic_removexattr
+c03adb58 r __ksymtab_dcache_dir_close
+c03adb60 r __ksymtab_dcache_dir_lseek
+c03adb68 r __ksymtab_dcache_dir_open
+c03adb70 r __ksymtab_dcache_readdir
+c03adb78 r __ksymtab_dcache_readdir_filter
+c03adb80 r __ksymtab_generic_read_dir
+c03adb88 r __ksymtab_get_sb_pseudo
+c03adb90 r __ksymtab_simple_commit_write
+c03adb98 r __ksymtab_simple_dir_inode_operations
+c03adba0 r __ksymtab_simple_dir_operations
+c03adba8 r __ksymtab_simple_empty
+c03adbb0 r __ksymtab_d_alloc_name
+c03adbb8 r __ksymtab_simple_fill_super
+c03adbc0 r __ksymtab_simple_getattr
+c03adbc8 r __ksymtab_simple_link
+c03adbd0 r __ksymtab_simple_lookup
+c03adbd8 r __ksymtab_simple_pin_fs
+c03adbe0 r __ksymtab_simple_prepare_write
+c03adbe8 r __ksymtab_simple_readpage
+c03adbf0 r __ksymtab_simple_release_fs
+c03adbf8 r __ksymtab_simple_rename
+c03adc00 r __ksymtab_simple_rmdir
+c03adc08 r __ksymtab_simple_statfs
+c03adc10 r __ksymtab_simple_sync_file
+c03adc18 r __ksymtab_simple_unlink
+c03adc20 r __ksymtab_simple_read_from_buffer
+c03adc28 r __ksymtab_simple_transaction_get
+c03adc30 r __ksymtab_simple_transaction_read
+c03adc38 r __ksymtab_simple_transaction_release
+c03adc40 r __ksymtab___mark_inode_dirty
+c03adc48 r __ksymtab_write_inode_now
+c03adc50 r __ksymtab_sync_inode
+c03adc58 r __ksymtab_generic_osync_inode
+c03adc60 r __ksymtab_drop_pagecache_sb
+c03adc68 r __ksymtab_generic_file_splice_read
+c03adc70 r __ksymtab___splice_from_pipe
+c03adc78 r __ksymtab_generic_file_splice_write_nolock
+c03adc80 r __ksymtab_generic_file_splice_write
+c03adc88 r __ksymtab_generic_splice_sendpage
+c03adc90 r __ksymtab___lock_buffer
+c03adc98 r __ksymtab_sync_blockdev
+c03adca0 r __ksymtab_freeze_bdev
+c03adca8 r __ksymtab_thaw_bdev
+c03adcb0 r __ksymtab_mark_buffer_async_write
+c03adcb8 r __ksymtab_sync_mapping_buffers
+c03adcc0 r __ksymtab_mark_buffer_dirty_inode
+c03adcc8 r __ksymtab___set_page_dirty_buffers
+c03adcd0 r __ksymtab___find_get_block
+c03adcd8 r __ksymtab___getblk
+c03adce0 r __ksymtab___breadahead
+c03adce8 r __ksymtab___bread
+c03adcf0 r __ksymtab_set_bh_page
+c03adcf8 r __ksymtab_block_invalidatepage
+c03add00 r __ksymtab_create_empty_buffers
+c03add08 r __ksymtab_unmap_underlying_metadata
+c03add10 r __ksymtab_nobh_prepare_write
+c03add18 r __ksymtab_nobh_commit_write
+c03add20 r __ksymtab_nobh_writepage
+c03add28 r __ksymtab_nobh_truncate_page
+c03add30 r __ksymtab_try_to_free_buffers
+c03add38 r __ksymtab_alloc_buffer_head
+c03add40 r __ksymtab_free_buffer_head
+c03add48 r __ksymtab___bforget
+c03add50 r __ksymtab___brelse
+c03add58 r __ksymtab___wait_on_buffer
+c03add60 r __ksymtab_block_commit_write
+c03add68 r __ksymtab_block_prepare_write
+c03add70 r __ksymtab_block_read_full_page
+c03add78 r __ksymtab_block_sync_page
+c03add80 r __ksymtab_block_truncate_page
+c03add88 r __ksymtab_block_write_full_page
+c03add90 r __ksymtab_cont_prepare_write
+c03add98 r __ksymtab_end_buffer_read_sync
+c03adda0 r __ksymtab_end_buffer_write_sync
+c03adda8 r __ksymtab_file_fsync
+c03addb0 r __ksymtab_fsync_bdev
+c03addb8 r __ksymtab_generic_block_bmap
+c03addc0 r __ksymtab_generic_commit_write
+c03addc8 r __ksymtab_generic_cont_expand
+c03addd0 r __ksymtab_generic_cont_expand_simple
+c03addd8 r __ksymtab_init_buffer
+c03adde0 r __ksymtab_invalidate_bdev
+c03adde8 r __ksymtab_ll_rw_block
+c03addf0 r __ksymtab_mark_buffer_dirty
+c03addf8 r __ksymtab_submit_bh
+c03ade00 r __ksymtab_sync_dirty_buffer
+c03ade08 r __ksymtab_unlock_buffer
+c03ade10 r __ksymtab_zero_fill_bio
+c03ade18 r __ksymtab_bio_alloc
+c03ade20 r __ksymtab_bio_put
+c03ade28 r __ksymtab_bio_free
+c03ade30 r __ksymtab_bio_endio
+c03ade38 r __ksymtab_bio_init
+c03ade40 r __ksymtab___bio_clone
+c03ade48 r __ksymtab_bio_clone
+c03ade50 r __ksymtab_bio_phys_segments
+c03ade58 r __ksymtab_bio_hw_segments
+c03ade60 r __ksymtab_bio_add_page
+c03ade68 r __ksymtab_bio_add_pc_page
+c03ade70 r __ksymtab_bio_get_nr_vecs
+c03ade78 r __ksymtab_bio_map_user
+c03ade80 r __ksymtab_bio_unmap_user
+c03ade88 r __ksymtab_bio_map_kern
+c03ade90 r __ksymtab_bio_pair_release
+c03ade98 r __ksymtab_bio_split
+c03adea0 r __ksymtab_bio_split_pool
+c03adea8 r __ksymtab_bio_copy_user
+c03adeb0 r __ksymtab_bio_uncopy_user
+c03adeb8 r __ksymtab_bioset_create
+c03adec0 r __ksymtab_bioset_free
+c03adec8 r __ksymtab_bio_alloc_bioset
+c03aded0 r __ksymtab_I_BDEV
+c03aded8 r __ksymtab_set_blocksize
+c03adee0 r __ksymtab_sb_set_blocksize
+c03adee8 r __ksymtab_sb_min_blocksize
+c03adef0 r __ksymtab_bdget
+c03adef8 r __ksymtab_bdput
+c03adf00 r __ksymtab_bd_claim
+c03adf08 r __ksymtab_bd_release
+c03adf10 r __ksymtab_open_by_devnum
+c03adf18 r __ksymtab_check_disk_change
+c03adf20 r __ksymtab_bd_set_size
+c03adf28 r __ksymtab_blkdev_get
+c03adf30 r __ksymtab_blkdev_put
+c03adf38 r __ksymtab_ioctl_by_bdev
+c03adf40 r __ksymtab_open_bdev_excl
+c03adf48 r __ksymtab_close_bdev_excl
+c03adf50 r __ksymtab___invalidate_device
+c03adf58 r __ksymtab___blockdev_direct_IO
+c03adf60 r __ksymtab_mpage_readpages
+c03adf68 r __ksymtab_mpage_readpage
+c03adf70 r __ksymtab_mpage_writepages
+c03adf78 r __ksymtab_mpage_writepage
+c03adf80 r __ksymtab_generic_file_revoke
+c03adf88 r __ksymtab_mb_cache_create
+c03adf90 r __ksymtab_mb_cache_shrink
+c03adf98 r __ksymtab_mb_cache_destroy
+c03adfa0 r __ksymtab_mb_cache_entry_alloc
+c03adfa8 r __ksymtab_mb_cache_entry_insert
+c03adfb0 r __ksymtab_mb_cache_entry_release
+c03adfb8 r __ksymtab_mb_cache_entry_free
+c03adfc0 r __ksymtab_mb_cache_entry_get
+c03adfc8 r __ksymtab_mb_cache_entry_find_first
+c03adfd0 r __ksymtab_mb_cache_entry_find_next
+c03adfd8 r __ksymtab_posix_acl_alloc
+c03adfe0 r __ksymtab_posix_acl_clone
+c03adfe8 r __ksymtab_posix_acl_valid
+c03adff0 r __ksymtab_posix_acl_equiv_mode
+c03adff8 r __ksymtab_posix_acl_from_mode
+c03ae000 r __ksymtab_posix_acl_create_masq
+c03ae008 r __ksymtab_posix_acl_chmod_masq
+c03ae010 r __ksymtab_posix_acl_permission
+c03ae018 r __ksymtab_posix_acl_from_xattr
+c03ae020 r __ksymtab_posix_acl_to_xattr
+c03ae028 r __ksymtab_mark_info_dirty
+c03ae030 r __ksymtab_register_quota_format
+c03ae038 r __ksymtab_unregister_quota_format
+c03ae040 r __ksymtab_dqstats
+c03ae048 r __ksymtab_dq_data_lock
+c03ae050 r __ksymtab_vfs_quota_on
+c03ae058 r __ksymtab_vfs_quota_on_mount
+c03ae060 r __ksymtab_vfs_quota_off
+c03ae068 r __ksymtab_vfs_quota_sync
+c03ae070 r __ksymtab_vfs_get_dqinfo
+c03ae078 r __ksymtab_vfs_set_dqinfo
+c03ae080 r __ksymtab_vfs_get_dqblk
+c03ae088 r __ksymtab_vfs_set_dqblk
+c03ae090 r __ksymtab_dquot_commit
+c03ae098 r __ksymtab_dquot_commit_info
+c03ae0a0 r __ksymtab_dquot_acquire
+c03ae0a8 r __ksymtab_dquot_release
+c03ae0b0 r __ksymtab_dquot_mark_dquot_dirty
+c03ae0b8 r __ksymtab_dquot_initialize
+c03ae0c0 r __ksymtab_dquot_drop
+c03ae0c8 r __ksymtab_dquot_alloc_space
+c03ae0d0 r __ksymtab_dquot_alloc_inode
+c03ae0d8 r __ksymtab_dquot_free_space
+c03ae0e0 r __ksymtab_dquot_free_inode
+c03ae0e8 r __ksymtab_dquot_transfer
+c03ae0f0 r __ksymtab___inode_dir_notify
+c03ae0f8 r __ksymtab_proc_symlink
+c03ae100 r __ksymtab_proc_mkdir
+c03ae108 r __ksymtab_create_proc_entry
+c03ae110 r __ksymtab_remove_proc_entry
+c03ae118 r __ksymtab_proc_root
+c03ae120 r __ksymtab_proc_root_fs
+c03ae128 r __ksymtab_proc_bus
+c03ae130 r __ksymtab_proc_root_driver
+c03ae138 r __ksymtab_maps_protect
+c03ae140 r __ksymtab_bdevname
+c03ae148 r __ksymtab___bdevname
+c03ae150 r __ksymtab_read_dev_sector
+c03ae158 r __ksymtab_journal_start
+c03ae160 r __ksymtab_journal_restart
+c03ae168 r __ksymtab_journal_extend
+c03ae170 r __ksymtab_journal_stop
+c03ae178 r __ksymtab_journal_lock_updates
+c03ae180 r __ksymtab_journal_unlock_updates
+c03ae188 r __ksymtab_journal_get_write_access
+c03ae190 r __ksymtab_journal_get_create_access
+c03ae198 r __ksymtab_journal_get_undo_access
+c03ae1a0 r __ksymtab_journal_dirty_data
+c03ae1a8 r __ksymtab_journal_dirty_metadata
+c03ae1b0 r __ksymtab_journal_release_buffer
+c03ae1b8 r __ksymtab_journal_forget
+c03ae1c0 r __ksymtab_journal_flush
+c03ae1c8 r __ksymtab_journal_revoke
+c03ae1d0 r __ksymtab_journal_init_dev
+c03ae1d8 r __ksymtab_journal_init_inode
+c03ae1e0 r __ksymtab_journal_update_format
+c03ae1e8 r __ksymtab_journal_check_used_features
+c03ae1f0 r __ksymtab_journal_check_available_features
+c03ae1f8 r __ksymtab_journal_set_features
+c03ae200 r __ksymtab_journal_create
+c03ae208 r __ksymtab_journal_load
+c03ae210 r __ksymtab_journal_destroy
+c03ae218 r __ksymtab_journal_update_superblock
+c03ae220 r __ksymtab_journal_abort
+c03ae228 r __ksymtab_journal_errno
+c03ae230 r __ksymtab_journal_ack_err
+c03ae238 r __ksymtab_journal_clear_err
+c03ae240 r __ksymtab_log_wait_commit
+c03ae248 r __ksymtab_journal_start_commit
+c03ae250 r __ksymtab_journal_force_commit_nested
+c03ae258 r __ksymtab_journal_wipe
+c03ae260 r __ksymtab_journal_blocks_per_page
+c03ae268 r __ksymtab_journal_invalidatepage
+c03ae270 r __ksymtab_journal_try_to_free_buffers
+c03ae278 r __ksymtab_journal_force_commit
+c03ae280 r __ksymtab_register_nls
+c03ae288 r __ksymtab_unregister_nls
+c03ae290 r __ksymtab_unload_nls
+c03ae298 r __ksymtab_load_nls
+c03ae2a0 r __ksymtab_load_nls_default
+c03ae2a8 r __ksymtab_utf8_mbtowc
+c03ae2b0 r __ksymtab_utf8_mbstowcs
+c03ae2b8 r __ksymtab_utf8_wctomb
+c03ae2c0 r __ksymtab_utf8_wcstombs
+c03ae2c8 r __ksymtab_cap_netlink_send
+c03ae2d0 r __ksymtab_cap_netlink_recv
+c03ae2d8 r __ksymtab_cap_capable
+c03ae2e0 r __ksymtab_cap_settime
+c03ae2e8 r __ksymtab_cap_ptrace
+c03ae2f0 r __ksymtab_cap_capget
+c03ae2f8 r __ksymtab_cap_capset_check
+c03ae300 r __ksymtab_cap_capset_set
+c03ae308 r __ksymtab_cap_bprm_set_security
+c03ae310 r __ksymtab_cap_bprm_apply_creds
+c03ae318 r __ksymtab_cap_bprm_secureexec
+c03ae320 r __ksymtab_cap_inode_setxattr
+c03ae328 r __ksymtab_cap_inode_removexattr
+c03ae330 r __ksymtab_cap_task_post_setuid
+c03ae338 r __ksymtab_cap_task_reparent_to_init
+c03ae340 r __ksymtab_cap_syslog
+c03ae348 r __ksymtab_cap_vm_enough_memory
+c03ae350 r __ksymtab_elv_rq_merge_ok
+c03ae358 r __ksymtab_elevator_init
+c03ae360 r __ksymtab_elevator_exit
+c03ae368 r __ksymtab_elv_rb_add
+c03ae370 r __ksymtab_elv_rb_del
+c03ae378 r __ksymtab_elv_rb_find
+c03ae380 r __ksymtab_elv_dispatch_sort
+c03ae388 r __ksymtab_elv_dispatch_add_tail
+c03ae390 r __ksymtab___elv_add_request
+c03ae398 r __ksymtab_elv_add_request
+c03ae3a0 r __ksymtab_elv_next_request
+c03ae3a8 r __ksymtab_elv_dequeue_request
+c03ae3b0 r __ksymtab_elv_queue_empty
+c03ae3b8 r __ksymtab_elv_rb_former_request
+c03ae3c0 r __ksymtab_elv_rb_latter_request
+c03ae3c8 r __ksymtab_blk_max_low_pfn
+c03ae3d0 r __ksymtab_blk_max_pfn
+c03ae3d8 r __ksymtab_blk_get_backing_dev_info
+c03ae3e0 r __ksymtab_blk_queue_prep_rq
+c03ae3e8 r __ksymtab_blk_queue_merge_bvec
+c03ae3f0 r __ksymtab_blk_queue_softirq_done
+c03ae3f8 r __ksymtab_blk_queue_make_request
+c03ae400 r __ksymtab_blk_queue_ordered
+c03ae408 r __ksymtab_blk_queue_issue_flush_fn
+c03ae410 r __ksymtab_blk_queue_bounce_limit
+c03ae418 r __ksymtab_blk_queue_max_sectors
+c03ae420 r __ksymtab_blk_queue_max_phys_segments
+c03ae428 r __ksymtab_blk_queue_max_hw_segments
+c03ae430 r __ksymtab_blk_queue_max_segment_size
+c03ae438 r __ksymtab_blk_queue_hardsect_size
+c03ae440 r __ksymtab_blk_queue_stack_limits
+c03ae448 r __ksymtab_blk_queue_segment_boundary
+c03ae450 r __ksymtab_blk_queue_dma_alignment
+c03ae458 r __ksymtab_blk_queue_find_tag
+c03ae460 r __ksymtab_blk_free_tags
+c03ae468 r __ksymtab_blk_queue_free_tags
+c03ae470 r __ksymtab_blk_init_tags
+c03ae478 r __ksymtab_blk_queue_init_tags
+c03ae480 r __ksymtab_blk_queue_resize_tags
+c03ae488 r __ksymtab_blk_queue_end_tag
+c03ae490 r __ksymtab_blk_queue_start_tag
+c03ae498 r __ksymtab_blk_queue_invalidate_tags
+c03ae4a0 r __ksymtab_blk_dump_rq_flags
+c03ae4a8 r __ksymtab_blk_recount_segments
+c03ae4b0 r __ksymtab_blk_rq_map_sg
+c03ae4b8 r __ksymtab_ll_back_merge_fn
+c03ae4c0 r __ksymtab_blk_plug_device
+c03ae4c8 r __ksymtab_blk_remove_plug
+c03ae4d0 r __ksymtab___generic_unplug_device
+c03ae4d8 r __ksymtab_generic_unplug_device
+c03ae4e0 r __ksymtab_blk_start_queue
+c03ae4e8 r __ksymtab_blk_stop_queue
+c03ae4f0 r __ksymtab_blk_sync_queue
+c03ae4f8 r __ksymtab_blk_run_queue
+c03ae500 r __ksymtab_blk_put_queue
+c03ae508 r __ksymtab_blk_cleanup_queue
+c03ae510 r __ksymtab_blk_alloc_queue
+c03ae518 r __ksymtab_blk_alloc_queue_node
+c03ae520 r __ksymtab_blk_init_queue
+c03ae528 r __ksymtab_blk_init_queue_node
+c03ae530 r __ksymtab_blk_get_queue
+c03ae538 r __ksymtab_blk_get_request
+c03ae540 r __ksymtab_blk_start_queueing
+c03ae548 r __ksymtab_blk_requeue_request
+c03ae550 r __ksymtab_blk_insert_request
+c03ae558 r __ksymtab_blk_rq_map_user
+c03ae560 r __ksymtab_blk_rq_map_user_iov
+c03ae568 r __ksymtab_blk_rq_unmap_user
+c03ae570 r __ksymtab_blk_rq_map_kern
+c03ae578 r __ksymtab_blk_execute_rq
+c03ae580 r __ksymtab_blkdev_issue_flush
+c03ae588 r __ksymtab_blk_put_request
+c03ae590 r __ksymtab_blk_end_sync_rq
+c03ae598 r __ksymtab_generic_make_request
+c03ae5a0 r __ksymtab_submit_bio
+c03ae5a8 r __ksymtab_end_that_request_first
+c03ae5b0 r __ksymtab_end_that_request_chunk
+c03ae5b8 r __ksymtab_blk_complete_request
+c03ae5c0 r __ksymtab_end_that_request_last
+c03ae5c8 r __ksymtab_end_request
+c03ae5d0 r __ksymtab_blk_rq_bio_prep
+c03ae5d8 r __ksymtab_kblockd_schedule_work
+c03ae5e0 r __ksymtab_kblockd_flush_work
+c03ae5e8 r __ksymtab_put_io_context
+c03ae5f0 r __ksymtab_get_io_context
+c03ae5f8 r __ksymtab_copy_io_context
+c03ae600 r __ksymtab_swap_io_context
+c03ae608 r __ksymtab_register_blkdev
+c03ae610 r __ksymtab_unregister_blkdev
+c03ae618 r __ksymtab_blk_register_region
+c03ae620 r __ksymtab_blk_unregister_region
+c03ae628 r __ksymtab_add_disk
+c03ae630 r __ksymtab_del_gendisk
+c03ae638 r __ksymtab_alloc_disk
+c03ae640 r __ksymtab_alloc_disk_node
+c03ae648 r __ksymtab_get_disk
+c03ae650 r __ksymtab_put_disk
+c03ae658 r __ksymtab_set_device_ro
+c03ae660 r __ksymtab_set_disk_ro
+c03ae668 r __ksymtab_bdev_read_only
+c03ae670 r __ksymtab_invalidate_partition
+c03ae678 r __ksymtab_scsi_command_size
+c03ae680 r __ksymtab_scsi_cmd_ioctl
+c03ae688 r __ksymtab_argv_free
+c03ae690 r __ksymtab_argv_split
+c03ae698 r __ksymtab___bitmap_empty
+c03ae6a0 r __ksymtab___bitmap_full
+c03ae6a8 r __ksymtab___bitmap_equal
+c03ae6b0 r __ksymtab___bitmap_complement
+c03ae6b8 r __ksymtab___bitmap_shift_right
+c03ae6c0 r __ksymtab___bitmap_shift_left
+c03ae6c8 r __ksymtab___bitmap_and
+c03ae6d0 r __ksymtab___bitmap_or
+c03ae6d8 r __ksymtab___bitmap_xor
+c03ae6e0 r __ksymtab___bitmap_andnot
+c03ae6e8 r __ksymtab___bitmap_intersects
+c03ae6f0 r __ksymtab___bitmap_subset
+c03ae6f8 r __ksymtab___bitmap_weight
+c03ae700 r __ksymtab_bitmap_scnprintf
+c03ae708 r __ksymtab___bitmap_parse
+c03ae710 r __ksymtab_bitmap_parse_user
+c03ae718 r __ksymtab_bitmap_scnlistprintf
+c03ae720 r __ksymtab_bitmap_parselist
+c03ae728 r __ksymtab_bitmap_remap
+c03ae730 r __ksymtab_bitmap_bitremap
+c03ae738 r __ksymtab_bitmap_find_free_region
+c03ae740 r __ksymtab_bitmap_release_region
+c03ae748 r __ksymtab_bitmap_allocate_region
+c03ae750 r __ksymtab_memparse
+c03ae758 r __ksymtab_get_option
+c03ae760 r __ksymtab_get_options
+c03ae768 r __ksymtab___first_cpu
+c03ae770 r __ksymtab___next_cpu
+c03ae778 r __ksymtab___any_online_cpu
+c03ae780 r __ksymtab__ctype
+c03ae788 r __ksymtab__atomic_dec_and_lock
+c03ae790 r __ksymtab_idr_pre_get
+c03ae798 r __ksymtab_idr_get_new_above
+c03ae7a0 r __ksymtab_idr_get_new
+c03ae7a8 r __ksymtab_idr_remove
+c03ae7b0 r __ksymtab_idr_destroy
+c03ae7b8 r __ksymtab_idr_find
+c03ae7c0 r __ksymtab_idr_replace
+c03ae7c8 r __ksymtab_idr_init
+c03ae7d0 r __ksymtab_ida_pre_get
+c03ae7d8 r __ksymtab_ida_get_new_above
+c03ae7e0 r __ksymtab_ida_get_new
+c03ae7e8 r __ksymtab_ida_remove
+c03ae7f0 r __ksymtab_ida_destroy
+c03ae7f8 r __ksymtab_ida_init
+c03ae800 r __ksymtab_int_sqrt
+c03ae808 r __ksymtab_kobject_set_name
+c03ae810 r __ksymtab_kobject_init
+c03ae818 r __ksymtab_kobject_register
+c03ae820 r __ksymtab_kobject_unregister
+c03ae828 r __ksymtab_kobject_get
+c03ae830 r __ksymtab_kobject_put
+c03ae838 r __ksymtab_kobject_add
+c03ae840 r __ksymtab_kobject_del
+c03ae848 r __ksymtab_kset_register
+c03ae850 r __ksymtab_kset_unregister
+c03ae858 r __ksymtab_subsystem_register
+c03ae860 r __ksymtab_subsystem_unregister
+c03ae868 r __ksymtab_subsys_create_file
+c03ae870 r __ksymtab_kref_init
+c03ae878 r __ksymtab_kref_get
+c03ae880 r __ksymtab_kref_put
+c03ae888 r __ksymtab_radix_tree_insert
+c03ae890 r __ksymtab_radix_tree_lookup_slot
+c03ae898 r __ksymtab_radix_tree_lookup
+c03ae8a0 r __ksymtab_radix_tree_tag_set
+c03ae8a8 r __ksymtab_radix_tree_tag_clear
+c03ae8b0 r __ksymtab_radix_tree_gang_lookup
+c03ae8b8 r __ksymtab_radix_tree_gang_lookup_tag
+c03ae8c0 r __ksymtab_radix_tree_delete
+c03ae8c8 r __ksymtab_radix_tree_tagged
+c03ae8d0 r __ksymtab_rb_insert_color
+c03ae8d8 r __ksymtab_rb_erase
+c03ae8e0 r __ksymtab_rb_first
+c03ae8e8 r __ksymtab_rb_last
+c03ae8f0 r __ksymtab_rb_next
+c03ae8f8 r __ksymtab_rb_prev
+c03ae900 r __ksymtab_rb_replace_node
+c03ae908 r __ksymtab___init_rwsem
+c03ae910 r __ksymtab_rwsem_down_read_failed
+c03ae918 r __ksymtab_rwsem_down_write_failed
+c03ae920 r __ksymtab_rwsem_wake
+c03ae928 r __ksymtab_rwsem_downgrade_wake
+c03ae930 r __ksymtab_strnicmp
+c03ae938 r __ksymtab_strcasecmp
+c03ae940 r __ksymtab_strncasecmp
+c03ae948 r __ksymtab_strlcpy
+c03ae950 r __ksymtab_strlcat
+c03ae958 r __ksymtab_strnchr
+c03ae960 r __ksymtab_strstrip
+c03ae968 r __ksymtab_strspn
+c03ae970 r __ksymtab_strcspn
+c03ae978 r __ksymtab_strpbrk
+c03ae980 r __ksymtab_strsep
+c03ae988 r __ksymtab_memcmp
+c03ae990 r __ksymtab_simple_strtoul
+c03ae998 r __ksymtab_simple_strtol
+c03ae9a0 r __ksymtab_simple_strtoull
+c03ae9a8 r __ksymtab_vsnprintf
+c03ae9b0 r __ksymtab_vscnprintf
+c03ae9b8 r __ksymtab_snprintf
+c03ae9c0 r __ksymtab_scnprintf
+c03ae9c8 r __ksymtab_vsprintf
+c03ae9d0 r __ksymtab_sprintf
+c03ae9d8 r __ksymtab_vsscanf
+c03ae9e0 r __ksymtab_sscanf
+c03ae9e8 r __ksymtab_kvasprintf
+c03ae9f0 r __ksymtab_kasprintf
+c03ae9f8 r __ksymtab_find_next_bit
+c03aea00 r __ksymtab_find_next_zero_bit
+c03aea08 r __ksymtab___delay
+c03aea10 r __ksymtab___const_udelay
+c03aea18 r __ksymtab___udelay
+c03aea20 r __ksymtab___ndelay
+c03aea28 r __ksymtab_memcpy
+c03aea30 r __ksymtab_memset
+c03aea38 r __ksymtab_memmove
+c03aea40 r __ksymtab___strncpy_from_user
+c03aea48 r __ksymtab_strncpy_from_user
+c03aea50 r __ksymtab_clear_user
+c03aea58 r __ksymtab___clear_user
+c03aea60 r __ksymtab_strnlen_user
+c03aea68 r __ksymtab___copy_to_user_ll
+c03aea70 r __ksymtab___copy_from_user_ll
+c03aea78 r __ksymtab___copy_from_user_ll_nozero
+c03aea80 r __ksymtab_copy_to_user
+c03aea88 r __ksymtab_copy_from_user
+c03aea90 r __ksymtab___div64_32
+c03aea98 r __ksymtab_div64_64
+c03aeaa0 r __ksymtab_sort
+c03aeaa8 r __ksymtab_match_token
+c03aeab0 r __ksymtab_match_int
+c03aeab8 r __ksymtab_match_octal
+c03aeac0 r __ksymtab_match_hex
+c03aeac8 r __ksymtab_match_strcpy
+c03aead0 r __ksymtab_match_strdup
+c03aead8 r __ksymtab_half_md4_transform
+c03aeae0 r __ksymtab_random32
+c03aeae8 r __ksymtab_srandom32
+c03aeaf0 r __ksymtab_hex_dump_to_buffer
+c03aeaf8 r __ksymtab_print_hex_dump
+c03aeb00 r __ksymtab_print_hex_dump_bytes
+c03aeb08 r __ksymtab_ioread8
+c03aeb10 r __ksymtab_ioread16
+c03aeb18 r __ksymtab_ioread16be
+c03aeb20 r __ksymtab_ioread32
+c03aeb28 r __ksymtab_ioread32be
+c03aeb30 r __ksymtab_iowrite8
+c03aeb38 r __ksymtab_iowrite16
+c03aeb40 r __ksymtab_iowrite16be
+c03aeb48 r __ksymtab_iowrite32
+c03aeb50 r __ksymtab_iowrite32be
+c03aeb58 r __ksymtab_ioread8_rep
+c03aeb60 r __ksymtab_ioread16_rep
+c03aeb68 r __ksymtab_ioread32_rep
+c03aeb70 r __ksymtab_iowrite8_rep
+c03aeb78 r __ksymtab_iowrite16_rep
+c03aeb80 r __ksymtab_iowrite32_rep
+c03aeb88 r __ksymtab_ioport_map
+c03aeb90 r __ksymtab_ioport_unmap
+c03aeb98 r __ksymtab_pci_iomap
+c03aeba0 r __ksymtab_pci_iounmap
+c03aeba8 r __ksymtab_devm_ioremap
+c03aebb0 r __ksymtab_devm_ioremap_nocache
+c03aebb8 r __ksymtab_devm_iounmap
+c03aebc0 r __ksymtab_devm_ioport_map
+c03aebc8 r __ksymtab_devm_ioport_unmap
+c03aebd0 r __ksymtab_pcim_iomap_table
+c03aebd8 r __ksymtab_pcim_iomap
+c03aebe0 r __ksymtab_pcim_iounmap
+c03aebe8 r __ksymtab_pcim_iomap_regions
+c03aebf0 r __ksymtab_pcim_iounmap_regions
+c03aebf8 r __ksymtab___spin_lock_init
+c03aec00 r __ksymtab___rwlock_init
+c03aec08 r __ksymtab_hweight32
+c03aec10 r __ksymtab_hweight16
+c03aec18 r __ksymtab_hweight8
+c03aec20 r __ksymtab_hweight64
+c03aec28 r __ksymtab_lock_kernel
+c03aec30 r __ksymtab_unlock_kernel
+c03aec38 r __ksymtab___list_add
+c03aec40 r __ksymtab_list_add
+c03aec48 r __ksymtab_list_del
+c03aec50 r __ksymtab_bitrev32
+c03aec58 r __ksymtab_crc32_le
+c03aec60 r __ksymtab_crc32_be
+c03aec68 r __ksymtab_zlib_inflate_workspacesize
+c03aec70 r __ksymtab_zlib_inflate
+c03aec78 r __ksymtab_zlib_inflateInit2
+c03aec80 r __ksymtab_zlib_inflateEnd
+c03aec88 r __ksymtab_zlib_inflateReset
+c03aec90 r __ksymtab_zlib_inflateIncomp
+c03aec98 r __ksymtab_textsearch_register
+c03aeca0 r __ksymtab_textsearch_unregister
+c03aeca8 r __ksymtab_textsearch_prepare
+c03aecb0 r __ksymtab_textsearch_find_continuous
+c03aecb8 r __ksymtab_textsearch_destroy
+c03aecc0 r __ksymtab_percpu_counter_mod
+c03aecc8 r __ksymtab_percpu_counter_sum
+c03aecd0 r __ksymtab_rdmsr_on_cpu
+c03aecd8 r __ksymtab_wrmsr_on_cpu
+c03aece0 r __ksymtab_rdmsr_safe_on_cpu
+c03aece8 r __ksymtab_wrmsr_safe_on_cpu
+c03aecf0 r __ksymtab_pci_bus_read_config_byte
+c03aecf8 r __ksymtab_pci_bus_read_config_word
+c03aed00 r __ksymtab_pci_bus_read_config_dword
+c03aed08 r __ksymtab_pci_bus_write_config_byte
+c03aed10 r __ksymtab_pci_bus_write_config_word
+c03aed18 r __ksymtab_pci_bus_write_config_dword
+c03aed20 r __ksymtab_pci_bus_alloc_resource
+c03aed28 r __ksymtab_pci_bus_add_devices
+c03aed30 r __ksymtab_pci_enable_bridges
+c03aed38 r __ksymtab_pci_root_buses
+c03aed40 r __ksymtab_alloc_pci_dev
+c03aed48 r __ksymtab_pci_scan_bus_parented
+c03aed50 r __ksymtab_pci_add_new_bus
+c03aed58 r __ksymtab_pci_do_scan_bus
+c03aed60 r __ksymtab_pci_scan_slot
+c03aed68 r __ksymtab_pci_scan_bridge
+c03aed70 r __ksymtab_pci_scan_single_device
+c03aed78 r __ksymtab_pci_remove_bus
+c03aed80 r __ksymtab_pci_remove_bus_device
+c03aed88 r __ksymtab_pci_remove_behind_bridge
+c03aed90 r __ksymtab_pci_choose_state
+c03aed98 r __ksymtab_pci_enable_device_bars
+c03aeda0 r __ksymtab_pci_enable_device
+c03aeda8 r __ksymtab_pcim_enable_device
+c03aedb0 r __ksymtab_pcim_pin_device
+c03aedb8 r __ksymtab_pci_disable_device
+c03aedc0 r __ksymtab_pci_find_capability
+c03aedc8 r __ksymtab_pci_bus_find_capability
+c03aedd0 r __ksymtab_pci_release_regions
+c03aedd8 r __ksymtab_pci_request_regions
+c03aede0 r __ksymtab_pci_release_region
+c03aede8 r __ksymtab_pci_request_region
+c03aedf0 r __ksymtab_pci_release_selected_regions
+c03aedf8 r __ksymtab_pci_request_selected_regions
+c03aee00 r __ksymtab_pci_set_master
+c03aee08 r __ksymtab_pci_set_mwi
+c03aee10 r __ksymtab_pci_clear_mwi
+c03aee18 r __ksymtab_pci_set_dma_mask
+c03aee20 r __ksymtab_pci_set_consistent_dma_mask
+c03aee28 r __ksymtab_pci_assign_resource
+c03aee30 r __ksymtab_pci_find_parent_resource
+c03aee38 r __ksymtab_pci_select_bars
+c03aee40 r __ksymtab_pci_set_power_state
+c03aee48 r __ksymtab_pci_save_state
+c03aee50 r __ksymtab_pci_restore_state
+c03aee58 r __ksymtab_pci_enable_wake
+c03aee60 r __ksymtab_isa_dma_bridge_buggy
+c03aee68 r __ksymtab_pci_pci_problems
+c03aee70 r __ksymtab_pcie_mch_quirk
+c03aee78 r __ksymtab_pci_fixup_device
+c03aee80 r __ksymtab_pci_match_id
+c03aee88 r __ksymtab_pci_match_device
+c03aee90 r __ksymtab___pci_register_driver
+c03aee98 r __ksymtab_pci_unregister_driver
+c03aeea0 r __ksymtab_pci_dev_driver
+c03aeea8 r __ksymtab_pci_bus_type
+c03aeeb0 r __ksymtab_pci_dev_get
+c03aeeb8 r __ksymtab_pci_dev_put
+c03aeec0 r __ksymtab_pci_dev_present
+c03aeec8 r __ksymtab_pci_find_present
+c03aeed0 r __ksymtab_pci_find_device
+c03aeed8 r __ksymtab_pci_find_slot
+c03aeee0 r __ksymtab_pci_find_bus
+c03aeee8 r __ksymtab_pci_find_next_bus
+c03aeef0 r __ksymtab_pci_get_device
+c03aeef8 r __ksymtab_pci_get_device_reverse
+c03aef00 r __ksymtab_pci_get_subsys
+c03aef08 r __ksymtab_pci_get_slot
+c03aef10 r __ksymtab_pci_get_bus_and_slot
+c03aef18 r __ksymtab_pci_get_class
+c03aef20 r __ksymtab_pci_map_rom
+c03aef28 r __ksymtab_pci_map_rom_copy
+c03aef30 r __ksymtab_pci_unmap_rom
+c03aef38 r __ksymtab_pci_remove_rom
+c03aef40 r __ksymtab_pci_proc_attach_device
+c03aef48 r __ksymtab_pci_proc_detach_bus
+c03aef50 r __ksymtab_pcie_port_service_register
+c03aef58 r __ksymtab_pcie_port_service_unregister
+c03aef60 r __ksymtab_pci_enable_msi
+c03aef68 r __ksymtab_pci_disable_msi
+c03aef70 r __ksymtab_pci_enable_msix
+c03aef78 r __ksymtab_pci_disable_msix
+c03aef80 r __ksymtab___ht_create_irq
+c03aef88 r __ksymtab_ht_create_irq
+c03aef90 r __ksymtab_ht_destroy_irq
+c03aef98 r __ksymtab_pci_setup_cardbus
+c03aefa0 r __ksymtab_pci_bus_size_bridges
+c03aefa8 r __ksymtab_pci_bus_assign_resources
+c03aefb0 r __ksymtab_pci_osc_support_set
+c03aefb8 r __ksymtab_pci_osc_control_set
+c03aefc0 r __ksymtab_fb_register_client
+c03aefc8 r __ksymtab_fb_unregister_client
+c03aefd0 r __ksymtab_acpi_os_printf
+c03aefd8 r __ksymtab_acpi_os_sleep
+c03aefe0 r __ksymtab_acpi_os_stall
+c03aefe8 r __ksymtab_acpi_os_read_port
+c03aeff0 r __ksymtab_acpi_os_write_port
+c03aeff8 r __ksymtab_acpi_os_read_pci_configuration
+c03af000 r __ksymtab_acpi_os_execute
+c03af008 r __ksymtab_acpi_os_wait_events_complete
+c03af010 r __ksymtab_acpi_os_create_semaphore
+c03af018 r __ksymtab_acpi_os_delete_semaphore
+c03af020 r __ksymtab_acpi_os_wait_semaphore
+c03af028 r __ksymtab_acpi_os_signal_semaphore
+c03af030 r __ksymtab_acpi_os_signal
+c03af038 r __ksymtab_max_cstate
+c03af040 r __ksymtab_acpi_do_set_cstate_limit
+c03af048 r __ksymtab_acpi_set_cstate_limit
+c03af050 r __ksymtab_acpi_extract_package
+c03af058 r __ksymtab_acpi_evaluate_integer
+c03af060 r __ksymtab_acpi_evaluate_reference
+c03af068 r __ksymtab_acpi_enable
+c03af070 r __ksymtab_acpi_disable
+c03af078 r __ksymtab_acpi_enable_event
+c03af080 r __ksymtab_acpi_set_gpe_type
+c03af088 r __ksymtab_acpi_enable_gpe
+c03af090 r __ksymtab_acpi_disable_gpe
+c03af098 r __ksymtab_acpi_disable_event
+c03af0a0 r __ksymtab_acpi_clear_event
+c03af0a8 r __ksymtab_acpi_clear_gpe
+c03af0b0 r __ksymtab_acpi_install_gpe_block
+c03af0b8 r __ksymtab_acpi_remove_gpe_block
+c03af0c0 r __ksymtab_acpi_install_fixed_event_handler
+c03af0c8 r __ksymtab_acpi_remove_fixed_event_handler
+c03af0d0 r __ksymtab_acpi_install_notify_handler
+c03af0d8 r __ksymtab_acpi_remove_notify_handler
+c03af0e0 r __ksymtab_acpi_install_gpe_handler
+c03af0e8 r __ksymtab_acpi_remove_gpe_handler
+c03af0f0 r __ksymtab_acpi_acquire_global_lock
+c03af0f8 r __ksymtab_acpi_release_global_lock
+c03af100 r __ksymtab_acpi_install_address_space_handler
+c03af108 r __ksymtab_acpi_remove_address_space_handler
+c03af110 r __ksymtab_acpi_get_sleep_type_data
+c03af118 r __ksymtab_acpi_get_register
+c03af120 r __ksymtab_acpi_set_register
+c03af128 r __ksymtab_acpi_set_firmware_waking_vector
+c03af130 r __ksymtab_acpi_enter_sleep_state_prep
+c03af138 r __ksymtab_acpi_enter_sleep_state
+c03af140 r __ksymtab_acpi_enter_sleep_state_s4bios
+c03af148 r __ksymtab_acpi_leave_sleep_state
+c03af150 r __ksymtab_acpi_evaluate_object
+c03af158 r __ksymtab_acpi_walk_namespace
+c03af160 r __ksymtab_acpi_get_devices
+c03af168 r __ksymtab_acpi_attach_data
+c03af170 r __ksymtab_acpi_detach_data
+c03af178 r __ksymtab_acpi_get_data
+c03af180 r __ksymtab_acpi_get_handle
+c03af188 r __ksymtab_acpi_get_name
+c03af190 r __ksymtab_acpi_get_object_info
+c03af198 r __ksymtab_acpi_get_id
+c03af1a0 r __ksymtab_acpi_get_type
+c03af1a8 r __ksymtab_acpi_get_parent
+c03af1b0 r __ksymtab_acpi_get_next_object
+c03af1b8 r __ksymtab_acpi_get_irq_routing_table
+c03af1c0 r __ksymtab_acpi_get_current_resources
+c03af1c8 r __ksymtab_acpi_set_current_resources
+c03af1d0 r __ksymtab_acpi_resource_to_address64
+c03af1d8 r __ksymtab_acpi_get_vendor_resource
+c03af1e0 r __ksymtab_acpi_rs_match_vendor_resource
+c03af1e8 r __ksymtab_acpi_walk_resources
+c03af1f0 r __ksymtab_acpi_load_table
+c03af1f8 r __ksymtab_acpi_get_table_header
+c03af200 r __ksymtab_acpi_unload_table_id
+c03af208 r __ksymtab_acpi_get_table
+c03af210 r __ksymtab_acpi_get_table_by_index
+c03af218 r __ksymtab_acpi_load_tables
+c03af220 r __ksymtab_acpi_ut_exception
+c03af228 r __ksymtab_acpi_enable_subsystem
+c03af230 r __ksymtab_acpi_initialize_objects
+c03af238 r __ksymtab_acpi_terminate
+c03af240 r __ksymtab_acpi_purge_cached_objects
+c03af248 r __ksymtab_acpi_gbl_FADT
+c03af250 r __ksymtab_acpi_format_exception
+c03af258 r __ksymtab_acpi_dbg_level
+c03af260 r __ksymtab_acpi_dbg_layer
+c03af268 r __ksymtab_acpi_gpe_count
+c03af270 r __ksymtab_acpi_root_dir
+c03af278 r __ksymtab_acpi_bus_get_device
+c03af280 r __ksymtab_acpi_bus_get_status
+c03af288 r __ksymtab_acpi_bus_get_power
+c03af290 r __ksymtab_acpi_bus_set_power
+c03af298 r __ksymtab_acpi_bus_generate_event
+c03af2a0 r __ksymtab_acpi_bus_receive_event
+c03af2a8 r __ksymtab_register_acpi_bus_type
+c03af2b0 r __ksymtab_unregister_acpi_bus_type
+c03af2b8 r __ksymtab_acpi_get_child
+c03af2c0 r __ksymtab_acpi_get_physical_device
+c03af2c8 r __ksymtab_acpi_bus_register_driver
+c03af2d0 r __ksymtab_acpi_bus_unregister_driver
+c03af2d8 r __ksymtab_acpi_bus_add
+c03af2e0 r __ksymtab_acpi_bus_start
+c03af2e8 r __ksymtab_ec_burst_enable
+c03af2f0 r __ksymtab_ec_burst_disable
+c03af2f8 r __ksymtab_ec_read
+c03af300 r __ksymtab_ec_write
+c03af308 r __ksymtab_ec_transaction
+c03af310 r __ksymtab_acpi_pci_register_driver
+c03af318 r __ksymtab_acpi_pci_unregister_driver
+c03af320 r __ksymtab_acpi_pci_irq_enable
+c03af328 r __ksymtab_acpi_get_pci_id
+c03af330 r __ksymtab_acpi_lock_ac_dir
+c03af338 r __ksymtab_acpi_unlock_ac_dir
+c03af340 r __ksymtab_acpi_lock_battery_dir
+c03af348 r __ksymtab_acpi_unlock_battery_dir
+c03af350 r __ksymtab_pnp_platform_devices
+c03af358 r __ksymtab_pnp_request_card_device
+c03af360 r __ksymtab_pnp_release_card_device
+c03af368 r __ksymtab_pnp_register_card_driver
+c03af370 r __ksymtab_pnp_unregister_card_driver
+c03af378 r __ksymtab_pnp_register_driver
+c03af380 r __ksymtab_pnp_unregister_driver
+c03af388 r __ksymtab_pnp_device_attach
+c03af390 r __ksymtab_pnp_device_detach
+c03af398 r __ksymtab_pnp_manual_config_dev
+c03af3a0 r __ksymtab_pnp_start_dev
+c03af3a8 r __ksymtab_pnp_stop_dev
+c03af3b0 r __ksymtab_pnp_activate_dev
+c03af3b8 r __ksymtab_pnp_disable_dev
+c03af3c0 r __ksymtab_pnp_resource_change
+c03af3c8 r __ksymtab_pnp_init_resource_table
+c03af3d0 r __ksymtab_pnp_is_active
+c03af3d8 r __ksymtab_add_disk_randomness
+c03af3e0 r __ksymtab_get_random_bytes
+c03af3e8 r __ksymtab_generate_random_uuid
+c03af3f0 r __ksymtab_secure_tcpv6_sequence_number
+c03af3f8 r __ksymtab_tty_std_termios
+c03af400 r __ksymtab_tty_mutex
+c03af408 r __ksymtab_tty_name
+c03af410 r __ksymtab_tty_insert_flip_string
+c03af418 r __ksymtab_tty_insert_flip_string_flags
+c03af420 r __ksymtab_tty_schedule_flip
+c03af428 r __ksymtab_tty_register_ldisc
+c03af430 r __ksymtab_tty_unregister_ldisc
+c03af438 r __ksymtab_tty_check_change
+c03af440 r __ksymtab_tty_hangup
+c03af448 r __ksymtab_tty_vhangup
+c03af450 r __ksymtab_tty_hung_up_p
+c03af458 r __ksymtab_stop_tty
+c03af460 r __ksymtab_start_tty
+c03af468 r __ksymtab_do_SAK
+c03af470 r __ksymtab_tty_flip_buffer_push
+c03af478 r __ksymtab_tty_register_device
+c03af480 r __ksymtab_tty_unregister_device
+c03af488 r __ksymtab_alloc_tty_driver
+c03af490 r __ksymtab_put_tty_driver
+c03af498 r __ksymtab_tty_set_operations
+c03af4a0 r __ksymtab_tty_register_driver
+c03af4a8 r __ksymtab_tty_unregister_driver
+c03af4b0 r __ksymtab_tty_devnum
+c03af4b8 r __ksymtab_proc_clear_tty
+c03af4c0 r __ksymtab_tty_wait_until_sent
+c03af4c8 r __ksymtab_tty_termios_baud_rate
+c03af4d0 r __ksymtab_tty_termios_input_baud_rate
+c03af4d8 r __ksymtab_tty_get_baud_rate
+c03af4e0 r __ksymtab_n_tty_ioctl
+c03af4e8 r __ksymtab_misc_register
+c03af4f0 r __ksymtab_misc_deregister
+c03af4f8 r __ksymtab_con_set_default_unimap
+c03af500 r __ksymtab_con_copy_unimap
+c03af508 r __ksymtab_con_is_bound
+c03af510 r __ksymtab_register_con_driver
+c03af518 r __ksymtab_unregister_con_driver
+c03af520 r __ksymtab_do_blank_screen
+c03af528 r __ksymtab_do_unblank_screen
+c03af530 r __ksymtab_color_table
+c03af538 r __ksymtab_default_red
+c03af540 r __ksymtab_default_grn
+c03af548 r __ksymtab_default_blu
+c03af550 r __ksymtab_update_region
+c03af558 r __ksymtab_redraw_screen
+c03af560 r __ksymtab_vc_resize
+c03af568 r __ksymtab_vc_lock_resize
+c03af570 r __ksymtab_fg_console
+c03af578 r __ksymtab_console_blank_hook
+c03af580 r __ksymtab_console_blanked
+c03af588 r __ksymtab_vc_cons
+c03af590 r __ksymtab_take_over_console
+c03af598 r __ksymtab_give_up_console
+c03af5a0 r __ksymtab_handle_sysrq
+c03af5a8 r __ksymtab_register_sysrq_key
+c03af5b0 r __ksymtab_unregister_sysrq_key
+c03af5b8 r __ksymtab_rtc_register
+c03af5c0 r __ksymtab_rtc_unregister
+c03af5c8 r __ksymtab_rtc_control
+c03af5d0 r __ksymtab_hpet_alloc
+c03af5d8 r __ksymtab_hpet_register
+c03af5e0 r __ksymtab_hpet_unregister
+c03af5e8 r __ksymtab_hpet_control
+c03af5f0 r __ksymtab_uart_update_timeout
+c03af5f8 r __ksymtab_uart_get_baud_rate
+c03af600 r __ksymtab_uart_get_divisor
+c03af608 r __ksymtab_uart_match_port
+c03af610 r __ksymtab_uart_write_wakeup
+c03af618 r __ksymtab_uart_register_driver
+c03af620 r __ksymtab_uart_unregister_driver
+c03af628 r __ksymtab_uart_suspend_port
+c03af630 r __ksymtab_uart_resume_port
+c03af638 r __ksymtab_uart_add_one_port
+c03af640 r __ksymtab_uart_remove_one_port
+c03af648 r __ksymtab_serial8250_register_port
+c03af650 r __ksymtab_serial8250_unregister_port
+c03af658 r __ksymtab_serial8250_unregister_by_port
+c03af660 r __ksymtab_serial8250_suspend_port
+c03af668 r __ksymtab_serial8250_resume_port
+c03af670 r __ksymtab_dev_driver_string
+c03af678 r __ksymtab_cpu_sysdev_class
+c03af680 r __ksymtab_dpm_runtime_resume
+c03af688 r __ksymtab_dpm_runtime_suspend
+c03af690 r __ksymtab_dmam_alloc_coherent
+c03af698 r __ksymtab_dmam_free_coherent
+c03af6a0 r __ksymtab_dmam_alloc_noncoherent
+c03af6a8 r __ksymtab_dmam_free_noncoherent
+c03af6b0 r __ksymtab_dmam_declare_coherent_memory
+c03af6b8 r __ksymtab_dmam_release_declared_memory
+c03af6c0 r __ksymtab_dma_pool_create
+c03af6c8 r __ksymtab_dma_pool_destroy
+c03af6d0 r __ksymtab_dma_pool_alloc
+c03af6d8 r __ksymtab_dma_pool_free
+c03af6e0 r __ksymtab_dmam_pool_create
+c03af6e8 r __ksymtab_dmam_pool_destroy
+c03af6f0 r __ksymtab_release_firmware
+c03af6f8 r __ksymtab_request_firmware
+c03af700 r __ksymtab_request_firmware_nowait
+c03af708 r __ksymtab_noautodma
+c03af710 r __ksymtab_ide_hwifs
+c03af718 r __ksymtab_ide_unregister
+c03af720 r __ksymtab_ide_register_hw_with_fixup
+c03af728 r __ksymtab_ide_register_hw
+c03af730 r __ksymtab_ide_spin_wait_hwgroup
+c03af738 r __ksymtab_system_bus_clock
+c03af740 r __ksymtab_generic_ide_ioctl
+c03af748 r __ksymtab_ide_lock
+c03af750 r __ksymtab_ide_end_request
+c03af758 r __ksymtab_ide_get_error_location
+c03af760 r __ksymtab_ide_end_drive_cmd
+c03af768 r __ksymtab_ide_stall_queue
+c03af770 r __ksymtab_ide_init_drive_cmd
+c03af778 r __ksymtab_ide_do_drive_cmd
+c03af780 r __ksymtab_default_hwif_mmiops
+c03af788 r __ksymtab_SELECT_DRIVE
+c03af790 r __ksymtab_ide_fix_driveid
+c03af798 r __ksymtab_ide_fixstring
+c03af7a0 r __ksymtab_drive_is_ready
+c03af7a8 r __ksymtab_ide_wait_stat
+c03af7b0 r __ksymtab_ide_config_drive_speed
+c03af7b8 r __ksymtab_ide_set_handler
+c03af7c0 r __ksymtab_ide_execute_command
+c03af7c8 r __ksymtab_ide_do_reset
+c03af7d0 r __ksymtab_ide_xfer_verbose
+c03af7d8 r __ksymtab_ide_rate_filter
+c03af7e0 r __ksymtab_ide_dump_status
+c03af7e8 r __ksymtab_probe_hwif_init
+c03af7f0 r __ksymtab_task_no_data_intr
+c03af7f8 r __ksymtab_task_in_intr
+c03af800 r __ksymtab_pre_task_out_intr
+c03af808 r __ksymtab_ide_raw_taskfile
+c03af810 r __ksymtab_ide_dma_host_off
+c03af818 r __ksymtab_ide_dma_off_quietly
+c03af820 r __ksymtab_ide_dma_off
+c03af828 r __ksymtab_ide_dma_host_on
+c03af830 r __ksymtab___ide_dma_on
+c03af838 r __ksymtab___ide_dma_check
+c03af840 r __ksymtab___ide_dma_end
+c03af848 r __ksymtab___ide_dma_bad_drive
+c03af850 r __ksymtab___ide_dma_good_drive
+c03af858 r __ksymtab_ide_dma_verbose
+c03af860 r __ksymtab___ide_dma_lostirq
+c03af868 r __ksymtab___ide_dma_timeout
+c03af870 r __ksymtab_cdrom_get_last_written
+c03af878 r __ksymtab_register_cdrom
+c03af880 r __ksymtab_unregister_cdrom
+c03af888 r __ksymtab_cdrom_open
+c03af890 r __ksymtab_cdrom_release
+c03af898 r __ksymtab_cdrom_ioctl
+c03af8a0 r __ksymtab_cdrom_media_changed
+c03af8a8 r __ksymtab_cdrom_number_of_slots
+c03af8b0 r __ksymtab_cdrom_mode_select
+c03af8b8 r __ksymtab_cdrom_mode_sense
+c03af8c0 r __ksymtab_init_cdrom_command
+c03af8c8 r __ksymtab_cdrom_get_media_event
+c03af8d0 r __ksymtab_usb_disabled
+c03af8d8 r __ksymtab_usb_put_dev
+c03af8e0 r __ksymtab_usb_get_dev
+c03af8e8 r __ksymtab_usb_hub_tt_clear_buffer
+c03af8f0 r __ksymtab_usb_lock_device_for_reset
+c03af8f8 r __ksymtab_usb_find_interface
+c03af900 r __ksymtab_usb_ifnum_to_if
+c03af908 r __ksymtab_usb_altnum_to_altsetting
+c03af910 r __ksymtab___usb_get_extra_descriptor
+c03af918 r __ksymtab_usb_find_device
+c03af920 r __ksymtab_usb_get_current_frame_number
+c03af928 r __ksymtab_usb_buffer_alloc
+c03af930 r __ksymtab_usb_buffer_free
+c03af938 r __ksymtab_usb_buffer_map_sg
+c03af940 r __ksymtab_usb_buffer_unmap_sg
+c03af948 r __ksymtab_usb_reset_device
+c03af950 r __ksymtab_usb_reset_composite_device
+c03af958 r __ksymtab_usb_calc_bus_time
+c03af960 r __ksymtab_usb_hcd_giveback_urb
+c03af968 r __ksymtab_usb_create_hcd
+c03af970 r __ksymtab_usb_get_hcd
+c03af978 r __ksymtab_usb_put_hcd
+c03af980 r __ksymtab_usb_add_hcd
+c03af988 r __ksymtab_usb_remove_hcd
+c03af990 r __ksymtab_usb_hcd_platform_shutdown
+c03af998 r __ksymtab_usb_init_urb
+c03af9a0 r __ksymtab_usb_alloc_urb
+c03af9a8 r __ksymtab_usb_free_urb
+c03af9b0 r __ksymtab_usb_get_urb
+c03af9b8 r __ksymtab_usb_submit_urb
+c03af9c0 r __ksymtab_usb_unlink_urb
+c03af9c8 r __ksymtab_usb_kill_urb
+c03af9d0 r __ksymtab_usb_control_msg
+c03af9d8 r __ksymtab_usb_bulk_msg
+c03af9e0 r __ksymtab_usb_sg_init
+c03af9e8 r __ksymtab_usb_sg_cancel
+c03af9f0 r __ksymtab_usb_sg_wait
+c03af9f8 r __ksymtab_usb_get_descriptor
+c03afa00 r __ksymtab_usb_get_status
+c03afa08 r __ksymtab_usb_string
+c03afa10 r __ksymtab_usb_clear_halt
+c03afa18 r __ksymtab_usb_reset_configuration
+c03afa20 r __ksymtab_usb_set_interface
+c03afa28 r __ksymtab_usb_driver_claim_interface
+c03afa30 r __ksymtab_usb_driver_release_interface
+c03afa38 r __ksymtab_usb_register_dev
+c03afa40 r __ksymtab_usb_deregister_dev
+c03afa48 r __ksymtab_usb_hcd_pci_probe
+c03afa50 r __ksymtab_usb_hcd_pci_remove
+c03afa58 r __ksymtab_usb_hcd_pci_suspend
+c03afa60 r __ksymtab_usb_hcd_pci_resume
+c03afa68 r __ksymtab_usb_hcd_pci_shutdown
+c03afa70 r __ksymtab_serio_interrupt
+c03afa78 r __ksymtab___serio_register_port
+c03afa80 r __ksymtab_serio_unregister_port
+c03afa88 r __ksymtab_serio_unregister_child_port
+c03afa90 r __ksymtab___serio_register_driver
+c03afa98 r __ksymtab_serio_unregister_driver
+c03afaa0 r __ksymtab_serio_open
+c03afaa8 r __ksymtab_serio_close
+c03afab0 r __ksymtab_serio_rescan
+c03afab8 r __ksymtab_serio_reconnect
+c03afac0 r __ksymtab_ps2_sendbyte
+c03afac8 r __ksymtab_ps2_drain
+c03afad0 r __ksymtab_ps2_is_keyboard_id
+c03afad8 r __ksymtab_ps2_command
+c03afae0 r __ksymtab_ps2_schedule_command
+c03afae8 r __ksymtab_ps2_init
+c03afaf0 r __ksymtab_ps2_handle_ack
+c03afaf8 r __ksymtab_ps2_handle_response
+c03afb00 r __ksymtab_ps2_cmd_aborted
+c03afb08 r __ksymtab_input_event
+c03afb10 r __ksymtab_input_inject_event
+c03afb18 r __ksymtab_input_grab_device
+c03afb20 r __ksymtab_input_release_device
+c03afb28 r __ksymtab_input_open_device
+c03afb30 r __ksymtab_input_flush_device
+c03afb38 r __ksymtab_input_close_device
+c03afb40 r __ksymtab_input_allocate_device
+c03afb48 r __ksymtab_input_free_device
+c03afb50 r __ksymtab_input_set_capability
+c03afb58 r __ksymtab_input_register_device
+c03afb60 r __ksymtab_input_unregister_device
+c03afb68 r __ksymtab_input_register_handler
+c03afb70 r __ksymtab_input_unregister_handler
+c03afb78 r __ksymtab_input_register_handle
+c03afb80 r __ksymtab_input_unregister_handle
+c03afb88 r __ksymtab_register_md_personality
+c03afb90 r __ksymtab_unregister_md_personality
+c03afb98 r __ksymtab_md_error
+c03afba0 r __ksymtab_md_done_sync
+c03afba8 r __ksymtab_md_write_start
+c03afbb0 r __ksymtab_md_write_end
+c03afbb8 r __ksymtab_md_register_thread
+c03afbc0 r __ksymtab_md_unregister_thread
+c03afbc8 r __ksymtab_md_wakeup_thread
+c03afbd0 r __ksymtab_md_check_recovery
+c03afbd8 r __ksymtab_bitmap_startwrite
+c03afbe0 r __ksymtab_bitmap_endwrite
+c03afbe8 r __ksymtab_bitmap_start_sync
+c03afbf0 r __ksymtab_bitmap_end_sync
+c03afbf8 r __ksymtab_bitmap_unplug
+c03afc00 r __ksymtab_bitmap_close_sync
+c03afc08 r __ksymtab_dm_get_mapinfo
+c03afc10 r __ksymtab_dm_vcalloc
+c03afc18 r __ksymtab_dm_get_device
+c03afc20 r __ksymtab_dm_put_device
+c03afc28 r __ksymtab_dm_table_event
+c03afc30 r __ksymtab_dm_table_get_size
+c03afc38 r __ksymtab_dm_table_get_mode
+c03afc40 r __ksymtab_dm_table_get_md
+c03afc48 r __ksymtab_dm_table_put
+c03afc50 r __ksymtab_dm_table_get
+c03afc58 r __ksymtab_dm_table_unplug_all
+c03afc60 r __ksymtab_dm_table_flush_all
+c03afc68 r __ksymtab_dm_register_target
+c03afc70 r __ksymtab_dm_unregister_target
+c03afc78 r __ksymtab_dm_io_client_create
+c03afc80 r __ksymtab_dm_io_client_resize
+c03afc88 r __ksymtab_dm_io_client_destroy
+c03afc90 r __ksymtab_dm_io
+c03afc98 r __ksymtab_kcopyd_client_create
+c03afca0 r __ksymtab_kcopyd_client_destroy
+c03afca8 r __ksymtab_kcopyd_copy
+c03afcb0 r __ksymtab_dmi_check_system
+c03afcb8 r __ksymtab_dmi_get_system_info
+c03afcc0 r __ksymtab_dmi_name_in_vendors
+c03afcc8 r __ksymtab_dmi_find_device
+c03afcd0 r __ksymtab_dma_sync_wait
+c03afcd8 r __ksymtab_dma_chan_cleanup
+c03afce0 r __ksymtab_dma_async_client_register
+c03afce8 r __ksymtab_dma_async_client_unregister
+c03afcf0 r __ksymtab_dma_async_client_chan_request
+c03afcf8 r __ksymtab_dma_async_device_register
+c03afd00 r __ksymtab_dma_async_device_unregister
+c03afd08 r __ksymtab_dma_async_memcpy_buf_to_buf
+c03afd10 r __ksymtab_dma_async_memcpy_buf_to_pg
+c03afd18 r __ksymtab_dma_async_memcpy_pg_to_pg
+c03afd20 r __ksymtab_dma_async_tx_descriptor_init
+c03afd28 r __ksymtab_pcibios_get_irq_routing_table
+c03afd30 r __ksymtab_pcibios_set_irq_routing
+c03afd38 r __ksymtab_save_processor_state
+c03afd40 r __ksymtab_restore_processor_state
+c03afd48 r __ksymtab_brioctl_set
+c03afd50 r __ksymtab_vlan_ioctl_set
+c03afd58 r __ksymtab_dlci_ioctl_set
+c03afd60 r __ksymtab_move_addr_to_kernel
+c03afd68 r __ksymtab_move_addr_to_user
+c03afd70 r __ksymtab_sock_create
+c03afd78 r __ksymtab_sock_create_kern
+c03afd80 r __ksymtab_sock_create_lite
+c03afd88 r __ksymtab_sock_map_fd
+c03afd90 r __ksymtab_sock_recvmsg
+c03afd98 r __ksymtab_sock_register
+c03afda0 r __ksymtab_sock_release
+c03afda8 r __ksymtab_sock_sendmsg
+c03afdb0 r __ksymtab_sock_unregister
+c03afdb8 r __ksymtab_sock_wake_async
+c03afdc0 r __ksymtab_sockfd_lookup
+c03afdc8 r __ksymtab_kernel_sendmsg
+c03afdd0 r __ksymtab_kernel_recvmsg
+c03afdd8 r __ksymtab_kernel_bind
+c03afde0 r __ksymtab_kernel_listen
+c03afde8 r __ksymtab_kernel_accept
+c03afdf0 r __ksymtab_kernel_connect
+c03afdf8 r __ksymtab_kernel_getsockname
+c03afe00 r __ksymtab_kernel_getpeername
+c03afe08 r __ksymtab_kernel_getsockopt
+c03afe10 r __ksymtab_kernel_setsockopt
+c03afe18 r __ksymtab_kernel_sendpage
+c03afe20 r __ksymtab_kernel_sock_ioctl
+c03afe28 r __ksymtab_sock_queue_rcv_skb
+c03afe30 r __ksymtab_sk_receive_skb
+c03afe38 r __ksymtab___sk_dst_check
+c03afe40 r __ksymtab_sk_dst_check
+c03afe48 r __ksymtab_sk_wait_data
+c03afe50 r __ksymtab_sk_reset_timer
+c03afe58 r __ksymtab_sk_stop_timer
+c03afe60 r __ksymtab_lock_sock_nested
+c03afe68 r __ksymtab_release_sock
+c03afe70 r __ksymtab_sock_get_timestamp
+c03afe78 r __ksymtab_sock_get_timestampns
+c03afe80 r __ksymtab_sock_enable_timestamp
+c03afe88 r __ksymtab_sock_common_getsockopt
+c03afe90 r __ksymtab_sock_common_recvmsg
+c03afe98 r __ksymtab_sock_common_setsockopt
+c03afea0 r __ksymtab_sk_common_release
+c03afea8 r __ksymtab_proto_register
+c03afeb0 r __ksymtab_proto_unregister
+c03afeb8 r __ksymtab_sk_alloc
+c03afec0 r __ksymtab_sk_free
+c03afec8 r __ksymtab_sk_send_sigurg
+c03afed0 r __ksymtab_sock_alloc_send_skb
+c03afed8 r __ksymtab_sock_init_data
+c03afee0 r __ksymtab_sock_kfree_s
+c03afee8 r __ksymtab_sock_kmalloc
+c03afef0 r __ksymtab_sock_no_accept
+c03afef8 r __ksymtab_sock_no_bind
+c03aff00 r __ksymtab_sock_no_connect
+c03aff08 r __ksymtab_sock_no_getname
+c03aff10 r __ksymtab_sock_no_getsockopt
+c03aff18 r __ksymtab_sock_no_ioctl
+c03aff20 r __ksymtab_sock_no_listen
+c03aff28 r __ksymtab_sock_no_mmap
+c03aff30 r __ksymtab_sock_no_poll
+c03aff38 r __ksymtab_sock_no_recvmsg
+c03aff40 r __ksymtab_sock_no_sendmsg
+c03aff48 r __ksymtab_sock_no_sendpage
+c03aff50 r __ksymtab_sock_no_setsockopt
+c03aff58 r __ksymtab_sock_no_shutdown
+c03aff60 r __ksymtab_sock_no_socketpair
+c03aff68 r __ksymtab_sock_rfree
+c03aff70 r __ksymtab_sock_setsockopt
+c03aff78 r __ksymtab_sock_wfree
+c03aff80 r __ksymtab_sock_wmalloc
+c03aff88 r __ksymtab_sock_i_uid
+c03aff90 r __ksymtab_sock_i_ino
+c03aff98 r __ksymtab_sysctl_optmem_max
+c03affa0 r __ksymtab_sysctl_rmem_max
+c03affa8 r __ksymtab_sysctl_wmem_max
+c03affb0 r __ksymtab_reqsk_queue_alloc
+c03affb8 r __ksymtab_reqsk_queue_destroy
+c03affc0 r __ksymtab_skb_truesize_bug
+c03affc8 r __ksymtab_skb_store_bits
+c03affd0 r __ksymtab____pskb_trim
+c03affd8 r __ksymtab___kfree_skb
+c03affe0 r __ksymtab_kfree_skb
+c03affe8 r __ksymtab___pskb_pull_tail
+c03afff0 r __ksymtab___alloc_skb
+c03afff8 r __ksymtab___netdev_alloc_skb
+c03b0000 r __ksymtab_pskb_copy
+c03b0008 r __ksymtab_pskb_expand_head
+c03b0010 r __ksymtab_skb_checksum
+c03b0018 r __ksymtab_skb_clone
+c03b0020 r __ksymtab_skb_copy
+c03b0028 r __ksymtab_skb_copy_and_csum_bits
+c03b0030 r __ksymtab_skb_copy_and_csum_dev
+c03b0038 r __ksymtab_skb_copy_bits
+c03b0040 r __ksymtab_skb_copy_expand
+c03b0048 r __ksymtab_skb_over_panic
+c03b0050 r __ksymtab_skb_pad
+c03b0058 r __ksymtab_skb_realloc_headroom
+c03b0060 r __ksymtab_skb_under_panic
+c03b0068 r __ksymtab_skb_dequeue
+c03b0070 r __ksymtab_skb_dequeue_tail
+c03b0078 r __ksymtab_skb_insert
+c03b0080 r __ksymtab_skb_queue_purge
+c03b0088 r __ksymtab_skb_queue_head
+c03b0090 r __ksymtab_skb_queue_tail
+c03b0098 r __ksymtab_skb_unlink
+c03b00a0 r __ksymtab_skb_append
+c03b00a8 r __ksymtab_skb_split
+c03b00b0 r __ksymtab_skb_prepare_seq_read
+c03b00b8 r __ksymtab_skb_seq_read
+c03b00c0 r __ksymtab_skb_abort_seq_read
+c03b00c8 r __ksymtab_skb_find_text
+c03b00d0 r __ksymtab_skb_append_datato_frags
+c03b00d8 r __ksymtab_csum_partial_copy_fromiovecend
+c03b00e0 r __ksymtab_memcpy_fromiovec
+c03b00e8 r __ksymtab_memcpy_fromiovecend
+c03b00f0 r __ksymtab_memcpy_toiovec
+c03b00f8 r __ksymtab_skb_kill_datagram
+c03b0100 r __ksymtab___skb_checksum_complete_head
+c03b0108 r __ksymtab___skb_checksum_complete
+c03b0110 r __ksymtab_datagram_poll
+c03b0118 r __ksymtab_skb_copy_and_csum_datagram_iovec
+c03b0120 r __ksymtab_skb_copy_datagram_iovec
+c03b0128 r __ksymtab_skb_free_datagram
+c03b0130 r __ksymtab_skb_recv_datagram
+c03b0138 r __ksymtab_sk_stream_write_space
+c03b0140 r __ksymtab_sk_stream_wait_connect
+c03b0148 r __ksymtab_sk_stream_wait_close
+c03b0150 r __ksymtab_sk_stream_wait_memory
+c03b0158 r __ksymtab_sk_stream_rfree
+c03b0160 r __ksymtab_sk_stream_error
+c03b0168 r __ksymtab___sk_stream_mem_reclaim
+c03b0170 r __ksymtab_sk_stream_mem_schedule
+c03b0178 r __ksymtab_sk_stream_kill_queues
+c03b0180 r __ksymtab___scm_destroy
+c03b0188 r __ksymtab___scm_send
+c03b0190 r __ksymtab_put_cmsg
+c03b0198 r __ksymtab_scm_detach_fds
+c03b01a0 r __ksymtab_scm_fp_dup
+c03b01a8 r __ksymtab_gnet_stats_start_copy
+c03b01b0 r __ksymtab_gnet_stats_start_copy_compat
+c03b01b8 r __ksymtab_gnet_stats_copy_basic
+c03b01c0 r __ksymtab_gnet_stats_copy_rate_est
+c03b01c8 r __ksymtab_gnet_stats_copy_queue
+c03b01d0 r __ksymtab_gnet_stats_copy_app
+c03b01d8 r __ksymtab_gnet_stats_finish_copy
+c03b01e0 r __ksymtab_gen_kill_estimator
+c03b01e8 r __ksymtab_gen_new_estimator
+c03b01f0 r __ksymtab_gen_replace_estimator
+c03b01f8 r __ksymtab_dev_base_lock
+c03b0200 r __ksymtab_dev_getbyhwaddr
+c03b0208 r __ksymtab___dev_getfirstbyhwtype
+c03b0210 r __ksymtab_dev_getfirstbyhwtype
+c03b0218 r __ksymtab_netdev_features_change
+c03b0220 r __ksymtab___netif_schedule
+c03b0228 r __ksymtab___netif_rx_schedule
+c03b0230 r __ksymtab_dev_kfree_skb_any
+c03b0238 r __ksymtab_netif_device_detach
+c03b0240 r __ksymtab_netif_device_attach
+c03b0248 r __ksymtab_skb_gso_segment
+c03b0250 r __ksymtab_netdev_rx_csum_fault
+c03b0258 r __ksymtab_netif_rx_ni
+c03b0260 r __ksymtab_register_netdev
+c03b0268 r __ksymtab_alloc_netdev
+c03b0270 r __ksymtab_unregister_netdev
+c03b0278 r __ksymtab_netdev_compute_features
+c03b0280 r __ksymtab___dev_get_by_index
+c03b0288 r __ksymtab___dev_get_by_name
+c03b0290 r __ksymtab___dev_remove_pack
+c03b0298 r __ksymtab_dev_valid_name
+c03b02a0 r __ksymtab_dev_add_pack
+c03b02a8 r __ksymtab_dev_alloc_name
+c03b02b0 r __ksymtab_dev_close
+c03b02b8 r __ksymtab_dev_get_by_flags
+c03b02c0 r __ksymtab_dev_get_by_index
+c03b02c8 r __ksymtab_dev_get_by_name
+c03b02d0 r __ksymtab_dev_open
+c03b02d8 r __ksymtab_dev_queue_xmit
+c03b02e0 r __ksymtab_dev_remove_pack
+c03b02e8 r __ksymtab_dev_set_allmulti
+c03b02f0 r __ksymtab_dev_set_promiscuity
+c03b02f8 r __ksymtab_dev_change_flags
+c03b0300 r __ksymtab_dev_set_mtu
+c03b0308 r __ksymtab_dev_set_mac_address
+c03b0310 r __ksymtab_free_netdev
+c03b0318 r __ksymtab_netdev_boot_setup_check
+c03b0320 r __ksymtab_netdev_set_master
+c03b0328 r __ksymtab_netdev_state_change
+c03b0330 r __ksymtab_netif_receive_skb
+c03b0338 r __ksymtab_netif_rx
+c03b0340 r __ksymtab_register_gifconf
+c03b0348 r __ksymtab_register_netdevice
+c03b0350 r __ksymtab_register_netdevice_notifier
+c03b0358 r __ksymtab_skb_checksum_help
+c03b0360 r __ksymtab_synchronize_net
+c03b0368 r __ksymtab_unregister_netdevice
+c03b0370 r __ksymtab_unregister_netdevice_notifier
+c03b0378 r __ksymtab_net_enable_timestamp
+c03b0380 r __ksymtab_net_disable_timestamp
+c03b0388 r __ksymtab_dev_get_flags
+c03b0390 r __ksymtab_dev_load
+c03b0398 r __ksymtab_per_cpu__softnet_data
+c03b03a0 r __ksymtab_dev_ethtool
+c03b03a8 r __ksymtab_ethtool_op_get_link
+c03b03b0 r __ksymtab_ethtool_op_get_sg
+c03b03b8 r __ksymtab_ethtool_op_get_tso
+c03b03c0 r __ksymtab_ethtool_op_get_tx_csum
+c03b03c8 r __ksymtab_ethtool_op_set_sg
+c03b03d0 r __ksymtab_ethtool_op_set_tso
+c03b03d8 r __ksymtab_ethtool_op_set_tx_csum
+c03b03e0 r __ksymtab_ethtool_op_set_tx_hw_csum
+c03b03e8 r __ksymtab_ethtool_op_set_ufo
+c03b03f0 r __ksymtab_ethtool_op_get_ufo
+c03b03f8 r __ksymtab_dev_mc_add
+c03b0400 r __ksymtab_dev_mc_delete
+c03b0408 r __ksymtab_dev_mc_upload
+c03b0410 r __ksymtab___dst_free
+c03b0418 r __ksymtab_dst_alloc
+c03b0420 r __ksymtab_dst_destroy
+c03b0428 r __ksymtab_neigh_for_each
+c03b0430 r __ksymtab___neigh_for_each_release
+c03b0438 r __ksymtab_neigh_seq_start
+c03b0440 r __ksymtab_neigh_seq_next
+c03b0448 r __ksymtab_neigh_seq_stop
+c03b0450 r __ksymtab___neigh_event_send
+c03b0458 r __ksymtab_neigh_changeaddr
+c03b0460 r __ksymtab_neigh_compat_output
+c03b0468 r __ksymtab_neigh_connected_output
+c03b0470 r __ksymtab_neigh_create
+c03b0478 r __ksymtab_neigh_destroy
+c03b0480 r __ksymtab_neigh_event_ns
+c03b0488 r __ksymtab_neigh_ifdown
+c03b0490 r __ksymtab_neigh_lookup
+c03b0498 r __ksymtab_neigh_lookup_nodev
+c03b04a0 r __ksymtab_neigh_parms_alloc
+c03b04a8 r __ksymtab_neigh_parms_alloc_default
+c03b04b0 r __ksymtab_neigh_parms_release
+c03b04b8 r __ksymtab_neigh_rand_reach_time
+c03b04c0 r __ksymtab_neigh_resolve_output
+c03b04c8 r __ksymtab_neigh_table_clear
+c03b04d0 r __ksymtab_neigh_table_init
+c03b04d8 r __ksymtab_neigh_table_init_no_netlink
+c03b04e0 r __ksymtab_neigh_update
+c03b04e8 r __ksymtab_pneigh_enqueue
+c03b04f0 r __ksymtab_pneigh_lookup
+c03b04f8 r __ksymtab_neigh_sysctl_register
+c03b0500 r __ksymtab_neigh_sysctl_unregister
+c03b0508 r __ksymtab___rta_fill
+c03b0510 r __ksymtab_rtattr_strlcpy
+c03b0518 r __ksymtab_rtattr_parse
+c03b0520 r __ksymtab___rtattr_parse_nested_compat
+c03b0528 r __ksymtab_rtnetlink_put_metrics
+c03b0530 r __ksymtab_rtnl_lock
+c03b0538 r __ksymtab_rtnl_trylock
+c03b0540 r __ksymtab_rtnl_unlock
+c03b0548 r __ksymtab_rtnl_unicast
+c03b0550 r __ksymtab_rtnl_notify
+c03b0558 r __ksymtab_rtnl_set_sk_err
+c03b0560 r __ksymtab_net_msg_warn
+c03b0568 r __ksymtab_net_ratelimit
+c03b0570 r __ksymtab_in_aton
+c03b0578 r __ksymtab_in4_pton
+c03b0580 r __ksymtab_in6_pton
+c03b0588 r __ksymtab_linkwatch_fire_event
+c03b0590 r __ksymtab_sk_chk_filter
+c03b0598 r __ksymtab_sk_run_filter
+c03b05a0 r __ksymtab_flow_cache_genid
+c03b05a8 r __ksymtab_flow_cache_lookup
+c03b05b0 r __ksymtab_eth_type_trans
+c03b05b8 r __ksymtab_ether_setup
+c03b05c0 r __ksymtab_alloc_etherdev
+c03b05c8 r __ksymtab_netif_carrier_on
+c03b05d0 r __ksymtab_netif_carrier_off
+c03b05d8 r __ksymtab_noop_qdisc
+c03b05e0 r __ksymtab_qdisc_create_dflt
+c03b05e8 r __ksymtab_qdisc_destroy
+c03b05f0 r __ksymtab_qdisc_reset
+c03b05f8 r __ksymtab_qdisc_lock_tree
+c03b0600 r __ksymtab_qdisc_unlock_tree
+c03b0608 r __ksymtab_qdisc_watchdog_init
+c03b0610 r __ksymtab_qdisc_watchdog_schedule
+c03b0618 r __ksymtab_qdisc_watchdog_cancel
+c03b0620 r __ksymtab_qdisc_tree_decrease_qlen
+c03b0628 r __ksymtab_tcf_destroy_chain
+c03b0630 r __ksymtab_qdisc_get_rtab
+c03b0638 r __ksymtab_qdisc_put_rtab
+c03b0640 r __ksymtab_register_qdisc
+c03b0648 r __ksymtab_unregister_qdisc
+c03b0650 r __ksymtab_tc_classify
+c03b0658 r __ksymtab_register_tcf_proto_ops
+c03b0660 r __ksymtab_unregister_tcf_proto_ops
+c03b0668 r __ksymtab_tcf_exts_validate
+c03b0670 r __ksymtab_tcf_exts_destroy
+c03b0678 r __ksymtab_tcf_exts_change
+c03b0680 r __ksymtab_tcf_exts_dump
+c03b0688 r __ksymtab_tcf_exts_dump_stats
+c03b0690 r __ksymtab_bfifo_qdisc_ops
+c03b0698 r __ksymtab_pfifo_qdisc_ops
+c03b06a0 r __ksymtab_netlink_ack
+c03b06a8 r __ksymtab_netlink_run_queue
+c03b06b0 r __ksymtab_netlink_broadcast
+c03b06b8 r __ksymtab_netlink_dump_start
+c03b06c0 r __ksymtab_netlink_kernel_create
+c03b06c8 r __ksymtab_netlink_register_notifier
+c03b06d0 r __ksymtab_netlink_set_nonroot
+c03b06d8 r __ksymtab_netlink_unicast
+c03b06e0 r __ksymtab_netlink_unregister_notifier
+c03b06e8 r __ksymtab_nlmsg_notify
+c03b06f0 r __ksymtab_nla_validate
+c03b06f8 r __ksymtab_nla_parse
+c03b0700 r __ksymtab_nla_find
+c03b0708 r __ksymtab_nla_strlcpy
+c03b0710 r __ksymtab___nla_reserve
+c03b0718 r __ksymtab___nla_reserve_nohdr
+c03b0720 r __ksymtab_nla_reserve
+c03b0728 r __ksymtab_nla_reserve_nohdr
+c03b0730 r __ksymtab___nla_put
+c03b0738 r __ksymtab___nla_put_nohdr
+c03b0740 r __ksymtab_nla_put
+c03b0748 r __ksymtab_nla_put_nohdr
+c03b0750 r __ksymtab_nla_memcpy
+c03b0758 r __ksymtab_nla_memcmp
+c03b0760 r __ksymtab_nla_strcmp
+c03b0768 r __ksymtab_genl_sock
+c03b0770 r __ksymtab_genl_register_ops
+c03b0778 r __ksymtab_genl_unregister_ops
+c03b0780 r __ksymtab_genl_register_family
+c03b0788 r __ksymtab_genl_unregister_family
+c03b0790 r __ksymtab_nf_afinfo
+c03b0798 r __ksymtab_nf_hooks
+c03b07a0 r __ksymtab_nf_register_hook
+c03b07a8 r __ksymtab_nf_unregister_hook
+c03b07b0 r __ksymtab_nf_register_hooks
+c03b07b8 r __ksymtab_nf_unregister_hooks
+c03b07c0 r __ksymtab_nf_hook_slow
+c03b07c8 r __ksymtab_skb_make_writable
+c03b07d0 r __ksymtab_nf_proto_csum_replace4
+c03b07d8 r __ksymtab_ip_ct_attach
+c03b07e0 r __ksymtab_nf_ct_attach
+c03b07e8 r __ksymtab_nf_ct_destroy
+c03b07f0 r __ksymtab_nf_conntrack_destroy
+c03b07f8 r __ksymtab_nf_log_register
+c03b0800 r __ksymtab_nf_log_unregister_pf
+c03b0808 r __ksymtab_nf_log_unregister
+c03b0810 r __ksymtab_nf_log_packet
+c03b0818 r __ksymtab_nf_register_queue_handler
+c03b0820 r __ksymtab_nf_unregister_queue_handler
+c03b0828 r __ksymtab_nf_reinject
+c03b0830 r __ksymtab_nf_register_sockopt
+c03b0838 r __ksymtab_nf_unregister_sockopt
+c03b0840 r __ksymtab_nf_setsockopt
+c03b0848 r __ksymtab_nf_getsockopt
+c03b0850 r __ksymtab___ip_select_ident
+c03b0858 r __ksymtab_ip_route_input
+c03b0860 r __ksymtab_ip_route_output_key
+c03b0868 r __ksymtab_inet_add_protocol
+c03b0870 r __ksymtab_inet_del_protocol
+c03b0878 r __ksymtab_ip_statistics
+c03b0880 r __ksymtab_ip_defrag
+c03b0888 r __ksymtab_ip_fragment
+c03b0890 r __ksymtab_ip_generic_getfrag
+c03b0898 r __ksymtab_ip_queue_xmit
+c03b08a0 r __ksymtab_ip_send_check
+c03b08a8 r __ksymtab_ip_cmsg_recv
+c03b08b0 r __ksymtab_ip_getsockopt
+c03b08b8 r __ksymtab_ip_setsockopt
+c03b08c0 r __ksymtab_inet_put_port
+c03b08c8 r __ksymtab_inet_listen_wlock
+c03b08d0 r __ksymtab_inet_twsk_deschedule
+c03b08d8 r __ksymtab_inet_csk_timer_bug_msg
+c03b08e0 r __ksymtab_inet_csk_accept
+c03b08e8 r __ksymtab_inet_csk_init_xmit_timers
+c03b08f0 r __ksymtab_inet_csk_clear_xmit_timers
+c03b08f8 r __ksymtab_inet_csk_delete_keepalive_timer
+c03b0900 r __ksymtab_inet_csk_reset_keepalive_timer
+c03b0908 r __ksymtab_inet_csk_destroy_sock
+c03b0910 r __ksymtab_sysctl_tcp_mem
+c03b0918 r __ksymtab_sysctl_tcp_rmem
+c03b0920 r __ksymtab_sysctl_tcp_wmem
+c03b0928 r __ksymtab_tcp_memory_allocated
+c03b0930 r __ksymtab_tcp_sockets_allocated
+c03b0938 r __ksymtab_tcp_memory_pressure
+c03b0940 r __ksymtab_tcp_enter_memory_pressure
+c03b0948 r __ksymtab_tcp_tso_segment
+c03b0950 r __ksymtab_tcp_close
+c03b0958 r __ksymtab_tcp_disconnect
+c03b0960 r __ksymtab_tcp_getsockopt
+c03b0968 r __ksymtab_tcp_ioctl
+c03b0970 r __ksymtab_tcp_poll
+c03b0978 r __ksymtab_tcp_read_sock
+c03b0980 r __ksymtab_tcp_recvmsg
+c03b0988 r __ksymtab_tcp_sendmsg
+c03b0990 r __ksymtab_tcp_sendpage
+c03b0998 r __ksymtab_tcp_setsockopt
+c03b09a0 r __ksymtab_tcp_shutdown
+c03b09a8 r __ksymtab_tcp_statistics
+c03b09b0 r __ksymtab_sysctl_tcp_ecn
+c03b09b8 r __ksymtab_sysctl_tcp_reordering
+c03b09c0 r __ksymtab_tcp_parse_options
+c03b09c8 r __ksymtab_tcp_rcv_established
+c03b09d0 r __ksymtab_tcp_rcv_state_process
+c03b09d8 r __ksymtab_tcp_initialize_rcv_mss
+c03b09e0 r __ksymtab_tcp_connect
+c03b09e8 r __ksymtab_tcp_make_synack
+c03b09f0 r __ksymtab_tcp_simple_retransmit
+c03b09f8 r __ksymtab_tcp_sync_mss
+c03b0a00 r __ksymtab_sysctl_tcp_tso_win_divisor
+c03b0a08 r __ksymtab_tcp_mtup_init
+c03b0a10 r __ksymtab_tcp_init_xmit_timers
+c03b0a18 r __ksymtab_tcp_v4_destroy_sock
+c03b0a20 r __ksymtab_ipv4_specific
+c03b0a28 r __ksymtab_tcp_hashinfo
+c03b0a30 r __ksymtab_tcp_prot
+c03b0a38 r __ksymtab_tcp_unhash
+c03b0a40 r __ksymtab_tcp_v4_conn_request
+c03b0a48 r __ksymtab_tcp_v4_connect
+c03b0a50 r __ksymtab_tcp_v4_do_rcv
+c03b0a58 r __ksymtab_tcp_v4_remember_stamp
+c03b0a60 r __ksymtab_tcp_v4_send_check
+c03b0a68 r __ksymtab_tcp_v4_syn_recv_sock
+c03b0a70 r __ksymtab_tcp_proc_register
+c03b0a78 r __ksymtab_tcp_proc_unregister
+c03b0a80 r __ksymtab_sysctl_tcp_low_latency
+c03b0a88 r __ksymtab_tcp_check_req
+c03b0a90 r __ksymtab_tcp_child_process
+c03b0a98 r __ksymtab_tcp_create_openreq_child
+c03b0aa0 r __ksymtab_tcp_timewait_state_process
+c03b0aa8 r __ksymtab_ip4_datagram_connect
+c03b0ab0 r __ksymtab_udp_disconnect
+c03b0ab8 r __ksymtab_udp_hash
+c03b0ac0 r __ksymtab_udp_hash_lock
+c03b0ac8 r __ksymtab_udp_ioctl
+c03b0ad0 r __ksymtab_udp_get_port
+c03b0ad8 r __ksymtab_udp_prot
+c03b0ae0 r __ksymtab_udp_sendmsg
+c03b0ae8 r __ksymtab_udp_lib_getsockopt
+c03b0af0 r __ksymtab_udp_lib_setsockopt
+c03b0af8 r __ksymtab_udp_poll
+c03b0b00 r __ksymtab_udp_proc_register
+c03b0b08 r __ksymtab_udp_proc_unregister
+c03b0b10 r __ksymtab_udplite_hash
+c03b0b18 r __ksymtab_udplite_prot
+c03b0b20 r __ksymtab_udplite_get_port
+c03b0b28 r __ksymtab_arp_broken_ops
+c03b0b30 r __ksymtab_arp_find
+c03b0b38 r __ksymtab_arp_create
+c03b0b40 r __ksymtab_arp_xmit
+c03b0b48 r __ksymtab_arp_send
+c03b0b50 r __ksymtab_arp_tbl
+c03b0b58 r __ksymtab_icmp_err_convert
+c03b0b60 r __ksymtab_icmp_send
+c03b0b68 r __ksymtab_icmp_statistics
+c03b0b70 r __ksymtab_xrlim_allow
+c03b0b78 r __ksymtab_in_dev_finish_destroy
+c03b0b80 r __ksymtab_inet_select_addr
+c03b0b88 r __ksymtab_inetdev_by_index
+c03b0b90 r __ksymtab_register_inetaddr_notifier
+c03b0b98 r __ksymtab_unregister_inetaddr_notifier
+c03b0ba0 r __ksymtab_inet_ehash_secret
+c03b0ba8 r __ksymtab_build_ehash_secret
+c03b0bb0 r __ksymtab_inet_sk_rebuild_header
+c03b0bb8 r __ksymtab_inet_accept
+c03b0bc0 r __ksymtab_inet_bind
+c03b0bc8 r __ksymtab_inet_dgram_connect
+c03b0bd0 r __ksymtab_inet_dgram_ops
+c03b0bd8 r __ksymtab_inet_getname
+c03b0be0 r __ksymtab_inet_ioctl
+c03b0be8 r __ksymtab_inet_listen
+c03b0bf0 r __ksymtab_inet_register_protosw
+c03b0bf8 r __ksymtab_inet_release
+c03b0c00 r __ksymtab_inet_sendmsg
+c03b0c08 r __ksymtab_inet_shutdown
+c03b0c10 r __ksymtab_inet_sock_destruct
+c03b0c18 r __ksymtab_inet_stream_connect
+c03b0c20 r __ksymtab_inet_stream_ops
+c03b0c28 r __ksymtab_inet_unregister_protosw
+c03b0c30 r __ksymtab_net_statistics
+c03b0c38 r __ksymtab_ip_mc_dec_group
+c03b0c40 r __ksymtab_ip_mc_inc_group
+c03b0c48 r __ksymtab_ip_mc_join_group
+c03b0c50 r __ksymtab_ip_mc_rejoin_group
+c03b0c58 r __ksymtab_inet_addr_type
+c03b0c60 r __ksymtab_ip_dev_find
+c03b0c68 r __ksymtab_xfrm4_tunnel_register
+c03b0c70 r __ksymtab_xfrm4_tunnel_deregister
+c03b0c78 r __ksymtab_ip_route_me_harder
+c03b0c80 r __ksymtab_ip_xfrm_me_harder
+c03b0c88 r __ksymtab_ip_nat_decode_session
+c03b0c90 r __ksymtab_nf_ip_checksum
+c03b0c98 r __ksymtab_xfrm4_rcv
+c03b0ca0 r __ksymtab_xfrm_cfg_mutex
+c03b0ca8 r __ksymtab_xfrm_policy_count
+c03b0cb0 r __ksymtab_xfrm_register_type
+c03b0cb8 r __ksymtab_xfrm_unregister_type
+c03b0cc0 r __ksymtab_xfrm_dst_lookup
+c03b0cc8 r __ksymtab_xfrm_register_mode
+c03b0cd0 r __ksymtab_xfrm_unregister_mode
+c03b0cd8 r __ksymtab_xfrm_policy_alloc
+c03b0ce0 r __ksymtab___xfrm_policy_destroy
+c03b0ce8 r __ksymtab_xfrm_spd_getinfo
+c03b0cf0 r __ksymtab_xfrm_policy_insert
+c03b0cf8 r __ksymtab_xfrm_policy_bysel_ctx
+c03b0d00 r __ksymtab_xfrm_policy_byid
+c03b0d08 r __ksymtab_xfrm_policy_flush
+c03b0d10 r __ksymtab_xfrm_policy_walk
+c03b0d18 r __ksymtab_xfrm_policy_delete
+c03b0d20 r __ksymtab___xfrm_lookup
+c03b0d28 r __ksymtab_xfrm_lookup
+c03b0d30 r __ksymtab_xfrm_decode_session
+c03b0d38 r __ksymtab___xfrm_policy_check
+c03b0d40 r __ksymtab___xfrm_route_forward
+c03b0d48 r __ksymtab_xfrm_dst_ifdown
+c03b0d50 r __ksymtab_xfrm_init_pmtu
+c03b0d58 r __ksymtab_xfrm_bundle_ok
+c03b0d60 r __ksymtab_xfrm_policy_register_afinfo
+c03b0d68 r __ksymtab_xfrm_policy_unregister_afinfo
+c03b0d70 r __ksymtab_xfrm_nl
+c03b0d78 r __ksymtab_km_waitq
+c03b0d80 r __ksymtab_xfrm_state_alloc
+c03b0d88 r __ksymtab___xfrm_state_destroy
+c03b0d90 r __ksymtab___xfrm_state_delete
+c03b0d98 r __ksymtab_xfrm_state_delete
+c03b0da0 r __ksymtab_xfrm_state_flush
+c03b0da8 r __ksymtab_xfrm_sad_getinfo
+c03b0db0 r __ksymtab_xfrm_state_insert
+c03b0db8 r __ksymtab_xfrm_state_add
+c03b0dc0 r __ksymtab_xfrm_state_update
+c03b0dc8 r __ksymtab_xfrm_state_check_expire
+c03b0dd0 r __ksymtab_xfrm_state_check
+c03b0dd8 r __ksymtab_xfrm_state_lookup
+c03b0de0 r __ksymtab_xfrm_state_lookup_byaddr
+c03b0de8 r __ksymtab_xfrm_find_acq
+c03b0df0 r __ksymtab_xfrm_find_acq_byseq
+c03b0df8 r __ksymtab_xfrm_get_acqseq
+c03b0e00 r __ksymtab_xfrm_alloc_spi
+c03b0e08 r __ksymtab_xfrm_state_walk
+c03b0e10 r __ksymtab_xfrm_replay_notify
+c03b0e18 r __ksymtab_xfrm_replay_check
+c03b0e20 r __ksymtab_xfrm_replay_advance
+c03b0e28 r __ksymtab_km_policy_notify
+c03b0e30 r __ksymtab_km_state_notify
+c03b0e38 r __ksymtab_km_state_expired
+c03b0e40 r __ksymtab_km_query
+c03b0e48 r __ksymtab_km_new_mapping
+c03b0e50 r __ksymtab_km_policy_expired
+c03b0e58 r __ksymtab_km_migrate
+c03b0e60 r __ksymtab_km_report
+c03b0e68 r __ksymtab_xfrm_user_policy
+c03b0e70 r __ksymtab_xfrm_register_km
+c03b0e78 r __ksymtab_xfrm_unregister_km
+c03b0e80 r __ksymtab_xfrm_state_register_afinfo
+c03b0e88 r __ksymtab_xfrm_state_unregister_afinfo
+c03b0e90 r __ksymtab_xfrm_state_get_afinfo
+c03b0e98 r __ksymtab_xfrm_state_put_afinfo
+c03b0ea0 r __ksymtab_xfrm_state_delete_tunnel
+c03b0ea8 r __ksymtab_xfrm_init_state
+c03b0eb0 r __ksymtab___secpath_destroy
+c03b0eb8 r __ksymtab_secpath_dup
+c03b0ec0 r __ksymtab_xfrm_parse_spi
+c03b0ec8 r __ksymtab_inet6_bind
+c03b0ed0 r __ksymtab_inet6_release
+c03b0ed8 r __ksymtab_inet6_getname
+c03b0ee0 r __ksymtab_inet6_ioctl
+c03b0ee8 r __ksymtab_inet6_register_protosw
+c03b0ef0 r __ksymtab_inet6_unregister_protosw
+c03b0ef8 r __ksymtab_ip6_xmit
+c03b0f00 r __ksymtab_in6_dev_finish_destroy
+c03b0f08 r __ksymtab_ipv6_get_saddr
+c03b0f10 r __ksymtab_ipv6_chk_addr
+c03b0f18 r __ksymtab_register_inet6addr_notifier
+c03b0f20 r __ksymtab_unregister_inet6addr_notifier
+c03b0f28 r __ksymtab_rt6_lookup
+c03b0f30 r __ksymtab_ip6_route_output
+c03b0f38 r __ksymtab_ipv6_setsockopt
+c03b0f40 r __ksymtab_ipv6_getsockopt
+c03b0f48 r __ksymtab_ndisc_mc_map
+c03b0f50 r __ksymtab_inet6_add_protocol
+c03b0f58 r __ksymtab_inet6_del_protocol
+c03b0f60 r __ksymtab_icmpv6_statistics
+c03b0f68 r __ksymtab_icmpv6_send
+c03b0f70 r __ksymtab_icmpv6_err_convert
+c03b0f78 r __ksymtab_ipv6_push_nfrag_opts
+c03b0f80 r __ksymtab_xfrm6_rcv_spi
+c03b0f88 r __ksymtab_xfrm6_rcv
+c03b0f90 r __ksymtab_xfrm6_input_addr
+c03b0f98 r __ksymtab_xfrm6_find_1stfragopt
+c03b0fa0 r __ksymtab_ip6_route_me_harder
+c03b0fa8 r __ksymtab_nf_ip6_checksum
+c03b0fb0 r __ksymtab___ipv6_addr_type
+c03b0fb8 r __ksymtab_ipv6_ext_hdr
+c03b0fc0 r __ksymtab_ipv6_skip_exthdr
+c03b0fc8 r __ksymtab___inet6_hash
+c03b0fd0 r __ksymtab___inet6_lookup_established
+c03b0fd8 r __ksymtab_wireless_send_event
+c03b0fe0 r __ksymtab_iw_handler_set_spy
+c03b0fe8 r __ksymtab_iw_handler_get_spy
+c03b0ff0 r __ksymtab_iw_handler_set_thrspy
+c03b0ff8 r __ksymtab_iw_handler_get_thrspy
+c03b1000 r __ksymtab_wireless_spy_update
+c03b1008 r __ksymtab_sha_transform
+c03b1010 r __ksymtab_init_uts_ns
+c03b1010 R __start___ksymtab_gpl
+c03b1010 R __stop___ksymtab
+c03b1018 r __ksymtab_cpu_idle_wait
+c03b1020 r __ksymtab_edid_info
+c03b1028 r __ksymtab_kernel_fpu_begin
+c03b1030 r __ksymtab_e820_any_mapped
+c03b1038 r __ksymtab_mark_tsc_unstable
+c03b1040 r __ksymtab_per_cpu__gdt_page
+c03b1048 r __ksymtab_nr_mce_banks
+c03b1050 r __ksymtab_local_apic_timer_c2_ok
+c03b1058 r __ksymtab_vdso_enabled
+c03b1060 r __ksymtab_register_page_fault_notifier
+c03b1068 r __ksymtab_unregister_page_fault_notifier
+c03b1070 r __ksymtab___wake_up_sync
+c03b1078 r __ksymtab_task_nice
+c03b1080 r __ksymtab_sched_setscheduler
+c03b1088 r __ksymtab_set_cpus_allowed
+c03b1090 r __ksymtab_mmput
+c03b1098 r __ksymtab_get_task_mm
+c03b10a0 r __ksymtab_copy_fs_struct
+c03b10a8 r __ksymtab_prof_on
+c03b10b0 r __ksymtab_register_timer_hook
+c03b10b8 r __ksymtab_unregister_timer_hook
+c03b10c0 r __ksymtab_task_handoff_register
+c03b10c8 r __ksymtab_task_handoff_unregister
+c03b10d0 r __ksymtab_profile_event_register
+c03b10d8 r __ksymtab_profile_event_unregister
+c03b10e0 r __ksymtab_profile_hits
+c03b10e8 r __ksymtab_exit_fs
+c03b10f0 r __ksymtab_do_exit
+c03b10f8 r __ksymtab___local_bh_enable
+c03b1100 r __ksymtab_register_net_sysctl_table
+c03b1108 r __ksymtab_unregister_net_sysctl_table
+c03b1110 r __ksymtab___round_jiffies
+c03b1118 r __ksymtab___round_jiffies_relative
+c03b1120 r __ksymtab_round_jiffies
+c03b1128 r __ksymtab_round_jiffies_relative
+c03b1130 r __ksymtab_init_user_ns
+c03b1138 r __ksymtab_kill_pid_info_as_uid
+c03b1140 r __ksymtab_dequeue_signal
+c03b1148 r __ksymtab_atomic_notifier_chain_register
+c03b1150 r __ksymtab_atomic_notifier_chain_unregister
+c03b1158 r __ksymtab___atomic_notifier_call_chain
+c03b1160 r __ksymtab_atomic_notifier_call_chain
+c03b1168 r __ksymtab_blocking_notifier_chain_register
+c03b1170 r __ksymtab_blocking_notifier_chain_unregister
+c03b1178 r __ksymtab___blocking_notifier_call_chain
+c03b1180 r __ksymtab_blocking_notifier_call_chain
+c03b1188 r __ksymtab_raw_notifier_chain_register
+c03b1190 r __ksymtab_raw_notifier_chain_unregister
+c03b1198 r __ksymtab___raw_notifier_call_chain
+c03b11a0 r __ksymtab_raw_notifier_call_chain
+c03b11a8 r __ksymtab_srcu_notifier_chain_register
+c03b11b0 r __ksymtab_srcu_notifier_chain_unregister
+c03b11b8 r __ksymtab___srcu_notifier_call_chain
+c03b11c0 r __ksymtab_srcu_notifier_call_chain
+c03b11c8 r __ksymtab_srcu_init_notifier_head
+c03b11d0 r __ksymtab_emergency_restart
+c03b11d8 r __ksymtab_kernel_restart
+c03b11e0 r __ksymtab_kernel_halt
+c03b11e8 r __ksymtab_kernel_power_off
+c03b11f0 r __ksymtab_orderly_poweroff
+c03b11f8 r __ksymtab_queue_work
+c03b1200 r __ksymtab_queue_delayed_work
+c03b1208 r __ksymtab_queue_delayed_work_on
+c03b1210 r __ksymtab_flush_workqueue
+c03b1218 r __ksymtab_cancel_work_sync
+c03b1220 r __ksymtab_execute_in_process_context
+c03b1228 r __ksymtab___create_workqueue
+c03b1230 r __ksymtab_destroy_workqueue
+c03b1238 r __ksymtab_put_pid
+c03b1240 r __ksymtab_find_pid
+c03b1248 r __ksymtab_find_get_pid
+c03b1250 r __ksymtab_rcu_barrier
+c03b1258 r __ksymtab_rcu_batches_completed
+c03b1260 r __ksymtab_rcu_batches_completed_bh
+c03b1268 r __ksymtab_call_rcu
+c03b1270 r __ksymtab_call_rcu_bh
+c03b1278 r __ksymtab_synchronize_rcu
+c03b1280 r __ksymtab_posix_timer_event
+c03b1288 r __ksymtab_register_posix_clock
+c03b1290 r __ksymtab_do_posix_clock_nosettime
+c03b1298 r __ksymtab_do_posix_clock_nonanosleep
+c03b12a0 r __ksymtab_ktime_get
+c03b12a8 r __ksymtab_ktime_get_real
+c03b12b0 r __ksymtab_ktime_get_ts
+c03b12b8 r __ksymtab_hrtimer_forward
+c03b12c0 r __ksymtab_hrtimer_start
+c03b12c8 r __ksymtab_hrtimer_try_to_cancel
+c03b12d0 r __ksymtab_hrtimer_cancel
+c03b12d8 r __ksymtab_hrtimer_get_remaining
+c03b12e0 r __ksymtab_hrtimer_init
+c03b12e8 r __ksymtab_hrtimer_get_res
+c03b12f0 r __ksymtab_set_acceptable_latency
+c03b12f8 r __ksymtab_modify_acceptable_latency
+c03b1300 r __ksymtab_remove_acceptable_latency
+c03b1308 r __ksymtab_system_latency_constraint
+c03b1310 r __ksymtab_synchronize_acceptable_latency
+c03b1318 r __ksymtab_register_latency_notifier
+c03b1320 r __ksymtab_unregister_latency_notifier
+c03b1328 r __ksymtab_init_srcu_struct
+c03b1330 r __ksymtab_cleanup_srcu_struct
+c03b1338 r __ksymtab_srcu_read_lock
+c03b1340 r __ksymtab_srcu_read_unlock
+c03b1348 r __ksymtab_synchronize_srcu
+c03b1350 r __ksymtab_srcu_batches_completed
+c03b1358 r __ksymtab_srcu_readers_active
+c03b1360 r __ksymtab_register_die_notifier
+c03b1368 r __ksymtab_unregister_die_notifier
+c03b1370 r __ksymtab_free_vx_info
+c03b1378 r __ksymtab_free_nx_info
+c03b1380 r __ksymtab_unhash_nx_info
+c03b1388 r __ksymtab_vlimit_name
+c03b1390 r __ksymtab_locate_dl_info
+c03b1398 r __ksymtab_rcu_free_dl_info
+c03b13a0 r __ksymtab_ip_v4_find_src
+c03b13a8 r __ksymtab_clockevents_notify
+c03b13b0 r __ksymtab_get_futex_key
+c03b13b8 r __ksymtab_get_futex_key_refs
+c03b13c0 r __ksymtab_drop_futex_key_refs
+c03b13c8 r __ksymtab_rt_mutex_lock
+c03b13d0 r __ksymtab_rt_mutex_lock_interruptible
+c03b13d8 r __ksymtab_rt_mutex_timed_lock
+c03b13e0 r __ksymtab_rt_mutex_trylock
+c03b13e8 r __ksymtab_rt_mutex_unlock
+c03b13f0 r __ksymtab_rt_mutex_destroy
+c03b13f8 r __ksymtab___rt_mutex_init
+c03b1400 r __ksymtab_symbol_put_addr
+c03b1408 r __ksymtab___symbol_get
+c03b1410 r __ksymtab_sprint_symbol
+c03b1418 r __ksymtab_stop_machine_run
+c03b1420 r __ksymtab_register_kprobe
+c03b1428 r __ksymtab_unregister_kprobe
+c03b1430 r __ksymtab_register_jprobe
+c03b1438 r __ksymtab_unregister_jprobe
+c03b1440 r __ksymtab_jprobe_return
+c03b1448 r __ksymtab_register_kretprobe
+c03b1450 r __ksymtab_unregister_kretprobe
+c03b1458 r __ksymtab_kernel_subsys
+c03b1460 r __ksymtab_relay_buf_empty
+c03b1468 r __ksymtab_relay_buf_full
+c03b1470 r __ksymtab_relay_reset
+c03b1478 r __ksymtab_relay_open
+c03b1480 r __ksymtab_relay_switch_subbuf
+c03b1488 r __ksymtab_relay_subbufs_consumed
+c03b1490 r __ksymtab_relay_close
+c03b1498 r __ksymtab_relay_flush
+c03b14a0 r __ksymtab_relay_file_operations
+c03b14a8 r __ksymtab_default_backing_dev_info
+c03b14b0 r __ksymtab_file_ra_state_init
+c03b14b8 r __ksymtab_page_cache_readahead
+c03b14c0 r __ksymtab_invalidate_inode_pages2_range
+c03b14c8 r __ksymtab_invalidate_inode_pages2
+c03b14d0 r __ksymtab_all_vm_events
+c03b14d8 r __ksymtab_apply_to_page_range
+c03b14e0 r __ksymtab___handle_mm_fault
+c03b14e8 r __ksymtab_page_mkclean
+c03b14f0 r __ksymtab_kmem_cache_name
+c03b14f8 r __ksymtab_xip_file_read
+c03b1500 r __ksymtab_xip_file_sendfile
+c03b1508 r __ksymtab_xip_file_mmap
+c03b1510 r __ksymtab_xip_file_write
+c03b1518 r __ksymtab_xip_truncate_page
+c03b1520 r __ksymtab_percpu_depopulate
+c03b1528 r __ksymtab___percpu_depopulate_mask
+c03b1530 r __ksymtab_percpu_populate
+c03b1538 r __ksymtab___percpu_populate_mask
+c03b1540 r __ksymtab___percpu_alloc_mask
+c03b1548 r __ksymtab_percpu_free
+c03b1550 r __ksymtab_lookup_instantiate_filp
+c03b1558 r __ksymtab_sys_open
+c03b1560 r __ksymtab_sys_read
+c03b1568 r __ksymtab_get_max_files
+c03b1570 r __ksymtab_vfs_kern_mount
+c03b1578 r __ksymtab_lookup_create
+c03b1580 r __ksymtab_vfs_test_lock
+c03b1588 r __ksymtab_vfs_lock_file
+c03b1590 r __ksymtab_vfs_cancel_lock
+c03b1598 r __ksymtab_sysctl_vfs_cache_pressure
+c03b15a0 r __ksymtab_d_materialise_unique
+c03b15a8 r __ksymtab___iget
+c03b15b0 r __ksymtab_generic_drop_inode
+c03b15b8 r __ksymtab_fs_subsys
+c03b15c0 r __ksymtab_do_add_mount
+c03b15c8 r __ksymtab_mark_mounts_for_expiry
+c03b15d0 r __ksymtab_shrink_submounts
+c03b15d8 r __ksymtab_vfs_setxattr
+c03b15e0 r __ksymtab_vfs_getxattr
+c03b15e8 r __ksymtab_vfs_listxattr
+c03b15f0 r __ksymtab_vfs_removexattr
+c03b15f8 r __ksymtab_simple_attr_open
+c03b1600 r __ksymtab_simple_attr_close
+c03b1608 r __ksymtab_simple_attr_read
+c03b1610 r __ksymtab_simple_attr_write
+c03b1618 r __ksymtab_do_sync_mapping_range
+c03b1620 r __ksymtab_fsstack_copy_inode_size
+c03b1628 r __ksymtab_fsstack_copy_attr_all
+c03b1630 r __ksymtab_alloc_page_buffers
+c03b1638 r __ksymtab_bd_claim_by_disk
+c03b1640 r __ksymtab_bd_release_from_disk
+c03b1648 r __ksymtab_get_inotify_watch
+c03b1650 r __ksymtab_put_inotify_watch
+c03b1658 r __ksymtab_inotify_remove_watch_locked
+c03b1660 r __ksymtab_inotify_inode_queue_event
+c03b1668 r __ksymtab_inotify_dentry_parent_queue_event
+c03b1670 r __ksymtab_inotify_get_cookie
+c03b1678 r __ksymtab_inotify_unmount_inodes
+c03b1680 r __ksymtab_inotify_inode_is_dead
+c03b1688 r __ksymtab_inotify_init
+c03b1690 r __ksymtab_inotify_init_watch
+c03b1698 r __ksymtab_inotify_destroy
+c03b16a0 r __ksymtab_inotify_find_watch
+c03b16a8 r __ksymtab_inotify_find_update_watch
+c03b16b0 r __ksymtab_inotify_add_watch
+c03b16b8 r __ksymtab_inotify_rm_wd
+c03b16c0 r __ksymtab_inotify_rm_watch
+c03b16c8 r __ksymtab_dnotify_parent
+c03b16d0 r __ksymtab_sysfs_notify
+c03b16d8 r __ksymtab_sysfs_add_file_to_group
+c03b16e0 r __ksymtab_sysfs_chmod_file
+c03b16e8 r __ksymtab_sysfs_remove_file_from_group
+c03b16f0 r __ksymtab_sysfs_schedule_callback
+c03b16f8 r __ksymtab_sysfs_create_file
+c03b1700 r __ksymtab_sysfs_remove_file
+c03b1708 r __ksymtab_sysfs_update_file
+c03b1710 r __ksymtab_sysfs_create_link
+c03b1718 r __ksymtab_sysfs_remove_link
+c03b1720 r __ksymtab_sysfs_create_bin_file
+c03b1728 r __ksymtab_sysfs_remove_bin_file
+c03b1730 r __ksymtab_sysfs_create_group
+c03b1738 r __ksymtab_sysfs_remove_group
+c03b1740 r __ksymtab_dcookie_register
+c03b1748 r __ksymtab_dcookie_unregister
+c03b1750 r __ksymtab_get_dcookie
+c03b1758 r __ksymtab_debugfs_create_file
+c03b1760 r __ksymtab_debugfs_create_dir
+c03b1768 r __ksymtab_debugfs_create_symlink
+c03b1770 r __ksymtab_debugfs_remove
+c03b1778 r __ksymtab_debugfs_create_u8
+c03b1780 r __ksymtab_debugfs_create_u16
+c03b1788 r __ksymtab_debugfs_create_u32
+c03b1790 r __ksymtab_debugfs_create_u64
+c03b1798 r __ksymtab_debugfs_create_bool
+c03b17a0 r __ksymtab_debugfs_create_blob
+c03b17a8 r __ksymtab_crypto_alg_list
+c03b17b0 r __ksymtab_crypto_alg_sem
+c03b17b8 r __ksymtab_crypto_chain
+c03b17c0 r __ksymtab_crypto_mod_get
+c03b17c8 r __ksymtab_crypto_mod_put
+c03b17d0 r __ksymtab___crypto_alg_lookup
+c03b17d8 r __ksymtab_crypto_alg_mod_lookup
+c03b17e0 r __ksymtab_crypto_shoot_alg
+c03b17e8 r __ksymtab___crypto_alloc_tfm
+c03b17f0 r __ksymtab_crypto_alloc_base
+c03b17f8 r __ksymtab_crypto_free_tfm
+c03b1800 r __ksymtab_crypto_has_alg
+c03b1808 r __ksymtab_crypto_km_types
+c03b1810 r __ksymtab_scatterwalk_start
+c03b1818 r __ksymtab_scatterwalk_map
+c03b1820 r __ksymtab_scatterwalk_done
+c03b1828 r __ksymtab_scatterwalk_copychunks
+c03b1830 r __ksymtab_elv_register
+c03b1838 r __ksymtab_elv_unregister
+c03b1840 r __ksymtab_blk_execute_rq_nowait
+c03b1848 r __ksymtab_disk_round_stats
+c03b1850 r __ksymtab___blk_put_request
+c03b1858 r __ksymtab_blkdev_driver_ioctl
+c03b1860 r __ksymtab_blkdev_ioctl
+c03b1868 r __ksymtab_genhd_media_change_notify
+c03b1870 r __ksymtab_sg_scsi_ioctl
+c03b1878 r __ksymtab___blk_add_trace
+c03b1880 r __ksymtab_kobject_get_path
+c03b1888 r __ksymtab_kobject_uevent_env
+c03b1890 r __ksymtab_kobject_uevent
+c03b1898 r __ksymtab_add_uevent_var
+c03b18a0 r __ksymtab___iowrite32_copy
+c03b18a8 r __ksymtab___iowrite64_copy
+c03b18b0 r __ksymtab_byte_rev_table
+c03b18b8 r __ksymtab_pci_block_user_cfg_access
+c03b18c0 r __ksymtab_pci_unblock_user_cfg_access
+c03b18c8 r __ksymtab_pci_walk_bus
+c03b18d0 r __ksymtab_pci_bus_add_device
+c03b18d8 r __ksymtab_pci_create_bus
+c03b18e0 r __ksymtab_pci_scan_child_bus
+c03b18e8 r __ksymtab_pci_stop_bus_device
+c03b18f0 r __ksymtab_pci_bus_max_busnr
+c03b18f8 r __ksymtab_pci_find_next_capability
+c03b1900 r __ksymtab_pci_find_ext_capability
+c03b1908 r __ksymtab_pci_find_next_ht_capability
+c03b1910 r __ksymtab_pci_find_ht_capability
+c03b1918 r __ksymtab_pci_restore_bars
+c03b1920 r __ksymtab_pci_intx
+c03b1928 r __ksymtab_pci_set_pcie_reset_state
+c03b1930 r __ksymtab_pci_claim_resource
+c03b1938 r __ksymtab_pcie_port_bus_type
+c03b1940 r __ksymtab_pci_find_aer_capability
+c03b1948 r __ksymtab_pci_enable_pcie_error_reporting
+c03b1950 r __ksymtab_pci_disable_pcie_error_reporting
+c03b1958 r __ksymtab_pci_cleanup_aer_uncorrect_error_status
+c03b1960 r __ksymtab_fb_notifier_call_chain
+c03b1968 r __ksymtab_acpi_os_map_memory
+c03b1970 r __ksymtab_acpi_os_unmap_memory
+c03b1978 r __ksymtab_acpi_bus_get_ejd
+c03b1980 r __ksymtab_acpi_bus_trim
+c03b1988 r __ksymtab_acpi_ec_add_query_handler
+c03b1990 r __ksymtab_acpi_ec_remove_query_handler
+c03b1998 r __ksymtab_acpi_get_pci_rootbridge_handle
+c03b19a0 r __ksymtab_add_input_randomness
+c03b19a8 r __ksymtab_tty_buffer_request_room
+c03b19b0 r __ksymtab_tty_prepare_flip_string
+c03b19b8 r __ksymtab_tty_prepare_flip_string_flags
+c03b19c0 r __ksymtab_tty_ldisc_get
+c03b19c8 r __ksymtab_tty_ldisc_put
+c03b19d0 r __ksymtab_tty_ldisc_ref_wait
+c03b19d8 r __ksymtab_tty_ldisc_ref
+c03b19e0 r __ksymtab_tty_ldisc_deref
+c03b19e8 r __ksymtab_tty_wakeup
+c03b19f0 r __ksymtab_tty_ldisc_flush
+c03b19f8 r __ksymtab_get_current_tty
+c03b1a00 r __ksymtab_tty_termios_encode_baud_rate
+c03b1a08 r __ksymtab_hwrng_register
+c03b1a10 r __ksymtab_hwrng_unregister
+c03b1a18 r __ksymtab_uart_console_write
+c03b1a20 r __ksymtab_pciserial_init_ports
+c03b1a28 r __ksymtab_pciserial_remove_ports
+c03b1a30 r __ksymtab_pciserial_suspend_ports
+c03b1a38 r __ksymtab_pciserial_resume_ports
+c03b1a40 r __ksymtab_device_create_bin_file
+c03b1a48 r __ksymtab_device_remove_bin_file
+c03b1a50 r __ksymtab_device_schedule_callback_owner
+c03b1a58 r __ksymtab_device_for_each_child
+c03b1a60 r __ksymtab_device_find_child
+c03b1a68 r __ksymtab_device_initialize
+c03b1a70 r __ksymtab_device_add
+c03b1a78 r __ksymtab_device_register
+c03b1a80 r __ksymtab_device_del
+c03b1a88 r __ksymtab_device_unregister
+c03b1a90 r __ksymtab_get_device
+c03b1a98 r __ksymtab_put_device
+c03b1aa0 r __ksymtab_device_create_file
+c03b1aa8 r __ksymtab_device_remove_file
+c03b1ab0 r __ksymtab_device_create
+c03b1ab8 r __ksymtab_device_destroy
+c03b1ac0 r __ksymtab_device_rename
+c03b1ac8 r __ksymtab_device_move
+c03b1ad0 r __ksymtab_sysdev_create_file
+c03b1ad8 r __ksymtab_sysdev_remove_file
+c03b1ae0 r __ksymtab_sysdev_class_create_file
+c03b1ae8 r __ksymtab_sysdev_class_remove_file
+c03b1af0 r __ksymtab_sysdev_class_register
+c03b1af8 r __ksymtab_sysdev_class_unregister
+c03b1b00 r __ksymtab_sysdev_driver_register
+c03b1b08 r __ksymtab_sysdev_driver_unregister
+c03b1b10 r __ksymtab_sysdev_register
+c03b1b18 r __ksymtab_sysdev_unregister
+c03b1b20 r __ksymtab_device_reprobe
+c03b1b28 r __ksymtab_bus_register_notifier
+c03b1b30 r __ksymtab_bus_unregister_notifier
+c03b1b38 r __ksymtab_bus_for_each_dev
+c03b1b40 r __ksymtab_bus_find_device
+c03b1b48 r __ksymtab_bus_for_each_drv
+c03b1b50 r __ksymtab_bus_register
+c03b1b58 r __ksymtab_bus_unregister
+c03b1b60 r __ksymtab_bus_rescan_devices
+c03b1b68 r __ksymtab_bus_create_file
+c03b1b70 r __ksymtab_bus_remove_file
+c03b1b78 r __ksymtab_device_bind_driver
+c03b1b80 r __ksymtab_device_release_driver
+c03b1b88 r __ksymtab_device_attach
+c03b1b90 r __ksymtab_driver_attach
+c03b1b98 r __ksymtab_driver_for_each_device
+c03b1ba0 r __ksymtab_driver_find_device
+c03b1ba8 r __ksymtab_driver_register
+c03b1bb0 r __ksymtab_driver_unregister
+c03b1bb8 r __ksymtab_get_driver
+c03b1bc0 r __ksymtab_put_driver
+c03b1bc8 r __ksymtab_driver_find
+c03b1bd0 r __ksymtab_driver_create_file
+c03b1bd8 r __ksymtab_driver_remove_file
+c03b1be0 r __ksymtab_class_create_file
+c03b1be8 r __ksymtab_class_remove_file
+c03b1bf0 r __ksymtab_class_register
+c03b1bf8 r __ksymtab_class_unregister
+c03b1c00 r __ksymtab_class_create
+c03b1c08 r __ksymtab_class_destroy
+c03b1c10 r __ksymtab_class_device_register
+c03b1c18 r __ksymtab_class_device_unregister
+c03b1c20 r __ksymtab_class_device_initialize
+c03b1c28 r __ksymtab_class_device_add
+c03b1c30 r __ksymtab_class_device_del
+c03b1c38 r __ksymtab_class_device_get
+c03b1c40 r __ksymtab_class_device_put
+c03b1c48 r __ksymtab_class_device_create
+c03b1c50 r __ksymtab_class_device_destroy
+c03b1c58 r __ksymtab_class_device_create_file
+c03b1c60 r __ksymtab_class_device_remove_file
+c03b1c68 r __ksymtab_class_device_create_bin_file
+c03b1c70 r __ksymtab_class_device_remove_bin_file
+c03b1c78 r __ksymtab_class_interface_register
+c03b1c80 r __ksymtab_class_interface_unregister
+c03b1c88 r __ksymtab_platform_bus
+c03b1c90 r __ksymtab_platform_get_resource
+c03b1c98 r __ksymtab_platform_get_irq
+c03b1ca0 r __ksymtab_platform_get_resource_byname
+c03b1ca8 r __ksymtab_platform_get_irq_byname
+c03b1cb0 r __ksymtab_platform_add_devices
+c03b1cb8 r __ksymtab_platform_device_put
+c03b1cc0 r __ksymtab_platform_device_alloc
+c03b1cc8 r __ksymtab_platform_device_add_resources
+c03b1cd0 r __ksymtab_platform_device_add_data
+c03b1cd8 r __ksymtab_platform_device_add
+c03b1ce0 r __ksymtab_platform_device_del
+c03b1ce8 r __ksymtab_platform_device_register
+c03b1cf0 r __ksymtab_platform_device_unregister
+c03b1cf8 r __ksymtab_platform_device_register_simple
+c03b1d00 r __ksymtab_platform_driver_register
+c03b1d08 r __ksymtab_platform_driver_unregister
+c03b1d10 r __ksymtab_platform_driver_probe
+c03b1d18 r __ksymtab_platform_bus_type
+c03b1d20 r __ksymtab_dma_get_required_mask
+c03b1d28 r __ksymtab_get_cpu_sysdev
+c03b1d30 r __ksymtab_firmware_register
+c03b1d38 r __ksymtab_firmware_unregister
+c03b1d40 r __ksymtab_devres_alloc
+c03b1d48 r __ksymtab_devres_free
+c03b1d50 r __ksymtab_devres_add
+c03b1d58 r __ksymtab_devres_find
+c03b1d60 r __ksymtab_devres_get
+c03b1d68 r __ksymtab_devres_remove
+c03b1d70 r __ksymtab_devres_destroy
+c03b1d78 r __ksymtab_devres_open_group
+c03b1d80 r __ksymtab_devres_close_group
+c03b1d88 r __ksymtab_devres_remove_group
+c03b1d90 r __ksymtab_devres_release_group
+c03b1d98 r __ksymtab_devm_kzalloc
+c03b1da0 r __ksymtab_devm_kfree
+c03b1da8 r __ksymtab_attribute_container_classdev_to_container
+c03b1db0 r __ksymtab_attribute_container_register
+c03b1db8 r __ksymtab_attribute_container_unregister
+c03b1dc0 r __ksymtab_attribute_container_find_class_device
+c03b1dc8 r __ksymtab_transport_class_register
+c03b1dd0 r __ksymtab_transport_class_unregister
+c03b1dd8 r __ksymtab_anon_transport_class_register
+c03b1de0 r __ksymtab_anon_transport_class_unregister
+c03b1de8 r __ksymtab_transport_setup_device
+c03b1df0 r __ksymtab_transport_add_device
+c03b1df8 r __ksymtab_transport_configure_device
+c03b1e00 r __ksymtab_transport_remove_device
+c03b1e08 r __ksymtab_transport_destroy_device
+c03b1e10 r __ksymtab_device_pm_set_parent
+c03b1e18 r __ksymtab_device_suspend
+c03b1e20 r __ksymtab_device_power_down
+c03b1e28 r __ksymtab___suspend_report_result
+c03b1e30 r __ksymtab_device_resume
+c03b1e38 r __ksymtab_device_power_up
+c03b1e40 r __ksymtab_ide_setting_sem
+c03b1e48 r __ksymtab_ide_bus_type
+c03b1e50 r __ksymtab_ide_end_dequeued_request
+c03b1e58 r __ksymtab___ide_error
+c03b1e60 r __ksymtab_ide_error
+c03b1e68 r __ksymtab___ide_abort
+c03b1e70 r __ksymtab_ide_map_sg
+c03b1e78 r __ksymtab_ide_init_sg_cmd
+c03b1e80 r __ksymtab_ide_wait_not_busy
+c03b1e88 r __ksymtab_ide_use_fast_pio
+c03b1e90 r __ksymtab_ide_pio_timings
+c03b1e98 r __ksymtab_ide_get_best_pio_mode
+c03b1ea0 r __ksymtab_ide_undecoded_slave
+c03b1ea8 r __ksymtab_ide_register_region
+c03b1eb0 r __ksymtab_ide_unregister_region
+c03b1eb8 r __ksymtab_ide_init_disk
+c03b1ec0 r __ksymtab_ideprobe_init
+c03b1ec8 r __ksymtab_ide_setup_pci_noise
+c03b1ed0 r __ksymtab_ide_pci_setup_ports
+c03b1ed8 r __ksymtab_ide_setup_pci_device
+c03b1ee0 r __ksymtab_ide_setup_pci_devices
+c03b1ee8 r __ksymtab___ide_pci_register_driver
+c03b1ef0 r __ksymtab_ide_dma_intr
+c03b1ef8 r __ksymtab_ide_build_sglist
+c03b1f00 r __ksymtab_ide_build_dmatable
+c03b1f08 r __ksymtab_ide_destroy_dmatable
+c03b1f10 r __ksymtab_ide_dma_setup
+c03b1f18 r __ksymtab_ide_dma_start
+c03b1f20 r __ksymtab_ide_max_dma_mode
+c03b1f28 r __ksymtab_ide_tune_dma
+c03b1f30 r __ksymtab_ide_set_dma
+c03b1f38 r __ksymtab_ide_setup_dma
+c03b1f40 r __ksymtab_usb_get_intf
+c03b1f48 r __ksymtab_usb_put_intf
+c03b1f50 r __ksymtab_ehci_cf_port_reset_rwsem
+c03b1f58 r __ksymtab_usb_root_hub_lost_power
+c03b1f60 r __ksymtab_usb_bus_list
+c03b1f68 r __ksymtab_usb_bus_list_lock
+c03b1f70 r __ksymtab_usb_hcd_poll_rh_status
+c03b1f78 r __ksymtab_usb_hcd_resume_root_hub
+c03b1f80 r __ksymtab_usb_hc_died
+c03b1f88 r __ksymtab_usb_interrupt_msg
+c03b1f90 r __ksymtab_usb_driver_set_configuration
+c03b1f98 r __ksymtab_usb_store_new_id
+c03b1fa0 r __ksymtab_usb_match_one_id
+c03b1fa8 r __ksymtab_usb_register_device_driver
+c03b1fb0 r __ksymtab_usb_deregister_device_driver
+c03b1fb8 r __ksymtab_usb_register_notify
+c03b1fc0 r __ksymtab_usb_unregister_notify
+c03b1fc8 r __ksymtab_uhci_reset_hc
+c03b1fd0 r __ksymtab_uhci_check_and_reset_hc
+c03b1fd8 r __ksymtab_storage_usb_ids
+c03b1fe0 r __ksymtab_usb_usual_set_present
+c03b1fe8 r __ksymtab_usb_usual_clear_present
+c03b1ff0 r __ksymtab_usb_usual_check_type
+c03b1ff8 r __ksymtab_input_class
+c03b2000 r __ksymtab_input_ff_upload
+c03b2008 r __ksymtab_input_ff_erase
+c03b2010 r __ksymtab_input_ff_event
+c03b2018 r __ksymtab_input_ff_create
+c03b2020 r __ksymtab_input_ff_destroy
+c03b2028 r __ksymtab___i2c_board_lock
+c03b2030 r __ksymtab___i2c_board_list
+c03b2038 r __ksymtab___i2c_first_dynamic_bus_num
+c03b2040 r __ksymtab_md_new_event
+c03b2048 r __ksymtab_sync_page_io
+c03b2050 r __ksymtab_md_allow_write
+c03b2058 r __ksymtab_md_do_sync
+c03b2060 r __ksymtab_dm_device_name
+c03b2068 r __ksymtab_dm_put
+c03b2070 r __ksymtab_dm_noflush_suspending
+c03b2078 r __ksymtab_dm_create_error_table
+c03b2080 r __ksymtab_dm_set_device_limits
+c03b2088 r __ksymtab_hid_free_device
+c03b2090 r __ksymtab_hid_parse_report
+c03b2098 r __ksymtab_hid_input_field
+c03b20a0 r __ksymtab_hid_output_report
+c03b20a8 r __ksymtab_hid_set_field
+c03b20b0 r __ksymtab_hid_input_report
+c03b20b8 r __ksymtab_hidinput_report_event
+c03b20c0 r __ksymtab_hidinput_find_field
+c03b20c8 r __ksymtab_hidinput_connect
+c03b20d0 r __ksymtab_hidinput_disconnect
+c03b20d8 r __ksymtab___sock_recv_timestamp
+c03b20e0 r __ksymtab_sk_clone
+c03b20e8 r __ksymtab_sk_setup_caps
+c03b20f0 r __ksymtab_skb_pull_rcsum
+c03b20f8 r __ksymtab_skb_segment
+c03b2100 r __ksymtab_skb_to_sgvec
+c03b2108 r __ksymtab_skb_cow_data
+c03b2110 r __ksymtab_init_net
+c03b2118 r __ksymtab___put_net
+c03b2120 r __ksymtab_register_pernet_subsys
+c03b2128 r __ksymtab_unregister_pernet_subsys
+c03b2130 r __ksymtab_register_pernet_device
+c03b2138 r __ksymtab_unregister_pernet_device
+c03b2140 r __ksymtab_ethtool_op_get_perm_addr
+c03b2148 r __ksymtab_register_netevent_notifier
+c03b2150 r __ksymtab_unregister_netevent_notifier
+c03b2158 r __ksymtab_call_netevent_notifiers
+c03b2160 r __ksymtab___rtnl_register
+c03b2168 r __ksymtab_rtnl_register
+c03b2170 r __ksymtab_rtnl_unregister
+c03b2178 r __ksymtab_rtnl_unregister_all
+c03b2180 r __ksymtab___rtnl_link_register
+c03b2188 r __ksymtab_rtnl_link_register
+c03b2190 r __ksymtab___rtnl_link_unregister
+c03b2198 r __ksymtab_rtnl_link_unregister
+c03b21a0 r __ksymtab_rtnl_put_cacheinfo
+c03b21a8 r __ksymtab_fib_rules_register
+c03b21b0 r __ksymtab_fib_rules_unregister
+c03b21b8 r __ksymtab_fib_rules_lookup
+c03b21c0 r __ksymtab_netlink_has_listeners
+c03b21c8 r __ksymtab_nf_register_afinfo
+c03b21d0 r __ksymtab_nf_unregister_afinfo
+c03b21d8 r __ksymtab_nf_unregister_queue_handlers
+c03b21e0 r __ksymtab_nf_register_sysctl_table
+c03b21e8 r __ksymtab_nf_unregister_sysctl_table
+c03b21f0 r __ksymtab_nf_net_netfilter_sysctl_path
+c03b21f8 r __ksymtab_nf_net_ipv4_netfilter_sysctl_path
+c03b2200 r __ksymtab___ip_route_output_key
+c03b2208 r __ksymtab_ip_route_output_flow
+c03b2210 r __ksymtab_ip_build_and_send_pkt
+c03b2218 r __ksymtab___inet_lookup_listener
+c03b2220 r __ksymtab_inet_hash_connect
+c03b2228 r __ksymtab___inet_twsk_kill
+c03b2230 r __ksymtab___inet_twsk_hashdance
+c03b2238 r __ksymtab_inet_twsk_alloc
+c03b2240 r __ksymtab_inet_twdr_hangman
+c03b2248 r __ksymtab_inet_twdr_twkill_work
+c03b2250 r __ksymtab_inet_twsk_schedule
+c03b2258 r __ksymtab_inet_twdr_twcal_tick
+c03b2260 r __ksymtab_inet_csk_bind_conflict
+c03b2268 r __ksymtab_inet_csk_get_port
+c03b2270 r __ksymtab_inet_csk_route_req
+c03b2278 r __ksymtab_inet_csk_search_req
+c03b2280 r __ksymtab_inet_csk_reqsk_queue_hash_add
+c03b2288 r __ksymtab_inet_csk_reqsk_queue_prune
+c03b2290 r __ksymtab_inet_csk_clone
+c03b2298 r __ksymtab_inet_csk_listen_start
+c03b22a0 r __ksymtab_inet_csk_listen_stop
+c03b22a8 r __ksymtab_inet_csk_addr2sockaddr
+c03b22b0 r __ksymtab_inet_csk_ctl_sock_create
+c03b22b8 r __ksymtab_tcp_orphan_count
+c03b22c0 r __ksymtab_tcp_get_info
+c03b22c8 r __ksymtab_tcp_done
+c03b22d0 r __ksymtab_tcp_twsk_unique
+c03b22d8 r __ksymtab_tcp_death_row
+c03b22e0 r __ksymtab_tcp_twsk_destructor
+c03b22e8 r __ksymtab_tcp_register_congestion_control
+c03b22f0 r __ksymtab_tcp_unregister_congestion_control
+c03b22f8 r __ksymtab_tcp_slow_start
+c03b2300 r __ksymtab_tcp_reno_cong_avoid
+c03b2308 r __ksymtab_tcp_reno_ssthresh
+c03b2310 r __ksymtab_tcp_reno_min_cwnd
+c03b2318 r __ksymtab_tcp_init_congestion_ops
+c03b2320 r __ksymtab_snmp_fold_field
+c03b2328 r __ksymtab_snmp_mib_init
+c03b2330 r __ksymtab_snmp_mib_free
+c03b2338 r __ksymtab_xfrm_aalg_get_byid
+c03b2340 r __ksymtab_xfrm_ealg_get_byid
+c03b2348 r __ksymtab_xfrm_calg_get_byid
+c03b2350 r __ksymtab_xfrm_aalg_get_byname
+c03b2358 r __ksymtab_xfrm_ealg_get_byname
+c03b2360 r __ksymtab_xfrm_calg_get_byname
+c03b2368 r __ksymtab_xfrm_aalg_get_byidx
+c03b2370 r __ksymtab_xfrm_ealg_get_byidx
+c03b2378 r __ksymtab_xfrm_probe_algs
+c03b2380 r __ksymtab_xfrm_count_auth_supported
+c03b2388 r __ksymtab_xfrm_count_enc_supported
+c03b2390 r __ksymtab_skb_icv_walk
+c03b2398 r __ksymtab_inet6_destroy_sock
+c03b23a0 r __ksymtab_inet6_sk_rebuild_header
+c03b23a8 r __ksymtab_ipv6_opt_accepted
+c03b23b0 r __ksymtab_ip6_find_1stfragopt
+c03b23b8 r __ksymtab_ip6_dst_lookup
+c03b23c0 r __ksymtab_ip6_sk_dst_lookup
+c03b23c8 r __ksymtab_ip6_dst_blackhole
+c03b23d0 r __ksymtab_ipv6_find_tlv
+c03b23d8 r __ksymtab_ipv6_invert_rthdr
+c03b23e0 r __ksymtab_ipv6_dup_options
+c03b23e8 r __ksymtab_fl6_sock_lookup
+c03b23f0 r __ksymtab_inet6_csk_bind_conflict
+c03b23f8 r __ksymtab_inet6_csk_search_req
+c03b2400 r __ksymtab_inet6_csk_reqsk_queue_hash_add
+c03b2408 r __ksymtab_inet6_csk_addr2sockaddr
+c03b2410 r __ksymtab_inet6_csk_xmit
+c03b2418 r __ksymtab_inet6_lookup_listener
+c03b2420 r __ksymtab_inet6_lookup
+c03b2428 r __ksymtab_inet6_hash_connect
+c03b2430 r __ksymtab_klist_init
+c03b2438 r __ksymtab_klist_add_head
+c03b2440 r __ksymtab_klist_add_tail
+c03b2448 r __ksymtab_klist_del
+c03b2450 r __ksymtab_klist_remove
+c03b2458 r __ksymtab_klist_node_attached
+c03b2460 r __ksymtab_klist_iter_init_node
+c03b2468 r __ksymtab_klist_iter_init
+c03b2470 r __ksymtab_klist_iter_exit
+c03b2478 r __ksymtab_klist_next
+c03b2480 r __ksymtab_usb_match_id
+c03b2480 R __start___ksymtab_gpl_future
+c03b2480 ? __start___ksymtab_unused
+c03b2480 ? __start___ksymtab_unused_gpl
+c03b2480 R __stop___ksymtab_gpl
+c03b2480 ? __stop___ksymtab_unused
+c03b2480 ? __stop___ksymtab_unused_gpl
+c03b2488 r __ksymtab_usb_register_driver
+c03b2490 r __ksymtab_usb_deregister
+c03b2498 ? __start___kcrctab
+c03b2498 ? __start___kcrctab_gpl
+c03b2498 ? __start___kcrctab_gpl_future
+c03b2498 ? __start___kcrctab_unused
+c03b2498 ? __start___kcrctab_unused_gpl
+c03b2498 ? __stop___kcrctab
+c03b2498 ? __stop___kcrctab_gpl
+c03b2498 ? __stop___kcrctab_gpl_future
+c03b2498 ? __stop___kcrctab_unused
+c03b2498 ? __stop___kcrctab_unused_gpl
+c03b2498 R __stop___ksymtab_gpl_future
+c03b24a0 r __kstrtab_init_mm
+c03b24a8 r __kstrtab_init_task
+c03b24b2 r __kstrtab_system_state
+c03b24bf r __kstrtab_reset_devices
+c03b24cd r __kstrtab_loops_per_jiffy
+c03b24dd r __kstrtab___per_cpu_offset
+c03b24ee r __kstrtab_init_uts_ns
+c03b2500 r __kstrtab_boot_option_idle_override
+c03b251a r __kstrtab_per_cpu__current_task
+c03b2530 r __kstrtab_per_cpu__cpu_number
+c03b2544 r __kstrtab_pm_idle
+c03b254c r __kstrtab_disable_hlt
+c03b2558 r __kstrtab_enable_hlt
+c03b2563 r __kstrtab_cpu_idle_wait
+c03b2571 r __kstrtab_kernel_thread
+c03b257f r __kstrtab_dump_thread
+c03b258b r __kstrtab_dump_trace
+c03b2596 r __kstrtab_dump_stack
+c03b25a1 r __kstrtab_per_cpu__irq_stat
+c03b25b3 r __kstrtab_per_cpu__irq_regs
+c03b25c5 r __kstrtab_do_softirq
+c03b25d0 r __kstrtab_cpu_khz
+c03b25d8 r __kstrtab_rtc_lock
+c03b25e1 r __kstrtab_cmos_lock
+c03b25eb r __kstrtab_rtc_cmos_read
+c03b25f9 r __kstrtab_rtc_cmos_write
+c03b2608 r __kstrtab_profile_pc
+c03b2613 r __kstrtab_boot_cpu_data
+c03b2621 r __kstrtab_drive_info
+c03b262c r __kstrtab_screen_info
+c03b2638 r __kstrtab_apm_info
+c03b2641 r __kstrtab_edid_info
+c03b264b r __kstrtab_edd
+c03b2660 r __kstrtab_dma_alloc_coherent
+c03b2673 r __kstrtab_dma_free_coherent
+c03b2685 r __kstrtab_dma_declare_coherent_memory
+c03b26a1 r __kstrtab_dma_release_declared_memory
+c03b26c0 r __kstrtab_dma_mark_declared_memory_occupied
+c03b26e2 r __kstrtab_forbid_dac
+c03b26ed r __kstrtab___down_failed
+c03b26fb r __kstrtab___down_failed_interruptible
+c03b2717 r __kstrtab___down_failed_trylock
+c03b272d r __kstrtab___up_wakeup
+c03b2739 r __kstrtab_csum_partial_copy_generic
+c03b2753 r __kstrtab___get_user_1
+c03b2760 r __kstrtab___get_user_2
+c03b276d r __kstrtab___get_user_4
+c03b277a r __kstrtab___put_user_1
+c03b2787 r __kstrtab___put_user_2
+c03b2794 r __kstrtab___put_user_4
+c03b27a1 r __kstrtab___put_user_8
+c03b27ae r __kstrtab_strstr
+c03b27b5 r __kstrtab___write_lock_failed
+c03b27c9 r __kstrtab___read_lock_failed
+c03b27dc r __kstrtab_csum_partial
+c03b27e9 r __kstrtab_kernel_fpu_begin
+c03b27fa r __kstrtab_dump_fpu
+c03b2803 r __kstrtab_efi_enabled
+c03b280f r __kstrtab_pci_mem_start
+c03b281d r __kstrtab_e820_any_mapped
+c03b282d r __kstrtab_i8253_lock
+c03b2838 r __kstrtab_recalibrate_cpu_khz
+c03b284c r __kstrtab_mark_tsc_unstable
+c03b285e r __kstrtab_per_cpu__gdt_page
+c03b2870 r __kstrtab_nr_mce_banks
+c03b287d r __kstrtab_mtrr_add
+c03b2886 r __kstrtab_mtrr_del
+c03b288f r __kstrtab_avail_to_resrv_perfctr_nmi
+c03b28aa r __kstrtab_avail_to_resrv_perfctr_nmi_bit
+c03b28c9 r __kstrtab_reserve_perfctr_nmi
+c03b28dd r __kstrtab_release_perfctr_nmi
+c03b28f1 r __kstrtab_reserve_evntsel_nmi
+c03b2905 r __kstrtab_release_evntsel_nmi
+c03b2919 r __kstrtab_acpi_disabled
+c03b2927 r __kstrtab_acpi_strict
+c03b2933 r __kstrtab_acpi_register_gsi
+c03b2945 r __kstrtab_acpi_register_ioapic
+c03b295a r __kstrtab_acpi_unregister_ioapic
+c03b2971 r __kstrtab_pm_power_off
+c03b297e r __kstrtab_flush_tlb_page
+c03b298d r __kstrtab_smp_num_siblings
+c03b299e r __kstrtab_cpu_sibling_map
+c03b29ae r __kstrtab_cpu_core_map
+c03b29bb r __kstrtab_cpu_online_map
+c03b29ca r __kstrtab_cpu_callout_map
+c03b29da r __kstrtab_cpu_possible_map
+c03b29eb r __kstrtab_cpu_data
+c03b29f4 r __kstrtab_x86_cpu_to_apicid
+c03b2a06 r __kstrtab_per_cpu__this_cpu_off
+c03b2a1c r __kstrtab_smp_call_function
+c03b2a2e r __kstrtab_smp_call_function_single
+c03b2a47 r __kstrtab_local_apic_timer_c2_ok
+c03b2a5e r __kstrtab_touch_nmi_watchdog
+c03b2a71 r __kstrtab_nmi_active
+c03b2a7c r __kstrtab_nmi_watchdog
+c03b2a89 r __kstrtab_IO_APIC_get_PCI_irq_vector
+c03b2aa4 r __kstrtab_vdso_enabled
+c03b2ab1 r __kstrtab_efi
+c03b2ab5 r __kstrtab___PAGE_KERNEL
+c03b2ac3 r __kstrtab___FIXADDR_TOP
+c03b2ad1 r __kstrtab_register_page_fault_notifier
+c03b2aee r __kstrtab_unregister_page_fault_notifier
+c03b2b0d r __kstrtab___ioremap
+c03b2b17 r __kstrtab_ioremap_nocache
+c03b2b27 r __kstrtab_iounmap
+c03b2b2f r __kstrtab_change_page_attr
+c03b2b40 r __kstrtab_global_flush_tlb
+c03b2b51 r __kstrtab_kmap
+c03b2b56 r __kstrtab_kunmap
+c03b2b5d r __kstrtab_kmap_atomic
+c03b2b69 r __kstrtab_kunmap_atomic
+c03b2b77 r __kstrtab_kmap_atomic_to_page
+c03b2ba0 r __kstrtab_wake_up_process
+c03b2bb0 r __kstrtab_per_cpu__kstat
+c03b2bbf r __kstrtab_schedule
+c03b2bc8 r __kstrtab_default_wake_function
+c03b2bde r __kstrtab___wake_up
+c03b2be8 r __kstrtab___wake_up_sync
+c03b2bf7 r __kstrtab_complete
+c03b2c00 r __kstrtab_complete_all
+c03b2c0d r __kstrtab_wait_for_completion
+c03b2c21 r __kstrtab_wait_for_completion_timeout
+c03b2c40 r __kstrtab_wait_for_completion_interruptible
+c03b2c80 r __kstrtab_wait_for_completion_interruptible_timeout
+c03b2caa r __kstrtab_interruptible_sleep_on
+c03b2cc1 r __kstrtab_interruptible_sleep_on_timeout
+c03b2ce0 r __kstrtab_sleep_on
+c03b2ce9 r __kstrtab_sleep_on_timeout
+c03b2cfa r __kstrtab_set_user_nice
+c03b2d08 r __kstrtab_task_nice
+c03b2d12 r __kstrtab_sched_setscheduler
+c03b2d25 r __kstrtab_cpu_present_map
+c03b2d35 r __kstrtab_cond_resched
+c03b2d42 r __kstrtab_cond_resched_lock
+c03b2d54 r __kstrtab_cond_resched_softirq
+c03b2d69 r __kstrtab_yield
+c03b2d6f r __kstrtab_io_schedule
+c03b2d7b r __kstrtab_set_cpus_allowed
+c03b2d8c r __kstrtab_nr_cpu_ids
+c03b2d97 r __kstrtab___might_sleep
+c03b2da5 r __kstrtab_free_task
+c03b2daf r __kstrtab_mmput
+c03b2db5 r __kstrtab_get_task_mm
+c03b2dc1 r __kstrtab_copy_fs_struct
+c03b2dd0 r __kstrtab_unshare_files
+c03b2dde r __kstrtab_register_exec_domain
+c03b2df3 r __kstrtab_unregister_exec_domain
+c03b2e0a r __kstrtab___set_personality
+c03b2e1c r __kstrtab_panic_notifier_list
+c03b2e30 r __kstrtab_panic_blink
+c03b2e3c r __kstrtab_panic
+c03b2e42 r __kstrtab_add_taint
+c03b2e4c r __kstrtab_oops_in_progress
+c03b2e5d r __kstrtab_printk
+c03b2e64 r __kstrtab_vprintk
+c03b2e6c r __kstrtab_acquire_console_sem
+c03b2e80 r __kstrtab_try_acquire_console_sem
+c03b2e98 r __kstrtab_release_console_sem
+c03b2eac r __kstrtab_console_conditional_schedule
+c03b2ec9 r __kstrtab_console_print
+c03b2ed7 r __kstrtab_console_stop
+c03b2ee4 r __kstrtab_console_start
+c03b2ef2 r __kstrtab_register_console
+c03b2f03 r __kstrtab_unregister_console
+c03b2f16 r __kstrtab___printk_ratelimit
+c03b2f29 r __kstrtab_printk_ratelimit
+c03b2f3a r __kstrtab_printk_timed_ratelimit
+c03b2f51 r __kstrtab_prof_on
+c03b2f59 r __kstrtab_register_timer_hook
+c03b2f6d r __kstrtab_unregister_timer_hook
+c03b2f83 r __kstrtab_task_handoff_register
+c03b2f99 r __kstrtab_task_handoff_unregister
+c03b2fb1 r __kstrtab_profile_event_register
+c03b2fc8 r __kstrtab_profile_event_unregister
+c03b2fe1 r __kstrtab_profile_hits
+c03b2fee r __kstrtab_allow_signal
+c03b2ffb r __kstrtab_disallow_signal
+c03b300b r __kstrtab_daemonize
+c03b3015 r __kstrtab_put_files_struct
+c03b3026 r __kstrtab_reset_files_struct
+c03b3039 r __kstrtab_exit_fs
+c03b3041 r __kstrtab_do_exit
+c03b3049 r __kstrtab_complete_and_exit
+c03b305b r __kstrtab_sys_tz
+c03b3062 r __kstrtab_current_kernel_time
+c03b3076 r __kstrtab_current_fs_time
+c03b3086 r __kstrtab_jiffies_to_msecs
+c03b3097 r __kstrtab_jiffies_to_usecs
+c03b30a8 r __kstrtab_timespec_trunc
+c03b30b7 r __kstrtab_mktime
+c03b30be r __kstrtab_ns_to_timespec
+c03b30cd r __kstrtab_ns_to_timeval
+c03b30db r __kstrtab_msecs_to_jiffies
+c03b30ec r __kstrtab_usecs_to_jiffies
+c03b30fd r __kstrtab_timespec_to_jiffies
+c03b3111 r __kstrtab_jiffies_to_timespec
+c03b3125 r __kstrtab_timeval_to_jiffies
+c03b3138 r __kstrtab_jiffies_to_timeval
+c03b314b r __kstrtab_jiffies_to_clock_t
+c03b315e r __kstrtab_clock_t_to_jiffies
+c03b3171 r __kstrtab_jiffies_64_to_clock_t
+c03b3187 r __kstrtab_get_jiffies_64
+c03b3196 r __kstrtab_jiffies
+c03b319e r __kstrtab_local_bh_disable
+c03b31af r __kstrtab___local_bh_enable
+c03b31c1 r __kstrtab__local_bh_enable
+c03b31d2 r __kstrtab_local_bh_enable
+c03b31e2 r __kstrtab_local_bh_enable_ip
+c03b31f5 r __kstrtab_raise_softirq_irqoff
+c03b320a r __kstrtab___tasklet_schedule
+c03b321d r __kstrtab___tasklet_hi_schedule
+c03b3233 r __kstrtab_tasklet_init
+c03b3240 r __kstrtab_tasklet_kill
+c03b324d r __kstrtab_on_each_cpu
+c03b3259 r __kstrtab_ioport_resource
+c03b3269 r __kstrtab_iomem_resource
+c03b3278 r __kstrtab_request_resource
+c03b3289 r __kstrtab_release_resource
+c03b329a r __kstrtab_allocate_resource
+c03b32ac r __kstrtab_adjust_resource
+c03b32bc r __kstrtab___request_region
+c03b32cd r __kstrtab___check_region
+c03b32dc r __kstrtab___release_region
+c03b32ed r __kstrtab___devm_request_region
+c03b3303 r __kstrtab___devm_release_region
+c03b3320 r __kstrtab_register_net_sysctl_table
+c03b333a r __kstrtab_unregister_net_sysctl_table
+c03b3356 r __kstrtab_proc_dointvec
+c03b3364 r __kstrtab_proc_dointvec_jiffies
+c03b337a r __kstrtab_proc_dointvec_minmax
+c03b338f r __kstrtab_proc_dointvec_userhz_jiffies
+c03b33ac r __kstrtab_proc_dointvec_ms_jiffies
+c03b33c5 r __kstrtab_proc_dostring
+c03b33d3 r __kstrtab_proc_doulongvec_minmax
+c03b3400 r __kstrtab_proc_doulongvec_ms_jiffies_minmax
+c03b3422 r __kstrtab_register_sysctl_table
+c03b3438 r __kstrtab_sysctl_intvec
+c03b3446 r __kstrtab_sysctl_jiffies
+c03b3455 r __kstrtab_sysctl_ms_jiffies
+c03b3467 r __kstrtab_sysctl_string
+c03b3475 r __kstrtab_sysctl_data
+c03b3481 r __kstrtab_unregister_sysctl_table
+c03b3499 r __kstrtab_securebits
+c03b34a4 r __kstrtab_cap_bset
+c03b34ad r __kstrtab___capable
+c03b34b7 r __kstrtab_capable
+c03b34c0 r __kstrtab_jiffies_64
+c03b34cb r __kstrtab_boot_tvec_bases
+c03b34db r __kstrtab___round_jiffies
+c03b34eb r __kstrtab___round_jiffies_relative
+c03b3504 r __kstrtab_round_jiffies
+c03b3512 r __kstrtab_round_jiffies_relative
+c03b3529 r __kstrtab_init_timer
+c03b3534 r __kstrtab_init_timer_deferrable
+c03b354a r __kstrtab___mod_timer
+c03b3556 r __kstrtab_mod_timer
+c03b3560 r __kstrtab_del_timer
+c03b356a r __kstrtab_try_to_del_timer_sync
+c03b3580 r __kstrtab_del_timer_sync
+c03b358f r __kstrtab_avenrun
+c03b3597 r __kstrtab_schedule_timeout
+c03b35a8 r __kstrtab_schedule_timeout_interruptible
+c03b35e0 r __kstrtab_schedule_timeout_uninterruptible
+c03b3601 r __kstrtab_msleep
+c03b3608 r __kstrtab_msleep_interruptible
+c03b361d r __kstrtab_init_user_ns
+c03b362a r __kstrtab_kill_pid_info_as_uid
+c03b363f r __kstrtab_kill_pgrp
+c03b3649 r __kstrtab_kill_pid
+c03b3652 r __kstrtab_recalc_sigpending
+c03b3664 r __kstrtab_dequeue_signal
+c03b3673 r __kstrtab_flush_signals
+c03b3681 r __kstrtab_force_sig
+c03b368b r __kstrtab_kill_proc
+c03b3695 r __kstrtab_ptrace_notify
+c03b36a3 r __kstrtab_send_sig
+c03b36ac r __kstrtab_send_sig_info
+c03b36ba r __kstrtab_sigprocmask
+c03b36c6 r __kstrtab_block_all_signals
+c03b36d8 r __kstrtab_unblock_all_signals
+c03b3700 r __kstrtab_overflowuid
+c03b370c r __kstrtab_overflowgid
+c03b3718 r __kstrtab_fs_overflowuid
+c03b3727 r __kstrtab_fs_overflowgid
+c03b3736 r __kstrtab_cad_pid
+c03b373e r __kstrtab_atomic_notifier_chain_register
+c03b3760 r __kstrtab_atomic_notifier_chain_unregister
+c03b3781 r __kstrtab___atomic_notifier_call_chain
+c03b379e r __kstrtab_atomic_notifier_call_chain
+c03b37c0 r __kstrtab_blocking_notifier_chain_register
+c03b3800 r __kstrtab_blocking_notifier_chain_unregister
+c03b3823 r __kstrtab___blocking_notifier_call_chain
+c03b3842 r __kstrtab_blocking_notifier_call_chain
+c03b385f r __kstrtab_raw_notifier_chain_register
+c03b387b r __kstrtab_raw_notifier_chain_unregister
+c03b3899 r __kstrtab___raw_notifier_call_chain
+c03b38b3 r __kstrtab_raw_notifier_call_chain
+c03b38cb r __kstrtab_srcu_notifier_chain_register
+c03b38e8 r __kstrtab_srcu_notifier_chain_unregister
+c03b3907 r __kstrtab___srcu_notifier_call_chain
+c03b3922 r __kstrtab_srcu_notifier_call_chain
+c03b393b r __kstrtab_srcu_init_notifier_head
+c03b3953 r __kstrtab_register_reboot_notifier
+c03b396c r __kstrtab_unregister_reboot_notifier
+c03b3987 r __kstrtab_emergency_restart
+c03b3999 r __kstrtab_kernel_restart
+c03b39a8 r __kstrtab_kernel_halt
+c03b39b4 r __kstrtab_kernel_power_off
+c03b39c5 r __kstrtab_groups_alloc
+c03b39d2 r __kstrtab_groups_free
+c03b39de r __kstrtab_set_current_groups
+c03b39f1 r __kstrtab_in_group_p
+c03b39fc r __kstrtab_in_egroup_p
+c03b3a08 r __kstrtab_uts_sem
+c03b3a10 r __kstrtab_orderly_poweroff
+c03b3a21 r __kstrtab_request_module
+c03b3a30 r __kstrtab_call_usermodehelper_freeinfo
+c03b3a4d r __kstrtab_call_usermodehelper_setup
+c03b3a67 r __kstrtab_call_usermodehelper_setkeys
+c03b3a83 r __kstrtab_call_usermodehelper_setcleanup
+c03b3aa2 r __kstrtab_call_usermodehelper_stdinpipe
+c03b3ac0 r __kstrtab_call_usermodehelper_exec
+c03b3ad9 r __kstrtab_call_usermodehelper_pipe
+c03b3af2 r __kstrtab_queue_work
+c03b3afd r __kstrtab_queue_delayed_work
+c03b3b10 r __kstrtab_queue_delayed_work_on
+c03b3b26 r __kstrtab_flush_workqueue
+c03b3b36 r __kstrtab_cancel_work_sync
+c03b3b47 r __kstrtab_cancel_rearming_delayed_work
+c03b3b64 r __kstrtab_schedule_work
+c03b3b72 r __kstrtab_schedule_delayed_work
+c03b3b88 r __kstrtab_schedule_delayed_work_on
+c03b3ba1 r __kstrtab_flush_scheduled_work
+c03b3bb6 r __kstrtab_execute_in_process_context
+c03b3bd1 r __kstrtab___create_workqueue
+c03b3be4 r __kstrtab_destroy_workqueue
+c03b3bf6 r __kstrtab_put_pid
+c03b3bfe r __kstrtab_find_pid
+c03b3c07 r __kstrtab_find_task_by_pid_type
+c03b3c1d r __kstrtab_find_get_pid
+c03b3c2a r __kstrtab_rcu_barrier
+c03b3c36 r __kstrtab_rcu_batches_completed
+c03b3c4c r __kstrtab_rcu_batches_completed_bh
+c03b3c65 r __kstrtab_call_rcu
+c03b3c6e r __kstrtab_call_rcu_bh
+c03b3c7a r __kstrtab_synchronize_rcu
+c03b3c8a r __kstrtab_param_set_byte
+c03b3c99 r __kstrtab_param_get_byte
+c03b3ca8 r __kstrtab_param_set_short
+c03b3cb8 r __kstrtab_param_get_short
+c03b3cc8 r __kstrtab_param_set_ushort
+c03b3cd9 r __kstrtab_param_get_ushort
+c03b3cea r __kstrtab_param_set_int
+c03b3cf8 r __kstrtab_param_get_int
+c03b3d06 r __kstrtab_param_set_uint
+c03b3d15 r __kstrtab_param_get_uint
+c03b3d24 r __kstrtab_param_set_long
+c03b3d33 r __kstrtab_param_get_long
+c03b3d42 r __kstrtab_param_set_ulong
+c03b3d52 r __kstrtab_param_get_ulong
+c03b3d62 r __kstrtab_param_set_charp
+c03b3d72 r __kstrtab_param_get_charp
+c03b3d82 r __kstrtab_param_set_bool
+c03b3d91 r __kstrtab_param_get_bool
+c03b3da0 r __kstrtab_param_set_invbool
+c03b3db2 r __kstrtab_param_get_invbool
+c03b3dc4 r __kstrtab_param_array_set
+c03b3dd4 r __kstrtab_param_array_get
+c03b3de4 r __kstrtab_param_set_copystring
+c03b3df9 r __kstrtab_param_get_string
+c03b3e0a r __kstrtab_posix_timer_event
+c03b3e1c r __kstrtab_register_posix_clock
+c03b3e31 r __kstrtab_do_posix_clock_nosettime
+c03b3e4a r __kstrtab_do_posix_clock_nonanosleep
+c03b3e65 r __kstrtab_kthread_should_stop
+c03b3e79 r __kstrtab_kthread_create
+c03b3e88 r __kstrtab_kthread_bind
+c03b3e95 r __kstrtab_kthread_stop
+c03b3ea2 r __kstrtab_init_waitqueue_head
+c03b3eb6 r __kstrtab_add_wait_queue
+c03b3ec5 r __kstrtab_add_wait_queue_exclusive
+c03b3ede r __kstrtab_remove_wait_queue
+c03b3ef0 r __kstrtab_prepare_to_wait
+c03b3f00 r __kstrtab_prepare_to_wait_exclusive
+c03b3f1a r __kstrtab_finish_wait
+c03b3f26 r __kstrtab_autoremove_wake_function
+c03b3f3f r __kstrtab_wake_bit_function
+c03b3f51 r __kstrtab___wait_on_bit
+c03b3f5f r __kstrtab_out_of_line_wait_on_bit
+c03b3f77 r __kstrtab___wait_on_bit_lock
+c03b3f8a r __kstrtab_out_of_line_wait_on_bit_lock
+c03b3fa7 r __kstrtab___wake_up_bit
+c03b3fb5 r __kstrtab_wake_up_bit
+c03b3fc1 r __kstrtab_bit_waitqueue
+c03b3fcf r __kstrtab_kfifo_init
+c03b3fda r __kstrtab_kfifo_alloc
+c03b3fe6 r __kstrtab_kfifo_free
+c03b3ff1 r __kstrtab___kfifo_put
+c03b3ffd r __kstrtab___kfifo_get
+c03b4009 r __kstrtab___mutex_init
+c03b4016 r __kstrtab_mutex_lock
+c03b4021 r __kstrtab_mutex_unlock
+c03b402e r __kstrtab_mutex_lock_interruptible
+c03b4047 r __kstrtab_mutex_trylock
+c03b4055 r __kstrtab_ktime_get
+c03b405f r __kstrtab_ktime_get_real
+c03b406e r __kstrtab_ktime_get_ts
+c03b407b r __kstrtab_hrtimer_forward
+c03b408b r __kstrtab_hrtimer_start
+c03b4099 r __kstrtab_hrtimer_try_to_cancel
+c03b40af r __kstrtab_hrtimer_cancel
+c03b40be r __kstrtab_hrtimer_get_remaining
+c03b40d4 r __kstrtab_hrtimer_init
+c03b40e1 r __kstrtab_hrtimer_get_res
+c03b40f1 r __kstrtab_down_read
+c03b40fb r __kstrtab_down_read_trylock
+c03b410d r __kstrtab_down_write
+c03b4118 r __kstrtab_down_write_trylock
+c03b412b r __kstrtab_up_read
+c03b4133 r __kstrtab_up_write
+c03b413c r __kstrtab_downgrade_write
+c03b414c r __kstrtab_set_acceptable_latency
+c03b4163 r __kstrtab_modify_acceptable_latency
+c03b417d r __kstrtab_remove_acceptable_latency
+c03b4197 r __kstrtab_system_latency_constraint
+c03b41b1 r __kstrtab_synchronize_acceptable_latency
+c03b41d0 r __kstrtab_register_latency_notifier
+c03b41ea r __kstrtab_unregister_latency_notifier
+c03b4206 r __kstrtab_init_srcu_struct
+c03b4217 r __kstrtab_cleanup_srcu_struct
+c03b422b r __kstrtab_srcu_read_lock
+c03b423a r __kstrtab_srcu_read_unlock
+c03b424b r __kstrtab_synchronize_srcu
+c03b425c r __kstrtab_srcu_batches_completed
+c03b4273 r __kstrtab_srcu_readers_active
+c03b4287 r __kstrtab_register_die_notifier
+c03b429d r __kstrtab_unregister_die_notifier
+c03b42b5 r __kstrtab_free_vx_info
+c03b42c2 r __kstrtab_free_nx_info
+c03b42cf r __kstrtab_unhash_nx_info
+c03b42de r __kstrtab_vlimit_name
+c03b42ea r __kstrtab_locate_dl_info
+c03b42f9 r __kstrtab_rcu_free_dl_info
+c03b430a r __kstrtab_ip_v4_find_src
+c03b4319 r __kstrtab_xtime_lock
+c03b4324 r __kstrtab_xtime
+c03b432a r __kstrtab_getnstimeofday
+c03b4339 r __kstrtab_do_gettimeofday
+c03b4349 r __kstrtab_do_settimeofday
+c03b4359 r __kstrtab_getboottime
+c03b4365 r __kstrtab_monotonic_to_bootbased
+c03b437c r __kstrtab_clocksource_register
+c03b4391 r __kstrtab_clockevents_notify
+c03b43a4 r __kstrtab_get_futex_key
+c03b43b2 r __kstrtab_get_futex_key_refs
+c03b43c5 r __kstrtab_drop_futex_key_refs
+c03b43d9 r __kstrtab_rt_mutex_lock
+c03b43e7 r __kstrtab_rt_mutex_lock_interruptible
+c03b4403 r __kstrtab_rt_mutex_timed_lock
+c03b4417 r __kstrtab_rt_mutex_trylock
+c03b4428 r __kstrtab_rt_mutex_unlock
+c03b4438 r __kstrtab_rt_mutex_destroy
+c03b4449 r __kstrtab___rt_mutex_init
+c03b4459 r __kstrtab_request_dma
+c03b4465 r __kstrtab_free_dma
+c03b446e r __kstrtab_dma_spin_lock
+c03b447c r __kstrtab__spin_trylock
+c03b448a r __kstrtab__read_trylock
+c03b4498 r __kstrtab__write_trylock
+c03b44a7 r __kstrtab__read_lock
+c03b44b2 r __kstrtab__spin_lock_irqsave
+c03b44c5 r __kstrtab__spin_lock_irq
+c03b44d4 r __kstrtab__spin_lock_bh
+c03b44e2 r __kstrtab__read_lock_irqsave
+c03b44f5 r __kstrtab__read_lock_irq
+c03b4504 r __kstrtab__read_lock_bh
+c03b4512 r __kstrtab__write_lock_irqsave
+c03b4526 r __kstrtab__write_lock_irq
+c03b4536 r __kstrtab__write_lock_bh
+c03b4545 r __kstrtab__spin_lock
+c03b4550 r __kstrtab__write_lock
+c03b455c r __kstrtab__spin_unlock
+c03b4569 r __kstrtab__write_unlock
+c03b4577 r __kstrtab__read_unlock
+c03b4584 r __kstrtab__spin_unlock_irqrestore
+c03b459c r __kstrtab__spin_unlock_irq
+c03b45ad r __kstrtab__spin_unlock_bh
+c03b45bd r __kstrtab__read_unlock_irqrestore
+c03b45d5 r __kstrtab__read_unlock_irq
+c03b45e6 r __kstrtab__read_unlock_bh
+c03b45f6 r __kstrtab__write_unlock_irqrestore
+c03b460f r __kstrtab__write_unlock_irq
+c03b4621 r __kstrtab__write_unlock_bh
+c03b4632 r __kstrtab__spin_trylock_bh
+c03b4643 r __kstrtab_in_lock_functions
+c03b4655 r __kstrtab_register_module_notifier
+c03b466e r __kstrtab_unregister_module_notifier
+c03b4689 r __kstrtab___module_put_and_exit
+c03b469f r __kstrtab_module_refcount
+c03b46af r __kstrtab___symbol_put
+c03b46bc r __kstrtab_symbol_put_addr
+c03b46cc r __kstrtab_module_put
+c03b46d7 r __kstrtab___symbol_get
+c03b46e4 r __kstrtab_module_add_driver
+c03b46f6 r __kstrtab_module_remove_driver
+c03b470b r __kstrtab___print_symbol
+c03b471a r __kstrtab_sprint_symbol
+c03b4728 r __kstrtab_pm_suspend
+c03b4733 r __kstrtab_refrigerator
+c03b4740 r __kstrtab_pm_register
+c03b474c r __kstrtab_pm_send_all
+c03b4758 r __kstrtab_pm_active
+c03b4762 r __kstrtab_stop_machine_run
+c03b4773 r __kstrtab_register_kprobe
+c03b4783 r __kstrtab_unregister_kprobe
+c03b4795 r __kstrtab_register_jprobe
+c03b47a5 r __kstrtab_unregister_jprobe
+c03b47b7 r __kstrtab_jprobe_return
+c03b47c5 r __kstrtab_register_kretprobe
+c03b47d8 r __kstrtab_unregister_kretprobe
+c03b47ed r __kstrtab_kernel_subsys
+c03b47fb r __kstrtab_touch_softlockup_watchdog
+c03b4815 r __kstrtab_touch_all_softlockup_watchdogs
+c03b4834 r __kstrtab_synchronize_irq
+c03b4844 r __kstrtab_disable_irq_nosync
+c03b4857 r __kstrtab_disable_irq
+c03b4863 r __kstrtab_enable_irq
+c03b486e r __kstrtab_set_irq_wake
+c03b487b r __kstrtab_free_irq
+c03b4884 r __kstrtab_request_irq
+c03b4890 r __kstrtab_set_irq_chip
+c03b489d r __kstrtab_set_irq_type
+c03b48aa r __kstrtab_set_irq_data
+c03b48b7 r __kstrtab_set_irq_chip_data
+c03b48c9 r __kstrtab_devm_request_irq
+c03b48da r __kstrtab_devm_free_irq
+c03b48e8 r __kstrtab_probe_irq_on
+c03b48f5 r __kstrtab_probe_irq_mask
+c03b4904 r __kstrtab_probe_irq_off
+c03b4912 r __kstrtab_relay_buf_empty
+c03b4922 r __kstrtab_relay_buf_full
+c03b4931 r __kstrtab_relay_reset
+c03b493d r __kstrtab_relay_open
+c03b4948 r __kstrtab_relay_switch_subbuf
+c03b495c r __kstrtab_relay_subbufs_consumed
+c03b4973 r __kstrtab_relay_close
+c03b497f r __kstrtab_relay_flush
+c03b498b r __kstrtab_relay_file_operations
+c03b49c0 r __kstrtab_filemap_fdatawrite
+c03b49d3 r __kstrtab_filemap_flush
+c03b49e1 r __kstrtab_sync_page_range
+c03b49f1 r __kstrtab_sync_page_range_nolock
+c03b4a08 r __kstrtab_filemap_fdatawait
+c03b4a1a r __kstrtab_filemap_write_and_wait
+c03b4a31 r __kstrtab_add_to_page_cache
+c03b4a43 r __kstrtab_wait_on_page_bit
+c03b4a54 r __kstrtab_unlock_page
+c03b4a60 r __kstrtab_end_page_writeback
+c03b4a73 r __kstrtab___lock_page
+c03b4a7f r __kstrtab_find_get_page
+c03b4a8d r __kstrtab_find_lock_page
+c03b4a9c r __kstrtab_find_or_create_page
+c03b4ab0 r __kstrtab_find_get_pages_contig
+c03b4ac6 r __kstrtab_find_get_pages_tag
+c03b4ad9 r __kstrtab_grab_cache_page_nowait
+c03b4af0 r __kstrtab_do_generic_mapping_read
+c03b4b08 r __kstrtab_generic_segment_checks
+c03b4b1f r __kstrtab_generic_file_aio_read
+c03b4b35 r __kstrtab_generic_file_sendfile
+c03b4b4b r __kstrtab_filemap_fault
+c03b4b59 r __kstrtab_filemap_nopage
+c03b4b68 r __kstrtab_filemap_populate
+c03b4b79 r __kstrtab_generic_file_mmap
+c03b4b8b r __kstrtab_generic_file_readonly_mmap
+c03b4ba6 r __kstrtab_read_cache_page_async
+c03b4bbc r __kstrtab_read_cache_page
+c03b4bcc r __kstrtab_should_remove_suid
+c03b4bdf r __kstrtab_remove_suid
+c03b4beb r __kstrtab_generic_write_checks
+c03b4c00 r __kstrtab_generic_file_direct_write
+c03b4c1a r __kstrtab_generic_file_buffered_write
+c03b4c36 r __kstrtab_generic_file_aio_write_nolock
+c03b4c54 r __kstrtab_generic_file_aio_write
+c03b4c6b r __kstrtab_try_to_release_page
+c03b4c7f r __kstrtab_mempool_create
+c03b4c8e r __kstrtab_mempool_create_node
+c03b4ca2 r __kstrtab_mempool_resize
+c03b4cb1 r __kstrtab_mempool_destroy
+c03b4cc1 r __kstrtab_mempool_alloc
+c03b4ccf r __kstrtab_mempool_free
+c03b4cdc r __kstrtab_mempool_alloc_slab
+c03b4cef r __kstrtab_mempool_free_slab
+c03b4d01 r __kstrtab_mempool_kmalloc
+c03b4d11 r __kstrtab_mempool_kzalloc
+c03b4d21 r __kstrtab_mempool_kfree
+c03b4d2f r __kstrtab_mempool_alloc_pages
+c03b4d43 r __kstrtab_mempool_free_pages
+c03b4d56 r __kstrtab_node_online_map
+c03b4d66 r __kstrtab_node_possible_map
+c03b4d78 r __kstrtab_totalram_pages
+c03b4d87 r __kstrtab___alloc_pages
+c03b4d95 r __kstrtab___get_free_pages
+c03b4da6 r __kstrtab_get_zeroed_page
+c03b4db6 r __kstrtab___free_pages
+c03b4dc3 r __kstrtab_free_pages
+c03b4dce r __kstrtab_si_meminfo
+c03b4dd9 r __kstrtab_contig_page_data
+c03b4e00 r __kstrtab_laptop_mode
+c03b4e20 r __kstrtab_balance_dirty_pages_ratelimited_nr
+c03b4e43 r __kstrtab_write_cache_pages
+c03b4e55 r __kstrtab_generic_writepages
+c03b4e68 r __kstrtab_write_one_page
+c03b4e77 r __kstrtab___set_page_dirty_nobuffers
+c03b4e92 r __kstrtab_redirty_page_for_writepage
+c03b4ead r __kstrtab_set_page_dirty
+c03b4ebc r __kstrtab_set_page_dirty_lock
+c03b4ed0 r __kstrtab_clear_page_dirty_for_io
+c03b4ee8 r __kstrtab_test_set_page_writeback
+c03b4f00 r __kstrtab_mapping_tagged
+c03b4f0f r __kstrtab_default_unplug_io_fn
+c03b4f24 r __kstrtab_default_backing_dev_info
+c03b4f3d r __kstrtab_file_ra_state_init
+c03b4f50 r __kstrtab_read_cache_pages
+c03b4f61 r __kstrtab_page_cache_readahead
+c03b4f76 r __kstrtab_put_page
+c03b4f7f r __kstrtab_put_pages_list
+c03b4f8e r __kstrtab_mark_page_accessed
+c03b4fa1 r __kstrtab___pagevec_release
+c03b4fb3 r __kstrtab___pagevec_lru_add
+c03b4fc5 r __kstrtab_pagevec_lookup
+c03b4fd4 r __kstrtab_pagevec_lookup_tag
+c03b4fe7 r __kstrtab_cancel_dirty_page
+c03b4ff9 r __kstrtab_truncate_inode_pages_range
+c03b5014 r __kstrtab_truncate_inode_pages
+c03b5029 r __kstrtab_invalidate_mapping_pages
+c03b5042 r __kstrtab_invalidate_inode_pages2_range
+c03b5060 r __kstrtab_invalidate_inode_pages2
+c03b5078 r __kstrtab_set_shrinker
+c03b5085 r __kstrtab_remove_shrinker
+c03b5095 r __kstrtab___kzalloc
+c03b509f r __kstrtab_kstrdup
+c03b50a7 r __kstrtab_kstrndup
+c03b50b0 r __kstrtab_kmemdup
+c03b50b8 r __kstrtab_strndup_user
+c03b50c5 r __kstrtab_per_cpu__vm_event_states
+c03b50de r __kstrtab_all_vm_events
+c03b50ec r __kstrtab_vm_stat
+c03b50f4 r __kstrtab___mod_zone_page_state
+c03b510a r __kstrtab_mod_zone_page_state
+c03b511e r __kstrtab___inc_zone_page_state
+c03b5134 r __kstrtab___dec_zone_page_state
+c03b514a r __kstrtab_inc_zone_page_state
+c03b515e r __kstrtab_dec_zone_page_state
+c03b5172 r __kstrtab_refresh_vm_stats
+c03b5183 r __kstrtab_clear_bdi_congested
+c03b5197 r __kstrtab_set_bdi_congested
+c03b51a9 r __kstrtab_congestion_wait
+c03b51b9 r __kstrtab_congestion_wait_interruptible
+c03b51d7 r __kstrtab_congestion_end
+c03b51e6 r __kstrtab_install_page
+c03b51f3 r __kstrtab_kmap_high
+c03b51fd r __kstrtab_kunmap_high
+c03b5209 r __kstrtab_page_address
+c03b5216 r __kstrtab_max_mapnr
+c03b5220 r __kstrtab_mem_map
+c03b5228 r __kstrtab_num_physpages
+c03b5236 r __kstrtab_high_memory
+c03b5242 r __kstrtab_vmalloc_earlyreserve
+c03b5257 r __kstrtab_get_user_pages
+c03b5266 r __kstrtab_vm_insert_page
+c03b5275 r __kstrtab_vm_insert_pfn
+c03b5283 r __kstrtab_remap_pfn_range
+c03b5293 r __kstrtab_apply_to_page_range
+c03b52a7 r __kstrtab_unmap_mapping_range
+c03b52bb r __kstrtab_vmtruncate
+c03b52c6 r __kstrtab___handle_mm_fault
+c03b52d8 r __kstrtab_vmalloc_to_page
+c03b52e8 r __kstrtab_vmalloc_to_pfn
+c03b52f7 r __kstrtab_can_do_mlock
+c03b5304 r __kstrtab_vm_get_page_prot
+c03b5315 r __kstrtab___vm_enough_memory
+c03b5328 r __kstrtab_do_mmap_pgoff
+c03b5336 r __kstrtab_get_unmapped_area
+c03b5348 r __kstrtab_find_vma
+c03b5351 r __kstrtab_do_munmap
+c03b535b r __kstrtab_do_brk
+c03b5362 r __kstrtab_page_mkclean
+c03b536f r __kstrtab_vfree
+c03b5375 r __kstrtab_vunmap
+c03b537c r __kstrtab_vmap
+c03b5381 r __kstrtab___vmalloc
+c03b538b r __kstrtab_vmalloc
+c03b5393 r __kstrtab_vmalloc_user
+c03b53a0 r __kstrtab_vmalloc_node
+c03b53ad r __kstrtab_vmalloc_32
+c03b53b8 r __kstrtab_vmalloc_32_user
+c03b53c8 r __kstrtab_remap_vmalloc_range
+c03b53dc r __kstrtab_blk_queue_bounce
+c03b53ed r __kstrtab_malloc_sizes
+c03b53fa r __kstrtab_kmem_cache_create
+c03b540c r __kstrtab_kmem_cache_shrink
+c03b541e r __kstrtab_kmem_cache_destroy
+c03b5431 r __kstrtab_kmem_cache_alloc
+c03b5442 r __kstrtab_kmem_cache_zalloc
+c03b5454 r __kstrtab___kmalloc
+c03b545e r __kstrtab_krealloc
+c03b5467 r __kstrtab_kmem_cache_free
+c03b5477 r __kstrtab_kfree
+c03b547d r __kstrtab_kmem_cache_size
+c03b548d r __kstrtab_kmem_cache_name
+c03b549d r __kstrtab_xip_file_read
+c03b54ab r __kstrtab_xip_file_sendfile
+c03b54bd r __kstrtab_xip_file_mmap
+c03b54cb r __kstrtab_xip_file_write
+c03b54da r __kstrtab_xip_truncate_page
+c03b54ec r __kstrtab_percpu_depopulate
+c03b54fe r __kstrtab___percpu_depopulate_mask
+c03b5517 r __kstrtab_percpu_populate
+c03b5527 r __kstrtab___percpu_populate_mask
+c03b553e r __kstrtab___percpu_alloc_mask
+c03b5552 r __kstrtab_percpu_free
+c03b5560 r __kstrtab_vfs_statfs
+c03b556b r __kstrtab_filp_open
+c03b5575 r __kstrtab_lookup_instantiate_filp
+c03b558d r __kstrtab_dentry_open
+c03b5599 r __kstrtab_get_unused_fd
+c03b55a7 r __kstrtab_put_unused_fd
+c03b55b5 r __kstrtab_fd_install
+c03b55c0 r __kstrtab_sys_open
+c03b55c9 r __kstrtab_filp_close
+c03b55d4 r __kstrtab_sys_close
+c03b55de r __kstrtab_generic_file_open
+c03b55f0 r __kstrtab_nonseekable_open
+c03b5601 r __kstrtab_generic_ro_fops
+c03b5611 r __kstrtab_generic_file_llseek
+c03b5625 r __kstrtab_remote_llseek
+c03b5633 r __kstrtab_no_llseek
+c03b563d r __kstrtab_default_llseek
+c03b564c r __kstrtab_vfs_llseek
+c03b5657 r __kstrtab_do_sync_read
+c03b5664 r __kstrtab_vfs_read
+c03b566d r __kstrtab_do_sync_write
+c03b567b r __kstrtab_vfs_write
+c03b5685 r __kstrtab_sys_read
+c03b568e r __kstrtab_vfs_readv
+c03b5698 r __kstrtab_vfs_writev
+c03b56a3 r __kstrtab_get_max_files
+c03b56b1 r __kstrtab_get_empty_filp
+c03b56c0 r __kstrtab_fput
+c03b56c5 r __kstrtab_fget
+c03b56ca r __kstrtab_deactivate_super
+c03b56db r __kstrtab_lock_super
+c03b56e6 r __kstrtab_unlock_super
+c03b56f3 r __kstrtab_generic_shutdown_super
+c03b570a r __kstrtab_sget
+c03b570f r __kstrtab_drop_super
+c03b571a r __kstrtab_get_super
+c03b5724 r __kstrtab_set_anon_super
+c03b5733 r __kstrtab_kill_anon_super
+c03b5743 r __kstrtab_kill_litter_super
+c03b5755 r __kstrtab_get_sb_bdev
+c03b5761 r __kstrtab_kill_block_super
+c03b5772 r __kstrtab_get_sb_nodev
+c03b577f r __kstrtab_get_sb_single
+c03b578d r __kstrtab_vfs_kern_mount
+c03b579c r __kstrtab_kern_mount
+c03b57a7 r __kstrtab_register_chrdev_region
+c03b57be r __kstrtab_unregister_chrdev_region
+c03b57d7 r __kstrtab_alloc_chrdev_region
+c03b57eb r __kstrtab_cdev_init
+c03b57f5 r __kstrtab_cdev_alloc
+c03b5800 r __kstrtab_cdev_del
+c03b5809 r __kstrtab_cdev_add
+c03b5812 r __kstrtab_register_chrdev
+c03b5822 r __kstrtab_unregister_chrdev
+c03b5834 r __kstrtab_directly_mappable_cdev_bdi
+c03b584f r __kstrtab_generic_fillattr
+c03b5860 r __kstrtab_vfs_getattr
+c03b586c r __kstrtab_vfs_stat
+c03b5875 r __kstrtab_vfs_lstat
+c03b587f r __kstrtab_vfs_fstat
+c03b5889 r __kstrtab_inode_add_bytes
+c03b5899 r __kstrtab_inode_sub_bytes
+c03b58a9 r __kstrtab_inode_get_bytes
+c03b58b9 r __kstrtab_inode_set_bytes
+c03b58c9 r __kstrtab_suid_dumpable
+c03b58d7 r __kstrtab_register_binfmt
+c03b58e7 r __kstrtab_unregister_binfmt
+c03b58f9 r __kstrtab_copy_strings_kernel
+c03b590d r __kstrtab_setup_arg_pages
+c03b591d r __kstrtab_open_exec
+c03b5927 r __kstrtab_kernel_read
+c03b5933 r __kstrtab_flush_old_exec
+c03b5942 r __kstrtab_prepare_binprm
+c03b5951 r __kstrtab_compute_creds
+c03b595f r __kstrtab_remove_arg_zero
+c03b596f r __kstrtab_search_binary_handler
+c03b5985 r __kstrtab_set_binfmt
+c03b5990 r __kstrtab_lookup_create
+c03b599e r __kstrtab___user_walk
+c03b59aa r __kstrtab___user_walk_fd
+c03b59b9 r __kstrtab_follow_down
+c03b59c5 r __kstrtab_follow_up
+c03b59cf r __kstrtab_get_write_access
+c03b59e0 r __kstrtab_getname
+c03b59e8 r __kstrtab_lock_rename
+c03b59f4 r __kstrtab_lookup_one_len_nd
+c03b5a06 r __kstrtab_page_follow_link_light
+c03b5a1d r __kstrtab_page_put_link
+c03b5a2b r __kstrtab_page_readlink
+c03b5a39 r __kstrtab___page_symlink
+c03b5a48 r __kstrtab_page_symlink
+c03b5a55 r __kstrtab_page_symlink_inode_operations
+c03b5a73 r __kstrtab_path_lookup
+c03b5a7f r __kstrtab_path_release
+c03b5a8c r __kstrtab_path_walk
+c03b5a96 r __kstrtab_permission
+c03b5aa1 r __kstrtab_vfs_permission
+c03b5ab0 r __kstrtab_file_permission
+c03b5ac0 r __kstrtab_unlock_rename
+c03b5ace r __kstrtab_vfs_create
+c03b5ad9 r __kstrtab_vfs_follow_link
+c03b5ae9 r __kstrtab_vfs_link
+c03b5af2 r __kstrtab_vfs_mkdir
+c03b5afc r __kstrtab_vfs_mknod
+c03b5b06 r __kstrtab_generic_permission
+c03b5b19 r __kstrtab_vfs_readlink
+c03b5b26 r __kstrtab_vfs_rename
+c03b5b31 r __kstrtab_vfs_rmdir
+c03b5b3b r __kstrtab_vfs_symlink
+c03b5b47 r __kstrtab_vfs_unlink
+c03b5b52 r __kstrtab_dentry_unhash
+c03b5b60 r __kstrtab_generic_readlink
+c03b5b71 r __kstrtab___f_setown
+c03b5b7c r __kstrtab_f_setown
+c03b5b85 r __kstrtab_fasync_helper
+c03b5b93 r __kstrtab___kill_fasync
+c03b5ba1 r __kstrtab_kill_fasync
+c03b5bad r __kstrtab_vfs_readdir
+c03b5bb9 r __kstrtab_poll_initwait
+c03b5bc7 r __kstrtab_poll_freewait
+c03b5bd5 r __kstrtab_locks_init_lock
+c03b5be5 r __kstrtab_locks_copy_lock
+c03b5bf5 r __kstrtab_posix_test_lock
+c03b5c05 r __kstrtab_posix_lock_file
+c03b5c15 r __kstrtab_posix_lock_file_wait
+c03b5c2a r __kstrtab_locks_mandatory_area
+c03b5c3f r __kstrtab_lease_modify
+c03b5c4c r __kstrtab___break_lease
+c03b5c5a r __kstrtab_lease_get_mtime
+c03b5c6a r __kstrtab_setlease
+c03b5c73 r __kstrtab_flock_lock_file_wait
+c03b5c88 r __kstrtab_vfs_test_lock
+c03b5c96 r __kstrtab_vfs_lock_file
+c03b5ca4 r __kstrtab_locks_remove_posix
+c03b5cb7 r __kstrtab_posix_unblock_lock
+c03b5cca r __kstrtab_vfs_cancel_lock
+c03b5cda r __kstrtab_lock_may_read
+c03b5ce8 r __kstrtab_lock_may_write
+c03b5cf7 r __kstrtab_sysctl_vfs_cache_pressure
+c03b5d11 r __kstrtab_dcache_lock
+c03b5d1d r __kstrtab_d_instantiate_unique
+c03b5d32 r __kstrtab_d_genocide
+c03b5d3d r __kstrtab_d_alloc
+c03b5d45 r __kstrtab_d_alloc_anon
+c03b5d52 r __kstrtab_d_alloc_root
+c03b5d5f r __kstrtab_d_delete
+c03b5d68 r __kstrtab_d_find_alias
+c03b5d75 r __kstrtab_d_instantiate
+c03b5d83 r __kstrtab_d_invalidate
+c03b5d90 r __kstrtab_d_lookup
+c03b5d99 r __kstrtab_d_move
+c03b5da0 r __kstrtab_d_materialise_unique
+c03b5db5 r __kstrtab_d_path
+c03b5dbc r __kstrtab_d_prune_aliases
+c03b5dcc r __kstrtab_d_rehash
+c03b5dd5 r __kstrtab_d_splice_alias
+c03b5de4 r __kstrtab_d_validate
+c03b5def r __kstrtab_dget_locked
+c03b5dfb r __kstrtab_dput
+c03b5e00 r __kstrtab_find_inode_number
+c03b5e12 r __kstrtab_have_submounts
+c03b5e21 r __kstrtab_names_cachep
+c03b5e2e r __kstrtab_shrink_dcache_parent
+c03b5e43 r __kstrtab_shrink_dcache_sb
+c03b5e54 r __kstrtab_inode_init_once
+c03b5e64 r __kstrtab___iget
+c03b5e6b r __kstrtab_clear_inode
+c03b5e77 r __kstrtab_invalidate_inodes
+c03b5e89 r __kstrtab_new_inode
+c03b5e93 r __kstrtab_unlock_new_inode
+c03b5ea4 r __kstrtab_iunique
+c03b5eac r __kstrtab_igrab
+c03b5eb2 r __kstrtab_ilookup5_nowait
+c03b5ec2 r __kstrtab_ilookup5
+c03b5ecb r __kstrtab_ilookup
+c03b5ed3 r __kstrtab_iget5_locked
+c03b5ee0 r __kstrtab_iget_locked
+c03b5eec r __kstrtab___insert_inode_hash
+c03b5f00 r __kstrtab_remove_inode_hash
+c03b5f12 r __kstrtab_generic_delete_inode
+c03b5f27 r __kstrtab_generic_drop_inode
+c03b5f3a r __kstrtab_iput
+c03b5f3f r __kstrtab_bmap
+c03b5f44 r __kstrtab_touch_atime
+c03b5f50 r __kstrtab_file_update_time
+c03b5f61 r __kstrtab_inode_needs_sync
+c03b5f72 r __kstrtab_inode_double_lock
+c03b5f84 r __kstrtab_inode_double_unlock
+c03b5f98 r __kstrtab_init_special_inode
+c03b5fab r __kstrtab_inode_change_ok
+c03b5fbb r __kstrtab_inode_setattr
+c03b5fc9 r __kstrtab_notify_change
+c03b5fd7 r __kstrtab_make_bad_inode
+c03b5fe6 r __kstrtab_is_bad_inode
+c03b5ff3 r __kstrtab_register_filesystem
+c03b6007 r __kstrtab_unregister_filesystem
+c03b601d r __kstrtab_get_fs_type
+c03b6029 r __kstrtab_fs_subsys
+c03b6033 r __kstrtab_simple_set_mnt
+c03b6042 r __kstrtab_mntput_no_expire
+c03b6053 r __kstrtab_mnt_pin
+c03b605b r __kstrtab_mnt_unpin
+c03b6065 r __kstrtab_may_umount_tree
+c03b6075 r __kstrtab_may_umount
+c03b6080 r __kstrtab_do_add_mount
+c03b608d r __kstrtab_mark_mounts_for_expiry
+c03b60a4 r __kstrtab_shrink_submounts
+c03b60b5 r __kstrtab_kick_iocb
+c03b60bf r __kstrtab_aio_complete
+c03b60cc r __kstrtab_aio_put_req
+c03b60d8 r __kstrtab_wait_on_sync_kiocb
+c03b60eb r __kstrtab_seq_open
+c03b60f4 r __kstrtab_seq_read
+c03b60fd r __kstrtab_seq_lseek
+c03b6107 r __kstrtab_seq_release
+c03b6113 r __kstrtab_seq_escape
+c03b611e r __kstrtab_seq_printf
+c03b6129 r __kstrtab_seq_path
+c03b6132 r __kstrtab_single_open
+c03b613e r __kstrtab_single_release
+c03b614d r __kstrtab_seq_release_private
+c03b6161 r __kstrtab_seq_putc
+c03b616a r __kstrtab_seq_puts
+c03b6173 r __kstrtab_vfs_setxattr
+c03b6180 r __kstrtab_vfs_getxattr
+c03b618d r __kstrtab_vfs_listxattr
+c03b619b r __kstrtab_vfs_removexattr
+c03b61ab r __kstrtab_generic_getxattr
+c03b61bc r __kstrtab_generic_listxattr
+c03b61ce r __kstrtab_generic_setxattr
+c03b61df r __kstrtab_generic_removexattr
+c03b61f3 r __kstrtab_dcache_dir_close
+c03b6204 r __kstrtab_dcache_dir_lseek
+c03b6215 r __kstrtab_dcache_dir_open
+c03b6225 r __kstrtab_dcache_readdir
+c03b6234 r __kstrtab_dcache_readdir_filter
+c03b624a r __kstrtab_generic_read_dir
+c03b625b r __kstrtab_get_sb_pseudo
+c03b6269 r __kstrtab_simple_commit_write
+c03b627d r __kstrtab_simple_dir_inode_operations
+c03b6299 r __kstrtab_simple_dir_operations
+c03b62af r __kstrtab_simple_empty
+c03b62bc r __kstrtab_d_alloc_name
+c03b62c9 r __kstrtab_simple_fill_super
+c03b62db r __kstrtab_simple_getattr
+c03b62ea r __kstrtab_simple_link
+c03b62f6 r __kstrtab_simple_lookup
+c03b6304 r __kstrtab_simple_pin_fs
+c03b6312 r __kstrtab_simple_prepare_write
+c03b6327 r __kstrtab_simple_readpage
+c03b6337 r __kstrtab_simple_release_fs
+c03b6349 r __kstrtab_simple_rename
+c03b6357 r __kstrtab_simple_rmdir
+c03b6364 r __kstrtab_simple_statfs
+c03b6372 r __kstrtab_simple_sync_file
+c03b6383 r __kstrtab_simple_unlink
+c03b6391 r __kstrtab_simple_read_from_buffer
+c03b63a9 r __kstrtab_simple_transaction_get
+c03b63c0 r __kstrtab_simple_transaction_read
+c03b63d8 r __kstrtab_simple_transaction_release
+c03b63f3 r __kstrtab_simple_attr_open
+c03b6404 r __kstrtab_simple_attr_close
+c03b6416 r __kstrtab_simple_attr_read
+c03b6427 r __kstrtab_simple_attr_write
+c03b6439 r __kstrtab___mark_inode_dirty
+c03b644c r __kstrtab_write_inode_now
+c03b645c r __kstrtab_sync_inode
+c03b6467 r __kstrtab_generic_osync_inode
+c03b647b r __kstrtab_drop_pagecache_sb
+c03b64a0 r __kstrtab_generic_file_splice_read
+c03b64b9 r __kstrtab___splice_from_pipe
+c03b64e0 r __kstrtab_generic_file_splice_write_nolock
+c03b6501 r __kstrtab_generic_file_splice_write
+c03b651b r __kstrtab_generic_splice_sendpage
+c03b6533 r __kstrtab_do_sync_mapping_range
+c03b6549 r __kstrtab_fsstack_copy_inode_size
+c03b6561 r __kstrtab_fsstack_copy_attr_all
+c03b6577 r __kstrtab___lock_buffer
+c03b6585 r __kstrtab_sync_blockdev
+c03b6593 r __kstrtab_freeze_bdev
+c03b659f r __kstrtab_thaw_bdev
+c03b65a9 r __kstrtab_mark_buffer_async_write
+c03b65c1 r __kstrtab_sync_mapping_buffers
+c03b65d6 r __kstrtab_mark_buffer_dirty_inode
+c03b65ee r __kstrtab___set_page_dirty_buffers
+c03b6607 r __kstrtab_alloc_page_buffers
+c03b661a r __kstrtab___find_get_block
+c03b662b r __kstrtab___getblk
+c03b6634 r __kstrtab___breadahead
+c03b6641 r __kstrtab___bread
+c03b6649 r __kstrtab_set_bh_page
+c03b6655 r __kstrtab_block_invalidatepage
+c03b666a r __kstrtab_create_empty_buffers
+c03b667f r __kstrtab_unmap_underlying_metadata
+c03b6699 r __kstrtab_nobh_prepare_write
+c03b66ac r __kstrtab_nobh_commit_write
+c03b66be r __kstrtab_nobh_writepage
+c03b66cd r __kstrtab_nobh_truncate_page
+c03b66e0 r __kstrtab_try_to_free_buffers
+c03b66f4 r __kstrtab_alloc_buffer_head
+c03b6706 r __kstrtab_free_buffer_head
+c03b6717 r __kstrtab___bforget
+c03b6721 r __kstrtab___brelse
+c03b672a r __kstrtab___wait_on_buffer
+c03b673b r __kstrtab_block_commit_write
+c03b674e r __kstrtab_block_prepare_write
+c03b6762 r __kstrtab_block_read_full_page
+c03b6777 r __kstrtab_block_sync_page
+c03b6787 r __kstrtab_block_truncate_page
+c03b679b r __kstrtab_block_write_full_page
+c03b67b1 r __kstrtab_cont_prepare_write
+c03b67c4 r __kstrtab_end_buffer_read_sync
+c03b67d9 r __kstrtab_end_buffer_write_sync
+c03b67ef r __kstrtab_file_fsync
+c03b67fa r __kstrtab_fsync_bdev
+c03b6805 r __kstrtab_generic_block_bmap
+c03b6818 r __kstrtab_generic_commit_write
+c03b682d r __kstrtab_generic_cont_expand
+c03b6841 r __kstrtab_generic_cont_expand_simple
+c03b685c r __kstrtab_init_buffer
+c03b6868 r __kstrtab_invalidate_bdev
+c03b6878 r __kstrtab_ll_rw_block
+c03b6884 r __kstrtab_mark_buffer_dirty
+c03b6896 r __kstrtab_submit_bh
+c03b68a0 r __kstrtab_sync_dirty_buffer
+c03b68b2 r __kstrtab_unlock_buffer
+c03b68c0 r __kstrtab_zero_fill_bio
+c03b68ce r __kstrtab_bio_alloc
+c03b68d8 r __kstrtab_bio_put
+c03b68e0 r __kstrtab_bio_free
+c03b68e9 r __kstrtab_bio_endio
+c03b68f3 r __kstrtab_bio_init
+c03b68fc r __kstrtab___bio_clone
+c03b6908 r __kstrtab_bio_clone
+c03b6912 r __kstrtab_bio_phys_segments
+c03b6924 r __kstrtab_bio_hw_segments
+c03b6934 r __kstrtab_bio_add_page
+c03b6941 r __kstrtab_bio_add_pc_page
+c03b6951 r __kstrtab_bio_get_nr_vecs
+c03b6961 r __kstrtab_bio_map_user
+c03b696e r __kstrtab_bio_unmap_user
+c03b697d r __kstrtab_bio_map_kern
+c03b698a r __kstrtab_bio_pair_release
+c03b699b r __kstrtab_bio_split
+c03b69a5 r __kstrtab_bio_split_pool
+c03b69b4 r __kstrtab_bio_copy_user
+c03b69c2 r __kstrtab_bio_uncopy_user
+c03b69d2 r __kstrtab_bioset_create
+c03b69e0 r __kstrtab_bioset_free
+c03b69ec r __kstrtab_bio_alloc_bioset
+c03b69fd r __kstrtab_I_BDEV
+c03b6a04 r __kstrtab_set_blocksize
+c03b6a12 r __kstrtab_sb_set_blocksize
+c03b6a23 r __kstrtab_sb_min_blocksize
+c03b6a34 r __kstrtab_bdget
+c03b6a3a r __kstrtab_bdput
+c03b6a40 r __kstrtab_bd_claim
+c03b6a49 r __kstrtab_bd_release
+c03b6a54 r __kstrtab_bd_claim_by_disk
+c03b6a65 r __kstrtab_bd_release_from_disk
+c03b6a7a r __kstrtab_open_by_devnum
+c03b6a89 r __kstrtab_check_disk_change
+c03b6a9b r __kstrtab_bd_set_size
+c03b6aa7 r __kstrtab_blkdev_get
+c03b6ab2 r __kstrtab_blkdev_put
+c03b6abd r __kstrtab_ioctl_by_bdev
+c03b6acb r __kstrtab_open_bdev_excl
+c03b6ada r __kstrtab_close_bdev_excl
+c03b6aea r __kstrtab___invalidate_device
+c03b6afe r __kstrtab___blockdev_direct_IO
+c03b6b13 r __kstrtab_mpage_readpages
+c03b6b23 r __kstrtab_mpage_readpage
+c03b6b32 r __kstrtab_mpage_writepages
+c03b6b43 r __kstrtab_mpage_writepage
+c03b6b53 r __kstrtab_generic_file_revoke
+c03b6b80 r __kstrtab_get_inotify_watch
+c03b6b92 r __kstrtab_put_inotify_watch
+c03b6ba4 r __kstrtab_inotify_remove_watch_locked
+c03b6bc0 r __kstrtab_inotify_inode_queue_event
+c03b6be0 r __kstrtab_inotify_dentry_parent_queue_event
+c03b6c02 r __kstrtab_inotify_get_cookie
+c03b6c15 r __kstrtab_inotify_unmount_inodes
+c03b6c2c r __kstrtab_inotify_inode_is_dead
+c03b6c42 r __kstrtab_inotify_init
+c03b6c4f r __kstrtab_inotify_init_watch
+c03b6c62 r __kstrtab_inotify_destroy
+c03b6c72 r __kstrtab_inotify_find_watch
+c03b6c85 r __kstrtab_inotify_find_update_watch
+c03b6c9f r __kstrtab_inotify_add_watch
+c03b6cb1 r __kstrtab_inotify_rm_wd
+c03b6cbf r __kstrtab_inotify_rm_watch
+c03b6cd0 r __kstrtab_mb_cache_create
+c03b6ce0 r __kstrtab_mb_cache_shrink
+c03b6cf0 r __kstrtab_mb_cache_destroy
+c03b6d01 r __kstrtab_mb_cache_entry_alloc
+c03b6d16 r __kstrtab_mb_cache_entry_insert
+c03b6d2c r __kstrtab_mb_cache_entry_release
+c03b6d43 r __kstrtab_mb_cache_entry_free
+c03b6d57 r __kstrtab_mb_cache_entry_get
+c03b6d6a r __kstrtab_mb_cache_entry_find_first
+c03b6d84 r __kstrtab_mb_cache_entry_find_next
+c03b6d9d r __kstrtab_posix_acl_alloc
+c03b6dad r __kstrtab_posix_acl_clone
+c03b6dbd r __kstrtab_posix_acl_valid
+c03b6dcd r __kstrtab_posix_acl_equiv_mode
+c03b6de2 r __kstrtab_posix_acl_from_mode
+c03b6df6 r __kstrtab_posix_acl_create_masq
+c03b6e0c r __kstrtab_posix_acl_chmod_masq
+c03b6e21 r __kstrtab_posix_acl_permission
+c03b6e36 r __kstrtab_posix_acl_from_xattr
+c03b6e4b r __kstrtab_posix_acl_to_xattr
+c03b6e5e r __kstrtab_mark_info_dirty
+c03b6e6e r __kstrtab_register_quota_format
+c03b6e84 r __kstrtab_unregister_quota_format
+c03b6e9c r __kstrtab_dqstats
+c03b6ea4 r __kstrtab_dq_data_lock
+c03b6eb1 r __kstrtab_vfs_quota_on
+c03b6ebe r __kstrtab_vfs_quota_on_mount
+c03b6ed1 r __kstrtab_vfs_quota_off
+c03b6edf r __kstrtab_vfs_quota_sync
+c03b6eee r __kstrtab_vfs_get_dqinfo
+c03b6efd r __kstrtab_vfs_set_dqinfo
+c03b6f0c r __kstrtab_vfs_get_dqblk
+c03b6f1a r __kstrtab_vfs_set_dqblk
+c03b6f28 r __kstrtab_dquot_commit
+c03b6f35 r __kstrtab_dquot_commit_info
+c03b6f47 r __kstrtab_dquot_acquire
+c03b6f55 r __kstrtab_dquot_release
+c03b6f63 r __kstrtab_dquot_mark_dquot_dirty
+c03b6f7a r __kstrtab_dquot_initialize
+c03b6f8b r __kstrtab_dquot_drop
+c03b6f96 r __kstrtab_dquot_alloc_space
+c03b6fa8 r __kstrtab_dquot_alloc_inode
+c03b6fba r __kstrtab_dquot_free_space
+c03b6fcb r __kstrtab_dquot_free_inode
+c03b6fdc r __kstrtab_dquot_transfer
+c03b6feb r __kstrtab___inode_dir_notify
+c03b6ffe r __kstrtab_dnotify_parent
+c03b700d r __kstrtab_proc_symlink
+c03b701a r __kstrtab_proc_mkdir
+c03b7025 r __kstrtab_create_proc_entry
+c03b7037 r __kstrtab_remove_proc_entry
+c03b7049 r __kstrtab_proc_root
+c03b7053 r __kstrtab_proc_root_fs
+c03b7060 r __kstrtab_proc_bus
+c03b7069 r __kstrtab_proc_root_driver
+c03b707a r __kstrtab_maps_protect
+c03b7087 r __kstrtab_bdevname
+c03b7090 r __kstrtab___bdevname
+c03b709b r __kstrtab_read_dev_sector
+c03b70ab r __kstrtab_sysfs_notify
+c03b70b8 r __kstrtab_sysfs_add_file_to_group
+c03b70d0 r __kstrtab_sysfs_chmod_file
+c03b70e1 r __kstrtab_sysfs_remove_file_from_group
+c03b70fe r __kstrtab_sysfs_schedule_callback
+c03b7116 r __kstrtab_sysfs_create_file
+c03b7128 r __kstrtab_sysfs_remove_file
+c03b713a r __kstrtab_sysfs_update_file
+c03b714c r __kstrtab_sysfs_create_link
+c03b715e r __kstrtab_sysfs_remove_link
+c03b7170 r __kstrtab_sysfs_create_bin_file
+c03b7186 r __kstrtab_sysfs_remove_bin_file
+c03b719c r __kstrtab_sysfs_create_group
+c03b71af r __kstrtab_sysfs_remove_group
+c03b71c2 r __kstrtab_dcookie_register
+c03b71d3 r __kstrtab_dcookie_unregister
+c03b71e6 r __kstrtab_get_dcookie
+c03b7200 r __kstrtab_journal_start
+c03b720e r __kstrtab_journal_restart
+c03b721e r __kstrtab_journal_extend
+c03b722d r __kstrtab_journal_stop
+c03b723a r __kstrtab_journal_lock_updates
+c03b724f r __kstrtab_journal_unlock_updates
+c03b7266 r __kstrtab_journal_get_write_access
+c03b727f r __kstrtab_journal_get_create_access
+c03b7299 r __kstrtab_journal_get_undo_access
+c03b72b1 r __kstrtab_journal_dirty_data
+c03b72c4 r __kstrtab_journal_dirty_metadata
+c03b72db r __kstrtab_journal_release_buffer
+c03b72f2 r __kstrtab_journal_forget
+c03b7301 r __kstrtab_journal_flush
+c03b730f r __kstrtab_journal_revoke
+c03b731e r __kstrtab_journal_init_dev
+c03b732f r __kstrtab_journal_init_inode
+c03b7342 r __kstrtab_journal_update_format
+c03b7358 r __kstrtab_journal_check_used_features
+c03b7380 r __kstrtab_journal_check_available_features
+c03b73a1 r __kstrtab_journal_set_features
+c03b73b6 r __kstrtab_journal_create
+c03b73c5 r __kstrtab_journal_load
+c03b73d2 r __kstrtab_journal_destroy
+c03b73e2 r __kstrtab_journal_update_superblock
+c03b73fc r __kstrtab_journal_abort
+c03b740a r __kstrtab_journal_errno
+c03b7418 r __kstrtab_journal_ack_err
+c03b7428 r __kstrtab_journal_clear_err
+c03b743a r __kstrtab_log_wait_commit
+c03b744a r __kstrtab_journal_start_commit
+c03b745f r __kstrtab_journal_force_commit_nested
+c03b747b r __kstrtab_journal_wipe
+c03b7488 r __kstrtab_journal_blocks_per_page
+c03b74a0 r __kstrtab_journal_invalidatepage
+c03b74b7 r __kstrtab_journal_try_to_free_buffers
+c03b74d3 r __kstrtab_journal_force_commit
+c03b74e8 r __kstrtab_register_nls
+c03b74f5 r __kstrtab_unregister_nls
+c03b7504 r __kstrtab_unload_nls
+c03b750f r __kstrtab_load_nls
+c03b7518 r __kstrtab_load_nls_default
+c03b7529 r __kstrtab_utf8_mbtowc
+c03b7535 r __kstrtab_utf8_mbstowcs
+c03b7543 r __kstrtab_utf8_wctomb
+c03b754f r __kstrtab_utf8_wcstombs
+c03b755d r __kstrtab_debugfs_create_file
+c03b7571 r __kstrtab_debugfs_create_dir
+c03b7584 r __kstrtab_debugfs_create_symlink
+c03b759b r __kstrtab_debugfs_remove
+c03b75aa r __kstrtab_debugfs_create_u8
+c03b75bc r __kstrtab_debugfs_create_u16
+c03b75cf r __kstrtab_debugfs_create_u32
+c03b75e2 r __kstrtab_debugfs_create_u64
+c03b75f5 r __kstrtab_debugfs_create_bool
+c03b7609 r __kstrtab_debugfs_create_blob
+c03b761d r __kstrtab_cap_netlink_send
+c03b762e r __kstrtab_cap_netlink_recv
+c03b763f r __kstrtab_cap_capable
+c03b764b r __kstrtab_cap_settime
+c03b7657 r __kstrtab_cap_ptrace
+c03b7662 r __kstrtab_cap_capget
+c03b766d r __kstrtab_cap_capset_check
+c03b767e r __kstrtab_cap_capset_set
+c03b768d r __kstrtab_cap_bprm_set_security
+c03b76a3 r __kstrtab_cap_bprm_apply_creds
+c03b76b8 r __kstrtab_cap_bprm_secureexec
+c03b76cc r __kstrtab_cap_inode_setxattr
+c03b76df r __kstrtab_cap_inode_removexattr
+c03b76f5 r __kstrtab_cap_task_post_setuid
+c03b770a r __kstrtab_cap_task_reparent_to_init
+c03b7724 r __kstrtab_cap_syslog
+c03b772f r __kstrtab_cap_vm_enough_memory
+c03b7744 r __kstrtab_crypto_alg_list
+c03b7754 r __kstrtab_crypto_alg_sem
+c03b7763 r __kstrtab_crypto_chain
+c03b7770 r __kstrtab_crypto_mod_get
+c03b777f r __kstrtab_crypto_mod_put
+c03b778e r __kstrtab___crypto_alg_lookup
+c03b77a2 r __kstrtab_crypto_alg_mod_lookup
+c03b77b8 r __kstrtab_crypto_shoot_alg
+c03b77c9 r __kstrtab___crypto_alloc_tfm
+c03b77dc r __kstrtab_crypto_alloc_base
+c03b77ee r __kstrtab_crypto_free_tfm
+c03b77fe r __kstrtab_crypto_has_alg
+c03b780d r __kstrtab_crypto_km_types
+c03b781d r __kstrtab_scatterwalk_start
+c03b782f r __kstrtab_scatterwalk_map
+c03b783f r __kstrtab_scatterwalk_done
+c03b7850 r __kstrtab_scatterwalk_copychunks
+c03b7867 r __kstrtab_elv_rq_merge_ok
+c03b7877 r __kstrtab_elevator_init
+c03b7885 r __kstrtab_elevator_exit
+c03b7893 r __kstrtab_elv_rb_add
+c03b789e r __kstrtab_elv_rb_del
+c03b78a9 r __kstrtab_elv_rb_find
+c03b78b5 r __kstrtab_elv_dispatch_sort
+c03b78c7 r __kstrtab_elv_dispatch_add_tail
+c03b78dd r __kstrtab___elv_add_request
+c03b78ef r __kstrtab_elv_add_request
+c03b78ff r __kstrtab_elv_next_request
+c03b7910 r __kstrtab_elv_dequeue_request
+c03b7924 r __kstrtab_elv_queue_empty
+c03b7934 r __kstrtab_elv_register
+c03b7941 r __kstrtab_elv_unregister
+c03b7950 r __kstrtab_elv_rb_former_request
+c03b7966 r __kstrtab_elv_rb_latter_request
+c03b797c r __kstrtab_blk_max_low_pfn
+c03b798c r __kstrtab_blk_max_pfn
+c03b7998 r __kstrtab_blk_get_backing_dev_info
+c03b79b1 r __kstrtab_blk_queue_prep_rq
+c03b79c3 r __kstrtab_blk_queue_merge_bvec
+c03b79d8 r __kstrtab_blk_queue_softirq_done
+c03b79ef r __kstrtab_blk_queue_make_request
+c03b7a06 r __kstrtab_blk_queue_ordered
+c03b7a18 r __kstrtab_blk_queue_issue_flush_fn
+c03b7a31 r __kstrtab_blk_queue_bounce_limit
+c03b7a48 r __kstrtab_blk_queue_max_sectors
+c03b7a5e r __kstrtab_blk_queue_max_phys_segments
+c03b7a7a r __kstrtab_blk_queue_max_hw_segments
+c03b7a94 r __kstrtab_blk_queue_max_segment_size
+c03b7aaf r __kstrtab_blk_queue_hardsect_size
+c03b7ac7 r __kstrtab_blk_queue_stack_limits
+c03b7ade r __kstrtab_blk_queue_segment_boundary
+c03b7af9 r __kstrtab_blk_queue_dma_alignment
+c03b7b11 r __kstrtab_blk_queue_find_tag
+c03b7b24 r __kstrtab_blk_free_tags
+c03b7b32 r __kstrtab_blk_queue_free_tags
+c03b7b46 r __kstrtab_blk_init_tags
+c03b7b54 r __kstrtab_blk_queue_init_tags
+c03b7b68 r __kstrtab_blk_queue_resize_tags
+c03b7b7e r __kstrtab_blk_queue_end_tag
+c03b7b90 r __kstrtab_blk_queue_start_tag
+c03b7ba4 r __kstrtab_blk_queue_invalidate_tags
+c03b7bbe r __kstrtab_blk_dump_rq_flags
+c03b7bd0 r __kstrtab_blk_recount_segments
+c03b7be5 r __kstrtab_blk_rq_map_sg
+c03b7bf3 r __kstrtab_ll_back_merge_fn
+c03b7c04 r __kstrtab_blk_plug_device
+c03b7c14 r __kstrtab_blk_remove_plug
+c03b7c24 r __kstrtab___generic_unplug_device
+c03b7c3c r __kstrtab_generic_unplug_device
+c03b7c52 r __kstrtab_blk_start_queue
+c03b7c62 r __kstrtab_blk_stop_queue
+c03b7c71 r __kstrtab_blk_sync_queue
+c03b7c80 r __kstrtab_blk_run_queue
+c03b7c8e r __kstrtab_blk_put_queue
+c03b7c9c r __kstrtab_blk_cleanup_queue
+c03b7cae r __kstrtab_blk_alloc_queue
+c03b7cbe r __kstrtab_blk_alloc_queue_node
+c03b7cd3 r __kstrtab_blk_init_queue
+c03b7ce2 r __kstrtab_blk_init_queue_node
+c03b7cf6 r __kstrtab_blk_get_queue
+c03b7d04 r __kstrtab_blk_get_request
+c03b7d14 r __kstrtab_blk_start_queueing
+c03b7d27 r __kstrtab_blk_requeue_request
+c03b7d3b r __kstrtab_blk_insert_request
+c03b7d4e r __kstrtab_blk_rq_map_user
+c03b7d5e r __kstrtab_blk_rq_map_user_iov
+c03b7d72 r __kstrtab_blk_rq_unmap_user
+c03b7d84 r __kstrtab_blk_rq_map_kern
+c03b7d94 r __kstrtab_blk_execute_rq_nowait
+c03b7daa r __kstrtab_blk_execute_rq
+c03b7db9 r __kstrtab_blkdev_issue_flush
+c03b7dcc r __kstrtab_disk_round_stats
+c03b7ddd r __kstrtab___blk_put_request
+c03b7def r __kstrtab_blk_put_request
+c03b7dff r __kstrtab_blk_end_sync_rq
+c03b7e0f r __kstrtab_generic_make_request
+c03b7e24 r __kstrtab_submit_bio
+c03b7e2f r __kstrtab_end_that_request_first
+c03b7e46 r __kstrtab_end_that_request_chunk
+c03b7e5d r __kstrtab_blk_complete_request
+c03b7e72 r __kstrtab_end_that_request_last
+c03b7e88 r __kstrtab_end_request
+c03b7e94 r __kstrtab_blk_rq_bio_prep
+c03b7ea4 r __kstrtab_kblockd_schedule_work
+c03b7eba r __kstrtab_kblockd_flush_work
+c03b7ecd r __kstrtab_put_io_context
+c03b7edc r __kstrtab_get_io_context
+c03b7eeb r __kstrtab_copy_io_context
+c03b7efb r __kstrtab_swap_io_context
+c03b7f0b r __kstrtab_blkdev_driver_ioctl
+c03b7f1f r __kstrtab_blkdev_ioctl
+c03b7f2c r __kstrtab_register_blkdev
+c03b7f3c r __kstrtab_unregister_blkdev
+c03b7f4e r __kstrtab_blk_register_region
+c03b7f62 r __kstrtab_blk_unregister_region
+c03b7f78 r __kstrtab_add_disk
+c03b7f81 r __kstrtab_del_gendisk
+c03b7f8d r __kstrtab_genhd_media_change_notify
+c03b7fa7 r __kstrtab_alloc_disk
+c03b7fb2 r __kstrtab_alloc_disk_node
+c03b7fc2 r __kstrtab_get_disk
+c03b7fcb r __kstrtab_put_disk
+c03b7fd4 r __kstrtab_set_device_ro
+c03b7fe2 r __kstrtab_set_disk_ro
+c03b7fee r __kstrtab_bdev_read_only
+c03b7ffd r __kstrtab_invalidate_partition
+c03b8012 r __kstrtab_scsi_command_size
+c03b8024 r __kstrtab_sg_scsi_ioctl
+c03b8032 r __kstrtab_scsi_cmd_ioctl
+c03b8041 r __kstrtab___blk_add_trace
+c03b8051 r __kstrtab_argv_free
+c03b805b r __kstrtab_argv_split
+c03b8066 r __kstrtab___bitmap_empty
+c03b8075 r __kstrtab___bitmap_full
+c03b8083 r __kstrtab___bitmap_equal
+c03b8092 r __kstrtab___bitmap_complement
+c03b80a6 r __kstrtab___bitmap_shift_right
+c03b80bb r __kstrtab___bitmap_shift_left
+c03b80cf r __kstrtab___bitmap_and
+c03b80dc r __kstrtab___bitmap_or
+c03b80e8 r __kstrtab___bitmap_xor
+c03b80f5 r __kstrtab___bitmap_andnot
+c03b8105 r __kstrtab___bitmap_intersects
+c03b8119 r __kstrtab___bitmap_subset
+c03b8129 r __kstrtab___bitmap_weight
+c03b8139 r __kstrtab_bitmap_scnprintf
+c03b814a r __kstrtab___bitmap_parse
+c03b8159 r __kstrtab_bitmap_parse_user
+c03b816b r __kstrtab_bitmap_scnlistprintf
+c03b8180 r __kstrtab_bitmap_parselist
+c03b8191 r __kstrtab_bitmap_remap
+c03b819e r __kstrtab_bitmap_bitremap
+c03b81ae r __kstrtab_bitmap_find_free_region
+c03b81c6 r __kstrtab_bitmap_release_region
+c03b81dc r __kstrtab_bitmap_allocate_region
+c03b81f3 r __kstrtab_memparse
+c03b81fc r __kstrtab_get_option
+c03b8207 r __kstrtab_get_options
+c03b8213 r __kstrtab___first_cpu
+c03b821f r __kstrtab___next_cpu
+c03b822a r __kstrtab___any_online_cpu
+c03b823b r __kstrtab__ctype
+c03b8242 r __kstrtab__atomic_dec_and_lock
+c03b8257 r __kstrtab_idr_pre_get
+c03b8263 r __kstrtab_idr_get_new_above
+c03b8275 r __kstrtab_idr_get_new
+c03b8281 r __kstrtab_idr_remove
+c03b828c r __kstrtab_idr_destroy
+c03b8298 r __kstrtab_idr_find
+c03b82a1 r __kstrtab_idr_replace
+c03b82ad r __kstrtab_idr_init
+c03b82b6 r __kstrtab_ida_pre_get
+c03b82c2 r __kstrtab_ida_get_new_above
+c03b82d4 r __kstrtab_ida_get_new
+c03b82e0 r __kstrtab_ida_remove
+c03b82eb r __kstrtab_ida_destroy
+c03b82f7 r __kstrtab_ida_init
+c03b8300 r __kstrtab_int_sqrt
+c03b8309 r __kstrtab_kobject_get_path
+c03b831a r __kstrtab_kobject_set_name
+c03b832b r __kstrtab_kobject_init
+c03b8338 r __kstrtab_kobject_register
+c03b8349 r __kstrtab_kobject_unregister
+c03b835c r __kstrtab_kobject_get
+c03b8368 r __kstrtab_kobject_put
+c03b8374 r __kstrtab_kobject_add
+c03b8380 r __kstrtab_kobject_del
+c03b838c r __kstrtab_kset_register
+c03b839a r __kstrtab_kset_unregister
+c03b83aa r __kstrtab_subsystem_register
+c03b83bd r __kstrtab_subsystem_unregister
+c03b83d2 r __kstrtab_subsys_create_file
+c03b83e5 r __kstrtab_kobject_uevent_env
+c03b83f8 r __kstrtab_kobject_uevent
+c03b8407 r __kstrtab_add_uevent_var
+c03b8416 r __kstrtab_kref_init
+c03b8420 r __kstrtab_kref_get
+c03b8429 r __kstrtab_kref_put
+c03b8432 r __kstrtab_radix_tree_insert
+c03b8444 r __kstrtab_radix_tree_lookup_slot
+c03b845b r __kstrtab_radix_tree_lookup
+c03b846d r __kstrtab_radix_tree_tag_set
+c03b8480 r __kstrtab_radix_tree_tag_clear
+c03b8495 r __kstrtab_radix_tree_gang_lookup
+c03b84ac r __kstrtab_radix_tree_gang_lookup_tag
+c03b84c7 r __kstrtab_radix_tree_delete
+c03b84d9 r __kstrtab_radix_tree_tagged
+c03b84eb r __kstrtab_rb_insert_color
+c03b84fb r __kstrtab_rb_erase
+c03b8504 r __kstrtab_rb_first
+c03b850d r __kstrtab_rb_last
+c03b8515 r __kstrtab_rb_next
+c03b851d r __kstrtab_rb_prev
+c03b8525 r __kstrtab_rb_replace_node
+c03b8535 r __kstrtab___init_rwsem
+c03b8542 r __kstrtab_rwsem_down_read_failed
+c03b8559 r __kstrtab_rwsem_down_write_failed
+c03b8571 r __kstrtab_rwsem_wake
+c03b857c r __kstrtab_rwsem_downgrade_wake
+c03b8591 r __kstrtab_strnicmp
+c03b859a r __kstrtab_strcasecmp
+c03b85a5 r __kstrtab_strncasecmp
+c03b85b1 r __kstrtab_strlcpy
+c03b85b9 r __kstrtab_strlcat
+c03b85c1 r __kstrtab_strnchr
+c03b85c9 r __kstrtab_strstrip
+c03b85d2 r __kstrtab_strspn
+c03b85d9 r __kstrtab_strcspn
+c03b85e1 r __kstrtab_strpbrk
+c03b85e9 r __kstrtab_strsep
+c03b85f0 r __kstrtab_memcmp
+c03b85f7 r __kstrtab_simple_strtoul
+c03b8606 r __kstrtab_simple_strtol
+c03b8614 r __kstrtab_simple_strtoull
+c03b8624 r __kstrtab_vsnprintf
+c03b862e r __kstrtab_vscnprintf
+c03b8639 r __kstrtab_snprintf
+c03b8642 r __kstrtab_scnprintf
+c03b864c r __kstrtab_vsprintf
+c03b8655 r __kstrtab_sprintf
+c03b865d r __kstrtab_vsscanf
+c03b8665 r __kstrtab_sscanf
+c03b866c r __kstrtab_kvasprintf
+c03b8677 r __kstrtab_kasprintf
+c03b8681 r __kstrtab_find_next_bit
+c03b868f r __kstrtab_find_next_zero_bit
+c03b86a2 r __kstrtab___delay
+c03b86aa r __kstrtab___const_udelay
+c03b86b9 r __kstrtab___udelay
+c03b86c2 r __kstrtab___ndelay
+c03b86cb r __kstrtab_memcpy
+c03b86d2 r __kstrtab_memset
+c03b86d9 r __kstrtab_memmove
+c03b86e1 r __kstrtab___strncpy_from_user
+c03b86f5 r __kstrtab_strncpy_from_user
+c03b8707 r __kstrtab_clear_user
+c03b8712 r __kstrtab___clear_user
+c03b871f r __kstrtab_strnlen_user
+c03b872c r __kstrtab___copy_to_user_ll
+c03b873e r __kstrtab___copy_from_user_ll
+c03b8752 r __kstrtab___copy_from_user_ll_nozero
+c03b876d r __kstrtab_copy_to_user
+c03b877a r __kstrtab_copy_from_user
+c03b8789 r __kstrtab___div64_32
+c03b8794 r __kstrtab_div64_64
+c03b879d r __kstrtab_sort
+c03b87a2 r __kstrtab_match_token
+c03b87ae r __kstrtab_match_int
+c03b87b8 r __kstrtab_match_octal
+c03b87c4 r __kstrtab_match_hex
+c03b87ce r __kstrtab_match_strcpy
+c03b87db r __kstrtab_match_strdup
+c03b87e8 r __kstrtab_half_md4_transform
+c03b87fb r __kstrtab_random32
+c03b8804 r __kstrtab_srandom32
+c03b880e r __kstrtab_hex_dump_to_buffer
+c03b8821 r __kstrtab_print_hex_dump
+c03b8830 r __kstrtab_print_hex_dump_bytes
+c03b8845 r __kstrtab_ioread8
+c03b884d r __kstrtab_ioread16
+c03b8856 r __kstrtab_ioread16be
+c03b8861 r __kstrtab_ioread32
+c03b886a r __kstrtab_ioread32be
+c03b8875 r __kstrtab_iowrite8
+c03b887e r __kstrtab_iowrite16
+c03b8888 r __kstrtab_iowrite16be
+c03b8894 r __kstrtab_iowrite32
+c03b889e r __kstrtab_iowrite32be
+c03b88aa r __kstrtab_ioread8_rep
+c03b88b6 r __kstrtab_ioread16_rep
+c03b88c3 r __kstrtab_ioread32_rep
+c03b88d0 r __kstrtab_iowrite8_rep
+c03b88dd r __kstrtab_iowrite16_rep
+c03b88eb r __kstrtab_iowrite32_rep
+c03b88f9 r __kstrtab_ioport_map
+c03b8904 r __kstrtab_ioport_unmap
+c03b8911 r __kstrtab_pci_iomap
+c03b891b r __kstrtab_pci_iounmap
+c03b8927 r __kstrtab___iowrite32_copy
+c03b8938 r __kstrtab___iowrite64_copy
+c03b8949 r __kstrtab_devm_ioremap
+c03b8956 r __kstrtab_devm_ioremap_nocache
+c03b896b r __kstrtab_devm_iounmap
+c03b8978 r __kstrtab_devm_ioport_map
+c03b8988 r __kstrtab_devm_ioport_unmap
+c03b899a r __kstrtab_pcim_iomap_table
+c03b89ab r __kstrtab_pcim_iomap
+c03b89b6 r __kstrtab_pcim_iounmap
+c03b89c3 r __kstrtab_pcim_iomap_regions
+c03b89d6 r __kstrtab_pcim_iounmap_regions
+c03b89eb r __kstrtab___spin_lock_init
+c03b89fc r __kstrtab___rwlock_init
+c03b8a0a r __kstrtab_hweight32
+c03b8a14 r __kstrtab_hweight16
+c03b8a1e r __kstrtab_hweight8
+c03b8a27 r __kstrtab_hweight64
+c03b8a31 r __kstrtab_lock_kernel
+c03b8a3d r __kstrtab_unlock_kernel
+c03b8a4b r __kstrtab___list_add
+c03b8a56 r __kstrtab_list_add
+c03b8a5f r __kstrtab_list_del
+c03b8a68 r __kstrtab_byte_rev_table
+c03b8a77 r __kstrtab_bitrev32
+c03b8a80 r __kstrtab_crc32_le
+c03b8a89 r __kstrtab_crc32_be
+c03b8a92 r __kstrtab_zlib_inflate_workspacesize
+c03b8aad r __kstrtab_zlib_inflate
+c03b8aba r __kstrtab_zlib_inflateInit2
+c03b8acc r __kstrtab_zlib_inflateEnd
+c03b8adc r __kstrtab_zlib_inflateReset
+c03b8aee r __kstrtab_zlib_inflateIncomp
+c03b8b01 r __kstrtab_textsearch_register
+c03b8b15 r __kstrtab_textsearch_unregister
+c03b8b2b r __kstrtab_textsearch_prepare
+c03b8b3e r __kstrtab_textsearch_find_continuous
+c03b8b59 r __kstrtab_textsearch_destroy
+c03b8b6c r __kstrtab_percpu_counter_mod
+c03b8b7f r __kstrtab_percpu_counter_sum
+c03b8b92 r __kstrtab_rdmsr_on_cpu
+c03b8b9f r __kstrtab_wrmsr_on_cpu
+c03b8bac r __kstrtab_rdmsr_safe_on_cpu
+c03b8bbe r __kstrtab_wrmsr_safe_on_cpu
+c03b8be0 r __kstrtab_pci_bus_read_config_byte
+c03b8bf9 r __kstrtab_pci_bus_read_config_word
+c03b8c12 r __kstrtab_pci_bus_read_config_dword
+c03b8c2c r __kstrtab_pci_bus_write_config_byte
+c03b8c46 r __kstrtab_pci_bus_write_config_word
+c03b8c60 r __kstrtab_pci_bus_write_config_dword
+c03b8c7b r __kstrtab_pci_block_user_cfg_access
+c03b8c95 r __kstrtab_pci_unblock_user_cfg_access
+c03b8cb1 r __kstrtab_pci_walk_bus
+c03b8cbe r __kstrtab_pci_bus_alloc_resource
+c03b8cd5 r __kstrtab_pci_bus_add_device
+c03b8ce8 r __kstrtab_pci_bus_add_devices
+c03b8cfc r __kstrtab_pci_enable_bridges
+c03b8d0f r __kstrtab_pci_root_buses
+c03b8d1e r __kstrtab_alloc_pci_dev
+c03b8d2c r __kstrtab_pci_create_bus
+c03b8d3b r __kstrtab_pci_scan_bus_parented
+c03b8d51 r __kstrtab_pci_add_new_bus
+c03b8d61 r __kstrtab_pci_do_scan_bus
+c03b8d71 r __kstrtab_pci_scan_slot
+c03b8d7f r __kstrtab_pci_scan_bridge
+c03b8d8f r __kstrtab_pci_scan_single_device
+c03b8da6 r __kstrtab_pci_scan_child_bus
+c03b8db9 r __kstrtab_pci_remove_bus
+c03b8dc8 r __kstrtab_pci_remove_bus_device
+c03b8dde r __kstrtab_pci_remove_behind_bridge
+c03b8df7 r __kstrtab_pci_stop_bus_device
+c03b8e0b r __kstrtab_pci_bus_max_busnr
+c03b8e1d r __kstrtab_pci_find_next_capability
+c03b8e36 r __kstrtab_pci_find_ext_capability
+c03b8e4e r __kstrtab_pci_find_next_ht_capability
+c03b8e6a r __kstrtab_pci_find_ht_capability
+c03b8e81 r __kstrtab_pci_choose_state
+c03b8e92 r __kstrtab_pci_restore_bars
+c03b8ea3 r __kstrtab_pci_enable_device_bars
+c03b8eba r __kstrtab_pci_enable_device
+c03b8ecc r __kstrtab_pcim_enable_device
+c03b8edf r __kstrtab_pcim_pin_device
+c03b8eef r __kstrtab_pci_disable_device
+c03b8f02 r __kstrtab_pci_find_capability
+c03b8f16 r __kstrtab_pci_bus_find_capability
+c03b8f2e r __kstrtab_pci_release_regions
+c03b8f42 r __kstrtab_pci_request_regions
+c03b8f56 r __kstrtab_pci_release_region
+c03b8f69 r __kstrtab_pci_request_region
+c03b8f7c r __kstrtab_pci_release_selected_regions
+c03b8f99 r __kstrtab_pci_request_selected_regions
+c03b8fb6 r __kstrtab_pci_set_master
+c03b8fc5 r __kstrtab_pci_set_mwi
+c03b8fd1 r __kstrtab_pci_clear_mwi
+c03b8fdf r __kstrtab_pci_intx
+c03b8fe8 r __kstrtab_pci_set_dma_mask
+c03b8ff9 r __kstrtab_pci_set_consistent_dma_mask
+c03b9015 r __kstrtab_pci_assign_resource
+c03b9029 r __kstrtab_pci_find_parent_resource
+c03b9042 r __kstrtab_pci_select_bars
+c03b9052 r __kstrtab_pci_set_power_state
+c03b9066 r __kstrtab_pci_save_state
+c03b9075 r __kstrtab_pci_restore_state
+c03b9087 r __kstrtab_pci_enable_wake
+c03b9097 r __kstrtab_pci_set_pcie_reset_state
+c03b90b0 r __kstrtab_isa_dma_bridge_buggy
+c03b90c5 r __kstrtab_pci_pci_problems
+c03b90d6 r __kstrtab_pcie_mch_quirk
+c03b90e5 r __kstrtab_pci_fixup_device
+c03b90f6 r __kstrtab_pci_match_id
+c03b9103 r __kstrtab_pci_match_device
+c03b9114 r __kstrtab___pci_register_driver
+c03b912a r __kstrtab_pci_unregister_driver
+c03b9140 r __kstrtab_pci_dev_driver
+c03b914f r __kstrtab_pci_bus_type
+c03b915c r __kstrtab_pci_dev_get
+c03b9168 r __kstrtab_pci_dev_put
+c03b9174 r __kstrtab_pci_dev_present
+c03b9184 r __kstrtab_pci_find_present
+c03b9195 r __kstrtab_pci_find_device
+c03b91a5 r __kstrtab_pci_find_slot
+c03b91b3 r __kstrtab_pci_find_bus
+c03b91c0 r __kstrtab_pci_find_next_bus
+c03b91d2 r __kstrtab_pci_get_device
+c03b91e1 r __kstrtab_pci_get_device_reverse
+c03b91f8 r __kstrtab_pci_get_subsys
+c03b9207 r __kstrtab_pci_get_slot
+c03b9214 r __kstrtab_pci_get_bus_and_slot
+c03b9229 r __kstrtab_pci_get_class
+c03b9237 r __kstrtab_pci_map_rom
+c03b9243 r __kstrtab_pci_map_rom_copy
+c03b9254 r __kstrtab_pci_unmap_rom
+c03b9262 r __kstrtab_pci_remove_rom
+c03b9271 r __kstrtab_pci_claim_resource
+c03b9284 r __kstrtab_pci_proc_attach_device
+c03b929b r __kstrtab_pci_proc_detach_bus
+c03b92c0 r __kstrtab_pcie_port_service_register
+c03b92db r __kstrtab_pcie_port_service_unregister
+c03b92f8 r __kstrtab_pcie_port_bus_type
+c03b9320 r __kstrtab_pci_find_aer_capability
+c03b9340 r __kstrtab_pci_enable_pcie_error_reporting
+c03b9360 r __kstrtab_pci_disable_pcie_error_reporting
+c03b93a0 r __kstrtab_pci_cleanup_aer_uncorrect_error_status
+c03b93c7 r __kstrtab_pci_enable_msi
+c03b93d6 r __kstrtab_pci_disable_msi
+c03b93e6 r __kstrtab_pci_enable_msix
+c03b93f6 r __kstrtab_pci_disable_msix
+c03b9407 r __kstrtab___ht_create_irq
+c03b9417 r __kstrtab_ht_create_irq
+c03b9425 r __kstrtab_ht_destroy_irq
+c03b9434 r __kstrtab_pci_setup_cardbus
+c03b9446 r __kstrtab_pci_bus_size_bridges
+c03b945b r __kstrtab_pci_bus_assign_resources
+c03b9474 r __kstrtab_pci_osc_support_set
+c03b9488 r __kstrtab_pci_osc_control_set
+c03b949c r __kstrtab_fb_register_client
+c03b94af r __kstrtab_fb_unregister_client
+c03b94c4 r __kstrtab_fb_notifier_call_chain
+c03b94e0 r __kstrtab_acpi_os_printf
+c03b94ef r __kstrtab_acpi_os_map_memory
+c03b9502 r __kstrtab_acpi_os_unmap_memory
+c03b9517 r __kstrtab_acpi_os_sleep
+c03b9525 r __kstrtab_acpi_os_stall
+c03b9533 r __kstrtab_acpi_os_read_port
+c03b9545 r __kstrtab_acpi_os_write_port
+c03b9558 r __kstrtab_acpi_os_read_pci_configuration
+c03b9577 r __kstrtab_acpi_os_execute
+c03b9587 r __kstrtab_acpi_os_wait_events_complete
+c03b95a4 r __kstrtab_acpi_os_create_semaphore
+c03b95bd r __kstrtab_acpi_os_delete_semaphore
+c03b95d6 r __kstrtab_acpi_os_wait_semaphore
+c03b95ed r __kstrtab_acpi_os_signal_semaphore
+c03b9606 r __kstrtab_acpi_os_signal
+c03b9615 r __kstrtab_max_cstate
+c03b9620 r __kstrtab_acpi_do_set_cstate_limit
+c03b9639 r __kstrtab_acpi_set_cstate_limit
+c03b964f r __kstrtab_acpi_extract_package
+c03b9664 r __kstrtab_acpi_evaluate_integer
+c03b967a r __kstrtab_acpi_evaluate_reference
+c03b96a0 r __kstrtab_acpi_enable
+c03b96ac r __kstrtab_acpi_disable
+c03b96b9 r __kstrtab_acpi_enable_event
+c03b96cb r __kstrtab_acpi_set_gpe_type
+c03b96dd r __kstrtab_acpi_enable_gpe
+c03b96ed r __kstrtab_acpi_disable_gpe
+c03b96fe r __kstrtab_acpi_disable_event
+c03b9711 r __kstrtab_acpi_clear_event
+c03b9722 r __kstrtab_acpi_clear_gpe
+c03b9731 r __kstrtab_acpi_install_gpe_block
+c03b9748 r __kstrtab_acpi_remove_gpe_block
+c03b9760 r __kstrtab_acpi_install_fixed_event_handler
+c03b97a0 r __kstrtab_acpi_remove_fixed_event_handler
+c03b97c0 r __kstrtab_acpi_install_notify_handler
+c03b97dc r __kstrtab_acpi_remove_notify_handler
+c03b97f7 r __kstrtab_acpi_install_gpe_handler
+c03b9810 r __kstrtab_acpi_remove_gpe_handler
+c03b9828 r __kstrtab_acpi_acquire_global_lock
+c03b9841 r __kstrtab_acpi_release_global_lock
+c03b9860 r __kstrtab_acpi_install_address_space_handler
+c03b98a0 r __kstrtab_acpi_remove_address_space_handler
+c03b98e0 r __kstrtab_acpi_get_sleep_type_data
+c03b98f9 r __kstrtab_acpi_get_register
+c03b990b r __kstrtab_acpi_set_register
+c03b9920 r __kstrtab_acpi_set_firmware_waking_vector
+c03b9940 r __kstrtab_acpi_enter_sleep_state_prep
+c03b995c r __kstrtab_acpi_enter_sleep_state
+c03b9973 r __kstrtab_acpi_enter_sleep_state_s4bios
+c03b9991 r __kstrtab_acpi_leave_sleep_state
+c03b99a8 r __kstrtab_acpi_evaluate_object
+c03b99bd r __kstrtab_acpi_walk_namespace
+c03b99d1 r __kstrtab_acpi_get_devices
+c03b99e2 r __kstrtab_acpi_attach_data
+c03b99f3 r __kstrtab_acpi_detach_data
+c03b9a04 r __kstrtab_acpi_get_data
+c03b9a12 r __kstrtab_acpi_get_handle
+c03b9a22 r __kstrtab_acpi_get_name
+c03b9a30 r __kstrtab_acpi_get_object_info
+c03b9a45 r __kstrtab_acpi_get_id
+c03b9a51 r __kstrtab_acpi_get_type
+c03b9a5f r __kstrtab_acpi_get_parent
+c03b9a6f r __kstrtab_acpi_get_next_object
+c03b9a84 r __kstrtab_acpi_get_irq_routing_table
+c03b9a9f r __kstrtab_acpi_get_current_resources
+c03b9aba r __kstrtab_acpi_set_current_resources
+c03b9ad5 r __kstrtab_acpi_resource_to_address64
+c03b9af0 r __kstrtab_acpi_get_vendor_resource
+c03b9b09 r __kstrtab_acpi_rs_match_vendor_resource
+c03b9b27 r __kstrtab_acpi_walk_resources
+c03b9b3b r __kstrtab_acpi_load_table
+c03b9b4b r __kstrtab_acpi_get_table_header
+c03b9b61 r __kstrtab_acpi_unload_table_id
+c03b9b76 r __kstrtab_acpi_get_table
+c03b9b85 r __kstrtab_acpi_get_table_by_index
+c03b9b9d r __kstrtab_acpi_load_tables
+c03b9bae r __kstrtab_acpi_ut_exception
+c03b9bc0 r __kstrtab_acpi_enable_subsystem
+c03b9bd6 r __kstrtab_acpi_initialize_objects
+c03b9bee r __kstrtab_acpi_terminate
+c03b9bfd r __kstrtab_acpi_purge_cached_objects
+c03b9c17 r __kstrtab_acpi_gbl_FADT
+c03b9c25 r __kstrtab_acpi_format_exception
+c03b9c3b r __kstrtab_acpi_dbg_level
+c03b9c4a r __kstrtab_acpi_dbg_layer
+c03b9c59 r __kstrtab_acpi_gpe_count
+c03b9c68 r __kstrtab_acpi_root_dir
+c03b9c76 r __kstrtab_acpi_bus_get_device
+c03b9c8a r __kstrtab_acpi_bus_get_status
+c03b9c9e r __kstrtab_acpi_bus_get_power
+c03b9cb1 r __kstrtab_acpi_bus_set_power
+c03b9cc4 r __kstrtab_acpi_bus_generate_event
+c03b9cdc r __kstrtab_acpi_bus_receive_event
+c03b9cf3 r __kstrtab_register_acpi_bus_type
+c03b9d0a r __kstrtab_unregister_acpi_bus_type
+c03b9d23 r __kstrtab_acpi_get_child
+c03b9d32 r __kstrtab_acpi_get_physical_device
+c03b9d4b r __kstrtab_acpi_bus_register_driver
+c03b9d64 r __kstrtab_acpi_bus_unregister_driver
+c03b9d7f r __kstrtab_acpi_bus_get_ejd
+c03b9d90 r __kstrtab_acpi_bus_add
+c03b9d9d r __kstrtab_acpi_bus_start
+c03b9dac r __kstrtab_acpi_bus_trim
+c03b9dba r __kstrtab_ec_burst_enable
+c03b9dca r __kstrtab_ec_burst_disable
+c03b9ddb r __kstrtab_ec_read
+c03b9de3 r __kstrtab_ec_write
+c03b9dec r __kstrtab_ec_transaction
+c03b9dfb r __kstrtab_acpi_ec_add_query_handler
+c03b9e15 r __kstrtab_acpi_ec_remove_query_handler
+c03b9e32 r __kstrtab_acpi_pci_register_driver
+c03b9e4b r __kstrtab_acpi_pci_unregister_driver
+c03b9e66 r __kstrtab_acpi_get_pci_rootbridge_handle
+c03b9e85 r __kstrtab_acpi_pci_irq_enable
+c03b9e99 r __kstrtab_acpi_get_pci_id
+c03b9ea9 r __kstrtab_acpi_lock_ac_dir
+c03b9eba r __kstrtab_acpi_unlock_ac_dir
+c03b9ecd r __kstrtab_acpi_lock_battery_dir
+c03b9ee3 r __kstrtab_acpi_unlock_battery_dir
+c03b9efb r __kstrtab_pnp_platform_devices
+c03b9f10 r __kstrtab_pnp_request_card_device
+c03b9f28 r __kstrtab_pnp_release_card_device
+c03b9f40 r __kstrtab_pnp_register_card_driver
+c03b9f59 r __kstrtab_pnp_unregister_card_driver
+c03b9f74 r __kstrtab_pnp_register_driver
+c03b9f88 r __kstrtab_pnp_unregister_driver
+c03b9f9e r __kstrtab_pnp_device_attach
+c03b9fb0 r __kstrtab_pnp_device_detach
+c03b9fc2 r __kstrtab_pnp_manual_config_dev
+c03b9fd8 r __kstrtab_pnp_start_dev
+c03b9fe6 r __kstrtab_pnp_stop_dev
+c03b9ff3 r __kstrtab_pnp_activate_dev
+c03ba004 r __kstrtab_pnp_disable_dev
+c03ba014 r __kstrtab_pnp_resource_change
+c03ba028 r __kstrtab_pnp_init_resource_table
+c03ba040 r __kstrtab_pnp_is_active
+c03ba04e r __kstrtab_add_input_randomness
+c03ba063 r __kstrtab_add_disk_randomness
+c03ba077 r __kstrtab_get_random_bytes
+c03ba088 r __kstrtab_generate_random_uuid
+c03ba09d r __kstrtab_secure_tcpv6_sequence_number
+c03ba0ba r __kstrtab_tty_std_termios
+c03ba0ca r __kstrtab_tty_mutex
+c03ba0d4 r __kstrtab_tty_name
+c03ba0dd r __kstrtab_tty_buffer_request_room
+c03ba0f5 r __kstrtab_tty_insert_flip_string
+c03ba10c r __kstrtab_tty_insert_flip_string_flags
+c03ba129 r __kstrtab_tty_schedule_flip
+c03ba13b r __kstrtab_tty_prepare_flip_string
+c03ba153 r __kstrtab_tty_prepare_flip_string_flags
+c03ba171 r __kstrtab_tty_register_ldisc
+c03ba184 r __kstrtab_tty_unregister_ldisc
+c03ba199 r __kstrtab_tty_ldisc_get
+c03ba1a7 r __kstrtab_tty_ldisc_put
+c03ba1b5 r __kstrtab_tty_ldisc_ref_wait
+c03ba1c8 r __kstrtab_tty_ldisc_ref
+c03ba1d6 r __kstrtab_tty_ldisc_deref
+c03ba1e6 r __kstrtab_tty_check_change
+c03ba1f7 r __kstrtab_tty_wakeup
+c03ba202 r __kstrtab_tty_ldisc_flush
+c03ba212 r __kstrtab_tty_hangup
+c03ba21d r __kstrtab_tty_vhangup
+c03ba229 r __kstrtab_tty_hung_up_p
+c03ba237 r __kstrtab_stop_tty
+c03ba240 r __kstrtab_start_tty
+c03ba24a r __kstrtab_do_SAK
+c03ba251 r __kstrtab_tty_flip_buffer_push
+c03ba266 r __kstrtab_tty_register_device
+c03ba27a r __kstrtab_tty_unregister_device
+c03ba290 r __kstrtab_alloc_tty_driver
+c03ba2a1 r __kstrtab_put_tty_driver
+c03ba2b0 r __kstrtab_tty_set_operations
+c03ba2c3 r __kstrtab_tty_register_driver
+c03ba2d7 r __kstrtab_tty_unregister_driver
+c03ba2ed r __kstrtab_tty_devnum
+c03ba2f8 r __kstrtab_proc_clear_tty
+c03ba307 r __kstrtab_get_current_tty
+c03ba317 r __kstrtab_tty_wait_until_sent
+c03ba32b r __kstrtab_tty_termios_baud_rate
+c03ba341 r __kstrtab_tty_termios_input_baud_rate
+c03ba35d r __kstrtab_tty_termios_encode_baud_rate
+c03ba37a r __kstrtab_tty_get_baud_rate
+c03ba38c r __kstrtab_n_tty_ioctl
+c03ba398 r __kstrtab_misc_register
+c03ba3a6 r __kstrtab_misc_deregister
+c03ba3b6 r __kstrtab_con_set_default_unimap
+c03ba3cd r __kstrtab_con_copy_unimap
+c03ba3dd r __kstrtab_con_is_bound
+c03ba3ea r __kstrtab_register_con_driver
+c03ba3fe r __kstrtab_unregister_con_driver
+c03ba414 r __kstrtab_do_blank_screen
+c03ba424 r __kstrtab_do_unblank_screen
+c03ba436 r __kstrtab_color_table
+c03ba442 r __kstrtab_default_red
+c03ba44e r __kstrtab_default_grn
+c03ba45a r __kstrtab_default_blu
+c03ba466 r __kstrtab_update_region
+c03ba474 r __kstrtab_redraw_screen
+c03ba482 r __kstrtab_vc_resize
+c03ba48c r __kstrtab_vc_lock_resize
+c03ba49b r __kstrtab_fg_console
+c03ba4a6 r __kstrtab_console_blank_hook
+c03ba4b9 r __kstrtab_console_blanked
+c03ba4c9 r __kstrtab_vc_cons
+c03ba4d1 r __kstrtab_take_over_console
+c03ba4e3 r __kstrtab_give_up_console
+c03ba4f3 r __kstrtab_handle_sysrq
+c03ba500 r __kstrtab_register_sysrq_key
+c03ba513 r __kstrtab_unregister_sysrq_key
+c03ba528 r __kstrtab_rtc_register
+c03ba535 r __kstrtab_rtc_unregister
+c03ba544 r __kstrtab_rtc_control
+c03ba550 r __kstrtab_hpet_alloc
+c03ba55b r __kstrtab_hpet_register
+c03ba569 r __kstrtab_hpet_unregister
+c03ba579 r __kstrtab_hpet_control
+c03ba586 r __kstrtab_hwrng_register
+c03ba595 r __kstrtab_hwrng_unregister
+c03ba5a6 r __kstrtab_uart_update_timeout
+c03ba5ba r __kstrtab_uart_get_baud_rate
+c03ba5cd r __kstrtab_uart_get_divisor
+c03ba5de r __kstrtab_uart_console_write
+c03ba5f1 r __kstrtab_uart_match_port
+c03ba601 r __kstrtab_uart_write_wakeup
+c03ba613 r __kstrtab_uart_register_driver
+c03ba628 r __kstrtab_uart_unregister_driver
+c03ba63f r __kstrtab_uart_suspend_port
+c03ba651 r __kstrtab_uart_resume_port
+c03ba662 r __kstrtab_uart_add_one_port
+c03ba674 r __kstrtab_uart_remove_one_port
+c03ba689 r __kstrtab_serial8250_register_port
+c03ba6a2 r __kstrtab_serial8250_unregister_port
+c03ba6bd r __kstrtab_serial8250_unregister_by_port
+c03ba6db r __kstrtab_serial8250_suspend_port
+c03ba6f3 r __kstrtab_serial8250_resume_port
+c03ba70a r __kstrtab_pciserial_init_ports
+c03ba71f r __kstrtab_pciserial_remove_ports
+c03ba736 r __kstrtab_pciserial_suspend_ports
+c03ba74e r __kstrtab_pciserial_resume_ports
+c03ba780 r __kstrtab_dev_driver_string
+c03ba792 r __kstrtab_device_create_bin_file
+c03ba7a9 r __kstrtab_device_remove_bin_file
+c03ba7c0 r __kstrtab_device_schedule_callback_owner
+c03ba7df r __kstrtab_device_for_each_child
+c03ba7f5 r __kstrtab_device_find_child
+c03ba807 r __kstrtab_device_initialize
+c03ba819 r __kstrtab_device_add
+c03ba824 r __kstrtab_device_register
+c03ba834 r __kstrtab_device_del
+c03ba83f r __kstrtab_device_unregister
+c03ba851 r __kstrtab_get_device
+c03ba85c r __kstrtab_put_device
+c03ba867 r __kstrtab_device_create_file
+c03ba87a r __kstrtab_device_remove_file
+c03ba88d r __kstrtab_device_create
+c03ba89b r __kstrtab_device_destroy
+c03ba8aa r __kstrtab_device_rename
+c03ba8b8 r __kstrtab_device_move
+c03ba8c4 r __kstrtab_sysdev_create_file
+c03ba8d7 r __kstrtab_sysdev_remove_file
+c03ba8ea r __kstrtab_sysdev_class_create_file
+c03ba903 r __kstrtab_sysdev_class_remove_file
+c03ba91c r __kstrtab_sysdev_class_register
+c03ba932 r __kstrtab_sysdev_class_unregister
+c03ba94a r __kstrtab_sysdev_driver_register
+c03ba961 r __kstrtab_sysdev_driver_unregister
+c03ba97a r __kstrtab_sysdev_register
+c03ba98a r __kstrtab_sysdev_unregister
+c03ba99c r __kstrtab_device_reprobe
+c03ba9ab r __kstrtab_bus_register_notifier
+c03ba9c1 r __kstrtab_bus_unregister_notifier
+c03ba9d9 r __kstrtab_bus_for_each_dev
+c03ba9ea r __kstrtab_bus_find_device
+c03ba9fa r __kstrtab_bus_for_each_drv
+c03baa0b r __kstrtab_bus_register
+c03baa18 r __kstrtab_bus_unregister
+c03baa27 r __kstrtab_bus_rescan_devices
+c03baa3a r __kstrtab_bus_create_file
+c03baa4a r __kstrtab_bus_remove_file
+c03baa5a r __kstrtab_device_bind_driver
+c03baa6d r __kstrtab_device_release_driver
+c03baa83 r __kstrtab_device_attach
+c03baa91 r __kstrtab_driver_attach
+c03baa9f r __kstrtab_driver_for_each_device
+c03baab6 r __kstrtab_driver_find_device
+c03baac9 r __kstrtab_driver_register
+c03baad9 r __kstrtab_driver_unregister
+c03baaeb r __kstrtab_get_driver
+c03baaf6 r __kstrtab_put_driver
+c03bab01 r __kstrtab_driver_find
+c03bab0d r __kstrtab_driver_create_file
+c03bab20 r __kstrtab_driver_remove_file
+c03bab33 r __kstrtab_class_create_file
+c03bab45 r __kstrtab_class_remove_file
+c03bab57 r __kstrtab_class_register
+c03bab66 r __kstrtab_class_unregister
+c03bab77 r __kstrtab_class_create
+c03bab84 r __kstrtab_class_destroy
+c03bab92 r __kstrtab_class_device_register
+c03baba8 r __kstrtab_class_device_unregister
+c03babc0 r __kstrtab_class_device_initialize
+c03babd8 r __kstrtab_class_device_add
+c03babe9 r __kstrtab_class_device_del
+c03babfa r __kstrtab_class_device_get
+c03bac0b r __kstrtab_class_device_put
+c03bac1c r __kstrtab_class_device_create
+c03bac30 r __kstrtab_class_device_destroy
+c03bac45 r __kstrtab_class_device_create_file
+c03bac5e r __kstrtab_class_device_remove_file
+c03bac77 r __kstrtab_class_device_create_bin_file
+c03bac94 r __kstrtab_class_device_remove_bin_file
+c03bacb1 r __kstrtab_class_interface_register
+c03bacca r __kstrtab_class_interface_unregister
+c03bad00 r __kstrtab_platform_bus
+c03bad0d r __kstrtab_platform_get_resource
+c03bad23 r __kstrtab_platform_get_irq
+c03bad34 r __kstrtab_platform_get_resource_byname
+c03bad51 r __kstrtab_platform_get_irq_byname
+c03bad69 r __kstrtab_platform_add_devices
+c03bad7e r __kstrtab_platform_device_put
+c03bad92 r __kstrtab_platform_device_alloc
+c03bada8 r __kstrtab_platform_device_add_resources
+c03badc6 r __kstrtab_platform_device_add_data
+c03baddf r __kstrtab_platform_device_add
+c03badf3 r __kstrtab_platform_device_del
+c03bae07 r __kstrtab_platform_device_register
+c03bae20 r __kstrtab_platform_device_unregister
+c03bae40 r __kstrtab_platform_device_register_simple
+c03bae60 r __kstrtab_platform_driver_register
+c03bae79 r __kstrtab_platform_driver_unregister
+c03bae94 r __kstrtab_platform_driver_probe
+c03baeaa r __kstrtab_platform_bus_type
+c03baebc r __kstrtab_dma_get_required_mask
+c03baed2 r __kstrtab_cpu_sysdev_class
+c03baee3 r __kstrtab_get_cpu_sysdev
+c03baef2 r __kstrtab_firmware_register
+c03baf04 r __kstrtab_firmware_unregister
+c03baf18 r __kstrtab_devres_alloc
+c03baf25 r __kstrtab_devres_free
+c03baf31 r __kstrtab_devres_add
+c03baf3c r __kstrtab_devres_find
+c03baf48 r __kstrtab_devres_get
+c03baf53 r __kstrtab_devres_remove
+c03baf61 r __kstrtab_devres_destroy
+c03baf70 r __kstrtab_devres_open_group
+c03baf82 r __kstrtab_devres_close_group
+c03baf95 r __kstrtab_devres_remove_group
+c03bafa9 r __kstrtab_devres_release_group
+c03bafbe r __kstrtab_devm_kzalloc
+c03bafcb r __kstrtab_devm_kfree
+c03bafe0 r __kstrtab_attribute_container_classdev_to_container
+c03bb00a r __kstrtab_attribute_container_register
+c03bb027 r __kstrtab_attribute_container_unregister
+c03bb060 r __kstrtab_attribute_container_find_class_device
+c03bb0a0 r __kstrtab_transport_class_register
+c03bb0b9 r __kstrtab_transport_class_unregister
+c03bb0d4 r __kstrtab_anon_transport_class_register
+c03bb100 r __kstrtab_anon_transport_class_unregister
+c03bb120 r __kstrtab_transport_setup_device
+c03bb137 r __kstrtab_transport_add_device
+c03bb14c r __kstrtab_transport_configure_device
+c03bb167 r __kstrtab_transport_remove_device
+c03bb17f r __kstrtab_transport_destroy_device
+c03bb198 r __kstrtab_device_pm_set_parent
+c03bb1ad r __kstrtab_device_suspend
+c03bb1bc r __kstrtab_device_power_down
+c03bb1ce r __kstrtab___suspend_report_result
+c03bb1e6 r __kstrtab_device_resume
+c03bb1f4 r __kstrtab_device_power_up
+c03bb204 r __kstrtab_dpm_runtime_resume
+c03bb217 r __kstrtab_dpm_runtime_suspend
+c03bb22b r __kstrtab_dmam_alloc_coherent
+c03bb23f r __kstrtab_dmam_free_coherent
+c03bb252 r __kstrtab_dmam_alloc_noncoherent
+c03bb269 r __kstrtab_dmam_free_noncoherent
+c03bb27f r __kstrtab_dmam_declare_coherent_memory
+c03bb29c r __kstrtab_dmam_release_declared_memory
+c03bb2b9 r __kstrtab_dma_pool_create
+c03bb2c9 r __kstrtab_dma_pool_destroy
+c03bb2da r __kstrtab_dma_pool_alloc
+c03bb2e9 r __kstrtab_dma_pool_free
+c03bb2f7 r __kstrtab_dmam_pool_create
+c03bb308 r __kstrtab_dmam_pool_destroy
+c03bb31a r __kstrtab_release_firmware
+c03bb32b r __kstrtab_request_firmware
+c03bb33c r __kstrtab_request_firmware_nowait
+c03bb354 r __kstrtab_noautodma
+c03bb35e r __kstrtab_ide_hwifs
+c03bb368 r __kstrtab_ide_unregister
+c03bb377 r __kstrtab_ide_register_hw_with_fixup
+c03bb392 r __kstrtab_ide_register_hw
+c03bb3a2 r __kstrtab_ide_setting_sem
+c03bb3b2 r __kstrtab_ide_spin_wait_hwgroup
+c03bb3c8 r __kstrtab_system_bus_clock
+c03bb3d9 r __kstrtab_generic_ide_ioctl
+c03bb3eb r __kstrtab_ide_lock
+c03bb3f4 r __kstrtab_ide_bus_type
+c03bb401 r __kstrtab_ide_end_request
+c03bb411 r __kstrtab_ide_end_dequeued_request
+c03bb42a r __kstrtab_ide_get_error_location
+c03bb441 r __kstrtab_ide_end_drive_cmd
+c03bb453 r __kstrtab___ide_error
+c03bb45f r __kstrtab_ide_error
+c03bb469 r __kstrtab___ide_abort
+c03bb475 r __kstrtab_ide_map_sg
+c03bb480 r __kstrtab_ide_init_sg_cmd
+c03bb490 r __kstrtab_ide_stall_queue
+c03bb4a0 r __kstrtab_ide_init_drive_cmd
+c03bb4b3 r __kstrtab_ide_do_drive_cmd
+c03bb4c4 r __kstrtab_default_hwif_mmiops
+c03bb4d8 r __kstrtab_SELECT_DRIVE
+c03bb4e5 r __kstrtab_ide_fix_driveid
+c03bb4f5 r __kstrtab_ide_fixstring
+c03bb503 r __kstrtab_drive_is_ready
+c03bb512 r __kstrtab_ide_wait_stat
+c03bb520 r __kstrtab_ide_config_drive_speed
+c03bb537 r __kstrtab_ide_set_handler
+c03bb547 r __kstrtab_ide_execute_command
+c03bb55b r __kstrtab_ide_do_reset
+c03bb568 r __kstrtab_ide_wait_not_busy
+c03bb57a r __kstrtab_ide_xfer_verbose
+c03bb58b r __kstrtab_ide_rate_filter
+c03bb59b r __kstrtab_ide_use_fast_pio
+c03bb5ac r __kstrtab_ide_pio_timings
+c03bb5bc r __kstrtab_ide_get_best_pio_mode
+c03bb5d2 r __kstrtab_ide_dump_status
+c03bb5e2 r __kstrtab_ide_undecoded_slave
+c03bb5f6 r __kstrtab_probe_hwif_init
+c03bb606 r __kstrtab_ide_register_region
+c03bb61a r __kstrtab_ide_unregister_region
+c03bb630 r __kstrtab_ide_init_disk
+c03bb63e r __kstrtab_ideprobe_init
+c03bb64c r __kstrtab_task_no_data_intr
+c03bb65e r __kstrtab_task_in_intr
+c03bb66b r __kstrtab_pre_task_out_intr
+c03bb67d r __kstrtab_ide_raw_taskfile
+c03bb68e r __kstrtab_ide_setup_pci_noise
+c03bb6a2 r __kstrtab_ide_pci_setup_ports
+c03bb6b6 r __kstrtab_ide_setup_pci_device
+c03bb6cb r __kstrtab_ide_setup_pci_devices
+c03bb6e1 r __kstrtab___ide_pci_register_driver
+c03bb6fb r __kstrtab_ide_dma_intr
+c03bb708 r __kstrtab_ide_build_sglist
+c03bb719 r __kstrtab_ide_build_dmatable
+c03bb72c r __kstrtab_ide_destroy_dmatable
+c03bb741 r __kstrtab_ide_dma_host_off
+c03bb752 r __kstrtab_ide_dma_off_quietly
+c03bb766 r __kstrtab_ide_dma_off
+c03bb772 r __kstrtab_ide_dma_host_on
+c03bb782 r __kstrtab___ide_dma_on
+c03bb78f r __kstrtab___ide_dma_check
+c03bb79f r __kstrtab_ide_dma_setup
+c03bb7ad r __kstrtab_ide_dma_start
+c03bb7bb r __kstrtab___ide_dma_end
+c03bb7c9 r __kstrtab___ide_dma_bad_drive
+c03bb7dd r __kstrtab___ide_dma_good_drive
+c03bb7f2 r __kstrtab_ide_max_dma_mode
+c03bb803 r __kstrtab_ide_tune_dma
+c03bb810 r __kstrtab_ide_dma_verbose
+c03bb820 r __kstrtab_ide_set_dma
+c03bb82c r __kstrtab___ide_dma_lostirq
+c03bb83e r __kstrtab___ide_dma_timeout
+c03bb850 r __kstrtab_ide_setup_dma
+c03bb85e r __kstrtab_cdrom_get_last_written
+c03bb875 r __kstrtab_register_cdrom
+c03bb884 r __kstrtab_unregister_cdrom
+c03bb895 r __kstrtab_cdrom_open
+c03bb8a0 r __kstrtab_cdrom_release
+c03bb8ae r __kstrtab_cdrom_ioctl
+c03bb8ba r __kstrtab_cdrom_media_changed
+c03bb8ce r __kstrtab_cdrom_number_of_slots
+c03bb8e4 r __kstrtab_cdrom_mode_select
+c03bb8f6 r __kstrtab_cdrom_mode_sense
+c03bb907 r __kstrtab_init_cdrom_command
+c03bb91a r __kstrtab_cdrom_get_media_event
+c03bb930 r __kstrtab_usb_disabled
+c03bb93d r __kstrtab_usb_get_intf
+c03bb94a r __kstrtab_usb_put_intf
+c03bb957 r __kstrtab_usb_put_dev
+c03bb963 r __kstrtab_usb_get_dev
+c03bb96f r __kstrtab_usb_hub_tt_clear_buffer
+c03bb987 r __kstrtab_usb_lock_device_for_reset
+c03bb9a1 r __kstrtab_usb_find_interface
+c03bb9b4 r __kstrtab_usb_ifnum_to_if
+c03bb9c4 r __kstrtab_usb_altnum_to_altsetting
+c03bb9dd r __kstrtab___usb_get_extra_descriptor
+c03bb9f8 r __kstrtab_usb_find_device
+c03bba08 r __kstrtab_usb_get_current_frame_number
+c03bba25 r __kstrtab_usb_buffer_alloc
+c03bba36 r __kstrtab_usb_buffer_free
+c03bba46 r __kstrtab_usb_buffer_map_sg
+c03bba58 r __kstrtab_usb_buffer_unmap_sg
+c03bba6c r __kstrtab_ehci_cf_port_reset_rwsem
+c03bba85 r __kstrtab_usb_root_hub_lost_power
+c03bba9d r __kstrtab_usb_reset_device
+c03bbaae r __kstrtab_usb_reset_composite_device
+c03bbac9 r __kstrtab_usb_bus_list
+c03bbad6 r __kstrtab_usb_bus_list_lock
+c03bbae8 r __kstrtab_usb_hcd_poll_rh_status
+c03bbaff r __kstrtab_usb_calc_bus_time
+c03bbb11 r __kstrtab_usb_hcd_resume_root_hub
+c03bbb29 r __kstrtab_usb_hcd_giveback_urb
+c03bbb3e r __kstrtab_usb_hc_died
+c03bbb4a r __kstrtab_usb_create_hcd
+c03bbb59 r __kstrtab_usb_get_hcd
+c03bbb65 r __kstrtab_usb_put_hcd
+c03bbb71 r __kstrtab_usb_add_hcd
+c03bbb7d r __kstrtab_usb_remove_hcd
+c03bbb8c r __kstrtab_usb_hcd_platform_shutdown
+c03bbba6 r __kstrtab_usb_init_urb
+c03bbbb3 r __kstrtab_usb_alloc_urb
+c03bbbc1 r __kstrtab_usb_free_urb
+c03bbbce r __kstrtab_usb_get_urb
+c03bbbda r __kstrtab_usb_submit_urb
+c03bbbe9 r __kstrtab_usb_unlink_urb
+c03bbbf8 r __kstrtab_usb_kill_urb
+c03bbc05 r __kstrtab_usb_interrupt_msg
+c03bbc17 r __kstrtab_usb_driver_set_configuration
+c03bbc34 r __kstrtab_usb_control_msg
+c03bbc44 r __kstrtab_usb_bulk_msg
+c03bbc51 r __kstrtab_usb_sg_init
+c03bbc5d r __kstrtab_usb_sg_cancel
+c03bbc6b r __kstrtab_usb_sg_wait
+c03bbc77 r __kstrtab_usb_get_descriptor
+c03bbc8a r __kstrtab_usb_get_status
+c03bbc99 r __kstrtab_usb_string
+c03bbca4 r __kstrtab_usb_clear_halt
+c03bbcb3 r __kstrtab_usb_reset_configuration
+c03bbccb r __kstrtab_usb_set_interface
+c03bbcdd r __kstrtab_usb_store_new_id
+c03bbcee r __kstrtab_usb_driver_claim_interface
+c03bbd09 r __kstrtab_usb_driver_release_interface
+c03bbd26 r __kstrtab_usb_match_one_id
+c03bbd37 r __kstrtab_usb_match_id
+c03bbd44 r __kstrtab_usb_register_device_driver
+c03bbd5f r __kstrtab_usb_deregister_device_driver
+c03bbd7c r __kstrtab_usb_register_driver
+c03bbd90 r __kstrtab_usb_deregister
+c03bbd9f r __kstrtab_usb_register_dev
+c03bbdb0 r __kstrtab_usb_deregister_dev
+c03bbdc3 r __kstrtab_usb_register_notify
+c03bbdd7 r __kstrtab_usb_unregister_notify
+c03bbded r __kstrtab_usb_hcd_pci_probe
+c03bbdff r __kstrtab_usb_hcd_pci_remove
+c03bbe12 r __kstrtab_usb_hcd_pci_suspend
+c03bbe26 r __kstrtab_usb_hcd_pci_resume
+c03bbe39 r __kstrtab_usb_hcd_pci_shutdown
+c03bbe4e r __kstrtab_uhci_reset_hc
+c03bbe5c r __kstrtab_uhci_check_and_reset_hc
+c03bbe74 r __kstrtab_storage_usb_ids
+c03bbe84 r __kstrtab_usb_usual_set_present
+c03bbe9a r __kstrtab_usb_usual_clear_present
+c03bbeb2 r __kstrtab_usb_usual_check_type
+c03bbec7 r __kstrtab_serio_interrupt
+c03bbed7 r __kstrtab___serio_register_port
+c03bbeed r __kstrtab_serio_unregister_port
+c03bbf03 r __kstrtab_serio_unregister_child_port
+c03bbf1f r __kstrtab___serio_register_driver
+c03bbf37 r __kstrtab_serio_unregister_driver
+c03bbf4f r __kstrtab_serio_open
+c03bbf5a r __kstrtab_serio_close
+c03bbf66 r __kstrtab_serio_rescan
+c03bbf73 r __kstrtab_serio_reconnect
+c03bbf83 r __kstrtab_ps2_sendbyte
+c03bbf90 r __kstrtab_ps2_drain
+c03bbf9a r __kstrtab_ps2_is_keyboard_id
+c03bbfad r __kstrtab_ps2_command
+c03bbfb9 r __kstrtab_ps2_schedule_command
+c03bbfce r __kstrtab_ps2_init
+c03bbfd7 r __kstrtab_ps2_handle_ack
+c03bbfe6 r __kstrtab_ps2_handle_response
+c03bbffa r __kstrtab_ps2_cmd_aborted
+c03bc00a r __kstrtab_input_event
+c03bc016 r __kstrtab_input_inject_event
+c03bc029 r __kstrtab_input_grab_device
+c03bc03b r __kstrtab_input_release_device
+c03bc050 r __kstrtab_input_open_device
+c03bc062 r __kstrtab_input_flush_device
+c03bc075 r __kstrtab_input_close_device
+c03bc088 r __kstrtab_input_class
+c03bc094 r __kstrtab_input_allocate_device
+c03bc0aa r __kstrtab_input_free_device
+c03bc0bc r __kstrtab_input_set_capability
+c03bc0d1 r __kstrtab_input_register_device
+c03bc0e7 r __kstrtab_input_unregister_device
+c03bc0ff r __kstrtab_input_register_handler
+c03bc116 r __kstrtab_input_unregister_handler
+c03bc12f r __kstrtab_input_register_handle
+c03bc145 r __kstrtab_input_unregister_handle
+c03bc15d r __kstrtab_input_ff_upload
+c03bc16d r __kstrtab_input_ff_erase
+c03bc17c r __kstrtab_input_ff_event
+c03bc18b r __kstrtab_input_ff_create
+c03bc19b r __kstrtab_input_ff_destroy
+c03bc1ac r __kstrtab___i2c_board_lock
+c03bc1bd r __kstrtab___i2c_board_list
+c03bc1ce r __kstrtab___i2c_first_dynamic_bus_num
+c03bc1ea r __kstrtab_md_new_event
+c03bc1f7 r __kstrtab_sync_page_io
+c03bc204 r __kstrtab_md_allow_write
+c03bc213 r __kstrtab_md_do_sync
+c03bc21e r __kstrtab_register_md_personality
+c03bc236 r __kstrtab_unregister_md_personality
+c03bc250 r __kstrtab_md_error
+c03bc259 r __kstrtab_md_done_sync
+c03bc266 r __kstrtab_md_write_start
+c03bc275 r __kstrtab_md_write_end
+c03bc282 r __kstrtab_md_register_thread
+c03bc295 r __kstrtab_md_unregister_thread
+c03bc2aa r __kstrtab_md_wakeup_thread
+c03bc2bb r __kstrtab_md_check_recovery
+c03bc2cd r __kstrtab_bitmap_startwrite
+c03bc2df r __kstrtab_bitmap_endwrite
+c03bc2ef r __kstrtab_bitmap_start_sync
+c03bc301 r __kstrtab_bitmap_end_sync
+c03bc311 r __kstrtab_bitmap_unplug
+c03bc31f r __kstrtab_bitmap_close_sync
+c03bc331 r __kstrtab_dm_device_name
+c03bc340 r __kstrtab_dm_put
+c03bc347 r __kstrtab_dm_noflush_suspending
+c03bc35d r __kstrtab_dm_get_mapinfo
+c03bc36c r __kstrtab_dm_create_error_table
+c03bc382 r __kstrtab_dm_set_device_limits
+c03bc397 r __kstrtab_dm_vcalloc
+c03bc3a2 r __kstrtab_dm_get_device
+c03bc3b0 r __kstrtab_dm_put_device
+c03bc3be r __kstrtab_dm_table_event
+c03bc3cd r __kstrtab_dm_table_get_size
+c03bc3df r __kstrtab_dm_table_get_mode
+c03bc3f1 r __kstrtab_dm_table_get_md
+c03bc401 r __kstrtab_dm_table_put
+c03bc40e r __kstrtab_dm_table_get
+c03bc41b r __kstrtab_dm_table_unplug_all
+c03bc42f r __kstrtab_dm_table_flush_all
+c03bc442 r __kstrtab_dm_register_target
+c03bc455 r __kstrtab_dm_unregister_target
+c03bc46a r __kstrtab_dm_io_client_create
+c03bc47e r __kstrtab_dm_io_client_resize
+c03bc492 r __kstrtab_dm_io_client_destroy
+c03bc4a7 r __kstrtab_dm_io
+c03bc4ad r __kstrtab_kcopyd_client_create
+c03bc4c2 r __kstrtab_kcopyd_client_destroy
+c03bc4d8 r __kstrtab_kcopyd_copy
+c03bc4e4 r __kstrtab_dmi_check_system
+c03bc4f5 r __kstrtab_dmi_get_system_info
+c03bc509 r __kstrtab_dmi_name_in_vendors
+c03bc51d r __kstrtab_dmi_find_device
+c03bc52d r __kstrtab_dma_sync_wait
+c03bc53b r __kstrtab_dma_chan_cleanup
+c03bc54c r __kstrtab_dma_async_client_register
+c03bc566 r __kstrtab_dma_async_client_unregister
+c03bc582 r __kstrtab_dma_async_client_chan_request
+c03bc5a0 r __kstrtab_dma_async_device_register
+c03bc5ba r __kstrtab_dma_async_device_unregister
+c03bc5d6 r __kstrtab_dma_async_memcpy_buf_to_buf
+c03bc5f2 r __kstrtab_dma_async_memcpy_buf_to_pg
+c03bc60d r __kstrtab_dma_async_memcpy_pg_to_pg
+c03bc627 r __kstrtab_dma_async_tx_descriptor_init
+c03bc644 r __kstrtab_hid_free_device
+c03bc654 r __kstrtab_hid_parse_report
+c03bc665 r __kstrtab_hid_input_field
+c03bc675 r __kstrtab_hid_output_report
+c03bc687 r __kstrtab_hid_set_field
+c03bc695 r __kstrtab_hid_input_report
+c03bc6a6 r __kstrtab_hidinput_report_event
+c03bc6bc r __kstrtab_hidinput_find_field
+c03bc6d0 r __kstrtab_hidinput_connect
+c03bc6e1 r __kstrtab_hidinput_disconnect
+c03bc6f5 r __kstrtab_pcibios_get_irq_routing_table
+c03bc713 r __kstrtab_pcibios_set_irq_routing
+c03bc72b r __kstrtab_save_processor_state
+c03bc740 r __kstrtab_restore_processor_state
+c03bc760 r __kstrtab___sock_recv_timestamp
+c03bc776 r __kstrtab_brioctl_set
+c03bc782 r __kstrtab_vlan_ioctl_set
+c03bc791 r __kstrtab_dlci_ioctl_set
+c03bc7a0 r __kstrtab_move_addr_to_kernel
+c03bc7b4 r __kstrtab_move_addr_to_user
+c03bc7c6 r __kstrtab_sock_create
+c03bc7d2 r __kstrtab_sock_create_kern
+c03bc7e3 r __kstrtab_sock_create_lite
+c03bc7f4 r __kstrtab_sock_map_fd
+c03bc800 r __kstrtab_sock_recvmsg
+c03bc80d r __kstrtab_sock_register
+c03bc81b r __kstrtab_sock_release
+c03bc828 r __kstrtab_sock_sendmsg
+c03bc835 r __kstrtab_sock_unregister
+c03bc845 r __kstrtab_sock_wake_async
+c03bc855 r __kstrtab_sockfd_lookup
+c03bc863 r __kstrtab_kernel_sendmsg
+c03bc872 r __kstrtab_kernel_recvmsg
+c03bc881 r __kstrtab_kernel_bind
+c03bc88d r __kstrtab_kernel_listen
+c03bc89b r __kstrtab_kernel_accept
+c03bc8a9 r __kstrtab_kernel_connect
+c03bc8b8 r __kstrtab_kernel_getsockname
+c03bc8cb r __kstrtab_kernel_getpeername
+c03bc8de r __kstrtab_kernel_getsockopt
+c03bc8f0 r __kstrtab_kernel_setsockopt
+c03bc902 r __kstrtab_kernel_sendpage
+c03bc912 r __kstrtab_kernel_sock_ioctl
+c03bc940 r __kstrtab_sock_queue_rcv_skb
+c03bc953 r __kstrtab_sk_receive_skb
+c03bc962 r __kstrtab___sk_dst_check
+c03bc971 r __kstrtab_sk_dst_check
+c03bc97e r __kstrtab_sk_clone
+c03bc987 r __kstrtab_sk_setup_caps
+c03bc995 r __kstrtab_sk_wait_data
+c03bc9a2 r __kstrtab_sk_reset_timer
+c03bc9b1 r __kstrtab_sk_stop_timer
+c03bc9bf r __kstrtab_lock_sock_nested
+c03bc9d0 r __kstrtab_release_sock
+c03bc9dd r __kstrtab_sock_get_timestamp
+c03bc9f0 r __kstrtab_sock_get_timestampns
+c03bca05 r __kstrtab_sock_enable_timestamp
+c03bca1b r __kstrtab_sock_common_getsockopt
+c03bca32 r __kstrtab_sock_common_recvmsg
+c03bca46 r __kstrtab_sock_common_setsockopt
+c03bca5d r __kstrtab_sk_common_release
+c03bca6f r __kstrtab_proto_register
+c03bca7e r __kstrtab_proto_unregister
+c03bca8f r __kstrtab_sk_alloc
+c03bca98 r __kstrtab_sk_free
+c03bcaa0 r __kstrtab_sk_send_sigurg
+c03bcaaf r __kstrtab_sock_alloc_send_skb
+c03bcac3 r __kstrtab_sock_init_data
+c03bcad2 r __kstrtab_sock_kfree_s
+c03bcadf r __kstrtab_sock_kmalloc
+c03bcaec r __kstrtab_sock_no_accept
+c03bcafb r __kstrtab_sock_no_bind
+c03bcb08 r __kstrtab_sock_no_connect
+c03bcb18 r __kstrtab_sock_no_getname
+c03bcb28 r __kstrtab_sock_no_getsockopt
+c03bcb3b r __kstrtab_sock_no_ioctl
+c03bcb49 r __kstrtab_sock_no_listen
+c03bcb58 r __kstrtab_sock_no_mmap
+c03bcb65 r __kstrtab_sock_no_poll
+c03bcb72 r __kstrtab_sock_no_recvmsg
+c03bcb82 r __kstrtab_sock_no_sendmsg
+c03bcb92 r __kstrtab_sock_no_sendpage
+c03bcba3 r __kstrtab_sock_no_setsockopt
+c03bcbb6 r __kstrtab_sock_no_shutdown
+c03bcbc7 r __kstrtab_sock_no_socketpair
+c03bcbda r __kstrtab_sock_rfree
+c03bcbe5 r __kstrtab_sock_setsockopt
+c03bcbf5 r __kstrtab_sock_wfree
+c03bcc00 r __kstrtab_sock_wmalloc
+c03bcc0d r __kstrtab_sock_i_uid
+c03bcc18 r __kstrtab_sock_i_ino
+c03bcc23 r __kstrtab_sysctl_optmem_max
+c03bcc35 r __kstrtab_sysctl_rmem_max
+c03bcc45 r __kstrtab_sysctl_wmem_max
+c03bcc55 r __kstrtab_reqsk_queue_alloc
+c03bcc67 r __kstrtab_reqsk_queue_destroy
+c03bcc7b r __kstrtab_skb_truesize_bug
+c03bcc8c r __kstrtab_skb_store_bits
+c03bcc9b r __kstrtab_skb_pull_rcsum
+c03bccaa r __kstrtab_skb_segment
+c03bccb6 r __kstrtab____pskb_trim
+c03bccc3 r __kstrtab___kfree_skb
+c03bcccf r __kstrtab_kfree_skb
+c03bccd9 r __kstrtab___pskb_pull_tail
+c03bccea r __kstrtab___alloc_skb
+c03bccf6 r __kstrtab___netdev_alloc_skb
+c03bcd09 r __kstrtab_pskb_copy
+c03bcd13 r __kstrtab_pskb_expand_head
+c03bcd24 r __kstrtab_skb_checksum
+c03bcd31 r __kstrtab_skb_clone
+c03bcd3b r __kstrtab_skb_copy
+c03bcd44 r __kstrtab_skb_copy_and_csum_bits
+c03bcd5b r __kstrtab_skb_copy_and_csum_dev
+c03bcd71 r __kstrtab_skb_copy_bits
+c03bcd7f r __kstrtab_skb_copy_expand
+c03bcd8f r __kstrtab_skb_over_panic
+c03bcd9e r __kstrtab_skb_pad
+c03bcda6 r __kstrtab_skb_realloc_headroom
+c03bcdbb r __kstrtab_skb_under_panic
+c03bcdcb r __kstrtab_skb_dequeue
+c03bcdd7 r __kstrtab_skb_dequeue_tail
+c03bcde8 r __kstrtab_skb_insert
+c03bcdf3 r __kstrtab_skb_queue_purge
+c03bce03 r __kstrtab_skb_queue_head
+c03bce12 r __kstrtab_skb_queue_tail
+c03bce21 r __kstrtab_skb_unlink
+c03bce2c r __kstrtab_skb_append
+c03bce37 r __kstrtab_skb_split
+c03bce41 r __kstrtab_skb_prepare_seq_read
+c03bce56 r __kstrtab_skb_seq_read
+c03bce63 r __kstrtab_skb_abort_seq_read
+c03bce76 r __kstrtab_skb_find_text
+c03bce84 r __kstrtab_skb_append_datato_frags
+c03bce9c r __kstrtab_skb_to_sgvec
+c03bcea9 r __kstrtab_skb_cow_data
+c03bceb6 r __kstrtab_csum_partial_copy_fromiovecend
+c03bced5 r __kstrtab_memcpy_fromiovec
+c03bcee6 r __kstrtab_memcpy_fromiovecend
+c03bcefa r __kstrtab_memcpy_toiovec
+c03bcf20 r __kstrtab_skb_kill_datagram
+c03bcf32 r __kstrtab___skb_checksum_complete_head
+c03bcf4f r __kstrtab___skb_checksum_complete
+c03bcf67 r __kstrtab_datagram_poll
+c03bcf80 r __kstrtab_skb_copy_and_csum_datagram_iovec
+c03bcfa1 r __kstrtab_skb_copy_datagram_iovec
+c03bcfb9 r __kstrtab_skb_free_datagram
+c03bcfcb r __kstrtab_skb_recv_datagram
+c03bcfdd r __kstrtab_sk_stream_write_space
+c03bcff3 r __kstrtab_sk_stream_wait_connect
+c03bd00a r __kstrtab_sk_stream_wait_close
+c03bd01f r __kstrtab_sk_stream_wait_memory
+c03bd035 r __kstrtab_sk_stream_rfree
+c03bd045 r __kstrtab_sk_stream_error
+c03bd055 r __kstrtab___sk_stream_mem_reclaim
+c03bd06d r __kstrtab_sk_stream_mem_schedule
+c03bd084 r __kstrtab_sk_stream_kill_queues
+c03bd09a r __kstrtab___scm_destroy
+c03bd0a8 r __kstrtab___scm_send
+c03bd0b3 r __kstrtab_put_cmsg
+c03bd0bc r __kstrtab_scm_detach_fds
+c03bd0cb r __kstrtab_scm_fp_dup
+c03bd0d6 r __kstrtab_gnet_stats_start_copy
+c03bd0ec r __kstrtab_gnet_stats_start_copy_compat
+c03bd109 r __kstrtab_gnet_stats_copy_basic
+c03bd11f r __kstrtab_gnet_stats_copy_rate_est
+c03bd138 r __kstrtab_gnet_stats_copy_queue
+c03bd14e r __kstrtab_gnet_stats_copy_app
+c03bd162 r __kstrtab_gnet_stats_finish_copy
+c03bd179 r __kstrtab_gen_kill_estimator
+c03bd18c r __kstrtab_gen_new_estimator
+c03bd19e r __kstrtab_gen_replace_estimator
+c03bd1b4 r __kstrtab_init_net
+c03bd1bd r __kstrtab___put_net
+c03bd1c7 r __kstrtab_register_pernet_subsys
+c03bd1de r __kstrtab_unregister_pernet_subsys
+c03bd1f7 r __kstrtab_register_pernet_device
+c03bd20e r __kstrtab_unregister_pernet_device
+c03bd227 r __kstrtab_dev_base_lock
+c03bd235 r __kstrtab_dev_getbyhwaddr
+c03bd245 r __kstrtab___dev_getfirstbyhwtype
+c03bd25c r __kstrtab_dev_getfirstbyhwtype
+c03bd271 r __kstrtab_netdev_features_change
+c03bd288 r __kstrtab___netif_schedule
+c03bd299 r __kstrtab___netif_rx_schedule
+c03bd2ad r __kstrtab_dev_kfree_skb_any
+c03bd2bf r __kstrtab_netif_device_detach
+c03bd2d3 r __kstrtab_netif_device_attach
+c03bd2e7 r __kstrtab_skb_gso_segment
+c03bd2f7 r __kstrtab_netdev_rx_csum_fault
+c03bd30c r __kstrtab_netif_rx_ni
+c03bd318 r __kstrtab_register_netdev
+c03bd328 r __kstrtab_alloc_netdev
+c03bd335 r __kstrtab_unregister_netdev
+c03bd347 r __kstrtab_netdev_compute_features
+c03bd35f r __kstrtab___dev_get_by_index
+c03bd372 r __kstrtab___dev_get_by_name
+c03bd384 r __kstrtab___dev_remove_pack
+c03bd396 r __kstrtab_dev_valid_name
+c03bd3a5 r __kstrtab_dev_add_pack
+c03bd3b2 r __kstrtab_dev_alloc_name
+c03bd3c1 r __kstrtab_dev_close
+c03bd3cb r __kstrtab_dev_get_by_flags
+c03bd3dc r __kstrtab_dev_get_by_index
+c03bd3ed r __kstrtab_dev_get_by_name
+c03bd3fd r __kstrtab_dev_open
+c03bd406 r __kstrtab_dev_queue_xmit
+c03bd415 r __kstrtab_dev_remove_pack
+c03bd425 r __kstrtab_dev_set_allmulti
+c03bd436 r __kstrtab_dev_set_promiscuity
+c03bd44a r __kstrtab_dev_change_flags
+c03bd45b r __kstrtab_dev_set_mtu
+c03bd467 r __kstrtab_dev_set_mac_address
+c03bd47b r __kstrtab_free_netdev
+c03bd487 r __kstrtab_netdev_boot_setup_check
+c03bd49f r __kstrtab_netdev_set_master
+c03bd4b1 r __kstrtab_netdev_state_change
+c03bd4c5 r __kstrtab_netif_receive_skb
+c03bd4d7 r __kstrtab_netif_rx
+c03bd4e0 r __kstrtab_register_gifconf
+c03bd4f1 r __kstrtab_register_netdevice
+c03bd504 r __kstrtab_register_netdevice_notifier
+c03bd520 r __kstrtab_skb_checksum_help
+c03bd532 r __kstrtab_synchronize_net
+c03bd542 r __kstrtab_unregister_netdevice
+c03bd557 r __kstrtab_unregister_netdevice_notifier
+c03bd575 r __kstrtab_net_enable_timestamp
+c03bd58a r __kstrtab_net_disable_timestamp
+c03bd5a0 r __kstrtab_dev_get_flags
+c03bd5ae r __kstrtab_dev_load
+c03bd5b7 r __kstrtab_per_cpu__softnet_data
+c03bd5cd r __kstrtab_dev_ethtool
+c03bd5d9 r __kstrtab_ethtool_op_get_link
+c03bd5ed r __kstrtab_ethtool_op_get_perm_addr
+c03bd606 r __kstrtab_ethtool_op_get_sg
+c03bd618 r __kstrtab_ethtool_op_get_tso
+c03bd62b r __kstrtab_ethtool_op_get_tx_csum
+c03bd642 r __kstrtab_ethtool_op_set_sg
+c03bd654 r __kstrtab_ethtool_op_set_tso
+c03bd667 r __kstrtab_ethtool_op_set_tx_csum
+c03bd67e r __kstrtab_ethtool_op_set_tx_hw_csum
+c03bd698 r __kstrtab_ethtool_op_set_ufo
+c03bd6ab r __kstrtab_ethtool_op_get_ufo
+c03bd6be r __kstrtab_dev_mc_add
+c03bd6c9 r __kstrtab_dev_mc_delete
+c03bd6d7 r __kstrtab_dev_mc_upload
+c03bd6e5 r __kstrtab___dst_free
+c03bd6f0 r __kstrtab_dst_alloc
+c03bd6fa r __kstrtab_dst_destroy
+c03bd706 r __kstrtab_register_netevent_notifier
+c03bd721 r __kstrtab_unregister_netevent_notifier
+c03bd73e r __kstrtab_call_netevent_notifiers
+c03bd756 r __kstrtab_neigh_for_each
+c03bd765 r __kstrtab___neigh_for_each_release
+c03bd77e r __kstrtab_neigh_seq_start
+c03bd78e r __kstrtab_neigh_seq_next
+c03bd79d r __kstrtab_neigh_seq_stop
+c03bd7ac r __kstrtab___neigh_event_send
+c03bd7bf r __kstrtab_neigh_changeaddr
+c03bd7d0 r __kstrtab_neigh_compat_output
+c03bd7e4 r __kstrtab_neigh_connected_output
+c03bd7fb r __kstrtab_neigh_create
+c03bd808 r __kstrtab_neigh_destroy
+c03bd816 r __kstrtab_neigh_event_ns
+c03bd825 r __kstrtab_neigh_ifdown
+c03bd832 r __kstrtab_neigh_lookup
+c03bd83f r __kstrtab_neigh_lookup_nodev
+c03bd852 r __kstrtab_neigh_parms_alloc
+c03bd864 r __kstrtab_neigh_parms_alloc_default
+c03bd87e r __kstrtab_neigh_parms_release
+c03bd892 r __kstrtab_neigh_rand_reach_time
+c03bd8a8 r __kstrtab_neigh_resolve_output
+c03bd8bd r __kstrtab_neigh_table_clear
+c03bd8cf r __kstrtab_neigh_table_init
+c03bd8e0 r __kstrtab_neigh_table_init_no_netlink
+c03bd8fc r __kstrtab_neigh_update
+c03bd909 r __kstrtab_pneigh_enqueue
+c03bd918 r __kstrtab_pneigh_lookup
+c03bd926 r __kstrtab_neigh_sysctl_register
+c03bd93c r __kstrtab_neigh_sysctl_unregister
+c03bd954 r __kstrtab___rtnl_register
+c03bd964 r __kstrtab_rtnl_register
+c03bd972 r __kstrtab_rtnl_unregister
+c03bd982 r __kstrtab_rtnl_unregister_all
+c03bd996 r __kstrtab___rtnl_link_register
+c03bd9ab r __kstrtab_rtnl_link_register
+c03bd9be r __kstrtab___rtnl_link_unregister
+c03bd9d5 r __kstrtab_rtnl_link_unregister
+c03bd9ea r __kstrtab_rtnl_put_cacheinfo
+c03bd9fd r __kstrtab___rta_fill
+c03bda08 r __kstrtab_rtattr_strlcpy
+c03bda17 r __kstrtab_rtattr_parse
+c03bda24 r __kstrtab___rtattr_parse_nested_compat
+c03bda41 r __kstrtab_rtnetlink_put_metrics
+c03bda57 r __kstrtab_rtnl_lock
+c03bda61 r __kstrtab_rtnl_trylock
+c03bda6e r __kstrtab_rtnl_unlock
+c03bda7a r __kstrtab_rtnl_unicast
+c03bda87 r __kstrtab_rtnl_notify
+c03bda93 r __kstrtab_rtnl_set_sk_err
+c03bdaa3 r __kstrtab_net_msg_warn
+c03bdab0 r __kstrtab_net_ratelimit
+c03bdabe r __kstrtab_in_aton
+c03bdac6 r __kstrtab_in4_pton
+c03bdacf r __kstrtab_in6_pton
+c03bdad8 r __kstrtab_linkwatch_fire_event
+c03bdaed r __kstrtab_sk_chk_filter
+c03bdafb r __kstrtab_sk_run_filter
+c03bdb09 r __kstrtab_flow_cache_genid
+c03bdb1a r __kstrtab_flow_cache_lookup
+c03bdb2c r __kstrtab_fib_rules_register
+c03bdb3f r __kstrtab_fib_rules_unregister
+c03bdb54 r __kstrtab_fib_rules_lookup
+c03bdb65 r __kstrtab_eth_type_trans
+c03bdb74 r __kstrtab_ether_setup
+c03bdb80 r __kstrtab_alloc_etherdev
+c03bdb8f r __kstrtab_netif_carrier_on
+c03bdba0 r __kstrtab_netif_carrier_off
+c03bdbb2 r __kstrtab_noop_qdisc
+c03bdbbd r __kstrtab_qdisc_create_dflt
+c03bdbcf r __kstrtab_qdisc_destroy
+c03bdbdd r __kstrtab_qdisc_reset
+c03bdbe9 r __kstrtab_qdisc_lock_tree
+c03bdbf9 r __kstrtab_qdisc_unlock_tree
+c03bdc0b r __kstrtab_qdisc_watchdog_init
+c03bdc1f r __kstrtab_qdisc_watchdog_schedule
+c03bdc37 r __kstrtab_qdisc_watchdog_cancel
+c03bdc4d r __kstrtab_qdisc_tree_decrease_qlen
+c03bdc66 r __kstrtab_tcf_destroy_chain
+c03bdc78 r __kstrtab_qdisc_get_rtab
+c03bdc87 r __kstrtab_qdisc_put_rtab
+c03bdc96 r __kstrtab_register_qdisc
+c03bdca5 r __kstrtab_unregister_qdisc
+c03bdcb6 r __kstrtab_tc_classify
+c03bdcc2 r __kstrtab_register_tcf_proto_ops
+c03bdcd9 r __kstrtab_unregister_tcf_proto_ops
+c03bdcf2 r __kstrtab_tcf_exts_validate
+c03bdd04 r __kstrtab_tcf_exts_destroy
+c03bdd15 r __kstrtab_tcf_exts_change
+c03bdd25 r __kstrtab_tcf_exts_dump
+c03bdd33 r __kstrtab_tcf_exts_dump_stats
+c03bdd47 r __kstrtab_bfifo_qdisc_ops
+c03bdd57 r __kstrtab_pfifo_qdisc_ops
+c03bdd67 r __kstrtab_netlink_has_listeners
+c03bdd7d r __kstrtab_netlink_ack
+c03bdd89 r __kstrtab_netlink_run_queue
+c03bdd9b r __kstrtab_netlink_broadcast
+c03bddad r __kstrtab_netlink_dump_start
+c03bddc0 r __kstrtab_netlink_kernel_create
+c03bddd6 r __kstrtab_netlink_register_notifier
+c03bddf0 r __kstrtab_netlink_set_nonroot
+c03bde04 r __kstrtab_netlink_unicast
+c03bde14 r __kstrtab_netlink_unregister_notifier
+c03bde30 r __kstrtab_nlmsg_notify
+c03bde3d r __kstrtab_nla_validate
+c03bde4a r __kstrtab_nla_parse
+c03bde54 r __kstrtab_nla_find
+c03bde5d r __kstrtab_nla_strlcpy
+c03bde69 r __kstrtab___nla_reserve
+c03bde77 r __kstrtab___nla_reserve_nohdr
+c03bde8b r __kstrtab_nla_reserve
+c03bde97 r __kstrtab_nla_reserve_nohdr
+c03bdea9 r __kstrtab___nla_put
+c03bdeb3 r __kstrtab___nla_put_nohdr
+c03bdec3 r __kstrtab_nla_put
+c03bdecb r __kstrtab_nla_put_nohdr
+c03bded9 r __kstrtab_nla_memcpy
+c03bdee4 r __kstrtab_nla_memcmp
+c03bdeef r __kstrtab_nla_strcmp
+c03bdefa r __kstrtab_genl_sock
+c03bdf04 r __kstrtab_genl_register_ops
+c03bdf16 r __kstrtab_genl_unregister_ops
+c03bdf2a r __kstrtab_genl_register_family
+c03bdf3f r __kstrtab_genl_unregister_family
+c03bdf60 r __kstrtab_nf_afinfo
+c03bdf6a r __kstrtab_nf_register_afinfo
+c03bdf7d r __kstrtab_nf_unregister_afinfo
+c03bdf92 r __kstrtab_nf_hooks
+c03bdf9b r __kstrtab_nf_register_hook
+c03bdfac r __kstrtab_nf_unregister_hook
+c03bdfbf r __kstrtab_nf_register_hooks
+c03bdfd1 r __kstrtab_nf_unregister_hooks
+c03bdfe5 r __kstrtab_nf_hook_slow
+c03bdff2 r __kstrtab_skb_make_writable
+c03be004 r __kstrtab_nf_proto_csum_replace4
+c03be01b r __kstrtab_ip_ct_attach
+c03be028 r __kstrtab_nf_ct_attach
+c03be035 r __kstrtab_nf_ct_destroy
+c03be043 r __kstrtab_nf_conntrack_destroy
+c03be058 r __kstrtab_nf_log_register
+c03be068 r __kstrtab_nf_log_unregister_pf
+c03be07d r __kstrtab_nf_log_unregister
+c03be08f r __kstrtab_nf_log_packet
+c03be09d r __kstrtab_nf_register_queue_handler
+c03be0b7 r __kstrtab_nf_unregister_queue_handler
+c03be0d3 r __kstrtab_nf_unregister_queue_handlers
+c03be0f0 r __kstrtab_nf_reinject
+c03be0fc r __kstrtab_nf_register_sockopt
+c03be110 r __kstrtab_nf_unregister_sockopt
+c03be126 r __kstrtab_nf_setsockopt
+c03be134 r __kstrtab_nf_getsockopt
+c03be160 r __kstrtab_nf_register_sysctl_table
+c03be179 r __kstrtab_nf_unregister_sysctl_table
+c03be194 r __kstrtab_nf_net_netfilter_sysctl_path
+c03be1c0 r __kstrtab_nf_net_ipv4_netfilter_sysctl_path
+c03be200 r __kstrtab___ip_route_output_key
+c03be216 r __kstrtab_ip_route_output_flow
+c03be22b r __kstrtab___ip_select_ident
+c03be23d r __kstrtab_ip_route_input
+c03be24c r __kstrtab_ip_route_output_key
+c03be260 r __kstrtab_inet_add_protocol
+c03be272 r __kstrtab_inet_del_protocol
+c03be284 r __kstrtab_ip_statistics
+c03be292 r __kstrtab_ip_defrag
+c03be29c r __kstrtab_ip_build_and_send_pkt
+c03be2b2 r __kstrtab_ip_fragment
+c03be2be r __kstrtab_ip_generic_getfrag
+c03be2d1 r __kstrtab_ip_queue_xmit
+c03be2df r __kstrtab_ip_send_check
+c03be2ed r __kstrtab_ip_cmsg_recv
+c03be2fa r __kstrtab_ip_getsockopt
+c03be308 r __kstrtab_ip_setsockopt
+c03be316 r __kstrtab_inet_put_port
+c03be324 r __kstrtab_inet_listen_wlock
+c03be336 r __kstrtab___inet_lookup_listener
+c03be34d r __kstrtab_inet_hash_connect
+c03be35f r __kstrtab___inet_twsk_kill
+c03be370 r __kstrtab___inet_twsk_hashdance
+c03be386 r __kstrtab_inet_twsk_alloc
+c03be396 r __kstrtab_inet_twdr_hangman
+c03be3a8 r __kstrtab_inet_twdr_twkill_work
+c03be3be r __kstrtab_inet_twsk_deschedule
+c03be3d3 r __kstrtab_inet_twsk_schedule
+c03be3e6 r __kstrtab_inet_twdr_twcal_tick
+c03be400 r __kstrtab_inet_csk_timer_bug_msg
+c03be417 r __kstrtab_inet_csk_bind_conflict
+c03be42e r __kstrtab_inet_csk_get_port
+c03be440 r __kstrtab_inet_csk_accept
+c03be450 r __kstrtab_inet_csk_init_xmit_timers
+c03be46a r __kstrtab_inet_csk_clear_xmit_timers
+c03be4a0 r __kstrtab_inet_csk_delete_keepalive_timer
+c03be4c0 r __kstrtab_inet_csk_reset_keepalive_timer
+c03be4df r __kstrtab_inet_csk_route_req
+c03be4f2 r __kstrtab_inet_csk_search_req
+c03be506 r __kstrtab_inet_csk_reqsk_queue_hash_add
+c03be524 r __kstrtab_inet_csk_reqsk_queue_prune
+c03be53f r __kstrtab_inet_csk_clone
+c03be54e r __kstrtab_inet_csk_destroy_sock
+c03be564 r __kstrtab_inet_csk_listen_start
+c03be57a r __kstrtab_inet_csk_listen_stop
+c03be58f r __kstrtab_inet_csk_addr2sockaddr
+c03be5a6 r __kstrtab_inet_csk_ctl_sock_create
+c03be5bf r __kstrtab_tcp_orphan_count
+c03be5d0 r __kstrtab_sysctl_tcp_mem
+c03be5df r __kstrtab_sysctl_tcp_rmem
+c03be5ef r __kstrtab_sysctl_tcp_wmem
+c03be5ff r __kstrtab_tcp_memory_allocated
+c03be614 r __kstrtab_tcp_sockets_allocated
+c03be62a r __kstrtab_tcp_memory_pressure
+c03be63e r __kstrtab_tcp_enter_memory_pressure
+c03be658 r __kstrtab_tcp_get_info
+c03be665 r __kstrtab_tcp_tso_segment
+c03be675 r __kstrtab_tcp_done
+c03be67e r __kstrtab_tcp_close
+c03be688 r __kstrtab_tcp_disconnect
+c03be697 r __kstrtab_tcp_getsockopt
+c03be6a6 r __kstrtab_tcp_ioctl
+c03be6b0 r __kstrtab_tcp_poll
+c03be6b9 r __kstrtab_tcp_read_sock
+c03be6c7 r __kstrtab_tcp_recvmsg
+c03be6d3 r __kstrtab_tcp_sendmsg
+c03be6df r __kstrtab_tcp_sendpage
+c03be6ec r __kstrtab_tcp_setsockopt
+c03be6fb r __kstrtab_tcp_shutdown
+c03be708 r __kstrtab_tcp_statistics
+c03be717 r __kstrtab_sysctl_tcp_ecn
+c03be726 r __kstrtab_sysctl_tcp_reordering
+c03be73c r __kstrtab_tcp_parse_options
+c03be74e r __kstrtab_tcp_rcv_established
+c03be762 r __kstrtab_tcp_rcv_state_process
+c03be778 r __kstrtab_tcp_initialize_rcv_mss
+c03be78f r __kstrtab_tcp_connect
+c03be79b r __kstrtab_tcp_make_synack
+c03be7ab r __kstrtab_tcp_simple_retransmit
+c03be7c1 r __kstrtab_tcp_sync_mss
+c03be7ce r __kstrtab_sysctl_tcp_tso_win_divisor
+c03be7e9 r __kstrtab_tcp_mtup_init
+c03be7f7 r __kstrtab_tcp_init_xmit_timers
+c03be80c r __kstrtab_tcp_twsk_unique
+c03be81c r __kstrtab_tcp_v4_destroy_sock
+c03be830 r __kstrtab_ipv4_specific
+c03be83e r __kstrtab_tcp_hashinfo
+c03be84b r __kstrtab_tcp_prot
+c03be854 r __kstrtab_tcp_unhash
+c03be85f r __kstrtab_tcp_v4_conn_request
+c03be873 r __kstrtab_tcp_v4_connect
+c03be882 r __kstrtab_tcp_v4_do_rcv
+c03be890 r __kstrtab_tcp_v4_remember_stamp
+c03be8a6 r __kstrtab_tcp_v4_send_check
+c03be8b8 r __kstrtab_tcp_v4_syn_recv_sock
+c03be8cd r __kstrtab_tcp_proc_register
+c03be8df r __kstrtab_tcp_proc_unregister
+c03be8f3 r __kstrtab_sysctl_tcp_low_latency
+c03be90a r __kstrtab_tcp_death_row
+c03be918 r __kstrtab_tcp_twsk_destructor
+c03be92c r __kstrtab_tcp_check_req
+c03be93a r __kstrtab_tcp_child_process
+c03be94c r __kstrtab_tcp_create_openreq_child
+c03be965 r __kstrtab_tcp_timewait_state_process
+c03be980 r __kstrtab_tcp_register_congestion_control
+c03be9a0 r __kstrtab_tcp_unregister_congestion_control
+c03be9c2 r __kstrtab_tcp_slow_start
+c03be9d1 r __kstrtab_tcp_reno_cong_avoid
+c03be9e5 r __kstrtab_tcp_reno_ssthresh
+c03be9f7 r __kstrtab_tcp_reno_min_cwnd
+c03bea09 r __kstrtab_tcp_init_congestion_ops
+c03bea21 r __kstrtab_ip4_datagram_connect
+c03bea36 r __kstrtab_udp_disconnect
+c03bea45 r __kstrtab_udp_hash
+c03bea4e r __kstrtab_udp_hash_lock
+c03bea5c r __kstrtab_udp_ioctl
+c03bea66 r __kstrtab_udp_get_port
+c03bea73 r __kstrtab_udp_prot
+c03bea7c r __kstrtab_udp_sendmsg
+c03bea88 r __kstrtab_udp_lib_getsockopt
+c03bea9b r __kstrtab_udp_lib_setsockopt
+c03beaae r __kstrtab_udp_poll
+c03beab7 r __kstrtab_udp_proc_register
+c03beac9 r __kstrtab_udp_proc_unregister
+c03beadd r __kstrtab_udplite_hash
+c03beaea r __kstrtab_udplite_prot
+c03beaf7 r __kstrtab_udplite_get_port
+c03beb08 r __kstrtab_arp_broken_ops
+c03beb17 r __kstrtab_arp_find
+c03beb20 r __kstrtab_arp_create
+c03beb2b r __kstrtab_arp_xmit
+c03beb34 r __kstrtab_arp_send
+c03beb3d r __kstrtab_arp_tbl
+c03beb45 r __kstrtab_icmp_err_convert
+c03beb56 r __kstrtab_icmp_send
+c03beb60 r __kstrtab_icmp_statistics
+c03beb70 r __kstrtab_xrlim_allow
+c03beb7c r __kstrtab_in_dev_finish_destroy
+c03beb92 r __kstrtab_inet_select_addr
+c03beba3 r __kstrtab_inetdev_by_index
+c03bebb4 r __kstrtab_register_inetaddr_notifier
+c03bebcf r __kstrtab_unregister_inetaddr_notifier
+c03bebec r __kstrtab_inet_ehash_secret
+c03bebfe r __kstrtab_build_ehash_secret
+c03bec11 r __kstrtab_inet_sk_rebuild_header
+c03bec28 r __kstrtab_snmp_fold_field
+c03bec38 r __kstrtab_snmp_mib_init
+c03bec46 r __kstrtab_snmp_mib_free
+c03bec54 r __kstrtab_inet_accept
+c03bec60 r __kstrtab_inet_bind
+c03bec6a r __kstrtab_inet_dgram_connect
+c03bec7d r __kstrtab_inet_dgram_ops
+c03bec8c r __kstrtab_inet_getname
+c03bec99 r __kstrtab_inet_ioctl
+c03beca4 r __kstrtab_inet_listen
+c03becb0 r __kstrtab_inet_register_protosw
+c03becc6 r __kstrtab_inet_release
+c03becd3 r __kstrtab_inet_sendmsg
+c03bece0 r __kstrtab_inet_shutdown
+c03becee r __kstrtab_inet_sock_destruct
+c03bed01 r __kstrtab_inet_stream_connect
+c03bed15 r __kstrtab_inet_stream_ops
+c03bed25 r __kstrtab_inet_unregister_protosw
+c03bed3d r __kstrtab_net_statistics
+c03bed4c r __kstrtab_ip_mc_dec_group
+c03bed5c r __kstrtab_ip_mc_inc_group
+c03bed6c r __kstrtab_ip_mc_join_group
+c03bed7d r __kstrtab_ip_mc_rejoin_group
+c03bed90 r __kstrtab_inet_addr_type
+c03bed9f r __kstrtab_ip_dev_find
+c03bedab r __kstrtab_xfrm4_tunnel_register
+c03bedc1 r __kstrtab_xfrm4_tunnel_deregister
+c03bedd9 r __kstrtab_ip_route_me_harder
+c03bedec r __kstrtab_ip_xfrm_me_harder
+c03bedfe r __kstrtab_ip_nat_decode_session
+c03bee14 r __kstrtab_nf_ip_checksum
+c03bee23 r __kstrtab_xfrm4_rcv
+c03bee2d r __kstrtab_xfrm_cfg_mutex
+c03bee3c r __kstrtab_xfrm_policy_count
+c03bee4e r __kstrtab_xfrm_register_type
+c03bee61 r __kstrtab_xfrm_unregister_type
+c03bee76 r __kstrtab_xfrm_dst_lookup
+c03bee86 r __kstrtab_xfrm_register_mode
+c03bee99 r __kstrtab_xfrm_unregister_mode
+c03beeae r __kstrtab_xfrm_policy_alloc
+c03beec0 r __kstrtab___xfrm_policy_destroy
+c03beed6 r __kstrtab_xfrm_spd_getinfo
+c03beee7 r __kstrtab_xfrm_policy_insert
+c03beefa r __kstrtab_xfrm_policy_bysel_ctx
+c03bef10 r __kstrtab_xfrm_policy_byid
+c03bef21 r __kstrtab_xfrm_policy_flush
+c03bef33 r __kstrtab_xfrm_policy_walk
+c03bef44 r __kstrtab_xfrm_policy_delete
+c03bef57 r __kstrtab___xfrm_lookup
+c03bef65 r __kstrtab_xfrm_lookup
+c03bef71 r __kstrtab_xfrm_decode_session
+c03bef85 r __kstrtab___xfrm_policy_check
+c03bef99 r __kstrtab___xfrm_route_forward
+c03befae r __kstrtab_xfrm_dst_ifdown
+c03befbe r __kstrtab_xfrm_init_pmtu
+c03befcd r __kstrtab_xfrm_bundle_ok
+c03befdc r __kstrtab_xfrm_policy_register_afinfo
+c03beff8 r __kstrtab_xfrm_policy_unregister_afinfo
+c03bf016 r __kstrtab_xfrm_nl
+c03bf01e r __kstrtab_km_waitq
+c03bf027 r __kstrtab_xfrm_state_alloc
+c03bf038 r __kstrtab___xfrm_state_destroy
+c03bf04d r __kstrtab___xfrm_state_delete
+c03bf061 r __kstrtab_xfrm_state_delete
+c03bf073 r __kstrtab_xfrm_state_flush
+c03bf084 r __kstrtab_xfrm_sad_getinfo
+c03bf095 r __kstrtab_xfrm_state_insert
+c03bf0a7 r __kstrtab_xfrm_state_add
+c03bf0b6 r __kstrtab_xfrm_state_update
+c03bf0c8 r __kstrtab_xfrm_state_check_expire
+c03bf0e0 r __kstrtab_xfrm_state_check
+c03bf0f1 r __kstrtab_xfrm_state_lookup
+c03bf103 r __kstrtab_xfrm_state_lookup_byaddr
+c03bf11c r __kstrtab_xfrm_find_acq
+c03bf12a r __kstrtab_xfrm_find_acq_byseq
+c03bf13e r __kstrtab_xfrm_get_acqseq
+c03bf14e r __kstrtab_xfrm_alloc_spi
+c03bf15d r __kstrtab_xfrm_state_walk
+c03bf16d r __kstrtab_xfrm_replay_notify
+c03bf180 r __kstrtab_xfrm_replay_check
+c03bf192 r __kstrtab_xfrm_replay_advance
+c03bf1a6 r __kstrtab_km_policy_notify
+c03bf1b7 r __kstrtab_km_state_notify
+c03bf1c7 r __kstrtab_km_state_expired
+c03bf1d8 r __kstrtab_km_query
+c03bf1e1 r __kstrtab_km_new_mapping
+c03bf1f0 r __kstrtab_km_policy_expired
+c03bf202 r __kstrtab_km_migrate
+c03bf20d r __kstrtab_km_report
+c03bf217 r __kstrtab_xfrm_user_policy
+c03bf228 r __kstrtab_xfrm_register_km
+c03bf239 r __kstrtab_xfrm_unregister_km
+c03bf24c r __kstrtab_xfrm_state_register_afinfo
+c03bf267 r __kstrtab_xfrm_state_unregister_afinfo
+c03bf284 r __kstrtab_xfrm_state_get_afinfo
+c03bf29a r __kstrtab_xfrm_state_put_afinfo
+c03bf2b0 r __kstrtab_xfrm_state_delete_tunnel
+c03bf2c9 r __kstrtab_xfrm_init_state
+c03bf2d9 r __kstrtab___secpath_destroy
+c03bf2eb r __kstrtab_secpath_dup
+c03bf2f7 r __kstrtab_xfrm_parse_spi
+c03bf306 r __kstrtab_xfrm_aalg_get_byid
+c03bf319 r __kstrtab_xfrm_ealg_get_byid
+c03bf32c r __kstrtab_xfrm_calg_get_byid
+c03bf33f r __kstrtab_xfrm_aalg_get_byname
+c03bf354 r __kstrtab_xfrm_ealg_get_byname
+c03bf369 r __kstrtab_xfrm_calg_get_byname
+c03bf37e r __kstrtab_xfrm_aalg_get_byidx
+c03bf392 r __kstrtab_xfrm_ealg_get_byidx
+c03bf3a6 r __kstrtab_xfrm_probe_algs
+c03bf3b6 r __kstrtab_xfrm_count_auth_supported
+c03bf3d0 r __kstrtab_xfrm_count_enc_supported
+c03bf3e9 r __kstrtab_skb_icv_walk
+c03bf3f6 r __kstrtab_inet6_bind
+c03bf401 r __kstrtab_inet6_release
+c03bf40f r __kstrtab_inet6_destroy_sock
+c03bf422 r __kstrtab_inet6_getname
+c03bf430 r __kstrtab_inet6_ioctl
+c03bf43c r __kstrtab_inet6_register_protosw
+c03bf453 r __kstrtab_inet6_unregister_protosw
+c03bf46c r __kstrtab_inet6_sk_rebuild_header
+c03bf484 r __kstrtab_ipv6_opt_accepted
+c03bf496 r __kstrtab_ip6_xmit
+c03bf49f r __kstrtab_ip6_find_1stfragopt
+c03bf4b3 r __kstrtab_ip6_dst_lookup
+c03bf4c2 r __kstrtab_ip6_sk_dst_lookup
+c03bf4d4 r __kstrtab_in6_dev_finish_destroy
+c03bf4eb r __kstrtab_ipv6_get_saddr
+c03bf4fa r __kstrtab_ipv6_chk_addr
+c03bf508 r __kstrtab_register_inet6addr_notifier
+c03bf524 r __kstrtab_unregister_inet6addr_notifier
+c03bf542 r __kstrtab_rt6_lookup
+c03bf54d r __kstrtab_ip6_route_output
+c03bf55e r __kstrtab_ip6_dst_blackhole
+c03bf570 r __kstrtab_ipv6_setsockopt
+c03bf580 r __kstrtab_ipv6_getsockopt
+c03bf590 r __kstrtab_ndisc_mc_map
+c03bf59d r __kstrtab_inet6_add_protocol
+c03bf5b0 r __kstrtab_inet6_del_protocol
+c03bf5c3 r __kstrtab_icmpv6_statistics
+c03bf5d5 r __kstrtab_icmpv6_send
+c03bf5e1 r __kstrtab_icmpv6_err_convert
+c03bf5f4 r __kstrtab_ipv6_find_tlv
+c03bf602 r __kstrtab_ipv6_invert_rthdr
+c03bf614 r __kstrtab_ipv6_push_nfrag_opts
+c03bf629 r __kstrtab_ipv6_dup_options
+c03bf63a r __kstrtab_fl6_sock_lookup
+c03bf64a r __kstrtab_inet6_csk_bind_conflict
+c03bf662 r __kstrtab_inet6_csk_search_req
+c03bf677 r __kstrtab_inet6_csk_reqsk_queue_hash_add
+c03bf696 r __kstrtab_inet6_csk_addr2sockaddr
+c03bf6ae r __kstrtab_inet6_csk_xmit
+c03bf6bd r __kstrtab_xfrm6_rcv_spi
+c03bf6cb r __kstrtab_xfrm6_rcv
+c03bf6d5 r __kstrtab_xfrm6_input_addr
+c03bf6e6 r __kstrtab_xfrm6_find_1stfragopt
+c03bf6fc r __kstrtab_ip6_route_me_harder
+c03bf710 r __kstrtab_nf_ip6_checksum
+c03bf720 r __kstrtab___ipv6_addr_type
+c03bf731 r __kstrtab_ipv6_ext_hdr
+c03bf73e r __kstrtab_ipv6_skip_exthdr
+c03bf74f r __kstrtab___inet6_hash
+c03bf75c r __kstrtab___inet6_lookup_established
+c03bf777 r __kstrtab_inet6_lookup_listener
+c03bf78d r __kstrtab_inet6_lookup
+c03bf79a r __kstrtab_inet6_hash_connect
+c03bf7ad r __kstrtab_wireless_send_event
+c03bf7c1 r __kstrtab_iw_handler_set_spy
+c03bf7d4 r __kstrtab_iw_handler_get_spy
+c03bf7e7 r __kstrtab_iw_handler_set_thrspy
+c03bf7fd r __kstrtab_iw_handler_get_thrspy
+c03bf813 r __kstrtab_wireless_spy_update
+c03bf827 r __kstrtab_klist_init
+c03bf832 r __kstrtab_klist_add_head
+c03bf841 r __kstrtab_klist_add_tail
+c03bf850 r __kstrtab_klist_del
+c03bf85a r __kstrtab_klist_remove
+c03bf867 r __kstrtab_klist_node_attached
+c03bf87b r __kstrtab_klist_iter_init_node
+c03bf890 r __kstrtab_klist_iter_init
+c03bf8a0 r __kstrtab_klist_iter_exit
+c03bf8b0 r __kstrtab_klist_next
+c03bf8bb r __kstrtab_sha_transform
+c03bf8cc r __param_show
+c03bf8cc R __start___param
+c03bf8e0 r __param_printk_time
+c03bf8f4 r __param_blimit
+c03bf908 r __param_qhimark
+c03bf91c r __param_qlowmark
+c03bf930 r __param_forceload
+c03bf944 r __param_acpica_version
+c03bf958 r __param_brl_timeout
+c03bf96c r __param_brl_nbchords
+c03bf980 r __param_default_utf8
+c03bf994 r __param_default_red
+c03bf9a8 r __param_default_grn
+c03bf9bc r __param_default_blu
+c03bf9d0 r __param_italic
+c03bf9e4 r __param_underline
+c03bf9f8 r __param_no_fwh_detect
+c03bfa0c r __param_hangcheck_tick
+c03bfa20 r __param_hangcheck_margin
+c03bfa34 r __param_hangcheck_reboot
+c03bfa48 r __param_hangcheck_dump_tasks
+c03bfa5c r __param_share_irqs
+c03bfa70 r __param_nr_uarts
+c03bfa84 r __param_probe_rsa
+c03bfa98 r __param_rd_size
+c03bfaac r __param_rd_blocksize
+c03bfac0 r __param_newif
+c03bfad4 r __param_delif
+c03bfae8 r __param_noraid
+c03bfafc r __param_all_generic_ide
+c03bfb10 r __param_ignore
+c03bfb24 r __param_debug
+c03bfb38 r __param_autoclose
+c03bfb4c r __param_autoeject
+c03bfb60 r __param_lockdoor
+c03bfb74 r __param_check_media_type
+c03bfb88 r __param_mrw_format_restart
+c03bfb9c r __param_nousb
+c03bfbb0 r __param_blinkenlights
+c03bfbc4 r __param_old_scheme_first
+c03bfbd8 r __param_use_both_schemes
+c03bfbec r __param_usbfs_snoop
+c03bfc00 r __param_bias
+c03bfc14 r __param_nokbd
+c03bfc28 r __param_noaux
+c03bfc3c r __param_nomux
+c03bfc50 r __param_unlock
+c03bfc64 r __param_reset
+c03bfc78 r __param_direct
+c03bfc8c r __param_dumbkbd
+c03bfca0 r __param_noloop
+c03bfcb4 r __param_panicblink
+c03bfcc8 r __param_nopnp
+c03bfcdc r __param_debug
+c03bfcf0 r __param_xres
+c03bfd04 r __param_yres
+c03bfd18 r __param_tap_time
+c03bfd2c r __param_set
+c03bfd40 r __param_reset
+c03bfd54 r __param_softrepeat
+c03bfd68 r __param_softraw
+c03bfd7c r __param_scroll
+c03bfd90 r __param_extra
+c03bfda4 r __param_proto
+c03bfdb8 r __param_resolution
+c03bfdcc r __param_rate
+c03bfde0 r __param_smartscroll
+c03bfdf4 r __param_resetafter
+c03bfe08 r __param_resync_time
+c03bfe1c r __param_start_ro
+c03bfe30 r __param_start_dirty_degraded
+c03bfe44 r __param_major
+c03bfe58 r __param_pb_fnmode
+c03bfe6c r __param_mousepoll
+c03bfe80 r __param_quirks
+c03bfe94 r __param_fast_convergence
+c03bfea8 r __param_max_increment
+c03bfebc r __param_beta
+c03bfed0 r __param_initial_ssthresh
+c03bfee4 r __param_bic_scale
+c03bfef8 r __param_tcp_friendliness
+c03bff0c R __end_rodata
+c03bff0c R __stop___param
+c03c0000 D stack_start
+c03c0008 d ready
+c03c0009 d early_recursion_flag
+c03c000d d int_msg
+c03c0039 d fault_msg
+c03c008e D boot_gdt_descr
+c03c0096 D idt_descr
+c03c00a0 D early_gdt_descr
+c03c0100 D boot_gdt
+c03c0180 D init_mm
+c03c0380 D init_task
+c03c08e0 d init_fs
+c03c0980 d init_files
+c03c0b00 d init_signals
+c03c0ca0 d init_sighand
+c03c11c0 D envp_init
+c03c1248 D loops_per_jiffy
+c03c1260 d argv_init
+c03c12e8 d max_cpus
+c03c1300 D init_uts_ns
+c03c148c D root_mountflags
+c03c1490 d argv.14999
+c03c14a0 D genapic
+c03c14c0 D apic_summit
+c03c1560 D apic_bigsmp
+c03c15ec d cpu.4885
+c03c1600 d bigsmp_dmi_table
+c03c16a0 D apic_es7000
+c03c1740 D apic_default
+c03c1800 D interrupt
+c03c1b80 D kstack_depth_to_print
+c03c1b84 d code_bytes
+c03c1b88 d nmi_print_lock
+c03c1b98 d die.19656
+c03c1bb0 d print_trace_ops
+c03c1bc0 D rtc_lock
+c03c1bd0 d sync_cmos_timer
+c03c1be8 d highmem_pages
+c03c1c00 D i8259A_lock
+c03c1c10 D cached_irq_mask
+c03c1c20 d i8259_sysdev_class
+c03c1ca0 d device_i8259A
+c03c1d00 d fpu_irq
+c03c1d20 d i8259A_chip
+c03c1d60 D pci_mem_start
+c03c1d80 D data_resource
+c03c1dc0 D code_resource
+c03c1e00 d video_ram_resource
+c03c1e40 d standard_io_resources
+c03c1fa0 d adapter_rom_resources
+c03c2080 d video_rom_resource
+c03c20c0 d system_rom_resource
+c03c2100 d extension_rom_resource
+c03c2140 d i8237_sysdev_class
+c03c21c0 d device_i8237A
+c03c2220 d intelnops
+c03c2244 d k8nops
+c03c2268 d k7nops
+c03c22a0 d intel_nops
+c03c22c4 d smp_alt
+c03c22d4 d smp_alt_modules
+c03c22e0 d k8_nops
+c03c2320 d k7_nops
+c03c2380 D i8253_lock
+c03c23a0 D pit_clockevent
+c03c2400 d clocksource_pit
+c03c2500 d clocksource_tsc
+c03c2600 D cpuinfo_op
+c03c2620 d ktype_percpu_entry
+c03c262c d ktype_cache
+c03c2638 d sysfs_ops
+c03c2640 d default_attrs
+c03c2664 d type
+c03c2678 d level
+c03c268c d coherency_line_size
+c03c26a0 d physical_line_partition
+c03c26b4 d ways_of_associativity
+c03c26c8 d number_of_sets
+c03c26dc d size
+c03c26f0 d shared_cpu_map
+c03c2704 D machine_check_vector
+c03c2708 d vendor_thermal_interrupt
+c03c270c d thermal_throttle_attr_group
+c03c2714 d thermal_throttle_attrs
+c03c271c d attr_count
+c03c2740 d mtrr_sysdev_driver
+c03c275c d mtrr_mutex
+c03c2780 D generic_mtrr_ops
+c03c27a0 d set_atomicity_lock
+c03c27b0 d __param_str_show
+c03c27c0 d amd_mtrr_ops
+c03c27e0 d cyrix_mtrr_ops
+c03c2800 d centaur_mtrr_ops
+c03c2820 d k7_wd_ops
+c03c2860 d intel_arch_wd_ops
+c03c28a0 d p6_wd_ops
+c03c28e0 d p4_wd_ops
+c03c2920 D machine_ops
+c03c2938 d jump_to_bios
+c03c2940 d reboot_cpu
+c03c2960 d real_mode_switch
+c03c298b d real_mode_idt
+c03c2993 d real_mode_gdt
+c03c29a0 d real_mode_gdt_entries
+c03c29b8 D smp_ops
+c03c29d4 d call_lock
+c03c29e4 d tlbstate_lock
+c03c29f4 D smp_num_siblings
+c03c2a00 D mp_bus_id_to_pci_bus
+c03c2e10 D boot_cpu_physical_apicid
+c03c2e14 D bios_cpu_apicid
+c03c2e24 d pci_irq.21808
+c03c2e40 d lapic_sysclass
+c03c2ec0 d device_lapic
+c03c2f20 d lapic_clockevent
+c03c2f80 D nmi_watchdog
+c03c2fa0 d nmi_sysclass
+c03c3020 d device_lapic_nmi
+c03c3074 d nmi_hz
+c03c3078 d lock.17234
+c03c30a0 D sis_apic_bug
+c03c30c0 d ioapic_sysdev_class
+c03c3140 d ioapic_lock
+c03c3150 d first_free_entry.22706
+c03c3154 d vector_lock
+c03c3164 d current_vector.23161
+c03c3180 d ht_irq_chip
+c03c31c0 d msi_chip
+c03c3200 d ioapic_i8259
+c03c3208 d crash_nmi_nb
+c03c3214 d efi_rt_lock
+c03c3224 d saved_return_addr
+c03c3228 d efi_rt_function_ptr
+c03c322c d irqbits_lock
+c03c3240 D early_console
+c03c3260 d early_vga_console
+c03c3294 d current_ypos
+c03c3298 d max_ypos
+c03c329c d max_xpos
+c03c32a0 d early_serial_console
+c03c32e0 d simnow_console
+c03c3314 d early_serial_base
+c03c3380 d hpet_class
+c03c3400 d hpet_device
+c03c3460 d hpet_clockevent
+c03c3500 d clocksource_hpet
+c03c3600 D __VMALLOC_RESERVE
+c03c3608 D __PAGE_KERNEL
+c03c3610 D __PAGE_KERNEL_EXEC
+c03c3618 D __FIXADDR_TOP
+c03c361c D pgd_lock
+c03c362c D show_unhandled_signals
+c03c3630 d start.19309
+c03c3634 d notify_page_fault_chain
+c03c3648 d cpa_lock
+c03c3658 d df_list
+c03c3660 d irq0
+c03c3680 d irq2
+c03c3700 D attr_sched_mc_power_savings
+c03c3714 D attr_sched_smt_power_savings
+c03c3728 d migration_factor
+c03c3740 d migration_cost
+c03c3840 d balancing
+c03c3850 d sched_hotcpu_mutex
+c03c3880 D default_exec_domain
+c03c38ac d exec_domains_lock
+c03c38bc d exec_domains
+c03c38c0 d ident_map
+c03c3940 D panic_notifier_list
+c03c3954 d pause_on_oops_lock
+c03c3980 D log_wait
+c03c3998 D console_printk
+c03c39a8 D printk_ratelimit_jiffies
+c03c39ac D printk_ratelimit_burst
+c03c39b0 d log_buf_len
+c03c39b4 d logbuf_lock
+c03c39c4 d log_buf
+c03c39c8 d toks.25918
+c03c39cc d ratelimit_lock.25916
+c03c39dc d preferred_console
+c03c39e0 d selected_console
+c03c3a00 d console_sem
+c03c3a20 d secondary_console_sem
+c03c3a40 d msg_level.25429
+c03c3a44 d printk_cpu
+c03c3a48 d log_level_unknown.25561
+c03c3a4c d __param_str_printk_time
+c03c3a60 d profile_flip_mutex
+c03c3a7c d prof_cpu_mask
+c03c3a80 d task_exit_notifier
+c03c3aa0 d munmap_notifier
+c03c3ac0 d task_free_notifier
+c03c3ad4 d lowest_to_date.29713
+c03c3ad8 d low_water_lock.29711
+c03c3ae8 d firsttime.23842
+c03c3b00 D ioport_resource
+c03c3b40 D iomem_resource
+c03c3b64 d resource_lock
+c03c3b80 d root_table
+c03c3cb4 d sysctl_lock
+c03c3cc4 d root_table_header
+c03c3ce0 d kern_table
+c03c42c0 d vm_table
+c03c46a0 d fs_table
+c03c4960 d debug_table
+c03c49b8 d maxolduid
+c03c49bc d ngroups_max
+c03c49c0 d one_hundred
+c03c49c4 d min_percpu_pagelist_fract
+c03c49c8 D cap_bset
+c03c49cc d task_capability_lock
+c03c49dc d count.20411
+c03c49e0 D root_user
+c03c4a10 d uidhash_lock
+c03c4a20 D init_user_ns
+c03c5240 D overflowuid
+c03c5244 D overflowgid
+c03c5248 D fs_overflowuid
+c03c524c D fs_overflowgid
+c03c5250 D C_A_D
+c03c5260 D init_groups
+c03c52ec D uts_sem
+c03c5320 D poweroff_cmd
+c03c5420 d envp.27637
+c03c542c d cad_work.26420
+c03c5440 d reboot_notifier_list
+c03c5460 D modprobe_path
+c03c5560 d envp.23942
+c03c5570 d workqueue_mutex
+c03c558c d workqueues
+c03c55a0 D init_struct_pid
+c03c55c4 D pid_max
+c03c55c8 D pid_max_min
+c03c55cc D pid_max_max
+c03c55d0 D init_pid_ns
+c03c5600 d blimit
+c03c5604 d qhimark
+c03c5608 d qlowmark
+c03c5680 d rcu_ctrlblk
+c03c5780 d rcu_bh_ctrlblk
+c03c5880 d rcu_barrier_mutex
+c03c589c d __param_str_blimit
+c03c58ac d __param_str_qhimark
+c03c58bd d __param_str_qlowmark
+c03c58e0 D module_subsys
+c03c594c d module_ktype
+c03c5958 d module_uevent_ops
+c03c5964 d module_sysfs_ops
+c03c596c d idr_lock
+c03c597c d kthread_create_list
+c03c5984 d kthread_create_lock
+c03c5994 d kthread_stop_lock
+c03c59c0 d latency_notifier
+c03c59e0 d latency_lock
+c03c59f0 d latency_list
+c03c5a00 D init_nsproxy
+c03c5a2c d die_chain
+c03c5a40 d vx_info_hash_lock
+c03c5a50 d vx_info_inactive_lock
+c03c5a60 d nx_info_hash_lock
+c03c5a70 d tokens
+c03c5a80 D vlimit_name
+c03c5ae0 D account_mask
+c03c5b00 D vshelper_path
+c03c5c00 d dl_info_hash_lock
+c03c5c20 d proc_virtual_dir_operations
+c03c5ca0 d proc_virtual_dir_inode_operations
+c03c5d00 d proc_virtnet_dir_operations
+c03c5d80 d proc_virtnet_dir_inode_operations
+c03c5de0 d nx_virtnet_stuff
+c03c5e40 d nx_base_stuff
+c03c5e88 d proc_nid_dentry_operations
+c03c5ec0 d vx_virtual_stuff
+c03c5f20 d vx_base_stuff
+c03c5fe0 d proc_xid_dentry_operations
+c03c6000 d proc_vs_info_file_operations
+c03c6080 d proc_nid_inode_operations
+c03c60e0 d proc_nid_file_operations
+c03c6160 d proc_nx_info_file_operations
+c03c61e0 d proc_xid_inode_operations
+c03c6240 d proc_xid_file_operations
+c03c62c0 d proc_vx_info_file_operations
+c03c6380 d timekeeping_sysclass
+c03c6400 d device_timer
+c03c6454 D tick_usec
+c03c6458 D time_status
+c03c645c D time_maxerror
+c03c6460 D time_esterror
+c03c6464 d time_constant
+c03c6480 d clocksource_lock
+c03c64a0 d clocksource_sysclass
+c03c6520 d device_clocksource
+c03c6574 d attr_current_clocksource
+c03c6588 d attr_available_clocksource
+c03c659c d clocksource_list
+c03c65a4 d curr_clocksource
+c03c65a8 d watchdog_lock
+c03c65b8 d watchdog_list
+c03c6600 D clocksource_jiffies
+c03c6700 d timer_list_fops
+c03c6770 d clockevents_lock
+c03c6780 d clockevents_released
+c03c6788 d clockevent_devices
+c03c6790 D tick_device_lock
+c03c67a0 d tick_notifier
+c03c67ac d tick_broadcast_lock
+c03c67c0 d futex_fs_type
+c03c67e0 D max_lock_depth
+c03c6800 D dma_spin_lock
+c03c6820 d dma_chan_busy
+c03c6860 d cpu_add_remove_lock
+c03c687c d cpu_bitmask_lock
+c03c68a0 d modules
+c03c68a8 d module_mutex
+c03c68c4 d modlist_lock
+c03c68e0 d module_notify_list
+c03c6900 d notify_mutex
+c03c6920 d modinfo_version
+c03c6940 d modinfo_srcversion
+c03c6960 d initstate
+c03c6980 d refcnt
+c03c69a0 D pm_mutex
+c03c69c0 D power_subsys
+c03c6a2c d attr_group
+c03c6a34 d g
+c03c6a3c d state_attr
+c03c6a50 d pm_devs_lock
+c03c6a6c d pm_devs
+c03c6a74 d sysrq_poweroff_op
+c03c6a84 d poweroff_work
+c03c6a94 D acct_parm
+c03c6aa0 D crashk_res
+c03c6ae0 D proc_container_operations
+c03c6b50 d container_mutex
+c03c6b6c d roots
+c03c6b74 d release_list
+c03c6b7c d release_agent_work
+c03c6b8c d container_dops.23817
+c03c6ba8 d css_group_lock
+c03c6bc0 d container_fs_type
+c03c6be0 d proc_containerstats_operations
+c03c6c60 d files
+c03c6d80 d cft_release_agent
+c03c6de0 d container_ops
+c03c6e40 d container_dir_inode_operations
+c03c6ea0 d container_file_operations
+c03c6f10 d container_backing_dev_info.23788
+c03c6f40 D cpuacct_subsys
+c03c6fa0 d files
+c03c7060 D ns_subsys
+c03c70c0 d stopmachine_mutex
+c03c70e0 D kprobe_mutex
+c03c70fc D kretprobe_lock
+c03c710c d kprobe_exceptions_nb
+c03c7120 d debugfs_kprobes_operations
+c03c71a0 d fops_kp
+c03c7210 d kprobe_page_fault_nb
+c03c721c d kprobes_seq_ops
+c03c7240 D kernel_subsys
+c03c72ac d kernel_attr_group
+c03c72b4 d kernel_attrs
+c03c72c8 d uevent_seqnum_attr
+c03c72dc d uevent_helper_attr
+c03c72f0 d kexec_loaded_attr
+c03c7304 d kexec_crash_loaded_attr
+c03c7318 d panic_block
+c03c7324 d print_lock
+c03c7340 D no_irq_chip
+c03c7380 D dummy_irq_chip
+c03c73c0 d count.11610
+c03c73c4 d probing_active
+c03c73e0 d relay_channels_mutex
+c03c73fc d relay_channels
+c03c7404 d default_channel_callbacks
+c03c7418 d relay_file_mmap_ops
+c03c7440 d uts_root_table
+c03c74a0 d uts_kern_table
+c03c7600 d bdata_list
+c03c7608 D generic_file_vm_ops
+c03c7624 d oom_lock.17064
+c03c7680 D sysctl_lowmem_reserve_ratio
+c03c7688 D min_free_kbytes
+c03c7700 D contig_page_data
+c03c9700 D dirty_background_ratio
+c03c9704 D vm_dirty_ratio
+c03c9708 D dirty_writeback_interval
+c03c970c D dirty_expire_interval
+c03c9710 d wb_timer
+c03c9728 d ratelimit_pages
+c03c972c d laptop_mode_wb_timer
+c03c9744 d pdflush_lock
+c03c9754 d pdflush_list
+c03c975c D default_backing_dev_info
+c03c9778 D vm_swappiness
+c03c977c d shrinker_rwsem
+c03c9798 d shrinker_list
+c03c97a0 d congestion_wqh
+c03c97d0 d pkmap_map_wait
+c03c97e8 d shmlock_user_lock
+c03c9800 D protection_map
+c03c9840 D sysctl_overcommit_ratio
+c03c9844 d special_mapping_vmops
+c03c9860 D vmlist_lock
+c03c9880 D swapper_space
+c03c98f8 d swap_backing_dev_info
+c03c9914 D swap_lock
+c03c9924 D swap_list
+c03c992c d swapon_mutex
+c03c9948 d swap_unplug_sem
+c03c9964 d swap_token_lock
+c03c9980 d tmpfs_fs_type
+c03c99a0 d shmem_export_ops
+c03c99b8 d shmem_swaplist_lock
+c03c99c8 d lock.26387
+c03c99d8 d shmem_vm_ops
+c03c99f4 d shmem_swaplist
+c03c9a00 D malloc_sizes
+c03c9ae4 d cache_chain_mutex
+c03c9b00 d cache_cache
+c03c9b8c d slab_early_init
+c03c9ba0 d initarray_generic
+c03c9bc4 d xip_file_vm_ops
+c03c9be0 d xip_alloc_lock.18143
+c03c9c00 D files_stat
+c03c9c0c D super_blocks
+c03c9c14 D sb_lock
+c03c9c24 d unnamed_dev_lock
+c03c9c34 d mutex.27200
+c03c9c50 D directly_mappable_cdev_bdi
+c03c9c6c d chrdevs_lock
+c03c9c88 d ktype_cdev_default
+c03c9c94 d cdev_lock
+c03c9ca4 d ktype_cdev_dynamic
+c03c9cb0 d warncount.24372
+c03c9cc0 D core_pattern
+c03c9d40 d binfmt_lock
+c03c9d60 d pipe_fs_type
+c03c9d80 d pipefs_dentry_operations
+c03c9d9c d fasync_lock
+c03c9dc0 D leases_enable
+c03c9dc4 D lease_break_time
+c03c9dc8 d file_lock_list
+c03c9dd0 d blocked_list
+c03c9de0 d lease_manager_ops
+c03c9e00 D dentry_stat
+c03c9e18 d dentry_unused
+c03c9e20 D inode_in_use
+c03c9e28 D inode_unused
+c03c9e30 D inode_lock
+c03c9e40 d iprune_mutex
+c03c9e5c d file_systems_lock
+c03c9e80 D fs_subsys
+c03c9eec D mounts_op
+c03c9efc D mountstats_op
+c03c9f20 d fs_info.25062
+c03c9fe0 D aio_max_nr
+c03c9fe4 d fput_lock
+c03c9ff4 d fput_head
+c03c9ffc d fput_work
+c03ca00c d aio_nr_lock
+c03ca01c d simple_transaction_lock.18011
+c03ca02c d pin_fs_lock
+c03ca03c d cursor_name.17640
+c03ca048 d simple_dentry_operations.17626
+c03ca064 d bio_dirty_lock
+c03ca074 d bio_dirty_work
+c03ca0a0 d all_bdevs
+c03ca0c0 d bd_type
+c03ca0e0 d revokefs_fs_type
+c03ca100 d revokefs_super_ops
+c03ca160 d revoked_inode_ops
+c03ca1c0 D inotify_table
+c03ca280 d inotify_fs_type
+c03ca2a0 d anon_inode_fs_type
+c03ca2c0 d anon_inodefs_dentry_operations
+c03ca2e0 d bm_fs_type
+c03ca300 d misc_format
+c03ca31c d enabled
+c03ca320 d entries_lock
+c03ca330 d entries
+c03ca340 d bm_files.19395
+c03ca37c d script_format
+c03ca398 d elf_format
+c03ca3b4 d mb_cache_spinlock
+c03ca3c4 d mb_cache_list
+c03ca3cc d mb_cache_lru_list
+c03ca3d4 d mb_cache_queue
+c03ca400 D dq_data_lock
+c03ca420 D dquot_operations
+c03ca460 D vfs_quotactl_ops
+c03ca4a0 d sys_table
+c03ca4f8 d flag_print_warnings
+c03ca4fc d dq_list_lock
+c03ca50c d free_dquots
+c03ca514 d inuse_list
+c03ca520 d fs_table
+c03ca580 d fs_dqstats_table
+c03ca738 d v2_quota_format
+c03ca748 d v2_format_ops
+c03ca780 d pagemap_walk
+c03ca790 d clear_refs_walk
+c03ca7a0 d proc_pid_smaps_op
+c03ca7b0 d smaps_walk
+c03ca7c0 d proc_pid_maps_op
+c03ca7e0 D proc_root
+c03ca840 d proc_fs_type
+c03ca860 d proc_base_dentry_operations
+c03ca87c d pid_dentry_operations
+c03ca898 d tid_fd_dentry_operations
+c03ca8c0 D proc_subdir_lock
+c03ca8d0 d proc_dentry_operations
+c03ca8ec d proc_inum_lock
+c03ca900 d proc_inum_idr
+c03ca920 d task_state_array
+c03ca940 d tty_drivers_op
+c03ca960 d simple_ones.21868
+c03ca9a8 d int_seq_ops
+c03ca9b8 d devinfo_ops
+c03ca9e0 d proc_sys_inode_operations
+c03caa3c d proc_sys_dentry_operations
+c03caa60 D proc_net_ns_ops
+c03caa80 d proc_net_dir_inode_operations
+c03caadc d kclist_lock
+c03caaf0 D elfcorehdr_addr
+c03caaf8 d vmcore_list
+c03cab00 D warn_no_part
+c03cab04 D ktype_part
+c03cab10 d addpartattr.20485
+c03cab1c d part_sysfs_ops
+c03cab24 d default_attrs
+c03cab3c d part_attr_uevent
+c03cab50 d part_attr_dev
+c03cab64 d part_attr_start
+c03cab78 d part_attr_size
+c03cab8c d part_attr_stat
+c03caba0 d sysfs_backing_dev_info
+c03cabbc d subsys_sysfs_ops
+c03cabe0 D sysfs_mutex
+c03cabfc D sysfs_assoc_lock
+c03cac0c d sysfs_dentry_ops
+c03cac28 d sysfs_ino_lock
+c03cac40 d sysfs_ino_ida
+c03cac80 D sysfs_root
+c03cacc0 d sysfs_fs_type
+c03cace0 d devpts_fs_type
+c03cad00 d devpts_dir_operations
+c03cad70 d config
+c03cada0 d tokens
+c03cadc0 d devpts_file_inode_operations
+c03cae1c d dcookie_mutex
+c03cae38 d dcookie_users
+c03cae40 d ext3_fs_type
+c03cae60 d ext3_export_ops
+c03cae80 d ext3_qctl_operations
+c03caec0 d ext3_quota_operations
+c03caf00 d tokens
+c03cb0a0 D ext3_xattr_handlers
+c03cb0b8 D ext3_xattr_user_handler
+c03cb0c8 D ext3_xattr_trusted_handler
+c03cb0d8 D ext3_xattr_acl_access_handler
+c03cb0e8 D ext3_xattr_acl_default_handler
+c03cb0f8 D ext3_xattr_security_handler
+c03cb120 d ext2_filetype_table
+c03cb140 d ext2_fs_type
+c03cb160 d ext2_export_ops
+c03cb180 d tokens
+c03cb288 D ext2_xattr_handlers
+c03cb2a0 D ext2_xattr_user_handler
+c03cb2b0 D ext2_xattr_trusted_handler
+c03cb2c0 D ext2_xattr_acl_access_handler
+c03cb2d0 D ext2_xattr_acl_default_handler
+c03cb2e0 D ext2_xattr_security_handler
+c03cb300 d cramfs_fs_type
+c03cb320 d read_mutex
+c03cb340 d ramfs_fs_type
+c03cb360 d rootfs_fs_type
+c03cb380 d ramfs_backing_dev_info
+c03cb3a0 d iso9660_fs_type
+c03cb3c0 d isofs_dentry_ops
+c03cb440 d tokens
+c03cb550 D isofs_export_ops
+c03cb580 d default_table
+c03cb5a0 d nls_lock
+c03cb5b0 d tables
+c03cb5c0 d utf8_table
+c03cb660 d charset2lower
+c03cb760 d charset2upper
+c03cb860 d page00
+c03cb960 d table
+c03cb980 d charset2lower
+c03cba80 d charset2upper
+c03cbb80 d page00
+c03cbc80 d page01
+c03cbd80 d page03
+c03cbe80 d page20
+c03cbf80 d page22
+c03cc080 d page23
+c03cc180 d page25
+c03cc280 d table
+c03cc2a0 d charset2lower
+c03cc3a0 d charset2upper
+c03cc4a0 d page00
+c03cc5a0 d debug_subsys
+c03cc620 d debug_fs_type
+c03cc640 d debug_files.17949
+c03cc660 d fops_u64
+c03cc6e0 d fops_u32
+c03cc760 d fops_u16
+c03cc7e0 d fops_u8
+c03cc860 D init_ipc_ns
+c03cc8a0 d sysvipc_proc_seqops
+c03cc8b0 d shm_vm_ops
+c03cc8e0 d ipc_root_table
+c03cc940 d ipc_kern_table
+c03ccaa0 d mq_sysctl_root
+c03ccb00 d mqueue_fs_type
+c03ccb20 d queues_max
+c03ccb24 d msg_max
+c03ccb28 d msgsize_max
+c03ccb40 d mqueue_super_ops
+c03ccba0 d mq_sysctl_dir
+c03ccc00 d mq_sysctls
+c03cccb0 d msg_max_limit_min
+c03cccb4 d msg_max_limit_max
+c03cccb8 d msg_maxsize_limit_min
+c03cccbc d msg_maxsize_limit_max
+c03cccc0 D crypto_alg_list
+c03cccc8 D crypto_alg_sem
+c03ccd00 D crypto_chain
+c03ccd20 D crypto_km_types
+c03ccd40 d elv_list_lock
+c03ccd50 d elv_list
+c03ccd58 d elv_ktype
+c03ccd64 d elv_sysfs_ops
+c03ccd6c d queue_ktype
+c03ccd78 d queue_sysfs_ops
+c03ccd80 d default_attrs
+c03ccd98 d queue_requests_entry
+c03ccdac d queue_ra_entry
+c03ccdc0 d queue_max_hw_sectors_entry
+c03ccdd4 d queue_max_sectors_entry
+c03ccde8 d queue_iosched_entry
+c03cce00 D partitions_op
+c03cce20 D block_subsys
+c03cce8c D diskstats_op
+c03cce9c d ktype_block
+c03ccea8 d block_subsys_lock
+c03ccec4 d block_uevent_ops
+c03cced0 d disk_sysfs_ops
+c03ccee0 d default_attrs
+c03ccf00 d disk_attr_uevent
+c03ccf14 d disk_attr_dev
+c03ccf28 d disk_attr_range
+c03ccf3c d disk_attr_removable
+c03ccf50 d disk_attr_size
+c03ccf64 d disk_attr_stat
+c03ccf78 d disk_attr_capability
+c03ccfa0 d cmd_type.20322
+c03cd0a0 d elevator_noop
+c03cd120 d cfq_slice_async
+c03cd124 d cfq_slice_idle
+c03cd140 d iosched_cfq
+c03cd1c0 d cfq_attrs
+c03cd288 d blk_relay_callbacks
+c03cd29c d module_bug_list
+c03cd2c0 D _ctype
+c03cd3c0 d dir_ktype
+c03cd3e0 D uevent_helper
+c03cd4e0 d sequence_lock
+c03cd4f0 d warn.7934
+c03cd4f4 d delay_fn
+c03cd500 D debug_locks
+c03cd504 d count.15708
+c03cd520 d kernel_sem
+c03cd540 d ts_ops
+c03cd548 d ts_mod_lock
+c03cd580 d pci_lock
+c03cd590 d pci_ucfg_wait
+c03cd5c0 D pci_root_buses
+c03cd5c8 D pci_devices
+c03cd5d0 D class_device_attr_cpuaffinity
+c03cd600 d pcibus_class
+c03cd744 D pci_pm_d3_delay
+c03cd748 D pci_cardbus_io_size
+c03cd74c D pci_cardbus_mem_size
+c03cd750 D pci_cache_line_size
+c03cd754 d via_vlink_dev_lo
+c03cd758 d via_vlink_dev_hi
+c03cd760 D pci_bus_type
+c03cd980 d pci_compat_driver
+c03cda90 d pci_driver_kobj_type
+c03cda9c d driver_attr_new_id
+c03cdab0 d pci_driver_sysfs_ops
+c03cdab8 D pci_bus_sem
+c03cdae0 D pci_dev_attrs
+c03cdc00 d pci_config_attr
+c03cdc20 d pcie_config_attr
+c03cdc40 d proc_bus_pci_devices_op
+c03cdc60 d pcie_portdriver
+c03cdd70 d pcie_portdrv_err_handler
+c03cdda0 D pcie_port_bus_type
+c03cdfc0 d logbuf_lock
+c03cdfd0 d __param_str_forceload
+c03ce000 d aerdriver
+c03ce0e0 d aer_error_handlers
+c03ce100 d aer_id
+c03ce148 d pci_msi_enable
+c03ce14c d ht_irq_lock
+c03ce15c d acpi_pci_bus
+c03ce170 d OSC_UUID
+c03ce180 d fb_notifier_list
+c03ce1a0 d vga_lock
+c03ce1b0 d vga_font_is_default
+c03ce1c0 d cga_console_resource.17919
+c03ce200 d vga_console_resource.17912
+c03ce240 d ega_console_resource.17911
+c03ce280 d mda2_console_resource.17909
+c03ce2c0 d mda1_console_resource.17908
+c03ce300 d ega_console_resource.17907
+c03ce340 D max_cstate
+c03ce360 D acpi_rs_convert_address16
+c03ce374 D acpi_rs_convert_address32
+c03ce388 D acpi_rs_convert_address64
+c03ce39c D acpi_rs_convert_ext_address64
+c03ce3b0 d acpi_rs_convert_general_flags
+c03ce3c8 d acpi_rs_convert_mem_flags
+c03ce3dc d acpi_rs_convert_io_flags
+c03ce400 D acpi_gbl_set_resource_dispatch
+c03ce460 D acpi_gbl_get_resource_dispatch
+c03ce4d0 D acpi_rs_convert_io
+c03ce4e4 D acpi_rs_convert_fixed_io
+c03ce4f4 D acpi_rs_convert_generic_reg
+c03ce504 D acpi_rs_convert_end_dpf
+c03ce50c D acpi_rs_convert_end_tag
+c03ce514 D acpi_rs_get_start_dpf
+c03ce528 D acpi_rs_set_start_dpf
+c03ce540 D acpi_rs_get_irq
+c03ce560 D acpi_rs_set_irq
+c03ce5a0 D acpi_rs_convert_ext_irq
+c03ce5c4 D acpi_rs_convert_dma
+c03ce5dc D acpi_rs_convert_memory24
+c03ce5ec D acpi_rs_convert_memory32
+c03ce5fc D acpi_rs_convert_fixed_memory32
+c03ce60c D acpi_rs_get_vendor_small
+c03ce618 D acpi_rs_get_vendor_large
+c03ce624 D acpi_rs_set_vendor
+c03ce640 D acpi_gbl_exception_names_env
+c03ce6c0 D acpi_gbl_exception_names_pgm
+c03ce6e4 D acpi_gbl_exception_names_tbl
+c03ce700 D acpi_gbl_exception_names_aml
+c03ce7a0 D acpi_gbl_exception_names_ctrl
+c03ce7d4 D acpi_gbl_create_osi_method
+c03ce7d5 D acpi_gbl_leave_wake_gpes_disabled
+c03ce7d8 D acpi_dbg_level
+c03ce7dc D acpi_dbg_layer
+c03ce7e0 D acpi_gbl_shutdown
+c03ce7e4 D acpi_gbl_sleep_state_names
+c03ce7fc D acpi_gbl_highest_dstate_names
+c03ce820 D acpi_gbl_bit_register_info
+c03ce878 D acpi_gbl_fixed_event_info
+c03ce8a0 D acpi_gbl_region_types
+c03ce8c0 d acpi_sysclass
+c03ce940 d device_acpi
+c03ce9a0 D acpi_bus_event_list
+c03ce9a8 D acpi_bus_event_queue
+c03ce9c0 D acpi_subsys
+c03cea2c d acpi_bus_event_lock
+c03cea3c d bus_type_sem
+c03cea58 d bus_type_list
+c03cea60 D acpi_device_lock
+c03cea70 D acpi_wakeup_device_list
+c03cea80 D acpi_bus_type
+c03cec88 d acpi_bus_id_list
+c03cec90 d acpi_device_list
+c03cec98 d dev_attr_path
+c03cecac d dev_attr_hid
+c03cecc0 d dev_attr_eject
+c03cece0 d acpi_ec_mode
+c03ced00 d acpi_ec_driver
+c03ceea0 d acpi_ec_info_ops
+c03cef20 d acpi_pci_root_driver
+c03cf0b4 d acpi_pci_roots
+c03cf0c0 D acpi_link_lock
+c03cf0e0 d acpi_pci_link_driver
+c03cf280 d irqrouter_sysdev_class
+c03cf300 d device_irqrouter
+c03cf360 d acpi_irq_penalty
+c03cf760 d acpi_prt_lock
+c03cf770 d first_time.18832
+c03cf780 d acpi_power_driver
+c03cf914 d acpi_table_attr_list
+c03cf91c d __param_str_acpica_version
+c03cf930 d acpi_system_event_lock
+c03cf940 d cm_sbs_mutex
+c03cf960 D pnp_global
+c03cf968 D pnp_lock
+c03cf978 d pnp_protocols
+c03cf980 D pnp_cards
+c03cf988 d pnp_card_drivers
+c03cf990 d dev_attr_name
+c03cf9a4 d dev_attr_card_id
+c03cf9c0 D pnp_bus_type
+c03cfbe0 d pnp_reserve_mem
+c03cfc20 d pnp_reserve_io
+c03cfc60 d pnp_reserve_dma
+c03cfc80 d pnp_reserve_irq
+c03cfcc0 D pnp_res_mutex
+c03cfce0 d dev_attr_options
+c03cfcf4 d dev_attr_resources
+c03cfd08 d dev_attr_id
+c03cfd20 d pnp_fixups
+c03cfdc0 d system_pnp_driver
+c03cfea0 d pnpacpi_protocol
+c03d0080 d zero_bdi
+c03d0100 D random_table
+c03d0280 d input_pool
+c03d0380 d random_read_wakeup_thresh
+c03d0384 d random_write_wakeup_thresh
+c03d03a0 d rekey_work
+c03d0400 d nonblocking_pool
+c03d0500 d random_write_wait
+c03d0518 d random_read_wait
+c03d0580 d blocking_pool
+c03d0680 d sysctl_poolsize
+c03d0684 d min_read_thresh
+c03d0688 d max_read_thresh
+c03d068c d max_write_thresh
+c03d06a0 d poolinfo_table
+c03d06e0 D tty_std_termios
+c03d070c D tty_drivers
+c03d0714 D tty_mutex
+c03d0740 d allocated_ptys_lock
+c03d0760 d allocated_ptys
+c03d0780 d redirect_lock
+c03d0790 d tty_ldisc_wait
+c03d07a8 d tty_ldisc_lock
+c03d07c0 D tty_ldisc_N_TTY
+c03d0820 D pty_limit
+c03d0840 D pty_table
+c03d08c4 d pty_limit_max
+c03d08c8 d misc_mtx
+c03d08e4 d misc_list
+c03d08ec d misc_seq_ops
+c03d08fc d vt_activate_queue
+c03d0920 d translations
+c03d1120 D dfont_unicount
+c03d1220 D dfont_unitable
+c03d1480 d sel_start
+c03d14a0 d inwordLut
+c03d14c0 D vt_spawn_con
+c03d14e0 D kbd_sysrq_xlate
+c03d16e0 D keyboard_tasklet
+c03d16f4 d brl_timeout
+c03d16f8 d brl_nbchords
+c03d16fc d ledstate
+c03d1700 d kbd_handler
+c03d1738 d kbd
+c03d173c d npadch
+c03d1740 d buf.18552
+c03d1744 d kd_mksound_timer
+c03d175c d __param_str_brl_timeout
+c03d1771 d __param_str_brl_nbchords
+c03d17a0 D want_console
+c03d17a4 D color_table
+c03d17c0 D default_red
+c03d1800 D default_grn
+c03d1840 D default_blu
+c03d1880 D con_buf_mtx
+c03d189c d default_italic_color
+c03d18a0 d default_underline_color
+c03d18c0 d device_attrs
+c03d18e8 d blankinterval
+c03d18ec d console_timer
+c03d1920 d vt_console_driver
+c03d1954 d console_work
+c03d1964 d old_offset.19347
+c03d1968 d __param_str_default_utf8
+c03d1978 d __param_str_default_red
+c03d1988 d __param_arr_default_red
+c03d19a0 d __param_str_default_grn
+c03d19b0 d __param_arr_default_grn
+c03d19c8 d __param_str_default_blu
+c03d19d8 d __param_arr_default_blu
+c03d19f0 d __param_str_italic
+c03d19fa d __param_str_underline
+c03d1a20 D plain_map
+c03d1c20 D shift_map
+c03d1e20 D altgr_map
+c03d2020 D ctrl_map
+c03d2220 D shift_ctrl_map
+c03d2420 D alt_map
+c03d2620 D ctrl_alt_map
+c03d2820 D key_maps
+c03d2c20 D keymap_count
+c03d2c40 D func_buf
+c03d2cdc D funcbufptr
+c03d2ce0 D funcbufsize
+c03d2d00 D func_table
+c03d3100 D accent_table
+c03d3400 D accent_table_size
+c03d3420 d sysrq_key_table_lock
+c03d3440 d sysrq_key_table
+c03d34d0 d moom_work
+c03d34e0 d sysrq_loglevel_op
+c03d34f0 d sysrq_reboot_op
+c03d3500 d sysrq_crashdump_op
+c03d3510 d sysrq_term_op
+c03d3520 d sysrq_moom_op
+c03d3530 d sysrq_kill_op
+c03d3540 d sysrq_SAK_op
+c03d3550 d sysrq_showmem_op
+c03d3560 d sysrq_unrt_op
+c03d3570 d sysrq_showregs_op
+c03d3580 d sysrq_show_timers_op
+c03d3590 d sysrq_unraw_op
+c03d35a0 d sysrq_sync_op
+c03d35b0 d sysrq_showstate_op
+c03d35c0 d sysrq_mountro_op
+c03d35d0 d sysrq_showstate_blocked_op
+c03d35e0 d rtc_has_irq
+c03d35e4 d rtc_dev
+c03d3600 d rtc_irq_timer
+c03d3618 d rtc_wait
+c03d3630 d rtc_max_user_freq
+c03d3634 d epoch
+c03d3640 d dev_root
+c03d3698 d rtc_task_lock
+c03d36c0 d rtc_root
+c03d3720 d rtc_table
+c03d3780 d hpet_misc
+c03d37a0 d dev_root
+c03d3800 d hpet_acpi_driver
+c03d3994 d hpet_max_freq
+c03d3998 d hpet_lock
+c03d39a8 d hpet_task_lock
+c03d39c0 d hpet_root
+c03d3a20 d hpet_table
+c03d3a80 d rng_mutex
+c03d3a9c d rng_list
+c03d3aa4 d rng_miscdev
+c03d3ac0 d dev_attr_rng_available
+c03d3ad4 d dev_attr_rng_current
+c03d3b00 d intel_rng
+c03d3b20 d __param_str_no_fwh_detect
+c03d3b40 d hangcheck_tick
+c03d3b44 d hangcheck_margin
+c03d3b48 d hangcheck_ticktock
+c03d3b60 d __param_str_hangcheck_tick
+c03d3b80 d __param_str_hangcheck_margin
+c03d3bc0 d __param_str_hangcheck_reboot
+c03d3c00 d __param_str_hangcheck_dump_tasks
+c03d3c40 d port_mutex
+c03d3c60 d share_irqs
+c03d3c64 d nr_uarts
+c03d3c80 d serial8250_reg
+c03d3cc0 d serial8250_isa_driver
+c03d3da0 d serial8250_console
+c03d3de0 d serial8250_pops
+c03d3e30 d first.18280
+c03d3e34 d serial_mutex
+c03d3e50 d __param_str_share_irqs
+c03d3e60 d __param_str_nr_uarts
+c03d3e6e d __param_str_probe_rsa
+c03d3e80 d __param_arr_probe_rsa
+c03d3ea0 d serial_pnp_driver
+c03d3f80 d modem_names
+c03d4000 d serial_pci_driver
+c03d4120 d pci_boards
+c03d4820 d pci_serial_quirks
+c03d4a80 d serial_pci_tbl
+c03d5a20 D devices_subsys
+c03d5a8c d ktype_device
+c03d5a98 d devt_attr
+c03d5aac d uevent_attr
+c03d5ac0 d device_uevent_ops
+c03d5acc d dev_sysfs_ops
+c03d5ae0 d system_subsys
+c03d5b4c d sysdev_drivers
+c03d5b60 d sysdev_drivers_lock
+c03d5b80 d ktype_sysdev
+c03d5b8c d ktype_sysdev_class
+c03d5b98 d sysfs_ops
+c03d5ba0 d sysfs_class_ops
+c03d5bc0 d bus_subsys
+c03d5c2c d ktype_driver
+c03d5c38 d driver_attr_bind
+c03d5c4c d driver_attr_unbind
+c03d5c60 d ktype_bus
+c03d5c6c d driver_sysfs_ops
+c03d5c74 d bus_sysfs_ops
+c03d5c7c d probe_waitqueue
+c03d5ca0 d class_subsys
+c03d5d20 d class_obj_subsys
+c03d5d8c d ktype_class_device
+c03d5d98 d class_uevent_attr
+c03d5dac d class_devt_attr
+c03d5dc0 d ktype_class
+c03d5dcc d class_uevent_ops
+c03d5dd8 d class_dev_sysfs_ops
+c03d5de0 d class_sysfs_ops
+c03d5e00 D platform_bus
+c03d5fc0 D platform_bus_type
+c03d61e0 d platform_dev_attrs
+c03d6220 D cpu_sysdev_class
+c03d62a0 d attr_crash_notes
+c03d62c0 d firmware_subsys
+c03d632c d attribute_container_mutex
+c03d6360 D dpm_active
+c03d6368 D dpm_off
+c03d6370 D dpm_off_irq
+c03d6380 D dpm_sem
+c03d63a0 D dpm_list_sem
+c03d63c0 d pm_attr_group
+c03d63c8 d power_attrs
+c03d63d0 d dev_attr_wakeup
+c03d63e4 d pools_lock
+c03d6400 d dev_attr_pools
+c03d6420 d firmware_class
+c03d6564 d class_attr_timeout
+c03d6578 d loading_timeout
+c03d657c d fw_lock
+c03d6598 d dev_attr_loading
+c03d65ac d topology_attr_group
+c03d65b4 d default_attrs
+c03d65c8 d attr_physical_package_id
+c03d65dc d attr_core_id
+c03d65f0 d attr_thread_siblings
+c03d6604 d attr_core_siblings
+c03d6620 D rd_size
+c03d6624 d rd_blocksize
+c03d6640 d rd_bd_op
+c03d6668 d rd_backing_dev_info
+c03d6684 d rd_file_backing_dev_info
+c03d66a0 d __param_str_rd_size
+c03d66ab d __param_str_rd_blocksize
+c03d66c0 d loopback_net_ops
+c03d66e0 d etun_list
+c03d6700 d etun_ethtool_ops
+c03d67a0 d ethtool_stats_keys
+c03d67c0 d __param_str_newif
+c03d67cb d __param_str_delif
+c03d67e0 d driver
+c03d6900 d aec62xx_chipsets
+c03d6a20 d aec62xx_pci_tbl
+c03d6ae0 d driver
+c03d6c00 d ali15x3_chipset
+c03d6c40 d ati_rs100.22479
+c03d6c80 d alim15x3_pci_tbl
+c03d6ce0 d driver
+c03d6e00 d amd74xx_chipsets
+c03d7320 d amd_ide_chips
+c03d7440 d ide_timing
+c03d75e0 d amd74xx_pci_tbl
+c03d7840 d driver
+c03d7960 d atiixp_pci_info
+c03d79d0 d atiixp_lock
+c03d79e0 d atiixp_pci_tbl
+c03d7aa0 d driver
+c03d7bc0 d cmd64x_pci_tbl
+c03d7c60 d driver
+c03d7d80 d cyrix_chipsets
+c03d7e00 d cs5520_pci_tbl
+c03d7e60 d driver
+c03d7f80 d cs5530_chipset
+c03d7fc0 d cs5530_pci_tbl
+c03d8000 d driver
+c03d8120 d cs5535_chipset
+c03d8160 d cs5535_pci_tbl
+c03d81a0 d driver
+c03d82c0 d cy82c693_chipset
+c03d8300 d cy82c693_pci_tbl
+c03d8340 d driver
+c03d8460 d hpt34x_chipset
+c03d84a0 d hpt34x_pci_tbl
+c03d84e0 d driver
+c03d85f0 d hpt372n
+c03d85f8 d hpt374
+c03d8600 d hpt371n
+c03d8608 d hpt371
+c03d8610 d hpt302n
+c03d8618 d hpt302
+c03d8620 d hpt372a
+c03d8640 d bad_ata100_5
+c03d8680 d bad_ata66_4
+c03d86c4 d bad_ata66_3
+c03d86e0 d bad_ata33
+c03d8780 d quirk_drives
+c03d87a0 d hpt366_pci_tbl
+c03d8864 d hpt37x_settings
+c03d8878 d hpt36x
+c03d8880 d hpt370
+c03d8888 d hpt370a
+c03d8890 d hpt372
+c03d88a0 d thirty_three_base_hpt37x
+c03d88e0 d fifty_base_hpt37x
+c03d8920 d sixty_six_base_hpt37x
+c03d895c d hpt36x_settings
+c03d8980 d twenty_five_base_hpt36x
+c03d89c0 d thirty_three_base_hpt36x
+c03d8a00 d forty_base_hpt36x
+c03d8a40 d driver
+c03d8b60 d it821x_chipsets
+c03d8b98 d __param_str_noraid
+c03d8bc0 d it821x_pci_tbl
+c03d8c20 d driver
+c03d8d40 d jmicron_chipsets
+c03d8e60 d jmicron_pci_tbl
+c03d8f20 d driver
+c03d9040 d pdc202xx_chipsets
+c03d9160 d pdc_quirk_drives
+c03d91a0 d pdc202xx_pci_tbl
+c03d9260 d driver
+c03d9380 d pdcnew_chipsets
+c03d9520 d pdc_quirk_drives
+c03d9560 d pdc202new_pci_tbl
+c03d9640 d driver
+c03d9760 d piix_pci_info
+c03d9cd8 d tune_lock.22252
+c03d9d00 d piix_pci_tbl
+c03d9fc0 d driver
+c03da0e0 d rz1000_chipset
+c03da120 d rz1000_pci_tbl
+c03da180 d driver
+c03da2a0 d serverworks_chipsets
+c03da3b8 d svwks_bad_ata100
+c03da3e0 d svwks_pci_tbl
+c03da4a0 d driver
+c03da5c0 d siimage_chipsets
+c03da668 d first.22812
+c03da680 d siimage_pci_tbl
+c03da6c0 d driver
+c03da7e0 d sis5513_chipset
+c03da820 d sis5513_pci_tbl
+c03da8a0 d driver
+c03da9c0 d slc90e66_chipset
+c03daa00 d slc90e66_pci_tbl
+c03daa40 d driver
+c03dab60 d triflex_device
+c03daba0 d triflex_pci_tbl
+c03dabe0 d driver
+c03dad00 d via82cxxx_chipsets
+c03dad80 d ide_timing
+c03daf20 d via_isa_bridges
+c03db040 d via_pci_tbl
+c03db0e0 d driver
+c03db200 d generic_chipsets
+c03db548 d __param_str_all_generic_ide
+c03db560 d generic_pci_tbl
+c03db720 D ide_cfg_sem
+c03db740 D ide_setting_sem
+c03db760 D ide_bus_type
+c03db980 d pci_default.22880
+c03db9b8 d magic_cookie.22869
+c03db9c0 d ide_words.23571
+c03dba20 d ide_dev_attrs
+c03dba80 d ide_pio_blacklist
+c03dbc10 d setup_counts
+c03dbc14 d active_counts
+c03dbc18 d recovery_counts
+c03dbc1c d pre_init
+c03dbc20 d ide_pci_drivers
+c03dbc40 d idedisk_driver
+c03dbd28 d idedisk_ref_mutex
+c03dbd60 d idedisk_ops
+c03dbda0 d ide_cdrom_driver
+c03dbe88 d idecd_ref_mutex
+c03dbec0 d idecd_ops
+c03dbf00 d ide_cdrom_dops
+c03dbf3c d retry.23522
+c03dbf40 d __param_str_ignore
+c03dbf60 d idefloppy_driver
+c03dc048 d idefloppy_ref_mutex
+c03dc080 d idefloppy_ops
+c03dc0c0 d autoclose
+c03dc0c4 d lockdoor
+c03dc0c8 d mrw_format_restart
+c03dc0e0 d cdrom_root_table
+c03dc138 d cdrom_lock
+c03dc148 d __param_str_debug
+c03dc154 d __param_str_autoclose
+c03dc164 d __param_str_autoeject
+c03dc174 d __param_str_lockdoor
+c03dc183 d __param_str_check_media_type
+c03dc19a d __param_str_mrw_format_restart
+c03dc1c0 d cdrom_cdrom_table
+c03dc220 d cdrom_table
+c03dc360 D usbcore_name
+c03dc364 D usb_device_type
+c03dc37c d __param_str_nousb
+c03dc3a0 D ehci_cf_port_reset_rwsem
+c03dc3bc d use_both_schemes
+c03dc3c0 d usb_address0_mutex.18091
+c03dc3dc d hub_event_lock
+c03dc3ec d hub_event_list
+c03dc3f4 d khubd_wait
+c03dc420 d hub_driver
+c03dc524 d device_state_lock
+c03dc534 d __param_str_blinkenlights
+c03dc54a d __param_str_old_scheme_first
+c03dc563 d __param_str_use_both_schemes
+c03dc580 d hub_id_table
+c03dc5bc D usb_bus_list
+c03dc5c4 D usb_bus_list_lock
+c03dc5e0 D usb_kill_urb_queue
+c03dc5f8 d hcd_root_hub_lock
+c03dc608 d hcd_data_lock
+c03dc618 D usb_if_device_type
+c03dc640 D usb_bus_type
+c03dc848 d driver_attr_new_id
+c03dc85c d minor_lock
+c03dc880 d dev_attr_interface
+c03dc894 d intf_attr_grp
+c03dc89c d dev_attr_manufacturer
+c03dc8b0 d dev_attr_product
+c03dc8c4 d dev_attr_serial
+c03dc8d8 d dev_attr_grp
+c03dc8e0 d intf_attrs
+c03dc900 d dev_attrs
+c03dc950 d dev_attr_bInterfaceNumber
+c03dc964 d dev_attr_bAlternateSetting
+c03dc978 d dev_attr_bNumEndpoints
+c03dc98c d dev_attr_bInterfaceClass
+c03dc9a0 d dev_attr_bInterfaceSubClass
+c03dc9b4 d dev_attr_bInterfaceProtocol
+c03dc9c8 d dev_attr_modalias
+c03dc9dc d dev_attr_configuration
+c03dc9f0 d dev_attr_bNumInterfaces
+c03dca04 d dev_attr_bConfigurationValue
+c03dca18 d dev_attr_bmAttributes
+c03dca2c d dev_attr_bMaxPower
+c03dca40 d dev_attr_idVendor
+c03dca54 d dev_attr_idProduct
+c03dca68 d dev_attr_bcdDevice
+c03dca7c d dev_attr_bDeviceClass
+c03dca90 d dev_attr_bDeviceSubClass
+c03dcaa4 d dev_attr_bDeviceProtocol
+c03dcab8 d dev_attr_bNumConfigurations
+c03dcacc d dev_attr_bMaxPacketSize0
+c03dcae0 d dev_attr_speed
+c03dcaf4 d dev_attr_busnum
+c03dcb08 d dev_attr_devnum
+c03dcb1c d dev_attr_version
+c03dcb30 d dev_attr_maxchild
+c03dcb44 d dev_attr_quirks
+c03dcb60 d ep_dev_attr_grp
+c03dcb80 d endpoint_idr
+c03dcba0 d minor_lock.16707
+c03dcbc0 d ep_dev_attrs
+c03dcbe4 d dev_attr_bLength
+c03dcbf8 d dev_attr_bEndpointAddress
+c03dcc0c d dev_attr_bmAttributes
+c03dcc20 d dev_attr_bInterval
+c03dcc34 d dev_attr_wMaxPacketSize
+c03dcc48 d dev_attr_interval
+c03dcc5c d dev_attr_type
+c03dcc70 d dev_attr_direction
+c03dcca0 D usbfs_mutex
+c03dccc0 D usbfs_driver
+c03dcdc4 d usbdev_nb
+c03dcde0 d usb_device_cdev
+c03dce44 d __param_str_usbfs_snoop
+c03dce60 d usb_notifier_list
+c03dce80 D usb_generic_driver
+c03dcf60 d usbfs_nb
+c03dcf80 d usb_fs_type
+c03dcfa0 d usbfs_ops
+c03dcff4 d devmode
+c03dcff6 d busmode
+c03dcff8 d listmode
+c03dd000 d tokens
+c03dd050 d deviceconndiscwq
+c03dd080 D storage_usb_ids
+c03de048 d usu_bias
+c03de060 d usu_driver
+c03de180 d usu_init_notify
+c03de1a0 d usu_lock
+c03de1b0 d usu_end_notify
+c03de1cc d __param_str_bias
+c03de1e0 d serio_bus
+c03de3e8 d serio_mutex
+c03de404 d serio_id_attr_group
+c03de40c d serio_event_lock
+c03de41c d serio_event_list
+c03de424 d serio_wait
+c03de43c d serio_list
+c03de460 d serio_device_attrs
+c03de4e0 d serio_driver_attrs
+c03de51c d serio_device_id_attrs
+c03de530 d dev_attr_type
+c03de544 d dev_attr_proto
+c03de558 d dev_attr_id
+c03de56c d dev_attr_extra
+c03de580 d i8042_blink_frequency
+c03de5a0 d i8042_driver
+c03de67c d i8042_lock
+c03de68c d i8042_command_reg
+c03de690 d i8042_data_reg
+c03de6a0 d i8042_pnp_kbd_driver
+c03de780 d i8042_pnp_aux_driver
+c03de85c d __param_str_nokbd
+c03de868 d __param_str_noaux
+c03de874 d __param_str_nomux
+c03de880 d __param_str_unlock
+c03de88d d __param_str_reset
+c03de899 d __param_str_direct
+c03de8a6 d __param_str_dumbkbd
+c03de8b4 d __param_str_noloop
+c03de8c1 d __param_str_panicblink
+c03de8d2 d __param_str_nopnp
+c03de8de d __param_str_debug
+c03de900 d pnp_kbd_devids
+c03de940 d pnp_aux_devids
+c03de9e0 D input_class
+c03deb24 d input_handlers_seq_ops
+c03deb34 d input_handler_list
+c03deb3c d input_devices_seq_ops
+c03deb4c d input_dev_list
+c03deb54 d input_devices_poll_wait
+c03deb6c d input_dev_attr_groups
+c03deb7c d input_dev_attr_group
+c03deb84 d input_dev_id_attr_group
+c03deb8c d input_dev_caps_attr_group
+c03deb94 d input_dev_attrs
+c03deba8 d input_dev_id_attrs
+c03debc0 d input_dev_caps_attrs
+c03debe8 d class_device_attr_name
+c03debfc d class_device_attr_phys
+c03dec10 d class_device_attr_uniq
+c03dec24 d class_device_attr_modalias
+c03dec38 d class_device_attr_bustype
+c03dec4c d class_device_attr_vendor
+c03dec60 d class_device_attr_product
+c03dec74 d class_device_attr_version
+c03dec88 d class_device_attr_ev
+c03dec9c d class_device_attr_key
+c03decb0 d class_device_attr_rel
+c03decc4 d class_device_attr_abs
+c03decd8 d class_device_attr_msc
+c03decec d class_device_attr_led
+c03ded00 d class_device_attr_snd
+c03ded14 d class_device_attr_ff
+c03ded28 d class_device_attr_sw
+c03ded40 d xres
+c03ded44 d yres
+c03ded48 d tap_time
+c03ded60 d mousedev_handler
+c03ded98 d mousedev_mix_list
+c03deda0 d __param_str_xres
+c03dedae d __param_str_yres
+c03dedbc d __param_str_tap_time
+c03dede0 d evdev_handler
+c03dee20 d atkbd_set
+c03dee24 d atkbd_softraw
+c03dee40 d atkbd_drv
+c03def28 d atkbd_attribute_group
+c03def40 d atkbd_set2_keycode
+c03df140 d atkbd_set3_keycode
+c03df340 d __param_str_set
+c03df34a d __param_str_reset
+c03df356 d __param_str_softrepeat
+c03df367 d __param_str_softraw
+c03df375 d __param_str_scroll
+c03df382 d __param_str_extra
+c03df38e d atkbd_serio_ids
+c03df3a0 d atkbd_attributes
+c03df3bc d atkbd_attr_extra
+c03df3d0 d atkbd_attr_scroll
+c03df3e4 d atkbd_attr_set
+c03df3f8 d atkbd_attr_softrepeat
+c03df40c d atkbd_attr_softraw
+c03df420 d atkbd_attr_err_count
+c03df440 d psmouse_max_proto
+c03df444 d psmouse_resolution
+c03df448 d psmouse_rate
+c03df44c d psmouse_smartscroll
+c03df450 d psmouse_resetafter
+c03df460 d psmouse_drv
+c03df548 d psmouse_mutex
+c03df564 d psmouse_attribute_group
+c03df56c d __param_str_proto
+c03df57a d __param_str_resolution
+c03df58d d __param_str_rate
+c03df59a d __param_str_smartscroll
+c03df5ae d __param_str_resetafter
+c03df5c1 d __param_str_resync_time
+c03df5d5 d psmouse_serio_ids
+c03df5e4 d psmouse_attributes
+c03df600 d psmouse_attr_protocol
+c03df620 d psmouse_attr_rate
+c03df640 d psmouse_attr_resolution
+c03df660 d psmouse_attr_resetafter
+c03df680 d psmouse_attr_resync_time
+c03df6a0 d toshiba_dmi_table
+c03df760 d psmouse_attr_smartscroll
+c03df780 d lifebook_dmi_table
+c03df940 d trackpoint_attr_group
+c03df960 d trackpoint_attrs
+c03df9a0 d psmouse_attr_sensitivity
+c03df9c0 d psmouse_attr_speed
+c03df9e0 d psmouse_attr_inertia
+c03dfa00 d psmouse_attr_reach
+c03dfa20 d psmouse_attr_draghys
+c03dfa40 d psmouse_attr_mindrag
+c03dfa60 d psmouse_attr_thresh
+c03dfa80 d psmouse_attr_upthresh
+c03dfaa0 d psmouse_attr_ztime
+c03dfac0 d psmouse_attr_jenks
+c03dfae0 d psmouse_attr_press_to_select
+c03dfb00 d psmouse_attr_skipback
+c03dfb20 d psmouse_attr_ext_dev
+c03dfb40 d trackpoint_attr_sensitivity
+c03dfb48 d trackpoint_attr_speed
+c03dfb50 d trackpoint_attr_inertia
+c03dfb58 d trackpoint_attr_reach
+c03dfb60 d trackpoint_attr_draghys
+c03dfb68 d trackpoint_attr_mindrag
+c03dfb70 d trackpoint_attr_thresh
+c03dfb78 d trackpoint_attr_upthresh
+c03dfb80 d trackpoint_attr_ztime
+c03dfb88 d trackpoint_attr_jenks
+c03dfb90 d trackpoint_attr_press_to_select
+c03dfb98 d trackpoint_attr_skipback
+c03dfba0 d trackpoint_attr_ext_dev
+c03dfba8 D __i2c_board_lock
+c03dfbc4 D __i2c_board_list
+c03dfbe0 d linear_personality
+c03dfc40 d md_notifier
+c03dfc60 d raid_root_table
+c03dfcb8 d sysctl_speed_limit_min
+c03dfcbc d sysctl_speed_limit_max
+c03dfcc0 d all_mddevs_lock
+c03dfcd0 d all_mddevs
+c03dfcd8 d md_redundancy_group
+c03dfce0 d md_seq_ops
+c03dfcf0 d pers_lock
+c03dfd00 d pers_list
+c03dfd08 d pending_raid_disks
+c03dfd10 d md_event_waiters
+c03dfd40 d md_fops
+c03dfd68 d md_ktype
+c03dfd74 d disks_mutex.24027
+c03dfda0 d array_states
+c03dfdc8 d rdev_ktype
+c03dfdd4 d resync_wait
+c03dfdec d __param_str_start_ro
+c03dfdfc d __param_str_start_dirty_degraded
+c03dfe20 d raid_dir_table
+c03dfe80 d md_redundancy_attrs
+c03dfea8 d md_sysfs_ops
+c03dfec0 d md_default_attrs
+c03dfef0 d rdev_sysfs_ops
+c03dfef8 d rdev_default_attrs
+c03dff20 d raid_table
+c03dffa4 d md_scan_mode
+c03dffb8 d md_mismatches
+c03dffcc d md_sync_min
+c03dffe0 d md_sync_max
+c03dfff4 d md_sync_speed
+c03e0008 d md_sync_completed
+c03e001c d md_suspend_lo
+c03e0030 d md_suspend_hi
+c03e0044 d md_bitmap
+c03e0058 d md_level
+c03e006c d md_layout
+c03e0080 d md_raid_disks
+c03e0094 d md_chunk_size
+c03e00a8 d md_size
+c03e00bc d md_resync_start
+c03e00d0 d md_metadata
+c03e00e4 d md_new_device
+c03e00f8 d md_safe_delay
+c03e010c d md_array_state
+c03e0120 d md_reshape_position
+c03e0134 d rdev_state
+c03e0148 d rdev_super
+c03e015c d rdev_errors
+c03e0170 d rdev_slot
+c03e0184 d rdev_offset
+c03e0198 d rdev_size
+c03e01c0 D _exits
+c03e01d8 d _minor_lock
+c03e0200 d _minor_idr
+c03e0220 d dm_blk_dops
+c03e0248 d __param_str_major
+c03e0258 d _event_lock
+c03e0280 d error_target
+c03e02c4 d _lock
+c03e02e0 d _targets
+c03e0300 d linear_target
+c03e0360 d stripe_target
+c03e03a4 d _dm_misc
+c03e03c0 d _hash_lock
+c03e03dc d _client_lock
+c03e03f8 d kcopyd_init_lock
+c03e0414 d _complete_jobs
+c03e041c d _io_jobs
+c03e0424 d _pages_jobs
+c03e042c d _job_lock
+c03e043c d _clients
+c03e0460 d dmi_devices
+c03e0480 d efi_subsys
+c03e0500 d vars_subsys
+c03e056c d efivars_lock
+c03e057c d efivar_list
+c03e0584 d ktype_efivar
+c03e0590 d var_subsys_attr_new_var
+c03e05a4 d var_subsys_attr_del_var
+c03e05b8 d efi_attr_systab
+c03e05cc d efivar_attr_ops
+c03e05d4 d def_attrs
+c03e05ec d efivar_attr_guid
+c03e0600 d efivar_attr_size
+c03e0614 d efivar_attr_attributes
+c03e0628 d efivar_attr_data
+c03e063c d efivar_attr_raw_var
+c03e0680 d clocksource_cyclone
+c03e0780 d clocksource_acpi_pm
+c03e0880 d dma_list_mutex
+c03e08a0 d dma_devclass
+c03e09e4 d dma_client_list
+c03e09ec d dma_device_list
+c03e0a00 d dma_class_attrs
+c03e0a60 d __param_str_pb_fnmode
+c03e0a70 d hid_pb_fnmode
+c03e0a80 d hid_driver
+c03e0b84 d __param_str_mousepoll
+c03e0b95 d __param_str_quirks
+c03e0ba4 d __param_arr_quirks
+c03e0bc0 d hid_usb_ids
+c03e0be8 d dquirks_rwsem
+c03e0c04 d dquirks_list
+c03e0c20 D pcibios_max_latency
+c03e0c24 d bios32_indirect
+c03e0c2c d pci_bios_access
+c03e0c34 d pci_indirect
+c03e0c3c d pci_mmcfg
+c03e0c44 D pci_direct_conf1
+c03e0c4c d pci_direct_conf2
+c03e0c60 d toshiba_ohci1394_dmi_table
+c03e0d10 d quirk_pcie_aspm_ops
+c03e0d20 D pcibios_irq_mask
+c03e0d40 d pirq_penalty
+c03e0d80 D pci_probe
+c03e0d84 D pcibios_last_bus
+c03e0d88 D pci_root_ops
+c03e0d90 D pci_config_lock
+c03e0da0 d pciprobe_dmi_table
+c03e10c0 d sock_fs_type
+c03e10e0 d sock_net_ops
+c03e1100 d sockfs_ops
+c03e1154 d net_family_lock
+c03e1164 d br_ioctl_mutex
+c03e1180 d vlan_ioctl_mutex
+c03e119c d dlci_ioctl_mutex
+c03e11b8 d sockfs_dentry_operations
+c03e11e0 d proto_list
+c03e11e8 d proto_list_lock
+c03e11f8 D sysctl_max_syn_backlog
+c03e11fc d est_lock
+c03e120c D net_namespace_list
+c03e1214 d net_mutex
+c03e1230 d pernet_list
+c03e1238 d first_device
+c03e123c d net_list_mutex
+c03e1260 D core_table
+c03e1480 D multi_core_table
+c03e15a0 D dev_base_lock
+c03e15b0 d dev_boot_phase
+c03e15b4 d netdev_net_ops
+c03e15c4 d default_device_ops
+c03e15d4 d dev_proc_ops
+c03e1600 d net_dma
+c03e1664 d net_todo_list_lock
+c03e1674 d net_todo_list
+c03e167c d net_todo_run_mutex
+c03e1698 d ptype_lock
+c03e16a8 d dev_mc_net_ops
+c03e16b8 d dst_dev_notifier
+c03e16c4 d dst_lock
+c03e16d4 d dst_gc_timer_inc
+c03e16d8 d dst_gc_timer
+c03e16f0 d netevent_notif_chain
+c03e1704 d neigh_tbl_lock
+c03e1714 d rtnetlink_net_ops
+c03e1724 d rtnetlink_dev_notifier
+c03e1730 d rtnl_mutex
+c03e174c d link_ops
+c03e1760 d lweventlist_lock
+c03e1780 d linkwatch_work
+c03e17a8 d flow_flush_sem.23195
+c03e17e0 d net_class
+c03e1924 d netstat_group
+c03e192c d wireless_group
+c03e1940 d net_class_attributes
+c03e1a80 d netstat_attrs
+c03e1ae0 d wireless_attrs
+c03e1b0c d dev_attr_rx_packets
+c03e1b20 d dev_attr_tx_packets
+c03e1b34 d dev_attr_rx_bytes
+c03e1b48 d dev_attr_tx_bytes
+c03e1b5c d dev_attr_rx_errors
+c03e1b70 d dev_attr_tx_errors
+c03e1b84 d dev_attr_rx_dropped
+c03e1b98 d dev_attr_tx_dropped
+c03e1bac d dev_attr_multicast
+c03e1bc0 d dev_attr_collisions
+c03e1bd4 d dev_attr_rx_length_errors
+c03e1be8 d dev_attr_rx_over_errors
+c03e1bfc d dev_attr_rx_crc_errors
+c03e1c10 d dev_attr_rx_frame_errors
+c03e1c24 d dev_attr_rx_fifo_errors
+c03e1c38 d dev_attr_rx_missed_errors
+c03e1c4c d dev_attr_tx_aborted_errors
+c03e1c60 d dev_attr_tx_carrier_errors
+c03e1c74 d dev_attr_tx_fifo_errors
+c03e1c88 d dev_attr_tx_heartbeat_errors
+c03e1c9c d dev_attr_tx_window_errors
+c03e1cb0 d dev_attr_rx_compressed
+c03e1cc4 d dev_attr_tx_compressed
+c03e1cd8 d dev_attr_status
+c03e1cec d dev_attr_link
+c03e1d00 d dev_attr_level
+c03e1d14 d dev_attr_noise
+c03e1d28 d dev_attr_nwid
+c03e1d3c d dev_attr_crypt
+c03e1d50 d dev_attr_fragment
+c03e1d64 d dev_attr_retries
+c03e1d78 d dev_attr_misc
+c03e1d8c d dev_attr_beacon
+c03e1da0 D sysctl_tcp_dma_copybreak
+c03e1da4 d fib_rules_net_ops
+c03e1db4 d fib_rules_notifier
+c03e1dc0 D noop_qdisc_ops
+c03e1e20 D noop_qdisc
+c03e1ec0 d pfifo_fast_ops
+c03e1f20 d noqueue_qdisc
+c03e1fc0 d noqueue_qdisc_ops
+c03e2008 d qdisc_mod_lock
+c03e2018 d autohandle.26693
+c03e2020 d blackhole_qdisc_ops
+c03e2068 d cls_mod_lock
+c03e2080 D pfifo_qdisc_ops
+c03e20e0 D bfifo_qdisc_ops
+c03e2140 d netlink_proto
+c03e29f0 d netlink_family_ops
+c03e29fc d netlink_net_ops
+c03e2a0c d netlink_seq_ops
+c03e2a1c d nl_table_lock
+c03e2a2c d nl_table_wait
+c03e2a44 d rover.27150
+c03e2a48 d netlink_chain
+c03e2a60 d genl_ctrl
+c03e2aa0 d genl_ctrl_ops
+c03e2ac0 d genl_mutex
+c03e2ae0 d netfilter_proc_ops
+c03e2af0 d nf_hook_mutex
+c03e2b0c d afinfo_mutex
+c03e2b28 d nflog_seq_ops
+c03e2b38 d nf_log_mutex
+c03e2b54 d nfqueue_seq_ops
+c03e2b64 d queue_handler_lock
+c03e2b74 d nf_sockopt_mutex
+c03e2b90 d nf_sockopts
+c03e2ba0 D nf_net_netfilter_sysctl_path
+c03e2c00 D nf_net_ipv4_netfilter_sysctl_path
+c03e2c60 d nf_net_netfilter_table
+c03e2cc0 d nf_net_ipv4_table
+c03e2d20 d nf_net_ipv4_netfilter_table
+c03e2d80 D ip_tos2prio
+c03e2da0 D ipv4_route_table
+c03e3110 D ip_rt_net_ops
+c03e3120 d ip_rt_min_delay
+c03e3124 d ip_rt_max_delay
+c03e3140 d ipv4_dst_ops
+c03e3170 d ip_rt_gc_min_interval
+c03e3174 d ip_rt_gc_timeout
+c03e3178 d ip_rt_gc_interval
+c03e317c d ip_rt_redirect_load
+c03e3180 d ip_rt_redirect_number
+c03e3184 d ip_rt_redirect_silence
+c03e3188 d ip_rt_error_cost
+c03e318c d ip_rt_error_burst
+c03e3190 d ip_rt_gc_elasticity
+c03e3194 d ip_rt_mtu_expires
+c03e3198 d ip_rt_min_pmtu
+c03e319c d ip_rt_min_advmss
+c03e31a0 d ip_rt_secret_interval
+c03e31a4 d expire.35644
+c03e31c0 d ipv4_dst_blackhole_ops
+c03e31f0 d ip_fb_id_lock.35856
+c03e3200 d rt_peer_lock.35846
+c03e3210 d rt_flush_lock
+c03e3220 D inet_peer_idlock
+c03e3230 d inet_peer_unused_lock
+c03e3240 d peer_pool_lock
+c03e3260 d peer_fake_node
+c03e328c d inet_peers_net_ops
+c03e329c d inet_proto_lock
+c03e32ac d ipfrag_net_ops
+c03e32bc d ipfrag_lock
+c03e32cc D ip_ra_lock
+c03e32dc d tcp_net_ops
+c03e3300 D ipv4_specific
+c03e3340 D tcp_prot
+c03e3bf0 d tcp4_proc_net_ops
+c03e3c00 d tcp4_seq_afinfo
+c03e3c14 d tcp_timewait_sock_ops
+c03e3c40 D tcp_death_row
+c03e3d60 D tcp_reno
+c03e3dc0 D tcp_init_congestion_ops
+c03e3e08 d tcp_cong_list
+c03e3e10 d tcp_cong_list_lock
+c03e3e20 D raw_v4_lock
+c03e3e40 D raw_prot
+c03e46f0 d raw_proc_net_ops
+c03e4700 D udp_hash_lock
+c03e4720 D udp_prot
+c03e4fd0 d udp4_proc_net_ops
+c03e4fe0 d udp4_seq_afinfo
+c03e5000 D udplite_prot
+c03e58b0 d udplite_protocol
+c03e58c4 d udplite4_protosw
+c03e58e0 d udplite4_seq_afinfo
+c03e5900 D arp_broken_ops
+c03e5920 D arp_tbl
+c03e5a40 d arp_direct_ops
+c03e5a5c d arp_hh_ops
+c03e5a78 d arp_generic_ops
+c03e5aa0 d arp_packet_type
+c03e5ac0 d arp_net_ops
+c03e5ad0 d arp_netdev_notifier
+c03e5ae0 D icmp_err_convert
+c03e5b60 D sysctl_icmp_ipod_version
+c03e5b64 D sysctl_icmp_ipod_host
+c03e5b68 D sysctl_icmp_ipod_mask
+c03e5b80 D sysctl_icmp_ipod_key
+c03e5ba4 d icmp_net_ops
+c03e5bc0 d devinet_net_ops
+c03e5bd0 d ip_netdev_notifier
+c03e5be0 d inetaddr_chain
+c03e5c00 d devinet_sysctl
+c03e6140 d ipv4_devconf_template
+c03e61a0 d ipv4_devconf_dflt_template
+c03e6200 d inet_net_ops
+c03e6210 d inet_family_ops
+c03e621c d icmp_protocol
+c03e6230 d udp_protocol
+c03e6244 d tcp_protocol
+c03e6260 d inetsw_array
+c03e62c0 d ip_packet_type
+c03e62e0 d inetsw_lock
+c03e6300 D ipv4_table
+c03e6d00 D multi_ipv4_table
+c03e7070 d tcp_retr1_max
+c03e7074 d ip_local_port_range_min
+c03e707c d ip_local_port_range_max
+c03e7084 d fib_net_ops
+c03e7094 d fib_netdev_notifier
+c03e70a0 d fib_inetaddr_notifier
+c03e70ac d fib_info_lock
+c03e70bc d fib_hash_lock
+c03e70e0 d fib4_rule_table
+c03e7254 d tunnel4_protocol
+c03e7268 d tunnel64_protocol
+c03e727c d tunnel4_mutex
+c03e7298 d nf_ip_afinfo
+c03e72c0 d cubictcp
+c03e7308 d __param_str_fast_convergence
+c03e7323 d __param_str_max_increment
+c03e733b d __param_str_beta
+c03e734a d __param_str_initial_ssthresh
+c03e7365 d __param_str_bic_scale
+c03e7379 d __param_str_tcp_friendliness
+c03e73a0 d xfrm4_policy_afinfo
+c03e77e0 d xfrm4_dst_ops
+c03e7810 d xfrm4_state_afinfo
+c03e7840 D xfrm_cfg_mutex
+c03e785c d xfrm_dev_notifier
+c03e7868 d xfrm_policy_lock
+c03e7878 d xfrm_policy_gc_lock
+c03e7888 d xfrm_policy_afinfo_lock
+c03e7898 d xfrm_hash_work
+c03e78a8 d hash_resize_mutex
+c03e78c4 D km_waitq
+c03e78dc d xfrm_state_net_ops
+c03e78ec d xfrm_state_gc_lock
+c03e78fc d xfrm_state_afinfo_lock
+c03e790c d xfrm_km_lock
+c03e791c d xfrm_km_list
+c03e7924 d xfrm_state_lock
+c03e7934 d acqseq_lock.31437
+c03e7944 d xfrm_hash_work
+c03e7954 d hash_resize_mutex
+c03e7980 d ealg_list
+c03e7a60 d aalg_list
+c03e7b00 d calg_list
+c03e7b60 D unix_table_lock
+c03e7b80 d unix_proto
+c03e8430 d unix_family_ops
+c03e843c d unix_net_ops
+c03e844c d unix_seq_ops
+c03e845c d ordernum.26955
+c03e8460 d unix_gc_sem.25955
+c03e847c d gc_current
+c03e8480 d unix_sysctl
+c03e85a0 d rawv6_protosw
+c03e85bc d inet6_family_ops
+c03e85c8 d inetsw6_lock
+c03e85d8 d ac6_seq_ops
+c03e85e8 d ipv6_sk_ac_lock
+c03e85f8 d ip6_id_lock.31143
+c03e8608 d ipv6_fragmentation_id.31142
+c03e860c d ipv6_dev_notf
+c03e8618 d addrconf_hash_lock
+c03e8628 d addr_chk_timer
+c03e8640 d addrconf_verify_lock
+c03e8650 d inet6addr_chain
+c03e8664 d if6_seq_ops
+c03e8680 D ip6_rt_gc_interval
+c03e86a0 D ip6_null_entry
+c03e8780 D ipv6_route_table
+c03e8980 d ip6_dst_ops
+c03e89b0 d ip6_rt_max_size
+c03e89b4 d ip6_rt_gc_min_interval
+c03e89b8 d ip6_rt_gc_timeout
+c03e89bc d ip6_rt_gc_elasticity
+c03e89c0 d ip6_rt_mtu_expires
+c03e89c4 d ip6_rt_min_advmss
+c03e89c8 d expire.34552
+c03e89e0 d ip6_dst_blackhole_ops
+c03e8a10 d ndisc_lock
+c03e8a20 d ip6_fib_timer
+c03e8a40 d fib6_main_tbl
+c03e8a78 d fib6_walker_lock
+c03e8aa0 d fib6_walker_list
+c03e8ac0 d fib6_gc_lock
+c03e8ae0 D ip6_ra_lock
+c03e8b00 d ipv6_packet_type
+c03e8b20 D nd_tbl
+c03e8c40 d ndisc_direct_ops
+c03e8c5c d ndisc_hh_ops
+c03e8c78 d ndisc_generic_ops
+c03e8c94 d ndisc_netdev_notifier
+c03e8ca0 D udpv6_prot
+c03e9550 d udpv6_protocol
+c03e9564 d udpv6_protosw
+c03e9580 d udp6_seq_afinfo
+c03e95a0 D udplitev6_prot
+c03e9e50 d udplite6_seq_afinfo
+c03e9e68 d udplitev6_protocol
+c03e9e7c d udplite6_protosw
+c03e9ea0 D raw_v6_lock
+c03e9ec0 D rawv6_prot
+c03ea770 d raw6_seq_ops
+c03ea780 d inet6_proto_lock
+c03ea7a0 D ipv6_icmp_table
+c03ea7f8 d icmpv6_protocol
+c03ea80c d igmp6_mcf_seq_ops
+c03ea81c d igmp6_mc_seq_ops
+c03ea82c d mld2_all_mcr
+c03ea83c d ipv6_sk_mc_lock
+c03ea84c d frag_protocol
+c03ea860 d ip6_frag_lock
+c03ea870 d ip6_frag_lru_list
+c03ea880 D tcpv6_prot
+c03eb140 d ipv6_mapped
+c03eb180 d ipv6_specific
+c03eb1b0 d tcpv6_protocol
+c03eb1c4 d tcpv6_protosw
+c03eb1e0 d tcp6_seq_afinfo
+c03eb1f4 d tcp6_timewait_sock_ops
+c03eb204 d tlvprochopopt_lst
+c03eb21c d rthdr_protocol
+c03eb230 d nodata_protocol
+c03eb244 d destopt_protocol
+c03eb258 d tlvprocdestopt_lst
+c03eb260 d ipv6_root_table
+c03eb2c0 d ipv6_net_table
+c03eb320 d ipv6_table
+c03eb4ac d ip6_fl_gc_timer
+c03eb4c4 d ip6_fl_lock
+c03eb4d4 d ip6fl_seq_ops
+c03eb4e4 d ip6_sk_fl_lock
+c03eb500 d xfrm6_policy_afinfo
+c03eb940 d xfrm6_dst_ops
+c03eb970 d xfrm6_state_afinfo
+c03eb988 d nf_ip6_afinfo
+c03eb9a0 d snmp6_ipstats_list
+c03eba60 d snmp6_icmp6_list
+c03ebb60 d snmp6_udp6_list
+c03ebba0 d snmp6_udplite6_list
+c03ebbc8 d xfrm6_transport_mode
+c03ebbd8 d xfrm6_tunnel_mode
+c03ebbe8 d xfrm6_beet_mode
+c03ebbf8 d sit_handler
+c03ebc08 d ipip6_lock
+c03ebc20 d packet_proto
+c03ec4d0 d packet_family_ops
+c03ec4dc d packet_net_ops
+c03ec4ec d packet_netdev_notifier
+c03ec4f8 d packet_seq_ops
+c03ec508 d packet_mmap_ops
+c03ec524 d wireless_nlevent_tasklet
+c03ec540 D net_table
+c03ec5e0 D multi_net_table
+c03ec680 D net_root_table
+c03ed000 D __nosave_begin
+c03ed000 D __nosave_end
+c03ed000 D idt_table
+c03ed800 D cpu_data
+c03ee800 D doublefault_tss
+c03f0a00 D tasklist_lock
+c03f0a80 D mmlist_lock
+c03f0b00 d softirq_vec
+c03f0c00 D jiffies
+c03f0c00 D jiffies_64
+c03f0c80 d pidmap_lock
+c03f0d00 V xtime_lock
+c03f0d80 d acct_globals
+c03f0e00 D irq_desc
+c03f7e00 d dirty_exceeded
+c03f7e80 d kmap_lock
+c03f7f00 D files_lock
+c03f7f80 d nr_files
+c03f8000 D dcache_lock
+c03f8080 d rename_lock
+c03f8100 D vfsmount_lock
+c03f8180 d bdev_lock
+c03f8200 D ide_lock
+c03f8280 D tcp_hashinfo
+c03f8400 D __per_cpu_offset
+c03f8480 d hardirq_ctx
+c03f84c0 d softirq_ctx
+c03f8500 D boot_cpu_data
+c03f8600 d mxcsr_feature_mask
+c03f8604 d cyc2ns_scale
+c03f8680 D movsl_mask
+c03f8700 D x86_cpu_to_apicid
+c03f8710 D cpu_2_logical_apicid
+c03f8720 D cpu_online_map
+c03f8740 D cpu_sibling_map
+c03f8780 D cpu_core_map
+c03f87c0 d irq_vector
+c03f89c0 d ioapic_chip
+c03f8a00 d lapic_chip
+c03f8a40 D vdso_enabled
+c03f8a48 D __supported_pte_mask
+c03f8a50 D nr_cpu_ids
+c03f8a54 D cpu_present_map
+c03f8a58 d ignore_loglevel
+c03f8a5c D prof_on
+c03f8a60 D timer_hook
+c03f8a64 d singlethread_cpu
+c03f8a68 d cpu_singlethread_map
+c03f8a6c d cpu_populated_map
+c03f8a70 d keventd_wq
+c03f8a74 D tick_do_timer_cpu
+c03f8a78 d irqfixup
+c03f8a7c D noirqdebug
+c03f8a80 D node_online_map
+c03f8a84 D node_possible_map
+c03f8a88 D totalram_pages
+c03f8a8c D totalreserve_pages
+c03f8a90 d kswapd_min_order
+c03f8a94 D sysctl_stat_interval
+c03f8a98 D totalhigh_pages
+c03f8a9c D randomize_va_space
+c03f8aa0 D sysctl_max_map_count
+c03f8aa4 d shmem_backing_dev_info
+c03f8ac0 d use_alien_caches
+c03f8ae0 d pipe_mnt
+c03f8ae4 d fasync_cache
+c03f8ae8 d filelock_cache
+c03f8aec D sysctl_vfs_cache_pressure
+c03f8af0 d dentry_cache
+c03f8af4 d d_hash_mask
+c03f8af8 d d_hash_shift
+c03f8afc d dentry_hashtable
+c03f8b00 D names_cachep
+c03f8b04 D filp_cachep
+c03f8b08 d i_hash_mask
+c03f8b0c d i_hash_shift
+c03f8b10 d inode_hashtable
+c03f8b14 d inode_cachep
+c03f8b18 d mount_hashtable
+c03f8b1c d hash_mask
+c03f8b20 d hash_bits
+c03f8b24 d mnt_cache
+c03f8b40 d bvec_slabs
+c03f8b88 d bio_slab
+c03f8b8c D bio_split_pool
+c03f8b90 d bdev_cachep
+c03f8b94 d bd_mnt
+c03f8b98 d watch_cachep
+c03f8b9c d event_cachep
+c03f8ba0 d inotify_mnt
+c03f8ba4 D inotify_max_user_instances
+c03f8ba8 D inotify_max_user_watches
+c03f8bac D inotify_max_queued_events
+c03f8bb0 d epi_cache
+c03f8bb4 d pwq_cache
+c03f8bb8 d anon_inode_mnt
+c03f8bbc D dir_notify_enable
+c03f8bc0 d dn_cache
+c03f8bc4 d dcookie_cache
+c03f8bc8 d dcookie_hashtable
+c03f8bcc d hash_size
+c03f8be0 d blktrace_seq
+c03f8be4 d ddir_act
+c03f8c00 d bio_act
+c03f8c24 d height_to_maxindex
+c03f8c40 d vga_hardscroll_user_enable
+c03f8c44 d vga_init_done
+c03f8c48 d vga_vram_base
+c03f8c4c d vga_vram_end
+c03f8c50 d vga_vram_size
+c03f8c54 d vga_video_port_reg
+c03f8c56 d vga_video_port_val
+c03f8c58 d vga_can_do_color
+c03f8c5c d vga_default_font_height
+c03f8c60 d vga_video_type
+c03f8c61 d vga_hardscroll_enabled
+c03f8c64 d vga_scan_lines
+c03f8c68 d trickle_thresh
+c03f8c6c D __sysrq_enabled
+c03f8c70 d sysrq_always_enabled
+c03f8c74 D pmtmr_ioport
+c03f8c80 d net_families
+c03f8d08 d sock_inode_cachep
+c03f8d0c d sock_mnt
+c03f8d20 D sysctl_wmem_max
+c03f8d24 D sysctl_rmem_max
+c03f8d28 D sysctl_wmem_default
+c03f8d2c D sysctl_rmem_default
+c03f8d30 D sysctl_optmem_max
+c03f8d34 d skbuff_head_cache
+c03f8d38 d skbuff_fclone_cache
+c03f8d40 D netdev_max_backlog
+c03f8d44 D netdev_budget
+c03f8d48 D weight_p
+c03f8d60 d ptype_base
+c03f8de0 d ptype_all
+c03f8e00 d neigh_sysctl_template
+c03f92a8 D net_msg_cost
+c03f92ac D net_msg_burst
+c03f92b0 D net_msg_warn
+c03f92b4 d flow_cachep
+c03f92b8 d nla_attr_minlen
+c03f92e0 D nf_hooks
+c03f9b60 D nf_afinfo
+c03f9be8 d peer_cachep
+c03f9bec D ip_statistics
+c03f9bf4 D sysctl_tcp_fin_timeout
+c03f9bf8 D sysctl_tcp_mem
+c03f9c04 D sysctl_tcp_wmem
+c03f9c10 D sysctl_tcp_rmem
+c03f9c1c D tcp_memory_pressure
+c03f9c20 D tcp_statistics
+c03f9c28 D sysctl_tcp_sack
+c03f9c2c D sysctl_tcp_fack
+c03f9c30 D sysctl_tcp_reordering
+c03f9c34 D sysctl_tcp_dsack
+c03f9c38 D sysctl_tcp_app_win
+c03f9c3c D sysctl_tcp_adv_win_scale
+c03f9c40 D sysctl_tcp_max_orphans
+c03f9c44 D sysctl_tcp_moderate_rcvbuf
+c03f9c48 D sysctl_tcp_stdurg
+c03f9c4c D sysctl_tcp_rfc1337
+c03f9c50 D sysctl_tcp_ecn
+c03f9c54 D sysctl_tcp_frto
+c03f9c58 D sysctl_tcp_frto_response
+c03f9c5c D sysctl_tcp_nometrics_save
+c03f9c60 D sysctl_tcp_abc
+c03f9c64 D sysctl_tcp_retrans_collapse
+c03f9c68 D sysctl_tcp_workaround_signed_windows
+c03f9c6c D sysctl_tcp_tso_win_divisor
+c03f9c70 D sysctl_tcp_mtu_probing
+c03f9c74 D sysctl_tcp_base_mss
+c03f9c78 D sysctl_tcp_slow_start_after_idle
+c03f9c7c D sysctl_tcp_syn_retries
+c03f9c80 D sysctl_tcp_synack_retries
+c03f9c84 D sysctl_tcp_keepalive_time
+c03f9c88 D sysctl_tcp_keepalive_probes
+c03f9c8c D sysctl_tcp_keepalive_intvl
+c03f9c90 D sysctl_tcp_retries1
+c03f9c94 D sysctl_tcp_retries2
+c03f9c98 D sysctl_tcp_orphan_retries
+c03f9c9c D tcp_request_sock_ops
+c03f9cb8 d tcp_socket
+c03f9cbc D sysctl_tcp_tw_reuse
+c03f9cc0 D sysctl_tcp_low_latency
+c03f9cc4 D sysctl_tcp_syncookies
+c03f9cc8 D sysctl_tcp_abort_on_overflow
+c03f9ccc D udp_statistics
+c03f9cd4 D udplite_statistics
+c03f9cdc D sysctl_icmp_echo_ignore_broadcasts
+c03f9ce0 D sysctl_icmp_ignore_bogus_error_responses
+c03f9ce4 D sysctl_icmp_ratelimit
+c03f9ce8 D sysctl_icmp_ratemask
+c03f9cec D icmp_statistics
+c03f9cf4 D sysctl_icmp_echo_ignore_all
+c03f9cf8 D sysctl_icmp_errors_use_inbound_ifaddr
+c03f9cfc D inet_ehash_secret
+c03f9d00 D net_statistics
+c03f9d08 D sysctl_igmp_max_memberships
+c03f9d0c D sysctl_igmp_max_msf
+c03f9d10 d fn_hash_kmem
+c03f9d14 d fn_alias_kmem
+c03f9d18 d fast_convergence
+c03f9d1c d max_increment
+c03f9d20 d beta
+c03f9d24 d bic_scale
+c03f9d28 d tcp_friendliness
+c03f9d2c d initial_ssthresh
+c03f9d30 d cube_rtt_scale
+c03f9d34 d beta_scale
+c03f9d38 d cube_factor
+c03f9d40 d xfrm_policy_hashmax
+c03f9d44 d xfrm_dst_cache
+c03f9d60 d xfrm_policy_bydst
+c03f9d90 d xfrm_policy_byidx
+c03f9d94 d xfrm_idx_hmask
+c03f9d98 d xfrm_state_hashmax
+c03f9d9c d xfrm_state_bydst
+c03f9da0 d xfrm_state_bysrc
+c03f9da4 d xfrm_state_byspi
+c03f9da8 d xfrm_state_hmask
+c03f9dac d secpath_cachep
+c03f9dc0 D sysctl_ipv6_bindv6only
+c03f9de0 D ipv6_devconf
+c03f9e40 d ipv6_devconf_dflt
+c03f9ea0 d addrconf_sysctl
+c03fa47c d fib6_node_kmem
+c03fa480 D ipv6_statistics
+c03fa488 D udp_stats_in6
+c03fa490 D udplite_stats_in6
+c03fa498 d sysctl_icmpv6_time
+c03fa49c D icmpv6_statistics
+c03fa4a4 D sysctl_mld_max_msf
+c03fa4a8 D sysctl_ip6frag_high_thresh
+c03fa4ac D sysctl_ip6frag_low_thresh
+c03fa4b0 D sysctl_ip6frag_time
+c03fa4b4 D sysctl_ip6frag_secret_interval
+c03fa4b8 d tcp6_request_sock_ops
+c03fa4d4 D _edata
+c03fb000 D init_thread_union
+c03fc000 R __smp_locks
+c03ffc6c R __smp_locks_end
+c0400000 T __init_begin
+c0400000 T _sinittext
+c0400000 T startup_32_smp
+c0400080 t checkCPUtype
+c0400101 t is486
+c0400108 t is386
+c0400173 t check_x87
+c040019a t setup_idt
+c04001b7 t rp_sidt
+c040023b t early_divide_err
+c0400241 t early_illegal_opcode
+c040024a t early_protection_fault
+c0400251 t early_page_fault
+c0400258 t early_fault
+c0400280 t hlt_loop
+c0400284 t ignore_int
+c04002c5 t nosmp
+c04002d5 t set_reset_devices
+c04002e5 t debug_kernel
+c04002fb t quiet_kernel
+c0400311 t init_setup
+c040032f t rdinit_setup
+c040034d W smp_setup_processor_id
+c040034e t initcall_debug_setup
+c040035e t loglevel
+c0400377 t maxcpus
+c0400390 t do_early_param
+c04003f3 T parse_early_param
+c0400440 t unknown_bootoption
+c0400642 t kernel_init
+c04008e9 T start_kernel
+c0400bf5 t readonly
+c0400c08 t readwrite
+c0400c1b t root_data_setup
+c0400c26 t fs_names_setup
+c0400c31 t root_delay_setup
+c0400c45 t root_dev_setup
+c0400c5c t load_ramdisk
+c0400c73 T change_floppy
+c0400d85 T mount_block_root
+c0400fb5 T mount_root
+c040100f T prepare_namespace
+c0401151 t ramdisk_start_setup
+c0401165 t prompt_ramdisk
+c040117c t error
+c04011a6 t fill_inbuf
+c0401201 t flush_window
+c04012aa t free
+c04012af t huft_free
+c04012c5 t inflate_codes
+c04016e3 t malloc
+c04016ed t huft_build
+c0401c5c t inflate_dynamic
+c04021b3 t inflate_fixed
+c0402321 T rd_load_image
+c04031e1 T rd_load_disk
+c0403292 t no_initrd
+c04032a2 T initrd_load
+c0403605 t do_linuxrc
+c0403697 t md_setup
+c040384f T md_run_setup
+c0403dad t raid_setup
+c0403eaa t read_into
+c0403f0c t do_start
+c0403f23 t write_buffer
+c0403f4b t flush_window
+c0403ffa t retain_initrd_param
+c0404010 t inflate_codes
+c0404400 t malloc
+c040440a t clean_path
+c0404458 t do_symlink
+c04044d4 t maybe_link
+c04045bc t free
+c04045c1 t huft_free
+c04045d7 t huft_build
+c0404b46 t inflate_fixed
+c0404cb4 t do_name
+c0404e72 t free_initrd
+c0404f05 t do_collect
+c0404f7b t do_skip
+c0405004 t do_copy
+c04050b1 t do_header
+c040529b t inflate_dynamic
+c04057d7 t unpack_to_rootfs
+c04060dd t populate_rootfs
+c04061bd t do_reset
+c040626d t lpj_setup
+c0406281 t parse_apic
+c04062d5 T acpi_madt_oem_check
+c0406335 T mps_oem_check
+c04063a0 T generic_bigsmp_probe
+c04063e4 T generic_apic_probe
+c0406441 t mps_oem_check
+c040647b t acpi_madt_oem_check
+c04064e8 t enable_apic_mode
+c04064ed T setup_unisys
+c0406520 T parse_unisys_oem
+c04065c4 T es7000_sw_apic
+c04066eb T find_unisys_acpi_oem_table
+c0406743 t idle_setup
+c04067ce t set_trap_gate
+c04067ed t set_system_gate
+c040680c T early_trap_init
+c0406848 t code_bytes_setup
+c040686a t kstack_setup
+c040687e T trap_init
+c0406a0f T time_init
+c0406a1f T hpet_time_init
+c0406a32 t parse_vmalloc
+c0406a53 t parse_highmem
+c0406a7b t parse_elfcorehdr
+c0406aa2 t parse_reservetop
+c0406ac3 t parse_mem
+c0406b23 T find_max_low_pfn
+c0406c50 W memory_setup
+c0406c55 T remapped_pgdat_init
+c0406c56 T setup_bootmem_allocator
+c0406d85 T zone_sizes_init
+c0406dce T setup_arch
+c0407136 t i8259A_init_sysfs
+c040714f W init_IRQ
+c040714f T native_init_IRQ
+c04071af T init_ISA_irqs
+c040721b t parity
+c0407235 t sbf_init
+c0407303 t romsignature
+c0407338 t romchecksum
+c040738b t efi_find_max_pfn
+c04073a1 t efi_memory_present_wrapper
+c04073a4 T e820_all_mapped
+c0407456 T print_memory_map
+c0407515 T e820_register_memory
+c04075e2 T add_memory_region
+c0407645 T copy_e820_map
+c0407741 T sanitize_e820_map
+c04079f1 t request_standard_resources
+c0407d15 T limit_regions
+c0407ee1 T find_max_pfn
+c0407f85 t parse_memmap
+c0408058 T register_bootmem_low_pages
+c04080f2 t free_available_memory
+c0408119 t i8237A_init_sysfs
+c0408132 t topology_init
+c040815d t bootonly
+c040816d t debug_alt
+c040817d t setup_noreplace_smp
+c040818d T alternative_instructions
+c0408211 t init_pit_clocksource
+c040826e T setup_pit_timer
+c04082fa t dmi_mark_tsc_unstable
+c040831f t tsc_setup
+c0408335 T unsynchronized_tsc
+c040837d T tsc_init
+c04084af T get_model_name
+c0408574 t x86_sep_setup
+c0408584 T cpu_detect
+c0408619 t x86_serial_nr_setup
+c0408629 t cachesize_setup
+c0408642 T print_cpu_info
+c04086fc t get_cpu_vendor
+c04087ae T early_cpu_init
+c0408817 t identify_cpu
+c0408bb4 T identify_secondary_cpu
+c0408bce T identify_boot_cpu
+c0408be7 t default_init
+c0408c11 t x86_fxsr_setup
+c0408c33 T detect_ht
+c0408d74 T display_cacheinfo
+c0408e37 T cpu_init
+c040907e t no_halt
+c040908b t mca_pentium
+c040909b t no_387
+c04090b1 T check_bugs
+c04091c5 t amd_size_cache
+c04091ed T amd_init_cpu
+c04091fa t init_amd
+c04096d5 t do_cyrix_devid
+c040975f T cyrix_init_cpu
+c040976c T nsc_init_cpu
+c0409779 t init_cyrix
+c0409bad t init_nsc
+c0409bcb t cyrix_identify
+c0409c68 t centaur_size_cache
+c0409c94 T centaur_init_cpu
+c0409ca1 t init_centaur
+c0409f21 t transmeta_identify
+c0409f54 T transmeta_init_cpu
+c0409f61 t init_transmeta
+c040a1a2 T early_intel_workaround
+c040a1bb t intel_size_cache
+c040a1d6 T intel_cpu_init
+c040a1e3 T ppro_with_ram_bug
+c040a217 t init_intel
+c040a424 t cpuid4_cache_lookup
+c040a62f t cacheinfo_cpu_callback
+c040a917 t cache_sysfs_init
+c040a956 T init_intel_cacheinfo
+c040ad92 T rise_init_cpu
+c040ad9f t init_rise
+c040adfc t init_nexgen
+c040ae04 t nexgen_identify
+c040ae37 T nexgen_init_cpu
+c040ae44 T umc_init_cpu
+c040ae51 t mcheck_disable
+c040ae61 t mcheck_enable
+c040ae71 t thermal_throttle_init_device
+c040aee5 t mtrr_init_finialize
+c040af0d T mtrr_bp_init
+c040b13b t mtrr_if_init
+c040b18f T mtrr_state_warn
+c040b1eb T amd_init_mtrr
+c040b1f8 T cyrix_init_mtrr
+c040b205 T centaur_init_mtrr
+c040b212 t acpi_parse_lapic_addr_ovr
+c040b23f t acpi_scan_rsdp
+c040b291 T acpi_find_rsdp
+c040b2ce t parse_acpi_skip_timer_override
+c040b2db t parse_acpi_use_timer_override
+c040b2e8 t acpi_parse_fadt
+c040b333 t acpi_parse_hpet
+c040b38b t acpi_parse_sbf
+c040b3b2 t acpi_parse_nmi_src
+c040b3d5 t acpi_parse_lapic_nmi
+c040b413 t acpi_parse_lapic
+c040b449 t acpi_sci_ioapic_setup
+c040b49b T acpi_boot_init
+c040b6ef t acpi_parse_int_src_ovr
+c040b792 t acpi_parse_ioapic
+c040b7c7 t acpi_parse_madt
+c040b82c T acpi_parse_mcfg
+c040b905 t parse_pci
+c040b93f t setup_acpi_sci
+c040b9f4 t dmi_disable_acpi
+c040ba4e t force_acpi_ht
+c040baa8 T acpi_boot_table_init
+c040bb72 t parse_acpi
+c040bcb3 t disable_acpi_irq
+c040bce1 t disable_acpi_pci
+c040bd19 T acpi_pic_sci_set_trigger
+c040bd93 t nvidia_hpet_check
+c040bd96 T check_acpi_pci
+c040be8d t reboot_setup
+c040bf3e t reboot_init
+c040bf4b t set_bios_reboot
+c040bf79 t parse_maxcpus
+c040bf8a T smp_intr_init
+c040bfc7 T native_smp_cpus_done
+c040bfd1 t smp_store_cpu_info
+c040c085 T native_smp_prepare_cpus
+c040cac8 T native_cpu_up
+c040cb36 T native_smp_prepare_boot_cpu
+c040cb7f t start_secondary
+c040ceb0 T smp_alloc_memory
+c040cee1 t check_tsc_warp
+c040d046 T check_tsc_sync_source
+c040d137 T check_tsc_sync_target
+c040d16e T init_gdt
+c040d1cd t mpf_checksum
+c040d1e6 t ELCR_trigger
+c040d200 t MP_bus_info
+c040d36a T mp_config_acpi_legacy_irqs
+c040d44d T mp_override_legacy_irq
+c040d505 t MP_intsrc_info
+c040d53e t construct_default_ioirq_mptable
+c040d640 t MP_ioapic_info
+c040d6d6 T mp_register_ioapic
+c040d80c t MP_processor_info
+c040d937 T mp_register_lapic
+c040da0c t smp_scan_config
+c040dad7 T find_smp_config
+c040db24 T get_smp_config
+c040df47 T mp_register_lapic_address
+c040df85 t parse_lapic
+c040df92 t parse_nolapic
+c040dfa8 t parse_disable_lapic_timer
+c040dfb5 t parse_lapic_timer_c2_ok
+c040dfc2 t init_lapic_sysfs
+c040dfeb T connect_bsp_APIC
+c040e023 T verify_local_APIC
+c040e151 T apic_intr_init
+c040e192 T setup_boot_APIC_clock
+c040e5cf t apic_set_verbosity
+c040e633 T sync_Arb_IDs
+c040e66b t lapic_cal_handler
+c040e717 T init_bsp_APIC
+c040e792 T init_apic_mappings
+c040e9f4 T APIC_init_uniprocessor
+c040eaf3 t init_lapic_nmi_sysfs
+c040eb20 t setup_nmi_watchdog
+c040eb47 t check_nmi_watchdog
+c040ece1 t nmi_cpu_busy
+c040ecf4 t ioapic_setup
+c040ed04 t find_isa_irq_pin
+c040ed5f t find_isa_irq_apic
+c040edd3 t notimercheck
+c040ede3 t setup_disable_8254_timer
+c040edf3 t setup_enable_8254_timer
+c040ee03 t io_apic_bug_finalize
+c040ee1b t parse_disable_timer_pin_1
+c040ee28 t parse_enable_timer_pin_1
+c040ee35 t parse_noapic
+c040ee42 T io_apic_get_redir_entries
+c040ee79 T print_IO_APIC
+c040f211 t ioapic_pirq_setup
+c040f2a5 T setup_ioapic_dest
+c040f2fc T timer_irq_works
+c040f33b T setup_IO_APIC
+c0410080 t ioapic_init_sysfs
+c0410135 T io_apic_get_unique_id
+c0410333 T io_apic_get_version
+c0410365 t parse_crashkernel
+c04103af t kdump_buf_page_init
+c04103e1 T arch_init_kprobes
+c04103e4 t vdso_setup
+c04103f8 T sysenter_setup
+c04106d2 T efi_initialize_iomem_resources
+c0410858 T efi_enter_virtual_mode
+c04109cb T efi_map_memmap
+c0410a1d T efi_init
+c0410ef4 t early_serial_init
+c0411030 t setup_early_printk
+c04111cc t hpet_setup
+c041120e t hpet_register_sysfs
+c0411253 T hpet_enable
+c04114b0 t add_pcspkr
+c04114e1 T native_pagetable_setup_start
+c04114e2 T native_pagetable_setup_done
+c04114e3 T pgtable_cache_init
+c04114e4 t one_page_table_init
+c041152a t page_table_range_init
+c0411584 t free_new_highpage
+c0411599 T online_page
+c04115d6 T add_one_highpage_init
+c0411611 T mem_init
+c04119a3 T paging_init
+c0411bda t noexec_setup
+c0411c4d T bt_iounmap
+c0411c8a T bt_ioremap
+c0411d0f T boot_ioremap
+c0411d84 T pre_setup_arch_hook
+c0411d85 T trap_init_hook
+c0411d86 t print_ipi_mode
+c0411db2 t no_ipi_broadcast
+c0411df4 T machine_specific_memory_setup
+c0411e92 T time_init_hook
+c0411ea8 T intr_init_hook
+c0411ec6 T pre_intr_init_hook
+c0411ecb t setup_max_cache_size
+c0411ee8 t setup_migration_debug
+c0411f05 t setup_migration_factor
+c0411f3a t migration_cost_setup
+c0411fbd T init_idle
+c0412037 t migration_call
+c0412105 T migration_init
+c041214c t isolated_cpu_setup
+c0412190 T sched_init_smp
+c04121ec T sched_init
+c041237f T proc_caches_init
+c0412494 T fork_init
+c0412529 T fork_idle
+c041257e t pause_on_oops_setup
+c0412592 t panic_setup
+c04125a6 t printk_time_setup
+c04125bc T add_preferred_console
+c0412658 t ignore_loglevel_setup
+c0412678 t log_buf_len_setup
+c041277c t console_setup
+c041281c t profile_nop
+c041281d t create_proc_profile
+c041298c T profile_init
+c04129c4 t profile_setup
+c0412bc0 t cpu_callback
+c0412c52 T spawn_ksoftirqd
+c0412c95 T softirq_init
+c0412cbe t ioresources_init
+c0412cf3 t reserve_setup
+c0412db5 t sysctl_init
+c0412dc4 t timer_cpu_notify
+c0412f34 T init_timers
+c0412f70 t uid_cache_init
+c0412fdd T signals_init
+c0413014 T usermodehelper_init
+c0413033 T init_workqueues
+c0413076 T pidmap_init
+c04130cd T pidhash_init
+c0413162 t rcu_cpu_notify
+c04131c0 T rcu_init
+c04131e0 T sort_main_extable
+c04131ef t kernel_param_sysfs_setup
+c041326e t param_sysfs_init
+c0413425 t init_posix_timers
+c04134b6 t init_posix_cpu_timers
+c0413550 t hrtimer_cpu_notify
+c0413585 T hrtimers_init
+c04135a5 t latency_init
+c04135c1 t nsproxy_cache_init
+c04135f7 t init_network
+c041365a t init_vserver
+c041365d t timekeeping_init_device
+c0413676 T timekeeping_init
+c041377b t clocksource_done_booting
+c0413788 t boot_override_clocksource
+c04137c1 t boot_override_clock
+c041380e t init_clocksource_sysfs
+c041384d t init_jiffies_clocksource
+c0413857 t init_timer_list_procfs
+c041387d T tick_init
+c0413887 t init
+c0413905 t proc_dma_init
+c0413921 T cpu_up
+c0413a54 T register_cpu_notifier
+c0413a7d t kallsyms_init
+c0413a9c t pm_init
+c0413aba t crash_notes_memory_init
+c0413af1 T container_init
+c0413b39 T container_init_early
+c0413c4b t init_kprobes
+c0413c8e t ksysfs_init
+c0413cac t cpu_callback
+c0413d73 T spawn_softlockup_task
+c0413dc2 t irqpoll_setup
+c0413dee t irqfixup_setup
+c0413e1a t relay_init
+c0413e1d t utsname_sysctl_init
+c0413e2a T bootmem_bootmap_pages
+c0413e39 t get_mapsize
+c0413e50 t free_bootmem_core
+c0413ea7 T free_bootmem
+c0413eb2 T free_bootmem_node
+c0413eba t reserve_bootmem_core
+c0413f15 T reserve_bootmem
+c0413f20 T reserve_bootmem_node
+c0413f28 t free_all_bootmem_core
+c0414080 T free_all_bootmem
+c041408a T free_all_bootmem_node
+c041408f t init_bootmem_core
+c0414133 T init_bootmem
+c0414154 T init_bootmem_node
+c0414159 T __alloc_bootmem_core
+c04143d9 T __alloc_bootmem_low_node
+c04143fb T __alloc_bootmem_low
+c0414462 T __alloc_bootmem_nopanic
+c04144af T __alloc_bootmem
+c04144de T __alloc_bootmem_node
+c041451c T memmap_init_zone
+c0414571 t first_active_region_index_in_nid
+c0414599 t next_active_region_index_in_nid
+c04145cd T early_pfn_to_nid
+c041460a T sparse_memory_present_with_active_regions
+c0414622 T push_node_boundaries
+c0414623 T shrink_active_range
+c0414656 t cmp_node_active_region
+c0414666 T find_max_pfn_with_active_regions
+c041468d T set_dma_reserve
+c0414693 T page_alloc_init
+c0414694 T __absent_pages_in_range
+c0414719 T absent_pages_in_range
+c0414727 t build_zonelists_node
+c0414762 T find_min_pfn_for_node
+c04147b1 T find_min_pfn_with_active_regions
+c04147bb T add_active_range
+c0414893 T get_pfn_range_for_nid
+c0414908 T zone_absent_pages_in_node
+c0414946 T zone_spanned_pages_in_node
+c0414988 t init_per_zone_pages_min
+c04149d1 t __build_all_zonelists
+c0414a80 T free_bootmem_with_active_regions
+c0414acc T init_currently_empty_zone
+c0414b50 T free_area_init_node
+c0414f45 T free_area_init
+c0414f68 T build_all_zonelists
+c0414fb4 T alloc_large_system_hash
+c04151d6 T remove_all_active_ranges
+c04151f1 T free_area_init_nodes
+c0415333 T __free_pages_bootmem
+c0415391 T page_writeback_init
+c04153b6 t ratelimit_handler
+c04153be t pdflush_init
+c04153d0 T swap_setup
+c04153e6 t kswapd_init
+c04153fe T setup_vmstat
+c0415438 t vmstat_cpuup_callback
+c0415485 T page_address_init
+c0415501 t disable_randmaps
+c0415511 T anon_vma_init
+c0415545 t init_emergency_pool
+c04155a5 t procswaps_init
+c04155c1 t init_tmpfs
+c041567a t noaliencache_setup
+c041568a t set_up_list3s
+c04156c6 t cpucache_init
+c04156f1 t cpuup_callback
+c041599d T kmem_cache_init
+c0415d12 T files_init
+c0415d7a T unnamed_dev_init
+c0415d84 T chrdev_init
+c0415d99 t init_pipe_fs
+c0415dd4 t fasync_init
+c0415e0a t filelock_init
+c0415e40 t set_dhash_entries
+c0415e63 T vfs_caches_init
+c0415fb0 T vfs_caches_init_early
+c0416026 t set_ihash_entries
+c0416049 T inode_init
+c04160f7 T inode_init_early
+c0416169 T files_defer_init
+c04161c8 T mnt_init
+c0416386 t aio_setup
+c0416402 T buffer_init
+c0416454 t init_bio
+c041651b T bdev_cache_init
+c0416590 t revokefs_init
+c0416611 t inotify_setup
+c041661e t inotify_user_setup
+c04166e0 t eventpoll_init
+c041677f t anon_inode_init
+c0416860 t init_misc_binfmt
+c041688f t init_script_binfmt
+c0416899 t init_elf_binfmt
+c04168a3 t init_mbcache
+c04168ba t dquot_init
+c04169a3 t init_v2_quota_format
+c04169ad t dnotify_init
+c04169e3 T proc_init_inodecache
+c0416a1f T proc_root_init
+c0416ac3 T proc_tty_init
+c0416b34 T proc_misc_init
+c0416cf1 t get_new_element
+c0416d16 t vmcore_init
+c04176de T sysfs_init
+c041777f t init_devpts_fs
+c04177ab t init_ext3_fs
+c0417815 T init_ext3_xattr
+c0417848 T journal_init_revoke_caches
+c04178d3 t journal_init
+c04179a9 t init_ext2_fs
+c0417a13 T init_ext2_xattr
+c0417a46 t init_cramfs_fs
+c0417a6b T init_rootfs
+c0417a75 t init_ramfs_fs
+c0417a7f t init_iso9660_fs
+c0417aeb T zisofs_init
+c0417b4b t init_nls_cp437
+c0417b55 t init_nls_ascii
+c0417b5f t debugfs_init
+c0417b98 t ipc_init
+c0417baa T ipc_init_proc_interface
+c0417c10 T msg_init
+c0417c3f T sem_init
+c0417c6b T shm_init
+c0417c9a t ipc_sysctl_init
+c0417ca7 t init_mqueue_fs
+c0417d65 t elevator_setup
+c0417db8 T blk_dev_init
+c0417ec2 t genhd_device_init
+c0417f0e T printk_all_partitions
+c0418048 t noop_init
+c0418052 t cfq_init
+c0418114 t blk_trace_init
+c04181b3 t kobject_uevent_init
+c0418203 T prio_tree_init
+c0418225 T radix_tree_init
+c0418295 t random32_reseed
+c04182e1 t random32_init
+c041831f t pci_sort_bf_cmp
+c0418350 t pcibus_class_init
+c041835a T pci_sort_breadthfirst
+c04184b6 t quirk_ioapic_rmw
+c04184d5 t quirk_eisa_bridge
+c04184dd t quirk_tc86c001_ide
+c041851d t quirk_alimagik
+c041853e t quirk_disable_all_msi
+c0418554 t quirk_alder_ioapic
+c04185bf t asus_hides_smbus_hostbridge
+c0418756 t quirk_ide_samemode
+c04187b6 t pci_driver_init
+c04187c0 t pci_sysfs_init
+c04187f1 t pci_proc_init
+c041884c t pcie_portdrv_init
+c041888f t aer_service_init
+c0418899 T pci_assign_unassigned_resources
+c04188e1 t acpi_pci_init
+c0418924 t no_scroll
+c0418938 t acpi_parse_apic_instance
+c041895e T acpi_table_init
+c04189d7 T acpi_table_parse
+c0418a42 T acpi_table_parse_entries
+c0418b4c T acpi_table_parse_madt
+c0418b6a T acpi_blacklisted
+c0418ce6 t acpi_os_name_setup
+c0418d42 t acpi_wake_gpes_always_on_setup
+c0418d5f t acpi_serialize_setup
+c0418d7c t acpi_request_region
+c0418dd6 t acpi_reserve_resources
+c0418e9a T acpi_os_get_root_pointer
+c0418ed2 T acpi_os_initialize
+c0418edf t acpi_osi_setup
+c0418fa3 T acpi_initialize_tables
+c041901e T acpi_tb_parse_root_table
+c0419320 T acpi_initialize_subsystem
+c04193a8 T acpi_early_init
+c04194a2 t acpi_init
+c04196a0 t init_acpi_device_notify
+c04196e4 t acpi_scan_init
+c04197e5 t acpi_ec_set_intr_mode
+c0419843 t acpi_ec_init
+c0419894 T acpi_ec_ecdt_probe
+c041992c t acpi_pci_root_init
+c041994d t acpi_irq_nobalance_set
+c041995d T acpi_irq_balance_set
+c041996d t acpi_pci_link_init
+c04199ac t irqrouter_init_sysfs
+c04199d9 t acpi_irq_penalty_update
+c0419a35 t acpi_irq_pci
+c0419a39 t acpi_irq_isa
+c0419a40 T acpi_irq_penalty_init
+c0419ad1 t acpi_power_init
+c0419b36 t acpi_system_init
+c0419cb9 t acpi_event_init
+c0419ced t acpi_cm_sbs_init
+c0419cf0 t pnp_init
+c0419d0a t pnp_setup_reserve_mem
+c0419d37 t pnp_setup_reserve_io
+c0419d64 t pnp_setup_reserve_dma
+c0419d91 t pnp_setup_reserve_irq
+c0419dbe t pnp_system_init
+c0419dc8 t ispnpidacpi
+c0419e23 t pnpidacpi_to_pnpid
+c0419e90 t pnpacpi_setup
+c0419ed2 t pnpacpi_init
+c0419f58 t acpi_pnp_find_device
+c0419f92 t acpi_pnp_match
+c0419fd0 t pnpacpi_add_device_handler
+c041a240 t chr_dev_init
+c041a2c3 t seqgen_init
+c041a2cd t rand_initialize
+c041a2ee t tty_init
+c041a4b6 T console_init
+c041a4d9 t tty_class_init
+c041a4f8 t pty_init
+c041a713 t misc_init
+c041a78b T vcs_init
+c041a816 T console_map_init
+c041a84a T kbd_init
+c041a8cb T vty_init
+c041a996 t con_init
+c041aba8 t vtconsole_class_init
+c041ac59 t sysrq_always_enabled_setup
+c041ac79 t rtc_init
+c041ae2f t hpet_init
+c041ae82 t mod_init
+c041b045 t intel_rng_hw_init
+c041b117 t hangcheck_init
+c041b1ab t hangcheck_parse_dump_tasks
+c041b1d1 t hangcheck_parse_reboot
+c041b1f7 t hangcheck_parse_margin
+c041b21d t hangcheck_parse_tick
+c041b243 T uart_get_console
+c041b29c T uart_parse_options
+c041b2f5 T uart_set_options
+c041b3b3 t serial8250_console_setup
+c041b45d t serial8250_isa_init_ports
+c041b565 T early_serial_setup
+c041b5ae t serial8250_init
+c041b6be t serial8250_console_init
+c041b6d0 T serial8250_start_console
+c041b77a t serial8250_pnp_init
+c041b784 t serial8250_pci_init
+c041b795 t serial_in
+c041b7ac t serial_out
+c041b7c8 t wait_for_xmitr
+c041b7e5 t putc
+c041b7fa t early_uart_console_switch
+c041b873 t early_uart_setup
+c041bb83 t early_uart_write
+c041bbe3 t early_uart_console_init
+c041bc03 T early_serial_console_init
+c041bc48 T devices_init
+c041bc52 T system_bus_init
+c041bc66 T buses_init
+c041bc70 T classes_init
+c041bca7 T platform_bus_init
+c041bcd6 T cpu_dev_init
+c041bcef T firmware_init
+c041bcf9 T driver_init
+c041bd21 T attribute_container_init
+c041bd38 t firmware_class_init
+c041bd9b t topology_sysfs_init
+c041bddf t ramdisk_blocksize
+c041bdf3 t ramdisk_size
+c041be07 t ramdisk_size2
+c041be09 t rd_init
+c041bf89 t probe_list2
+c041bfc6 t net_olddevs_init
+c041c043 t loopback_init
+c041c04d t etun_init
+c041c086 t aec62xx_ide_init
+c041c097 t ali15x3_ide_init
+c041c0a8 t amd74xx_ide_init
+c041c0b9 t atiixp_ide_init
+c041c0ca t cmd64x_ide_init
+c041c0db t cs5520_ide_init
+c041c0ec t cs5530_ide_init
+c041c0fd t cs5535_ide_init
+c041c10e t cy82c693_ide_init
+c041c11f t hpt34x_ide_init
+c041c130 t hpt366_ide_init
+c041c141 t it821x_ide_init
+c041c152 t jmicron_ide_init
+c041c163 t pdc202xx_ide_init
+c041c174 t pdc202new_ide_init
+c041c185 t piix_ide_init
+c041c240 t rz1000_ide_init
+c041c251 t svwks_ide_init
+c041c262 t siimage_ide_init
+c041c273 t sis5513_ide_init
+c041c284 t slc90e66_ide_init
+c041c295 t triflex_ide_init
+c041c2a6 t via_ide_init
+c041c2b7 t generic_ide_init
+c041c2c8 t ide_generic_all_on
+c041c2e8 t stridx
+c041c314 t match_parm
+c041c3da t init_ide_data
+c041c42e t ide_init
+c041c486 t ide_setup
+c041c979 t match_pci_cmd640_device
+c041c99c t secondary_port_responding
+c041ca0d T ide_probe_for_cmd640x
+c041cf5e t ide_scan_pcidev
+c041cfa6 T ide_scan_pcibus
+c041d04d t ide_generic_init
+c041d055 t idedisk_init
+c041d05f t ide_cdrom_init
+c041d069 t idefloppy_init
+c041d083 t cdrom_init
+c041d08b t usb_init
+c041d18e T usb_devio_init
+c041d274 T usbfs_init
+c041d2a8 t usb_usual_init
+c041d2d2 t serio_init
+c041d35a t i8042_init
+c041d68a t input_init
+c041d783 t mousedev_init
+c041d83b t evdev_init
+c041d845 t atkbd_init
+c041d856 t psmouse_init
+c041d8ad T i2c_register_board_info
+c041d931 t linear_init
+c041d93b t md_init
+c041da12 t dm_netlink_init
+c041da15 t dm_init
+c041da49 t local_init
+c041dafc T dm_target_init
+c041db06 T dm_linear_init
+c041db30 T dm_stripe_init
+c041db55 T dm_interface_init
+c041dbcb t dmi_present
+c041dd3a T dmi_scan_machine
+c041ddbf t dmi_string
+c041de46 t dmi_save_ident
+c041de69 t dmi_decode
+c041e09e t efivars_init
+c041e230 t init_cyclone_clocksource
+c041e3a3 t acpi_pm_good_setup
+c041e3b3 t init_acpi_pm_clocksource
+c041e502 t dma_bus_init
+c041e520 t hid_init
+c041e56c t pcibios_assign_resources
+c041e5ed t pcibios_allocate_bus_resources
+c041e693 t pcibios_allocate_resources
+c041e7c7 T pcibios_resource_survey
+c041e7e2 t pci_access_init
+c041e821 T pci_pcbios_init
+c041ea26 T pci_mmcfg_arch_init
+c041ea46 T pci_mmcfg_arch_reachable
+c041ea54 T pci_direct_init
+c041ea85 t pci_sanity_check
+c041eb34 T pci_direct_probe
+c041ecb1 t pci_mmcfg_intel_945
+c041edbd T pci_mmcfg_init
+c041f15e t pci_mmcfg_e7520
+c041f203 t pci_acpi_init
+c041f29c t pci_legacy_init
+c041f39f t via_router_probe
+c041f427 t vlsi_router_probe
+c041f449 t serverworks_router_probe
+c041f473 t sis_router_probe
+c041f494 t cyrix_router_probe
+c041f4b5 t opti_router_probe
+c041f4d7 t ite_router_probe
+c041f4f9 t amd_router_probe
+c041f53f t fix_acer_tm360_irqrouting
+c041f56d t fix_broken_hp_bios_irq9
+c041f59b t ali_router_probe
+c041f5dc t intel_router_probe
+c041f733 t pcibios_irq_init
+c041fbc6 t pcibios_init
+c041fc43 t sock_init
+c041fcab T sk_init
+c041fcfc t proto_init
+c041fd26 T skb_init
+c041fd87 t net_ns_init
+c041fe25 T netdev_boot_setup
+c041fedd t net_dev_init
+c0420051 T dev_mcast_init
+c042005b T dst_init
+c0420065 t neigh_init
+c04200de T rtnetlink_init
+c04201e6 t flow_cache_init
+c042032e t fib_rules_init
+c0420391 t pktsched_init
+c0420459 t blackhole_module_init
+c0420463 t tc_filter_init
+c04204b2 t netlink_proto_init
+c04205c5 t genl_init
+c0420672 T netfilter_init
+c04206db T netfilter_log_init
+c0420703 T netfilter_queue_init
+c042072b t set_rhash_entries
+c042074e T ip_rt_init
+c04209aa T inet_initpeers
+c04209e7 T ip_init
+c04209f1 t set_thash_entries
+c0420a14 T tcp_init
+c0420cb9 T tcp_v4_init
+c0420ce9 T tcp4_proc_init
+c0420cf3 t tcp_congestion_default
+c0420cfd T raw_proc_exit
+c0420d07 T raw_proc_init
+c0420d11 T udp4_proc_init
+c0420d1b T udplite4_register
+c0420d93 T arp_init
+c0420dbb T icmp_init
+c0420dda T devinet_init
+c0420e50 t inet_init
+c042111a T igmp_mc_proc_init
+c042115d T ip_fib_init
+c04211cd T ip_misc_proc_init
+c042125e t tunnel4_init
+c04212bb t cubictcp_register
+c042134a T xfrm4_init
+c0421359 T xfrm4_state_init
+c0421363 T xfrm_init
+c0421439 T xfrm_state_init
+c04214c8 T xfrm_input_init
+c04214fc t af_unix_init
+c0421545 t inet6_init
+c04217d0 T ac6_proc_init
+c04217fa T if6_proc_init
+c0421824 T addrconf_init
+c0421944 T ip6_route_init
+c0421a26 T fib6_init
+c0421aaf T ipv6_packet_init
+c0421ab9 T ndisc_init
+c0421b78 T udpv6_init
+c0421ba5 T udp6_proc_init
+c0421bb4 T udplite6_proc_init
+c0421bc3 T udplitev6_init
+c0421bf9 T raw6_proc_init
+c0421c23 T icmpv6_init
+c0421d04 T igmp6_init
+c0421db3 T ipv6_frag_init
+c0421e3a T tcpv6_init
+c0421e93 T tcp6_proc_init
+c0421ea2 T ipv6_rthdr_init
+c0421ec6 T ipv6_nodata_init
+c0421eea T ipv6_destopt_init
+c0421f0e T xfrm6_init
+c0421f1d T xfrm6_state_init
+c0421f27 T ipv6_netfilter_init
+c0421f31 T ipv6_misc_proc_init
+c0421fbb t xfrm6_transport_init
+c0421fca t xfrm6_tunnel_init
+c0421fd9 t xfrm6_beet_init
+c0421fe8 t ipip6_fb_tunnel_init
+c0422049 t sit_init
+c04220d1 t packet_init
+c0422106 t wireless_nlevent_init
+c042213b T _einittext
+c0423000 t tmp_cmdline.28992
+c0423800 t done.28991
+c0423804 t initcall_debug
+c0423820 T boot_command_line
+c0424020 t __setup_str_nosmp
+c0424026 t __setup_str_maxcpus
+c042402f t __setup_str_set_reset_devices
+c042403d t __setup_str_debug_kernel
+c0424043 t __setup_str_quiet_kernel
+c0424049 t __setup_str_loglevel
+c0424053 t __setup_str_init_setup
+c0424059 t __setup_str_rdinit_setup
+c0424061 t __setup_str_initcall_debug_setup
+c0424080 t saved_root_name
+c04240c0 t root_mount_data
+c04240c4 t root_fs_names
+c04240c8 t root_delay
+c04240cc T root_device_name
+c04240d0 T rd_doload
+c04240d4 t __setup_str_load_ramdisk
+c04240e2 t __setup_str_readonly
+c04240e5 t __setup_str_readwrite
+c04240e8 t __setup_str_root_dev_setup
+c04240ee t __setup_str_root_data_setup
+c04240f9 t __setup_str_fs_names_setup
+c0424105 t __setup_str_root_delay_setup
+c0424110 T rd_prompt
+c0424114 T rd_image_start
+c0424118 t __setup_str_prompt_ramdisk
+c0424128 t __setup_str_ramdisk_start_setup
+c0424138 t mount_initrd
+c042413c t old_fd
+c0424140 t root_fd
+c0424144 t __setup_str_no_initrd
+c0424160 t raid_noautodetect
+c0424164 t raid_autopart
+c0424180 t md_setup_args
+c0425580 t md_setup_ents
+c0425584 t __setup_str_raid_setup
+c042558a t __setup_str_md_setup
+c04255a0 t actions
+c04255c0 t message
+c04255e0 t head
+c0425660 t ino
+c0425664 t major
+c0425668 t minor
+c042566c t nlink
+c0425670 t mode
+c0425674 t body_len
+c0425678 t name_len
+c042567c t uid
+c0425680 t gid
+c0425684 t rdev
+c0425688 t state
+c042568c t next_state
+c0425690 t victim
+c0425694 t count
+c0425698 t this_header
+c04256a0 t next_header
+c04256a8 t dry_run
+c04256ac t collected
+c04256b0 t remains
+c04256b4 t collect
+c04256b8 t header_buf
+c04256bc t symlink_buf
+c04256c0 t name_buf
+c04256c4 t wfd
+c04256c8 t do_retain_initrd
+c04256cc t __setup_str_retain_initrd_param
+c04256da t __setup_str_lpj_setup
+c04256e0 T apic_probe
+c04256f4 t cmdline_apic
+c04256f8 t __setup_str_parse_apic
+c0425700 t __setup_str_idle_setup
+c0425705 t __setup_str_kstack_setup
+c042570d t __setup_str_code_bytes_setup
+c0425780 T init_pg_tables_end
+c0425800 T new_cpu_data
+c0425900 T user_defined_memmap
+c0425920 t command_line
+c0426120 T boot_params
+c0427120 t __setup_str_parse_mem
+c0427124 t __setup_str_parse_elfcorehdr
+c042712f t __setup_str_parse_highmem
+c0427137 t __setup_str_parse_vmalloc
+c042713f t __setup_str_parse_reservetop
+c042714a t __setup_str_check_iommu
+c0427154 T sbf_port
+c0427160 t change_point_list
+c0427d60 t change_point
+c0428160 t overlap_list
+c0428360 t new_bios
+c0428d60 t __setup_str_parse_memmap
+c0428d67 t __setup_str_bootonly
+c0428d74 t __setup_str_debug_alt
+c0428d86 t __setup_str_setup_noreplace_smp
+c0428da0 t bad_tsc_dmi_table
+c0428df8 t __setup_str_tsc_setup
+c0428e00 T cpu_initialized
+c0428e04 t disable_x86_serial_nr
+c0428e08 t cachesize_override
+c0428e0c t this_cpu
+c0428e20 t default_cpu
+c0428f58 t disable_x86_fxsr
+c0428f5c t disable_x86_sep
+c0428f60 t __setup_str_cachesize_setup
+c0428f6b t __setup_str_x86_fxsr_setup
+c0428f72 t __setup_str_x86_sep_setup
+c0428f78 t __setup_str_x86_serial_nr_setup
+c0428f88 t x
+c0428f90 t y
+c0428f98 t __setup_str_no_halt
+c0428f9f t __setup_str_mca_pentium
+c0428fab t __setup_str_no_387
+c0428fc0 t amd_cpu_dev
+c04290f8 T force_mwait
+c0429100 t nsc_cpu_dev
+c0429238 t Cx86_dir0_msb
+c0429240 t Cx486_name
+c0429268 t Cx486D_name
+c0429280 t Cx486S_name
+c0429290 t cyrix_model_mult1
+c0429297 t Cx86_cb
+c04292ab t cyrix_model_mult2
+c04292c0 t Cx86_model
+c0429320 t cyrix_cpu_dev
+c0429460 t centaur_cpu_dev
+c04295a0 t transmeta_cpu_dev
+c04296e0 t intel_cpu_dev
+c0429820 t cacheinfo_cpu_notifier
+c0429840 t cache_table
+c0429920 t rise_cpu_dev
+c0429a60 t nexgen_cpu_dev
+c0429ba0 t umc_cpu_dev
+c0429cd8 t __setup_str_mcheck_disable
+c0429cde t __setup_str_mcheck_enable
+c0429d00 T acpi_ht
+c0429d04 t acpi_force
+c0429d08 t acpi_lapic_addr
+c0429d20 t acpi_dmi_table
+c042a038 T acpi_pci_disabled
+c042a03c T acpi_skip_timer_override
+c042a040 T acpi_use_timer_override
+c042a044 T acpi_sci_flags
+c042a048 T acpi_sci_override_gsi
+c042a04c t __setup_str_parse_acpi
+c042a051 t __setup_str_parse_pci
+c042a055 t __setup_str_parse_acpi_skip_timer_override
+c042a06e t __setup_str_parse_acpi_use_timer_override
+c042a086 t __setup_str_setup_acpi_sci
+c042a0a0 t reboot_dmi_table
+c042a1a8 t __setup_str_reboot_setup
+c042a1c0 T cpu_llc_id
+c042a200 t __setup_str_parse_maxcpus
+c042a208 t sync_lock
+c042a20c t start_count
+c042a210 t stop_count
+c042a218 t last_tsc
+c042a220 t max_warp
+c042a228 t nr_warps
+c042a22c t r_base
+c042a22c T trampoline_data
+c042a256 t boot_gdt_descr
+c042a25c t boot_idt_descr
+c042a262 T trampoline_end
+c042a280 T maxcpus
+c042a2a0 t translation_table
+c042b2a0 T num_processors
+c042b2a8 t enable_local_apic
+c042b2ac t lapic_cal_loops
+c042b2b0 t lapic_cal_t1
+c042b2b4 t lapic_cal_t2
+c042b2b8 t lapic_cal_tsc1
+c042b2c0 t lapic_cal_tsc2
+c042b2c8 t lapic_cal_pm1
+c042b2cc t lapic_cal_pm2
+c042b2d0 t lapic_cal_j1
+c042b2d4 t lapic_cal_j2
+c042b2d8 t __setup_str_parse_lapic
+c042b2de t __setup_str_parse_nolapic
+c042b2e6 t __setup_str_parse_disable_lapic_timer
+c042b2f4 t __setup_str_parse_lapic_timer_c2_ok
+c042b306 t __setup_str_apic_set_verbosity
+c042b30c t endflag
+c042b310 t __setup_str_setup_nmi_watchdog
+c042b320 T timer_over_8254
+c042b324 t disable_timer_pin_1
+c042b328 T no_timer_check
+c042b32c t __setup_str_ioapic_setup
+c042b333 t __setup_str_ioapic_pirq_setup
+c042b339 t __setup_str_notimercheck
+c042b348 t __setup_str_setup_disable_8254_timer
+c042b35b t __setup_str_setup_enable_8254_timer
+c042b36d t __setup_str_parse_disable_timer_pin_1
+c042b381 t __setup_str_parse_enable_timer_pin_1
+c042b394 t __setup_str_parse_noapic
+c042b39b t __setup_str_parse_crashkernel
+c042b3a7 t __setup_str_vdso_setup
+c042b3ad T vsyscall_int80_start
+c042bc21 T vsyscall_int80_end
+c042bc21 T vsyscall_sysenter_start
+c042c4ad T vsyscall_sysenter_end
+c042c4b0 t keep_early
+c042c4b4 t __setup_str_setup_early_printk
+c042c4c0 t __setup_str_hpet_setup
+c042d000 t disable_nx
+c042d004 t __setup_str_noexec_setup
+c042e000 t boot_ioremap_space
+c0432000 t __setup_str_no_ipi_broadcast
+c0432014 t migration_notifier
+c0432020 t __setup_str_isolated_cpu_setup
+c043202a t __setup_str_migration_cost_setup
+c043203a t __setup_str_setup_migration_factor
+c043204c t __setup_str_setup_migration_debug
+c043205d t __setup_str_setup_max_cache_size
+c043206d t __setup_str_panic_setup
+c0432074 t __setup_str_pause_on_oops_setup
+c0432083 t __setup_str_log_buf_len_setup
+c0432090 t __setup_str_ignore_loglevel_setup
+c04320a0 t __setup_str_printk_time_setup
+c04320a5 t __setup_str_console_setup
+c04320ae t kvmstr.18063
+c04320b2 t sleepstr.18062
+c04320b8 t schedstr.18061
+c04320c1 t __setup_str_profile_setup
+c04320cc t cpu_nfb
+c04320d8 t __setup_str_reserve_setup
+c04320e4 t timers_nb
+c04320f0 t rcu_nb
+c04320fc t hrtimers_nb
+c0432108 t __setup_str_boot_override_clocksource
+c0432115 t __setup_str_boot_override_clock
+c043211c t cpu_chain
+c0432120 t cpu_nfb
+c043212c t __setup_str_noirqdebug_setup
+c0432137 t __setup_str_irqfixup_setup
+c0432140 t __setup_str_irqpoll_setup
+c0432160 t dma_reserve
+c0432164 T nr_kernel_pages
+c0432168 T nr_all_pages
+c0432180 T early_node_map
+c0432d80 T nr_nodemap_entries
+c0432d84 T arch_zone_lowest_possible_pfn
+c0432d90 T arch_zone_highest_possible_pfn
+c0432d9c t ratelimit_nb
+c0432da8 t vmstat_notifier
+c0432db4 t __setup_str_disable_randmaps
+c0432dc0 t initarray_cache
+c0432e00 t cache_names
+c0432e98 t cpucache_notifier
+c0432ec0 T initkmem_list3
+c0432f8c t __setup_str_noaliencache_setup
+c0432f9c t dhash_entries
+c0432fa0 t __setup_str_set_dhash_entries
+c0432fb0 t ihash_entries
+c0432fb4 t __setup_str_set_ihash_entries
+c0432fc3 t __setup_str_elevator_setup
+c0432fe0 t __setup_str_pci_setup
+c0432fe4 t __setup_str_no_scroll
+c0433000 t initial_tables
+c0433a00 t acpi_apic_instance
+c0433a04 t __setup_str_acpi_parse_apic_instance
+c0433a20 t acpi_blacklist
+c0433b00 t acpi_osl_dmi_table
+c0433b58 t __setup_str_acpi_os_name_setup
+c0433b66 t __setup_str_acpi_osi_setup
+c0433b70 t __setup_str_acpi_serialize_setup
+c0433b7f t __setup_str_acpi_wake_gpes_always_on_setup
+c0433b98 t __setup_str_acpi_ec_set_intr_mode
+c0433ba1 t __setup_str_acpi_irq_isa
+c0433baf t __setup_str_acpi_irq_pci
+c0433bbd t __setup_str_acpi_irq_nobalance_set
+c0433bd0 t __setup_str_acpi_irq_balance_set
+c0433c00 t __setup_str_pnp_setup_reserve_irq
+c0433c11 t __setup_str_pnp_setup_reserve_dma
+c0433c22 t __setup_str_pnp_setup_reserve_io
+c0433c32 t __setup_str_pnp_setup_reserve_mem
+c0433c60 t acpi_pnp_bus
+c0433c80 t excluded_id_list
+c0433ca4 T pnpacpi_disabled
+c0433ca8 t __setup_str_pnpacpi_setup
+c0433cc0 t __setup_str_sysrq_always_enabled_setup
+c0433ce0 t warning.15949
+c0433e00 t no_fwh_detect
+c0433e04 t __setup_str_hangcheck_parse_tick
+c0433e10 t __setup_str_hangcheck_parse_margin
+c0433e1e t __setup_str_hangcheck_parse_reboot
+c0433e2c t __setup_str_hangcheck_parse_dump_tasks
+c0433e40 t early_uart_console
+c0433e80 t early_device
+c0433f28 t early_uart_registered
+c0433f2c t __setup_str_ramdisk_size
+c0433f35 t __setup_str_ramdisk_size2
+c0433f43 t __setup_str_ramdisk_blocksize
+c0433f58 t m68k_probes
+c0433f60 t eisa_probes
+c0433f68 t mca_probes
+c0433f70 t isa_probes
+c0433f78 t parport_probes
+c0433f80 t __setup_str_ide_generic_all_on
+c0433fa0 t is_chipset_set
+c0433fc8 t __setup_str_ide_setup
+c0433fe0 t i8042_dmi_noloop_table
+c0434100 t i8042_dmi_nomux_table
+c0434418 T _inits
+c0434430 t __setup_str_acpi_pm_good_setup
+c0434440 t pci_mmcfg_probes
+c0434460 t pciirq_dmi_table
+c0434500 t pirq_routers
+c0434560 t pirq_440gx.22194
+c04345b4 t __setup_str_netdev_boot_setup
+c04345bc t __setup_str_netdev_boot_setup
+c04345c4 t rhash_entries
+c04345c8 t __setup_str_set_rhash_entries
+c04345d8 t thash_entries
+c04345dc t __setup_str_set_thash_entries
+c04345f0 t __setup_nosmp
+c04345f0 T __setup_start
+c04345fc t __setup_maxcpus
+c0434608 t __setup_set_reset_devices
+c0434614 t __setup_debug_kernel
+c0434620 t __setup_quiet_kernel
+c043462c t __setup_loglevel
+c0434638 t __setup_init_setup
+c0434644 t __setup_rdinit_setup
+c0434650 t __setup_initcall_debug_setup
+c043465c t __setup_load_ramdisk
+c0434668 t __setup_readonly
+c0434674 t __setup_readwrite
+c0434680 t __setup_root_dev_setup
+c043468c t __setup_root_data_setup
+c0434698 t __setup_fs_names_setup
+c04346a4 t __setup_root_delay_setup
+c04346b0 t __setup_prompt_ramdisk
+c04346bc t __setup_ramdisk_start_setup
+c04346c8 t __setup_no_initrd
+c04346d4 t __setup_raid_setup
+c04346e0 t __setup_md_setup
+c04346ec t __setup_retain_initrd_param
+c04346f8 t __setup_lpj_setup
+c0434704 t __setup_parse_apic
+c0434710 t __setup_idle_setup
+c043471c t __setup_kstack_setup
+c0434728 t __setup_code_bytes_setup
+c0434734 t __setup_parse_mem
+c0434740 t __setup_parse_elfcorehdr
+c043474c t __setup_parse_highmem
+c0434758 t __setup_parse_vmalloc
+c0434764 t __setup_parse_reservetop
+c0434770 t __setup_check_iommu
+c043477c t __setup_parse_memmap
+c0434788 t __setup_bootonly
+c0434794 t __setup_debug_alt
+c04347a0 t __setup_setup_noreplace_smp
+c04347ac t __setup_tsc_setup
+c04347b8 t __setup_cachesize_setup
+c04347c4 t __setup_x86_fxsr_setup
+c04347d0 t __setup_x86_sep_setup
+c04347dc t __setup_x86_serial_nr_setup
+c04347e8 t __setup_no_halt
+c04347f4 t __setup_mca_pentium
+c0434800 t __setup_no_387
+c043480c t __setup_mcheck_disable
+c0434818 t __setup_mcheck_enable
+c0434824 t __setup_parse_acpi
+c0434830 t __setup_parse_pci
+c043483c t __setup_parse_acpi_skip_timer_override
+c0434848 t __setup_parse_acpi_use_timer_override
+c0434854 t __setup_setup_acpi_sci
+c0434860 t __setup_reboot_setup
+c043486c t __setup_parse_maxcpus
+c0434878 t __setup_parse_lapic
+c0434884 t __setup_parse_nolapic
+c0434890 t __setup_parse_disable_lapic_timer
+c043489c t __setup_parse_lapic_timer_c2_ok
+c04348a8 t __setup_apic_set_verbosity
+c04348b4 t __setup_setup_nmi_watchdog
+c04348c0 t __setup_ioapic_setup
+c04348cc t __setup_ioapic_pirq_setup
+c04348d8 t __setup_notimercheck
+c04348e4 t __setup_setup_disable_8254_timer
+c04348f0 t __setup_setup_enable_8254_timer
+c04348fc t __setup_parse_disable_timer_pin_1
+c0434908 t __setup_parse_enable_timer_pin_1
+c0434914 t __setup_parse_noapic
+c0434920 t __setup_parse_crashkernel
+c043492c t __setup_vdso_setup
+c0434938 t __setup_setup_early_printk
+c0434944 t __setup_hpet_setup
+c0434950 t __setup_noexec_setup
+c043495c t __setup_no_ipi_broadcast
+c0434968 t __setup_isolated_cpu_setup
+c0434974 t __setup_migration_cost_setup
+c0434980 t __setup_setup_migration_factor
+c043498c t __setup_setup_migration_debug
+c0434998 t __setup_setup_max_cache_size
+c04349a4 t __setup_panic_setup
+c04349b0 t __setup_pause_on_oops_setup
+c04349bc t __setup_log_buf_len_setup
+c04349c8 t __setup_ignore_loglevel_setup
+c04349d4 t __setup_printk_time_setup
+c04349e0 t __setup_console_setup
+c04349ec t __setup_profile_setup
+c04349f8 t __setup_reserve_setup
+c0434a04 t __setup_boot_override_clocksource
+c0434a10 t __setup_boot_override_clock
+c0434a1c t __setup_noirqdebug_setup
+c0434a28 t __setup_irqfixup_setup
+c0434a34 t __setup_irqpoll_setup
+c0434a40 t __setup_disable_randmaps
+c0434a4c t __setup_noaliencache_setup
+c0434a58 t __setup_set_dhash_entries
+c0434a64 t __setup_set_ihash_entries
+c0434a70 t __setup_elevator_setup
+c0434a7c t __setup_pci_setup
+c0434a88 t __setup_no_scroll
+c0434a94 t __setup_acpi_parse_apic_instance
+c0434aa0 t __setup_acpi_os_name_setup
+c0434aac t __setup_acpi_osi_setup
+c0434ab8 t __setup_acpi_serialize_setup
+c0434ac4 t __setup_acpi_wake_gpes_always_on_setup
+c0434ad0 t __setup_acpi_ec_set_intr_mode
+c0434adc t __setup_acpi_irq_isa
+c0434ae8 t __setup_acpi_irq_pci
+c0434af4 t __setup_acpi_irq_nobalance_set
+c0434b00 t __setup_acpi_irq_balance_set
+c0434b0c t __setup_pnp_setup_reserve_irq
+c0434b18 t __setup_pnp_setup_reserve_dma
+c0434b24 t __setup_pnp_setup_reserve_io
+c0434b30 t __setup_pnp_setup_reserve_mem
+c0434b3c t __setup_pnpacpi_setup
+c0434b48 t __setup_sysrq_always_enabled_setup
+c0434b54 t __setup_hangcheck_parse_tick
+c0434b60 t __setup_hangcheck_parse_margin
+c0434b6c t __setup_hangcheck_parse_reboot
+c0434b78 t __setup_hangcheck_parse_dump_tasks
+c0434b84 t __setup_ramdisk_size
+c0434b90 t __setup_ramdisk_size2
+c0434b9c t __setup_ramdisk_blocksize
+c0434ba8 t __setup_ide_generic_all_on
+c0434bb4 t __setup_ide_setup
+c0434bc0 t __setup_acpi_pm_good_setup
+c0434bcc t __setup_netdev_boot_setup
+c0434bd8 t __setup_netdev_boot_setup
+c0434be4 t __setup_set_rhash_entries
+c0434bf0 t __setup_set_thash_entries
+c0434bfc t __initcall_net_ns_init1
+c0434bfc T __initcall_start
+c0434bfc T __setup_end
+c0434c00 t __initcall_reboot_init1
+c0434c04 t __initcall_sysctl_init1
+c0434c08 t __initcall_init_jiffies_clocksource1
+c0434c0c t __initcall_pm_init1
+c0434c10 t __initcall_ksysfs_init1
+c0434c14 t __initcall_filelock_init1
+c0434c18 t __initcall_init_misc_binfmt1
+c0434c1c t __initcall_init_script_binfmt1
+c0434c20 t __initcall_init_elf_binfmt1
+c0434c24 t __initcall_debugfs_init1
+c0434c28 t __initcall_random32_init1
+c0434c2c t __initcall_sock_init1
+c0434c30 t __initcall_netlink_proto_init1
+c0434c34 t __initcall_kobject_uevent_init2
+c0434c38 t __initcall_pcibus_class_init2
+c0434c3c t __initcall_pci_driver_init2
+c0434c40 t __initcall_tty_class_init2
+c0434c44 t __initcall_vtconsole_class_init2
+c0434c48 t __initcall_init_pit_clocksource3
+c0434c4c t __initcall_mtrr_if_init3
+c0434c50 t __initcall_kdump_buf_page_init3
+c0434c54 t __initcall_acpi_pci_init3
+c0434c58 t __initcall_init_acpi_device_notify3
+c0434c5c t __initcall_init_cyclone_clocksource3
+c0434c60 t __initcall_pci_access_init3
+c0434c64 t __initcall_request_standard_resources4
+c0434c68 t __initcall_topology_init4
+c0434c6c t __initcall_mtrr_init_finialize4
+c0434c70 t __initcall_param_sysfs_init4
+c0434c74 t __initcall_pm_sysrq_init4
+c0434c78 t __initcall_init_bio4
+c0434c7c t __initcall_genhd_device_init4
+c0434c80 t __initcall_acpi_init4
+c0434c84 t __initcall_acpi_scan_init4
+c0434c88 t __initcall_acpi_ec_init4
+c0434c8c t __initcall_acpi_pci_root_init4
+c0434c90 t __initcall_acpi_pci_link_init4
+c0434c94 t __initcall_acpi_power_init4
+c0434c98 t __initcall_acpi_system_init4
+c0434c9c t __initcall_acpi_event_init4
+c0434ca0 t __initcall_acpi_cm_sbs_init4
+c0434ca4 t __initcall_pnp_init4
+c0434ca8 t __initcall_pnpacpi_init4
+c0434cac t __initcall_misc_init4
+c0434cb0 t __initcall_usb_init4
+c0434cb4 t __initcall_serio_init4
+c0434cb8 t __initcall_input_init4
+c0434cbc t __initcall_md_init4
+c0434cc0 t __initcall_dma_bus_init4
+c0434cc4 t __initcall_pci_acpi_init4
+c0434cc8 t __initcall_pci_legacy_init4
+c0434ccc t __initcall_pcibios_irq_init4
+c0434cd0 t __initcall_pcibios_init4
+c0434cd4 t __initcall_proto_init4
+c0434cd8 t __initcall_net_dev_init4
+c0434cdc t __initcall_neigh_init4
+c0434ce0 t __initcall_fib_rules_init4
+c0434ce4 t __initcall_pktsched_init4
+c0434ce8 t __initcall_tc_filter_init4
+c0434cec t __initcall_genl_init4
+c0434cf0 t __initcall_wireless_nlevent_init4
+c0434cf4 t __initcall_clocksource_done_booting5
+c0434cf8 t __initcall_init_pipe_fs5
+c0434cfc t __initcall_eventpoll_init5
+c0434d00 t __initcall_anon_inode_init5
+c0434d04 t __initcall_pnp_system_init5
+c0434d08 t __initcall_chr_dev_init5
+c0434d0c t __initcall_firmware_class_init5
+c0434d10 t __initcall_init_acpi_pm_clocksource5
+c0434d14 t __initcall_pcibios_assign_resources5
+c0434d18 t __initcall_inet_init5
+c0434d1c t __initcall_populate_rootfsrootfs
+c0434d20 t __initcall_i8259A_init_sysfs6
+c0434d24 t __initcall_sbf_init6
+c0434d28 t __initcall_i8237A_init_sysfs6
+c0434d2c t __initcall_cache_sysfs_init6
+c0434d30 t __initcall_thermal_throttle_init_device6
+c0434d34 t __initcall_init_lapic_sysfs6
+c0434d38 t __initcall_ioapic_init_sysfs6
+c0434d3c t __initcall_hpet_register_sysfs6
+c0434d40 t __initcall_add_pcspkr6
+c0434d44 t __initcall_create_proc_profile6
+c0434d48 t __initcall_ioresources_init6
+c0434d4c t __initcall_uid_cache_init6
+c0434d50 t __initcall_init_posix_timers6
+c0434d54 t __initcall_init_posix_cpu_timers6
+c0434d58 t __initcall_latency_init6
+c0434d5c t __initcall_nsproxy_cache_init6
+c0434d60 t __initcall_init_network6
+c0434d64 t __initcall_init_vserver6
+c0434d68 t __initcall_timekeeping_init_device6
+c0434d6c t __initcall_init_clocksource_sysfs6
+c0434d70 t __initcall_init_timer_list_procfs6
+c0434d74 t __initcall_init6
+c0434d78 t __initcall_proc_dma_init6
+c0434d7c t __initcall_percpu_modinit6
+c0434d80 t __initcall_kallsyms_init6
+c0434d84 t __initcall_crash_notes_memory_init6
+c0434d88 t __initcall_init_kprobes6
+c0434d8c t __initcall_relay_init6
+c0434d90 t __initcall_utsname_sysctl_init6
+c0434d94 t __initcall_init_per_zone_pages_min6
+c0434d98 t __initcall_pdflush_init6
+c0434d9c t __initcall_kswapd_init6
+c0434da0 t __initcall_setup_vmstat6
+c0434da4 t __initcall_init_emergency_pool6
+c0434da8 t __initcall_procswaps_init6
+c0434dac t __initcall_init_tmpfs6
+c0434db0 t __initcall_cpucache_init6
+c0434db4 t __initcall_fasync_init6
+c0434db8 t __initcall_aio_setup6
+c0434dbc t __initcall_inotify_setup6
+c0434dc0 t __initcall_inotify_user_setup6
+c0434dc4 t __initcall_init_mbcache6
+c0434dc8 t __initcall_dquot_init6
+c0434dcc t __initcall_init_v2_quota_format6
+c0434dd0 t __initcall_dnotify_init6
+c0434dd4 t __initcall_vmcore_init6
+c0434dd8 t __initcall_init_devpts_fs6
+c0434ddc t __initcall_init_ext3_fs6
+c0434de0 t __initcall_journal_init6
+c0434de4 t __initcall_init_ext2_fs6
+c0434de8 t __initcall_init_cramfs_fs6
+c0434dec t __initcall_init_ramfs_fs6
+c0434df0 t __initcall_init_iso9660_fs6
+c0434df4 t __initcall_init_nls_cp4376
+c0434df8 t __initcall_init_nls_ascii6
+c0434dfc t __initcall_ipc_init6
+c0434e00 t __initcall_ipc_sysctl_init6
+c0434e04 t __initcall_init_mqueue_fs6
+c0434e08 t __initcall_noop_init6
+c0434e0c t __initcall_cfq_init6
+c0434e10 t __initcall_blk_trace_init6
+c0434e14 t __initcall_pci_init6
+c0434e18 t __initcall_pci_proc_init6
+c0434e1c t __initcall_pcie_portdrv_init6
+c0434e20 t __initcall_aer_service_init6
+c0434e24 t __initcall_acpi_reserve_resources6
+c0434e28 t __initcall_irqrouter_init_sysfs6
+c0434e2c t __initcall_rand_initialize6
+c0434e30 t __initcall_tty_init6
+c0434e34 t __initcall_pty_init6
+c0434e38 t __initcall_rtc_init6
+c0434e3c t __initcall_hpet_init6
+c0434e40 t __initcall_mod_init6
+c0434e44 t __initcall_hangcheck_init6
+c0434e48 t __initcall_serial8250_init6
+c0434e4c t __initcall_serial8250_pnp_init6
+c0434e50 t __initcall_serial8250_pci_init6
+c0434e54 t __initcall_topology_sysfs_init6
+c0434e58 t __initcall_rd_init6
+c0434e5c t __initcall_net_olddevs_init6
+c0434e60 t __initcall_loopback_init6
+c0434e64 t __initcall_etun_init6
+c0434e68 t __initcall_aec62xx_ide_init6
+c0434e6c t __initcall_ali15x3_ide_init6
+c0434e70 t __initcall_amd74xx_ide_init6
+c0434e74 t __initcall_atiixp_ide_init6
+c0434e78 t __initcall_cmd64x_ide_init6
+c0434e7c t __initcall_cs5520_ide_init6
+c0434e80 t __initcall_cs5530_ide_init6
+c0434e84 t __initcall_cs5535_ide_init6
+c0434e88 t __initcall_cy82c693_ide_init6
+c0434e8c t __initcall_hpt34x_ide_init6
+c0434e90 t __initcall_hpt366_ide_init6
+c0434e94 t __initcall_it821x_ide_init6
+c0434e98 t __initcall_jmicron_ide_init6
+c0434e9c t __initcall_pdc202xx_ide_init6
+c0434ea0 t __initcall_pdc202new_ide_init6
+c0434ea4 t __initcall_piix_ide_init6
+c0434ea8 t __initcall_rz1000_ide_init6
+c0434eac t __initcall_svwks_ide_init6
+c0434eb0 t __initcall_siimage_ide_init6
+c0434eb4 t __initcall_sis5513_ide_init6
+c0434eb8 t __initcall_slc90e66_ide_init6
+c0434ebc t __initcall_triflex_ide_init6
+c0434ec0 t __initcall_via_ide_init6
+c0434ec4 t __initcall_generic_ide_init6
+c0434ec8 t __initcall_ide_init6
+c0434ecc t __initcall_ide_generic_init6
+c0434ed0 t __initcall_idedisk_init6
+c0434ed4 t __initcall_ide_cdrom_init6
+c0434ed8 t __initcall_idefloppy_init6
+c0434edc t __initcall_cdrom_init6
+c0434ee0 t __initcall_usb_usual_init6
+c0434ee4 t __initcall_i8042_init6
+c0434ee8 t __initcall_mousedev_init6
+c0434eec t __initcall_evdev_init6
+c0434ef0 t __initcall_atkbd_init6
+c0434ef4 t __initcall_psmouse_init6
+c0434ef8 t __initcall_linear_init6
+c0434efc t __initcall_dm_init6
+c0434f00 t __initcall_efivars_init6
+c0434f04 t __initcall_hid_init6
+c0434f08 t __initcall_flow_cache_init6
+c0434f0c t __initcall_blackhole_module_init6
+c0434f10 t __initcall_tunnel4_init6
+c0434f14 t __initcall_ipv4_netfilter_init6
+c0434f18 t __initcall_cubictcp_register6
+c0434f1c t __initcall_af_unix_init6
+c0434f20 t __initcall_inet6_init6
+c0434f24 t __initcall_xfrm6_transport_init6
+c0434f28 t __initcall_xfrm6_tunnel_init6
+c0434f2c t __initcall_xfrm6_beet_init6
+c0434f30 t __initcall_sit_init6
+c0434f34 t __initcall_packet_init6
+c0434f38 t __initcall_check_nmi_watchdog7
+c0434f3c t __initcall_init_lapic_nmi_sysfs7
+c0434f40 t __initcall_io_apic_bug_finalize7
+c0434f44 t __initcall_print_ipi_mode7
+c0434f48 t __initcall_debugfs_kprobe_init7
+c0434f4c t __initcall_revokefs_init7
+c0434f50 t __initcall_random32_reseed7
+c0434f54 t __initcall_pci_sysfs_init7
+c0434f58 t __initcall_acpi_poweroff_init7
+c0434f5c t __initcall_seqgen_init7
+c0434f60 t __initcall_early_uart_console_switch7
+c0434f64 t __initcall_tcp_congestion_default7
+c0434f68 D __con_initcall_start
+c0434f68 d __initcall_con_init
+c0434f68 T __initcall_end
+c0434f6c d __initcall_serial8250_console_init
+c0434f70 d __initcall_early_uart_console_init
+c0434f74 R __alt_instructions
+c0434f74 D __con_initcall_end
+c0434f74 ? __security_initcall_end
+c0434f74 ? __security_initcall_start
+c0437697 R __alt_instructions_end
+c0438138 ? __parainstructions
+c0438138 ? __parainstructions_end
+c0438138 t cache_remove_dev
+c04381bb t exit_vserver
+c04381bc t exit_pipe_fs
+c04381dc t exit_misc_binfmt
+c04381f0 t exit_script_binfmt
+c04381fa t exit_elf_binfmt
+c0438204 t exit_mbcache
+c043820e t exit_v2_quota_format
+c0438218 t exit_devpts_fs
+c0438238 t exit_ext3_fs
+c043824c t journal_exit
+c0438251 t exit_ext2_fs
+c0438265 t exit_cramfs_fs
+c0438274 t exit_ramfs_fs
+c043827e t exit_iso9660_fs
+c0438292 t exit_nls_cp437
+c043829c t exit_nls_ascii
+c04382a6 t debugfs_exit
+c04382c9 t noop_exit
+c04382d3 t cfq_exit
+c0438375 t pcie_portdrv_exit
+c0438384 t aer_service_exit
+c043838e t cleanup_sysctl
+c0438398 t rtc_exit
+c04383f0 t hpet_exit
+c0438412 t mod_exit
+c043842b t hangcheck_exit
+c0438446 t serial8250_exit
+c0438473 t serial8250_pnp_exit
+c043847d t serial8250_pci_exit
+c0438487 t firmware_class_exit
+c0438491 t rd_cleanup
+c04384f4 t idedisk_exit
+c04384fe t ide_cdrom_exit
+c0438508 t idefloppy_exit
+c0438512 t cdrom_exit
+c0438532 t usb_exit
+c0438578 t usb_usual_exit
+c043859f t serio_exit
+c04385b3 t i8042_exit
+c04385d7 t input_exit
+c04385f5 t mousedev_exit
+c043860e t evdev_exit
+c0438618 t atkbd_exit
+c0438622 t psmouse_exit
+c0438636 t md_exit
+c0438718 t dm_exit
+c043872d t efivars_exit
+c043879d t hid_exit
+c04387ac t blackhole_module_exit
+c04387b6 t tunnel4_fini
+c04387f9 t cubictcp_unregister
+c0438803 t xfrm4_policy_fini
+c043880d t af_unix_exit
+c043882b t inet6_exit
+c04388bc T addrconf_cleanup
+c0438986 t xfrm6_transport_exit
+c043899e t xfrm6_tunnel_exit
+c04389b6 t xfrm6_beet_exit
+c04389ce t sit_destroy_tunnels
+c0438a02 t sit_cleanup
+c0438a2a t packet_exit
+c0439000 T __initramfs_start
+c0439086 T __initramfs_end
+c043a000 D __per_cpu_start
+c043a000 D per_cpu__init_tss
+c043d000 D per_cpu__current_task
+c043d004 d per_cpu__cpu_idle_state
+c043d008 D per_cpu__cpu_number
+c043d080 D per_cpu__irq_regs
+c043d100 D per_cpu__irq_stat
+c043e000 D per_cpu__gdt_page
+c043f000 d per_cpu__next_check
+c043f008 d per_cpu__thermal_throttle_count
+c043f00c d per_cpu__nmi_watchdog_ctlblk
+c043f080 D per_cpu__cpu_tlbstate
+c043f100 D per_cpu__cpu_state
+c043f104 D per_cpu__this_cpu_off
+c043f120 d per_cpu__lapic_events
+c043f168 d per_cpu__wd_enabled
+c043f180 D per_cpu__current_kprobe
+c043f1a0 D per_cpu__kprobe_ctlblk
+c043f240 D per_cpu__mmu_gathers
+c043fa80 d per_cpu__runqueues
+c0440440 d per_cpu__cpu_domains
+c0440520 d per_cpu__sched_group_cpus
+c0440540 d per_cpu__core_domains
+c0440620 d per_cpu__sched_group_core
+c0440640 d per_cpu__phys_domains
+c0440720 d per_cpu__sched_group_phys
+c0440740 D per_cpu__kstat
+c0440b00 D per_cpu__process_counts
+c0440b04 d per_cpu__cpu_profile_hits
+c0440b0c d per_cpu__cpu_profile_flip
+c0440b10 d per_cpu__tasklet_hi_vec
+c0440b14 d per_cpu__tasklet_vec
+c0440b18 d per_cpu__ksoftirqd
+c0440b1c d per_cpu__tvec_bases
+c0440b20 D per_cpu__rcu_data
+c0440b60 D per_cpu__rcu_bh_data
+c0440b9c d per_cpu__rcu_tasklet
+c0440bc0 D per_cpu__hrtimer_bases
+c0440c20 D per_cpu__tick_cpu_device
+c0440c28 d per_cpu__kprobe_instance
+c0440c2c d per_cpu__touch_timestamp
+c0440c30 d per_cpu__print_timestamp
+c0440c34 d per_cpu__watchdog_task
+c0440c40 d per_cpu__ratelimits.21761
+c0440c60 d per_cpu__committed_space
+c0440c80 d per_cpu__lru_add_pvecs
+c0440cc0 d per_cpu__lru_add_active_pvecs
+c0440d00 D per_cpu__vm_event_states
+c0440d80 d per_cpu__vmstat_work
+c0440dc0 d per_cpu__reap_work
+c0440de8 D per_cpu__quicklist
+c0440e00 d per_cpu__fdtable_defer_list
+c0440e40 d per_cpu__bh_accounting
+c0440e60 d per_cpu__bh_lrus
+c0440e80 d per_cpu__blk_cpu_done
+c0440e88 d per_cpu__ioc_count
+c0440e90 d per_cpu__blk_trace_cpu_offset
+c0440ea0 D per_cpu__radix_tree_preloads
+c0440ec0 d per_cpu__net_rand_state
+c0440ecc d per_cpu__trickle_count
+c0440ed0 d per_cpu__pcpu_lstats
+c0440f00 d per_cpu__sockets_in_use
+c0440f80 D per_cpu__softnet_data
+c0441600 D per_cpu__netdev_rx_stat
+c0441680 d per_cpu__flow_tables
+c0441700 d per_cpu__flow_hash_info
+c0441780 d per_cpu__flow_flush_tasklets
+c04417a0 d per_cpu__rt_cache_stat
+c04417e0 d per_cpu____icmpv6_socket
+c04417e4 D __per_cpu_end
+c0442000 B __bss_start
+c0442000 B __init_end
+c0442000 B swapper_pg_dir
+c0443000 B empty_zero_page
+c0444000 B system_state
+c0444004 B saved_command_line
+c0444008 B reset_devices
+c044400c B late_time_init
+c0444010 b static_command_line
+c0444014 b execute_command
+c0444018 b ramdisk_execute_command
+c044401c b panic_later
+c0444020 b panic_param
+c0444024 B Version_132630
+c0444040 B ROOT_DEV
+c0444060 b inbuf
+c0444064 b window
+c0444068 b insize
+c044406c b inptr
+c0444070 b outcnt
+c0444074 b exit_code
+c0444078 b unzip_error
+c044407c b bytes_out
+c0444080 b crd_infd
+c0444084 b crd_outfd
+c0444088 b bb
+c044408c b bk
+c0444090 b hufts
+c04440a0 b crc_32_tab
+c04444a0 b crc
+c04444a4 B initrd_below_start_ok
+c04444a8 B initrd_start
+c04444ac B initrd_end
+c04444b0 B real_root_dev
+c04444c0 b inbuf
+c04444c4 b window
+c04444c8 b insize
+c04444cc b inptr
+c04444d0 b outcnt
+c04444d4 b bytes_out
+c04444d8 b bb
+c04444dc b bk
+c04444e0 b hufts
+c0444500 b crc_32_tab
+c0444900 b crc
+c0444904 b preset_lpj
+c0444908 b dmi_bigsmp
+c044490c b id.4926
+c0444910 B psai
+c0444914 B mip_reg
+c0444918 B host_reg
+c044491c B mip_port
+c0444920 B mip_addr
+c0444924 B host_addr
+c0444928 b base
+c0445000 B boot_option_idle_override
+c0445004 B pm_idle
+c0445008 b hlt_counter
+c044500c B ignore_fpu_irq
+c0445010 B panic_on_unrecovered_nmi
+c0445014 b die_counter.19658
+c0446000 B irq_err_count
+c0446004 b __warned.12122
+c0447000 b softirq_stack
+c0457000 b hardirq_stack
+c0467000 B cmos_lock
+c0467004 B cpu_khz
+c0467008 B timer_ack
+c046700c B no_sync_cmos_clock
+c0467020 B disable_pse
+c0467024 B mmu_cr4_features
+c0467028 B machine_id
+c046702c B machine_submodel_id
+c0467030 B BIOS_revision
+c0467034 B mca_pentium_flag
+c0467038 B bootloader_type
+c0467040 B screen_info
+c0467080 B apm_info
+c04670c0 B edd
+c0467300 B edid_info
+c0467380 B ist_info
+c04673a0 B drive_info
+c04673c0 B saved_videomode
+c04673c4 B io_apic_irqs
+c04673c8 b spurious_irq_mask.12460
+c04673cc b i8259A_auto_eoi
+c04673d0 b irq_trigger
+c04673d4 B forbid_dac
+c04673e0 B efi_enabled
+c0467400 B e820
+c0467e20 b cpu_devices
+c04683e0 b noreplace_smp
+c04683e4 b debug_alternative
+c04683e8 b smp_alt_once
+c04683ec B global_clock_event
+c04683f0 b old_jifs.8711
+c04683f4 b old_count.8710
+c04683f8 B tsc_disable
+c04683fc B tsc_khz
+c0468400 b current_tsc_khz
+c0468404 b tsc_enabled
+c0468408 b tsc_unstable
+c0468420 B cpu_devs
+c0468444 b printed.16722
+c0468460 B num_cache_leaves
+c0468464 b is_initialized.11293
+c0468480 b cpuid4_info
+c04684c0 b cache_kobject
+c0468500 b index_kobject
+c0468540 B mce_disabled
+c0468544 B nr_mce_banks
+c0468548 b mce_num_extended_msrs
+c046854c B therm_throt_en
+c0468560 B num_var_ranges
+c0468564 B mtrr_if
+c0468568 B size_or_mask
+c0468570 B size_and_mask
+c0468578 B usage_table
+c0468580 b mtrr_ops
+c04685a4 b mtrr_state
+c04685a8 b proc_root_mtrr
+c04685c0 b cr4
+c04685e0 b mtrr_state
+c0468640 b smp_changes_mask
+c0468644 b mtrr_show
+c0468648 b deftype_lo
+c046864c b deftype_hi
+c0468650 B arr3_protected
+c0468654 b cr4
+c0468658 b ccr3
+c0468660 b centaur_mcr
+c04686a0 b centaur_mcr_reserved
+c04686a1 b centaur_mcr_type
+c04686a4 b wd_ops
+c04686a8 b perfctr_nmi_owner
+c04686b4 b evntsel_nmi_owner
+c04686c0 B acpi_disabled
+c04686c4 B acpi_irq_model
+c04686c8 B acpi_lapic
+c04686cc B acpi_ioapic
+c04686d0 B acpi_noirq
+c04686d4 B acpi_strict
+c04686d8 B pci_mmcfg_config
+c04686dc B pci_mmcfg_config_num
+c04686e0 b warned.18795
+c04686e4 B pm_power_off
+c04686e8 b no_idt
+c04686f0 b reboot_mode
+c04686f4 b reboot_thru_bios
+c04686f8 b flush_cpumask
+c04686fc b flush_mm
+c0468700 b flush_va
+c0468704 b call_data
+c0468720 B cpu_possible_map
+c0468724 B cpu_callout_map
+c0468728 B cpu_callin_map
+c0468740 B apicid_2_node
+c0468840 B xquad_portio
+c0468844 b smp_b_stepping
+c0468848 b smp_commenced_mask
+c046884c b trampoline_base
+c0468850 b trampoline_exec
+c0468854 b init_deasserted
+c0468858 b cpucount
+c046885c b cpu_sibling_setup_map
+c0468860 b boot_cpu_logical_apicid
+c0468880 B def_to_bigsmp
+c0468884 B es7000_plat
+c04688a0 B mp_bus_id_to_type
+c0468cc0 B mp_bus_id_to_node
+c04690e0 B mp_bus_id_to_local
+c0469500 B quad_local_to_mp_bus_id
+c0469540 B smp_found_config
+c0469544 B nr_ioapics
+c0469560 B apic_version
+c0469960 B mp_irq_entries
+c0469980 B mp_irqs
+c046a180 B mp_lapic_addr
+c046a184 B pic_mode
+c046a1a0 B phys_cpu_present_map
+c046a1c0 B mp_ioapics
+c046a3c0 b gsi_to_irq.21809
+c046e3c0 b mp_current_pci_id
+c046e3c4 b mpc_record
+c046e3c8 b mpf_found
+c046e3e0 b mp_ioapic_routing
+c046eae0 B apic_verbosity
+c046eae4 B local_apic_timer_c2_ok
+c046eae8 B local_apic_timer_disabled
+c046eaec b local_apic_timer_verify_ok
+c046eaf0 b calibration_result
+c046eaf4 b enabled_via_apicbase
+c046eb00 b apic_pm_state
+c046eb40 B nmi_active
+c046eb44 B nmi_watchdog_enabled
+c046eb48 B unknown_nmi_panic
+c046eb4c b backtrace_mask
+c046eb50 b nmi_pm_active
+c046eb60 b last_irq_sums
+c046eba0 b alert_counter
+c046ebe0 B nr_ioapic_registers
+c046ece0 B skip_ioapic_setup
+c046ece4 B timer_uses_ioapic_pin_0
+c046ece8 B ioapic_renumber_irq
+c046ecec B irq_mis_count
+c046ecf0 b current_offset.23162
+c046ed00 b apic_id_map.23956
+c046ed20 b __warned.23614
+c046ed24 b __warned.23608
+c046ed40 b irq_2_pin
+c0470240 b pirq_entries
+c0470260 b pirqs_enabled
+c0470280 b mp_ioapic_data
+c0471000 b kexec_pgd
+c0472000 b kexec_pte0
+c0473000 b kexec_pte1
+c0474000 b crashing_cpu
+c0474004 b waiting_for_crash_ipi
+c0474008 b kdump_buf_page
+c0474020 b vdso_mapped.16776
+c0474040 b gate_vma
+c0474094 b syscall_pages
+c04740a0 B efi
+c04740ec B memmap
+c0474120 b efi_phys
+c047416c b efi_rt_eflags
+c0474170 b efi_bak_pg_dir_pointer
+c0474180 b doublefault_stack
+c0475180 b vm86_irqs
+c0475200 b irqbits
+c0475204 b current_xpos
+c0475208 b early_console_initialized
+c047520c b simnow_fd
+c0475220 B hpet_address
+c0475224 b hpet_virt_address
+c0475228 b boot_hpet_disable
+c047522c b hpet_legacy_int_enabled
+c0475230 b hpet_period
+c0475234 b hpet_rtc_flags
+c0475238 b hpet_prev_update_sec
+c0475240 b hpet_alarm_time
+c0475264 b hpet_pie_count
+c0475268 b hpet_t1_cmp
+c047526c b hpet_default_delta
+c0475270 b hpet_pie_delta
+c0475274 b hpet_pie_limit
+c0475280 B nx_enabled
+c0475284 B pmd_cache
+c0475288 B highstart_pfn
+c047528c B highend_pfn
+c0475290 B kmap_pte
+c0475294 B kmap_prot
+c0475298 b kcore_mem
+c04752a4 b kcore_vmalloc
+c04752b0 B pgd_list
+c04752b4 b fixmaps
+c04752c0 b insync.19308
+c0475340 B no_broadcast
+c0475380 B nohz_cpu_mask
+c0475384 B sched_smt_power_savings
+c0475388 B sched_mc_power_savings
+c047538c B max_cache_size
+c0475390 b cpu_isolated_map
+c0475394 b prev_jiffy.33219
+c0475398 b __key.33172
+c0475398 b migration_debug
+c047539c B sighand_cachep
+c04753a0 B fs_cachep
+c04753a4 B total_forks
+c04753a8 B nr_threads
+c04753ac B files_cachep
+c04753b0 B vm_area_cachep
+c04753b4 B max_threads
+c04753b8 b __key.27160
+c04753b8 b __key.27161
+c04753b8 b __key.27162
+c04753b8 b __key.27284
+c04753b8 b __key.27346
+c04753b8 b __key.27567
+c04753b8 b __key.27589
+c04753b8 b __key.27921
+c04753b8 b task_struct_cachep
+c04753bc b signal_cachep
+c04753c0 b mm_cachep
+c04753e0 B panic_blink
+c04753e4 B panic_timeout
+c04753e8 B panic_on_oops
+c04753ec B tainted
+c04753f0 b spin_counter.11972
+c04753f4 b buf.11921
+c0475420 b buf.11895
+c0475820 b pause_on_oops
+c0475824 b pause_on_oops_flag
+c0475840 B oops_in_progress
+c0475844 B console_drivers
+c0475848 b printk_time
+c047584c b missed.25920
+c0475850 b last_msg.25919
+c0475860 b printk_buf.25560
+c0475c60 b __key.25501
+c0475c60 b oops_timestamp.25488
+c0475c64 b console_locked
+c0475c68 b console_suspended
+c0475c6c b log_start
+c0475c70 b con_start
+c0475c74 b log_end
+c0475c80 b console_cmdline
+c0475d00 b console_may_schedule
+c0475d20 b __log_buf
+c0495d20 b logged_chars
+c0495d24 b prof_buffer
+c0495d28 b prof_len
+c0495d2c b prof_shift
+c0495d30 B sys_tz
+c0495d38 b __warned.18398
+c0495d3c b __warned.18358
+c0495d40 b __warned.18352
+c0495d44 b __warned.18318
+c0495d48 b __warned.18312
+c0495d60 b reserve.13494
+c0495df0 b reserved.13493
+c0495e00 B sysctl_legacy_va_layout
+c0495e20 b dev_table
+c0495e4c b minolduid
+c0495e50 b zero
+c0495e60 b binfmt_misc_table
+c0495e8c B securebits
+c0495f00 B boot_tvec_bases
+c0496f80 B avenrun
+c0496f8c b __key.20666
+c0496f8c b boot_done.20654
+c0496f8d b tvec_base_done.20653
+c0496fa0 b uid_cachep
+c0496fa4 b sigqueue_cachep
+c0496fa8 B cad_pid
+c0496fac b __key.26145
+c0496fac b kmod_loop_msg.23944
+c0496fb0 b kmod_concurrent.23943
+c0496fb4 b khelper_wq
+c0496fb8 b __key.11561
+c0496fb8 b pid_hash
+c0496fbc b pidhash_shift
+c0496fc0 b pid_cachep
+c0496fc4 b rcu_barrier_cpu_count
+c0496fc8 b rcu_barrier_completion
+c0496fe4 B module_sysfs_initialized
+c0497000 b __key.19217
+c0497000 b posix_timers_cache
+c0497020 b posix_timers_id
+c0497040 b posix_clocks
+c04972c0 B kthreadd_task
+c04972e0 b kthread_stop_info
+c0497304 b __key.15731
+c0497304 b zero_it.10297
+c0497314 b __key.10296
+c0497314 b __key.11554
+c0497314 b __key.14637
+c0497314 b current_max_latency
+c0497318 b nsproxy_cachep
+c049731c b __key.10315
+c0497320 B vx_global_ctotal
+c0497324 B vx_global_cactive
+c0497328 b __key.16128
+c0497328 b __key.16129
+c0497340 b vx_info_hash
+c0497374 b vx_info_inactive
+c0497378 B vs_global_nsproxy
+c049737c B vs_global_fs
+c0497380 B vs_global_mnt_ns
+c0497384 B vs_global_uts_ns
+c0497388 B vs_global_ipc_ns
+c04973a0 B nx_global_ctotal
+c04973a4 B nx_global_cactive
+c04973c0 B nx_info_hash
+c04973f4 b nx_addr_v4_cachep
+c04973f8 b nx_addr_v6_cachep
+c04973fc B vx_area
+c0497400 B dl_info_hash
+c0497434 b __key.14293
+c0497434 b proc_virtual
+c0497438 b proc_virtnet
+c0497440 B xtime
+c0497450 B wall_to_monotonic
+c0497458 b total_sleep_time
+c049745c b clock
+c0497460 b timekeeping_suspended
+c0497464 b timekeeping_suspend_time
+c0497468 B tick_nsec
+c049746c B time_freq
+c0497470 B time_adjust
+c0497474 b time_state
+c0497478 b tick_length
+c0497480 b tick_length_base
+c0497488 b time_offset
+c0497490 b time_reftime
+c04974a0 b next_clocksource
+c04974a4 b clocksource_override
+c04974c0 b override_name
+c04974e0 b finished_booting
+c04974e4 b watchdog
+c04974e8 b watchdog_timer
+c0497500 b watchdog_last
+c0497508 b watchdog_resumed
+c049750c b clockevents_chain
+c0497510 B tick_next_period
+c0497518 B tick_period
+c0497520 B tick_broadcast_device
+c0497528 b tick_broadcast_mask
+c0497540 b __key.20431
+c0497540 b printk_interval.20178
+c0497560 b futex_queues
+c0499560 b futex_mnt
+c0499564 b __key.10846
+c0499564 b prev_max.10457
+c0499568 b cpu_hotplug_disabled
+c049956c b pcpu_num_used
+c0499570 b pcpu_num_allocated
+c0499574 b pcpu_size
+c0499578 B pm_ops
+c049957c b orig_fgconsole
+c0499580 b orig_kmsg
+c0499584 B pm_active
+c0499588 B kexec_image
+c049958c B kexec_crash_image
+c0499590 B crash_notes
+c0499594 b kexec_lock
+c04995a0 b rootnode
+c049a5fc b root_count
+c049a600 b need_forkexit_callback
+c049a620 b init_css_group
+c049a644 b init_css_group_link
+c049a658 b css_group_count
+c049a65c b __key.14474
+c049a65c b __key.14478
+c049a65c b stopmachine_state
+c049a660 b stopmachine_num_threads
+c049a664 b stopmachine_thread_ack
+c049a680 b kprobe_table
+c049a780 b kretprobe_inst_table
+c049a880 b kprobe_count
+c049a884 b kprobe_enabled
+c049a888 b kprobe_insn_pages
+c049a88c b kprobe_garbage_slots
+c049a890 b did_panic
+c049a894 B no_irq_affinity
+c049a898 b root_irq_dir
+c049a900 B max_low_pfn
+c049a904 B min_low_pfn
+c049a908 B max_pfn
+c049a90c B saved_max_pfn
+c049a910 b __key.19398
+c049a910 B sysctl_panic_on_oom
+c049a914 b count.17066
+c049a920 B hashdist
+c049a924 B nr_swap_pages
+c049a928 B percpu_pagelist_fraction
+c049a92c b __key.22348
+c049a92c b __key.22349
+c049a940 b contig_bootmem_data
+c049a960 B block_dump
+c049a964 B laptop_mode
+c049a968 B nr_pdflush_threads
+c049a96c b last_empty_jifs
+c049a970 B page_cluster
+c049a974 B vm_total_pages
+c049a980 B vm_stat
+c049aa00 B pkmap_page_table
+c049aa04 b __key.20191
+c049aa04 b __key.20195
+c049aa20 b pkmap_count
+c049ba20 b last_pkmap_nr
+c049ba24 b page_address_pool
+c049ba2c b pool_lock
+c049ba80 b page_address_htable
+c049fa80 b page_address_maps
+c04a3a80 B mem_map
+c04a3a84 B max_mapnr
+c04a3a88 B num_physpages
+c04a3a8c B high_memory
+c04a3a90 B vmalloc_earlyreserve
+c04a3a94 b __key.22474
+c04a3a94 B sysctl_overcommit_memory
+c04a3a98 B vm_committed_space
+c04a3a9c B anon_vma_cachep
+c04a3aa0 b __key.18453
+c04a3aa0 B vmlist
+c04a3aa4 b page_pool
+c04a3aa8 b isa_page_pool
+c04a3aac b swap_cache_info
+c04a3ae0 B total_swap_pages
+c04a3ae4 B nr_swapfiles
+c04a3ae8 b least_priority.27335
+c04a3aec b swap_overflow
+c04a3b00 b swap_info
+c04a4380 B swap_token_mm
+c04a4384 b global_faults
+c04a4388 b __key.25898
+c04a4388 b __key.26516
+c04a4388 b shmem_inode_cachep
+c04a438c b shm_mnt
+c04a4390 b __key.18056
+c04a4390 b __key.18790
+c04a4390 b slab_break_gfp_order
+c04a4394 b __key.18997
+c04a4394 b __key.19038
+c04a4394 b __key.19047
+c04a4394 b cache_chain
+c04a439c b g_cpucache_up
+c04a43a0 b __xip_sparse_page
+c04a43c0 b __key.22995
+c04a43c0 b __key.23672
+c04a43c0 b old_max.23667
+c04a43c4 b __key.22677
+c04a43e0 b __key.27005
+c04a43e0 b __key.27006
+c04a43e0 b __key.27007
+c04a43e0 b __key.27008
+c04a43e0 b __key.27009
+c04a43e0 b __key.27010
+c04a43e0 b default_op.27003
+c04a4440 b unnamed_dev_idr
+c04a4460 b cdev_map
+c04a4480 b chrdevs
+c04a487c B suid_dumpable
+c04a4880 B core_uses_pid
+c04a4884 b formats
+c04a48a0 b _buffer.25831
+c04a58a0 b _buffer.25438
+c04a68a0 b __key.25428
+c04a68a0 B inodes_stat
+c04a68c0 b empty_fops.24398
+c04a6940 b empty_iops.24397
+c04a69a0 b empty_aops.24396
+c04a69dc b counter.24746
+c04a69e0 b last_ino.24664
+c04a69e4 b __key.17372
+c04a69e4 b __key.24432
+c04a69e4 b __key.24433
+c04a69e4 b __key.24434
+c04a69e4 b __key.24435
+c04a69e4 b __key.24436
+c04a69e4 b __key.24437
+c04a69e4 b __key.24439
+c04a69e4 b file_systems
+c04a69e8 b __key.26064
+c04a69e8 b event
+c04a69ec b namespace_sem
+c04a6a08 B aio_nr
+c04a6a0c b __key.24229
+c04a6a0c b __key.24230
+c04a6a0c b kiocb_cachep
+c04a6a10 b kioctx_cachep
+c04a6a14 b aio_wq
+c04a6a18 b __key.12125
+c04a6a18 b __key.18067
+c04a6a18 B sysctl_drop_caches
+c04a6a1c B buffer_heads_over_limit
+c04a6a20 b msg_count.23794
+c04a6a24 b bh_cachep
+c04a6a28 b max_buffer_heads
+c04a6a2c b fs_bio_set
+c04a6a30 b bio_dirty_list
+c04a6a34 B blockdev_superblock
+c04a6a38 b __key.20207
+c04a6a38 b __key.20373
+c04a6a38 b revokefs_inode_cache
+c04a6a3c b revokefs_mnt
+c04a6a40 b __key.14847
+c04a6a40 b inotify_cookie
+c04a6a44 b __key.15369
+c04a6a44 b __key.15370
+c04a6a44 b zero
+c04a6a48 b __key.16959
+c04a6a48 b __key.17092
+c04a6a48 b __key.17093
+c04a6a48 b __key.17473
+c04a6a48 b epmutex
+c04a6a64 b psw
+c04a6a80 b anon_inode_inode
+c04a6aa0 b anon_inode_fops
+c04a6b10 b bm_mnt
+c04a6b14 b entry_count
+c04a6b18 b mb_shrinker
+c04a6b20 B dqstats
+c04a6b40 b __key.24837
+c04a6b40 b quota_formats
+c04a6b44 b dquot_cachep
+c04a6b48 b dq_hash_bits
+c04a6b4c b dq_hash_mask
+c04a6b50 b dquot_hash
+c04a6b58 B proc_mnt
+c04a6b5c b proc_inode_cachep
+c04a6b60 B proc_root_fs
+c04a6b64 B proc_bus
+c04a6b68 B proc_root_driver
+c04a6b6c B proc_virtual
+c04a6b70 B maps_protect
+c04a6b74 b proc_tty_ldisc
+c04a6b78 b proc_tty_driver
+c04a6b7c B proc_root_kcore
+c04a6b80 b p.21867
+c04a6b84 b proc_sys_root
+c04a6b88 b proc_net_shadow
+c04a6b8c b kclist
+c04a6b90 B proc_vmcore
+c04a6b94 b elfcorebuf
+c04a6b98 b elfcorebuf_sz
+c04a6ba0 b vmcore_size
+c04a6ba8 B sysfs_sb
+c04a6bac B sysfs_mount
+c04a6bb0 B sysfs_dir_cachep
+c04a6bb4 b __key.12318
+c04a6bb4 b devpts_mnt
+c04a6bb8 b devpts_root
+c04a6bbc b __key.18943
+c04a6bbc b __key.18957
+c04a6bbc b __key.22047
+c04a6bbc b __key.22048
+c04a6bbc b __key.22618
+c04a6bbc b __key.22619
+c04a6bbc b ext3_inode_cachep
+c04a6bc0 b ext3_xattr_cache
+c04a6bc4 b __key.18771
+c04a6bc4 b __key.18875
+c04a6bc4 b revoke_record_cache
+c04a6bc8 b revoke_table_cache
+c04a6bcc B jbd_handle_cache
+c04a6bd0 b last_warning.20256
+c04a6bd4 b __key.19460
+c04a6bd4 b __key.19461
+c04a6bd4 b __key.19462
+c04a6bd4 b __key.19463
+c04a6bd4 b __key.19464
+c04a6bd4 b jbd_slab
+c04a6be8 b journal_head_cache
+c04a6bec b __key.19996
+c04a6bec b __key.20010
+c04a6bec b __key.20701
+c04a6bec b __key.20702
+c04a6bec b __key.21059
+c04a6bec b ext2_inode_cachep
+c04a6bf0 b ext2_xattr_cache
+c04a6c00 b zerotime.19927
+c04a6c20 b read_buffers
+c04aec20 b buffer_blocknr
+c04aec28 b buffer_dev
+c04aec30 b next_buffer
+c04aec40 b stream
+c04aec70 b initialized
+c04aec80 b isofs_inode_cachep
+c04aeca0 b zisofs_sink_page
+c04afca0 b zisofs_zlib_workspace
+c04afcc0 b zisofs_zlib_semaphore
+c04afce0 b initialized
+c04afce4 b debugfs_mount
+c04afce8 b debugfs_mount_count
+c04afd00 b __key.22972
+c04afd00 b __key.23054
+c04afd00 b msg_bytes
+c04afd04 b msg_hdrs
+c04afd20 b init_msg_ids
+c04afd60 b __key.25026
+c04afd60 b init_sem_ids
+c04afda0 b init_shm_ids
+c04afdd0 b __key.28171
+c04afdd0 b __key.28925
+c04afdd0 b mq_lock
+c04afde0 b mqueue_inode_cachep
+c04afde4 b mqueue_mnt
+c04afde8 b queues_count
+c04afdec b mq_sysctl_table
+c04afdf0 b __warned.18910
+c04afdf4 b __warned.18832
+c04afe00 b __key.19848
+c04afe00 b printed.20149
+c04afe04 b chosen_elevator
+c04afe14 B blk_max_low_pfn
+c04afe18 B blk_max_pfn
+c04afe1c b __key.22209
+c04afe1c b __key.22235
+c04afe1c b request_cachep
+c04afe20 b requestq_cachep
+c04afe24 b iocontext_cachep
+c04afe28 b kblockd_workqueue
+c04afe40 b major_names
+c04b023c b bdev_map
+c04b0240 b cfq_pool
+c04b0244 b cfq_ioc_pool
+c04b0248 b ioc_gone
+c04b024c b __key.20196
+c04b024c b blk_tree_root
+c04b0250 b blk_tree_mutex
+c04b026c b root_users
+c04b0270 b __key.8093
+c04b0270 b idr_layer_cache
+c04b0274 b __key.7947
+c04b0278 B uevent_seqnum
+c04b0280 b uevent_sock
+c04b02a0 b index_bits_to_maxindex
+c04b0320 b radix_tree_node_cachep
+c04b0324 b __key.10317
+c04b0324 B debug_locks_silent
+c04b0380 B platform_pci_choose_state
+c04b0384 B platform_pci_set_power_state
+c04b0388 B pci_pci_problems
+c04b038c B pcie_mch_quirk
+c04b0390 B isa_dma_bridge_buggy
+c04b0394 b asus_hides_smbus
+c04b0398 b __key.18482
+c04b0398 b sysfs_initialized
+c04b039c b proc_initialized
+c04b03a0 b proc_bus_pci_dir
+c04b03c0 b errmsg_buff
+c04b0424 b forceload
+c04b0428 b __key.18731
+c04b0428 b ctrlset_buf
+c04b0434 b global_ctrlsets
+c04b0440 b vga_bootup_console.18555
+c04b0444 b cursor_size_lastfrom
+c04b0448 b cursor_size_lastto
+c04b044c b vgacon_xres
+c04b0450 b vgacon_yres
+c04b0460 b state
+c04b0488 b vgacon_uni_pagedir
+c04b0490 b vga_video_num_columns
+c04b0494 b vga_video_num_lines
+c04b0498 b vga_vesa_blanked
+c04b049c b vga_palette_blanked
+c04b04a0 b vga_is_gfx
+c04b04a4 b vga_512_chars
+c04b04a8 b vga_video_font_height
+c04b04ac b vga_rolled_over
+c04b04b0 b vgacon_scrollback
+c04b04b4 b vgacon_scrollback_tail
+c04b04b8 b vgacon_scrollback_size
+c04b04bc b vgacon_scrollback_rows
+c04b04c0 b vgacon_scrollback_cnt
+c04b04c4 b vgacon_scrollback_cur
+c04b04c8 b vgacon_scrollback_save
+c04b04cc b vgacon_scrollback_restore
+c04b04d0 b vga_state
+c04b04e0 B acpi_do_set_cstate_limit
+c04b04e4 B osi_linux
+c04b04e8 b __key.23375
+c04b04e8 b t.23118
+c04b0500 b buffer.23022
+c04b0700 b acpi_irq_irq
+c04b0704 b acpi_irq_handler
+c04b0708 b acpi_irq_context
+c04b070c b kacpid_wq
+c04b0710 b kacpi_notify_wq
+c04b0720 b osi_additional_string
+c04b0760 b acpi_os_name
+c04b07c4 b facs
+c04b07c8 b acpi_ev_global_lock_thread_id
+c04b07cc b acpi_ev_global_lock_acquired
+c04b07d0 b acpi_gbl_depth
+c04b07e0 B acpi_gbl_enable_interpreter_slack
+c04b07e1 B acpi_gbl_all_methods_serialized
+c04b07e4 B acpi_gbl_nesting_level
+c04b07e8 B acpi_gbl_db_terminate_threads
+c04b07e9 B acpi_gbl_abort_method
+c04b07ea B acpi_gbl_method_executing
+c04b07ec B acpi_gbl_startup_flags
+c04b07f0 B acpi_gpe_count
+c04b07f4 B acpi_gbl_original_dbg_level
+c04b07f8 B acpi_gbl_original_dbg_layer
+c04b07fc B acpi_gbl_trace_method_name
+c04b0800 B acpi_gbl_trace_dbg_level
+c04b0804 B acpi_gbl_trace_dbg_layer
+c04b0808 B acpi_gbl_trace_flags
+c04b080c B acpi_gbl_root_table_list
+c04b0820 B acpi_gbl_FADT
+c04b0914 B acpi_gbl_xpm1a_enable
+c04b0920 B acpi_gbl_xpm1b_enable
+c04b092c B acpi_gbl_integer_bit_width
+c04b092d B acpi_gbl_integer_byte_width
+c04b092e B acpi_gbl_integer_nybble_width
+c04b0940 B acpi_gbl_mutex_info
+c04b09a0 B acpi_gbl_global_lock_mutex
+c04b09a4 B acpi_gbl_global_lock_semaphore
+c04b09a8 B _acpi_gbl_gpe_lock
+c04b09b8 B _acpi_gbl_hardware_lock
+c04b09c8 B acpi_gbl_namespace_cache
+c04b09cc B acpi_gbl_state_cache
+c04b09d0 B acpi_gbl_ps_node_cache
+c04b09d4 B acpi_gbl_ps_node_ext_cache
+c04b09d8 B acpi_gbl_operand_cache
+c04b09dc B acpi_gbl_device_notify
+c04b09f4 B acpi_gbl_system_notify
+c04b0a0c B acpi_gbl_exception_handler
+c04b0a10 B acpi_gbl_init_handler
+c04b0a14 B acpi_gbl_breakpoint_walk
+c04b0a18 B acpi_gbl_original_mode
+c04b0a1c B acpi_gbl_rsdp_original_location
+c04b0a20 B acpi_gbl_ns_lookup_count
+c04b0a24 B acpi_gbl_ps_find_count
+c04b0a40 B acpi_gbl_owner_id_mask
+c04b0a60 B acpi_gbl_pm1_enable_register_save
+c04b0a62 B acpi_gbl_global_lock_handle
+c04b0a64 B acpi_gbl_last_owner_id_index
+c04b0a65 B acpi_gbl_next_owner_id_offset
+c04b0a66 B acpi_gbl_debugger_configuration
+c04b0a67 B acpi_gbl_global_lock_acquired
+c04b0a68 B acpi_gbl_step_to_next_call
+c04b0a69 B acpi_gbl_acpi_hardware_present
+c04b0a6a B acpi_gbl_global_lock_present
+c04b0a6b B acpi_gbl_events_initialized
+c04b0a6c B acpi_gbl_system_awake_and_running
+c04b0a70 B acpi_gbl_root_node_struct
+c04b0a84 B acpi_gbl_root_node
+c04b0a88 B acpi_gbl_fadt_gpe_device
+c04b0a8c B acpi_gbl_current_walk_list
+c04b0a90 B acpi_gbl_cm_single_step
+c04b0a91 B acpi_gbl_sleep_type_a
+c04b0a92 B acpi_gbl_sleep_type_b
+c04b0aa0 B acpi_gbl_fixed_event_handlers
+c04b0ac8 B acpi_gbl_gpe_xrupt_list_head
+c04b0acc B acpi_gbl_gpe_fadt_blocks
+c04b0ad4 B acpi_gbl_db_output_flags
+c04b0ad8 b __key.10111
+c04b0ad8 b __key.10112
+c04b0ad8 B acpi_gbl_permanent_mmap
+c04b0adc B acpi_root_dir
+c04b0ae0 B acpi_root
+c04b0ae4 b __key.19457
+c04b0ae4 b boot_ec
+c04b0ae8 b first_ec
+c04b0aec b acpi_ec_dir
+c04b0af0 b sub_driver
+c04b0af4 b acpi_link
+c04b0b00 b acpi_irq_balance
+c04b0b04 b acpi_prt
+c04b0b10 b __key.15927
+c04b0b10 b acpi_power_resource_list
+c04b0b18 b acpi_power_dir
+c04b0b20 b tables_kobj
+c04b0b80 B event_is_open
+c04b0b84 b ptr.18334
+c04b0b88 b chars_remaining.18333
+c04b0ba0 b str.18332
+c04b0bf0 b acpi_ac_dir
+c04b0bf4 b acpi_battery_dir
+c04b0bf8 b lock_ac_dir_cnt
+c04b0bfc b lock_battery_dir_cnt
+c04b0c00 B pnp_platform_devices
+c04b0c04 b num
+c04b0c80 b mem_class
+c04b0d00 b last_value.16747
+c04b0d04 b input_timer_state
+c04b0d20 b irq_timer_state
+c04b1100 b ip_keydata
+c04b1200 b ip_cnt
+c04b1204 b min_write_thresh
+c04b1208 b sysctl_bootid
+c04b1220 b input_pool_data
+c04b1420 b nonblocking_pool_data
+c04b14a0 b blocking_pool_data
+c04b1520 b __key.19306
+c04b1520 b __key.21020
+c04b1520 b __key.21022
+c04b1520 b __key.21023
+c04b1520 b __key.21024
+c04b1520 b __warned.21263
+c04b1540 b tty_ldiscs
+c04b1a4c b redirect
+c04b1a50 b tty_class
+c04b1a60 b tty_cdev
+c04b1ae0 b console_cdev
+c04b1b60 b ptmx_cdev
+c04b1be0 b vc0_cdev
+c04b1c44 B ptm_driver
+c04b1c48 b pts_driver
+c04b1c4c b pty_limit_min
+c04b1c50 b misc_minors
+c04b1c58 b misc_class
+c04b1c5c B vt_dont_switch
+c04b1c60 b vc_class
+c04b1c80 b inv_translate
+c04b1d7c b dflt
+c04b1d80 B sel_cons
+c04b1d84 b sel_end
+c04b1d88 b sel_buffer_lth
+c04b1d8c b sel_buffer
+c04b1da0 B shift_state
+c04b1dc0 B kbd_table
+c04b1efc b releasestart.18986
+c04b1f00 b committing.18985
+c04b1f04 b pressed.18984
+c04b1f08 b committed.18970
+c04b1f0c b chords.18969
+c04b1f20 b key_down
+c04b1f60 b shift_down
+c04b1f6c b dead_key_next
+c04b1f70 b diacr
+c04b1f74 b rep
+c04b1f75 b ledioctl
+c04b1f80 b ledptrs
+c04b1fa4 b sysrq_down
+c04b1fa8 b sysrq_alt_use
+c04b1fac b sysrq_alt
+c04b1fc0 B kmsg_redirect
+c04b1fc4 B conswitchp
+c04b1fe0 B vc_cons
+c04b24cc B fg_console
+c04b24d0 B last_console
+c04b24e0 B con_buf
+c04b34e0 B console_blanked
+c04b34e4 B do_poke_blanked_console
+c04b34e8 B console_blank_hook
+c04b34ec B console_driver
+c04b34f0 b printing.20863
+c04b34f4 b error.20650
+c04b34f8 b oldy.19350
+c04b34fa b oldx.19349
+c04b34fc b old.19348
+c04b3500 b registered_con_driver
+c04b36c0 b con_driver_map
+c04b37bc b printable
+c04b37c0 b default_utf8
+c04b37c4 b ignore_poke
+c04b37c8 b vesa_blank_mode
+c04b37cc b vesa_off_interval
+c04b37d0 b master_display_fg
+c04b37d4 b scrollback_delta
+c04b37d8 b blank_state
+c04b37dc b blank_timer_expired
+c04b37e0 b softcursor_original
+c04b37e4 b vtconsole_class
+c04b37e8 B funcbufleft
+c04b37ec b rtc_freq
+c04b37f0 b rtc_status
+c04b37f4 b rtc_irq_data
+c04b37f8 b rtc_callback
+c04b37fc b rtc_async_queue
+c04b3800 b sysctl_header
+c04b3804 b last.21373
+c04b3808 b hpet_nhpet
+c04b380c b hpets
+c04b3810 b sysctl_header
+c04b3814 b current_rng
+c04b3818 b hangcheck_reboot
+c04b381c b hangcheck_dump_tasks
+c04b3820 b hangcheck_tsc
+c04b3828 b hangcheck_tsc_margin
+c04b3840 b __key.18025
+c04b3840 b __key.18192
+c04b3840 b __key.18239
+c04b3840 b __key.18283
+c04b3840 b __key.18595
+c04b3840 b probe_rsa
+c04b3850 b probe_rsa_count
+c04b3860 b irq_lists
+c04b49e0 b serial8250_ports
+c04b62e0 b serial8250_isa_devs
+c04b6300 B platform_notify
+c04b6304 B platform_notify_remove
+c04b6308 b virtual_dir.8950
+c04b630c b __key.8939
+c04b630c b __key.8984
+c04b630c b probe_count
+c04b6320 b cpu_sys_devices
+c04b6360 b attribute_container_list
+c04b6368 B platform_enable_wakeup
+c04b636c b __key.17082
+c04b636c b topology_dev_map
+c04b6380 b rd_disks
+c04b63c0 b rd_bdev
+c04b6400 b rd_queue
+c04b6480 b m5229_revision
+c04b6481 b chip_is_1543c_e
+c04b6484 b isa_dev
+c04b6488 b amd_config
+c04b648c b amd_chipset
+c04b6490 b amd_80w
+c04b6494 b amd_clock
+c04b6498 b save_mdma_mode
+c04b64a8 b primary
+c04b64ac b it8212_noraid
+c04b64b0 b no_piix_dma
+c04b64b4 b svwks_revision
+c04b64b8 b isa_dev
+c04b64bc b chipset_family
+c04b64c0 b via_clock
+c04b64c4 b ide_generic_all
+c04b6500 B noautodma
+c04b6580 B ide_hwifs
+c04bba80 b tmp_hwif.23020
+c04bc300 b idebus_parameter
+c04bc304 b system_bus_speed
+c04bc308 b ide_scan_direction
+c04bc30c b count.23828
+c04bc310 b last_msgtime.23827
+c04bc314 B cmd640_vlb
+c04bc318 b cmd_hwif0
+c04bc31c b cmd_hwif1
+c04bc320 b cmd_drives
+c04bc330 b cmd640_key
+c04bc334 b __put_cmd640_reg
+c04bc338 b __get_cmd640_reg
+c04bc33c b cmd640_chip_version
+c04bc340 b ignore
+c04bc360 b dum.23366
+c04bc560 b dum.23318
+c04bc760 b initialized.23262
+c04bc764 b banner_printed.20582
+c04bc768 b debug
+c04bc76c b keeplocked
+c04bc770 b autoeject
+c04bc774 b check_media_type
+c04bc778 b topCdromPtr
+c04bc780 b cdrom_sysctl_settings
+c04bcb7c b cdrom_sysctl_header
+c04bcb80 B ksuspend_usb_wq
+c04bcb84 b __key.18870
+c04bcb84 b nousb
+c04bcb88 b blinkenlights
+c04bcb8c b old_scheme_first
+c04bcb90 b __key.16158
+c04bcb90 b __key.17553
+c04bcb90 b __key.17569
+c04bcb90 b khubd_task
+c04bcb94 b highspeed_hubs
+c04bcb98 b busmap
+c04bcba0 b usb_host_class
+c04bcba4 b __key.16567
+c04bcba4 b __key.17107
+c04bcba4 b __key.19142
+c04bcba4 b __key.19153
+c04bcba4 b __key.19165
+c04bcba4 b __key.19915
+c04bcbc0 b usb_minors
+c04bcfc0 b usb_class
+c04bcfc4 b usb_endpoint_major
+c04bcfc8 b ep_class
+c04bcfcc b usbfs_snoop
+c04bcfd0 b __key.24419
+c04bcfd0 b usb_classdev_class
+c04bcfd4 b usbdir
+c04bcfd8 b ignore_mount
+c04bcfdc b usbfs_mount
+c04bcfe0 b usbfs_mount_count
+c04bcfe4 b devices_usbfs_dentry
+c04bcfe8 b num_buses
+c04bcfec b devuid
+c04bcff0 b busuid
+c04bcff4 b listuid
+c04bcff8 b devgid
+c04bcffc b busgid
+c04bd000 b listgid
+c04bd004 b conndiscevcnt
+c04bd008 b total_threads
+c04bd00c b stat
+c04bd020 b __key.12264
+c04bd020 b __key.12265
+c04bd020 b serio_no.12263
+c04bd024 b serio_task
+c04bd040 b last_str.12939
+c04bd044 b last_transmit.12938
+c04bd048 b led.13200
+c04bd04c b last_blink.13199
+c04bd050 b i8042_nokbd
+c04bd054 b i8042_noaux
+c04bd058 b i8042_nomux
+c04bd05c b i8042_unlock
+c04bd060 b i8042_reset
+c04bd064 b i8042_direct
+c04bd068 b i8042_dumbkbd
+c04bd06c b i8042_noloop
+c04bd070 b i8042_nopnp
+c04bd074 b i8042_debug
+c04bd078 b i8042_kbd_irq
+c04bd07c b i8042_aux_irq
+c04bd080 b i8042_pnp_kbd_registered
+c04bd084 b i8042_pnp_kbd_devices
+c04bd088 b i8042_pnp_aux_registered
+c04bd08c b i8042_pnp_aux_devices
+c04bd090 b i8042_pnp_command_reg
+c04bd094 b i8042_pnp_data_reg
+c04bd098 b i8042_pnp_kbd_irq
+c04bd09c b i8042_pnp_aux_irq
+c04bd0a0 b i8042_pnp_kbd_name
+c04bd0c0 b i8042_pnp_aux_name
+c04bd0e0 b i8042_start_time
+c04bd100 b i8042_ports
+c04bd148 b i8042_initial_ctr
+c04bd149 b i8042_ctr
+c04bd14a b i8042_mux_present
+c04bd14b b i8042_kbd_irq_registered
+c04bd14c b i8042_aux_irq_registered
+c04bd14d b i8042_suppress_kbd_ack
+c04bd150 b i8042_platform_device
+c04bd154 b i8042_aux_irq_delivered
+c04bd170 b i8042_irq_being_tested
+c04bd174 b __key.16266
+c04bd180 b input_no.17807
+c04bd184 b __key.17759
+c04bd1a0 b input_table
+c04bd1c0 b proc_bus_input_dir
+c04bd1c4 b input_devices_state
+c04bd1c8 b __key.13369
+c04bd1e0 b __key.16120
+c04bd1e0 b mousedev_table
+c04bd260 b mousedev_mix
+c04bd320 b evdev_table
+c04bd3a0 b __key.16712
+c04bd3a0 b atkbd_reset
+c04bd3a4 b atkbd_softrepeat
+c04bd3a8 b atkbd_scroll
+c04bd3ac b atkbd_extra
+c04bd3b0 b psmouse_resync_time
+c04bd3b4 b kpsmoused_wq
+c04bd3b8 b desired_serio_phys
+c04bd3bc b lifebook_use_6byte_proto
+c04bd3c0 B __i2c_first_dynamic_bus_num
+c04bd3e0 B mdp_major
+c04bd3e4 b __key.21780
+c04bd3e4 b __key.21781
+c04bd3e4 b raid_table_header
+c04bd3e8 b start_readonly
+c04bd3ec b md_event_count
+c04bd3f0 b start_dirty_degraded
+c04bd400 b detected_devices
+c04bd600 b dev_cnt
+c04bd604 b __key.22513
+c04bd620 b major
+c04bd624 b _major
+c04bd628 b __key.21883
+c04bd628 b __key.21884
+c04bd628 b __key.21885
+c04bd628 b _io_cache
+c04bd62c b _tio_cache
+c04bd640 b _name_buckets
+c04bd840 b _uuid_buckets
+c04bda40 b kcopyd_clients
+c04bda44 b __key.20375
+c04bda44 b _kcopyd_wq
+c04bda48 b _kcopyd_work
+c04bda58 b _job_cache
+c04bda5c b _job_pool
+c04bda60 b dmi_ident
+c04bda8c B use_cyclone
+c04bda90 b cyclone_ptr
+c04bda94 b acpi_pm_good
+c04bda98 b __key.18269
+c04bda98 b __key.18279
+c04bda98 b id.17984
+c04bda9c b quirks_param
+c04bdaac b __key.17900
+c04bdaac b __key.17923
+c04bdaac b __key.19116
+c04bdaac b __key.19117
+c04bdaac b __key.19118
+c04bdaac b hid_mousepoll_interval
+c04bdac0 b pci_bios_present
+c04bdac4 b mmcfg_last_accessed_device
+c04bdac8 b mmcfg_last_accessed_cpu
+c04bdae0 B pci_mmcfg_fallback_slots
+c04bdb20 b quirk_aspm_offset
+c04bdbe0 b toshiba_line_size
+c04bdbe4 B pcibios_enable_irq
+c04bdbe8 B pcibios_disable_irq
+c04bdbec b eisa_irq_mask.21876
+c04bdbf0 b broken_hp_bios_irq9
+c04bdbf4 b acer_tm360_irqrouting
+c04bdbf8 b pirq_table
+c04bdbfc b pirq_router
+c04bdc0c b pirq_router_dev
+c04bdc10 B raw_pci_ops
+c04bdc14 B pirq_table_addr
+c04bdc18 B pci_root_bus
+c04bdc1c B pcibios_scanned
+c04bdc20 B pci_routeirq
+c04bdc24 b pci_bf_sort
+c04bdc40 B saved_context_ebx
+c04bdc44 B saved_context_esp
+c04bdc48 B saved_context_ebp
+c04bdc4c B saved_context_esi
+c04bdc50 B saved_context_edi
+c04bdc54 B saved_context_eflags
+c04bdc60 b saved_context
+c04bdd00 b br_ioctl_hook
+c04bdd04 b warned.32462
+c04bdd08 b vlan_ioctl_hook
+c04bdd0c b dlci_ioctl_hook
+c04bdd80 b __key.19540
+c04bdd80 b __key.34859
+c04bdd80 b __key.34910
+c04bdd80 b __key.34911
+c04bdd80 b __key.35351
+c04bdd80 b __key.35352
+c04bdd80 b warncomm.34524
+c04bdd90 b warned.34523
+c04bdd94 b warned.34502
+c04bdd98 b __key.25796
+c04bdda0 b elist
+c04bde80 B init_net
+c04be680 b net_cachep
+c04be6a0 b __key.19191
+c04be6a0 b __key.31153
+c04be6a0 b __key.31176
+c04be6a0 b ifindex.30727
+c04be6a4 b netdev_chain
+c04be6a8 b __key.30750
+c04be6a8 b __key.30751
+c04be6a8 b __key.30752
+c04be6a8 b netstamp_needed
+c04be6c0 b dev_boot_setup
+c04be7c0 b gifconf_list
+c04be848 b dst_garbage_list
+c04be84c b dst_gc_timer_expires
+c04be850 b __key.16600
+c04be850 b __key.25769
+c04be850 b __key.26581
+c04be850 b __key.26847
+c04be850 b neigh_tables
+c04be860 b rtnl_msg_handlers
+c04be8e8 b rta_buf
+c04be8ec b rtattr_max
+c04be8f0 b linkwatch_flags
+c04be8f4 b linkwatch_nextevent
+c04be8f8 b lweventlist
+c04be8fc B flow_cache_genid
+c04be900 b flow_hash_shift
+c04be904 b flow_lwm
+c04be908 b flow_hwm
+c04be90c b flow_hash_rnd_timer
+c04be924 b __key.26355
+c04be940 B tr_table
+c04be96c b __key.19201
+c04be96c b qdisc_base
+c04be970 b qdisc_rtab_list
+c04be974 b tcf_proto_base
+c04be980 b nl_table_users
+c04be984 b __key.27078
+c04be984 b nl_table
+c04be9a0 B genl_sock
+c04be9a4 b id_gen_idx.25887
+c04be9c0 b family_ht
+c04bea40 B ip_ct_attach
+c04bea44 B nf_ct_destroy
+c04bea60 b nf_loggers
+c04beb00 b queue_handler
+c04bec00 B ip_rt_acct
+c04bec04 b equilibrium.35647
+c04bec08 b rover.35646
+c04bec0c b last_gc.35645
+c04bec10 b __key.37510
+c04bec10 b rover.35527
+c04bec14 b ip_fallback_id.35858
+c04bec18 b ip_rt_max_size
+c04bec1c b rt_deadline
+c04bec20 b rt_flush_timer
+c04bec38 b rt_periodic_timer
+c04bec50 b rt_secret_timer
+c04bec68 b rt_hash_locks
+c04bec6c b rt_hash_table
+c04bec70 b rt_hash_mask
+c04bec74 b rt_hash_log
+c04bec78 b rt_hash_rnd
+c04bec7c b flush_delay
+c04bec80 B inet_protos
+c04bf080 b __key.28811
+c04bf080 B ip_ra_chain
+c04bf084 b hint.29382
+c04bf088 B tcp_orphan_count
+c04bf08c B tcp_memory_allocated
+c04bf090 B tcp_sockets_allocated
+c04bf094 b __key.35534
+c04bf094 b __key.35538
+c04bf0a0 b __key.16588
+c04bf0a0 b tcp4_seq_fops
+c04bf110 b __key.16735
+c04bf110 B sysctl_tcp_max_ssthresh
+c04bf120 B raw_v4_htable
+c04bf520 b complained.31787
+c04bf540 B udp_hash
+c04bf740 b udp4_seq_fops
+c04bf7c0 B udplite_hash
+c04bf9c0 b udplite_port_rover
+c04bf9e0 b udplite4_seq_fops
+c04bfa50 B sysctl_icmp_ipod_enabled
+c04bfa60 b inetsw
+c04bfab8 b __key.29416
+c04bfab8 b __key.29464
+c04bfab8 b __key.29465
+c04bfab8 b zero
+c04bfabc b fib_hash_genid
+c04bfac0 b tunnel4_handlers
+c04bfac4 b tunnel64_handlers
+c04bfac8 B ip_nat_decode_session
+c04bfae0 B xfrm_policy_count
+c04bfaf8 b xfrm_policy_gc_list
+c04bfb00 b dummy.32810
+c04bfb20 b idx_generator.31838
+c04bfb24 b __key.31558
+c04bfb40 b xfrm_policy_afinfo
+c04bfbc8 b xfrm_policy_gc_work
+c04bfbd8 b xfrm_policy_inexact
+c04bfc00 B xfrm_nl
+c04bfc04 b xfrm_state_gc_list
+c04bfc08 b acqseq.31436
+c04bfc0c b __key.30758
+c04bfc0c b xfrm_state_num
+c04bfc10 b xfrm_state_genid
+c04bfc20 b xfrm_state_afinfo
+c04bfca8 b xfrm_state_gc_work
+c04bfcc0 B unix_socket_table
+c04c00c4 b unix_nr_socks
+c04c00c8 b __key.26912
+c04c00c8 b __key.26913
+c04c00c8 B unix_tot_inflight
+c04c00cc b __key.16509
+c04c00e0 b inetsw6
+c04c0138 b __key.28881
+c04c0140 b __key.33937
+c04c0140 b __key.34054
+c04c0140 b inet6_addr_lst
+c04c0180 b last_gc.34553
+c04c0184 b ndisc_dst_gc_list
+c04c0188 b flush_delay
+c04c018c B rt6_stats
+c04c01a4 b __key.28790
+c04c01a4 b rt_sernum
+c04c01a8 b fib_table_hash
+c04c01ac b gc_args
+c04c01b4 B ip6_ra_chain
+c04c01b8 b warned.31025
+c04c01bc b warncomm.31024
+c04c01cc b ndisc_socket
+c04c01e0 b udp6_seq_fops
+c04c0260 b udplite6_seq_fops
+c04c02e0 B raw_v6_htable
+c04c06e0 B inet6_protos
+c04c0ae0 b __key.29642
+c04c0ae0 b __key.30040
+c04c0ae0 b __key.30106
+c04c0ae0 b __key.31811
+c04c0ae0 b igmp6_socket
+c04c0b00 B ip6_frag_nqueues
+c04c0b04 B ip6_frag_mem
+c04c0b08 b __key.29150
+c04c0b20 b ip6_frag_hash
+c04c0c20 b ip6_frag_hash_rnd
+c04c0c24 b ip6_frag_secret_timer
+c04c0c40 b __key.16664
+c04c0c40 b tcp6_socket
+c04c0c60 b tcp6_seq_fops
+c04c0cd0 b ipv6_sysctl_header
+c04c0ce0 b fl_size
+c04c0d00 b fl_ht
+c04c1100 b proc_net_devsnmp6
+c04c1120 b ipip6_fb_tunnel_dev
+c04c1140 b tunnels_r_l
+c04c1180 b tunnels_r
+c04c11c0 b tunnels_l
+c04c1200 b tunnels_wc
+c04c1204 b hint.30178
+c04c1208 b __key.29303
+c04c1208 b __key.30074
+c04c1208 b packet_socks_nr
+c04c120c b __key.16600
+c04c120c b wireless_nlevent_queue
+c04c1228 B __bss_stop
+c04c1228 b __key.7773
+c04c1228 B _end
+c04c2000 B pg0
diff -Nurb linux-2.6.22-590/inst/config linux-2.6.22-try2-netns/inst/config
--- linux-2.6.22-590/inst/config	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/config	2007-12-21 13:22:23.000000000 -0500
@@ -0,0 +1,1886 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.22-prep
+# Thu Dec 20 01:46:01 2007
+#
+CONFIG_X86_32=y
+CONFIG_GENERIC_TIME=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_SEMAPHORE_SLEEPERS=y
+CONFIG_X86=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA=y
+CONFIG_QUICKLIST=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_DMI=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_OOM_PANIC=y
+CONFIG_CONTAINERS=y
+# CONFIG_CONTAINER_DEBUG is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_CONTAINER_CPUACCT=y
+CONFIG_CONTAINER_NS=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROC_SMAPS=y
+CONFIG_PROC_CLEAR_REFS=y
+CONFIG_PROC_PAGEMAP=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_PAGE_GROUP_BY_MOBILITY is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_STOP_MACHINE=y
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+CONFIG_LBD=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_LSF=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=m
+CONFIG_IOSCHED_DEADLINE=m
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# Processor type and features
+#
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_SMP=y
+# CONFIG_X86_PC is not set
+# CONFIG_X86_ELAN is not set
+# CONFIG_X86_VOYAGER is not set
+# CONFIG_X86_NUMAQ is not set
+# CONFIG_X86_SUMMIT is not set
+# CONFIG_X86_BIGSMP is not set
+# CONFIG_X86_VISWS is not set
+CONFIG_X86_GENERICARCH=y
+# CONFIG_X86_ES7000 is not set
+# CONFIG_PARAVIRT is not set
+CONFIG_X86_CYCLONE_TIMER=y
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+# CONFIG_M586 is not set
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+CONFIG_M686=y
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP2 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MGEODEGX1 is not set
+# CONFIG_MGEODE_LX is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_MVIAC7 is not set
+CONFIG_X86_GENERIC=y
+CONFIG_X86_CMPXCHG=y
+CONFIG_X86_L1_CACHE_SHIFT=7
+CONFIG_X86_XADD=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_X86_PPRO_FENCE=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_GOOD_APIC=y
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_MODEL=4
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_NR_CPUS=16
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_PREEMPT_BKL=y
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_MCE=y
+# CONFIG_X86_MCE_NONFATAL is not set
+CONFIG_X86_MCE_P4THERMAL=y
+CONFIG_VM86=y
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+# CONFIG_X86_REBOOTFIXUPS is not set
+# CONFIG_MICROCODE is not set
+CONFIG_X86_MSR=m
+CONFIG_X86_CPUID=m
+
+#
+# Firmware Drivers
+#
+CONFIG_EDD=m
+CONFIG_EFI_VARS=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+# CONFIG_NOHIGHMEM is not set
+CONFIG_HIGHMEM4G=y
+# CONFIG_HIGHMEM64G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_HIGHMEM=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_RESOURCES_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_NR_QUICK=1
+CONFIG_HIGHPTE=y
+# CONFIG_MATH_EMULATION is not set
+CONFIG_MTRR=y
+CONFIG_EFI=y
+# CONFIG_IRQBALANCE is not set
+CONFIG_BOOT_IOREMAP=y
+# CONFIG_SECCOMP is not set
+# CONFIG_HZ_100 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+CONFIG_HZ_1000=y
+CONFIG_HZ=1000
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_PHYSICAL_START=0x100000
+# CONFIG_RELOCATABLE is not set
+CONFIG_PHYSICAL_ALIGN=0x100000
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_COMPAT_VDSO is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+
+#
+# Power management options (ACPI, APM)
+#
+CONFIG_PM=y
+CONFIG_PM_LEGACY=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_PM_SYSFS_DEPRECATED is not set
+
+#
+# ACPI (Advanced Configuration and Power Interface) Support
+#
+CONFIG_ACPI=y
+# CONFIG_ACPI_PROCFS is not set
+# CONFIG_ACPI_AC is not set
+# CONFIG_ACPI_BATTERY is not set
+# CONFIG_ACPI_BUTTON is not set
+# CONFIG_ACPI_FAN is not set
+# CONFIG_ACPI_DOCK is not set
+# CONFIG_ACPI_PROCESSOR is not set
+# CONFIG_ACPI_ASUS is not set
+# CONFIG_ACPI_TOSHIBA is not set
+CONFIG_ACPI_BLACKLIST_YEAR=2001
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_EC=y
+CONFIG_ACPI_POWER=y
+CONFIG_ACPI_SYSTEM=y
+CONFIG_X86_PM_TIMER=y
+# CONFIG_ACPI_CONTAINER is not set
+# CONFIG_ACPI_SBS is not set
+# CONFIG_APM is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPU idle PM support
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+# CONFIG_PCI_GODIRECT is not set
+CONFIG_PCI_GOANY=y
+CONFIG_PCI_BIOS=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+# CONFIG_PCI_DEBUG is not set
+CONFIG_HT_IRQ=y
+CONFIG_ISA_DMA_API=y
+# CONFIG_ISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_NET_NS=y
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+CONFIG_NET_IPGRE=m
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IP_VS is not set
+CONFIG_ICMP_IPOD=y
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_NF_CONNTRACK_ENABLED=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_GRE=m
+CONFIG_NF_CT_PROTO_SCTP=m
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_NF_CONNTRACK_PPTP=m
+# CONFIG_NF_CONNTRACK_SANE is not set
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NETFILTER_XTABLES=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+CONFIG_NETFILTER_XT_TARGET_SETXID=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_IPRANGE=m
+CONFIG_IP_NF_MATCH_TOS=m
+CONFIG_IP_NF_MATCH_RECENT=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_OWNER=m
+CONFIG_IP_NF_MATCH_ADDRTYPE=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_NF_NAT=m
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_SAME=m
+CONFIG_NF_NAT_SNMP_BASIC=m
+CONFIG_NF_NAT_PROTO_GRE=m
+CONFIG_NF_NAT_FTP=m
+CONFIG_NF_NAT_IRC=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_NF_NAT_PPTP=m
+CONFIG_NF_NAT_H323=m
+CONFIG_NF_NAT_SIP=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_TOS=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_IP_NF_SET=m
+CONFIG_IP_NF_SET_MAX=256
+CONFIG_IP_NF_SET_HASHSIZE=1024
+CONFIG_IP_NF_SET_IPMAP=m
+CONFIG_IP_NF_SET_MACIPMAP=m
+CONFIG_IP_NF_SET_PORTMAP=m
+CONFIG_IP_NF_SET_IPHASH=m
+CONFIG_IP_NF_SET_NETHASH=m
+CONFIG_IP_NF_SET_IPPORTHASH=m
+CONFIG_IP_NF_SET_IPTREE=m
+# CONFIG_IP_NF_SET_IPTREEMAP is not set
+CONFIG_IP_NF_MATCH_SET=m
+CONFIG_IP_NF_TARGET_SET=m
+
+#
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
+#
+# CONFIG_NF_CONNTRACK_IPV6 is not set
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+CONFIG_VLAN_8021Q=m
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_FIFO=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=m
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_INGRESS is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NET_CLS_FW=m
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+# CONFIG_NET_CLS_POLICE is not set
+# CONFIG_NET_CLS_IND is not set
+# CONFIG_NET_ESTIMATOR is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+CONFIG_IEEE80211_SOFTMAC=m
+CONFIG_IEEE80211_SOFTMAC_DEBUG=y
+# CONFIG_RFKILL is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+
+#
+# Block devices
+#
+CONFIG_BLK_DEV_FD=m
+CONFIG_BLK_CPQ_DA=m
+CONFIG_BLK_CPQ_CISS_DA=m
+CONFIG_CISS_SCSI_TAPE=y
+CONFIG_BLK_DEV_DAC960=m
+CONFIG_BLK_DEV_UMEM=m
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_VROOT is not set
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_SX8=m
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+CONFIG_ATA_OVER_ETH=m
+
+#
+# Misc devices
+#
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+CONFIG_TIFM_CORE=m
+CONFIG_TIFM_7XX1=m
+# CONFIG_SONY_LAPTOP is not set
+# CONFIG_THINKPAD_ACPI is not set
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+# CONFIG_BLK_DEV_HD_IDE is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+CONFIG_BLK_DEV_IDEFLOPPY=y
+CONFIG_BLK_DEV_IDESCSI=m
+# CONFIG_BLK_DEV_IDEACPI is not set
+CONFIG_IDE_TASK_IOCTL=y
+# CONFIG_IDE_PROC_FS is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_CMD640=y
+CONFIG_BLK_DEV_CMD640_ENHANCED=y
+# CONFIG_BLK_DEV_IDEPNP is not set
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+CONFIG_IDEPCI_PCIBUS_ORDER=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_RZ1000=y
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+# CONFIG_IDEDMA_ONLYDISK is not set
+CONFIG_BLK_DEV_AEC62XX=y
+CONFIG_BLK_DEV_ALI15X3=y
+# CONFIG_WDC_ALI15X3 is not set
+CONFIG_BLK_DEV_AMD74XX=y
+CONFIG_BLK_DEV_ATIIXP=y
+CONFIG_BLK_DEV_CMD64X=y
+CONFIG_BLK_DEV_TRIFLEX=y
+CONFIG_BLK_DEV_CY82C693=y
+CONFIG_BLK_DEV_CS5520=y
+CONFIG_BLK_DEV_CS5530=y
+CONFIG_BLK_DEV_CS5535=y
+CONFIG_BLK_DEV_HPT34X=y
+# CONFIG_HPT34X_AUTODMA is not set
+CONFIG_BLK_DEV_HPT366=y
+CONFIG_BLK_DEV_JMICRON=y
+# CONFIG_BLK_DEV_SC1200 is not set
+CONFIG_BLK_DEV_PIIX=y
+# CONFIG_BLK_DEV_IT8213 is not set
+CONFIG_BLK_DEV_IT821X=y
+# CONFIG_BLK_DEV_NS87415 is not set
+CONFIG_BLK_DEV_PDC202XX_OLD=y
+# CONFIG_PDC202XX_BURST is not set
+CONFIG_BLK_DEV_PDC202XX_NEW=y
+CONFIG_BLK_DEV_SVWKS=y
+CONFIG_BLK_DEV_SIIMAGE=y
+CONFIG_BLK_DEV_SIS5513=y
+CONFIG_BLK_DEV_SLC90E66=y
+# CONFIG_BLK_DEV_TRM290 is not set
+CONFIG_BLK_DEV_VIA82CXXX=y
+# CONFIG_BLK_DEV_TC86C001 is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_RAID_ATTRS=m
+CONFIG_SCSI=m
+CONFIG_SCSI_TGT=m
+CONFIG_SCSI_NETLINK=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=m
+CONFIG_CHR_DEV_SCH=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=m
+CONFIG_SCSI_FC_ATTRS=m
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=m
+CONFIG_SCSI_SAS_LIBSAS=m
+# CONFIG_SCSI_SAS_LIBSAS_DEBUG is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+CONFIG_BLK_DEV_3W_XXXX_RAID=m
+CONFIG_SCSI_3W_9XXX=m
+CONFIG_SCSI_ACARD=m
+CONFIG_SCSI_AACRAID=m
+CONFIG_SCSI_AIC7XXX=m
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=4
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+# CONFIG_AIC7XXX_DEBUG_ENABLE is not set
+CONFIG_AIC7XXX_DEBUG_MASK=0
+# CONFIG_AIC7XXX_REG_PRETTY_PRINT is not set
+CONFIG_SCSI_AIC7XXX_OLD=m
+CONFIG_SCSI_AIC79XX=m
+CONFIG_AIC79XX_CMDS_PER_DEVICE=4
+CONFIG_AIC79XX_RESET_DELAY_MS=15000
+# CONFIG_AIC79XX_DEBUG_ENABLE is not set
+CONFIG_AIC79XX_DEBUG_MASK=0
+# CONFIG_AIC79XX_REG_PRETTY_PRINT is not set
+CONFIG_SCSI_AIC94XX=m
+# CONFIG_AIC94XX_DEBUG is not set
+# CONFIG_SCSI_DPT_I2O is not set
+CONFIG_SCSI_ADVANSYS=m
+CONFIG_SCSI_ARCMSR=m
+CONFIG_MEGARAID_NEWGEN=y
+CONFIG_MEGARAID_MM=m
+CONFIG_MEGARAID_MAILBOX=m
+CONFIG_MEGARAID_LEGACY=m
+CONFIG_MEGARAID_SAS=m
+# CONFIG_SCSI_HPTIOP is not set
+CONFIG_SCSI_BUSLOGIC=m
+# CONFIG_SCSI_OMIT_FLASHPOINT is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+CONFIG_SCSI_GDTH=m
+CONFIG_SCSI_IPS=m
+CONFIG_SCSI_INITIO=m
+CONFIG_SCSI_INIA100=m
+CONFIG_SCSI_STEX=m
+CONFIG_SCSI_SYM53C8XX_2=m
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=1
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+CONFIG_SCSI_SYM53C8XX_MMIO=y
+CONFIG_SCSI_IPR=m
+CONFIG_SCSI_IPR_TRACE=y
+CONFIG_SCSI_IPR_DUMP=y
+CONFIG_SCSI_QLOGIC_1280=m
+CONFIG_SCSI_QLA_FC=m
+CONFIG_SCSI_QLA_ISCSI=m
+# CONFIG_SCSI_LPFC is not set
+CONFIG_SCSI_DC395x=m
+CONFIG_SCSI_DC390T=m
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+CONFIG_SCSI_SRP=m
+CONFIG_ATA=m
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_AHCI=m
+CONFIG_SATA_SVW=m
+CONFIG_ATA_PIIX=m
+CONFIG_SATA_MV=m
+CONFIG_SATA_NV=m
+CONFIG_PDC_ADMA=m
+CONFIG_SATA_QSTOR=m
+CONFIG_SATA_PROMISE=m
+CONFIG_SATA_SX4=m
+CONFIG_SATA_SIL=m
+CONFIG_SATA_SIL24=m
+CONFIG_SATA_SIS=m
+CONFIG_SATA_ULI=m
+CONFIG_SATA_VIA=m
+CONFIG_SATA_VITESSE=m
+# CONFIG_SATA_INIC162X is not set
+CONFIG_PATA_ALI=m
+CONFIG_PATA_AMD=m
+CONFIG_PATA_ARTOP=m
+CONFIG_PATA_ATIIXP=m
+# CONFIG_PATA_CMD640_PCI is not set
+CONFIG_PATA_CMD64X=m
+CONFIG_PATA_CS5520=m
+CONFIG_PATA_CS5530=m
+CONFIG_PATA_CS5535=m
+CONFIG_PATA_CYPRESS=m
+CONFIG_PATA_EFAR=m
+CONFIG_ATA_GENERIC=m
+CONFIG_PATA_HPT366=m
+CONFIG_PATA_HPT37X=m
+CONFIG_PATA_HPT3X2N=m
+CONFIG_PATA_HPT3X3=m
+CONFIG_PATA_IT821X=m
+# CONFIG_PATA_IT8213 is not set
+CONFIG_PATA_JMICRON=m
+CONFIG_PATA_TRIFLEX=m
+CONFIG_PATA_MARVELL=m
+CONFIG_PATA_MPIIX=m
+CONFIG_PATA_OLDPIIX=m
+CONFIG_PATA_NETCELL=m
+CONFIG_PATA_NS87410=m
+CONFIG_PATA_OPTI=m
+CONFIG_PATA_OPTIDMA=m
+CONFIG_PATA_PDC_OLD=m
+CONFIG_PATA_RADISYS=m
+CONFIG_PATA_RZ1000=m
+CONFIG_PATA_SC1200=m
+CONFIG_PATA_SERVERWORKS=m
+CONFIG_PATA_PDC2027X=m
+CONFIG_PATA_SIL680=m
+CONFIG_PATA_SIS=m
+CONFIG_PATA_VIA=m
+CONFIG_PATA_WINBOND=m
+
+#
+# Multi-device support (RAID and LVM)
+#
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_LINEAR=y
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID456 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+# CONFIG_DM_CRYPT is not set
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_NETLINK is not set
+
+#
+# Fusion MPT device support
+#
+CONFIG_FUSION=y
+CONFIG_FUSION_SPI=m
+CONFIG_FUSION_FC=m
+CONFIG_FUSION_SAS=m
+CONFIG_FUSION_MAX_SGE=40
+CONFIG_FUSION_CTL=m
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=m
+CONFIG_BONDING=m
+CONFIG_EQUALIZER=m
+CONFIG_TUN=m
+CONFIG_ETUN=y
+# CONFIG_NET_SB1000 is not set
+# CONFIG_ARCNET is not set
+CONFIG_PHYLIB=m
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+CONFIG_VITESSE_PHY=m
+CONFIG_SMSC_PHY=m
+CONFIG_BROADCOM_PHY=m
+CONFIG_FIXED_PHY=m
+CONFIG_FIXED_MII_10_FDX=y
+CONFIG_FIXED_MII_100_FDX=y
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=m
+CONFIG_HAPPYMEAL=m
+CONFIG_SUNGEM=m
+CONFIG_CASSINI=m
+CONFIG_NET_VENDOR_3COM=y
+CONFIG_VORTEX=m
+CONFIG_TYPHOON=m
+
+#
+# Tulip family network device support
+#
+CONFIG_NET_TULIP=y
+CONFIG_DE2104X=m
+CONFIG_TULIP=m
+# CONFIG_TULIP_MWI is not set
+CONFIG_TULIP_MMIO=y
+# CONFIG_TULIP_NAPI is not set
+CONFIG_DE4X5=m
+CONFIG_WINBOND_840=m
+CONFIG_DM9102=m
+CONFIG_ULI526X=m
+CONFIG_HP100=m
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=m
+# CONFIG_PCNET32_NAPI is not set
+CONFIG_AMD8111_ETH=m
+CONFIG_AMD8111E_NAPI=y
+CONFIG_ADAPTEC_STARFIRE=m
+CONFIG_ADAPTEC_STARFIRE_NAPI=y
+CONFIG_B44=m
+CONFIG_FORCEDETH=m
+# CONFIG_FORCEDETH_NAPI is not set
+CONFIG_DGRS=m
+# CONFIG_EEPRO100 is not set
+CONFIG_E100=m
+CONFIG_FEALNX=m
+CONFIG_NATSEMI=m
+CONFIG_NE2K_PCI=m
+CONFIG_8139CP=m
+CONFIG_8139TOO=m
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+CONFIG_8139TOO_8129=y
+# CONFIG_8139_OLD_RX_RESET is not set
+CONFIG_SIS900=m
+CONFIG_EPIC100=m
+CONFIG_SUNDANCE=m
+# CONFIG_SUNDANCE_MMIO is not set
+CONFIG_TLAN=m
+CONFIG_VIA_RHINE=m
+CONFIG_VIA_RHINE_MMIO=y
+# CONFIG_VIA_RHINE_NAPI is not set
+# CONFIG_SC92031 is not set
+CONFIG_NETDEV_1000=y
+CONFIG_ACENIC=m
+# CONFIG_ACENIC_OMIT_TIGON_I is not set
+CONFIG_DL2K=m
+CONFIG_E1000=m
+CONFIG_E1000_NAPI=y
+# CONFIG_E1000_DISABLE_PACKET_SPLIT is not set
+CONFIG_E1000E=m
+CONFIG_NS83820=m
+CONFIG_HAMACHI=m
+CONFIG_YELLOWFIN=m
+CONFIG_R8169=m
+CONFIG_R8169_NAPI=y
+CONFIG_R8169_VLAN=y
+CONFIG_SIS190=m
+CONFIG_SKGE=m
+CONFIG_SKY2=m
+CONFIG_SK98LIN=m
+CONFIG_VIA_VELOCITY=m
+CONFIG_TIGON3=m
+CONFIG_BNX2=m
+CONFIG_QLA3XXX=m
+# CONFIG_ATL1 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_CATC=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET_MII=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_CDCETHER=m
+# CONFIG_USB_NET_DM9601 is not set
+CONFIG_USB_NET_GL620A=m
+CONFIG_USB_NET_NET1080=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_USB_NET_RNDIS_HOST=m
+CONFIG_USB_NET_CDC_SUBSET=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+CONFIG_USB_EPSON2888=y
+# CONFIG_USB_KC2190 is not set
+CONFIG_USB_NET_ZAURUS=m
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_8250_DETECT_IRQ=y
+CONFIG_SERIAL_8250_RSA=y
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=m
+CONFIG_HW_RANDOM_GEODE=m
+CONFIG_HW_RANDOM_VIA=m
+# CONFIG_NVRAM is not set
+CONFIG_RTC=y
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_PC8736x_GPIO is not set
+# CONFIG_NSC_GPIO is not set
+# CONFIG_CS5535_GPIO is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_HPET=y
+# CONFIG_HPET_RTC_IRQ is not set
+CONFIG_HPET_MMAP=y
+CONFIG_HANGCHECK_TIMER=y
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=m
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_TINY_USB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+CONFIG_HWMON=m
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_CORETEMP is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+CONFIG_DAB=y
+# CONFIG_USB_DABUSB is not set
+
+#
+# Graphics support
+#
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=m
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_VGACON_SOFT_SCROLLBACK=y
+CONFIG_VGACON_SOFT_SCROLLBACK_SIZE=16
+CONFIG_VIDEO_SELECT=y
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# HID Devices
+#
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_SPLIT_ISO=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_EHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_ISP116X_HCD=m
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=m
+CONFIG_USB_SL811_HCD=m
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+CONFIG_MMC=m
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_PASSWORDS is not set
+
+#
+# MMC/SD Card Drivers
+#
+CONFIG_MMC_BLOCK=m
+CONFIG_MMC_BLOCK_BOUNCE=y
+
+#
+# MMC/SD Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=m
+CONFIG_MMC_WBSD=m
+CONFIG_MMC_TIFM_SD=m
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+# CONFIG_EDAC is not set
+
+#
+# Real Time Clock
+#
+# CONFIG_RTC_CLASS is not set
+
+#
+# DMA Engine support
+#
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+CONFIG_NET_DMA=y
+
+#
+# DMA Devices
+#
+CONFIG_INTEL_IOATDMA=m
+
+#
+# Virtualization
+#
+CONFIG_KVM=m
+CONFIG_KVM_INTEL=m
+CONFIG_KVM_AMD=m
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT2_FS_XIP=y
+CONFIG_FS_XIP=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Layered filesystems
+#
+# CONFIG_UNION_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=m
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
+# Instrumentation Support
+#
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=m
+CONFIG_KPROBES=y
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_UNUSED_SYMBOLS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+CONFIG_DEBUG_SPINLOCK=y
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+CONFIG_DEBUG_SPINLOCK_SLEEP=y
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_HIGHMEM=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+CONFIG_DEBUG_LIST=y
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_UNWIND_INFO is not set
+# CONFIG_FORCED_INLINING is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_WANT_EXTRA_DEBUG_INFORMATION is not set
+# CONFIG_KGDB is not set
+CONFIG_EARLY_PRINTK=y
+CONFIG_DEBUG_STACKOVERFLOW=y
+CONFIG_DEBUG_STACK_USAGE=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_DEBUG_RODATA=y
+CONFIG_4KSTACKS=y
+CONFIG_X86_FIND_SMP_CONFIG=y
+CONFIG_X86_MPPARSE=y
+CONFIG_DOUBLEFAULT=y
+
+#
+# Linux VServer
+#
+CONFIG_VSERVER_FILESHARING=y
+CONFIG_VSERVER_AUTO_LBACK=y
+CONFIG_VSERVER_AUTO_SINGLE=y
+CONFIG_VSERVER_COWBL=y
+# CONFIG_VSERVER_VTIME is not set
+# CONFIG_VSERVER_DEVICE is not set
+# CONFIG_VSERVER_PROC_SECURE is not set
+CONFIG_VSERVER_HARDCPU=y
+CONFIG_VSERVER_IDLETIME=y
+# CONFIG_VSERVER_IDLELIMIT is not set
+# CONFIG_TAGGING_NONE is not set
+# CONFIG_TAGGING_UID16 is not set
+# CONFIG_TAGGING_GID16 is not set
+CONFIG_TAGGING_ID24=y
+# CONFIG_TAGGING_INTERN is not set
+# CONFIG_TAG_NFSD is not set
+# CONFIG_VSERVER_PRIVACY is not set
+CONFIG_VSERVER_CONTEXTS=256
+CONFIG_VSERVER_WARN=y
+# CONFIG_VSERVER_DEBUG is not set
+CONFIG_VSERVER=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=m
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_HASH=m
+CONFIG_CRYPTO_MANAGER=m
+CONFIG_CRYPTO_HMAC=m
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_ECB=m
+CONFIG_CRYPTO_CBC=m
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_DES=m
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_586 is not set
+# CONFIG_CRYPTO_SERPENT is not set
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_AES_586 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_ARC4=m
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_CRYPTO_DEV_PADLOCK is not set
+CONFIG_CRYPTO_DEV_GEODE=m
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_X86_SMP=y
+CONFIG_X86_HT=y
+CONFIG_X86_BIOS_REBOOT=y
+CONFIG_X86_TRAMPOLINE=y
+CONFIG_KTIME_SCALAR=y
diff -Nurb linux-2.6.22-590/inst/config-2.6.22-prep linux-2.6.22-try2-netns/inst/config-2.6.22-prep
--- linux-2.6.22-590/inst/config-2.6.22-prep	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/config-2.6.22-prep	2007-12-21 13:22:23.000000000 -0500
@@ -0,0 +1,1886 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.22-prep
+# Thu Dec 20 01:46:01 2007
+#
+CONFIG_X86_32=y
+CONFIG_GENERIC_TIME=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_SEMAPHORE_SLEEPERS=y
+CONFIG_X86=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA=y
+CONFIG_QUICKLIST=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_DMI=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_OOM_PANIC=y
+CONFIG_CONTAINERS=y
+# CONFIG_CONTAINER_DEBUG is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_CONTAINER_CPUACCT=y
+CONFIG_CONTAINER_NS=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROC_SMAPS=y
+CONFIG_PROC_CLEAR_REFS=y
+CONFIG_PROC_PAGEMAP=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_PAGE_GROUP_BY_MOBILITY is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_STOP_MACHINE=y
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+CONFIG_LBD=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_LSF=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=m
+CONFIG_IOSCHED_DEADLINE=m
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# Processor type and features
+#
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_SMP=y
+# CONFIG_X86_PC is not set
+# CONFIG_X86_ELAN is not set
+# CONFIG_X86_VOYAGER is not set
+# CONFIG_X86_NUMAQ is not set
+# CONFIG_X86_SUMMIT is not set
+# CONFIG_X86_BIGSMP is not set
+# CONFIG_X86_VISWS is not set
+CONFIG_X86_GENERICARCH=y
+# CONFIG_X86_ES7000 is not set
+# CONFIG_PARAVIRT is not set
+CONFIG_X86_CYCLONE_TIMER=y
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+# CONFIG_M586 is not set
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+CONFIG_M686=y
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP2 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MGEODEGX1 is not set
+# CONFIG_MGEODE_LX is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_MVIAC7 is not set
+CONFIG_X86_GENERIC=y
+CONFIG_X86_CMPXCHG=y
+CONFIG_X86_L1_CACHE_SHIFT=7
+CONFIG_X86_XADD=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_X86_PPRO_FENCE=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_GOOD_APIC=y
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_MODEL=4
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_NR_CPUS=16
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_PREEMPT_BKL=y
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_MCE=y
+# CONFIG_X86_MCE_NONFATAL is not set
+CONFIG_X86_MCE_P4THERMAL=y
+CONFIG_VM86=y
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+# CONFIG_X86_REBOOTFIXUPS is not set
+# CONFIG_MICROCODE is not set
+CONFIG_X86_MSR=m
+CONFIG_X86_CPUID=m
+
+#
+# Firmware Drivers
+#
+CONFIG_EDD=m
+CONFIG_EFI_VARS=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+# CONFIG_NOHIGHMEM is not set
+CONFIG_HIGHMEM4G=y
+# CONFIG_HIGHMEM64G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_HIGHMEM=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_RESOURCES_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_NR_QUICK=1
+CONFIG_HIGHPTE=y
+# CONFIG_MATH_EMULATION is not set
+CONFIG_MTRR=y
+CONFIG_EFI=y
+# CONFIG_IRQBALANCE is not set
+CONFIG_BOOT_IOREMAP=y
+# CONFIG_SECCOMP is not set
+# CONFIG_HZ_100 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+CONFIG_HZ_1000=y
+CONFIG_HZ=1000
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_PHYSICAL_START=0x100000
+# CONFIG_RELOCATABLE is not set
+CONFIG_PHYSICAL_ALIGN=0x100000
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_COMPAT_VDSO is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+
+#
+# Power management options (ACPI, APM)
+#
+CONFIG_PM=y
+CONFIG_PM_LEGACY=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_PM_SYSFS_DEPRECATED is not set
+
+#
+# ACPI (Advanced Configuration and Power Interface) Support
+#
+CONFIG_ACPI=y
+# CONFIG_ACPI_PROCFS is not set
+# CONFIG_ACPI_AC is not set
+# CONFIG_ACPI_BATTERY is not set
+# CONFIG_ACPI_BUTTON is not set
+# CONFIG_ACPI_FAN is not set
+# CONFIG_ACPI_DOCK is not set
+# CONFIG_ACPI_PROCESSOR is not set
+# CONFIG_ACPI_ASUS is not set
+# CONFIG_ACPI_TOSHIBA is not set
+CONFIG_ACPI_BLACKLIST_YEAR=2001
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_EC=y
+CONFIG_ACPI_POWER=y
+CONFIG_ACPI_SYSTEM=y
+CONFIG_X86_PM_TIMER=y
+# CONFIG_ACPI_CONTAINER is not set
+# CONFIG_ACPI_SBS is not set
+# CONFIG_APM is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPU idle PM support
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+# CONFIG_PCI_GODIRECT is not set
+CONFIG_PCI_GOANY=y
+CONFIG_PCI_BIOS=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+# CONFIG_PCI_DEBUG is not set
+CONFIG_HT_IRQ=y
+CONFIG_ISA_DMA_API=y
+# CONFIG_ISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_NET_NS=y
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+CONFIG_NET_IPGRE=m
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IP_VS is not set
+CONFIG_ICMP_IPOD=y
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_NF_CONNTRACK_ENABLED=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_GRE=m
+CONFIG_NF_CT_PROTO_SCTP=m
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_NF_CONNTRACK_PPTP=m
+# CONFIG_NF_CONNTRACK_SANE is not set
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NETFILTER_XTABLES=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+CONFIG_NETFILTER_XT_TARGET_SETXID=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_IPRANGE=m
+CONFIG_IP_NF_MATCH_TOS=m
+CONFIG_IP_NF_MATCH_RECENT=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_OWNER=m
+CONFIG_IP_NF_MATCH_ADDRTYPE=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_NF_NAT=m
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_SAME=m
+CONFIG_NF_NAT_SNMP_BASIC=m
+CONFIG_NF_NAT_PROTO_GRE=m
+CONFIG_NF_NAT_FTP=m
+CONFIG_NF_NAT_IRC=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_NF_NAT_PPTP=m
+CONFIG_NF_NAT_H323=m
+CONFIG_NF_NAT_SIP=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_TOS=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_IP_NF_SET=m
+CONFIG_IP_NF_SET_MAX=256
+CONFIG_IP_NF_SET_HASHSIZE=1024
+CONFIG_IP_NF_SET_IPMAP=m
+CONFIG_IP_NF_SET_MACIPMAP=m
+CONFIG_IP_NF_SET_PORTMAP=m
+CONFIG_IP_NF_SET_IPHASH=m
+CONFIG_IP_NF_SET_NETHASH=m
+CONFIG_IP_NF_SET_IPPORTHASH=m
+CONFIG_IP_NF_SET_IPTREE=m
+# CONFIG_IP_NF_SET_IPTREEMAP is not set
+CONFIG_IP_NF_MATCH_SET=m
+CONFIG_IP_NF_TARGET_SET=m
+
+#
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
+#
+# CONFIG_NF_CONNTRACK_IPV6 is not set
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+CONFIG_VLAN_8021Q=m
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_FIFO=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=m
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_INGRESS is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NET_CLS_FW=m
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+# CONFIG_NET_CLS_POLICE is not set
+# CONFIG_NET_CLS_IND is not set
+# CONFIG_NET_ESTIMATOR is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+CONFIG_IEEE80211_SOFTMAC=m
+CONFIG_IEEE80211_SOFTMAC_DEBUG=y
+# CONFIG_RFKILL is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+
+#
+# Block devices
+#
+CONFIG_BLK_DEV_FD=m
+CONFIG_BLK_CPQ_DA=m
+CONFIG_BLK_CPQ_CISS_DA=m
+CONFIG_CISS_SCSI_TAPE=y
+CONFIG_BLK_DEV_DAC960=m
+CONFIG_BLK_DEV_UMEM=m
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_VROOT is not set
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_SX8=m
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+CONFIG_ATA_OVER_ETH=m
+
+#
+# Misc devices
+#
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+CONFIG_TIFM_CORE=m
+CONFIG_TIFM_7XX1=m
+# CONFIG_SONY_LAPTOP is not set
+# CONFIG_THINKPAD_ACPI is not set
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+# CONFIG_BLK_DEV_HD_IDE is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+CONFIG_BLK_DEV_IDEFLOPPY=y
+CONFIG_BLK_DEV_IDESCSI=m
+# CONFIG_BLK_DEV_IDEACPI is not set
+CONFIG_IDE_TASK_IOCTL=y
+# CONFIG_IDE_PROC_FS is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_CMD640=y
+CONFIG_BLK_DEV_CMD640_ENHANCED=y
+# CONFIG_BLK_DEV_IDEPNP is not set
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+CONFIG_IDEPCI_PCIBUS_ORDER=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_RZ1000=y
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+# CONFIG_IDEDMA_ONLYDISK is not set
+CONFIG_BLK_DEV_AEC62XX=y
+CONFIG_BLK_DEV_ALI15X3=y
+# CONFIG_WDC_ALI15X3 is not set
+CONFIG_BLK_DEV_AMD74XX=y
+CONFIG_BLK_DEV_ATIIXP=y
+CONFIG_BLK_DEV_CMD64X=y
+CONFIG_BLK_DEV_TRIFLEX=y
+CONFIG_BLK_DEV_CY82C693=y
+CONFIG_BLK_DEV_CS5520=y
+CONFIG_BLK_DEV_CS5530=y
+CONFIG_BLK_DEV_CS5535=y
+CONFIG_BLK_DEV_HPT34X=y
+# CONFIG_HPT34X_AUTODMA is not set
+CONFIG_BLK_DEV_HPT366=y
+CONFIG_BLK_DEV_JMICRON=y
+# CONFIG_BLK_DEV_SC1200 is not set
+CONFIG_BLK_DEV_PIIX=y
+# CONFIG_BLK_DEV_IT8213 is not set
+CONFIG_BLK_DEV_IT821X=y
+# CONFIG_BLK_DEV_NS87415 is not set
+CONFIG_BLK_DEV_PDC202XX_OLD=y
+# CONFIG_PDC202XX_BURST is not set
+CONFIG_BLK_DEV_PDC202XX_NEW=y
+CONFIG_BLK_DEV_SVWKS=y
+CONFIG_BLK_DEV_SIIMAGE=y
+CONFIG_BLK_DEV_SIS5513=y
+CONFIG_BLK_DEV_SLC90E66=y
+# CONFIG_BLK_DEV_TRM290 is not set
+CONFIG_BLK_DEV_VIA82CXXX=y
+# CONFIG_BLK_DEV_TC86C001 is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_RAID_ATTRS=m
+CONFIG_SCSI=m
+CONFIG_SCSI_TGT=m
+CONFIG_SCSI_NETLINK=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=m
+CONFIG_CHR_DEV_SCH=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=m
+CONFIG_SCSI_FC_ATTRS=m
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=m
+CONFIG_SCSI_SAS_LIBSAS=m
+# CONFIG_SCSI_SAS_LIBSAS_DEBUG is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+CONFIG_BLK_DEV_3W_XXXX_RAID=m
+CONFIG_SCSI_3W_9XXX=m
+CONFIG_SCSI_ACARD=m
+CONFIG_SCSI_AACRAID=m
+CONFIG_SCSI_AIC7XXX=m
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=4
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+# CONFIG_AIC7XXX_DEBUG_ENABLE is not set
+CONFIG_AIC7XXX_DEBUG_MASK=0
+# CONFIG_AIC7XXX_REG_PRETTY_PRINT is not set
+CONFIG_SCSI_AIC7XXX_OLD=m
+CONFIG_SCSI_AIC79XX=m
+CONFIG_AIC79XX_CMDS_PER_DEVICE=4
+CONFIG_AIC79XX_RESET_DELAY_MS=15000
+# CONFIG_AIC79XX_DEBUG_ENABLE is not set
+CONFIG_AIC79XX_DEBUG_MASK=0
+# CONFIG_AIC79XX_REG_PRETTY_PRINT is not set
+CONFIG_SCSI_AIC94XX=m
+# CONFIG_AIC94XX_DEBUG is not set
+# CONFIG_SCSI_DPT_I2O is not set
+CONFIG_SCSI_ADVANSYS=m
+CONFIG_SCSI_ARCMSR=m
+CONFIG_MEGARAID_NEWGEN=y
+CONFIG_MEGARAID_MM=m
+CONFIG_MEGARAID_MAILBOX=m
+CONFIG_MEGARAID_LEGACY=m
+CONFIG_MEGARAID_SAS=m
+# CONFIG_SCSI_HPTIOP is not set
+CONFIG_SCSI_BUSLOGIC=m
+# CONFIG_SCSI_OMIT_FLASHPOINT is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+CONFIG_SCSI_GDTH=m
+CONFIG_SCSI_IPS=m
+CONFIG_SCSI_INITIO=m
+CONFIG_SCSI_INIA100=m
+CONFIG_SCSI_STEX=m
+CONFIG_SCSI_SYM53C8XX_2=m
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=1
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+CONFIG_SCSI_SYM53C8XX_MMIO=y
+CONFIG_SCSI_IPR=m
+CONFIG_SCSI_IPR_TRACE=y
+CONFIG_SCSI_IPR_DUMP=y
+CONFIG_SCSI_QLOGIC_1280=m
+CONFIG_SCSI_QLA_FC=m
+CONFIG_SCSI_QLA_ISCSI=m
+# CONFIG_SCSI_LPFC is not set
+CONFIG_SCSI_DC395x=m
+CONFIG_SCSI_DC390T=m
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+CONFIG_SCSI_SRP=m
+CONFIG_ATA=m
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_AHCI=m
+CONFIG_SATA_SVW=m
+CONFIG_ATA_PIIX=m
+CONFIG_SATA_MV=m
+CONFIG_SATA_NV=m
+CONFIG_PDC_ADMA=m
+CONFIG_SATA_QSTOR=m
+CONFIG_SATA_PROMISE=m
+CONFIG_SATA_SX4=m
+CONFIG_SATA_SIL=m
+CONFIG_SATA_SIL24=m
+CONFIG_SATA_SIS=m
+CONFIG_SATA_ULI=m
+CONFIG_SATA_VIA=m
+CONFIG_SATA_VITESSE=m
+# CONFIG_SATA_INIC162X is not set
+CONFIG_PATA_ALI=m
+CONFIG_PATA_AMD=m
+CONFIG_PATA_ARTOP=m
+CONFIG_PATA_ATIIXP=m
+# CONFIG_PATA_CMD640_PCI is not set
+CONFIG_PATA_CMD64X=m
+CONFIG_PATA_CS5520=m
+CONFIG_PATA_CS5530=m
+CONFIG_PATA_CS5535=m
+CONFIG_PATA_CYPRESS=m
+CONFIG_PATA_EFAR=m
+CONFIG_ATA_GENERIC=m
+CONFIG_PATA_HPT366=m
+CONFIG_PATA_HPT37X=m
+CONFIG_PATA_HPT3X2N=m
+CONFIG_PATA_HPT3X3=m
+CONFIG_PATA_IT821X=m
+# CONFIG_PATA_IT8213 is not set
+CONFIG_PATA_JMICRON=m
+CONFIG_PATA_TRIFLEX=m
+CONFIG_PATA_MARVELL=m
+CONFIG_PATA_MPIIX=m
+CONFIG_PATA_OLDPIIX=m
+CONFIG_PATA_NETCELL=m
+CONFIG_PATA_NS87410=m
+CONFIG_PATA_OPTI=m
+CONFIG_PATA_OPTIDMA=m
+CONFIG_PATA_PDC_OLD=m
+CONFIG_PATA_RADISYS=m
+CONFIG_PATA_RZ1000=m
+CONFIG_PATA_SC1200=m
+CONFIG_PATA_SERVERWORKS=m
+CONFIG_PATA_PDC2027X=m
+CONFIG_PATA_SIL680=m
+CONFIG_PATA_SIS=m
+CONFIG_PATA_VIA=m
+CONFIG_PATA_WINBOND=m
+
+#
+# Multi-device support (RAID and LVM)
+#
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_LINEAR=y
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID456 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+# CONFIG_DM_CRYPT is not set
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_NETLINK is not set
+
+#
+# Fusion MPT device support
+#
+CONFIG_FUSION=y
+CONFIG_FUSION_SPI=m
+CONFIG_FUSION_FC=m
+CONFIG_FUSION_SAS=m
+CONFIG_FUSION_MAX_SGE=40
+CONFIG_FUSION_CTL=m
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=m
+CONFIG_BONDING=m
+CONFIG_EQUALIZER=m
+CONFIG_TUN=m
+CONFIG_ETUN=y
+# CONFIG_NET_SB1000 is not set
+# CONFIG_ARCNET is not set
+CONFIG_PHYLIB=m
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+CONFIG_VITESSE_PHY=m
+CONFIG_SMSC_PHY=m
+CONFIG_BROADCOM_PHY=m
+CONFIG_FIXED_PHY=m
+CONFIG_FIXED_MII_10_FDX=y
+CONFIG_FIXED_MII_100_FDX=y
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=m
+CONFIG_HAPPYMEAL=m
+CONFIG_SUNGEM=m
+CONFIG_CASSINI=m
+CONFIG_NET_VENDOR_3COM=y
+CONFIG_VORTEX=m
+CONFIG_TYPHOON=m
+
+#
+# Tulip family network device support
+#
+CONFIG_NET_TULIP=y
+CONFIG_DE2104X=m
+CONFIG_TULIP=m
+# CONFIG_TULIP_MWI is not set
+CONFIG_TULIP_MMIO=y
+# CONFIG_TULIP_NAPI is not set
+CONFIG_DE4X5=m
+CONFIG_WINBOND_840=m
+CONFIG_DM9102=m
+CONFIG_ULI526X=m
+CONFIG_HP100=m
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=m
+# CONFIG_PCNET32_NAPI is not set
+CONFIG_AMD8111_ETH=m
+CONFIG_AMD8111E_NAPI=y
+CONFIG_ADAPTEC_STARFIRE=m
+CONFIG_ADAPTEC_STARFIRE_NAPI=y
+CONFIG_B44=m
+CONFIG_FORCEDETH=m
+# CONFIG_FORCEDETH_NAPI is not set
+CONFIG_DGRS=m
+# CONFIG_EEPRO100 is not set
+CONFIG_E100=m
+CONFIG_FEALNX=m
+CONFIG_NATSEMI=m
+CONFIG_NE2K_PCI=m
+CONFIG_8139CP=m
+CONFIG_8139TOO=m
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+CONFIG_8139TOO_8129=y
+# CONFIG_8139_OLD_RX_RESET is not set
+CONFIG_SIS900=m
+CONFIG_EPIC100=m
+CONFIG_SUNDANCE=m
+# CONFIG_SUNDANCE_MMIO is not set
+CONFIG_TLAN=m
+CONFIG_VIA_RHINE=m
+CONFIG_VIA_RHINE_MMIO=y
+# CONFIG_VIA_RHINE_NAPI is not set
+# CONFIG_SC92031 is not set
+CONFIG_NETDEV_1000=y
+CONFIG_ACENIC=m
+# CONFIG_ACENIC_OMIT_TIGON_I is not set
+CONFIG_DL2K=m
+CONFIG_E1000=m
+CONFIG_E1000_NAPI=y
+# CONFIG_E1000_DISABLE_PACKET_SPLIT is not set
+CONFIG_E1000E=m
+CONFIG_NS83820=m
+CONFIG_HAMACHI=m
+CONFIG_YELLOWFIN=m
+CONFIG_R8169=m
+CONFIG_R8169_NAPI=y
+CONFIG_R8169_VLAN=y
+CONFIG_SIS190=m
+CONFIG_SKGE=m
+CONFIG_SKY2=m
+CONFIG_SK98LIN=m
+CONFIG_VIA_VELOCITY=m
+CONFIG_TIGON3=m
+CONFIG_BNX2=m
+CONFIG_QLA3XXX=m
+# CONFIG_ATL1 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_CATC=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET_MII=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_CDCETHER=m
+# CONFIG_USB_NET_DM9601 is not set
+CONFIG_USB_NET_GL620A=m
+CONFIG_USB_NET_NET1080=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_USB_NET_RNDIS_HOST=m
+CONFIG_USB_NET_CDC_SUBSET=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+CONFIG_USB_EPSON2888=y
+# CONFIG_USB_KC2190 is not set
+CONFIG_USB_NET_ZAURUS=m
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_8250_DETECT_IRQ=y
+CONFIG_SERIAL_8250_RSA=y
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=m
+CONFIG_HW_RANDOM_GEODE=m
+CONFIG_HW_RANDOM_VIA=m
+# CONFIG_NVRAM is not set
+CONFIG_RTC=y
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_PC8736x_GPIO is not set
+# CONFIG_NSC_GPIO is not set
+# CONFIG_CS5535_GPIO is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_HPET=y
+# CONFIG_HPET_RTC_IRQ is not set
+CONFIG_HPET_MMAP=y
+CONFIG_HANGCHECK_TIMER=y
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=m
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_TINY_USB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+CONFIG_HWMON=m
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_CORETEMP is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+CONFIG_DAB=y
+# CONFIG_USB_DABUSB is not set
+
+#
+# Graphics support
+#
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=m
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_VGACON_SOFT_SCROLLBACK=y
+CONFIG_VGACON_SOFT_SCROLLBACK_SIZE=16
+CONFIG_VIDEO_SELECT=y
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# HID Devices
+#
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_SPLIT_ISO=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_EHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_ISP116X_HCD=m
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=m
+CONFIG_USB_SL811_HCD=m
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+CONFIG_MMC=m
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_PASSWORDS is not set
+
+#
+# MMC/SD Card Drivers
+#
+CONFIG_MMC_BLOCK=m
+CONFIG_MMC_BLOCK_BOUNCE=y
+
+#
+# MMC/SD Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=m
+CONFIG_MMC_WBSD=m
+CONFIG_MMC_TIFM_SD=m
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+# CONFIG_EDAC is not set
+
+#
+# Real Time Clock
+#
+# CONFIG_RTC_CLASS is not set
+
+#
+# DMA Engine support
+#
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+CONFIG_NET_DMA=y
+
+#
+# DMA Devices
+#
+CONFIG_INTEL_IOATDMA=m
+
+#
+# Virtualization
+#
+CONFIG_KVM=m
+CONFIG_KVM_INTEL=m
+CONFIG_KVM_AMD=m
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT2_FS_XIP=y
+CONFIG_FS_XIP=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Layered filesystems
+#
+# CONFIG_UNION_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=m
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
+# Instrumentation Support
+#
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=m
+CONFIG_KPROBES=y
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_UNUSED_SYMBOLS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+CONFIG_DEBUG_SPINLOCK=y
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+CONFIG_DEBUG_SPINLOCK_SLEEP=y
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_HIGHMEM=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+CONFIG_DEBUG_LIST=y
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_UNWIND_INFO is not set
+# CONFIG_FORCED_INLINING is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_WANT_EXTRA_DEBUG_INFORMATION is not set
+# CONFIG_KGDB is not set
+CONFIG_EARLY_PRINTK=y
+CONFIG_DEBUG_STACKOVERFLOW=y
+CONFIG_DEBUG_STACK_USAGE=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_DEBUG_RODATA=y
+CONFIG_4KSTACKS=y
+CONFIG_X86_FIND_SMP_CONFIG=y
+CONFIG_X86_MPPARSE=y
+CONFIG_DOUBLEFAULT=y
+
+#
+# Linux VServer
+#
+CONFIG_VSERVER_FILESHARING=y
+CONFIG_VSERVER_AUTO_LBACK=y
+CONFIG_VSERVER_AUTO_SINGLE=y
+CONFIG_VSERVER_COWBL=y
+# CONFIG_VSERVER_VTIME is not set
+# CONFIG_VSERVER_DEVICE is not set
+# CONFIG_VSERVER_PROC_SECURE is not set
+CONFIG_VSERVER_HARDCPU=y
+CONFIG_VSERVER_IDLETIME=y
+# CONFIG_VSERVER_IDLELIMIT is not set
+# CONFIG_TAGGING_NONE is not set
+# CONFIG_TAGGING_UID16 is not set
+# CONFIG_TAGGING_GID16 is not set
+CONFIG_TAGGING_ID24=y
+# CONFIG_TAGGING_INTERN is not set
+# CONFIG_TAG_NFSD is not set
+# CONFIG_VSERVER_PRIVACY is not set
+CONFIG_VSERVER_CONTEXTS=256
+CONFIG_VSERVER_WARN=y
+# CONFIG_VSERVER_DEBUG is not set
+CONFIG_VSERVER=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=m
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_HASH=m
+CONFIG_CRYPTO_MANAGER=m
+CONFIG_CRYPTO_HMAC=m
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_ECB=m
+CONFIG_CRYPTO_CBC=m
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_DES=m
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_586 is not set
+# CONFIG_CRYPTO_SERPENT is not set
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_AES_586 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_ARC4=m
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_CRYPTO_DEV_PADLOCK is not set
+CONFIG_CRYPTO_DEV_GEODE=m
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_X86_SMP=y
+CONFIG_X86_HT=y
+CONFIG_X86_BIOS_REBOOT=y
+CONFIG_X86_TRAMPOLINE=y
+CONFIG_KTIME_SCALAR=y
diff -Nurb linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.alias linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.alias
--- linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.alias	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.alias	2007-12-21 13:22:40.000000000 -0500
@@ -0,0 +1,1695 @@
+# Aliases extracted from modules themselves.
+alias xt_tcp xt_tcpudp
+alias xt_udp xt_tcpudp
+alias ipt_udp xt_tcpudp
+alias ipt_tcp xt_tcpudp
+alias ip6t_udp xt_tcpudp
+alias ip6t_tcp xt_tcpudp
+alias ipt_tcpmss xt_tcpmss
+alias ipt_string xt_string
+alias ip6t_string xt_string
+alias ipt_statistic xt_statistic
+alias ip6t_statistic xt_statistic
+alias ipt_state xt_state
+alias ip6t_state xt_state
+alias ipt_sctp xt_sctp
+alias ipt_realm xt_realm
+alias ipt_quota xt_quota
+alias ip6t_quota xt_quota
+alias ipt_pkttype xt_pkttype
+alias ip6t_pkttype xt_pkttype
+alias ipt_multiport xt_multiport
+alias ip6t_multiport xt_multiport
+alias ipt_mark xt_mark
+alias ip6t_mark xt_mark
+alias ipt_mac xt_mac
+alias ip6t_mac xt_mac
+alias ipt_limit xt_limit
+alias ip6t_limit xt_limit
+alias ipt_length xt_length
+alias ip6t_length xt_length
+alias ipt_helper xt_helper
+alias ip6t_helper xt_helper
+alias ipt_hashlimit xt_hashlimit
+alias ip6t_hashlimit xt_hashlimit
+alias ipt_esp xt_esp
+alias ip6t_esp xt_esp
+alias ipt_dscp xt_dscp
+alias ip6t_dscp xt_dscp
+alias ipt_dccp xt_dccp
+alias ipt_conntrack xt_conntrack
+alias ipt_connmark xt_connmark
+alias ipt_connbytes xt_connbytes
+alias ipt_comment xt_comment
+alias ip6t_comment xt_comment
+alias ipt_SETXID xt_SETXID
+alias ipt_NOTRACK xt_NOTRACK
+alias ipt_NFQUEUE xt_NFQUEUE
+alias ip6t_NFQUEUE xt_NFQUEUE
+alias arpt_NFQUEUE xt_NFQUEUE
+alias ipt_NFLOG xt_NFLOG
+alias ip6t_NFLOG xt_NFLOG
+alias ipt_MARK xt_MARK
+alias ip6t_MARK xt_MARK
+alias ipt_DSCP xt_DSCP
+alias ip6t_DSCP xt_DSCP
+alias ipt_CONNMARK xt_CONNMARK
+alias ipt_CLASSIFY xt_CLASSIFY
+alias nfnetlink-subsys-3 nfnetlink_queue
+alias nfnetlink-subsys-4 nfnetlink_log
+alias net-pf-16-proto-12 nfnetlink
+alias ip_conntrack_tftp nf_conntrack_tftp
+alias ip_conntrack_sip nf_conntrack_sip
+alias ip_conntrack_proto_sctp nf_conntrack_proto_sctp
+alias ip_conntrack_pptp nf_conntrack_pptp
+alias ip_conntrack_netlink nf_conntrack_netlink
+alias nfnetlink-subsys-1 nf_conntrack_netlink
+alias nfnetlink-subsys-2 nf_conntrack_netlink
+alias ip_conntrack_netbios_ns nf_conntrack_netbios_ns
+alias ip_conntrack_irc nf_conntrack_irc
+alias ip_conntrack_h323 nf_conntrack_h323
+alias ip_conntrack_ftp nf_conntrack_ftp
+alias ip_conntrack_amanda nf_conntrack_amanda
+alias ip_nat_tftp nf_nat_tftp
+alias ip_nat_snmp_basic nf_nat_snmp_basic
+alias ip_nat_sip nf_nat_sip
+alias ip_nat_pptp nf_nat_pptp
+alias ip_nat_irc nf_nat_irc
+alias ip_nat_h323 nf_nat_h323
+alias ip_nat_ftp nf_nat_ftp
+alias ip_nat_amanda nf_nat_amanda
+alias nf_conntrack-2 nf_conntrack_ipv4
+alias ip_conntrack nf_conntrack_ipv4
+alias ip_nat iptable_nat
+alias net-pf-16-proto-5 ipt_ULOG
+alias rtnl-link-vlan 8021q
+alias pci:v*d*sv*sd*bc0Csc03i00* uhci_hcd
+alias pci:v*d*sv*sd*bc0Csc03i10* ohci_hcd
+alias pci:v*d*sv*sd*bc0Csc03i20* ehci_hcd
+alias pci:v00001022d00002020sv*sd*bc*sc*i* tmscsim
+alias pci:v00001000d00000001sv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d00000002sv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d00000003sv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d00000004sv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d00000005sv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d00000006sv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d0000000Asv*sd*bc01sc00i* sym53c8xx
+alias pci:v00001000d0000000Bsv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d0000000Csv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d0000000Dsv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d0000000Fsv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d00000010sv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d00000012sv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d00000013sv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d00000020sv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d00000021sv*sd*bc*sc*i* sym53c8xx
+alias pci:v00001000d0000008Fsv*sd*bc*sc*i* sym53c8xx
+alias pci:v0000105Ad00008350sv*sd*bc*sc*i* stex
+alias pci:v0000105Ad0000C350sv*sd*bc*sc*i* stex
+alias pci:v0000105Ad00004302sv*sd*bc*sc*i* stex
+alias pci:v0000105Ad0000E350sv*sd*bc*sc*i* stex
+alias pci:v0000105Ad00007250sv*sd*bc*sc*i* stex
+alias pci:v0000105Ad00008650sv*sd00004600bc*sc*i* stex
+alias pci:v0000105Ad00008650sv*sd00004610bc*sc*i* stex
+alias pci:v0000105Ad00008650sv*sd00008600bc*sc*i* stex
+alias pci:v0000105Ad00008650sv*sd00008601bc*sc*i* stex
+alias pci:v0000105Ad00008650sv*sd00008602bc*sc*i* stex
+alias pci:v0000105Ad00008650sv*sd*bc*sc*i* stex
+alias char-major-9-* st
+alias scsi:t-0x01* st
+alias block-major-11-* sr_mod
+alias scsi:t-0x05* sr_mod
+alias scsi:t-0x04* sr_mod
+alias char-major-21-* sg
+alias block-major-8-* sd_mod
+alias block-major-65-* sd_mod
+alias block-major-66-* sd_mod
+alias block-major-67-* sd_mod
+alias block-major-68-* sd_mod
+alias block-major-69-* sd_mod
+alias block-major-70-* sd_mod
+alias block-major-71-* sd_mod
+alias block-major-128-* sd_mod
+alias block-major-129-* sd_mod
+alias block-major-130-* sd_mod
+alias block-major-131-* sd_mod
+alias block-major-132-* sd_mod
+alias block-major-133-* sd_mod
+alias block-major-134-* sd_mod
+alias block-major-135-* sd_mod
+alias scsi:t-0x00* sd_mod
+alias scsi:t-0x07* sd_mod
+alias scsi:t-0x0e* sd_mod
+alias pci:v00001077d00004010sv*sd*bc*sc*i* qla4xxx
+alias pci:v00001077d00004022sv*sd*bc*sc*i* qla4xxx
+alias pci:v00001077d00004032sv*sd*bc*sc*i* qla4xxx
+alias pci:v00001077d00002100sv*sd*bc*sc*i* qla2xxx
+alias pci:v00001077d00002200sv*sd*bc*sc*i* qla2xxx
+alias pci:v00001077d00002300sv*sd*bc*sc*i* qla2xxx
+alias pci:v00001077d00002312sv*sd*bc*sc*i* qla2xxx
+alias pci:v00001077d00002322sv*sd*bc*sc*i* qla2xxx
+alias pci:v00001077d00006312sv*sd*bc*sc*i* qla2xxx
+alias pci:v00001077d00006322sv*sd*bc*sc*i* qla2xxx
+alias pci:v00001077d00002422sv*sd*bc*sc*i* qla2xxx
+alias pci:v00001077d00002432sv*sd*bc*sc*i* qla2xxx
+alias pci:v00001077d00005422sv*sd*bc*sc*i* qla2xxx
+alias pci:v00001077d00005432sv*sd*bc*sc*i* qla2xxx
+alias pci:v00001077d00001216sv*sd*bc*sc*i* qla1280
+alias pci:v00001077d00001020sv*sd*bc*sc*i* qla1280
+alias pci:v00001077d00001080sv*sd*bc*sc*i* qla1280
+alias pci:v00001077d00001240sv*sd*bc*sc*i* qla1280
+alias pci:v00001077d00001280sv*sd*bc*sc*i* qla1280
+alias pci:v00001077d00001016sv*sd*bc*sc*i* qla1280
+alias char-major-206-* osst
+alias scsi:t-0x01* osst
+alias pci:v00001000d00000411sv*sd*bc*sc*i* megaraid_sas
+alias pci:v00001000d00000060sv*sd*bc*sc*i* megaraid_sas
+alias pci:v00001000d00000413sv*sd*bc*sc*i* megaraid_sas
+alias pci:v00001028d00000015sv*sd*bc*sc*i* megaraid_sas
+alias pci:v00001028d0000000Esv00001028sd00000123bc*sc*i* megaraid_mbox
+alias pci:v00001000d00001960sv00001028sd00000520bc*sc*i* megaraid_mbox
+alias pci:v00001000d00001960sv00001028sd00000518bc*sc*i* megaraid_mbox
+alias pci:v00001000d00000407sv*sd*bc*sc*i* megaraid_mbox
+alias pci:v00001028d0000000Fsv00001028sd0000014Abc*sc*i* megaraid_mbox
+alias pci:v00001028d00000013sv00001028sd0000016Cbc*sc*i* megaraid_mbox
+alias pci:v00001028d00000013sv00001028sd0000016Dbc*sc*i* megaraid_mbox
+alias pci:v00001028d00000013sv00001028sd0000016Ebc*sc*i* megaraid_mbox
+alias pci:v00001028d00000013sv00001028sd0000016Fbc*sc*i* megaraid_mbox
+alias pci:v00001028d00000013sv00001028sd00000170bc*sc*i* megaraid_mbox
+alias pci:v00001000d00000408sv*sd*bc*sc*i* megaraid_mbox
+alias pci:v0000101Ed00001960sv*sd*bc*sc*i* megaraid_mbox
+alias pci:v00001000d00001960sv*sd*bc*sc*i* megaraid_mbox
+alias pci:v00001000d00000409sv*sd*bc*sc*i* megaraid_mbox
+alias pci:v0000101Ed00009010sv*sd*bc*sc*i* megaraid
+alias pci:v0000101Ed00009060sv*sd*bc*sc*i* megaraid
+alias pci:v00008086d00001960sv*sd*bc*sc*i* megaraid
+alias pci:v00001014d0000002Esv*sd*bc*sc*i* ips
+alias pci:v00001014d000001BDsv*sd*bc*sc*i* ips
+alias pci:v00009005d00000250sv*sd*bc*sc*i* ips
+alias pci:v00001069d0000B166sv00001014sd00000266bc*sc*i* ipr
+alias pci:v00001069d0000B166sv00001014sd00000278bc*sc*i* ipr
+alias pci:v00001069d0000B166sv00001014sd000002D4bc*sc*i* ipr
+alias pci:v00001069d0000B166sv00001014sd000002D3bc*sc*i* ipr
+alias pci:v00001014d0000028Csv00001014sd000002BEbc*sc*i* ipr
+alias pci:v00001014d0000028Csv00001014sd0000028Dbc*sc*i* ipr
+alias pci:v00001014d0000028Csv00001014sd000002C0bc*sc*i* ipr
+alias pci:v00001014d0000028Csv00001014sd0000030Dbc*sc*i* ipr
+alias pci:v00009005d00000500sv00001014sd000002C1bc*sc*i* ipr
+alias pci:v00009005d00000500sv00001014sd000002C2bc*sc*i* ipr
+alias pci:v00009005d00000500sv00001014sd00000338bc*sc*i* ipr
+alias pci:v00001014d000002BDsv00001014sd000002C1bc*sc*i* ipr
+alias pci:v00001014d000002BDsv00001014sd000002C2bc*sc*i* ipr
+alias pci:v00001014d000002BDsv00001014sd00000338bc*sc*i* ipr
+alias pci:v00001014d00000339sv00001014sd0000030Abc*sc*i* ipr
+alias pci:v00001014d00000339sv00001014sd0000033Ebc*sc*i* ipr
+alias pci:v00001014d00000339sv00001014sd0000033Abc*sc*i* ipr
+alias pci:v00001014d00000339sv00001014sd00000360bc*sc*i* ipr
+alias pci:v00001014d00000180sv00001014sd00000264bc*sc*i* ipr
+alias pci:v00009005d00000503sv00001014sd000002BFbc*sc*i* ipr
+alias pci:v00009005d00000503sv00001014sd000002D5bc*sc*i* ipr
+alias pci:v00009005d00000503sv00001014sd000002C3bc*sc*i* ipr
+alias pci:v00001014d0000034Asv00001014sd0000030Bbc*sc*i* ipr
+alias pci:v00001101d00009500sv*sd*bc*sc*i* initio
+alias pci:v00001101d00009400sv*sd*bc*sc*i* initio
+alias pci:v00001101d00009401sv*sd*bc*sc*i* initio
+alias pci:v00001101d00000002sv*sd*bc*sc*i* initio
+alias pci:v0000134Ad00000002sv*sd*bc*sc*i* initio
+alias pci:v00001119d*sv*sd*bc*sc*i* gdth
+alias pci:v00008086d00000600sv*sd*bc*sc*i* gdth
+alias pci:v00008086d00000601sv*sd*bc*sc*i* gdth
+alias pci:v00001DE1d00000391sv*sd*bc*sc*i* dc395x
+alias char-major-86-* ch
+alias pci:v00001191d0000808Asv*sd*bc*sc*i* atp870u
+alias pci:v00001191d00008080sv*sd*bc*sc*i* atp870u
+alias pci:v00001191d00008081sv*sd*bc*sc*i* atp870u
+alias pci:v00001191d00008002sv*sd*bc*sc*i* atp870u
+alias pci:v00001191d00008010sv*sd*bc*sc*i* atp870u
+alias pci:v00001191d00008020sv*sd*bc*sc*i* atp870u
+alias pci:v00001191d00008030sv*sd*bc*sc*i* atp870u
+alias pci:v00001191d00008040sv*sd*bc*sc*i* atp870u
+alias pci:v00001191d00008050sv*sd*bc*sc*i* atp870u
+alias pci:v00001191d00008060sv*sd*bc*sc*i* atp870u
+alias pci:v000017D3d00001110sv*sd*bc*sc*i* arcmsr
+alias pci:v000017D3d00001120sv*sd*bc*sc*i* arcmsr
+alias pci:v000017D3d00001130sv*sd*bc*sc*i* arcmsr
+alias pci:v000017D3d00001160sv*sd*bc*sc*i* arcmsr
+alias pci:v000017D3d00001170sv*sd*bc*sc*i* arcmsr
+alias pci:v000017D3d00001210sv*sd*bc*sc*i* arcmsr
+alias pci:v000017D3d00001220sv*sd*bc*sc*i* arcmsr
+alias pci:v000017D3d00001230sv*sd*bc*sc*i* arcmsr
+alias pci:v000017D3d00001260sv*sd*bc*sc*i* arcmsr
+alias pci:v000017D3d00001270sv*sd*bc*sc*i* arcmsr
+alias pci:v000017D3d00001280sv*sd*bc*sc*i* arcmsr
+alias pci:v000017D3d00001380sv*sd*bc*sc*i* arcmsr
+alias pci:v000017D3d00001381sv*sd*bc*sc*i* arcmsr
+alias pci:v000017D3d00001680sv*sd*bc*sc*i* arcmsr
+alias pci:v000017D3d00001681sv*sd*bc*sc*i* arcmsr
+alias pci:v00009005d00000410sv*sd*bc*sc*i* aic94xx
+alias pci:v00009005d00000412sv*sd*bc*sc*i* aic94xx
+alias pci:v00009005d0000041Esv*sd*bc*sc*i* aic94xx
+alias pci:v00009005d0000041Fsv*sd*bc*sc*i* aic94xx
+alias pci:v00009005d00000430sv*sd*bc*sc*i* aic94xx
+alias pci:v00009005d00000432sv*sd*bc*sc*i* aic94xx
+alias pci:v00009005d0000043Esv*sd*bc*sc*i* aic94xx
+alias pci:v00009005d0000043Fsv*sd*bc*sc*i* aic94xx
+alias pci:v00009004d00005078sv00009004sd00007850bc01sc00i* aic7xxx
+alias pci:v00009004d00003860sv00009004sd00003869bc01sc00i* aic7xxx
+alias pci:v00009004d00006075sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00006178sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00002178sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00006038sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00007178sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00007278sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00007378sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00007478sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00007578sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00007678sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00008178sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00008278sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00008478sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00008578sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00008378sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00008678sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00008878sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00008778sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00000078sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000011sv00009005sd00000181bc01sc00i* aic7xxx
+alias pci:v00009005d00000010sv00009005sd0000A100bc01sc00i* aic7xxx
+alias pci:v00009005d00000010sv00009005sd00002180bc01sc00i* aic7xxx
+alias pci:v00009005d00000010sv00009005sd0000A180bc01sc00i* aic7xxx
+alias pci:v00009005d00000010sv00009005sd0000E100bc01sc00i* aic7xxx
+alias pci:v00009005d00000010sv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d00000011sv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d00000012sv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d00000013sv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d00000014sv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d00000015sv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d00000016sv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d00000017sv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d00000018sv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d00000019sv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d0000001Asv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d0000001Bsv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d0000001Csv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d0000001Dsv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d0000001Esv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d0000001Fsv00009005sd0000000Fbc01sc00i* aic7xxx
+alias pci:v00009005d00000013sv00009005sd00000003bc01sc00i* aic7xxx
+alias pci:v00009005d00000080sv00009005sd0000E2A0bc01sc00i* aic7xxx
+alias pci:v00009005d00000080sv00000E11sd0000E2A0bc01sc00i* aic7xxx
+alias pci:v00009005d00000080sv00009005sd000062A0bc01sc00i* aic7xxx
+alias pci:v00009005d00000080sv00009005sd00006220bc01sc00i* aic7xxx
+alias pci:v00009005d00000080sv00009005sd0000E220bc01sc00i* aic7xxx
+alias pci:v00009005d00000081sv00009005sd000062A1bc01sc00i* aic7xxx
+alias pci:v00009005d00000083sv00009005sd0000FFFFbc01sc00i* aic7xxx
+alias pci:v00009004d00007895sv00009004sd00007891bc01sc00i* aic7xxx
+alias pci:v00009004d00007895sv00009004sd00007892bc01sc00i* aic7xxx
+alias pci:v00009004d00007895sv00009004sd00007894bc01sc00i* aic7xxx
+alias pci:v00009004d00007890sv00009004sd00007893bc01sc00i* aic7xxx
+alias pci:v00009005d00000050sv00009005sd0000FFFFbc01sc00i* aic7xxx
+alias pci:v00009005d00000050sv00009005sd0000F500bc01sc00i* aic7xxx
+alias pci:v00009005d00000051sv00009005sd0000FFFFbc01sc00i* aic7xxx
+alias pci:v00009005d00000051sv00009005sd0000B500bc01sc00i* aic7xxx
+alias pci:v00009005d00000053sv00009005sd0000FFFFbc01sc00i* aic7xxx
+alias pci:v00009005d000000C0sv00009005sd0000F620bc01sc00i* aic7xxx
+alias pci:v00009005d000000C0sv00000E11sd0000F620bc01sc00i* aic7xxx
+alias pci:v00009005d000000C3sv00009005sd0000FFFFbc01sc00i* aic7xxx
+alias pci:v00009004d00005078sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00005578sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00003860sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00006078sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00007078sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00008078sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000010sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000011sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000012sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000013sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000014sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000015sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000016sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000017sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000018sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000019sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000001Asv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000001Bsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000001Csv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000001Dsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000001Esv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000001Fsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000080sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000081sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000082sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000083sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000084sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000085sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000086sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000087sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000088sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000089sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000008Asv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000008Bsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000008Csv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000008Dsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000008Esv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000008Fsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00007895sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000050sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000051sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000052sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000053sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000054sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000055sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000056sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000057sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000058sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00000059sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000005Asv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000005Bsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000005Csv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000005Dsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000005Esv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d0000005Fsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000C0sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000C1sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000C2sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000C3sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000C4sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000C5sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000C6sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000C7sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000C8sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000C9sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000CAsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000CBsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000CCsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000CDsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000CEsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d000000CFsv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00001078sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009004d00007815sv*sd*bc01sc00i* aic7xxx
+alias pci:v00009005d00008000sv00009005sd00000060bc01sc00i* aic79xx
+alias pci:v00009005d00008000sv00009005sd00000060bc01sc04i* aic79xx
+alias pci:v00009005d00008080sv00009005sd00000060bc01sc00i* aic79xx
+alias pci:v00009005d00008080sv00009005sd00000060bc01sc04i* aic79xx
+alias pci:v00009005d00008017sv00009005sd00000044bc01sc00i* aic79xx
+alias pci:v00009005d00008017sv00009005sd00000044bc01sc04i* aic79xx
+alias pci:v00009005d00008097sv00009005sd00000044bc01sc00i* aic79xx
+alias pci:v00009005d00008097sv00009005sd00000044bc01sc04i* aic79xx
+alias pci:v00009005d00008017sv00009005sd00000045bc01sc00i* aic79xx
+alias pci:v00009005d00008017sv00009005sd00000045bc01sc04i* aic79xx
+alias pci:v00009005d00008097sv00009005sd00000045bc01sc00i* aic79xx
+alias pci:v00009005d00008097sv00009005sd00000045bc01sc04i* aic79xx
+alias pci:v00009005d00008012sv00009005sd00000042bc01sc00i* aic79xx
+alias pci:v00009005d00008012sv00009005sd00000042bc01sc04i* aic79xx
+alias pci:v00009005d00008092sv00009005sd00000042bc01sc00i* aic79xx
+alias pci:v00009005d00008092sv00009005sd00000042bc01sc04i* aic79xx
+alias pci:v00009005d00008013sv00009005sd00000043bc01sc00i* aic79xx
+alias pci:v00009005d00008013sv00009005sd00000043bc01sc04i* aic79xx
+alias pci:v00009005d00008093sv00009005sd00000043bc01sc00i* aic79xx
+alias pci:v00009005d00008093sv00009005sd00000043bc01sc04i* aic79xx
+alias pci:v00009005d00008014sv00009005sd00000044bc01sc00i* aic79xx
+alias pci:v00009005d00008014sv00009005sd00000044bc01sc04i* aic79xx
+alias pci:v00009005d00008094sv00009005sd00000044bc01sc00i* aic79xx
+alias pci:v00009005d00008094sv00009005sd00000044bc01sc04i* aic79xx
+alias pci:v00009005d00008010sv00009005sd00000040bc01sc00i* aic79xx
+alias pci:v00009005d00008010sv00009005sd00000040bc01sc04i* aic79xx
+alias pci:v00009005d00008090sv00009005sd00000040bc01sc00i* aic79xx
+alias pci:v00009005d00008090sv00009005sd00000040bc01sc04i* aic79xx
+alias pci:v00009005d00008015sv00009005sd00000040bc01sc00i* aic79xx
+alias pci:v00009005d00008015sv00009005sd00000040bc01sc04i* aic79xx
+alias pci:v00009005d00008095sv00009005sd00000040bc01sc00i* aic79xx
+alias pci:v00009005d00008095sv00009005sd00000040bc01sc04i* aic79xx
+alias pci:v00009005d00008016sv00009005sd00000040bc01sc00i* aic79xx
+alias pci:v00009005d00008016sv00009005sd00000040bc01sc04i* aic79xx
+alias pci:v00009005d00008096sv00009005sd00000040bc01sc00i* aic79xx
+alias pci:v00009005d00008096sv00009005sd00000040bc01sc04i* aic79xx
+alias pci:v00009005d00008011sv00009005sd00000041bc01sc00i* aic79xx
+alias pci:v00009005d00008011sv00009005sd00000041bc01sc04i* aic79xx
+alias pci:v00009005d00008091sv00009005sd00000041bc01sc00i* aic79xx
+alias pci:v00009005d00008091sv00009005sd00000041bc01sc04i* aic79xx
+alias pci:v00009005d00008011sv00000E11sd000000ACbc01sc00i* aic79xx
+alias pci:v00009005d00008011sv00000E11sd000000ACbc01sc04i* aic79xx
+alias pci:v00009005d00008091sv00000E11sd000000ACbc01sc00i* aic79xx
+alias pci:v00009005d00008091sv00000E11sd000000ACbc01sc04i* aic79xx
+alias pci:v00009005d0000801Csv00009005sd00000041bc01sc00i* aic79xx
+alias pci:v00009005d0000801Csv00009005sd00000041bc01sc04i* aic79xx
+alias pci:v00009005d0000809Csv00009005sd00000041bc01sc00i* aic79xx
+alias pci:v00009005d0000809Csv00009005sd00000041bc01sc04i* aic79xx
+alias pci:v00009005d0000801Csv00000E11sd000000ACbc01sc00i* aic79xx
+alias pci:v00009005d0000801Csv00000E11sd000000ACbc01sc04i* aic79xx
+alias pci:v00009005d0000809Csv00000E11sd000000ACbc01sc00i* aic79xx
+alias pci:v00009005d0000809Csv00000E11sd000000ACbc01sc04i* aic79xx
+alias pci:v00009005d00008000sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008000sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008080sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008080sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008001sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008001sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008081sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008081sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008002sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008002sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008082sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008082sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008003sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008003sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008083sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008083sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008004sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008004sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008084sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008084sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008005sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008005sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008085sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008085sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008006sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008006sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008086sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008086sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008007sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008007sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008087sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008087sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008008sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008008sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008088sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008088sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008009sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008009sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008089sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008089sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000800Asv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000800Asv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000808Asv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000808Asv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000800Bsv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000800Bsv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000808Bsv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000808Bsv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000800Csv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000800Csv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000808Csv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000808Csv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000800Dsv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000800Dsv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000808Dsv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000808Dsv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000800Esv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000800Esv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000808Esv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000808Esv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000800Fsv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000800Fsv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000808Fsv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000808Fsv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000801Esv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000801Esv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000809Esv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000809Esv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008010sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008010sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008090sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008090sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008011sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008011sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008091sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008091sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008012sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008012sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008092sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008092sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008013sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008013sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008093sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008093sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008014sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008014sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008094sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008094sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008015sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008015sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008095sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008095sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008016sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008016sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008096sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008096sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008017sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008017sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008097sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008097sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008018sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008018sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008098sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008098sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008019sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008019sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d00008099sv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d00008099sv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000801Asv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000801Asv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000809Asv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000809Asv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000801Bsv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000801Bsv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000809Bsv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000809Bsv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000801Csv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000801Csv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000809Csv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000809Csv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000801Dsv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000801Dsv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000809Dsv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000809Dsv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000801Esv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000801Esv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000809Esv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000809Esv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000801Fsv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000801Fsv*sd*bc01sc04i* aic79xx
+alias pci:v00009005d0000809Fsv*sd*bc01sc00i* aic79xx
+alias pci:v00009005d0000809Fsv*sd*bc01sc04i* aic79xx
+alias pci:v000010CDd00001100sv*sd*bc*sc*i* advansys
+alias pci:v000010CDd00001200sv*sd*bc*sc*i* advansys
+alias pci:v000010CDd00001300sv*sd*bc*sc*i* advansys
+alias pci:v000010CDd00002300sv*sd*bc*sc*i* advansys
+alias pci:v000010CDd00002500sv*sd*bc*sc*i* advansys
+alias pci:v000010CDd00002700sv*sd*bc*sc*i* advansys
+alias pci:v00001028d00000001sv00001028sd00000001bc*sc*i* aacraid
+alias pci:v00001028d00000002sv00001028sd00000002bc*sc*i* aacraid
+alias pci:v00001028d00000003sv00001028sd00000003bc*sc*i* aacraid
+alias pci:v00001028d00000004sv00001028sd000000D0bc*sc*i* aacraid
+alias pci:v00001028d00000002sv00001028sd000000D1bc*sc*i* aacraid
+alias pci:v00001028d00000002sv00001028sd000000D9bc*sc*i* aacraid
+alias pci:v00001028d0000000Asv00001028sd00000106bc*sc*i* aacraid
+alias pci:v00001028d0000000Asv00001028sd0000011Bbc*sc*i* aacraid
+alias pci:v00001028d0000000Asv00001028sd00000121bc*sc*i* aacraid
+alias pci:v00009005d00000283sv00009005sd00000283bc*sc*i* aacraid
+alias pci:v00009005d00000284sv00009005sd00000284bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd00000286bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd00000285bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd00000287bc*sc*i* aacraid
+alias pci:v00009005d00000285sv000017AAsd00000286bc*sc*i* aacraid
+alias pci:v00009005d00000285sv000017AAsd00000287bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd00000288bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd00000289bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd0000028Abc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd0000028Bbc*sc*i* aacraid
+alias pci:v00009005d00000286sv00009005sd0000028Cbc*sc*i* aacraid
+alias pci:v00009005d00000286sv00009005sd0000028Dbc*sc*i* aacraid
+alias pci:v00009005d00000286sv00009005sd0000029Bbc*sc*i* aacraid
+alias pci:v00009005d00000286sv00009005sd0000029Cbc*sc*i* aacraid
+alias pci:v00009005d00000286sv00009005sd0000029Dbc*sc*i* aacraid
+alias pci:v00009005d00000286sv00009005sd0000029Ebc*sc*i* aacraid
+alias pci:v00009005d00000286sv00009005sd0000029Fbc*sc*i* aacraid
+alias pci:v00009005d00000286sv00009005sd000002A0bc*sc*i* aacraid
+alias pci:v00009005d00000286sv00009005sd000002A1bc*sc*i* aacraid
+alias pci:v00009005d00000286sv00009005sd000002A3bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd000002A4bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd000002A5bc*sc*i* aacraid
+alias pci:v00009005d00000286sv00009005sd000002A6bc*sc*i* aacraid
+alias pci:v00009005d00000287sv00009005sd00000800bc*sc*i* aacraid
+alias pci:v00009005d00000200sv00009005sd00000200bc*sc*i* aacraid
+alias pci:v00009005d00000286sv00009005sd00000800bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd0000028Ebc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd0000028Fbc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd00000290bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00001028sd00000291bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd00000292bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd00000293bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd00000294bc*sc*i* aacraid
+alias pci:v00009005d00000285sv0000103Csd00003227bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd00000296bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd00000297bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00001014sd000002F2bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00001014sd00000312bc*sc*i* aacraid
+alias pci:v00009005d00000286sv00001014sd00009580bc*sc*i* aacraid
+alias pci:v00009005d00000286sv00001014sd00009540bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd00000298bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd00000299bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00009005sd0000029Abc*sc*i* aacraid
+alias pci:v00009005d00000286sv00009005sd000002A2bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00001028sd00000287bc*sc*i* aacraid
+alias pci:v00001011d00000046sv00009005sd00000365bc*sc*i* aacraid
+alias pci:v00001011d00000046sv00009005sd00000364bc*sc*i* aacraid
+alias pci:v00001011d00000046sv00009005sd00001364bc*sc*i* aacraid
+alias pci:v00001011d00000046sv0000103Csd000010C2bc*sc*i* aacraid
+alias pci:v00009005d00000285sv00001028sd*bc*sc*i* aacraid
+alias pci:v00009005d00000285sv000017AAsd*bc*sc*i* aacraid
+alias pci:v00009005d00000285sv*sd*bc*sc*i* aacraid
+alias pci:v00009005d00000286sv*sd*bc*sc*i* aacraid
+alias pci:v00009005d00000288sv*sd*bc*sc*i* aacraid
+alias pci:v00001101d00001060sv*sd*bc*sc*i* a100u2w
+alias pci:v0000104Bd00001040sv*sd*bc*sc*i* BusLogic
+alias pci:v0000104Bd00000140sv*sd*bc*sc*i* BusLogic
+alias pci:v0000104Bd00008130sv*sd*bc*sc*i* BusLogic
+alias pci:v000013C1d00001000sv*sd*bc*sc*i* 3w_xxxx
+alias pci:v000013C1d00001001sv*sd*bc*sc*i* 3w_xxxx
+alias pci:v000013C1d00001002sv*sd*bc*sc*i* 3w_9xxx
+alias pci:v000013C1d00001003sv*sd*bc*sc*i* 3w_9xxx
+alias pci:v000013C1d00001004sv*sd*bc*sc*i* 3w_9xxx
+alias pci:v00001000d00000702sv*sd*bc*sc*i* yellowfin
+alias pci:v00001000d00000701sv*sd*bc*sc*i* yellowfin
+alias pci:v00001106d00003119sv*sd*bc*sc*i* via_velocity
+alias pci:v00001106d00003043sv*sd*bc*sc*i* via_rhine
+alias pci:v00001106d00003065sv*sd*bc*sc*i* via_rhine
+alias pci:v00001106d00003106sv*sd*bc*sc*i* via_rhine
+alias pci:v00001106d00003053sv*sd*bc*sc*i* via_rhine
+alias usb:v04DDp8004d*dc*dsc*dp*ic02isc06ip00* zaurus
+alias usb:v04DDp8005d*dc*dsc*dp*ic02isc06ip00* zaurus
+alias usb:v04DDp8006d*dc*dsc*dp*ic02isc06ip00* zaurus
+alias usb:v04DDp8007d*dc*dsc*dp*ic02isc06ip00* zaurus
+alias usb:v04DDp9031d*dc*dsc*dp*ic02isc06ip00* zaurus
+alias usb:v04DDp9032d*dc*dsc*dp*ic02isc06ip00* zaurus
+alias usb:v04DDp9050d*dc*dsc*dp*ic02isc06ip00* zaurus
+alias usb:v*p*d*dc*dsc*dp*ic02isc0Aip00* zaurus
+alias usb:v07B4p0F02d*dc*dsc*dp*ic02isc06ip00* zaurus
+alias usb:v0BDAp8150d*dc*dsc*dp*ic*isc*ip* rtl8150
+alias usb:v0411p0012d*dc*dsc*dp*ic*isc*ip* rtl8150
+alias usb:v3980p0003d*dc*dsc*dp*ic*isc*ip* rtl8150
+alias usb:v07B8p401Ad*dc*dsc*dp*ic*isc*ip* rtl8150
+alias usb:v1557p8150d*dc*dsc*dp*ic*isc*ip* rtl8150
+alias usb:v0586p401Ad*dc*dsc*dp*ic*isc*ip* rtl8150
+alias usb:v*p*d*dc*dsc*dp*ic02isc02ipFF* rndis_host
+alias usb:v*p*d*dc*dsc*dp*icEFisc01ip01* rndis_host
+alias usb:v067Bp0000d*dc*dsc*dp*ic*isc*ip* plusb
+alias usb:v067Bp0001d*dc*dsc*dp*ic*isc*ip* plusb
+alias usb:v0506p4601d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v0557p2007d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07B8p110Cd*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07B8p4104d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07B8p4004d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07B8p4007d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07B8p4102d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07B8p4002d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07B8p400Bd*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07B8p400Cd*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07B8pABC1d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07B8p200Cd*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v083Ap1046d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v083Ap5046d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v083ApB004d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07A6p8511d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07A6p8513d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07A6p8515d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07A6p0986d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07A6p07C2d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v3334p1701d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07C9pB100d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v050Dp0121d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v08DDp0986d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v08DDp0987d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v049Fp8511d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v08DDp0988d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v08DDp8511d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07AAp0004d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v07AAp000Dd*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v2001p4001d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v2001p4002d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v2001p4102d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v2001p400Bd*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v2001p200Cd*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v2001p4003d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v2001pABC1d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v0DB7p0002d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v056Ep4010d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v1342p0304d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v05CCp3000d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v1044p8002d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v0E66p400Cd*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v03F0p811Cd*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v04BBp0904d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v04BBp0913d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v0951p000Ad*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v056Ep4002d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v056Ep4005d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v056Ep400Bd*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v056EpABC1d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v056Ep200Cd*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v066Bp2202d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v066Bp2203d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v066Bp2204d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v066Bp2206d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v077Bp08B4d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v066Bp400Bd*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v066Bp200Cd*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v0411p0001d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v0411p0005d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v0411p0009d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v045Ep007Ad*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v0846p1020d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v0B39p0109d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v0B39p0901d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v08D1p0003d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v0707p0200d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v0707p0201d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v15E8p9100d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v15E8p9110d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v067Cp1001d*dc*dsc*dp*ic*isc*ip* pegasus
+alias usb:v0525p1080d*dc*dsc*dp*ic*isc*ip* net1080
+alias usb:v06D0p0622d*dc*dsc*dp*ic*isc*ip* net1080
+alias usb:v9710p7830d*dc*dsc*dp*ic*isc*ip* mcs7830
+alias usb:v03E8p0008d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v04BBp0901d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v0506p03E8d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v0506p11F8d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v0557p2002d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v0557p4000d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v0565p0002d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v0565p0003d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v0565p0005d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v05E9p0008d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v05E9p0009d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v066Bp2202d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v06E1p0008d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v06E1p0009d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v0707p0100d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v07AAp0001d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v07B8p4000d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v0846p1001d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v0846p1002d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v085Ap0008d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v085Ap0009d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v087Dp5704d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v0951p0008d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v095Ap3003d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v10BDp1427d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v1342p0204d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v13D2p0400d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v1485p0001d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v1485p0002d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v1645p0005d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v1645p0008d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v1645p8005d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v1668p0323d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v2001p4000d*dc*dsc*dp*ic*isc*ip* kaweth
+alias usb:v05E3p0502d*dc*dsc*dp*ic*isc*ip* gl620a
+alias usb:v0402p5632d*dc*dsc*dp*ic*isc*ip* cdc_subset
+alias usb:v182Dp207Cd*dc*dsc*dp*ic*isc*ip* cdc_subset
+alias usb:v0547p2720d*dc*dsc*dp*ic*isc*ip* cdc_subset
+alias usb:v0547p2727d*dc*dsc*dp*ic*isc*ip* cdc_subset
+alias usb:v050Dp0004d*dc*dsc*dp*ic*isc*ip* cdc_subset
+alias usb:v056Cp8100d*dc*dsc*dp*ic*isc*ip* cdc_subset
+alias usb:v0525p9901d*dc*dsc*dp*ic*isc*ip* cdc_subset
+alias usb:v0525p2888d*dc*dsc*dp*ic*isc*ip* cdc_subset
+alias usb:v049Fp505Ad*dc*dsc*dp*ic*isc*ip* cdc_subset
+alias usb:v0E7Ep1001d*dc*dsc*dp*ic*isc*ip* cdc_subset
+alias usb:v8086p07D3d*dc*dsc*dp*ic*isc*ip* cdc_subset
+alias usb:v0525pA4A2d0203dc*dsc*dp*ic*isc*ip* cdc_subset
+alias usb:v04DDp8004d*dc*dsc*dp*ic02isc06ip00* cdc_ether
+alias usb:v04DDp8005d*dc*dsc*dp*ic02isc06ip00* cdc_ether
+alias usb:v04DDp8006d*dc*dsc*dp*ic02isc06ip00* cdc_ether
+alias usb:v04DDp8007d*dc*dsc*dp*ic02isc06ip00* cdc_ether
+alias usb:v04DDp9031d*dc*dsc*dp*ic02isc06ip00* cdc_ether
+alias usb:v04DDp9032d*dc*dsc*dp*ic02isc06ip00* cdc_ether
+alias usb:v04DDp9050d*dc*dsc*dp*ic02isc06ip00* cdc_ether
+alias usb:v07B4p0F02d*dc*dsc*dp*ic02isc06ip00* cdc_ether
+alias usb:v*p*d*dc*dsc*dp*ic02isc06ip00* cdc_ether
+alias usb:v0423p000Ad*dc*dsc*dp*ic*isc*ip* catc
+alias usb:v0423p000Cd*dc*dsc*dp*ic*isc*ip* catc
+alias usb:v08D1p0001d*dc*dsc*dp*ic*isc*ip* catc
+alias usb:v077Bp2226d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v0846p1040d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v2001p1A00d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v0B95p1720d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v07B8p420Ad*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v08DDp90FFd*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v0557p2009d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v0411p003Dd*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v6189p182Dd*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v07AAp0017d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v1189p0893d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v1631p6200d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v04F1p3008d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v0B95p7720d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v0B95p1780d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v13B1p0018d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v1557p7720d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v07D1p3C05d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v2001p3C05d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v1737p0039d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v04BBp0930d*dc*dsc*dp*ic*isc*ip* asix
+alias usb:v050Dp5055d*dc*dsc*dp*ic*isc*ip* asix
+alias pci:v000010B7d00009900sv*sd*bc*sc*i* typhoon
+alias pci:v000010B7d00009902sv*sd*bc*sc*i* typhoon
+alias pci:v000010B7d00009903sv*sd*bc*sc*i* typhoon
+alias pci:v000010B7d00009904sv*sd00001000bc*sc*i* typhoon
+alias pci:v000010B7d00009904sv*sd00001102bc*sc*i* typhoon
+alias pci:v000010B7d00009904sv*sd00002000bc*sc*i* typhoon
+alias pci:v000010B7d00009905sv*sd00001101bc*sc*i* typhoon
+alias pci:v000010B7d00009905sv*sd00001102bc*sc*i* typhoon
+alias pci:v000010B7d00009905sv*sd00002101bc*sc*i* typhoon
+alias pci:v000010B7d00009905sv*sd00002102bc*sc*i* typhoon
+alias pci:v000010B7d00009908sv*sd*bc*sc*i* typhoon
+alias pci:v000010B7d00009909sv*sd*bc*sc*i* typhoon
+alias pci:v000010B7d0000990Asv*sd*bc*sc*i* typhoon
+alias char-major-10-200 tun
+alias pci:v00001050d00000840sv*sd00008153bc*sc*i* winbond_840
+alias pci:v00001050d00000840sv*sd*bc*sc*i* winbond_840
+alias pci:v000011F6d00002011sv*sd*bc*sc*i* winbond_840
+alias pci:v000010B9d00005261sv*sd*bc*sc*i* uli526x
+alias pci:v000010B9d00005263sv*sd*bc*sc*i* uli526x
+alias pci:v00001011d00000009sv*sd*bc*sc*i* tulip
+alias pci:v00001011d00000019sv*sd*bc*sc*i* tulip
+alias pci:v000011ADd00000002sv*sd*bc*sc*i* tulip
+alias pci:v000010D9d00000512sv*sd*bc*sc*i* tulip
+alias pci:v000010D9d00000531sv*sd*bc*sc*i* tulip
+alias pci:v0000125Bd00001400sv*sd*bc*sc*i* tulip
+alias pci:v000011ADd0000C115sv*sd*bc*sc*i* tulip
+alias pci:v00001317d00000981sv*sd*bc*sc*i* tulip
+alias pci:v00001317d00000985sv*sd*bc*sc*i* tulip
+alias pci:v00001317d00001985sv*sd*bc*sc*i* tulip
+alias pci:v00001317d00009511sv*sd*bc*sc*i* tulip
+alias pci:v000013D1d0000AB02sv*sd*bc*sc*i* tulip
+alias pci:v000013D1d0000AB03sv*sd*bc*sc*i* tulip
+alias pci:v000013D1d0000AB08sv*sd*bc*sc*i* tulip
+alias pci:v0000104Ad00000981sv*sd*bc*sc*i* tulip
+alias pci:v0000104Ad00002774sv*sd*bc*sc*i* tulip
+alias pci:v00001259d0000A120sv*sd*bc*sc*i* tulip
+alias pci:v000011F6d00009881sv*sd*bc*sc*i* tulip
+alias pci:v00008086d00000039sv*sd*bc*sc*i* tulip
+alias pci:v00001282d00009100sv*sd*bc*sc*i* tulip
+alias pci:v00001282d00009102sv*sd*bc*sc*i* tulip
+alias pci:v00001113d00001216sv*sd*bc*sc*i* tulip
+alias pci:v00001113d00001217sv*sd*bc*sc*i* tulip
+alias pci:v00001113d00009511sv*sd*bc*sc*i* tulip
+alias pci:v00001186d00001541sv*sd*bc*sc*i* tulip
+alias pci:v00001186d00001561sv*sd*bc*sc*i* tulip
+alias pci:v00001186d00001591sv*sd*bc*sc*i* tulip
+alias pci:v000014F1d00001803sv*sd*bc*sc*i* tulip
+alias pci:v00001626d00008410sv*sd*bc*sc*i* tulip
+alias pci:v00001737d0000AB09sv*sd*bc*sc*i* tulip
+alias pci:v00001737d0000AB08sv*sd*bc*sc*i* tulip
+alias pci:v000017B3d0000AB08sv*sd*bc*sc*i* tulip
+alias pci:v000010B7d00009300sv*sd*bc*sc*i* tulip
+alias pci:v000014EAd0000AB08sv*sd*bc*sc*i* tulip
+alias pci:v00001414d00000002sv*sd*bc*sc*i* tulip
+alias pci:v00001282d00009132sv*sd*bc*sc*i* dmfe
+alias pci:v00001282d00009102sv*sd*bc*sc*i* dmfe
+alias pci:v00001282d00009100sv*sd*bc*sc*i* dmfe
+alias pci:v00001282d00009009sv*sd*bc*sc*i* dmfe
+alias pci:v00001011d00000002sv*sd*bc*sc*i* de2104x
+alias pci:v00001011d00000014sv*sd*bc*sc*i* de2104x
+alias pci:v00000E11d0000AE34sv*sd*bc*sc*i* tlan
+alias pci:v00000E11d0000AE32sv*sd*bc*sc*i* tlan
+alias pci:v00000E11d0000AE35sv*sd*bc*sc*i* tlan
+alias pci:v00000E11d0000F130sv*sd*bc*sc*i* tlan
+alias pci:v00000E11d0000F150sv*sd*bc*sc*i* tlan
+alias pci:v00000E11d0000AE43sv*sd*bc*sc*i* tlan
+alias pci:v00000E11d0000AE40sv*sd*bc*sc*i* tlan
+alias pci:v00000E11d0000B011sv*sd*bc*sc*i* tlan
+alias pci:v0000108Dd00000013sv*sd*bc*sc*i* tlan
+alias pci:v0000108Dd00000012sv*sd*bc*sc*i* tlan
+alias pci:v0000108Dd00000014sv*sd*bc*sc*i* tlan
+alias pci:v00000E11d0000B030sv*sd*bc*sc*i* tlan
+alias pci:v00000E11d0000B012sv*sd*bc*sc*i* tlan
+alias pci:v000014E4d00001644sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001645sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001646sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001647sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001648sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000164Dsv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001653sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001654sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000165Dsv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000165Esv*sd*bc*sc*i* tg3
+alias pci:v000014E4d000016A6sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d000016A7sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d000016A8sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d000016C6sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d000016C7sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001696sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000169Csv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000169Dsv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000170Dsv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000170Esv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001649sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000166Esv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001658sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001659sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000165Asv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001676sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001677sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000167Csv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000167Dsv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000167Esv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001600sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001601sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d000016F7sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d000016FDsv*sd*bc*sc*i* tg3
+alias pci:v000014E4d000016FEsv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000167Asv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001672sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000167Bsv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001673sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001674sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000169Asv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000169Bsv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001693sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000167Fsv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001668sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001669sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001678sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001679sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000166Asv*sd*bc*sc*i* tg3
+alias pci:v000014E4d0000166Bsv*sd*bc*sc*i* tg3
+alias pci:v000014E4d000016DDsv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001712sv*sd*bc*sc*i* tg3
+alias pci:v000014E4d00001713sv*sd*bc*sc*i* tg3
+alias pci:v00001148d00004400sv*sd*bc*sc*i* tg3
+alias pci:v00001148d00004500sv*sd*bc*sc*i* tg3
+alias pci:v0000173Bd000003E8sv*sd*bc*sc*i* tg3
+alias pci:v0000173Bd000003E9sv*sd*bc*sc*i* tg3
+alias pci:v0000173Bd000003EBsv*sd*bc*sc*i* tg3
+alias pci:v0000173Bd000003EAsv*sd*bc*sc*i* tg3
+alias pci:v0000106Bd00001645sv*sd*bc*sc*i* tg3
+alias pci:v0000108Ed00001001sv*sd*bc*sc*i* sunhme
+alias pci:v0000108Ed00002BADsv*sd*bc*sc*i* sungem
+alias pci:v0000108Ed00001101sv*sd*bc*sc*i* sungem
+alias pci:v0000106Bd00000021sv*sd*bc*sc*i* sungem
+alias pci:v0000106Bd00000024sv*sd*bc*sc*i* sungem
+alias pci:v0000106Bd00000032sv*sd*bc*sc*i* sungem
+alias pci:v0000106Bd0000004Csv*sd*bc*sc*i* sungem
+alias pci:v0000106Bd00000051sv*sd*bc*sc*i* sungem
+alias pci:v0000106Bd0000006Bsv*sd*bc*sc*i* sungem
+alias pci:v00001186d00001002sv00001186sd00001002bc*sc*i* sundance
+alias pci:v00001186d00001002sv00001186sd00001003bc*sc*i* sundance
+alias pci:v00001186d00001002sv00001186sd00001012bc*sc*i* sundance
+alias pci:v00001186d00001002sv00001186sd00001040bc*sc*i* sundance
+alias pci:v00001186d00001002sv*sd*bc*sc*i* sundance
+alias pci:v000013F0d00000201sv*sd*bc*sc*i* sundance
+alias pci:v000013F0d00000200sv*sd*bc*sc*i* sundance
+alias pci:v00009004d00006915sv*sd*bc*sc*i* starfire
+alias pci:v00001148d00009000sv*sd*bc*sc*i* sky2
+alias pci:v00001148d00009E00sv*sd*bc*sc*i* sky2
+alias pci:v00001186d00004B00sv*sd*bc*sc*i* sky2
+alias pci:v00001186d00004001sv*sd*bc*sc*i* sky2
+alias pci:v00001186d00004B02sv*sd*bc*sc*i* sky2
+alias pci:v00001186d00004B03sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004340sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004341sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004342sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004343sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004344sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004345sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004346sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004347sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004350sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004351sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004352sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004353sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004356sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004360sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004361sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004362sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004363sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004364sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004366sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004367sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004368sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd00004369sv*sd*bc*sc*i* sky2
+alias pci:v000011ABd0000436Asv*sd*bc*sc*i* sky2
+alias pci:v000010B7d00001700sv*sd*bc*sc*i* skge
+alias pci:v000010B7d000080EBsv*sd*bc*sc*i* skge
+alias pci:v00001148d00004300sv*sd*bc*sc*i* skge
+alias pci:v00001148d00004320sv*sd*bc*sc*i* skge
+alias pci:v00001186d00004C00sv*sd*bc*sc*i* skge
+alias pci:v00001186d00004B01sv*sd*bc*sc*i* skge
+alias pci:v000011ABd00004320sv*sd*bc*sc*i* skge
+alias pci:v000011ABd00005005sv*sd*bc*sc*i* skge
+alias pci:v00001371d0000434Esv*sd*bc*sc*i* skge
+alias pci:v00001737d00001064sv*sd*bc*sc*i* skge
+alias pci:v00001737d00001032sv*sd00000015bc*sc*i* skge
+alias pci:v000010B7d00001700sv*sd*bc*sc*i* sk98lin
+alias pci:v000010B7d000080EBsv*sd*bc*sc*i* sk98lin
+alias pci:v00001148d00004300sv*sd*bc*sc*i* sk98lin
+alias pci:v00001148d00004320sv*sd*bc*sc*i* sk98lin
+alias pci:v000011ABd00004320sv*sd*bc*sc*i* sk98lin
+alias pci:v000011ABd00005005sv*sd*bc*sc*i* sk98lin
+alias pci:v00001371d0000434Esv*sd*bc*sc*i* sk98lin
+alias pci:v00001737d00001032sv*sd00000015bc*sc*i* sk98lin
+alias pci:v00001737d00001064sv*sd*bc*sc*i* sk98lin
+alias pci:v00001039d00000900sv*sd*bc*sc*i* sis900
+alias pci:v00001039d00007016sv*sd*bc*sc*i* sis900
+alias pci:v00001039d00000190sv*sd*bc*sc*i* sis190
+alias pci:v00001039d00000191sv*sd*bc*sc*i* sis190
+alias pci:v000010ECd00008129sv*sd*bc*sc*i* r8169
+alias pci:v000010ECd00008136sv*sd*bc*sc*i* r8169
+alias pci:v000010ECd00008167sv*sd*bc*sc*i* r8169
+alias pci:v000010ECd00008168sv*sd*bc*sc*i* r8169
+alias pci:v000010ECd00008169sv*sd*bc*sc*i* r8169
+alias pci:v00001186d00004300sv*sd*bc*sc*i* r8169
+alias pci:v00001259d0000C107sv*sd*bc*sc*i* r8169
+alias pci:v000016ECd00000116sv*sd*bc*sc*i* r8169
+alias pci:v00001737d00001032sv*sd00000024bc*sc*i* r8169
+alias pci:v00001077d00003022sv*sd*bc*sc*i* qla3xxx
+alias pci:v00001077d00003032sv*sd*bc*sc*i* qla3xxx
+alias pci:v00001022d00002001sv*sd*bc*sc*i* pcnet32
+alias pci:v00001022d00002000sv*sd*bc*sc*i* pcnet32
+alias pci:v00001023d00002000sv*sd*bc02sc00i* pcnet32
+alias pci:v0000100Bd00000022sv*sd*bc*sc*i* ns83820
+alias pci:v000010ECd00008029sv*sd*bc*sc*i* ne2k_pci
+alias pci:v00001050d00000940sv*sd*bc*sc*i* ne2k_pci
+alias pci:v000011F6d00001401sv*sd*bc*sc*i* ne2k_pci
+alias pci:v00008E2Ed00003000sv*sd*bc*sc*i* ne2k_pci
+alias pci:v00004A14d00005000sv*sd*bc*sc*i* ne2k_pci
+alias pci:v00001106d00000926sv*sd*bc*sc*i* ne2k_pci
+alias pci:v000010BDd00000E34sv*sd*bc*sc*i* ne2k_pci
+alias pci:v00001050d00005A5Asv*sd*bc*sc*i* ne2k_pci
+alias pci:v000012C3d00000058sv*sd*bc*sc*i* ne2k_pci
+alias pci:v000012C3d00005598sv*sd*bc*sc*i* ne2k_pci
+alias pci:v00008C4Ad00001980sv*sd*bc*sc*i* ne2k_pci
+alias pci:v0000100Bd00000020sv000012D9sd0000000Cbc*sc*i* natsemi
+alias pci:v0000100Bd00000020sv*sd*bc*sc*i* natsemi
+alias pci:v0000103Cd00001030sv*sd*bc*sc*i* hp100
+alias pci:v0000103Cd00001031sv*sd*bc*sc*i* hp100
+alias pci:v0000103Cd00001042sv*sd*bc*sc*i* hp100
+alias pci:v0000103Cd00001040sv*sd*bc*sc*i* hp100
+alias pci:v000011F6d00000112sv*sd*bc*sc*i* hp100
+alias pci:v0000101Ad00000005sv*sd*bc*sc*i* hp100
+alias pci:v00001318d00000911sv*sd*bc*sc*i* hamachi
+alias pci:v000010DEd000001C3sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd00000066sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd000000D6sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd00000086sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd0000008Csv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd000000E6sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd000000DFsv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd00000056sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd00000057sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd00000037sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd00000038sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd00000268sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd00000269sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd00000372sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd00000373sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd000003E5sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd000003E6sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd000003EEsv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd000003EFsv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd00000450sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd00000451sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd00000452sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd00000453sv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd0000054Csv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd0000054Dsv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd0000054Esv*sd*bc*sc*i* forcedeth
+alias pci:v000010DEd0000054Fsv*sd*bc*sc*i* forcedeth
+alias pci:v00001516d00000800sv*sd*bc*sc*i* fealnx
+alias pci:v00001516d00000803sv*sd*bc*sc*i* fealnx
+alias pci:v00001516d00000891sv*sd*bc*sc*i* fealnx
+alias pci:v000010B8d00000005sv00001092sd00000AB4bc*sc*i* epic100
+alias pci:v000010B8d00000005sv*sd*bc*sc*i* epic100
+alias pci:v000010B8d00000006sv*sd*bc02sc00i* epic100
+alias pci:v00008086d000010C0sv*sd*bc*sc*i* e1000e
+alias pci:v00008086d000010C2sv*sd*bc*sc*i* e1000e
+alias pci:v00008086d000010C3sv*sd*bc*sc*i* e1000e
+alias pci:v00008086d000010BDsv*sd*bc*sc*i* e1000e
+alias pci:v00008086d0000294Csv*sd*bc*sc*i* e1000e
+alias pci:v00008086d00001000sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001001sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001004sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001008sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001009sv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000100Csv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000100Dsv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000100Esv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000100Fsv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001010sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001011sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001012sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001013sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001014sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001015sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001016sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001017sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001018sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001019sv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000101Asv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000101Dsv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000101Esv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001026sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001027sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001028sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001049sv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000104Asv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000104Bsv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000104Csv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000104Dsv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000105Esv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000105Fsv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001060sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001075sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001076sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001077sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001078sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001079sv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000107Asv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000107Bsv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000107Csv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000107Dsv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000107Esv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000107Fsv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000108Asv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000108Bsv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000108Csv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001096sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001098sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001099sv*sd*bc*sc*i* e1000
+alias pci:v00008086d0000109Asv*sd*bc*sc*i* e1000
+alias pci:v00008086d000010A4sv*sd*bc*sc*i* e1000
+alias pci:v00008086d000010B5sv*sd*bc*sc*i* e1000
+alias pci:v00008086d000010B9sv*sd*bc*sc*i* e1000
+alias pci:v00008086d000010BAsv*sd*bc*sc*i* e1000
+alias pci:v00008086d000010BBsv*sd*bc*sc*i* e1000
+alias pci:v00008086d000010BCsv*sd*bc*sc*i* e1000
+alias pci:v00008086d000010C4sv*sd*bc*sc*i* e1000
+alias pci:v00008086d000010C5sv*sd*bc*sc*i* e1000
+alias pci:v00008086d00001029sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001030sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001031sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001032sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001033sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001034sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001038sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001039sv*sd*bc02sc00i* e100
+alias pci:v00008086d0000103Asv*sd*bc02sc00i* e100
+alias pci:v00008086d0000103Bsv*sd*bc02sc00i* e100
+alias pci:v00008086d0000103Csv*sd*bc02sc00i* e100
+alias pci:v00008086d0000103Dsv*sd*bc02sc00i* e100
+alias pci:v00008086d0000103Esv*sd*bc02sc00i* e100
+alias pci:v00008086d00001050sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001051sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001052sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001053sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001054sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001055sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001056sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001057sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001059sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001064sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001065sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001066sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001067sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001068sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001069sv*sd*bc02sc00i* e100
+alias pci:v00008086d0000106Asv*sd*bc02sc00i* e100
+alias pci:v00008086d0000106Bsv*sd*bc02sc00i* e100
+alias pci:v00008086d00001091sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001092sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001093sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001094sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001095sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001209sv*sd*bc02sc00i* e100
+alias pci:v00008086d00001229sv*sd*bc02sc00i* e100
+alias pci:v00008086d00002449sv*sd*bc02sc00i* e100
+alias pci:v00008086d00002459sv*sd*bc02sc00i* e100
+alias pci:v00008086d0000245Dsv*sd*bc02sc00i* e100
+alias pci:v00008086d000027DCsv*sd*bc02sc00i* e100
+alias rtnl-link-dummy dummy
+alias pci:v00001186d00004000sv*sd*bc*sc*i* dl2k
+alias pci:v0000114Fd00000003sv*sd*bc*sc*i* dgrs
+alias pci:v0000108Ed0000ABBAsv*sd*bc*sc*i* cassini
+alias pci:v0000100Bd00000035sv*sd*bc*sc*i* cassini
+alias pci:v000014E4d0000164Asv0000103Csd00003101bc*sc*i* bnx2
+alias pci:v000014E4d0000164Asv0000103Csd00003106bc*sc*i* bnx2
+alias pci:v000014E4d0000164Asv*sd*bc*sc*i* bnx2
+alias pci:v000014E4d0000164Csv*sd*bc*sc*i* bnx2
+alias pci:v000014E4d000016AAsv0000103Csd00003102bc*sc*i* bnx2
+alias pci:v000014E4d000016AAsv*sd*bc*sc*i* bnx2
+alias pci:v000014E4d000016ACsv*sd*bc*sc*i* bnx2
+alias pci:v000014E4d00001639sv*sd*bc*sc*i* bnx2
+alias pci:v000014E4d0000163Asv*sd*bc*sc*i* bnx2
+alias pci:v000014E4d00004401sv*sd*bc*sc*i* b44
+alias pci:v000014E4d00004402sv*sd*bc*sc*i* b44
+alias pci:v000014E4d0000170Csv*sd*bc*sc*i* b44
+alias pci:v00001022d00007462sv*sd*bc*sc*i* amd8111e
+alias pci:v000012AEd00000001sv*sd*bc02sc00i* acenic
+alias pci:v000012AEd00000002sv*sd*bc02sc00i* acenic
+alias pci:v000010B7d00000001sv*sd*bc02sc00i* acenic
+alias pci:v00001385d0000620Asv*sd*bc02sc00i* acenic
+alias pci:v00001385d0000630Asv*sd*bc02sc00i* acenic
+alias pci:v00001011d0000001Asv*sd*bc02sc00i* acenic
+alias pci:v000012AEd000000FAsv*sd*bc02sc00i* acenic
+alias pci:v000010A9d00000009sv*sd*bc02sc00i* acenic
+alias pci:v000010ECd00008139sv*sd*bc*sc*i* 8139too
+alias pci:v000010ECd00008138sv*sd*bc*sc*i* 8139too
+alias pci:v00001113d00001211sv*sd*bc*sc*i* 8139too
+alias pci:v00001500d00001360sv*sd*bc*sc*i* 8139too
+alias pci:v00004033d00001360sv*sd*bc*sc*i* 8139too
+alias pci:v00001186d00001300sv*sd*bc*sc*i* 8139too
+alias pci:v00001186d00001340sv*sd*bc*sc*i* 8139too
+alias pci:v000013D1d0000AB06sv*sd*bc*sc*i* 8139too
+alias pci:v00001259d0000A117sv*sd*bc*sc*i* 8139too
+alias pci:v00001259d0000A11Esv*sd*bc*sc*i* 8139too
+alias pci:v000014EAd0000AB06sv*sd*bc*sc*i* 8139too
+alias pci:v000014EAd0000AB07sv*sd*bc*sc*i* 8139too
+alias pci:v000011DBd00001234sv*sd*bc*sc*i* 8139too
+alias pci:v00001432d00009130sv*sd*bc*sc*i* 8139too
+alias pci:v000002ACd00001012sv*sd*bc*sc*i* 8139too
+alias pci:v0000018Ad00000106sv*sd*bc*sc*i* 8139too
+alias pci:v0000126Cd00001211sv*sd*bc*sc*i* 8139too
+alias pci:v00001743d00008139sv*sd*bc*sc*i* 8139too
+alias pci:v0000021Bd00008139sv*sd*bc*sc*i* 8139too
+alias pci:v000010ECd00008129sv*sd*bc*sc*i* 8139too
+alias pci:v*d00008139sv000010ECsd00008139bc*sc*i* 8139too
+alias pci:v*d00008139sv00001186sd00001300bc*sc*i* 8139too
+alias pci:v*d00008139sv000013D1sd0000AB06bc*sc*i* 8139too
+alias pci:v000010ECd00008139sv*sd*bc*sc*i* 8139cp
+alias pci:v00000357d0000000Asv*sd*bc*sc*i* 8139cp
+alias pci:v000010B7d00005900sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00005920sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00005970sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00005950sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00005951sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00005952sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009000sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009001sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009004sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009005sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009006sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d0000900Asv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009050sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009051sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009055sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009058sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d0000905Asv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009200sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009202sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009800sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009805sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00007646sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00005055sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00006055sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00006056sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00005B57sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00005057sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00005157sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00005257sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00006560sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00006562sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00006564sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00004500sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009201sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00001201sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00001202sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009056sv*sd*bc*sc*i* 3c59x
+alias pci:v000010B7d00009210sv*sd*bc*sc*i* 3c59x
+alias pnp:dWEC0517* wbsd
+alias pnp:dWEC0518* wbsd
+alias pci:v00001180d00000822sv00001014sd*bc*sc*i* sdhci
+alias pci:v00001180d00000822sv*sd*bc*sc*i* sdhci
+alias pci:v0000104Cd00008034sv*sd*bc*sc*i* sdhci
+alias pci:v00001524d00000550sv*sd*bc*sc*i* sdhci
+alias pci:v00001524d00000551sv*sd*bc*sc*i* sdhci
+alias pci:v*d*sv*sd*bc08sc05i* sdhci
+alias pci:v0000104Cd00008033sv*sd*bc*sc*i* tifm_7xx1
+alias pci:v0000104Cd0000803Bsv*sd*bc*sc*i* tifm_7xx1
+alias pci:v0000104Cd0000AC8Fsv*sd*bc*sc*i* tifm_7xx1
+alias pci:v00001000d00000030sv*sd*bc*sc*i* mptspi
+alias pci:v00001000d00000040sv*sd*bc*sc*i* mptspi
+alias pci:v00001000d00000050sv*sd*bc*sc*i* mptsas
+alias pci:v00001000d00000054sv*sd*bc*sc*i* mptsas
+alias pci:v00001000d00000056sv*sd*bc*sc*i* mptsas
+alias pci:v00001000d00000058sv*sd*bc*sc*i* mptsas
+alias pci:v00001000d00000062sv*sd*bc*sc*i* mptsas
+alias pci:v00001000d00000621sv*sd*bc*sc*i* mptfc
+alias pci:v00001000d00000624sv*sd*bc*sc*i* mptfc
+alias pci:v00001000d00000622sv*sd*bc*sc*i* mptfc
+alias pci:v00001000d00000628sv*sd*bc*sc*i* mptfc
+alias pci:v00001000d00000626sv*sd*bc*sc*i* mptfc
+alias pci:v00001000d00000642sv*sd*bc*sc*i* mptfc
+alias pci:v00001000d00000640sv*sd*bc*sc*i* mptfc
+alias pci:v00001000d00000646sv*sd*bc*sc*i* mptfc
+alias pci:v00001022d00002082sv*sd*bc*sc*i* geode_aes
+alias pci:v00001022d00002082sv*sd*bc*sc*i* geode_rng
+alias pci:v00001022d00007443sv*sd*bc*sc*i* amd_rng
+alias pci:v00001022d0000746Bsv*sd*bc*sc*i* amd_rng
+alias pci:v00001332d00005415sv00000000sd00000000bc*sc*i* umem
+alias pci:v00001332d00005425sv00000000sd00000000bc*sc*i* umem
+alias pci:v00001332d00006155sv00000000sd00000000bc*sc*i* umem
+alias pci:v00008086d0000B555sv00001332sd00005460bc*sc*i* umem
+alias pci:v0000105Ad00008000sv*sd*bc*sc*i* sx8
+alias pci:v0000105Ad00008002sv*sd*bc*sc*i* sx8
+alias block-major-7-* loop
+alias block-major-2-* floppy
+alias pci:v00001011d00000046sv00000E11sd00004058bc*sc*i* cpqarray
+alias pci:v00001011d00000046sv00000E11sd00004051bc*sc*i* cpqarray
+alias pci:v00001011d00000046sv00000E11sd00004050bc*sc*i* cpqarray
+alias pci:v00001000d00000010sv00000E11sd00004048bc*sc*i* cpqarray
+alias pci:v00001000d00000010sv00000E11sd00004040bc*sc*i* cpqarray
+alias pci:v00000E11d0000AE10sv00000E11sd00004034bc*sc*i* cpqarray
+alias pci:v00000E11d0000AE10sv00000E11sd00004033bc*sc*i* cpqarray
+alias pci:v00000E11d0000AE10sv00000E11sd00004032bc*sc*i* cpqarray
+alias pci:v00000E11d0000AE10sv00000E11sd00004031bc*sc*i* cpqarray
+alias pci:v00000E11d0000AE10sv00000E11sd00004030bc*sc*i* cpqarray
+alias pci:v00000E11d0000B060sv00000E11sd00004070bc*sc*i* cciss
+alias pci:v00000E11d0000B178sv00000E11sd00004080bc*sc*i* cciss
+alias pci:v00000E11d0000B178sv00000E11sd00004082bc*sc*i* cciss
+alias pci:v00000E11d0000B178sv00000E11sd00004083bc*sc*i* cciss
+alias pci:v00000E11d00000046sv00000E11sd00004091bc*sc*i* cciss
+alias pci:v00000E11d00000046sv00000E11sd0000409Abc*sc*i* cciss
+alias pci:v00000E11d00000046sv00000E11sd0000409Bbc*sc*i* cciss
+alias pci:v00000E11d00000046sv00000E11sd0000409Cbc*sc*i* cciss
+alias pci:v00000E11d00000046sv00000E11sd0000409Dbc*sc*i* cciss
+alias pci:v0000103Cd00003220sv0000103Csd00003225bc*sc*i* cciss
+alias pci:v0000103Cd00003230sv0000103Csd00003223bc*sc*i* cciss
+alias pci:v0000103Cd00003230sv0000103Csd00003234bc*sc*i* cciss
+alias pci:v0000103Cd00003230sv0000103Csd00003235bc*sc*i* cciss
+alias pci:v0000103Cd00003238sv0000103Csd00003211bc*sc*i* cciss
+alias pci:v0000103Cd00003238sv0000103Csd00003212bc*sc*i* cciss
+alias pci:v0000103Cd00003238sv0000103Csd00003213bc*sc*i* cciss
+alias pci:v0000103Cd00003238sv0000103Csd00003214bc*sc*i* cciss
+alias pci:v0000103Cd00003238sv0000103Csd00003215bc*sc*i* cciss
+alias pci:v0000103Cd00003230sv0000103Csd00003237bc*sc*i* cciss
+alias pci:v0000103Cd*sv*sd*bc01sc04i* cciss
+alias pci:v00001069d0000B166sv00001069sd*bc*sc*i* DAC960
+alias pci:v00001069d0000BA56sv*sd*bc*sc*i* DAC960
+alias pci:v00001069d00000050sv*sd*bc*sc*i* DAC960
+alias pci:v00001011d00001065sv00001069sd00000020bc*sc*i* DAC960
+alias pci:v00001069d00000010sv*sd*bc*sc*i* DAC960
+alias pci:v00001069d00000002sv*sd*bc*sc*i* DAC960
+alias pci:v00001069d00000001sv*sd*bc*sc*i* DAC960
+alias pci:v00001725d00007174sv*sd*bc01sc06i00* sata_vsc
+alias pci:v00008086d00003200sv*sd*bc01sc06i00* sata_vsc
+alias pci:v00001106d00005337sv*sd*bc*sc*i* sata_via
+alias pci:v00001106d00000591sv*sd*bc*sc*i* sata_via
+alias pci:v00001106d00003149sv*sd*bc*sc*i* sata_via
+alias pci:v00001106d00003249sv*sd*bc*sc*i* sata_via
+alias pci:v00001106d00005287sv*sd*bc*sc*i* sata_via
+alias pci:v00001106d00005372sv*sd*bc*sc*i* sata_via
+alias pci:v00001106d00007372sv*sd*bc*sc*i* sata_via
+alias pci:v000010B9d00005289sv*sd*bc*sc*i* sata_uli
+alias pci:v000010B9d00005287sv*sd*bc*sc*i* sata_uli
+alias pci:v000010B9d00005281sv*sd*bc*sc*i* sata_uli
+alias pci:v0000105Ad00006622sv*sd*bc*sc*i* sata_sx4
+alias pci:v00001166d00000240sv*sd*bc*sc*i* sata_svw
+alias pci:v00001166d00000241sv*sd*bc*sc*i* sata_svw
+alias pci:v00001166d00000242sv*sd*bc*sc*i* sata_svw
+alias pci:v00001166d0000024Asv*sd*bc*sc*i* sata_svw
+alias pci:v00001166d0000024Bsv*sd*bc*sc*i* sata_svw
+alias pci:v00001039d00000180sv*sd*bc*sc*i* sata_sis
+alias pci:v00001039d00000181sv*sd*bc*sc*i* sata_sis
+alias pci:v00001039d00000182sv*sd*bc*sc*i* sata_sis
+alias pci:v00001039d00000183sv*sd*bc*sc*i* sata_sis
+alias pci:v00001039d00001182sv*sd*bc*sc*i* sata_sis
+alias pci:v00001039d00001183sv*sd*bc*sc*i* sata_sis
+alias pci:v00001095d00003124sv*sd*bc*sc*i* sata_sil24
+alias pci:v00008086d00003124sv*sd*bc*sc*i* sata_sil24
+alias pci:v00001095d00003132sv*sd*bc*sc*i* sata_sil24
+alias pci:v00001095d00000242sv*sd*bc*sc*i* sata_sil24
+alias pci:v00001095d00003131sv*sd*bc*sc*i* sata_sil24
+alias pci:v00001095d00003531sv*sd*bc*sc*i* sata_sil24
+alias pci:v00001095d00003112sv*sd*bc*sc*i* sata_sil
+alias pci:v00001095d00000240sv*sd*bc*sc*i* sata_sil
+alias pci:v00001095d00003512sv*sd*bc*sc*i* sata_sil
+alias pci:v00001095d00003114sv*sd*bc*sc*i* sata_sil
+alias pci:v00001002d0000436Esv*sd*bc*sc*i* sata_sil
+alias pci:v00001002d00004379sv*sd*bc*sc*i* sata_sil
+alias pci:v00001002d0000437Asv*sd*bc*sc*i* sata_sil
+alias pci:v000015E9d00002068sv*sd*bc*sc*i* sata_qstor
+alias pci:v0000105Ad00003371sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003373sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003375sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003376sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003570sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003571sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003574sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003577sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003D73sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003D75sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003318sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003319sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003515sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003519sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003D17sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00003D18sv*sd*bc*sc*i* sata_promise
+alias pci:v0000105Ad00006629sv*sd*bc*sc*i* sata_promise
+alias pci:v000010DEd0000008Esv*sd*bc*sc*i* sata_nv
+alias pci:v000010DEd000000E3sv*sd*bc*sc*i* sata_nv
+alias pci:v000010DEd000000EEsv*sd*bc*sc*i* sata_nv
+alias pci:v000010DEd00000054sv*sd*bc*sc*i* sata_nv
+alias pci:v000010DEd00000055sv*sd*bc*sc*i* sata_nv
+alias pci:v000010DEd00000036sv*sd*bc*sc*i* sata_nv
+alias pci:v000010DEd0000003Esv*sd*bc*sc*i* sata_nv
+alias pci:v000010DEd00000266sv*sd*bc*sc*i* sata_nv
+alias pci:v000010DEd00000267sv*sd*bc*sc*i* sata_nv
+alias pci:v000010DEd0000037Esv*sd*bc*sc*i* sata_nv
+alias pci:v000010DEd0000037Fsv*sd*bc*sc*i* sata_nv
+alias pci:v000010DEd000003E7sv*sd*bc*sc*i* sata_nv
+alias pci:v000010DEd000003F6sv*sd*bc*sc*i* sata_nv
+alias pci:v000010DEd000003F7sv*sd*bc*sc*i* sata_nv
+alias pci:v000011ABd00005040sv*sd*bc*sc*i* sata_mv
+alias pci:v000011ABd00005041sv*sd*bc*sc*i* sata_mv
+alias pci:v000011ABd00005080sv*sd*bc*sc*i* sata_mv
+alias pci:v000011ABd00005081sv*sd*bc*sc*i* sata_mv
+alias pci:v000011ABd00006040sv*sd*bc*sc*i* sata_mv
+alias pci:v000011ABd00006041sv*sd*bc*sc*i* sata_mv
+alias pci:v000011ABd00006042sv*sd*bc*sc*i* sata_mv
+alias pci:v000011ABd00006080sv*sd*bc*sc*i* sata_mv
+alias pci:v000011ABd00006081sv*sd*bc*sc*i* sata_mv
+alias pci:v00009005d00000241sv*sd*bc*sc*i* sata_mv
+alias pci:v00009005d00000243sv*sd*bc*sc*i* sata_mv
+alias pci:v00001103d00002310sv*sd*bc*sc*i* sata_mv
+alias pci:v000011ABd00007042sv*sd*bc*sc*i* sata_mv
+alias pci:v000015E9d00001841sv*sd*bc*sc*i* pdc_adma
+alias pci:v00001106d00000571sv*sd*bc*sc*i* pata_via
+alias pci:v00001106d00000581sv*sd*bc*sc*i* pata_via
+alias pci:v00001106d00001571sv*sd*bc*sc*i* pata_via
+alias pci:v00001106d00003164sv*sd*bc*sc*i* pata_via
+alias pci:v00001106d00005324sv*sd*bc*sc*i* pata_via
+alias pci:v00000E11d0000AE33sv*sd*bc*sc*i* pata_triflex
+alias pci:v000010ADd00000105sv*sd*bc*sc*i* pata_sl82c105
+alias pci:v00001039d00005513sv*sd*bc*sc*i* pata_sis
+alias pci:v00001039d00005518sv*sd*bc*sc*i* pata_sis
+alias pci:v00001039d00001180sv*sd*bc*sc*i* pata_sis
+alias pci:v00001095d00000680sv*sd*bc*sc*i* pata_sil680
+alias pci:v00001166d00000211sv*sd*bc*sc*i* pata_serverworks
+alias pci:v00001166d00000212sv*sd*bc*sc*i* pata_serverworks
+alias pci:v00001166d00000213sv*sd*bc*sc*i* pata_serverworks
+alias pci:v00001166d00000217sv*sd*bc*sc*i* pata_serverworks
+alias pci:v00001166d00000214sv*sd*bc*sc*i* pata_serverworks
+alias pci:v0000100Bd00000502sv*sd*bc*sc*i* pata_sc1200
+alias pci:v00001042d00001000sv*sd*bc*sc*i* pata_rz1000
+alias pci:v00001042d00001001sv*sd*bc*sc*i* pata_rz1000
+alias pci:v00001331d00008201sv*sd*bc*sc*i* pata_radisys
+alias pci:v0000105Ad00004D33sv*sd*bc*sc*i* pata_pdc202xx_old
+alias pci:v0000105Ad00004D38sv*sd*bc*sc*i* pata_pdc202xx_old
+alias pci:v0000105Ad00000D38sv*sd*bc*sc*i* pata_pdc202xx_old
+alias pci:v0000105Ad00000D30sv*sd*bc*sc*i* pata_pdc202xx_old
+alias pci:v0000105Ad00004D30sv*sd*bc*sc*i* pata_pdc202xx_old
+alias pci:v0000105Ad00004D68sv*sd*bc*sc*i* pata_pdc2027x
+alias pci:v0000105Ad00004D69sv*sd*bc*sc*i* pata_pdc2027x
+alias pci:v0000105Ad00006268sv*sd*bc*sc*i* pata_pdc2027x
+alias pci:v0000105Ad00006269sv*sd*bc*sc*i* pata_pdc2027x
+alias pci:v0000105Ad00001275sv*sd*bc*sc*i* pata_pdc2027x
+alias pci:v0000105Ad00005275sv*sd*bc*sc*i* pata_pdc2027x
+alias pci:v0000105Ad00007275sv*sd*bc*sc*i* pata_pdc2027x
+alias pci:v00001045d0000D568sv*sd*bc*sc*i* pata_optidma
+alias pci:v00001045d0000C621sv*sd*bc*sc*i* pata_opti
+alias pci:v00001045d0000D568sv*sd*bc*sc*i* pata_opti
+alias pci:v00008086d00001230sv*sd*bc*sc*i* pata_oldpiix
+alias pci:v0000100Bd0000D001sv*sd*bc*sc*i* pata_ns87410
+alias pci:v0000169Cd00000044sv*sd*bc*sc*i* pata_netcell
+alias pci:v00008086d00001234sv*sd*bc*sc*i* pata_mpiix
+alias pci:v000011ABd00006101sv*sd*bc*sc*i* pata_marvell
+alias pci:v000011ABd00006145sv*sd*bc*sc*i* pata_marvell
+alias pci:v0000197Bd00002361sv*sd*bc01sc01i* pata_jmicron
+alias pci:v0000197Bd00002363sv*sd*bc01sc01i* pata_jmicron
+alias pci:v0000197Bd00002365sv*sd*bc01sc01i* pata_jmicron
+alias pci:v0000197Bd00002366sv*sd*bc01sc01i* pata_jmicron
+alias pci:v0000197Bd00002368sv*sd*bc01sc01i* pata_jmicron
+alias pci:v00001283d00008211sv*sd*bc*sc*i* pata_it821x
+alias pci:v00001283d00008212sv*sd*bc*sc*i* pata_it821x
+alias pci:v00001103d00000003sv*sd*bc*sc*i* pata_hpt3x3
+alias pci:v00001103d00000004sv*sd*bc*sc*i* pata_hpt3x2n
+alias pci:v00001103d00000007sv*sd*bc*sc*i* pata_hpt3x2n
+alias pci:v00001103d00000005sv*sd*bc*sc*i* pata_hpt3x2n
+alias pci:v00001103d00000006sv*sd*bc*sc*i* pata_hpt3x2n
+alias pci:v00001103d00000009sv*sd*bc*sc*i* pata_hpt3x2n
+alias pci:v00001103d00000004sv*sd*bc*sc*i* pata_hpt37x
+alias pci:v00001103d00000007sv*sd*bc*sc*i* pata_hpt37x
+alias pci:v00001103d00000005sv*sd*bc*sc*i* pata_hpt37x
+alias pci:v00001103d00000008sv*sd*bc*sc*i* pata_hpt37x
+alias pci:v00001103d00000006sv*sd*bc*sc*i* pata_hpt37x
+alias pci:v00001103d00000004sv*sd*bc*sc*i* pata_hpt366
+alias pci:v00001055d00009130sv*sd*bc*sc*i* pata_efar
+alias pci:v00001080d0000C693sv*sd*bc*sc*i* pata_cypress
+alias pci:v0000100Bd0000002Dsv*sd*bc*sc*i* pata_cs5535
+alias pci:v00001078d00000102sv*sd*bc*sc*i* pata_cs5530
+alias pci:v00001078d00000000sv*sd*bc*sc*i* pata_cs5520
+alias pci:v00001078d00000002sv*sd*bc*sc*i* pata_cs5520
+alias pci:v00001095d00000643sv*sd*bc*sc*i* pata_cmd64x
+alias pci:v00001095d00000646sv*sd*bc*sc*i* pata_cmd64x
+alias pci:v00001095d00000648sv*sd*bc*sc*i* pata_cmd64x
+alias pci:v00001095d00000649sv*sd*bc*sc*i* pata_cmd64x
+alias pci:v00001002d00004349sv*sd*bc*sc*i* pata_atiixp
+alias pci:v00001002d00004369sv*sd*bc*sc*i* pata_atiixp
+alias pci:v00001002d00004376sv*sd*bc*sc*i* pata_atiixp
+alias pci:v00001002d0000438Csv*sd*bc*sc*i* pata_atiixp
+alias pci:v00001002d0000439Csv*sd*bc*sc*i* pata_atiixp
+alias pci:v00001191d00000005sv*sd*bc*sc*i* pata_artop
+alias pci:v00001191d00000006sv*sd*bc*sc*i* pata_artop
+alias pci:v00001191d00000007sv*sd*bc*sc*i* pata_artop
+alias pci:v00001191d00000008sv*sd*bc*sc*i* pata_artop
+alias pci:v00001191d00000009sv*sd*bc*sc*i* pata_artop
+alias pci:v00001022d00007401sv*sd*bc*sc*i* pata_amd
+alias pci:v00001022d00007409sv*sd*bc*sc*i* pata_amd
+alias pci:v00001022d00007411sv*sd*bc*sc*i* pata_amd
+alias pci:v00001022d00007441sv*sd*bc*sc*i* pata_amd
+alias pci:v00001022d00007469sv*sd*bc*sc*i* pata_amd
+alias pci:v000010DEd000001BCsv*sd*bc*sc*i* pata_amd
+alias pci:v000010DEd00000065sv*sd*bc*sc*i* pata_amd
+alias pci:v000010DEd00000085sv*sd*bc*sc*i* pata_amd
+alias pci:v000010DEd000000D5sv*sd*bc*sc*i* pata_amd
+alias pci:v000010DEd000000E5sv*sd*bc*sc*i* pata_amd
+alias pci:v000010DEd00000053sv*sd*bc*sc*i* pata_amd
+alias pci:v000010DEd00000035sv*sd*bc*sc*i* pata_amd
+alias pci:v000010DEd00000265sv*sd*bc*sc*i* pata_amd
+alias pci:v000010DEd0000036Esv*sd*bc*sc*i* pata_amd
+alias pci:v000010DEd000003ECsv*sd*bc*sc*i* pata_amd
+alias pci:v000010DEd00000448sv*sd*bc*sc*i* pata_amd
+alias pci:v000010DEd00000560sv*sd*bc*sc*i* pata_amd
+alias pci:v000010DEd0000056Csv*sd*bc*sc*i* pata_amd
+alias pci:v000010DEd00000759sv*sd*bc*sc*i* pata_amd
+alias pci:v00001022d0000209Asv*sd*bc*sc*i* pata_amd
+alias pci:v000010B9d00005228sv*sd*bc*sc*i* pata_ali
+alias pci:v000010B9d00005229sv*sd*bc*sc*i* pata_ali
+alias pci:v00008086d00007010sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00007111sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00007199sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00007601sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d000084CAsv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00002411sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00002421sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d0000244Asv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d0000244Bsv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d0000248Asv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d0000248Bsv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d000024CAsv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d000024CBsv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d000024DBsv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d0000245Bsv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d000025A2sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d0000266Fsv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d000027DFsv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d0000269Esv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00002850sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d000024D1sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d000024DFsv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d000025A3sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d000025B0sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00002651sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00002652sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00002653sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d000027C0sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d000027C4sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00002680sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00002820sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00002825sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00002828sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00002920sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00002921sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00002926sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d00002928sv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d0000292Dsv*sd*bc*sc*i* ata_piix
+alias pci:v00008086d0000292Esv*sd*bc*sc*i* ata_piix
+alias pci:v00001042d00003020sv*sd*bc*sc*i* ata_generic
+alias pci:v00009412d00006565sv*sd*bc*sc*i* ata_generic
+alias pci:v00001060d00000101sv*sd*bc*sc*i* ata_generic
+alias pci:v00001060d0000886Asv*sd*bc*sc*i* ata_generic
+alias pci:v00001060d0000673Asv*sd*bc*sc*i* ata_generic
+alias pci:v00003388d00008013sv*sd*bc*sc*i* ata_generic
+alias pci:v00001106d00000561sv*sd*bc*sc*i* ata_generic
+alias pci:v00001045d0000C558sv*sd*bc*sc*i* ata_generic
+alias pci:v00001179d00000102sv*sd*bc*sc*i* ata_generic
+alias pci:v00001179d00000103sv*sd*bc*sc*i* ata_generic
+alias pci:v00001179d00000105sv*sd*bc*sc*i* ata_generic
+alias pci:v*d*sv*sd*bc01sc01i* ata_generic
+alias pci:v00008086d00002652sv*sd*bc*sc*i* ahci
+alias pci:v00008086d00002653sv*sd*bc*sc*i* ahci
+alias pci:v00008086d000027C1sv*sd*bc*sc*i* ahci
+alias pci:v00008086d000027C5sv*sd*bc*sc*i* ahci
+alias pci:v00008086d000027C3sv*sd*bc*sc*i* ahci
+alias pci:v000010B9d00005288sv*sd*bc*sc*i* ahci
+alias pci:v00008086d00002681sv*sd*bc*sc*i* ahci
+alias pci:v00008086d00002682sv*sd*bc*sc*i* ahci
+alias pci:v00008086d00002683sv*sd*bc*sc*i* ahci
+alias pci:v00008086d000027C6sv*sd*bc*sc*i* ahci
+alias pci:v00008086d00002821sv*sd*bc*sc*i* ahci
+alias pci:v00008086d00002822sv*sd*bc*sc*i* ahci
+alias pci:v00008086d00002824sv*sd*bc*sc*i* ahci
+alias pci:v00008086d00002829sv*sd*bc*sc*i* ahci
+alias pci:v00008086d0000282Asv*sd*bc*sc*i* ahci
+alias pci:v00008086d00002922sv*sd*bc*sc*i* ahci
+alias pci:v00008086d00002923sv*sd*bc*sc*i* ahci
+alias pci:v00008086d00002924sv*sd*bc*sc*i* ahci
+alias pci:v00008086d00002925sv*sd*bc*sc*i* ahci
+alias pci:v00008086d00002927sv*sd*bc*sc*i* ahci
+alias pci:v00008086d00002929sv*sd*bc*sc*i* ahci
+alias pci:v00008086d0000292Asv*sd*bc*sc*i* ahci
+alias pci:v00008086d0000292Bsv*sd*bc*sc*i* ahci
+alias pci:v00008086d0000292Csv*sd*bc*sc*i* ahci
+alias pci:v00008086d0000292Fsv*sd*bc*sc*i* ahci
+alias pci:v00008086d0000294Dsv*sd*bc*sc*i* ahci
+alias pci:v00008086d0000294Esv*sd*bc*sc*i* ahci
+alias pci:v0000197Bd*sv*sd*bc01sc06i01* ahci
+alias pci:v00001002d00004380sv*sd*bc*sc*i* ahci
+alias pci:v00001002d00004390sv*sd*bc*sc*i* ahci
+alias pci:v00001002d00004391sv*sd*bc*sc*i* ahci
+alias pci:v00001002d00004392sv*sd*bc*sc*i* ahci
+alias pci:v00001002d00004393sv*sd*bc*sc*i* ahci
+alias pci:v00001106d00003349sv*sd*bc*sc*i* ahci
+alias pci:v00001106d00006287sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd0000044Csv*sd*bc*sc*i* ahci
+alias pci:v000010DEd0000044Dsv*sd*bc*sc*i* ahci
+alias pci:v000010DEd0000044Esv*sd*bc*sc*i* ahci
+alias pci:v000010DEd0000044Fsv*sd*bc*sc*i* ahci
+alias pci:v000010DEd0000045Csv*sd*bc*sc*i* ahci
+alias pci:v000010DEd0000045Dsv*sd*bc*sc*i* ahci
+alias pci:v000010DEd0000045Esv*sd*bc*sc*i* ahci
+alias pci:v000010DEd0000045Fsv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000550sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000551sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000552sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000553sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000554sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000555sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000556sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000557sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000558sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000559sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd0000055Asv*sd*bc*sc*i* ahci
+alias pci:v000010DEd0000055Bsv*sd*bc*sc*i* ahci
+alias pci:v000010DEd000007F0sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd000007F1sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd000007F2sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd000007F3sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd000007F4sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd000007F5sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd000007F6sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd000007F7sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd000007F8sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd000007F9sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd000007FAsv*sd*bc*sc*i* ahci
+alias pci:v000010DEd000007FBsv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000AD0sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000AD1sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000AD2sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000AD3sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000AD4sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000AD5sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000AD6sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000AD7sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000AD8sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000AD9sv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000ADAsv*sd*bc*sc*i* ahci
+alias pci:v000010DEd00000ADBsv*sd*bc*sc*i* ahci
+alias pci:v00001039d00001184sv*sd*bc*sc*i* ahci
+alias pci:v00001039d00001185sv*sd*bc*sc*i* ahci
+alias pci:v00001039d00000186sv*sd*bc*sc*i* ahci
+alias pci:v*d*sv*sd*bc01sc06i01* ahci
+alias sha1-generic sha1
+alias des3_ede des
diff -Nurb linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.ccwmap linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.ccwmap
--- linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.ccwmap	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.ccwmap	2007-12-21 13:22:40.000000000 -0500
@@ -0,0 +1 @@
+# ccw module         match_flags cu_type cu_model dev_type dev_model
diff -Nurb linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.dep linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.dep
--- linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.dep	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.dep	2007-12-21 13:22:40.000000000 -0500
@@ -0,0 +1,353 @@
+/lib/modules/2.6.22-prep/kernel/net/sched/sch_htb.ko:
+/lib/modules/2.6.22-prep/kernel/net/sched/cls_fw.ko:
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_tcpudp.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_tcpmss.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_string.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_statistic.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_state.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_sctp.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_realm.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_quota.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_pkttype.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_multiport.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_mark.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_mac.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_limit.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_length.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_helper.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_hashlimit.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_esp.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_dscp.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_dccp.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_conntrack.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_connmark.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_connbytes.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_comment.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_SETXID.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_NOTRACK.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_NFQUEUE.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_NFLOG.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_MARK.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_DSCP.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_CONNMARK.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/xt_CLASSIFY.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko:
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink_queue.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink_log.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko:
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_tftp.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_sip.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_proto_sctp.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_proto_gre.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_pptp.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_proto_gre.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_netlink.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_netbios_ns.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_irc.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_h323.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_ftp.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_amanda.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat_tftp.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_tftp.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat_snmp_basic.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat_sip.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_sip.ko /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat_proto_gre.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat_pptp.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_pptp.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_proto_gre.ko /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat_proto_gre.ko /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat_irc.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_irc.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat_h323.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_h323.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat_ftp.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_ftp.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat_amanda.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack_amanda.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_conntrack_ipv4.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/iptable_raw.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_tables.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/iptable_nat.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_tables.ko /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_conntrack_ipv4.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/iptable_mangle.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_tables.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/iptable_filter.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_tables.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_ttl.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_tos.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_set.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_recent.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_owner.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_iprange.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_ecn.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_ah.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_addrtype.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_ULOG.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_TTL.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_TOS.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_SET.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_SAME.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_REJECT.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_REDIRECT.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_NETMAP.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_MASQUERADE.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/nf_nat.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_LOG.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_ECN.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ipt_CLUSTERIP.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/nf_conntrack.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/nfnetlink.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_tables.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set_portmap.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set_nethash.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set_macipmap.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set_iptree.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set_ipporthash.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set_ipmap.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set_iphash.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_set.ko:
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/ip_queue.ko:
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/arptable_filter.ko: /lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/arp_tables.ko /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/arpt_mangle.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/netfilter/arp_tables.ko: /lib/modules/2.6.22-prep/kernel/net/netfilter/x_tables.ko
+/lib/modules/2.6.22-prep/kernel/net/ipv4/ip_gre.ko:
+/lib/modules/2.6.22-prep/kernel/net/ieee80211/softmac/ieee80211softmac.ko: /lib/modules/2.6.22-prep/kernel/net/ieee80211/ieee80211.ko /lib/modules/2.6.22-prep/kernel/net/ieee80211/ieee80211_crypt.ko
+/lib/modules/2.6.22-prep/kernel/net/ieee80211/ieee80211_crypt_wep.ko: /lib/modules/2.6.22-prep/kernel/net/ieee80211/ieee80211_crypt.ko
+/lib/modules/2.6.22-prep/kernel/net/ieee80211/ieee80211_crypt_tkip.ko: /lib/modules/2.6.22-prep/kernel/net/ieee80211/ieee80211_crypt.ko
+/lib/modules/2.6.22-prep/kernel/net/ieee80211/ieee80211_crypt_ccmp.ko: /lib/modules/2.6.22-prep/kernel/net/ieee80211/ieee80211_crypt.ko
+/lib/modules/2.6.22-prep/kernel/net/ieee80211/ieee80211_crypt.ko:
+/lib/modules/2.6.22-prep/kernel/net/ieee80211/ieee80211.ko: /lib/modules/2.6.22-prep/kernel/net/ieee80211/ieee80211_crypt.ko
+/lib/modules/2.6.22-prep/kernel/net/8021q/8021q.ko:
+/lib/modules/2.6.22-prep/kernel/lib/zlib_deflate/zlib_deflate.ko:
+/lib/modules/2.6.22-prep/kernel/lib/ts_kmp.ko:
+/lib/modules/2.6.22-prep/kernel/lib/ts_fsm.ko:
+/lib/modules/2.6.22-prep/kernel/lib/ts_bm.ko:
+/lib/modules/2.6.22-prep/kernel/lib/libcrc32c.ko:
+/lib/modules/2.6.22-prep/kernel/lib/crc16.ko:
+/lib/modules/2.6.22-prep/kernel/lib/crc-ccitt.ko:
+/lib/modules/2.6.22-prep/kernel/fs/vfat/vfat.ko: /lib/modules/2.6.22-prep/kernel/fs/fat/fat.ko
+/lib/modules/2.6.22-prep/kernel/fs/udf/udf.ko:
+/lib/modules/2.6.22-prep/kernel/fs/nls/nls_utf8.ko:
+/lib/modules/2.6.22-prep/kernel/fs/nls/nls_iso8859-1.ko:
+/lib/modules/2.6.22-prep/kernel/fs/msdos/msdos.ko: /lib/modules/2.6.22-prep/kernel/fs/fat/fat.ko
+/lib/modules/2.6.22-prep/kernel/fs/fat/fat.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/video/output.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/usb/storage/usb-storage.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/usb/host/uhci-hcd.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/usb/host/sl811-hcd.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/usb/host/ohci-hcd.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/usb/host/isp116x-hcd.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/usb/host/ehci-hcd.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/tmscsim.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/sym53c8xx_2/sym53c8xx.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_transport_spi.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/stex.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/st.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/sr_mod.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/sg.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/sd_mod.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_wait_scan.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_transport_spi.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_transport_sas.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_transport_iscsi.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_transport_fc.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_tgt.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/raid_class.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/qla4xxx/qla4xxx.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_transport_iscsi.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/qla2xxx/qla2xxx.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_transport_fc.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/qla1280.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/osst.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/megaraid/megaraid_sas.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/megaraid/megaraid_mm.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/megaraid/megaraid_mbox.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/megaraid/megaraid_mm.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/megaraid.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/libsrp.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_tgt.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/libsas/libsas.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_transport_sas.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/ips.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/ipr.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/initio.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/ide-scsi.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/gdth.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/dc395x.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/ch.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/atp870u.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/arcmsr/arcmsr.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/aic94xx/aic94xx.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/libsas/libsas.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_transport_sas.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/aic7xxx_old.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/aic7xxx/aic7xxx.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_transport_spi.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/aic7xxx/aic79xx.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_transport_spi.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/advansys.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/aacraid/aacraid.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/a100u2w.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/BusLogic.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/3w-xxxx.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/scsi/3w-9xxx.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/yellowfin.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/via-velocity.ko: /lib/modules/2.6.22-prep/kernel/lib/crc-ccitt.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/via-rhine.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/usb/zaurus.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/usb/cdc_ether.ko /lib/modules/2.6.22-prep/kernel/drivers/net/usb/usbnet.ko /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/usb/usbnet.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/usb/rtl8150.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/usb/rndis_host.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/usb/cdc_ether.ko /lib/modules/2.6.22-prep/kernel/drivers/net/usb/usbnet.ko /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/usb/plusb.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/usb/usbnet.ko /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/usb/pegasus.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/usb/net1080.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/usb/usbnet.ko /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/usb/mcs7830.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/usb/usbnet.ko /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/usb/kaweth.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/usb/gl620a.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/usb/usbnet.ko /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/usb/cdc_subset.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/usb/usbnet.ko /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/usb/cdc_ether.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/usb/usbnet.ko /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/usb/catc.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/usb/asix.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/usb/usbnet.ko /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/typhoon.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/tun.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/tulip/winbond-840.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/tulip/uli526x.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/tulip/tulip.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/tulip/dmfe.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/tulip/de4x5.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/tulip/de2104x.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/tlan.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/tg3.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/sunhme.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/sungem_phy.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/sungem.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/sungem_phy.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/sundance.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/starfire.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/sky2.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/skge.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/sk98lin/sk98lin.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/sis900.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/sis190.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/r8169.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/qla3xxx.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/phy/vitesse.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/phy/libphy.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/phy/smsc.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/phy/libphy.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/phy/qsemi.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/phy/libphy.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/phy/marvell.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/phy/libphy.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/phy/lxt.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/phy/libphy.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/phy/libphy.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/phy/fixed.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/phy/libphy.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/phy/davicom.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/phy/libphy.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/phy/cicada.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/phy/libphy.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/phy/broadcom.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/phy/libphy.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/pcnet32.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/ns83820.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/ne2k-pci.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/8390.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/natsemi.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/hp100.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/hamachi.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/forcedeth.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/fealnx.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/eql.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/epic100.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/e1000e/e1000e.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/e1000/e1000.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/e100.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/dummy.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/dl2k.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/dgrs.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/cassini.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/bonding/bonding.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/bnx2.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/b44.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/amd8111e.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/acenic.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/8390.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/net/8139too.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/8139cp.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/net/3c59x.ko: /lib/modules/2.6.22-prep/kernel/drivers/net/mii.ko
+/lib/modules/2.6.22-prep/kernel/drivers/mmc/host/wbsd.ko: /lib/modules/2.6.22-prep/kernel/drivers/mmc/core/mmc_core.ko
+/lib/modules/2.6.22-prep/kernel/drivers/mmc/host/tifm_sd.ko: /lib/modules/2.6.22-prep/kernel/drivers/mmc/core/mmc_core.ko /lib/modules/2.6.22-prep/kernel/drivers/misc/tifm_core.ko
+/lib/modules/2.6.22-prep/kernel/drivers/mmc/host/sdhci.ko: /lib/modules/2.6.22-prep/kernel/drivers/mmc/core/mmc_core.ko
+/lib/modules/2.6.22-prep/kernel/drivers/mmc/core/mmc_core.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/mmc/card/mmc_block.ko: /lib/modules/2.6.22-prep/kernel/drivers/mmc/core/mmc_core.ko
+/lib/modules/2.6.22-prep/kernel/drivers/misc/tifm_core.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/misc/tifm_7xx1.ko: /lib/modules/2.6.22-prep/kernel/drivers/misc/tifm_core.ko
+/lib/modules/2.6.22-prep/kernel/drivers/message/fusion/mptspi.ko: /lib/modules/2.6.22-prep/kernel/drivers/message/fusion/mptscsih.ko /lib/modules/2.6.22-prep/kernel/drivers/message/fusion/mptbase.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_transport_spi.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/message/fusion/mptscsih.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko /lib/modules/2.6.22-prep/kernel/drivers/message/fusion/mptbase.ko
+/lib/modules/2.6.22-prep/kernel/drivers/message/fusion/mptsas.ko: /lib/modules/2.6.22-prep/kernel/drivers/message/fusion/mptscsih.ko /lib/modules/2.6.22-prep/kernel/drivers/message/fusion/mptbase.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_transport_sas.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/message/fusion/mptfc.ko: /lib/modules/2.6.22-prep/kernel/drivers/message/fusion/mptscsih.ko /lib/modules/2.6.22-prep/kernel/drivers/message/fusion/mptbase.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_transport_fc.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/message/fusion/mptctl.ko: /lib/modules/2.6.22-prep/kernel/drivers/message/fusion/mptbase.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/message/fusion/mptbase.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/kvm/kvm.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/kvm/kvm-intel.ko: /lib/modules/2.6.22-prep/kernel/drivers/kvm/kvm.ko
+/lib/modules/2.6.22-prep/kernel/drivers/kvm/kvm-amd.ko: /lib/modules/2.6.22-prep/kernel/drivers/kvm/kvm.ko
+/lib/modules/2.6.22-prep/kernel/drivers/i2c/i2c-core.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/i2c/algos/i2c-algo-bit.ko: /lib/modules/2.6.22-prep/kernel/drivers/i2c/i2c-core.ko
+/lib/modules/2.6.22-prep/kernel/drivers/hwmon/hwmon.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/firmware/edd.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/dma/ioatdma.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/crypto/geode-aes.ko: /lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko /lib/modules/2.6.22-prep/kernel/crypto/blkcipher.ko
+/lib/modules/2.6.22-prep/kernel/drivers/connector/cn.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/char/hw_random/via-rng.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/char/hw_random/geode-rng.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/char/hw_random/amd-rng.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/block/umem.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/block/sx8.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/block/nbd.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/block/loop.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/block/floppy.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/block/cpqarray.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/block/cciss.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/block/aoe/aoe.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/block/DAC960.ko:
+/lib/modules/2.6.22-prep/kernel/drivers/ata/sata_vsc.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/sata_via.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/sata_uli.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/sata_sx4.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/sata_svw.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/sata_sis.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/pata_sis.ko /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/sata_sil24.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/sata_sil.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/sata_qstor.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/sata_promise.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/sata_nv.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/sata_mv.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pdc_adma.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_via.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_triflex.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_sl82c105.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_sis.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_sil680.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_serverworks.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_sc1200.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_rz1000.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_radisys.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_pdc202xx_old.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_pdc2027x.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_optidma.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_opti.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_oldpiix.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_ns87410.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_netcell.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_mpiix.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_marvell.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_jmicron.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_it821x.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_hpt3x3.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_hpt3x2n.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_hpt37x.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_hpt366.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_efar.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_cypress.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_cs5535.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_cs5530.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_cs5520.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_cmd64x.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_atiixp.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_artop.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_amd.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/pata_ali.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko: /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/ata_piix.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/ata_generic.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/drivers/ata/ahci.ko: /lib/modules/2.6.22-prep/kernel/drivers/ata/libata.ko /lib/modules/2.6.22-prep/kernel/drivers/scsi/scsi_mod.ko
+/lib/modules/2.6.22-prep/kernel/crypto/sha1.ko: /lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko
+/lib/modules/2.6.22-prep/kernel/crypto/pcbc.ko: /lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko /lib/modules/2.6.22-prep/kernel/crypto/blkcipher.ko
+/lib/modules/2.6.22-prep/kernel/crypto/michael_mic.ko: /lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko
+/lib/modules/2.6.22-prep/kernel/crypto/md5.ko: /lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko
+/lib/modules/2.6.22-prep/kernel/crypto/hmac.ko: /lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko /lib/modules/2.6.22-prep/kernel/crypto/crypto_hash.ko
+/lib/modules/2.6.22-prep/kernel/crypto/ecb.ko: /lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko /lib/modules/2.6.22-prep/kernel/crypto/blkcipher.ko
+/lib/modules/2.6.22-prep/kernel/crypto/des.ko: /lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko
+/lib/modules/2.6.22-prep/kernel/crypto/deflate.ko: /lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko /lib/modules/2.6.22-prep/kernel/lib/zlib_deflate/zlib_deflate.ko
+/lib/modules/2.6.22-prep/kernel/crypto/cryptomgr.ko: /lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko
+/lib/modules/2.6.22-prep/kernel/crypto/crypto_hash.ko:
+/lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko:
+/lib/modules/2.6.22-prep/kernel/crypto/crc32c.ko: /lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko /lib/modules/2.6.22-prep/kernel/lib/libcrc32c.ko
+/lib/modules/2.6.22-prep/kernel/crypto/cbc.ko: /lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko /lib/modules/2.6.22-prep/kernel/crypto/blkcipher.ko
+/lib/modules/2.6.22-prep/kernel/crypto/blkcipher.ko:
+/lib/modules/2.6.22-prep/kernel/crypto/arc4.ko: /lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko
+/lib/modules/2.6.22-prep/kernel/crypto/aes.ko: /lib/modules/2.6.22-prep/kernel/crypto/crypto_algapi.ko
+/lib/modules/2.6.22-prep/kernel/block/deadline-iosched.ko:
+/lib/modules/2.6.22-prep/kernel/block/as-iosched.ko:
+/lib/modules/2.6.22-prep/kernel/arch/i386/oprofile/oprofile.ko:
+/lib/modules/2.6.22-prep/kernel/arch/i386/kernel/msr.ko:
+/lib/modules/2.6.22-prep/kernel/arch/i386/kernel/cpuid.ko:
diff -Nurb linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.ieee1394map linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.ieee1394map
--- linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.ieee1394map	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.ieee1394map	2007-12-21 13:22:40.000000000 -0500
@@ -0,0 +1 @@
+# ieee1394 module    match_flags vendor_id model_id specifier_id version
diff -Nurb linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.inputmap linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.inputmap
--- linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.inputmap	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.inputmap	2007-12-21 13:22:40.000000000 -0500
@@ -0,0 +1 @@
+# module         matchBits bustype vendor product version evBits keyBits relBits absBits mscBits ledBits sndBits ffBits [swBits] driver_info
diff -Nurb linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.isapnpmap linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.isapnpmap
--- linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.isapnpmap	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.isapnpmap	2007-12-21 13:22:40.000000000 -0500
@@ -0,0 +1,3 @@
+# isapnp module      cardvendor carddevice driver_data vendor     function   ...
+wbsd                 0xffff     0xffff     0x00000000  0xa35c     0x1705    
+wbsd                 0xffff     0xffff     0x00000000  0xa35c     0x1805    
diff -Nurb linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.ofmap linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.ofmap
--- linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.ofmap	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.ofmap	2007-12-21 13:22:40.000000000 -0500
@@ -0,0 +1 @@
+# of module          name                 type                 compatible
diff -Nurb linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.pcimap linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.pcimap
--- linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.pcimap	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.pcimap	2007-12-21 13:22:40.000000000 -0500
@@ -0,0 +1,1400 @@
+# pci module         vendor     device     subvendor  subdevice  class      class_mask driver_data
+uhci-hcd             0xffffffff 0xffffffff 0xffffffff 0xffffffff 0x000c0300 0xffffffff 0x0
+ohci-hcd             0xffffffff 0xffffffff 0xffffffff 0xffffffff 0x000c0310 0xffffffff 0x0
+ehci-hcd             0xffffffff 0xffffffff 0xffffffff 0xffffffff 0x000c0320 0xffffffff 0x0
+tmscsim              0x00001022 0x00002020 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x00000001 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x00000002 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x00000003 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x00000004 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x00000005 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x00000006 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x0000000a 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+sym53c8xx            0x00001000 0x0000000b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x0000000c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x0000000d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x0000000f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x00000010 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x00000012 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x00000013 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x00000020 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x00000021 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sym53c8xx            0x00001000 0x0000008f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+stex                 0x0000105a 0x00008350 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+stex                 0x0000105a 0x0000c350 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+stex                 0x0000105a 0x00004302 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+stex                 0x0000105a 0x0000e350 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+stex                 0x0000105a 0x00007250 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+stex                 0x0000105a 0x00008650 0xffffffff 0x00004600 0x00000000 0x00000000 0x0
+stex                 0x0000105a 0x00008650 0xffffffff 0x00004610 0x00000000 0x00000000 0x0
+stex                 0x0000105a 0x00008650 0xffffffff 0x00008600 0x00000000 0x00000000 0x0
+stex                 0x0000105a 0x00008650 0xffffffff 0x00008601 0x00000000 0x00000000 0x0
+stex                 0x0000105a 0x00008650 0xffffffff 0x00008602 0x00000000 0x00000000 0x0
+stex                 0x0000105a 0x00008650 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla4xxx              0x00001077 0x00004010 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla4xxx              0x00001077 0x00004022 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla4xxx              0x00001077 0x00004032 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla2xxx              0x00001077 0x00002100 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla2xxx              0x00001077 0x00002200 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla2xxx              0x00001077 0x00002300 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla2xxx              0x00001077 0x00002312 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla2xxx              0x00001077 0x00002322 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla2xxx              0x00001077 0x00006312 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla2xxx              0x00001077 0x00006322 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla2xxx              0x00001077 0x00002422 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla2xxx              0x00001077 0x00002432 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla2xxx              0x00001077 0x00005422 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla2xxx              0x00001077 0x00005432 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla1280              0x00001077 0x00001216 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla1280              0x00001077 0x00001020 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla1280              0x00001077 0x00001080 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla1280              0x00001077 0x00001240 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla1280              0x00001077 0x00001280 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla1280              0x00001077 0x00001016 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+megaraid_sas         0x00001000 0x00000411 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+megaraid_sas         0x00001000 0x00000060 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+megaraid_sas         0x00001000 0x00000413 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+megaraid_sas         0x00001028 0x00000015 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+megaraid_mbox        0x00001028 0x0000000e 0x00001028 0x00000123 0x00000000 0x00000000 0x0
+megaraid_mbox        0x00001000 0x00001960 0x00001028 0x00000520 0x00000000 0x00000000 0x0
+megaraid_mbox        0x00001000 0x00001960 0x00001028 0x00000518 0x00000000 0x00000000 0x0
+megaraid_mbox        0x00001000 0x00000407 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+megaraid_mbox        0x00001028 0x0000000f 0x00001028 0x0000014a 0x00000000 0x00000000 0x0
+megaraid_mbox        0x00001028 0x00000013 0x00001028 0x0000016c 0x00000000 0x00000000 0x0
+megaraid_mbox        0x00001028 0x00000013 0x00001028 0x0000016d 0x00000000 0x00000000 0x0
+megaraid_mbox        0x00001028 0x00000013 0x00001028 0x0000016e 0x00000000 0x00000000 0x0
+megaraid_mbox        0x00001028 0x00000013 0x00001028 0x0000016f 0x00000000 0x00000000 0x0
+megaraid_mbox        0x00001028 0x00000013 0x00001028 0x00000170 0x00000000 0x00000000 0x0
+megaraid_mbox        0x00001000 0x00000408 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+megaraid_mbox        0x0000101e 0x00001960 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+megaraid_mbox        0x00001000 0x00001960 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+megaraid_mbox        0x00001000 0x00000409 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+megaraid             0x0000101e 0x00009010 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+megaraid             0x0000101e 0x00009060 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+megaraid             0x00008086 0x00001960 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ips                  0x00001014 0x0000002e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ips                  0x00001014 0x000001bd 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ips                  0x00009005 0x00000250 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ipr                  0x00001069 0x0000b166 0x00001014 0x00000266 0x00000000 0x00000000 0x0
+ipr                  0x00001069 0x0000b166 0x00001014 0x00000278 0x00000000 0x00000000 0x0
+ipr                  0x00001069 0x0000b166 0x00001014 0x000002d4 0x00000000 0x00000000 0x0
+ipr                  0x00001069 0x0000b166 0x00001014 0x000002d3 0x00000000 0x00000000 0x0
+ipr                  0x00001014 0x0000028c 0x00001014 0x000002be 0x00000000 0x00000000 0x0
+ipr                  0x00001014 0x0000028c 0x00001014 0x0000028d 0x00000000 0x00000000 0x0
+ipr                  0x00001014 0x0000028c 0x00001014 0x000002c0 0x00000000 0x00000000 0x0
+ipr                  0x00001014 0x0000028c 0x00001014 0x0000030d 0x00000000 0x00000000 0x0
+ipr                  0x00009005 0x00000500 0x00001014 0x000002c1 0x00000000 0x00000000 0x0
+ipr                  0x00009005 0x00000500 0x00001014 0x000002c2 0x00000000 0x00000000 0x0
+ipr                  0x00009005 0x00000500 0x00001014 0x00000338 0x00000000 0x00000000 0x0
+ipr                  0x00001014 0x000002bd 0x00001014 0x000002c1 0x00000000 0x00000000 0x0
+ipr                  0x00001014 0x000002bd 0x00001014 0x000002c2 0x00000000 0x00000000 0x0
+ipr                  0x00001014 0x000002bd 0x00001014 0x00000338 0x00000000 0x00000000 0x0
+ipr                  0x00001014 0x00000339 0x00001014 0x0000030a 0x00000000 0x00000000 0x0
+ipr                  0x00001014 0x00000339 0x00001014 0x0000033e 0x00000000 0x00000000 0x0
+ipr                  0x00001014 0x00000339 0x00001014 0x0000033a 0x00000000 0x00000000 0x0
+ipr                  0x00001014 0x00000339 0x00001014 0x00000360 0x00000000 0x00000000 0x0
+ipr                  0x00001014 0x00000180 0x00001014 0x00000264 0x00000000 0x00000000 0x0
+ipr                  0x00009005 0x00000503 0x00001014 0x000002bf 0x00000000 0x00000000 0x0
+ipr                  0x00009005 0x00000503 0x00001014 0x000002d5 0x00000000 0x00000000 0x0
+ipr                  0x00009005 0x00000503 0x00001014 0x000002c3 0x00000000 0x00000000 0x0
+ipr                  0x00001014 0x0000034a 0x00001014 0x0000030b 0x00000000 0x00000000 0x0
+initio               0x00001101 0x00009500 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+initio               0x00001101 0x00009400 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+initio               0x00001101 0x00009401 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+initio               0x00001101 0x00000002 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+initio               0x0000134a 0x00000002 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+gdth                 0x00001119 0xffffffff 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+gdth                 0x00008086 0x00000600 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+gdth                 0x00008086 0x00000601 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+dc395x               0x00001de1 0x00000391 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+atp870u              0x00001191 0x0000808a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+atp870u              0x00001191 0x00008080 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+atp870u              0x00001191 0x00008081 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+atp870u              0x00001191 0x00008002 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+atp870u              0x00001191 0x00008010 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+atp870u              0x00001191 0x00008020 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+atp870u              0x00001191 0x00008030 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+atp870u              0x00001191 0x00008040 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+atp870u              0x00001191 0x00008050 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+atp870u              0x00001191 0x00008060 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001110 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001120 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001130 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001160 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001170 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001210 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001220 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001230 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001260 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001270 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001280 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001380 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001381 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001680 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+arcmsr               0x000017d3 0x00001681 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+aic94xx              0x00009005 0x00000410 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+aic94xx              0x00009005 0x00000412 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+aic94xx              0x00009005 0x0000041e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+aic94xx              0x00009005 0x0000041f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+aic94xx              0x00009005 0x00000430 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+aic94xx              0x00009005 0x00000432 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+aic94xx              0x00009005 0x0000043e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+aic94xx              0x00009005 0x0000043f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+aic7xxx              0x00009004 0x00005078 0x00009004 0x00007850 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00003860 0x00009004 0x00003869 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00006075 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00006178 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00002178 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00006038 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00007178 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00007278 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00007378 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00007478 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00007578 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00007678 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00008178 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00008278 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00008478 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00008578 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00008378 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00008678 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00008878 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00008778 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00000078 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000011 0x00009005 0x00000181 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000010 0x00009005 0x0000a100 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000010 0x00009005 0x00002180 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000010 0x00009005 0x0000a180 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000010 0x00009005 0x0000e100 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000010 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000011 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000012 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000013 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000014 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000015 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000016 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000017 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000018 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000019 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000001a 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000001b 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000001c 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000001d 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000001e 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000001f 0x00009005 0x0000000f 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000013 0x00009005 0x00000003 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000080 0x00009005 0x0000e2a0 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000080 0x00000e11 0x0000e2a0 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000080 0x00009005 0x000062a0 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000080 0x00009005 0x00006220 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000080 0x00009005 0x0000e220 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000081 0x00009005 0x000062a1 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000083 0x00009005 0x0000ffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00007895 0x00009004 0x00007891 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00007895 0x00009004 0x00007892 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00007895 0x00009004 0x00007894 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00007890 0x00009004 0x00007893 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000050 0x00009005 0x0000ffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000050 0x00009005 0x0000f500 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000051 0x00009005 0x0000ffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000051 0x00009005 0x0000b500 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000053 0x00009005 0x0000ffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000c0 0x00009005 0x0000f620 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000c0 0x00000e11 0x0000f620 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000c3 0x00009005 0x0000ffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00005078 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00005578 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00003860 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00006078 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00007078 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00008078 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000010 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000011 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000012 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000013 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000014 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000015 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000016 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000017 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000018 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000019 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000001a 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000001b 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000001c 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000001d 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000001e 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000001f 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000080 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000081 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000082 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000083 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000084 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000085 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000086 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000087 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000088 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000089 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000008a 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000008b 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000008c 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000008d 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000008e 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000008f 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00007895 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000050 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000051 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000052 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000053 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000054 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000055 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000056 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000057 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000058 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x00000059 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000005a 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000005b 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000005c 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000005d 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000005e 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x0000005f 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000c0 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000c1 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000c2 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000c3 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000c4 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000c5 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000c6 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000c7 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000c8 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000c9 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000ca 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000cb 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000cc 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000cd 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000ce 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009005 0x000000cf 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00001078 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic7xxx              0x00009004 0x00007815 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008000 0x00009005 0x00000060 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008000 0x00009005 0x00000060 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008080 0x00009005 0x00000060 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008080 0x00009005 0x00000060 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008017 0x00009005 0x00000044 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008017 0x00009005 0x00000044 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008097 0x00009005 0x00000044 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008097 0x00009005 0x00000044 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008017 0x00009005 0x00000045 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008017 0x00009005 0x00000045 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008097 0x00009005 0x00000045 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008097 0x00009005 0x00000045 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008012 0x00009005 0x00000042 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008012 0x00009005 0x00000042 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008092 0x00009005 0x00000042 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008092 0x00009005 0x00000042 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008013 0x00009005 0x00000043 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008013 0x00009005 0x00000043 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008093 0x00009005 0x00000043 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008093 0x00009005 0x00000043 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008014 0x00009005 0x00000044 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008014 0x00009005 0x00000044 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008094 0x00009005 0x00000044 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008094 0x00009005 0x00000044 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008010 0x00009005 0x00000040 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008010 0x00009005 0x00000040 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008090 0x00009005 0x00000040 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008090 0x00009005 0x00000040 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008015 0x00009005 0x00000040 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008015 0x00009005 0x00000040 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008095 0x00009005 0x00000040 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008095 0x00009005 0x00000040 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008016 0x00009005 0x00000040 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008016 0x00009005 0x00000040 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008096 0x00009005 0x00000040 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008096 0x00009005 0x00000040 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008011 0x00009005 0x00000041 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008011 0x00009005 0x00000041 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008091 0x00009005 0x00000041 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008091 0x00009005 0x00000041 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008011 0x00000e11 0x000000ac 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008011 0x00000e11 0x000000ac 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008091 0x00000e11 0x000000ac 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008091 0x00000e11 0x000000ac 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801c 0x00009005 0x00000041 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801c 0x00009005 0x00000041 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809c 0x00009005 0x00000041 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809c 0x00009005 0x00000041 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801c 0x00000e11 0x000000ac 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801c 0x00000e11 0x000000ac 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809c 0x00000e11 0x000000ac 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809c 0x00000e11 0x000000ac 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008000 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008000 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008080 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008080 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008001 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008001 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008081 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008081 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008002 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008002 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008082 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008082 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008003 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008003 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008083 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008083 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008004 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008004 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008084 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008084 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008005 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008005 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008085 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008085 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008006 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008006 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008086 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008086 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008007 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008007 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008087 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008087 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008008 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008008 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008088 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008088 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008009 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008009 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008089 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008089 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000800a 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000800a 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000808a 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000808a 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000800b 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000800b 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000808b 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000808b 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000800c 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000800c 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000808c 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000808c 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000800d 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000800d 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000808d 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000808d 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000800e 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000800e 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000808e 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000808e 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000800f 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000800f 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000808f 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000808f 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801e 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801e 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809e 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809e 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008010 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008010 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008090 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008090 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008011 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008011 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008091 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008091 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008012 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008012 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008092 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008092 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008013 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008013 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008093 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008093 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008014 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008014 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008094 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008094 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008015 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008015 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008095 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008095 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008016 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008016 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008096 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008096 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008017 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008017 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008097 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008097 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008018 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008018 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008098 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008098 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008019 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008019 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008099 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x00008099 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801a 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801a 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809a 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809a 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801b 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801b 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809b 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809b 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801c 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801c 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809c 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809c 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801d 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801d 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809d 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809d 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801e 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801e 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809e 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809e 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801f 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000801f 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809f 0xffffffff 0xffffffff 0x00010000 0x00ffff00 0x0
+aic79xx              0x00009005 0x0000809f 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+advansys             0x000010cd 0x00001100 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+advansys             0x000010cd 0x00001200 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+advansys             0x000010cd 0x00001300 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+advansys             0x000010cd 0x00002300 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+advansys             0x000010cd 0x00002500 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+advansys             0x000010cd 0x00002700 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+aacraid              0x00001028 0x00000001 0x00001028 0x00000001 0x00000000 0x00000000 0x0
+aacraid              0x00001028 0x00000002 0x00001028 0x00000002 0x00000000 0x00000000 0x0
+aacraid              0x00001028 0x00000003 0x00001028 0x00000003 0x00000000 0x00000000 0x0
+aacraid              0x00001028 0x00000004 0x00001028 0x000000d0 0x00000000 0x00000000 0x0
+aacraid              0x00001028 0x00000002 0x00001028 0x000000d1 0x00000000 0x00000000 0x0
+aacraid              0x00001028 0x00000002 0x00001028 0x000000d9 0x00000000 0x00000000 0x0
+aacraid              0x00001028 0x0000000a 0x00001028 0x00000106 0x00000000 0x00000000 0x0
+aacraid              0x00001028 0x0000000a 0x00001028 0x0000011b 0x00000000 0x00000000 0x0
+aacraid              0x00001028 0x0000000a 0x00001028 0x00000121 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000283 0x00009005 0x00000283 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000284 0x00009005 0x00000284 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x00000286 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x00000285 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x00000287 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x000017aa 0x00000286 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x000017aa 0x00000287 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x00000288 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x00000289 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x0000028a 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x0000028b 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00009005 0x0000028c 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00009005 0x0000028d 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00009005 0x0000029b 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00009005 0x0000029c 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00009005 0x0000029d 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00009005 0x0000029e 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00009005 0x0000029f 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00009005 0x000002a0 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00009005 0x000002a1 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00009005 0x000002a3 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x000002a4 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x000002a5 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00009005 0x000002a6 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000287 0x00009005 0x00000800 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000200 0x00009005 0x00000200 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00009005 0x00000800 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x0000028e 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x0000028f 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x00000290 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00001028 0x00000291 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x00000292 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x00000293 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x00000294 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x0000103c 0x00003227 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x00000296 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x00000297 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00001014 0x000002f2 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00001014 0x00000312 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00001014 0x00009580 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00001014 0x00009540 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x00000298 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x00000299 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00009005 0x0000029a 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0x00009005 0x000002a2 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00001028 0x00000287 0x00000000 0x00000000 0x0
+aacraid              0x00001011 0x00000046 0x00009005 0x00000365 0x00000000 0x00000000 0x0
+aacraid              0x00001011 0x00000046 0x00009005 0x00000364 0x00000000 0x00000000 0x0
+aacraid              0x00001011 0x00000046 0x00009005 0x00001364 0x00000000 0x00000000 0x0
+aacraid              0x00001011 0x00000046 0x0000103c 0x000010c2 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x00001028 0xffffffff 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0x000017aa 0xffffffff 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000285 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000286 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+aacraid              0x00009005 0x00000288 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+a100u2w              0x00001101 0x00001060 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+BusLogic             0x0000104b 0x00001040 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+BusLogic             0x0000104b 0x00000140 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+BusLogic             0x0000104b 0x00008130 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3w-xxxx              0x000013c1 0x00001000 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3w-xxxx              0x000013c1 0x00001001 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3w-9xxx              0x000013c1 0x00001002 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3w-9xxx              0x000013c1 0x00001003 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3w-9xxx              0x000013c1 0x00001004 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+yellowfin            0x00001000 0x00000702 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+yellowfin            0x00001000 0x00000701 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+via-velocity         0x00001106 0x00003119 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+via-rhine            0x00001106 0x00003043 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+via-rhine            0x00001106 0x00003065 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+via-rhine            0x00001106 0x00003106 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+via-rhine            0x00001106 0x00003053 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+typhoon              0x000010b7 0x00009900 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+typhoon              0x000010b7 0x00009902 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+typhoon              0x000010b7 0x00009903 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+typhoon              0x000010b7 0x00009904 0xffffffff 0x00001000 0x00000000 0x00000000 0x0
+typhoon              0x000010b7 0x00009904 0xffffffff 0x00001102 0x00000000 0x00000000 0x0
+typhoon              0x000010b7 0x00009904 0xffffffff 0x00002000 0x00000000 0x00000000 0x0
+typhoon              0x000010b7 0x00009905 0xffffffff 0x00001101 0x00000000 0x00000000 0x0
+typhoon              0x000010b7 0x00009905 0xffffffff 0x00001102 0x00000000 0x00000000 0x0
+typhoon              0x000010b7 0x00009905 0xffffffff 0x00002101 0x00000000 0x00000000 0x0
+typhoon              0x000010b7 0x00009905 0xffffffff 0x00002102 0x00000000 0x00000000 0x0
+typhoon              0x000010b7 0x00009908 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+typhoon              0x000010b7 0x00009909 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+typhoon              0x000010b7 0x0000990a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+winbond-840          0x00001050 0x00000840 0xffffffff 0x00008153 0x00000000 0x00000000 0x0
+winbond-840          0x00001050 0x00000840 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+winbond-840          0x000011f6 0x00002011 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+uli526x              0x000010b9 0x00005261 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+uli526x              0x000010b9 0x00005263 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001011 0x00000009 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001011 0x00000019 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x000011ad 0x00000002 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x000010d9 0x00000512 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x000010d9 0x00000531 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x0000125b 0x00001400 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x000011ad 0x0000c115 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001317 0x00000981 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001317 0x00000985 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001317 0x00001985 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001317 0x00009511 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x000013d1 0x0000ab02 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x000013d1 0x0000ab03 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x000013d1 0x0000ab08 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x0000104a 0x00000981 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x0000104a 0x00002774 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001259 0x0000a120 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x000011f6 0x00009881 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00008086 0x00000039 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001282 0x00009100 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001282 0x00009102 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001113 0x00001216 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001113 0x00001217 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001113 0x00009511 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001186 0x00001541 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001186 0x00001561 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001186 0x00001591 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x000014f1 0x00001803 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001626 0x00008410 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001737 0x0000ab09 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001737 0x0000ab08 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x000017b3 0x0000ab08 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x000010b7 0x00009300 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x000014ea 0x0000ab08 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tulip                0x00001414 0x00000002 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+dmfe                 0x00001282 0x00009132 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+dmfe                 0x00001282 0x00009102 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+dmfe                 0x00001282 0x00009100 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+dmfe                 0x00001282 0x00009009 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+de2104x              0x00001011 0x00000002 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+de2104x              0x00001011 0x00000014 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tlan                 0x00000e11 0x0000ae34 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tlan                 0x00000e11 0x0000ae32 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tlan                 0x00000e11 0x0000ae35 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tlan                 0x00000e11 0x0000f130 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tlan                 0x00000e11 0x0000f150 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tlan                 0x00000e11 0x0000ae43 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tlan                 0x00000e11 0x0000ae40 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tlan                 0x00000e11 0x0000b011 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tlan                 0x0000108d 0x00000013 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tlan                 0x0000108d 0x00000012 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tlan                 0x0000108d 0x00000014 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tlan                 0x00000e11 0x0000b030 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tlan                 0x00000e11 0x0000b012 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001644 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001645 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001646 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001647 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001648 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000164d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001653 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001654 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000165d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000165e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x000016a6 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x000016a7 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x000016a8 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x000016c6 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x000016c7 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001696 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000169c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000169d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000170d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000170e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001649 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000166e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001658 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001659 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000165a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001676 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001677 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000167c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000167d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000167e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001600 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001601 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x000016f7 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x000016fd 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x000016fe 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000167a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001672 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000167b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001673 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001674 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000169a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000169b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001693 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000167f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001668 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001669 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001678 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001679 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000166a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x0000166b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x000016dd 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001712 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x000014e4 0x00001713 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x00001148 0x00004400 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x00001148 0x00004500 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x0000173b 0x000003e8 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x0000173b 0x000003e9 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x0000173b 0x000003eb 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x0000173b 0x000003ea 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tg3                  0x0000106b 0x00001645 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sunhme               0x0000108e 0x00001001 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sungem               0x0000108e 0x00002bad 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sungem               0x0000108e 0x00001101 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sungem               0x0000106b 0x00000021 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sungem               0x0000106b 0x00000024 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sungem               0x0000106b 0x00000032 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sungem               0x0000106b 0x0000004c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sungem               0x0000106b 0x00000051 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sungem               0x0000106b 0x0000006b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sundance             0x00001186 0x00001002 0x00001186 0x00001002 0x00000000 0x00000000 0x0
+sundance             0x00001186 0x00001002 0x00001186 0x00001003 0x00000000 0x00000000 0x0
+sundance             0x00001186 0x00001002 0x00001186 0x00001012 0x00000000 0x00000000 0x0
+sundance             0x00001186 0x00001002 0x00001186 0x00001040 0x00000000 0x00000000 0x0
+sundance             0x00001186 0x00001002 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sundance             0x000013f0 0x00000201 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sundance             0x000013f0 0x00000200 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+starfire             0x00009004 0x00006915 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x00001148 0x00009000 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x00001148 0x00009e00 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x00001186 0x00004b00 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x00001186 0x00004001 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x00001186 0x00004b02 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x00001186 0x00004b03 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004340 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004341 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004342 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004343 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004344 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004345 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004346 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004347 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004350 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004351 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004352 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004353 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004356 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004360 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004361 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004362 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004363 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004364 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004366 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004367 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004368 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x00004369 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sky2                 0x000011ab 0x0000436a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+skge                 0x000010b7 0x00001700 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+skge                 0x000010b7 0x000080eb 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+skge                 0x00001148 0x00004300 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+skge                 0x00001148 0x00004320 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+skge                 0x00001186 0x00004c00 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+skge                 0x00001186 0x00004b01 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+skge                 0x000011ab 0x00004320 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+skge                 0x000011ab 0x00005005 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+skge                 0x00001371 0x0000434e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+skge                 0x00001737 0x00001064 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+skge                 0x00001737 0x00001032 0xffffffff 0x00000015 0x00000000 0x00000000 0x0
+sk98lin              0x000010b7 0x00001700 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sk98lin              0x000010b7 0x000080eb 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sk98lin              0x00001148 0x00004300 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sk98lin              0x00001148 0x00004320 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sk98lin              0x000011ab 0x00004320 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sk98lin              0x000011ab 0x00005005 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sk98lin              0x00001371 0x0000434e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sk98lin              0x00001737 0x00001032 0xffffffff 0x00000015 0x00000000 0x00000000 0x0
+sk98lin              0x00001737 0x00001064 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sis900               0x00001039 0x00000900 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sis900               0x00001039 0x00007016 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sis190               0x00001039 0x00000190 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sis190               0x00001039 0x00000191 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+r8169                0x000010ec 0x00008129 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+r8169                0x000010ec 0x00008136 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+r8169                0x000010ec 0x00008167 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+r8169                0x000010ec 0x00008168 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+r8169                0x000010ec 0x00008169 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+r8169                0x00001186 0x00004300 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+r8169                0x00001259 0x0000c107 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+r8169                0x000016ec 0x00000116 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+r8169                0x00001737 0x00001032 0xffffffff 0x00000024 0x00000000 0x00000000 0x0
+qla3xxx              0x00001077 0x00003022 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+qla3xxx              0x00001077 0x00003032 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pcnet32              0x00001022 0x00002001 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pcnet32              0x00001022 0x00002000 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pcnet32              0x00001023 0x00002000 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+ns83820              0x0000100b 0x00000022 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ne2k-pci             0x000010ec 0x00008029 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ne2k-pci             0x00001050 0x00000940 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ne2k-pci             0x000011f6 0x00001401 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ne2k-pci             0x00008e2e 0x00003000 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ne2k-pci             0x00004a14 0x00005000 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ne2k-pci             0x00001106 0x00000926 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ne2k-pci             0x000010bd 0x00000e34 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ne2k-pci             0x00001050 0x00005a5a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ne2k-pci             0x000012c3 0x00000058 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ne2k-pci             0x000012c3 0x00005598 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ne2k-pci             0x00008c4a 0x00001980 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+natsemi              0x0000100b 0x00000020 0x000012d9 0x0000000c 0x00000000 0x00000000 0x0
+natsemi              0x0000100b 0x00000020 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+hp100                0x0000103c 0x00001030 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+hp100                0x0000103c 0x00001031 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+hp100                0x0000103c 0x00001042 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+hp100                0x0000103c 0x00001040 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+hp100                0x000011f6 0x00000112 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+hp100                0x0000101a 0x00000005 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+hamachi              0x00001318 0x00000911 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x000001c3 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x00000066 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x000000d6 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x00000086 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x0000008c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x000000e6 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x000000df 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x00000056 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x00000057 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x00000037 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x00000038 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x00000268 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x00000269 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x00000372 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x00000373 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x000003e5 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x000003e6 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x000003ee 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x000003ef 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x00000450 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x00000451 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x00000452 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x00000453 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x0000054c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x0000054d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x0000054e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+forcedeth            0x000010de 0x0000054f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+fealnx               0x00001516 0x00000800 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+fealnx               0x00001516 0x00000803 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+fealnx               0x00001516 0x00000891 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+epic100              0x000010b8 0x00000005 0x00001092 0x00000ab4 0x00000000 0x00000000 0x0
+epic100              0x000010b8 0x00000005 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+epic100              0x000010b8 0x00000006 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e1000e               0x00008086 0x000010c0 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000e               0x00008086 0x000010c2 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000e               0x00008086 0x000010c3 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000e               0x00008086 0x000010bd 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000e               0x00008086 0x0000294c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001000 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001001 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001004 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001008 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001009 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000100c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000100d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000100e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000100f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001010 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001011 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001012 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001013 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001014 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001015 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001016 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001017 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001018 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001019 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000101a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000101d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000101e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001026 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001027 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001028 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001049 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000104a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000104b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000104c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000104d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000105e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000105f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001060 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001075 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001076 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001077 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001078 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001079 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000107a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000107b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000107c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000107d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000107e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000107f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000108a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000108b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000108c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001096 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001098 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x00001099 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x0000109a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x000010a4 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x000010b5 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x000010b9 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x000010ba 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x000010bb 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x000010bc 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x000010c4 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e1000                0x00008086 0x000010c5 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+e100                 0x00008086 0x00001029 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001030 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001031 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001032 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001033 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001034 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001038 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001039 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x0000103a 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x0000103b 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x0000103c 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x0000103d 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x0000103e 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001050 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001051 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001052 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001053 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001054 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001055 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001056 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001057 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001059 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001064 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001065 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001066 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001067 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001068 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001069 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x0000106a 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x0000106b 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001091 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001092 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001093 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001094 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001095 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001209 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00001229 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00002449 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x00002459 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x0000245d 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+e100                 0x00008086 0x000027dc 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+dl2k                 0x00001186 0x00004000 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+dgrs                 0x0000114f 0x00000003 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+cassini              0x0000108e 0x0000abba 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+cassini              0x0000100b 0x00000035 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+bnx2                 0x000014e4 0x0000164a 0x0000103c 0x00003101 0x00000000 0x00000000 0x0
+bnx2                 0x000014e4 0x0000164a 0x0000103c 0x00003106 0x00000000 0x00000000 0x0
+bnx2                 0x000014e4 0x0000164a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+bnx2                 0x000014e4 0x0000164c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+bnx2                 0x000014e4 0x000016aa 0x0000103c 0x00003102 0x00000000 0x00000000 0x0
+bnx2                 0x000014e4 0x000016aa 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+bnx2                 0x000014e4 0x000016ac 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+bnx2                 0x000014e4 0x00001639 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+bnx2                 0x000014e4 0x0000163a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+b44                  0x000014e4 0x00004401 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+b44                  0x000014e4 0x00004402 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+b44                  0x000014e4 0x0000170c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+amd8111e             0x00001022 0x00007462 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+acenic               0x000012ae 0x00000001 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+acenic               0x000012ae 0x00000002 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+acenic               0x000010b7 0x00000001 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+acenic               0x00001385 0x0000620a 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+acenic               0x00001385 0x0000630a 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+acenic               0x00001011 0x0000001a 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+acenic               0x000012ae 0x000000fa 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+acenic               0x000010a9 0x00000009 0xffffffff 0xffffffff 0x00020000 0x00ffff00 0x0
+8139too              0x000010ec 0x00008139 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x000010ec 0x00008138 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x00001113 0x00001211 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x00001500 0x00001360 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x00004033 0x00001360 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x00001186 0x00001300 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x00001186 0x00001340 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x000013d1 0x0000ab06 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x00001259 0x0000a117 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x00001259 0x0000a11e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x000014ea 0x0000ab06 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x000014ea 0x0000ab07 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x000011db 0x00001234 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x00001432 0x00009130 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x000002ac 0x00001012 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x0000018a 0x00000106 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x0000126c 0x00001211 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x00001743 0x00008139 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x0000021b 0x00008139 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0x000010ec 0x00008129 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139too              0xffffffff 0x00008139 0x000010ec 0x00008139 0x00000000 0x00000000 0x0
+8139too              0xffffffff 0x00008139 0x00001186 0x00001300 0x00000000 0x00000000 0x0
+8139too              0xffffffff 0x00008139 0x000013d1 0x0000ab06 0x00000000 0x00000000 0x0
+8139cp               0x000010ec 0x00008139 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+8139cp               0x00000357 0x0000000a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00005900 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00005920 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00005970 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00005950 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00005951 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00005952 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009000 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009001 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009004 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009005 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009006 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x0000900a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009050 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009051 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009055 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009058 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x0000905a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009200 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009202 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009800 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009805 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00007646 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00005055 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00006055 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00006056 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00005b57 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00005057 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00005157 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00005257 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00006560 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00006562 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00006564 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00004500 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009201 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00001201 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00001202 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009056 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+3c59x                0x000010b7 0x00009210 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sdhci                0x00001180 0x00000822 0x00001014 0xffffffff 0x00000000 0x00000000 0x0
+sdhci                0x00001180 0x00000822 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sdhci                0x0000104c 0x00008034 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sdhci                0x00001524 0x00000550 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sdhci                0x00001524 0x00000551 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sdhci                0xffffffff 0xffffffff 0xffffffff 0xffffffff 0x00080500 0x00ffff00 0x0
+tifm_7xx1            0x0000104c 0x00008033 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tifm_7xx1            0x0000104c 0x0000803b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+tifm_7xx1            0x0000104c 0x0000ac8f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptspi               0x00001000 0x00000030 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptspi               0x00001000 0x00000040 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptsas               0x00001000 0x00000050 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptsas               0x00001000 0x00000054 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptsas               0x00001000 0x00000056 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptsas               0x00001000 0x00000058 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptsas               0x00001000 0x00000062 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptfc                0x00001000 0x00000621 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptfc                0x00001000 0x00000624 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptfc                0x00001000 0x00000622 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptfc                0x00001000 0x00000628 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptfc                0x00001000 0x00000626 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptfc                0x00001000 0x00000642 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptfc                0x00001000 0x00000640 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+mptfc                0x00001000 0x00000646 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+geode-aes            0x00001022 0x00002082 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+geode-rng            0x00001022 0x00002082 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+amd-rng              0x00001022 0x00007443 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+amd-rng              0x00001022 0x0000746b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+umem                 0x00001332 0x00005415 0x00000000 0x00000000 0x00000000 0x00000000 0x0
+umem                 0x00001332 0x00005425 0x00000000 0x00000000 0x00000000 0x00000000 0x0
+umem                 0x00001332 0x00006155 0x00000000 0x00000000 0x00000000 0x00000000 0x0
+umem                 0x00008086 0x0000b555 0x00001332 0x00005460 0x00050000 0x00000000 0x0
+sx8                  0x0000105a 0x00008000 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sx8                  0x0000105a 0x00008002 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+cpqarray             0x00001011 0x00000046 0x00000e11 0x00004058 0x00000000 0x00000000 0x0
+cpqarray             0x00001011 0x00000046 0x00000e11 0x00004051 0x00000000 0x00000000 0x0
+cpqarray             0x00001011 0x00000046 0x00000e11 0x00004050 0x00000000 0x00000000 0x0
+cpqarray             0x00001000 0x00000010 0x00000e11 0x00004048 0x00000000 0x00000000 0x0
+cpqarray             0x00001000 0x00000010 0x00000e11 0x00004040 0x00000000 0x00000000 0x0
+cpqarray             0x00000e11 0x0000ae10 0x00000e11 0x00004034 0x00000000 0x00000000 0x0
+cpqarray             0x00000e11 0x0000ae10 0x00000e11 0x00004033 0x00000000 0x00000000 0x0
+cpqarray             0x00000e11 0x0000ae10 0x00000e11 0x00004032 0x00000000 0x00000000 0x0
+cpqarray             0x00000e11 0x0000ae10 0x00000e11 0x00004031 0x00000000 0x00000000 0x0
+cpqarray             0x00000e11 0x0000ae10 0x00000e11 0x00004030 0x00000000 0x00000000 0x0
+cciss                0x00000e11 0x0000b060 0x00000e11 0x00004070 0x00000000 0x00000000 0x0
+cciss                0x00000e11 0x0000b178 0x00000e11 0x00004080 0x00000000 0x00000000 0x0
+cciss                0x00000e11 0x0000b178 0x00000e11 0x00004082 0x00000000 0x00000000 0x0
+cciss                0x00000e11 0x0000b178 0x00000e11 0x00004083 0x00000000 0x00000000 0x0
+cciss                0x00000e11 0x00000046 0x00000e11 0x00004091 0x00000000 0x00000000 0x0
+cciss                0x00000e11 0x00000046 0x00000e11 0x0000409a 0x00000000 0x00000000 0x0
+cciss                0x00000e11 0x00000046 0x00000e11 0x0000409b 0x00000000 0x00000000 0x0
+cciss                0x00000e11 0x00000046 0x00000e11 0x0000409c 0x00000000 0x00000000 0x0
+cciss                0x00000e11 0x00000046 0x00000e11 0x0000409d 0x00000000 0x00000000 0x0
+cciss                0x0000103c 0x00003220 0x0000103c 0x00003225 0x00000000 0x00000000 0x0
+cciss                0x0000103c 0x00003230 0x0000103c 0x00003223 0x00000000 0x00000000 0x0
+cciss                0x0000103c 0x00003230 0x0000103c 0x00003234 0x00000000 0x00000000 0x0
+cciss                0x0000103c 0x00003230 0x0000103c 0x00003235 0x00000000 0x00000000 0x0
+cciss                0x0000103c 0x00003238 0x0000103c 0x00003211 0x00000000 0x00000000 0x0
+cciss                0x0000103c 0x00003238 0x0000103c 0x00003212 0x00000000 0x00000000 0x0
+cciss                0x0000103c 0x00003238 0x0000103c 0x00003213 0x00000000 0x00000000 0x0
+cciss                0x0000103c 0x00003238 0x0000103c 0x00003214 0x00000000 0x00000000 0x0
+cciss                0x0000103c 0x00003238 0x0000103c 0x00003215 0x00000000 0x00000000 0x0
+cciss                0x0000103c 0x00003230 0x0000103c 0x00003237 0x00000000 0x00000000 0x0
+cciss                0x0000103c 0xffffffff 0xffffffff 0xffffffff 0x00010400 0x00ffff00 0x0
+DAC960               0x00001069 0x0000b166 0x00001069 0xffffffff 0x00000000 0x00000000 0x0
+DAC960               0x00001069 0x0000ba56 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+DAC960               0x00001069 0x00000050 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+DAC960               0x00001011 0x00001065 0x00001069 0x00000020 0x00000000 0x00000000 0x0
+DAC960               0x00001069 0x00000010 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+DAC960               0x00001069 0x00000002 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+DAC960               0x00001069 0x00000001 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_vsc             0x00001725 0x00007174 0xffffffff 0xffffffff 0x00010600 0x00ffffff 0x0
+sata_vsc             0x00008086 0x00003200 0xffffffff 0xffffffff 0x00010600 0x00ffffff 0x0
+sata_via             0x00001106 0x00005337 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_via             0x00001106 0x00000591 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_via             0x00001106 0x00003149 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_via             0x00001106 0x00003249 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_via             0x00001106 0x00005287 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_via             0x00001106 0x00005372 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_via             0x00001106 0x00007372 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_uli             0x000010b9 0x00005289 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_uli             0x000010b9 0x00005287 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_uli             0x000010b9 0x00005281 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sx4             0x0000105a 0x00006622 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_svw             0x00001166 0x00000240 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_svw             0x00001166 0x00000241 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_svw             0x00001166 0x00000242 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_svw             0x00001166 0x0000024a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_svw             0x00001166 0x0000024b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sis             0x00001039 0x00000180 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sis             0x00001039 0x00000181 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sis             0x00001039 0x00000182 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sis             0x00001039 0x00000183 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sis             0x00001039 0x00001182 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sis             0x00001039 0x00001183 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sil24           0x00001095 0x00003124 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sil24           0x00008086 0x00003124 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sil24           0x00001095 0x00003132 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sil24           0x00001095 0x00000242 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sil24           0x00001095 0x00003131 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sil24           0x00001095 0x00003531 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sil             0x00001095 0x00003112 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sil             0x00001095 0x00000240 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sil             0x00001095 0x00003512 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sil             0x00001095 0x00003114 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sil             0x00001002 0x0000436e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sil             0x00001002 0x00004379 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_sil             0x00001002 0x0000437a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_qstor           0x000015e9 0x00002068 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003371 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003373 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003375 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003376 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003570 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003571 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003574 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003577 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003d73 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003d75 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003318 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003319 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003515 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003519 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003d17 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00003d18 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_promise         0x0000105a 0x00006629 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_nv              0x000010de 0x0000008e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_nv              0x000010de 0x000000e3 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_nv              0x000010de 0x000000ee 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_nv              0x000010de 0x00000054 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_nv              0x000010de 0x00000055 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_nv              0x000010de 0x00000036 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_nv              0x000010de 0x0000003e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_nv              0x000010de 0x00000266 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_nv              0x000010de 0x00000267 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_nv              0x000010de 0x0000037e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_nv              0x000010de 0x0000037f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_nv              0x000010de 0x000003e7 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_nv              0x000010de 0x000003f6 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_nv              0x000010de 0x000003f7 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_mv              0x000011ab 0x00005040 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_mv              0x000011ab 0x00005041 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_mv              0x000011ab 0x00005080 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_mv              0x000011ab 0x00005081 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_mv              0x000011ab 0x00006040 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_mv              0x000011ab 0x00006041 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_mv              0x000011ab 0x00006042 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_mv              0x000011ab 0x00006080 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_mv              0x000011ab 0x00006081 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_mv              0x00009005 0x00000241 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_mv              0x00009005 0x00000243 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_mv              0x00001103 0x00002310 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+sata_mv              0x000011ab 0x00007042 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pdc_adma             0x000015e9 0x00001841 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_via             0x00001106 0x00000571 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_via             0x00001106 0x00000581 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_via             0x00001106 0x00001571 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_via             0x00001106 0x00003164 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_via             0x00001106 0x00005324 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_triflex         0x00000e11 0x0000ae33 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_sl82c105        0x000010ad 0x00000105 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_sis             0x00001039 0x00005513 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_sis             0x00001039 0x00005518 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_sis             0x00001039 0x00001180 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_sil680          0x00001095 0x00000680 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_serverworks     0x00001166 0x00000211 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_serverworks     0x00001166 0x00000212 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_serverworks     0x00001166 0x00000213 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_serverworks     0x00001166 0x00000217 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_serverworks     0x00001166 0x00000214 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_sc1200          0x0000100b 0x00000502 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_rz1000          0x00001042 0x00001000 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_rz1000          0x00001042 0x00001001 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_radisys         0x00001331 0x00008201 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_pdc202xx_old    0x0000105a 0x00004d33 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_pdc202xx_old    0x0000105a 0x00004d38 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_pdc202xx_old    0x0000105a 0x00000d38 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_pdc202xx_old    0x0000105a 0x00000d30 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_pdc202xx_old    0x0000105a 0x00004d30 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_pdc2027x        0x0000105a 0x00004d68 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_pdc2027x        0x0000105a 0x00004d69 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_pdc2027x        0x0000105a 0x00006268 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_pdc2027x        0x0000105a 0x00006269 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_pdc2027x        0x0000105a 0x00001275 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_pdc2027x        0x0000105a 0x00005275 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_pdc2027x        0x0000105a 0x00007275 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_optidma         0x00001045 0x0000d568 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_opti            0x00001045 0x0000c621 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_opti            0x00001045 0x0000d568 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_oldpiix         0x00008086 0x00001230 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_ns87410         0x0000100b 0x0000d001 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_netcell         0x0000169c 0x00000044 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_mpiix           0x00008086 0x00001234 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_marvell         0x000011ab 0x00006101 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_marvell         0x000011ab 0x00006145 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_jmicron         0x0000197b 0x00002361 0xffffffff 0xffffffff 0x00010100 0x00ffff00 0x0
+pata_jmicron         0x0000197b 0x00002363 0xffffffff 0xffffffff 0x00010100 0x00ffff00 0x0
+pata_jmicron         0x0000197b 0x00002365 0xffffffff 0xffffffff 0x00010100 0x00ffff00 0x0
+pata_jmicron         0x0000197b 0x00002366 0xffffffff 0xffffffff 0x00010100 0x00ffff00 0x0
+pata_jmicron         0x0000197b 0x00002368 0xffffffff 0xffffffff 0x00010100 0x00ffff00 0x0
+pata_it821x          0x00001283 0x00008211 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_it821x          0x00001283 0x00008212 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_hpt3x3          0x00001103 0x00000003 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_hpt3x2n         0x00001103 0x00000004 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_hpt3x2n         0x00001103 0x00000007 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_hpt3x2n         0x00001103 0x00000005 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_hpt3x2n         0x00001103 0x00000006 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_hpt3x2n         0x00001103 0x00000009 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_hpt37x          0x00001103 0x00000004 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_hpt37x          0x00001103 0x00000007 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_hpt37x          0x00001103 0x00000005 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_hpt37x          0x00001103 0x00000008 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_hpt37x          0x00001103 0x00000006 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_hpt366          0x00001103 0x00000004 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_efar            0x00001055 0x00009130 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_cypress         0x00001080 0x0000c693 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_cs5535          0x0000100b 0x0000002d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_cs5530          0x00001078 0x00000102 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_cs5520          0x00001078 0x00000000 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_cs5520          0x00001078 0x00000002 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_cmd64x          0x00001095 0x00000643 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_cmd64x          0x00001095 0x00000646 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_cmd64x          0x00001095 0x00000648 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_cmd64x          0x00001095 0x00000649 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_atiixp          0x00001002 0x00004349 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_atiixp          0x00001002 0x00004369 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_atiixp          0x00001002 0x00004376 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_atiixp          0x00001002 0x0000438c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_atiixp          0x00001002 0x0000439c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_artop           0x00001191 0x00000005 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_artop           0x00001191 0x00000006 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_artop           0x00001191 0x00000007 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_artop           0x00001191 0x00000008 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_artop           0x00001191 0x00000009 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x00001022 0x00007401 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x00001022 0x00007409 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x00001022 0x00007411 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x00001022 0x00007441 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x00001022 0x00007469 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x000010de 0x000001bc 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x000010de 0x00000065 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x000010de 0x00000085 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x000010de 0x000000d5 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x000010de 0x000000e5 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x000010de 0x00000053 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x000010de 0x00000035 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x000010de 0x00000265 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x000010de 0x0000036e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x000010de 0x000003ec 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x000010de 0x00000448 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x000010de 0x00000560 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x000010de 0x0000056c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x000010de 0x00000759 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_amd             0x00001022 0x0000209a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_ali             0x000010b9 0x00005228 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+pata_ali             0x000010b9 0x00005229 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00007010 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00007111 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00007199 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00007601 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x000084ca 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00002411 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00002421 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x0000244a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x0000244b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x0000248a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x0000248b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x000024ca 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x000024cb 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x000024db 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x0000245b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x000025a2 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x0000266f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x000027df 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x0000269e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00002850 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x000024d1 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x000024df 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x000025a3 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x000025b0 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00002651 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00002652 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00002653 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x000027c0 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x000027c4 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00002680 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00002820 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00002825 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00002828 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00002920 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00002921 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00002926 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x00002928 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x0000292d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_piix             0x00008086 0x0000292e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_generic          0x00001042 0x00003020 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_generic          0x00009412 0x00006565 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_generic          0x00001060 0x00000101 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_generic          0x00001060 0x0000886a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_generic          0x00001060 0x0000673a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_generic          0x00003388 0x00008013 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_generic          0x00001106 0x00000561 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_generic          0x00001045 0x0000c558 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_generic          0x00001179 0x00000102 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_generic          0x00001179 0x00000103 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_generic          0x00001179 0x00000105 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ata_generic          0xffffffff 0xffffffff 0xffffffff 0xffffffff 0x00010100 0xffffff00 0x0
+ahci                 0x00008086 0x00002652 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x00002653 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x000027c1 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x000027c5 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x000027c3 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010b9 0x00005288 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x00002681 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x00002682 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x00002683 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x000027c6 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x00002821 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x00002822 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x00002824 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x00002829 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x0000282a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x00002922 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x00002923 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x00002924 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x00002925 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x00002927 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x00002929 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x0000292a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x0000292b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x0000292c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x0000292f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x0000294d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00008086 0x0000294e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x0000197b 0xffffffff 0xffffffff 0xffffffff 0x00010601 0x00ffffff 0x0
+ahci                 0x00001002 0x00004380 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00001002 0x00004390 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00001002 0x00004391 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00001002 0x00004392 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00001002 0x00004393 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00001106 0x00003349 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00001106 0x00006287 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x0000044c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x0000044d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x0000044e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x0000044f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x0000045c 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x0000045d 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x0000045e 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x0000045f 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000550 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000551 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000552 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000553 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000554 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000555 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000556 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000557 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000558 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000559 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x0000055a 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x0000055b 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x000007f0 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x000007f1 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x000007f2 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x000007f3 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x000007f4 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x000007f5 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x000007f6 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x000007f7 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x000007f8 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x000007f9 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x000007fa 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x000007fb 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000ad0 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000ad1 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000ad2 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000ad3 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000ad4 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000ad5 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000ad6 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000ad7 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000ad8 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000ad9 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000ada 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x000010de 0x00000adb 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00001039 0x00001184 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00001039 0x00001185 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0x00001039 0x00000186 0xffffffff 0xffffffff 0x00000000 0x00000000 0x0
+ahci                 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0x00010601 0x00ffffff 0x0
diff -Nurb linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.seriomap linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.seriomap
--- linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.seriomap	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.seriomap	2007-12-21 13:22:40.000000000 -0500
@@ -0,0 +1 @@
+# serio module       type extra id   proto
diff -Nurb linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.symbols linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.symbols
--- linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.symbols	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.symbols	2007-12-21 13:22:40.000000000 -0500
@@ -0,0 +1,817 @@
+# Aliases for symbols, used by symbol_request().
+alias symbol:mpt_deregister mptbase
+alias symbol:i2c_put_adapter i2c_core
+alias symbol:scsi_sense_key_string scsi_mod
+alias symbol:hwmon_device_unregister hwmon
+alias symbol:scsi_execute scsi_mod
+alias symbol:kvm_mmu_free_some_pages kvm
+alias symbol:scsi_get_command scsi_mod
+alias symbol:sas_eh_device_reset_handler libsas
+alias symbol:scsi_target_quiesce scsi_mod
+alias symbol:mpt_free_fw_memory mptbase
+alias symbol:fc_remote_port_add scsi_transport_fc
+alias symbol:sas_release_transport scsi_transport_sas
+alias symbol:mptscsih_scandv_complete mptscsih
+alias symbol:nf_conntrack_expect_related nf_conntrack
+alias symbol:ata_check_status libata
+alias symbol:usbnet_cdc_unbind cdc_ether
+alias symbol:nf_conntrack_expect_chain nf_conntrack
+alias symbol:fc_vport_terminate scsi_transport_fc
+alias symbol:ieee80211_wx_get_encode ieee80211
+alias symbol:ieee80211_wx_set_encode ieee80211
+alias symbol:ata_pci_default_filter libata
+alias symbol:nf_conntrack_l4proto_tcp4 nf_conntrack
+alias symbol:mraid_mm_adapter_app_handle megaraid_mm
+alias symbol:arpt_do_table arp_tables
+alias symbol:sata_scr_write_flush libata
+alias symbol:xt_proto_fini x_tables
+alias symbol:nf_conntrack_expect_alloc nf_conntrack
+alias symbol:ata_host_suspend libata
+alias symbol:scsi_normalize_sense scsi_mod
+alias symbol:scsi_is_sas_rphy scsi_transport_sas
+alias symbol:ieee80211_rx_any ieee80211
+alias symbol:cn_del_callback cn
+alias symbol:mmc_cleanup_queue mmc_block
+alias symbol:ata_port_offline libata
+alias symbol:scsicam_bios_param scsi_mod
+alias symbol:nf_ct_l3proto_put nf_conntrack
+alias symbol:nf_ct_l4proto_put nf_conntrack
+alias symbol:phy_stop_interrupts libphy
+alias symbol:scsi_reset_provider scsi_mod
+alias symbol:sas_phy_add scsi_transport_sas
+alias symbol:ieee80211_channel_to_index ieee80211
+alias symbol:mpt_reset_deregister mptbase
+alias symbol:scsi_extd_sense_format scsi_mod
+alias symbol:ip_set_get_byindex ip_set
+alias symbol:nf_conntrack_expect_list nf_conntrack
+alias symbol:mpt_GetIocState mptbase
+alias symbol:ata_timing_merge libata
+alias symbol:ieee80211softmac_wx_get_genie ieee80211softmac
+alias symbol:ata_host_activate libata
+alias symbol:mptscsih_proc_info mptscsih
+alias symbol:scsi_flush_work scsi_mod
+alias symbol:scsi_host_get scsi_mod
+alias symbol:i2c_master_recv i2c_core
+alias symbol:ata_scsi_slave_destroy libata
+alias symbol:ata_sg_init_one libata
+alias symbol:mmc_wait_for_req mmc_core
+alias symbol:nf_nat_pptp_hook_expectfn nf_conntrack_pptp
+alias symbol:i2c_smbus_write_i2c_block_data i2c_core
+alias symbol:zlib_deflate zlib_deflate
+alias symbol:usbnet_suspend usbnet
+alias symbol:__nf_conntrack_confirm nf_conntrack
+alias symbol:scsi_device_set_state scsi_mod
+alias symbol:scsi_host_get_command scsi_tgt
+alias symbol:mmc_add_host mmc_core
+alias symbol:__scsi_device_lookup_by_target scsi_mod
+alias symbol:usbnet_set_msglevel usbnet
+alias symbol:usbnet_get_msglevel usbnet
+alias symbol:i2c_smbus_write_block_data i2c_core
+alias symbol:nf_ct_unlink_expect nf_conntrack
+alias symbol:ata_std_prereset libata
+alias symbol:sata_scr_read libata
+alias symbol:sas_phy_alloc scsi_transport_sas
+alias symbol:i2c_control i2c_core
+alias symbol:ieee80211softmac_highest_supported_rate ieee80211softmac
+alias symbol:fat_sync_inode fat
+alias symbol:nf_ct_invert_tuple nf_conntrack
+alias symbol:sas_rphy_delete scsi_transport_sas
+alias symbol:fc_get_event_number scsi_transport_fc
+alias symbol:ata_host_detach libata
+alias symbol:save_msrs kvm
+alias symbol:fat_date_unix2dos fat
+alias symbol:ata_bmdma_thaw libata
+alias symbol:phy_enable_interrupts libphy
+alias symbol:scsi_io_completion scsi_mod
+alias symbol:mii_ethtool_sset mii
+alias symbol:mii_ethtool_gset mii
+alias symbol:ip_set_testip_kernel ip_set
+alias symbol:nf_ct_l3proto_module_put nf_conntrack
+alias symbol:ieee80211softmac_wx_set_mlme ieee80211softmac
+alias symbol:kvm_hypercall kvm
+alias symbol:ieee80211_crypt_deinit_handler ieee80211_crypt
+alias symbol:ieee80211softmac_wx_set_genie ieee80211softmac
+alias symbol:scsi_device_lookup_by_target scsi_mod
+alias symbol:set_h225_addr_hook nf_conntrack_h323
+alias symbol:xt_register_table x_tables
+alias symbol:ata_dev_try_classify libata
+alias symbol:scsi_scan_target scsi_mod
+alias symbol:i2c_attach_client i2c_core
+alias symbol:sis_info133_for_sata pata_sis
+alias symbol:usbnet_nway_reset usbnet
+alias symbol:ieee80211softmac_fragment_lost ieee80211softmac
+alias symbol:scsi_is_fc_vport scsi_transport_fc
+alias symbol:alloc_ieee80211softmac ieee80211softmac
+alias symbol:usbnet_resume usbnet
+alias symbol:crypto_check_attr_type crypto_algapi
+alias symbol:nf_ct_l3protos nf_conntrack
+alias symbol:set_cr4 kvm
+alias symbol:ct_sip_get_info nf_conntrack_sip
+alias symbol:ata_wait_ready libata
+alias symbol:tifm_alloc_device tifm_core
+alias symbol:ata_dummy_irq_on libata
+alias symbol:nfattr_parse nfnetlink
+alias symbol:spi_attach_transport scsi_transport_spi
+alias symbol:scsi_logging_level scsi_mod
+alias symbol:nf_nat_need_gre nf_nat_proto_gre
+alias symbol:loop_unregister_transfer loop
+alias symbol:sata_set_spd libata
+alias symbol:mdiobus_register libphy
+alias symbol:usbnet_probe usbnet
+alias symbol:generic_mii_ioctl mii
+alias symbol:scsi_rescan_device scsi_mod
+alias symbol:sas_expander_alloc scsi_transport_sas
+alias symbol:scsi_tgt_queue_command scsi_tgt
+alias symbol:scsi_device_quiesce scsi_mod
+alias symbol:sas_unregister_ha libsas
+alias symbol:sas_read_port_mode_page scsi_transport_sas
+alias symbol:nf_ct_invert_tuplepr nf_conntrack
+alias symbol:sata_deb_timing_long libata
+alias symbol:ip_set_unregister_set_type ip_set
+alias symbol:scsi_is_sdev_device scsi_mod
+alias symbol:ieee80211softmac_notify_gfp ieee80211softmac
+alias symbol:mpt_suspend mptbase
+alias symbol:ata_port_online libata
+alias symbol:i2c_del_adapter i2c_core
+alias symbol:scsi_block_requests scsi_mod
+alias symbol:ata_port_disable libata
+alias symbol:mmc_release_host mmc_core
+alias symbol:sas_end_device_alloc scsi_transport_sas
+alias symbol:fat_dir_empty fat
+alias symbol:ata_cable_sata libata
+alias symbol:ata_sas_queuecmd libata
+alias symbol:print_tuple nf_conntrack
+alias symbol:ata_hsm_move libata
+alias symbol:zlib_deflateEnd zlib_deflate
+alias symbol:ata_bmdma_stop libata
+alias symbol:__scsi_device_lookup scsi_mod
+alias symbol:ieee80211softmac_clear_pending_work ieee80211softmac
+alias symbol:nat_rtp_rtcp_hook nf_conntrack_h323
+alias symbol:ata_std_postreset libata
+alias symbol:spi_release_transport scsi_transport_spi
+alias symbol:i2c_smbus_write_quick i2c_core
+alias symbol:iscsi_alloc_session scsi_transport_iscsi
+alias symbol:nf_conntrack_alter_reply nf_conntrack
+alias symbol:ata_std_ports libata
+alias symbol:i2c_probe i2c_core
+alias symbol:usbnet_get_drvinfo usbnet
+alias symbol:scsi_mode_sense scsi_mod
+alias symbol:scsi_show_sense_hdr scsi_mod
+alias symbol:nf_ct_get_tuple nf_conntrack
+alias symbol:scsi_mode_select scsi_mod
+alias symbol:tifm_map_sg tifm_core
+alias symbol:mii_check_media mii
+alias symbol:ei_open 8390
+alias symbol:ieee80211_is_valid_channel ieee80211
+alias symbol:xt_check_match x_tables
+alias symbol:mmc_wait_for_cmd mmc_core
+alias symbol:nf_ct_l3proto_try_module_get nf_conntrack
+alias symbol:ata_host_start libata
+alias symbol:ata_dev_classify libata
+alias symbol:nf_nat_mangle_udp_packet nf_nat
+alias symbol:i2c_bit_add_numbered_bus i2c_algo_bit
+alias symbol:tifm_queue_work tifm_core
+alias symbol:ata_irq_ack libata
+alias symbol:nf_nat_port_nfattr_to_range nf_nat
+alias symbol:nf_nat_setup_info nf_nat
+alias symbol:ata_do_set_mode libata
+alias symbol:xt_unregister_matches x_tables
+alias symbol:ata_port_freeze libata
+alias symbol:ata_bmdma_start libata
+alias symbol:iscsi_block_session scsi_transport_iscsi
+alias symbol:scsi_test_unit_ready scsi_mod
+alias symbol:scsi_remove_target scsi_mod
+alias symbol:scsi_show_result scsi_mod
+alias symbol:ata_host_register libata
+alias symbol:sas_remove_host scsi_transport_sas
+alias symbol:phy_connect libphy
+alias symbol:ata_dummy_irq_ack libata
+alias symbol:iscsi_unblock_session scsi_transport_iscsi
+alias symbol:nf_conntrack_chain nf_conntrack
+alias symbol:sas_port_add scsi_transport_sas
+alias symbol:xt_table_unlock x_tables
+alias symbol:scsi_ioctl scsi_mod
+alias symbol:scsi_report_device_reset scsi_mod
+alias symbol:scsi_print_sense scsi_mod
+alias symbol:mptscsih_bus_reset mptscsih
+alias symbol:ieee80211_crypt_deinit_entries ieee80211_crypt
+alias symbol:nf_conntrack_l4proto_tcp6 nf_conntrack
+alias symbol:emulate_instruction kvm
+alias symbol:ata_sas_port_alloc libata
+alias symbol:ata_port_abort libata
+alias symbol:mii_check_link mii
+alias symbol:scsi_tgt_alloc_queue scsi_tgt
+alias symbol:scsi_unregister scsi_mod
+alias symbol:scsi_internal_device_unblock scsi_mod
+alias symbol:nf_nat_packet nf_nat
+alias symbol:nf_nat_used_tuple nf_nat
+alias symbol:scsi_host_alloc scsi_mod
+alias symbol:fc_remote_port_delete scsi_transport_fc
+alias symbol:spi_print_msg scsi_transport_spi
+alias symbol:xt_proto_init x_tables
+alias symbol:ata_scsi_change_queue_depth libata
+alias symbol:nf_ct_log_invalid nf_conntrack
+alias symbol:pci_test_config_bits libata
+alias symbol:tifm_alloc_adapter tifm_core
+alias symbol:usbnet_disconnect usbnet
+alias symbol:ieee80211_wx_get_auth ieee80211
+alias symbol:ieee80211_wx_set_auth ieee80211
+alias symbol:nf_conntrack_l4proto_unregister nf_conntrack
+alias symbol:nf_conntrack_l3proto_unregister nf_conntrack
+alias symbol:nf_conntrack_register_cache nf_conntrack
+alias symbol:nf_nat_pptp_hook_inbound nf_conntrack_pptp
+alias symbol:sas_queuecommand libsas
+alias symbol:set_sig_addr_hook nf_conntrack_h323
+alias symbol:sas_phy_reset libsas
+alias symbol:scsi_eh_flush_done_q scsi_mod
+alias symbol:scsi_remove_host scsi_mod
+alias symbol:video_output_register output
+alias symbol:scsi_is_host_device scsi_mod
+alias symbol:ata_noop_dev_select libata
+alias symbol:mmc_register_driver mmc_core
+alias symbol:ieee80211softmac_wx_get_wap ieee80211softmac
+alias symbol:scsi_target_block scsi_mod
+alias symbol:phy_sanitize_settings libphy
+alias symbol:scsilun_to_int scsi_mod
+alias symbol:crc16 crc16
+alias symbol:nf_ct_remove_expectations nf_conntrack
+alias symbol:nfnetlink_unicast nfnetlink
+alias symbol:ata_port_schedule_eh libata
+alias symbol:mmc_claim_host mmc_core
+alias symbol:nf_conntrack_in nf_conntrack
+alias symbol:nf_conntrack_unexpect_related nf_conntrack
+alias symbol:ieee80211_wx_get_scan ieee80211
+alias symbol:ieee80211softmac_wx_get_rate ieee80211softmac
+alias symbol:fat_detach fat
+alias symbol:iscsi_destroy_session scsi_transport_iscsi
+alias symbol:crypto_spawn_tfm crypto_algapi
+alias symbol:ieee80211softmac_scan_finished ieee80211softmac
+alias symbol:mdio_bus_type libphy
+alias symbol:ata_noop_qc_prep libata
+alias symbol:ata_sas_port_start libata
+alias symbol:ata_sg_init libata
+alias symbol:xt_find_match x_tables
+alias symbol:crc_ccitt crc_ccitt
+alias symbol:crypto_init_spawn crypto_algapi
+alias symbol:mptscsih_remove mptscsih
+alias symbol:scsi_scan_host scsi_mod
+alias symbol:fat_notify_change fat
+alias symbol:scsi_track_queue_full scsi_mod
+alias symbol:sas_port_delete_phy scsi_transport_sas
+alias symbol:crc16_table crc16
+alias symbol:phy_driver_unregister libphy
+alias symbol:mpt_device_driver_deregister mptbase
+alias symbol:ieee80211softmac_stop ieee80211softmac
+alias symbol:scsi_set_medium_removal scsi_mod
+alias symbol:sas_port_mark_backlink scsi_transport_sas
+alias symbol:ata_port_queue_task libata
+alias symbol:ata_data_xfer_noirq libata
+alias symbol:sata_deb_timing_hotplug libata
+alias symbol:scsi_device_put scsi_mod
+alias symbol:scsi_device_get scsi_mod
+alias symbol:ieee80211_unregister_crypto_ops ieee80211_crypt
+alias symbol:nf_nat_protocol_register nf_nat
+alias symbol:sas_domain_attach_transport libsas
+alias symbol:ieee80211softmac_wx_set_wap ieee80211softmac
+alias symbol:nf_nat_protocol_unregister nf_nat
+alias symbol:mmc_request_done mmc_core
+alias symbol:crypto_unregister_alg crypto_algapi
+alias symbol:nf_nat_amanda_hook nf_conntrack_amanda
+alias symbol:ieee80211softmac_wx_set_rate ieee80211softmac
+alias symbol:tifm_add_adapter tifm_core
+alias symbol:xt_replace_table x_tables
+alias symbol:sas_task_abort libsas
+alias symbol:ata_eng_timeout libata
+alias symbol:sas_register_ha libsas
+alias symbol:ata_scsi_ioctl libata
+alias symbol:phy_start_interrupts libphy
+alias symbol:ieee80211_get_channel_flags ieee80211
+alias symbol:i2c_bus_type i2c_core
+alias symbol:nf_conntrack_lock nf_conntrack
+alias symbol:ata_dummy_port_info libata
+alias symbol:phy_stop libphy
+alias symbol:ata_device_blacklisted libata
+alias symbol:cn_add_callback cn
+alias symbol:nat_q931_hook nf_conntrack_h323
+alias symbol:nf_nat_mangle_tcp_packet nf_nat
+alias symbol:xt_find_table_lock x_tables
+alias symbol:sas_phy_delete scsi_transport_sas
+alias symbol:sas_phy_free scsi_transport_sas
+alias symbol:mptscsih_info mptscsih
+alias symbol:video_output_unregister output
+alias symbol:xt_unregister_table x_tables
+alias symbol:crc_ccitt_table crc_ccitt
+alias symbol:nf_nat_icmp_reply_translation nf_nat
+alias symbol:ata_bmdma_error_handler libata
+alias symbol:set_cr0 kvm
+alias symbol:scsi_adjust_queue_depth scsi_mod
+alias symbol:__sas_task_abort libsas
+alias symbol:i2c_bit_add_bus i2c_algo_bit
+alias symbol:ata_bmdma_status libata
+alias symbol:per_cpu__nf_conntrack_stat nf_conntrack
+alias symbol:fat_build_inode fat
+alias symbol:kvm_read_guest kvm
+alias symbol:mpt_verify_adapter mptbase
+alias symbol:scsi_remove_device scsi_mod
+alias symbol:nf_conntrack_find_get nf_conntrack
+alias symbol:crypto_unregister_template crypto_algapi
+alias symbol:scsi_free_host_dev scsi_mod
+alias symbol:ata_id_string libata
+alias symbol:i2c_smbus_write_word_data i2c_core
+alias symbol:scsi_complete_async_scans scsi_mod
+alias symbol:ata_tf_read libata
+alias symbol:ata_tf_load libata
+alias symbol:mptscsih_qcmd mptscsih
+alias symbol:mptscsih_is_phys_disk mptscsih
+alias symbol:ata_sff_port_start libata
+alias symbol:ct_sip_lnlen nf_conntrack_sip
+alias symbol:mptscsih_slave_destroy mptscsih
+alias symbol:ipt_unregister_table ip_tables
+alias symbol:xt_unregister_target x_tables
+alias symbol:ata_do_eh libata
+alias symbol:iscsi_create_conn scsi_transport_iscsi
+alias symbol:nf_conntrack_unregister_notifier nf_conntrack
+alias symbol:nf_conntrack_checksum nf_conntrack
+alias symbol:segment_base kvm
+alias symbol:mii_check_gmii_support mii
+alias symbol:ata_wait_register libata
+alias symbol:sl811h_driver sl811_hcd
+alias symbol:fat_attach fat
+alias symbol:ata_scsi_simulate libata
+alias symbol:scsi_tgt_tsk_mgmt_request scsi_tgt
+alias symbol:crc32c_be libcrc32c
+alias symbol:crc32c_le libcrc32c
+alias symbol:scsi_dma_map scsi_mod
+alias symbol:nf_nat_ftp_hook nf_conntrack_ftp
+alias symbol:nf_nat_irc_hook nf_conntrack_irc
+alias symbol:nf_nat_sdp_hook nf_conntrack_sip
+alias symbol:nf_nat_sip_hook nf_conntrack_sip
+alias symbol:scsi_unblock_requests scsi_mod
+alias symbol:nf_ct_deliver_cached_events nf_conntrack
+alias symbol:crypto_register_notifier crypto_algapi
+alias symbol:ata_sas_slave_configure libata
+alias symbol:ata_qc_complete libata
+alias symbol:i2c_master_send i2c_core
+alias symbol:scsi_tgt_free_queue scsi_tgt
+alias symbol:tifm_unregister_driver tifm_core
+alias symbol:genphy_read_status libphy
+alias symbol:set_cr3 kvm
+alias symbol:iscsi_conn_error scsi_transport_iscsi
+alias symbol:nf_conntrack_flush nf_conntrack
+alias symbol:xt_find_revision x_tables
+alias symbol:i2c_check_addr i2c_core
+alias symbol:mpt_event_register mptbase
+alias symbol:nf_conntrack_l3proto_generic nf_conntrack
+alias symbol:ata_sas_port_init libata
+alias symbol:fc_remove_host scsi_transport_fc
+alias symbol:ata_irq_on libata
+alias symbol:iscsi_create_session scsi_transport_iscsi
+alias symbol:iscsi_add_session scsi_transport_iscsi
+alias symbol:kvm_set_msr_common kvm
+alias symbol:kvm_get_msr_common kvm
+alias symbol:i2c_add_adapter i2c_core
+alias symbol:ata_bmdma_irq_clear libata
+alias symbol:mptscsih_bios_param mptscsih
+alias symbol:nf_conntrack_unregister_cache nf_conntrack
+alias symbol:ata_sas_port_stop libata
+alias symbol:i2c_use_client i2c_core
+alias symbol:scsi_print_command scsi_mod
+alias symbol:iscsi_if_destroy_session_done scsi_transport_iscsi
+alias symbol:sas_rphy_remove scsi_transport_sas
+alias symbol:iscsi_unregister_transport scsi_transport_iscsi
+alias symbol:ata_bmdma_drive_eh libata
+alias symbol:ata_qc_complete_multiple libata
+alias symbol:crypto_register_alg crypto_algapi
+alias symbol:mpt_get_msg_frame mptbase
+alias symbol:genphy_config_advert libphy
+alias symbol:__scsi_print_command scsi_mod
+alias symbol:__scsi_put_command scsi_mod
+alias symbol:__scsi_get_command scsi_mod
+alias symbol:mptscsih_taskmgmt_complete mptscsih
+alias symbol:fc_attach_transport scsi_transport_fc
+alias symbol:nf_nat_module_is_loaded nf_conntrack_ipv4
+alias symbol:sata_print_link_status libata
+alias symbol:nf_ct_gre_keymap_add nf_conntrack_proto_gre
+alias symbol:xt_check_target x_tables
+alias symbol:scsi_command_normalize_sense scsi_mod
+alias symbol:nf_conntrack_hash nf_conntrack
+alias symbol:set_h245_addr_hook nf_conntrack_h323
+alias symbol:nf_ct_helper_put nf_conntrack
+alias symbol:__nfa_fill nfnetlink
+alias symbol:sas_port_free scsi_transport_sas
+alias symbol:crypto_dequeue_request crypto_algapi
+alias symbol:crypto_enqueue_request crypto_algapi
+alias symbol:mii_nway_restart mii
+alias symbol:sas_port_alloc_num scsi_transport_sas
+alias symbol:fat_add_entries fat
+alias symbol:mpt_lan_index mptbase
+alias symbol:ata_pio_need_iordy libata
+alias symbol:ipt_register_table ip_tables
+alias symbol:ata_bmdma_freeze libata
+alias symbol:ieee80211_crypt_delayed_deinit ieee80211_crypt
+alias symbol:mpt_proc_root_dir mptbase
+alias symbol:ata_bus_reset libata
+alias symbol:i2c_release_client i2c_core
+alias symbol:spi_display_xfer_agreement scsi_transport_spi
+alias symbol:nf_conntrack_hash_insert nf_conntrack
+alias symbol:nf_nat_pptp_hook_exp_gre nf_conntrack_pptp
+alias symbol:fat_free_clusters fat
+alias symbol:iscsi_recv_pdu scsi_transport_iscsi
+alias symbol:ieee80211_channel_to_freq ieee80211
+alias symbol:ata_bmdma_post_internal_cmd libata
+alias symbol:spi_schedule_dv_device scsi_transport_spi
+alias symbol:gfn_to_page kvm
+alias symbol:ata_port_start libata
+alias symbol:nf_ct_port_tuple_to_nfattr nf_conntrack
+alias symbol:mpt_reset_register mptbase
+alias symbol:nf_conntrack_helper_register nf_conntrack
+alias symbol:mptscsih_timer_expired mptscsih
+alias symbol:sas_port_add_phy scsi_transport_sas
+alias symbol:crypto_blkcipher_type blkcipher
+alias symbol:phy_disable_interrupts libphy
+alias symbol:nf_conntrack_destroyed nf_conntrack
+alias symbol:blkcipher_walk_virt blkcipher
+alias symbol:ata_eh_freeze_port libata
+alias symbol:nf_conntrack_expect_init nf_conntrack
+alias symbol:nf_conntrack_l4proto_udp4 nf_conntrack
+alias symbol:ip_set_get_byname ip_set
+alias symbol:ata_eh_thaw_port libata
+alias symbol:ata_exec_command libata
+alias symbol:nf_conntrack_free nf_conntrack
+alias symbol:sata_std_hardreset libata
+alias symbol:spi_dv_device scsi_transport_spi
+alias symbol:scsi_alloc_sgtable scsi_mod
+alias symbol:crypto_get_attr_alg crypto_algapi
+alias symbol:scsi_queue_work scsi_mod
+alias symbol:mptscsih_TMHandler mptscsih
+alias symbol:nf_ct_l3proto_find_get nf_conntrack
+alias symbol:nf_ct_l4proto_find_get nf_conntrack
+alias symbol:sata_scr_write libata
+alias symbol:ieee80211_wx_get_encodeext ieee80211
+alias symbol:ieee80211_wx_set_encodeext ieee80211
+alias symbol:iscsi_free_session scsi_transport_iscsi
+alias symbol:mptscsih_event_process mptscsih
+alias symbol:mptscsih_resume mptscsih
+alias symbol:xt_request_find_target x_tables
+alias symbol:tifm_free_adapter tifm_core
+alias symbol:kvm_emulator_want_group7_invlpg kvm
+alias symbol:mptscsih_host_reset mptscsih
+alias symbol:fat_get_dotdot_entry fat
+alias symbol:sas_rphy_add scsi_transport_sas
+alias symbol:ata_id_c_string libata
+alias symbol:nf_ct_gre_keymap_destroy nf_conntrack_proto_gre
+alias symbol:nfnetlink_subsys_register nfnetlink
+alias symbol:i2c_register_driver i2c_core
+alias symbol:sata_scr_valid libata
+alias symbol:ip_set_register_set_type ip_set
+alias symbol:phy_ethtool_gset libphy
+alias symbol:phy_ethtool_sset libphy
+alias symbol:ata_host_alloc_pinfo libata
+alias symbol:ata_data_xfer libata
+alias symbol:ata_pci_remove_one libata
+alias symbol:mmc_detect_change mmc_core
+alias symbol:srp_transfer_data libsrp
+alias symbol:i2c_adapter_class i2c_core
+alias symbol:sas_remove_children scsi_transport_sas
+alias symbol:mii_phy_probe sungem_phy
+alias symbol:mpt_alloc_fw_memory mptbase
+alias symbol:i2c_smbus_read_i2c_block_data i2c_core
+alias symbol:ata_bmdma_setup libata
+alias symbol:cn_netlink_send cn
+alias symbol:mpt_print_ioc_summary mptbase
+alias symbol:xt_free_table_info x_tables
+alias symbol:nf_ct_helper_find_get nf_conntrack
+alias symbol:nat_h245_hook nf_conntrack_h323
+alias symbol:scsi_report_bus_reset scsi_mod
+alias symbol:mptscsih_change_queue_depth mptscsih
+alias symbol:ieee80211_get_channel ieee80211
+alias symbol:iscsi_remove_session scsi_transport_iscsi
+alias symbol:usbnet_unlink_rx_urbs usbnet
+alias symbol:scsi_bios_ptable scsi_mod
+alias symbol:phy_read libphy
+alias symbol:zlib_deflate_workspacesize zlib_deflate
+alias symbol:ata_pci_device_do_suspend libata
+alias symbol:mptscsih_shutdown mptscsih
+alias symbol:free_ieee80211 ieee80211
+alias symbol:ata_busy_sleep libata
+alias symbol:fat_search_long fat
+alias symbol:per_cpu__nf_conntrack_ecache nf_conntrack
+alias symbol:genphy_update_link libphy
+alias symbol:xt_alloc_table_info x_tables
+alias symbol:i2c_unregister_device i2c_core
+alias symbol:crypto_lookup_template crypto_algapi
+alias symbol:nf_conntrack_tcp_update nf_conntrack
+alias symbol:scsi_execute_req scsi_mod
+alias symbol:scsi_req_abort_cmd scsi_mod
+alias symbol:scsi_is_fc_rport scsi_transport_fc
+alias symbol:tifm_eject tifm_core
+alias symbol:mmc_start_request mmc_core
+alias symbol:scsi_add_host scsi_mod
+alias symbol:ieee80211_freq_to_channel ieee80211
+alias symbol:ata_pci_device_do_resume libata
+alias symbol:mmc_wait_for_app_cmd mmc_core
+alias symbol:usbnet_get_link usbnet
+alias symbol:scsi_schedule_eh scsi_mod
+alias symbol:fat_alloc_new_dir fat
+alias symbol:i2c_smbus_read_byte_data i2c_core
+alias symbol:scsi_print_sense_hdr scsi_mod
+alias symbol:scsi_host_lookup scsi_mod
+alias symbol:nf_conntrack_max nf_conntrack
+alias symbol:ieee80211_tx_frame ieee80211
+alias symbol:i2c_transfer i2c_core
+alias symbol:scsi_device_lookup scsi_mod
+alias symbol:crypto_drop_spawn crypto_algapi
+alias symbol:ata_cable_80wire libata
+alias symbol:mptbase_sas_persist_operation mptbase
+alias symbol:get_h225_addr nf_conntrack_h323
+alias symbol:nf_nat_tftp_hook nf_conntrack_tftp
+alias symbol:mpt_config mptbase
+alias symbol:ei_interrupt 8390
+alias symbol:scsi_get_host_dev scsi_mod
+alias symbol:scsi_add_device scsi_mod
+alias symbol:scsi_free_sgtable scsi_mod
+alias symbol:i2c_add_numbered_adapter i2c_core
+alias symbol:sas_port_alloc scsi_transport_sas
+alias symbol:sas_phy_enable libsas
+alias symbol:i2c_smbus_write_byte_data i2c_core
+alias symbol:scsi_kmap_atomic_sg scsi_mod
+alias symbol:ieee80211softmac_wx_get_essid ieee80211softmac
+alias symbol:tifm_free_device tifm_core
+alias symbol:starget_for_each_device scsi_mod
+alias symbol:ata_host_init libata
+alias symbol:tifm_unmap_sg tifm_core
+alias symbol:i2c_get_adapter i2c_core
+alias symbol:ieee80211softmac_set_rates ieee80211softmac
+alias symbol:free_ieee80211softmac ieee80211softmac
+alias symbol:usbnet_set_settings usbnet
+alias symbol:usbnet_get_settings usbnet
+alias symbol:fat_fill_super fat
+alias symbol:tifm_register_driver tifm_core
+alias symbol:kvm_resched kvm
+alias symbol:nf_ct_port_nfattr_to_tuple nf_conntrack
+alias symbol:load_msrs kvm
+alias symbol:mpt_detach mptbase
+alias symbol:mptscsih_dev_reset mptscsih
+alias symbol:mptscsih_raid_id_to_num mptscsih
+alias symbol:mmc_free_host mmc_core
+alias symbol:scsi_get_sense_info_fld scsi_mod
+alias symbol:sata_phy_reset libata
+alias symbol:zlib_deflateReset zlib_deflate
+alias symbol:scsi_kunmap_atomic_sg scsi_mod
+alias symbol:scsi_block_when_processing_errors scsi_mod
+alias symbol:ata_tf_to_fis libata
+alias symbol:i2c_smbus_read_word_data i2c_core
+alias symbol:fc_host_post_event scsi_transport_fc
+alias symbol:ata_interrupt libata
+alias symbol:ata_eh_qc_retry libata
+alias symbol:scsi_register_interface scsi_mod
+alias symbol:i2c_smbus_read_block_data i2c_core
+alias symbol:__nf_conntrack_helper_find_byname nf_conntrack
+alias symbol:tifm_remove_adapter tifm_core
+alias symbol:nf_conntrack_count nf_conntrack
+alias symbol:nf_conntrack_expect_put nf_conntrack
+alias symbol:mptscsih_io_done mptscsih
+alias symbol:sas_eh_bus_reset_handler libsas
+alias symbol:ieee80211softmac_start ieee80211softmac
+alias symbol:raid_class_release raid_class
+alias symbol:scsi_register scsi_mod
+alias symbol:ata_eh_qc_complete libata
+alias symbol:mpt_device_driver_register mptbase
+alias symbol:crypto_hash_type crypto_hash
+alias symbol:xt_unregister_targets x_tables
+alias symbol:mraid_mm_register_adp megaraid_mm
+alias symbol:ieee80211softmac_wx_set_essid ieee80211softmac
+alias symbol:sata_phy_resume libata
+alias symbol:raid_class_attach raid_class
+alias symbol:mpt_add_sge mptbase
+alias symbol:zlib_deflateInit2 zlib_deflate
+alias symbol:ata_host_resume libata
+alias symbol:mmc_remove_host mmc_core
+alias symbol:mpt_HardResetHandler mptbase
+alias symbol:usbnet_get_endpoints usbnet
+alias symbol:i2c_del_driver i2c_core
+alias symbol:ata_altstatus libata
+alias symbol:sas_slave_configure libsas
+alias symbol:i2c_clients_command i2c_core
+alias symbol:kvm_init_arch kvm
+alias symbol:sas_change_queue_type libsas
+alias symbol:mptscsih_ioc_reset mptscsih
+alias symbol:mmc_set_data_timeout mmc_core
+alias symbol:scsi_eh_finish_cmd scsi_mod
+alias symbol:ata_pci_device_suspend libata
+alias symbol:__scsi_add_device scsi_mod
+alias symbol:fat_scan fat
+alias symbol:__scsi_print_sense scsi_mod
+alias symbol:__sata_phy_reset libata
+alias symbol:mdiobus_unregister libphy
+alias symbol:mii_link_ok mii
+alias symbol:phy_detach libphy
+alias symbol:ieee80211softmac_wx_get_scan_results ieee80211softmac
+alias symbol:nf_conntrack_l4proto_udp6 nf_conntrack
+alias symbol:nf_conntrack_l4proto_register nf_conntrack
+alias symbol:nf_conntrack_l3proto_register nf_conntrack
+alias symbol:ata_timing_compute libata
+alias symbol:ieee80211_rx ieee80211
+alias symbol:ata_std_softreset libata
+alias symbol:usbnet_skb_return usbnet
+alias symbol:nf_ct_iterate_cleanup nf_conntrack
+alias symbol:phy_start_aneg libphy
+alias symbol:scsi_print_result scsi_mod
+alias symbol:ct_sip_search nf_conntrack_sip
+alias symbol:i2c_new_probed_device i2c_core
+alias symbol:int_to_scsilun scsi_mod
+alias symbol:kvm_emulate_cpuid kvm
+alias symbol:__scsi_alloc_queue scsi_mod
+alias symbol:sas_port_delete scsi_transport_sas
+alias symbol:ata_qc_issue_prot libata
+alias symbol:i2c_smbus_read_byte i2c_core
+alias symbol:blkcipher_walk_phys blkcipher
+alias symbol:ei_close 8390
+alias symbol:nf_conntrack_expect_unregister_notifier nf_conntrack
+alias symbol:scsi_finish_command scsi_mod
+alias symbol:ieee80211softmac_wx_trigger_scan ieee80211softmac
+alias symbol:mptscsih_abort mptscsih
+alias symbol:mptscsih_slave_configure mptscsih
+alias symbol:mpt_register mptbase
+alias symbol:phy_start libphy
+alias symbol:mpt_stm_index mptbase
+alias symbol:mpt_raid_phys_disk_pg0 mptbase
+alias symbol:ata_host_intr libata
+alias symbol:arpt_register_table arp_tables
+alias symbol:ata_std_bios_param libata
+alias symbol:crypto_larval_error crypto_algapi
+alias symbol:__nf_ct_l4proto_find nf_conntrack
+alias symbol:ata_qc_prep libata
+alias symbol:kvm_write_guest kvm
+alias symbol:scsi_nl_sock scsi_mod
+alias symbol:i2c_smbus_xfer i2c_core
+alias symbol:ata_dev_disable libata
+alias symbol:spi_populate_width_msg scsi_transport_spi
+alias symbol:mraid_mm_unregister_adp megaraid_mm
+alias symbol:scsi_device_type scsi_mod
+alias symbol:nf_conntrack_l4proto_icmp nf_conntrack_ipv4
+alias symbol:mmc_unregister_driver mmc_core
+alias symbol:ata_pci_init_native_host libata
+alias symbol:ieee80211_register_crypto_ops ieee80211_crypt
+alias symbol:__nf_ct_event_cache_init nf_conntrack
+alias symbol:spi_populate_sync_msg scsi_transport_spi
+alias symbol:phy_driver_register libphy
+alias symbol:scsi_dma_unmap scsi_mod
+alias symbol:phy_print_status libphy
+alias symbol:nf_conntrack_register_notifier nf_conntrack
+alias symbol:mpt_attach mptbase
+alias symbol:need_conntrack nf_conntrack
+alias symbol:scsi_nonblockable_ioctl scsi_mod
+alias symbol:ata_pci_device_resume libata
+alias symbol:ata_scsi_slave_config libata
+alias symbol:mpt_put_msg_frame mptbase
+alias symbol:scsi_partsize scsi_mod
+alias symbol:alloc_ieee80211 ieee80211
+alias symbol:kvm_exit_arch kvm
+alias symbol:scsi_host_put scsi_mod
+alias symbol:sas_domain_release_transport libsas
+alias symbol:nf_ct_gre_keymap_flush nf_conntrack_proto_gre
+alias symbol:crypto_register_instance crypto_algapi
+alias symbol:kvm_setup_pio kvm
+alias symbol:fc_release_transport scsi_transport_fc
+alias symbol:sas_rphy_free scsi_transport_sas
+alias symbol:crypto_get_attr_type crypto_algapi
+alias symbol:scsi_eh_get_sense scsi_mod
+alias symbol:nfnetlink_send nfnetlink
+alias symbol:loop_register_transfer loop
+alias symbol:ieee80211_get_crypto_ops ieee80211_crypt
+alias symbol:scsi_host_put_command scsi_tgt
+alias symbol:nf_nat_proto_put nf_nat
+alias symbol:ata_pci_init_bmdma libata
+alias symbol:srp_target_alloc libsrp
+alias symbol:set_ras_addr_hook nf_conntrack_h323
+alias symbol:ata_scsi_queuecmd libata
+alias symbol:xt_register_match x_tables
+alias symbol:kvm_put_guest_fpu kvm
+alias symbol:ata_dummy_port_ops libata
+alias symbol:sas_change_queue_depth libsas
+alias symbol:mmc_resume_host mmc_core
+alias symbol:ata_std_dev_select libata
+alias symbol:mmc_alloc_host mmc_core
+alias symbol:scsi_eh_ready_devs scsi_mod
+alias symbol:ieee80211_txb_free ieee80211
+alias symbol:i2c_new_device i2c_core
+alias symbol:ata_pci_init_one libata
+alias symbol:__nf_conntrack_expect_find nf_conntrack
+alias symbol:scsi_is_sas_phy scsi_transport_sas
+alias symbol:sata_port_hardreset libata
+alias symbol:scsi_is_target_device scsi_mod
+alias symbol:phy_write libphy
+alias symbol:scsi_internal_device_block scsi_mod
+alias symbol:scsi_target_resume scsi_mod
+alias symbol:scsi_is_sas_port scsi_transport_sas
+alias symbol:ieee80211_rx_mgt ieee80211
+alias symbol:__nf_ct_refresh_acct nf_conntrack
+alias symbol:srp_cmd_queue libsrp
+alias symbol:fat_fs_panic fat
+alias symbol:fixed_mdio_set_link_update fixed
+alias symbol:nf_conntrack_untracked nf_conntrack
+alias symbol:scsi_tgt_cmd_to_host scsi_tgt
+alias symbol:fat_remove_entries fat
+alias symbol:scsi_target_unblock scsi_mod
+alias symbol:phy_attach libphy
+alias symbol:xt_unregister_match x_tables
+alias symbol:mptscsih_suspend mptscsih
+alias symbol:__nf_conntrack_find nf_conntrack
+alias symbol:crypto_alloc_instance crypto_algapi
+alias symbol:set_cr8 kvm
+alias symbol:ata_dev_pair libata
+alias symbol:scsi_execute_async scsi_mod
+alias symbol:nfnetlink_subsys_unregister nfnetlink
+alias symbol:nat_callforwarding_hook nf_conntrack_h323
+alias symbol:phy_disconnect libphy
+alias symbol:ieee80211_get_geo ieee80211
+alias symbol:iscsi_destroy_conn scsi_transport_iscsi
+alias symbol:crypto_init_queue crypto_algapi
+alias symbol:kvm_load_guest_fpu kvm
+alias symbol:ieee80211_crypt_quiescing ieee80211_crypt
+alias symbol:mpt_findImVolumes mptbase
+alias symbol:escape_essid ieee80211
+alias symbol:__nf_conntrack_attach nf_conntrack
+alias symbol:mpt_free_msg_frame mptbase
+alias symbol:srp_iu_put libsrp
+alias symbol:srp_iu_get libsrp
+alias symbol:nf_conntrack_helper_unregister nf_conntrack
+alias symbol:scsi_print_status scsi_mod
+alias symbol:ieee80211_set_geo ieee80211
+alias symbol:ata_id_to_dma_mode libata
+alias symbol:scsi_put_command scsi_mod
+alias symbol:hwmon_device_register hwmon
+alias symbol:nf_conntrack_tuple_taken nf_conntrack
+alias symbol:sata_deb_timing_normal libata
+alias symbol:mmc_suspend_host mmc_core
+alias symbol:spi_populate_ppr_msg scsi_transport_spi
+alias symbol:__alloc_ei_netdev 8390
+alias symbol:xt_register_matches x_tables
+alias symbol:raid_component_add raid_class
+alias symbol:ata_sas_port_destroy libata
+alias symbol:srp_target_free libsrp
+alias symbol:phy_device_create libphy
+alias symbol:sata_phy_debounce libata
+alias symbol:usbnet_defer_kevent usbnet
+alias symbol:fx_init kvm
+alias symbol:nf_conntrack_alloc nf_conntrack
+alias symbol:fat_flush_inodes fat
+alias symbol:__scsi_iterate_devices scsi_mod
+alias symbol:ata_port_probe libata
+alias symbol:scsi_sense_desc_find scsi_mod
+alias symbol:crypto_tfm_in_queue crypto_algapi
+alias symbol:ata_tf_from_fis libata
+alias symbol:nf_nat_proto_find_get nf_nat
+alias symbol:nf_nat_port_range_to_nfattr nf_nat
+alias symbol:nfnetlink_has_listeners nfnetlink
+alias symbol:fc_host_post_vendor_event scsi_transport_fc
+alias symbol:scsi_device_cancel scsi_mod
+alias symbol:iscsi_register_transport scsi_transport_iscsi
+alias symbol:ata_pci_clear_simplex libata
+alias symbol:ip_set_put ip_set
+alias symbol:nf_conntrack_htable_size nf_conntrack
+alias symbol:iscsi_if_create_session_done scsi_transport_iscsi
+alias symbol:ip_set_delip_kernel ip_set
+alias symbol:ip_set_addip_kernel ip_set
+alias symbol:crypto_register_template crypto_algapi
+alias symbol:lmsw kvm
+alias symbol:ata_cable_40wire libata
+alias symbol:ata_cable_unknown libata
+alias symbol:scsi_show_extd_sense scsi_mod
+alias symbol:xt_register_target x_tables
+alias symbol:ata_pci_prepare_native_host libata
+alias symbol:mpt_event_deregister mptbase
+alias symbol:fat_getattr fat
+alias symbol:NS8390_init 8390
+alias symbol:usbnet_generic_cdc_bind cdc_ether
+alias symbol:blkcipher_walk_done blkcipher
+alias symbol:sas_bios_param libsas
+alias symbol:sas_attach_transport scsi_transport_sas
+alias symbol:i2c_detach_client i2c_core
+alias symbol:ata_host_alloc libata
+alias symbol:mpt_resume mptbase
+alias symbol:ioc_list mptbase
+alias symbol:sas_target_alloc libsas
+alias symbol:nf_conntrack_expect_find_get nf_conntrack
+alias symbol:scsi_device_resume scsi_mod
+alias symbol:crypto_unregister_notifier crypto_algapi
+alias symbol:scsi_calculate_bounce_limit scsi_mod
+alias symbol:ipt_do_table ip_tables
+alias symbol:xt_find_target x_tables
+alias symbol:nf_conntrack_expect_register_notifier nf_conntrack
+alias symbol:ata_ratelimit libata
+alias symbol:i2c_adapter_dev_release i2c_core
+alias symbol:fc_remote_port_rolechg scsi_transport_fc
+alias symbol:nf_nat_follow_master nf_nat
+alias symbol:i2c_smbus_write_byte i2c_core
+alias symbol:scsi_register_driver scsi_mod
+alias symbol:xt_register_targets x_tables
+alias symbol:nf_nat_seq_adjust nf_nat
+alias symbol:nf_nat_pptp_hook_outbound nf_conntrack_pptp
+alias symbol:mpt_send_handshake_request mptbase
+alias symbol:scsi_host_set_state scsi_mod
+alias symbol:genphy_config_aneg libphy
+alias symbol:nat_t120_hook nf_conntrack_h323
+alias symbol:sas_slave_destroy libsas
+alias symbol:arpt_unregister_table arp_tables
diff -Nurb linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.usbmap linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.usbmap
--- linux-2.6.22-590/inst/lib/modules/2.6.22-prep/modules.usbmap	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/inst/lib/modules/2.6.22-prep/modules.usbmap	2007-12-21 13:22:40.000000000 -0500
@@ -0,0 +1,176 @@
+# usb module         match_flags idVendor idProduct bcdDevice_lo bcdDevice_hi bDeviceClass bDeviceSubClass bDeviceProtocol bInterfaceClass bInterfaceSubClass bInterfaceProtocol driver_info
+zaurus               0x0383      0x04dd   0x8004    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+zaurus               0x0383      0x04dd   0x8005    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+zaurus               0x0383      0x04dd   0x8006    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+zaurus               0x0383      0x04dd   0x8007    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+zaurus               0x0383      0x04dd   0x9031    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+zaurus               0x0383      0x04dd   0x9032    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+zaurus               0x0383      0x04dd   0x9050    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+zaurus               0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x02            0x0a               0x00               0x0
+zaurus               0x0383      0x07b4   0x0f02    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+rtl8150              0x0003      0x0bda   0x8150    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+rtl8150              0x0003      0x0411   0x0012    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+rtl8150              0x0003      0x3980   0x0003    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+rtl8150              0x0003      0x07b8   0x401a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+rtl8150              0x0003      0x1557   0x8150    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+rtl8150              0x0003      0x0586   0x401a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+rndis_host           0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x02            0x02               0xff               0x0
+rndis_host           0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0xef            0x01               0x01               0x0
+plusb                0x0003      0x067b   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+plusb                0x0003      0x067b   0x0001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x0506   0x4601    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x0557   0x2007    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07b8   0x110c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07b8   0x4104    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07b8   0x4004    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07b8   0x4007    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07b8   0x4102    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07b8   0x4002    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07b8   0x400b    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07b8   0x400c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07b8   0xabc1    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07b8   0x200c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x083a   0x1046    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x083a   0x5046    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x083a   0xb004    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07a6   0x8511    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07a6   0x8513    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07a6   0x8515    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07a6   0x0986    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07a6   0x07c2    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x3334   0x1701    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07c9   0xb100    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x050d   0x0121    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x08dd   0x0986    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x08dd   0x0987    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x049f   0x8511    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x08dd   0x0988    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x08dd   0x8511    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07aa   0x0004    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x07aa   0x000d    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x2001   0x4001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x2001   0x4002    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x2001   0x4102    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x2001   0x400b    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x2001   0x200c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x2001   0x4003    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x2001   0xabc1    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x0db7   0x0002    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x056e   0x4010    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x1342   0x0304    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x05cc   0x3000    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x1044   0x8002    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x0e66   0x400c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x03f0   0x811c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x04bb   0x0904    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x04bb   0x0913    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x0951   0x000a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x056e   0x4002    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x056e   0x4005    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x056e   0x400b    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x056e   0xabc1    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x056e   0x200c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x066b   0x2202    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x066b   0x2203    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x066b   0x2204    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x066b   0x2206    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x077b   0x08b4    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x066b   0x400b    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x066b   0x200c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x0411   0x0001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x0411   0x0005    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x0411   0x0009    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x045e   0x007a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x0846   0x1020    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x0b39   0x0109    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x0b39   0x0901    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x08d1   0x0003    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x0707   0x0200    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x0707   0x0201    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x15e8   0x9100    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x15e8   0x9110    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+pegasus              0x0003      0x067c   0x1001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+net1080              0x0003      0x0525   0x1080    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+net1080              0x0003      0x06d0   0x0622    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+mcs7830              0x0003      0x9710   0x7830    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x03e8   0x0008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x04bb   0x0901    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x0506   0x03e8    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x0506   0x11f8    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x0557   0x2002    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x0557   0x4000    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x0565   0x0002    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x0565   0x0003    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x0565   0x0005    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x05e9   0x0008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x05e9   0x0009    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x066b   0x2202    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x06e1   0x0008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x06e1   0x0009    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x0707   0x0100    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x07aa   0x0001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x07b8   0x4000    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x0846   0x1001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x0846   0x1002    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x085a   0x0008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x085a   0x0009    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x087d   0x5704    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x0951   0x0008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x095a   0x3003    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x10bd   0x1427    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x1342   0x0204    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x13d2   0x0400    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x1485   0x0001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x1485   0x0002    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x1645   0x0005    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x1645   0x0008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x1645   0x8005    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x1668   0x0323    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+kaweth               0x0003      0x2001   0x4000    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+gl620a               0x0003      0x05e3   0x0502    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+cdc_subset           0x0003      0x0402   0x5632    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+cdc_subset           0x0003      0x182d   0x207c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+cdc_subset           0x0003      0x0547   0x2720    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+cdc_subset           0x0003      0x0547   0x2727    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+cdc_subset           0x0003      0x050d   0x0004    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+cdc_subset           0x0003      0x056c   0x8100    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+cdc_subset           0x0003      0x0525   0x9901    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+cdc_subset           0x0003      0x0525   0x2888    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+cdc_subset           0x0003      0x049f   0x505a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+cdc_subset           0x0003      0x0e7e   0x1001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+cdc_subset           0x0003      0x8086   0x07d3    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+cdc_subset           0x000f      0x0525   0xa4a2    0x0203       0x0203       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+cdc_ether            0x0383      0x04dd   0x8004    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+cdc_ether            0x0383      0x04dd   0x8005    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+cdc_ether            0x0383      0x04dd   0x8006    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+cdc_ether            0x0383      0x04dd   0x8007    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+cdc_ether            0x0383      0x04dd   0x9031    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+cdc_ether            0x0383      0x04dd   0x9032    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+cdc_ether            0x0383      0x04dd   0x9050    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+cdc_ether            0x0383      0x07b4   0x0f02    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+cdc_ether            0x0380      0x0000   0x0000    0x0000       0x0000       0x00         0x00            0x00            0x02            0x06               0x00               0x0
+catc                 0x0003      0x0423   0x000a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+catc                 0x0003      0x0423   0x000c    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+catc                 0x0003      0x08d1   0x0001    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x077b   0x2226    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x0846   0x1040    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x2001   0x1a00    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x0b95   0x1720    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x07b8   0x420a    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x08dd   0x90ff    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x0557   0x2009    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x0411   0x003d    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x6189   0x182d    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x07aa   0x0017    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x1189   0x0893    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x1631   0x6200    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x04f1   0x3008    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x0b95   0x7720    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x0b95   0x1780    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x13b1   0x0018    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x1557   0x7720    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x07d1   0x3c05    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x2001   0x3c05    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x1737   0x0039    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x04bb   0x0930    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
+asix                 0x0003      0x050d   0x5055    0x0000       0x0000       0x00         0x00            0x00            0x00            0x00               0x00               0x0
Files linux-2.6.22-590/inst/vmlinuz and linux-2.6.22-try2-netns/inst/vmlinuz differ
Files linux-2.6.22-590/inst/vmlinuz-2.6.22-prep and linux-2.6.22-try2-netns/inst/vmlinuz-2.6.22-prep differ
Files linux-2.6.22-590/inst.tar.gz and linux-2.6.22-try2-netns/inst.tar.gz differ
diff -Nurb linux-2.6.22-590/kernel/audit.c linux-2.6.22-try2-netns/kernel/audit.c
--- linux-2.6.22-590/kernel/audit.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/kernel/audit.c	2007-12-19 22:49:13.000000000 -0500
@@ -795,8 +795,8 @@
 
 	printk(KERN_INFO "audit: initializing netlink socket (%s)\n",
 	       audit_default ? "enabled" : "disabled");
-	audit_sock = netlink_kernel_create(NETLINK_AUDIT, 0, audit_receive,
-					   NULL, THIS_MODULE);
+	audit_sock = netlink_kernel_create(&init_net, NETLINK_AUDIT, 0,
+					   audit_receive, NULL, THIS_MODULE);
 	if (!audit_sock)
 		audit_panic("cannot initialize netlink socket");
 	else
diff -Nurb linux-2.6.22-590/kernel/container.c linux-2.6.22-try2-netns/kernel/container.c
--- linux-2.6.22-590/kernel/container.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/kernel/container.c	2007-12-20 00:28:39.000000000 -0500
@@ -2360,7 +2360,7 @@
 	}
 
 	/* Create the container directory, which also creates the container */
-	ret = vfs_mkdir(inode, dentry, S_IFDIR | 0755);
+	ret = vfs_mkdir(inode, dentry, S_IFDIR | 0755, NULL);
 	child = __d_cont(dentry);
 	dput(dentry);
 	if (ret) {
diff -Nurb linux-2.6.22-590/kernel/fork.c linux-2.6.22-try2-netns/kernel/fork.c
--- linux-2.6.22-590/kernel/fork.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/kernel/fork.c	2007-12-19 23:52:01.000000000 -0500
@@ -979,7 +979,7 @@
 {
 	int retval;
 	struct task_struct *p = NULL;
-+ 	int container_callbacks_done = 0;
+ 	int container_callbacks_done = 0;
 	struct vx_info *vxi;
 	struct nx_info *nxi;
 
diff -Nurb linux-2.6.22-590/kernel/nsproxy.c linux-2.6.22-try2-netns/kernel/nsproxy.c
--- linux-2.6.22-590/kernel/nsproxy.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/kernel/nsproxy.c	2007-12-21 13:29:56.000000000 -0500
@@ -19,6 +19,7 @@
 #include <linux/init_task.h>
 #include <linux/mnt_namespace.h>
 #include <linux/utsname.h>
+#include <net/net_namespace.h>
 #include <linux/pid_namespace.h>
 #include <linux/vserver/global.h>
 #include <linux/vserver/debug.h>
@@ -60,6 +61,7 @@
 			struct fs_struct *new_fs)
 {
 	struct nsproxy *new_nsp;
+	int err = -ENOMEM;
 
 	vxdprintk(VXD_CBIT(space, 4),
 		"unshare_namespaces(0x%08x,%p,%p)",
@@ -85,12 +87,21 @@
 	if (IS_ERR(new_nsp->pid_ns))
 		goto out_pid;
 
-	new_nsp->user_ns = copy_user_ns(flags, tsk->nsproxy->user_ns);
+	new_nsp->user_ns = copy_user_ns(flags, orig->user_ns);
 	if (IS_ERR(new_nsp->user_ns))
 		goto out_user;
 
+	new_nsp->net_ns = copy_net_ns(flags, orig->net_ns);
+	if (IS_ERR(new_nsp->net_ns))
+		goto out_net;
+
 	return new_nsp;
 
+out_net:
+	if (new_nsp->user_ns)
+		put_user_ns(new_nsp->user_ns);
+	if (new_nsp->net_ns)
+ 		put_net(new_nsp->net_ns);
 out_user:
 	if (new_nsp->pid_ns)
 		put_pid_ns(new_nsp->pid_ns);
@@ -152,10 +163,17 @@
 		return 0;
 
 	get_nsproxy(old_ns);
+	return 0;
 
-	if (!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWUSER)))
+	if (!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWUSER | CLONE_NEWNET)))
 		return 0;
 
+	 #ifndef CONFIG_NET_NS
+		if (unshare_flags & CLONE_NEWNET)
+			return -EINVAL;
+	 #endif
+
+
 	if (!capable(CAP_SYS_ADMIN)) {
 		err = -EPERM;
 		goto out;
@@ -211,9 +229,13 @@
 		unshare_flags, current->nsproxy);
 
 	if (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |
-			       CLONE_NEWUSER)))
+			       CLONE_NEWUSER | CLONE_NEWNET)))
 		return 0;
 
+#ifndef CONFIG_NET_NS
+	if (unshare_flags & CLONE_NEWNET)
+		return -EINVAL;
+#endif
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
diff -Nurb linux-2.6.22-590/kernel/sysctl.c linux-2.6.22-try2-netns/kernel/sysctl.c
--- linux-2.6.22-590/kernel/sysctl.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/kernel/sysctl.c	2007-12-19 22:49:13.000000000 -0500
@@ -47,6 +47,7 @@
 #include <linux/acpi.h>
 #include <linux/reboot.h>
 #include <linux/fs.h>
+#include <net/net_namespace.h>
 
 #include <asm/uaccess.h>
 #include <asm/processor.h>
@@ -139,6 +140,10 @@
 			       void __user *buffer, size_t *lenp, loff_t *ppos);
 #endif
 
+#ifdef CONFIG_NET
+static void sysctl_net_init(struct net *net);
+#endif
+
 static ctl_table root_table[];
 static struct ctl_table_header root_table_header =
 	{ root_table, LIST_HEAD_INIT(root_table_header.ctl_entry) };
@@ -1151,6 +1156,11 @@
 {
 	struct ctl_table_header *head;
 	struct list_head *tmp;
+	struct net *net = current->nsproxy->net_ns;
+
+	if (!net->net_table_header.ctl_table)
+		sysctl_net_init(net);
+
 	spin_lock(&sysctl_lock);
 	if (prev) {
 		tmp = &prev->ctl_entry;
@@ -1168,6 +1178,10 @@
 	next:
 		tmp = tmp->next;
 		if (tmp == &root_table_header.ctl_entry)
+#ifdef CONFIG_NET
+			tmp = &net->net_table_header.ctl_entry;
+		else if (tmp == &net->net_table_header.ctl_entry)
+#endif
 			break;
 	}
 	spin_unlock(&sysctl_lock);
@@ -1283,7 +1297,6 @@
 			void __user *newval, size_t newlen)
 {
 	int op = 0, rc;
-	size_t len;
 
 	if (oldval)
 		op |= 004;
@@ -1304,25 +1317,10 @@
 	/* If there is no strategy routine, or if the strategy returns
 	 * zero, proceed with automatic r/w */
 	if (table->data && table->maxlen) {
-		if (oldval && oldlenp) {
-			if (get_user(len, oldlenp))
-				return -EFAULT;
-			if (len) {
-				if (len > table->maxlen)
-					len = table->maxlen;
-				if(copy_to_user(oldval, table->data, len))
-					return -EFAULT;
-				if(put_user(len, oldlenp))
-					return -EFAULT;
-			}
-		}
-		if (newval && newlen) {
-			len = newlen;
-			if (len > table->maxlen)
-				len = table->maxlen;
-			if(copy_from_user(table->data, newval, len))
-				return -EFAULT;
-		}
+		rc = sysctl_data(table, name, nlen, oldval, oldlenp,
+				 newval, newlen);
+		if (rc < 0)
+			return rc;
 	}
 	return 0;
 }
@@ -1413,7 +1411,8 @@
  * This routine returns %NULL on a failure to register, and a pointer
  * to the table header on success.
  */
-struct ctl_table_header *register_sysctl_table(ctl_table * table)
+static struct ctl_table_header *__register_sysctl_table(
+	struct ctl_table_header *root, ctl_table * table)
 {
 	struct ctl_table_header *tmp;
 	tmp = kmalloc(sizeof(struct ctl_table_header), GFP_KERNEL);
@@ -1425,11 +1424,16 @@
 	tmp->unregistering = NULL;
 	sysctl_set_parent(NULL, table);
 	spin_lock(&sysctl_lock);
-	list_add_tail(&tmp->ctl_entry, &root_table_header.ctl_entry);
+	list_add_tail(&tmp->ctl_entry, &root->ctl_entry);
 	spin_unlock(&sysctl_lock);
 	return tmp;
 }
 
+struct ctl_table_header *register_sysctl_table(ctl_table *table)
+{
+	return __register_sysctl_table(&root_table_header, table);
+}
+
 /**
  * unregister_sysctl_table - unregister a sysctl table hierarchy
  * @header: the header returned from register_sysctl_table
@@ -1446,6 +1450,92 @@
 	kfree(header);
 }
 
+#ifdef CONFIG_NET
+
+static void *fixup_table_addr(void *addr,
+			      const char *start, size_t size, const char *new)
+{
+	char *ptr = addr;
+	if ((ptr >= start) && (ptr < (start + size)))
+		ptr += new - start;
+	return ptr;
+}
+
+static void table_fixup(struct ctl_table *table,
+			const void *start, size_t size, const void *new)
+{
+	for (; table->ctl_name || table->procname; table++) {
+		table->data   = fixup_table_addr(table->data, start, size, new);
+		table->extra1 = fixup_table_addr(table->extra1, start, size, new);
+		table->extra2 = fixup_table_addr(table->extra2, start, size, new);
+
+		/* Whee recursive functions on the kernel stack */
+		if (table->child)
+			table_fixup(table->child, start, size, new);
+	}
+}
+
+static unsigned count_table_entries(struct ctl_table *table)
+{
+	unsigned entries = 0;
+	for (; table->ctl_name || table->procname; table++) {
+		entries += 1;
+
+		if (table->child)
+			entries += count_table_entries(table->child);
+	}
+	entries += 1; /* Null terminating entry */
+	return entries;
+}
+
+static struct ctl_table *copy_table_entries(
+	struct ctl_table *dest, struct ctl_table *src)
+{
+	struct ctl_table *table = dest;
+	for (; src->ctl_name || src->procname; src++) {
+		*dest++ = *table;
+	}
+	dest++; /* Null terminating entry */
+	for (; table->ctl_name || table->procname; table++) {
+		if (table->child)
+			dest = copy_table_entries(dest, table->child);
+	}
+	return dest;
+}
+
+static void sysctl_net_init(struct net *net)
+{
+	unsigned entries;
+	struct ctl_table *table;
+	
+	entries = count_table_entries(net_root_table);
+	table = kzalloc(GFP_KERNEL, sizeof(*table)*entries);
+	/* FIXME free table... */
+
+	copy_table_entries(table, net_root_table);
+	table_fixup(table, &init_net, sizeof(init_net), net);
+
+	net->net_table_header.ctl_table = table;
+	INIT_LIST_HEAD(&net->net_table_header.ctl_entry);
+}
+
+struct ctl_table_header *register_net_sysctl_table(struct net *net, struct ctl_table *table)
+{
+	if (!net->net_table_header.ctl_table)
+		sysctl_net_init(net);
+	table_fixup(table, &init_net, sizeof(init_net), net);
+	return __register_sysctl_table(&net->net_table_header, table);
+}
+EXPORT_SYMBOL_GPL(register_net_sysctl_table);
+
+void unregister_net_sysctl_table(struct ctl_table_header *header)
+{
+	return unregister_sysctl_table(header);
+}
+EXPORT_SYMBOL_GPL(unregister_net_sysctl_table);
+#endif
+
+
 #else /* !CONFIG_SYSCTL */
 struct ctl_table_header *register_sysctl_table(ctl_table * table)
 {
@@ -2221,6 +2311,40 @@
  * General sysctl support routines 
  */
 
+/* The generic sysctl data routine (used if no strategy routine supplied) */
+int sysctl_data(ctl_table *table, int __user *name, int nlen,
+		void __user *oldval, size_t __user *oldlenp,
+		void __user *newval, size_t newlen)
+{
+	size_t len;
+
+	/* Get out of I don't have a variable */
+	if (!table->data || !table->maxlen)
+		return -ENOTDIR;
+
+	if (oldval && oldlenp) {
+		if (get_user(len, oldlenp))
+			return -EFAULT;
+		if (len) {
+			if (len > table->maxlen)
+				len = table->maxlen;
+			if (copy_to_user(oldval, table->data, len))
+				return -EFAULT;
+			if (put_user(len, oldlenp))
+				return -EFAULT;
+		}
+	}
+
+	if (newval && newlen) {
+		if (newlen > table->maxlen)
+			newlen = table->maxlen;
+
+		if (copy_from_user(table->data, newval, newlen))
+			return -EFAULT;
+	}
+	return 1;
+}
+
 /* The generic string strategy routine: */
 int sysctl_string(ctl_table *table, int __user *name, int nlen,
 		  void __user *oldval, size_t __user *oldlenp,
@@ -2409,6 +2533,13 @@
 	return -ENOSYS;
 }
 
+int sysctl_data(ctl_table *table, int __user *name, int nlen,
+		  void __user *oldval, size_t __user *oldlenp,
+		  void __user *newval, size_t newlen)
+{
+	return -ENOSYS;
+}
+
 int sysctl_string(ctl_table *table, int __user *name, int nlen,
 		  void __user *oldval, size_t __user *oldlenp,
 		  void __user *newval, size_t newlen)
@@ -2456,4 +2587,5 @@
 EXPORT_SYMBOL(sysctl_jiffies);
 EXPORT_SYMBOL(sysctl_ms_jiffies);
 EXPORT_SYMBOL(sysctl_string);
+EXPORT_SYMBOL(sysctl_data);
 EXPORT_SYMBOL(unregister_sysctl_table);
diff -Nurb linux-2.6.22-590/kernel/time/timekeeping.c linux-2.6.22-try2-netns/kernel/time/timekeeping.c
--- linux-2.6.22-590/kernel/time/timekeeping.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/kernel/time/timekeeping.c	2007-12-20 01:36:06.000000000 -0500
@@ -39,7 +39,7 @@
  */
 struct timespec xtime __attribute__ ((aligned (16)));
 struct timespec wall_to_monotonic __attribute__ ((aligned (16)));
-
+static unsigned long total_sleep_time;
 EXPORT_SYMBOL(xtime);
 
 
@@ -251,6 +251,7 @@
 	xtime.tv_nsec = 0;
 	set_normalized_timespec(&wall_to_monotonic,
 		-xtime.tv_sec, -xtime.tv_nsec);
+	total_sleep_time = 0;
 
 	write_sequnlock_irqrestore(&xtime_lock, flags);
 }
@@ -282,6 +283,7 @@
 
 		xtime.tv_sec += sleep_length;
 		wall_to_monotonic.tv_sec -= sleep_length;
+		total_sleep_time += sleep_length;
 	}
 	/* re-base the last cycle value */
 	clock->cycle_last = clocksource_read(clock);
@@ -476,3 +478,34 @@
 	change_clocksource();
 	update_vsyscall(&xtime, clock);
 }
+
+/**
+ * getboottime - Return the real time of system boot.
+ * @ts:		pointer to the timespec to be set
+ *
+ * Returns the time of day in a timespec.
+ *
+ * This is based on the wall_to_monotonic offset and the total suspend
+ * time. Calls to settimeofday will affect the value returned (which
+ * basically means that however wrong your real time clock is at boot time,
+ * you get the right time here).
+ */
+void getboottime(struct timespec *ts)
+{
+	set_normalized_timespec(ts,
+		- (wall_to_monotonic.tv_sec + total_sleep_time),
+		- wall_to_monotonic.tv_nsec);
+}
+
+EXPORT_SYMBOL(getboottime);
+
+/**
+ * monotonic_to_bootbased - Convert the monotonic time to boot based.
+ * @ts:		pointer to the timespec to be converted
+ */
+void monotonic_to_bootbased(struct timespec *ts)
+{
+	ts->tv_sec += total_sleep_time;
+}
+
+EXPORT_SYMBOL(monotonic_to_bootbased);
diff -Nurb linux-2.6.22-590/kernel/timer.c linux-2.6.22-try2-netns/kernel/timer.c
--- linux-2.6.22-590/kernel/timer.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/kernel/timer.c	2007-12-20 01:23:58.000000000 -0500
@@ -1130,6 +1130,7 @@
 		getnstimeofday(&tp);
 		tp.tv_sec += wall_to_monotonic.tv_sec;
 		tp.tv_nsec += wall_to_monotonic.tv_nsec;
+		monotonic_to_bootbased(&tp);
 		if (tp.tv_nsec - NSEC_PER_SEC >= 0) {
 			tp.tv_nsec = tp.tv_nsec - NSEC_PER_SEC;
 			tp.tv_sec++;
diff -Nurb linux-2.6.22-590/kernel/user.c linux-2.6.22-try2-netns/kernel/user.c
--- linux-2.6.22-590/kernel/user.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/kernel/user.c	2007-12-20 00:17:22.000000000 -0500
@@ -24,7 +24,7 @@
 
 #define UIDHASH_MASK		(UIDHASH_SZ - 1)
 #define __uidhashfn(xid,uid)	((((uid) >> UIDHASH_BITS) + ((uid)^(xid))) & UIDHASH_MASK)
-#define uidhashentry(ns, uid)	((ns)->uidhash_table + __uidhashfn((uid)))
+#define uidhashentry(ns, xid, uid)	((ns)->uidhash_table + __uidhashfn(xid, uid))
 
 static struct kmem_cache *uid_cachep;
 static struct list_head uidhash_table[UIDHASH_SZ];
@@ -97,7 +97,7 @@
  	struct user_namespace *ns = current->nsproxy->user_ns;
 
 	spin_lock_irqsave(&uidhash_lock, flags);
- 	ret = uid_hash_find(uid, uidhashentry(ns, uid));
+ 	ret = uid_hash_find(xid, uid, uidhashentry(ns, xid, uid));
 	spin_unlock_irqrestore(&uidhash_lock, flags);
 	return ret;
 }
@@ -121,9 +121,10 @@
 	}
 }
 
-struct user_struct * alloc_uid(struct user_namespace *ns, uid_t uid)
+struct user_struct * alloc_uid(xid_t xid, uid_t uid)
 {
- 	struct list_head *hashent = uidhashentry(ns, uid);
+	struct user_namespace *ns = current->nsproxy->user_ns;
+ 	struct list_head *hashent = uidhashentry(ns,xid, uid);
 	struct user_struct *up;
 
 	spin_lock_irq(&uidhash_lock);
@@ -217,7 +218,7 @@
 
 	/* Insert the root user immediately (init already runs as root) */
 	spin_lock_irq(&uidhash_lock);
- 	uid_hash_insert(&root_user, uidhashentry(&init_user_ns, 0));
+ 	uid_hash_insert(&root_user, uidhashentry(&init_user_ns, 0, 0));
 	spin_unlock_irq(&uidhash_lock);
 
 	return 0;
diff -Nurb linux-2.6.22-590/kernel/utsname.c linux-2.6.22-try2-netns/kernel/utsname.c
--- linux-2.6.22-590/kernel/utsname.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/kernel/utsname.c	2007-12-20 01:29:18.000000000 -0500
@@ -14,6 +14,7 @@
 #include <linux/utsname.h>
 #include <linux/version.h>
 #include <linux/vserver/global.h>
+#include <linux/err.h>
 
 /*
  * Clone a new ns copying an original utsname, setting refcount to 1
diff -Nurb linux-2.6.22-590/lib/idr.c linux-2.6.22-try2-netns/lib/idr.c
--- linux-2.6.22-590/lib/idr.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/lib/idr.c	2007-12-20 01:32:21.000000000 -0500
@@ -70,6 +70,26 @@
 	spin_unlock_irqrestore(&idp->lock, flags);
 }
 
+static void idr_mark_full(struct idr_layer **pa, int id)
+{
+	struct idr_layer *p = pa[0];
+	int l = 0;
+
+	__set_bit(id & IDR_MASK, &p->bitmap);
+	/*
+	 * If this layer is full mark the bit in the layer above to
+	 * show that this part of the radix tree is full.  This may
+	 * complete the layer above and require walking up the radix
+	 * tree.
+	 */
+	while (p->bitmap == IDR_FULL) {
+		if (!(p = pa[++l]))
+			break;
+		id = id >> IDR_BITS;
+		__set_bit((id & IDR_MASK), &p->bitmap);
+	}
+}
+
 /**
  * idr_pre_get - reserver resources for idr allocation
  * @idp:	idr handle
@@ -95,11 +115,10 @@
 }
 EXPORT_SYMBOL(idr_pre_get);
 
-static int sub_alloc(struct idr *idp, void *ptr, int *starting_id)
+static int sub_alloc(struct idr *idp, int *starting_id, struct idr_layer **pa)
 {
 	int n, m, sh;
 	struct idr_layer *p, *new;
-	struct idr_layer *pa[MAX_LEVEL];
 	int l, id;
 	long bm;
 
@@ -144,30 +163,13 @@
 		pa[l--] = p;
 		p = p->ary[m];
 	}
-	/*
-	 * We have reached the leaf node, plant the
-	 * users pointer and return the raw id.
-	 */
-	p->ary[m] = (struct idr_layer *)ptr;
-	__set_bit(m, &p->bitmap);
-	p->count++;
-	/*
-	 * If this layer is full mark the bit in the layer above
-	 * to show that this part of the radix tree is full.
-	 * This may complete the layer above and require walking
-	 * up the radix tree.
-	 */
-	n = id;
-	while (p->bitmap == IDR_FULL) {
-		if (!(p = pa[++l]))
-			break;
-		n = n >> IDR_BITS;
-		__set_bit((n & IDR_MASK), &p->bitmap);
-	}
-	return(id);
+
+	pa[l] = p;
+	return id;
 }
 
-static int idr_get_new_above_int(struct idr *idp, void *ptr, int starting_id)
+static int idr_get_empty_slot(struct idr *idp, int starting_id,
+			      struct idr_layer **pa)
 {
 	struct idr_layer *p, *new;
 	int layers, v, id;
@@ -213,12 +215,31 @@
 	}
 	idp->top = p;
 	idp->layers = layers;
-	v = sub_alloc(idp, ptr, &id);
+	v = sub_alloc(idp, &id, pa);
 	if (v == -2)
 		goto build_up;
 	return(v);
 }
 
+static int idr_get_new_above_int(struct idr *idp, void *ptr, int starting_id)
+{
+	struct idr_layer *pa[MAX_LEVEL];
+	int id;
+
+	id = idr_get_empty_slot(idp, starting_id, pa);
+	if (id >= 0) {
+		/*
+		 * Successfully found an empty slot.  Install the user
+		 * pointer and mark the slot full.
+		 */
+		pa[0]->ary[id & IDR_MASK] = (struct idr_layer *)ptr;
+		pa[0]->count++;
+		idr_mark_full(pa, id);
+	}
+
+	return id;
+}
+
 /**
  * idr_get_new_above - allocate new idr entry above or equal to a start id
  * @idp: idr handle
@@ -473,3 +494,248 @@
 	spin_lock_init(&idp->lock);
 }
 EXPORT_SYMBOL(idr_init);
+
+
+/*
+ * IDA - IDR based ID allocator
+ *
+ * this is id allocator without id -> pointer translation.  Memory
+ * usage is much lower than full blown idr because each id only
+ * occupies a bit.  ida uses a custom leaf node which contains
+ * IDA_BITMAP_BITS slots.
+ *
+ * 2007-04-25  written by Tejun Heo <htejun@gmail.com>
+ */
+
+static void free_bitmap(struct ida *ida, struct ida_bitmap *bitmap)
+{
+	unsigned long flags;
+
+	if (!ida->free_bitmap) {
+		spin_lock_irqsave(&ida->idr.lock, flags);
+		if (!ida->free_bitmap) {
+			ida->free_bitmap = bitmap;
+			bitmap = NULL;
+		}
+		spin_unlock_irqrestore(&ida->idr.lock, flags);
+	}
+
+	kfree(bitmap);
+}
+
+/**
+ * ida_pre_get - reserve resources for ida allocation
+ * @ida:	ida handle
+ * @gfp_mask:	memory allocation flag
+ *
+ * This function should be called prior to locking and calling the
+ * following function.  It preallocates enough memory to satisfy the
+ * worst possible allocation.
+ *
+ * If the system is REALLY out of memory this function returns 0,
+ * otherwise 1.
+ */
+int ida_pre_get(struct ida *ida, gfp_t gfp_mask)
+{
+	/* allocate idr_layers */
+	if (!idr_pre_get(&ida->idr, gfp_mask))
+		return 0;
+
+	/* allocate free_bitmap */
+	if (!ida->free_bitmap) {
+		struct ida_bitmap *bitmap;
+
+		bitmap = kmalloc(sizeof(struct ida_bitmap), gfp_mask);
+		if (!bitmap)
+			return 0;
+
+		free_bitmap(ida, bitmap);
+	}
+
+	return 1;
+}
+EXPORT_SYMBOL(ida_pre_get);
+
+/**
+ * ida_get_new_above - allocate new ID above or equal to a start id
+ * @ida:	ida handle
+ * @staring_id:	id to start search at
+ * @p_id:	pointer to the allocated handle
+ *
+ * Allocate new ID above or equal to @ida.  It should be called with
+ * any required locks.
+ *
+ * If memory is required, it will return -EAGAIN, you should unlock
+ * and go back to the ida_pre_get() call.  If the ida is full, it will
+ * return -ENOSPC.
+ *
+ * @p_id returns a value in the range 0 ... 0x7fffffff.
+ */
+int ida_get_new_above(struct ida *ida, int starting_id, int *p_id)
+{
+	struct idr_layer *pa[MAX_LEVEL];
+	struct ida_bitmap *bitmap;
+	unsigned long flags;
+	int idr_id = starting_id / IDA_BITMAP_BITS;
+	int offset = starting_id % IDA_BITMAP_BITS;
+	int t, id;
+
+ restart:
+	/* get vacant slot */
+	t = idr_get_empty_slot(&ida->idr, idr_id, pa);
+	if (t < 0) {
+		if (t == -1)
+			return -EAGAIN;
+		else /* will be -3 */
+			return -ENOSPC;
+	}
+
+	if (t * IDA_BITMAP_BITS >= MAX_ID_BIT)
+		return -ENOSPC;
+
+	if (t != idr_id)
+		offset = 0;
+	idr_id = t;
+
+	/* if bitmap isn't there, create a new one */
+	bitmap = (void *)pa[0]->ary[idr_id & IDR_MASK];
+	if (!bitmap) {
+		spin_lock_irqsave(&ida->idr.lock, flags);
+		bitmap = ida->free_bitmap;
+		ida->free_bitmap = NULL;
+		spin_unlock_irqrestore(&ida->idr.lock, flags);
+
+		if (!bitmap)
+			return -EAGAIN;
+
+		memset(bitmap, 0, sizeof(struct ida_bitmap));
+		pa[0]->ary[idr_id & IDR_MASK] = (void *)bitmap;
+		pa[0]->count++;
+	}
+
+	/* lookup for empty slot */
+	t = find_next_zero_bit(bitmap->bitmap, IDA_BITMAP_BITS, offset);
+	if (t == IDA_BITMAP_BITS) {
+		/* no empty slot after offset, continue to the next chunk */
+		idr_id++;
+		offset = 0;
+		goto restart;
+	}
+
+	id = idr_id * IDA_BITMAP_BITS + t;
+	if (id >= MAX_ID_BIT)
+		return -ENOSPC;
+
+	__set_bit(t, bitmap->bitmap);
+	if (++bitmap->nr_busy == IDA_BITMAP_BITS)
+		idr_mark_full(pa, idr_id);
+
+	*p_id = id;
+
+	/* Each leaf node can handle nearly a thousand slots and the
+	 * whole idea of ida is to have small memory foot print.
+	 * Throw away extra resources one by one after each successful
+	 * allocation.
+	 */
+	if (ida->idr.id_free_cnt || ida->free_bitmap) {
+		struct idr_layer *p = alloc_layer(&ida->idr);
+		if (p)
+			kmem_cache_free(idr_layer_cache, p);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ida_get_new_above);
+
+/**
+ * ida_get_new - allocate new ID
+ * @ida:	idr handle
+ * @p_id:	pointer to the allocated handle
+ *
+ * Allocate new ID.  It should be called with any required locks.
+ *
+ * If memory is required, it will return -EAGAIN, you should unlock
+ * and go back to the idr_pre_get() call.  If the idr is full, it will
+ * return -ENOSPC.
+ *
+ * @id returns a value in the range 0 ... 0x7fffffff.
+ */
+int ida_get_new(struct ida *ida, int *p_id)
+{
+	return ida_get_new_above(ida, 0, p_id);
+}
+EXPORT_SYMBOL(ida_get_new);
+
+/**
+ * ida_remove - remove the given ID
+ * @ida:	ida handle
+ * @id:		ID to free
+ */
+void ida_remove(struct ida *ida, int id)
+{
+	struct idr_layer *p = ida->idr.top;
+	int shift = (ida->idr.layers - 1) * IDR_BITS;
+	int idr_id = id / IDA_BITMAP_BITS;
+	int offset = id % IDA_BITMAP_BITS;
+	int n;
+	struct ida_bitmap *bitmap;
+
+	/* clear full bits while looking up the leaf idr_layer */
+	while ((shift > 0) && p) {
+		n = (idr_id >> shift) & IDR_MASK;
+		__clear_bit(n, &p->bitmap);
+		p = p->ary[n];
+		shift -= IDR_BITS;
+	}
+
+	if (p == NULL)
+		goto err;
+
+	n = idr_id & IDR_MASK;
+	__clear_bit(n, &p->bitmap);
+
+	bitmap = (void *)p->ary[n];
+	if (!test_bit(offset, bitmap->bitmap))
+		goto err;
+
+	/* update bitmap and remove it if empty */
+	__clear_bit(offset, bitmap->bitmap);
+	if (--bitmap->nr_busy == 0) {
+		__set_bit(n, &p->bitmap);	/* to please idr_remove() */
+		idr_remove(&ida->idr, idr_id);
+		free_bitmap(ida, bitmap);
+	}
+
+	return;
+
+ err:
+	printk(KERN_WARNING
+	       "ida_remove called for id=%d which is not allocated.\n", id);
+}
+EXPORT_SYMBOL(ida_remove);
+
+/**
+ * ida_destroy - release all cached layers within an ida tree
+ * ida:		ida handle
+ */
+void ida_destroy(struct ida *ida)
+{
+	idr_destroy(&ida->idr);
+	kfree(ida->free_bitmap);
+}
+EXPORT_SYMBOL(ida_destroy);
+
+/**
+ * ida_init - initialize ida handle
+ * @ida:	ida handle
+ *
+ * This function is use to set up the handle (@ida) that you will pass
+ * to the rest of the functions.
+ */
+void ida_init(struct ida *ida)
+{
+	memset(ida, 0, sizeof(struct ida));
+	idr_init(&ida->idr);
+
+}
+EXPORT_SYMBOL(ida_init);
diff -Nurb linux-2.6.22-590/lib/kobject.c linux-2.6.22-try2-netns/lib/kobject.c
--- linux-2.6.22-590/lib/kobject.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/lib/kobject.c	2007-12-21 14:26:58.000000000 -0500
@@ -44,11 +44,11 @@
 	return error;
 }
 
-static int create_dir(struct kobject *kobj, struct sysfs_dirent *shadow_parent)
+static int create_dir(struct kobject * kobj)
 {
 	int error = 0;
 	if (kobject_name(kobj)) {
-		error = sysfs_create_dir(kobj, shadow_parent);
+		error = sysfs_create_dir(kobj);
 		if (!error) {
 			if ((error = populate_dir(kobj)))
 				sysfs_remove_dir(kobj);
@@ -157,12 +157,11 @@
 }
 
 /**
- *	kobject_shadow_add - add an object to the hierarchy.
+ *	kobject_add - add an object to the hierarchy.
  *	@kobj:	object.
- *	@shadow_parent: sysfs directory to add to.
  */
 
-int kobject_shadow_add(struct kobject *kobj, struct sysfs_dirent *shadow_parent)
+int kobject_add(struct kobject * kobj)
 {
 	int error = 0;
 	struct kobject * parent;
@@ -194,7 +193,7 @@
 		kobj->parent = parent;
 	}
 
-	error = create_dir(kobj, shadow_parent);
+	error = create_dir(kobj);
 	if (error) {
 		/* unlink does the kobject_put() for us */
 		unlink(kobj);
@@ -216,16 +215,6 @@
 }
 
 /**
- *	kobject_add - add an object to the hierarchy.
- *	@kobj:	object.
- */
-int kobject_add(struct kobject * kobj)
-{
-	return kobject_shadow_add(kobj, NULL);
-}
-
-
-/**
  *	kobject_register - initialize and add an object.
  *	@kobj:	object in question.
  */
@@ -338,7 +327,7 @@
 	/* Note : if we want to send the new name alone, not the full path,
 	 * we could probably use kobject_name(kobj); */
 
-	error = sysfs_rename_dir(kobj, kobj->parent->sd, new_name);
+	error = sysfs_rename_dir(kobj, new_name);
 
 	/* This function is mostly/only used for network interface.
 	 * Some hotplug package track interfaces by their name and
@@ -355,27 +344,6 @@
 }
 
 /**
- *	kobject_rename - change the name of an object
- *	@kobj:	object in question.
- *	@new_parent: object's new parent
- *	@new_name: object's new name
- */
-
-int kobject_shadow_rename(struct kobject *kobj,
-			  struct sysfs_dirent *new_parent, const char *new_name)
-{
-	int error = 0;
-
-	kobj = kobject_get(kobj);
-	if (!kobj)
-		return -EINVAL;
-	error = sysfs_rename_dir(kobj, new_parent, new_name);
-	kobject_put(kobj);
-
-	return error;
-}
-
-/**
  *	kobject_move - move object to another parent
  *	@kobj:	object in question.
  *	@new_parent: object's new parent (can be NULL)
diff -Nurb linux-2.6.22-590/lib/kobject_uevent.c linux-2.6.22-try2-netns/lib/kobject_uevent.c
--- linux-2.6.22-590/lib/kobject_uevent.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/lib/kobject_uevent.c	2007-12-19 22:49:18.000000000 -0500
@@ -290,9 +290,8 @@
 #if defined(CONFIG_NET)
 static int __init kobject_uevent_init(void)
 {
-	uevent_sock = netlink_kernel_create(NETLINK_KOBJECT_UEVENT, 1, NULL,
-					    NULL, THIS_MODULE);
-
+	uevent_sock = netlink_kernel_create(&init_net, NETLINK_KOBJECT_UEVENT,
+					    1, NULL, NULL, THIS_MODULE);
 	if (!uevent_sock) {
 		printk(KERN_ERR
 		       "kobject_uevent: unable to create netlink socket!\n");
diff -Nurb linux-2.6.22-590/mm/shmem.c.orig linux-2.6.22-try2-netns/mm/shmem.c.orig
--- linux-2.6.22-590/mm/shmem.c.orig	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/mm/shmem.c.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,2619 +0,0 @@
-/*
- * Resizable virtual memory filesystem for Linux.
- *
- * Copyright (C) 2000 Linus Torvalds.
- *		 2000 Transmeta Corp.
- *		 2000-2001 Christoph Rohland
- *		 2000-2001 SAP AG
- *		 2002 Red Hat Inc.
- * Copyright (C) 2002-2005 Hugh Dickins.
- * Copyright (C) 2002-2005 VERITAS Software Corporation.
- * Copyright (C) 2004 Andi Kleen, SuSE Labs
- *
- * Extended attribute support for tmpfs:
- * Copyright (c) 2004, Luke Kenneth Casson Leighton <lkcl@lkcl.net>
- * Copyright (c) 2004 Red Hat, Inc., James Morris <jmorris@redhat.com>
- *
- * This file is released under the GPL.
- */
-
-/*
- * This virtual memory filesystem is heavily based on the ramfs. It
- * extends ramfs by the ability to use swap and honor resource limits
- * which makes it a completely usable filesystem.
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/fs.h>
-#include <linux/xattr.h>
-#include <linux/generic_acl.h>
-#include <linux/mm.h>
-#include <linux/mman.h>
-#include <linux/file.h>
-#include <linux/swap.h>
-#include <linux/pagemap.h>
-#include <linux/string.h>
-#include <linux/slab.h>
-#include <linux/backing-dev.h>
-#include <linux/shmem_fs.h>
-#include <linux/mount.h>
-#include <linux/writeback.h>
-#include <linux/vfs.h>
-#include <linux/blkdev.h>
-#include <linux/security.h>
-#include <linux/swapops.h>
-#include <linux/mempolicy.h>
-#include <linux/namei.h>
-#include <linux/ctype.h>
-#include <linux/migrate.h>
-#include <linux/highmem.h>
-#include <linux/backing-dev.h>
-
-#include <asm/uaccess.h>
-#include <asm/div64.h>
-#include <asm/pgtable.h>
-
-/* This magic number is used in glibc for posix shared memory */
-#define TMPFS_MAGIC	0x01021994
-
-#define ENTRIES_PER_PAGE (PAGE_CACHE_SIZE/sizeof(unsigned long))
-#define ENTRIES_PER_PAGEPAGE (ENTRIES_PER_PAGE*ENTRIES_PER_PAGE)
-#define BLOCKS_PER_PAGE  (PAGE_CACHE_SIZE/512)
-
-#define SHMEM_MAX_INDEX  (SHMEM_NR_DIRECT + (ENTRIES_PER_PAGEPAGE/2) * (ENTRIES_PER_PAGE+1))
-#define SHMEM_MAX_BYTES  ((unsigned long long)SHMEM_MAX_INDEX << PAGE_CACHE_SHIFT)
-
-#define VM_ACCT(size)    (PAGE_CACHE_ALIGN(size) >> PAGE_SHIFT)
-
-/* info->flags needs VM_flags to handle pagein/truncate races efficiently */
-#define SHMEM_PAGEIN	 VM_READ
-#define SHMEM_TRUNCATE	 VM_WRITE
-
-/* Definition to limit shmem_truncate's steps between cond_rescheds */
-#define LATENCY_LIMIT	 64
-
-/* Pretend that each entry is of this size in directory's i_size */
-#define BOGO_DIRENT_SIZE 20
-
-/* Flag allocation requirements to shmem_getpage and shmem_swp_alloc */
-enum sgp_type {
-	SGP_QUICK,	/* don't try more than file page cache lookup */
-	SGP_READ,	/* don't exceed i_size, don't allocate page */
-	SGP_CACHE,	/* don't exceed i_size, may allocate page */
-	SGP_WRITE,	/* may exceed i_size, may allocate page */
-};
-
-static int shmem_getpage(struct inode *inode, unsigned long idx,
-			 struct page **pagep, enum sgp_type sgp, int *type);
-
-static inline struct page *shmem_dir_alloc(gfp_t gfp_mask)
-{
-	/*
-	 * The above definition of ENTRIES_PER_PAGE, and the use of
-	 * BLOCKS_PER_PAGE on indirect pages, assume PAGE_CACHE_SIZE:
-	 * might be reconsidered if it ever diverges from PAGE_SIZE.
-	 */
-	return alloc_pages(gfp_mask, PAGE_CACHE_SHIFT-PAGE_SHIFT);
-}
-
-static inline void shmem_dir_free(struct page *page)
-{
-	__free_pages(page, PAGE_CACHE_SHIFT-PAGE_SHIFT);
-}
-
-static struct page **shmem_dir_map(struct page *page)
-{
-	return (struct page **)kmap_atomic(page, KM_USER0);
-}
-
-static inline void shmem_dir_unmap(struct page **dir)
-{
-	kunmap_atomic(dir, KM_USER0);
-}
-
-static swp_entry_t *shmem_swp_map(struct page *page)
-{
-	return (swp_entry_t *)kmap_atomic(page, KM_USER1);
-}
-
-static inline void shmem_swp_balance_unmap(void)
-{
-	/*
-	 * When passing a pointer to an i_direct entry, to code which
-	 * also handles indirect entries and so will shmem_swp_unmap,
-	 * we must arrange for the preempt count to remain in balance.
-	 * What kmap_atomic of a lowmem page does depends on config
-	 * and architecture, so pretend to kmap_atomic some lowmem page.
-	 */
-	(void) kmap_atomic(ZERO_PAGE(0), KM_USER1);
-}
-
-static inline void shmem_swp_unmap(swp_entry_t *entry)
-{
-	kunmap_atomic(entry, KM_USER1);
-}
-
-static inline struct shmem_sb_info *SHMEM_SB(struct super_block *sb)
-{
-	return sb->s_fs_info;
-}
-
-/*
- * shmem_file_setup pre-accounts the whole fixed size of a VM object,
- * for shared memory and for shared anonymous (/dev/zero) mappings
- * (unless MAP_NORESERVE and sysctl_overcommit_memory <= 1),
- * consistent with the pre-accounting of private mappings ...
- */
-static inline int shmem_acct_size(unsigned long flags, loff_t size)
-{
-	return (flags & VM_ACCOUNT)?
-		security_vm_enough_memory(VM_ACCT(size)): 0;
-}
-
-static inline void shmem_unacct_size(unsigned long flags, loff_t size)
-{
-	if (flags & VM_ACCOUNT)
-		vm_unacct_memory(VM_ACCT(size));
-}
-
-/*
- * ... whereas tmpfs objects are accounted incrementally as
- * pages are allocated, in order to allow huge sparse files.
- * shmem_getpage reports shmem_acct_block failure as -ENOSPC not -ENOMEM,
- * so that a failure on a sparse tmpfs mapping will give SIGBUS not OOM.
- */
-static inline int shmem_acct_block(unsigned long flags)
-{
-	return (flags & VM_ACCOUNT)?
-		0: security_vm_enough_memory(VM_ACCT(PAGE_CACHE_SIZE));
-}
-
-static inline void shmem_unacct_blocks(unsigned long flags, long pages)
-{
-	if (!(flags & VM_ACCOUNT))
-		vm_unacct_memory(pages * VM_ACCT(PAGE_CACHE_SIZE));
-}
-
-static const struct super_operations shmem_ops;
-static const struct address_space_operations shmem_aops;
-static const struct file_operations shmem_file_operations;
-static const struct inode_operations shmem_inode_operations;
-static const struct inode_operations shmem_dir_inode_operations;
-static const struct inode_operations shmem_special_inode_operations;
-static struct vm_operations_struct shmem_vm_ops;
-
-static struct backing_dev_info shmem_backing_dev_info  __read_mostly = {
-	.ra_pages	= 0,	/* No readahead */
-	.capabilities	= BDI_CAP_NO_ACCT_DIRTY | BDI_CAP_NO_WRITEBACK,
-	.unplug_io_fn	= default_unplug_io_fn,
-};
-
-static LIST_HEAD(shmem_swaplist);
-static DEFINE_SPINLOCK(shmem_swaplist_lock);
-
-static void shmem_free_blocks(struct inode *inode, long pages)
-{
-	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
-	if (sbinfo->max_blocks) {
-		spin_lock(&sbinfo->stat_lock);
-		sbinfo->free_blocks += pages;
-		inode->i_blocks -= pages*BLOCKS_PER_PAGE;
-		spin_unlock(&sbinfo->stat_lock);
-	}
-}
-
-/*
- * shmem_recalc_inode - recalculate the size of an inode
- *
- * @inode: inode to recalc
- *
- * We have to calculate the free blocks since the mm can drop
- * undirtied hole pages behind our back.
- *
- * But normally   info->alloced == inode->i_mapping->nrpages + info->swapped
- * So mm freed is info->alloced - (inode->i_mapping->nrpages + info->swapped)
- *
- * It has to be called with the spinlock held.
- */
-static void shmem_recalc_inode(struct inode *inode)
-{
-	struct shmem_inode_info *info = SHMEM_I(inode);
-	long freed;
-
-	freed = info->alloced - info->swapped - inode->i_mapping->nrpages;
-	if (freed > 0) {
-		info->alloced -= freed;
-		shmem_unacct_blocks(info->flags, freed);
-		shmem_free_blocks(inode, freed);
-	}
-}
-
-/*
- * shmem_swp_entry - find the swap vector position in the info structure
- *
- * @info:  info structure for the inode
- * @index: index of the page to find
- * @page:  optional page to add to the structure. Has to be preset to
- *         all zeros
- *
- * If there is no space allocated yet it will return NULL when
- * page is NULL, else it will use the page for the needed block,
- * setting it to NULL on return to indicate that it has been used.
- *
- * The swap vector is organized the following way:
- *
- * There are SHMEM_NR_DIRECT entries directly stored in the
- * shmem_inode_info structure. So small files do not need an addional
- * allocation.
- *
- * For pages with index > SHMEM_NR_DIRECT there is the pointer
- * i_indirect which points to a page which holds in the first half
- * doubly indirect blocks, in the second half triple indirect blocks:
- *
- * For an artificial ENTRIES_PER_PAGE = 4 this would lead to the
- * following layout (for SHMEM_NR_DIRECT == 16):
- *
- * i_indirect -> dir --> 16-19
- * 	      |	     +-> 20-23
- * 	      |
- * 	      +-->dir2 --> 24-27
- * 	      |	       +-> 28-31
- * 	      |	       +-> 32-35
- * 	      |	       +-> 36-39
- * 	      |
- * 	      +-->dir3 --> 40-43
- * 	       	       +-> 44-47
- * 	      	       +-> 48-51
- * 	      	       +-> 52-55
- */
-static swp_entry_t *shmem_swp_entry(struct shmem_inode_info *info, unsigned long index, struct page **page)
-{
-	unsigned long offset;
-	struct page **dir;
-	struct page *subdir;
-
-	if (index < SHMEM_NR_DIRECT) {
-		shmem_swp_balance_unmap();
-		return info->i_direct+index;
-	}
-	if (!info->i_indirect) {
-		if (page) {
-			info->i_indirect = *page;
-			*page = NULL;
-		}
-		return NULL;			/* need another page */
-	}
-
-	index -= SHMEM_NR_DIRECT;
-	offset = index % ENTRIES_PER_PAGE;
-	index /= ENTRIES_PER_PAGE;
-	dir = shmem_dir_map(info->i_indirect);
-
-	if (index >= ENTRIES_PER_PAGE/2) {
-		index -= ENTRIES_PER_PAGE/2;
-		dir += ENTRIES_PER_PAGE/2 + index/ENTRIES_PER_PAGE;
-		index %= ENTRIES_PER_PAGE;
-		subdir = *dir;
-		if (!subdir) {
-			if (page) {
-				*dir = *page;
-				*page = NULL;
-			}
-			shmem_dir_unmap(dir);
-			return NULL;		/* need another page */
-		}
-		shmem_dir_unmap(dir);
-		dir = shmem_dir_map(subdir);
-	}
-
-	dir += index;
-	subdir = *dir;
-	if (!subdir) {
-		if (!page || !(subdir = *page)) {
-			shmem_dir_unmap(dir);
-			return NULL;		/* need a page */
-		}
-		*dir = subdir;
-		*page = NULL;
-	}
-	shmem_dir_unmap(dir);
-	return shmem_swp_map(subdir) + offset;
-}
-
-static void shmem_swp_set(struct shmem_inode_info *info, swp_entry_t *entry, unsigned long value)
-{
-	long incdec = value? 1: -1;
-
-	entry->val = value;
-	info->swapped += incdec;
-	if ((unsigned long)(entry - info->i_direct) >= SHMEM_NR_DIRECT) {
-		struct page *page = kmap_atomic_to_page(entry);
-		set_page_private(page, page_private(page) + incdec);
-	}
-}
-
-/*
- * shmem_swp_alloc - get the position of the swap entry for the page.
- *                   If it does not exist allocate the entry.
- *
- * @info:	info structure for the inode
- * @index:	index of the page to find
- * @sgp:	check and recheck i_size? skip allocation?
- */
-static swp_entry_t *shmem_swp_alloc(struct shmem_inode_info *info, unsigned long index, enum sgp_type sgp)
-{
-	struct inode *inode = &info->vfs_inode;
-	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
-	struct page *page = NULL;
-	swp_entry_t *entry;
-
-	if (sgp != SGP_WRITE &&
-	    ((loff_t) index << PAGE_CACHE_SHIFT) >= i_size_read(inode))
-		return ERR_PTR(-EINVAL);
-
-	while (!(entry = shmem_swp_entry(info, index, &page))) {
-		if (sgp == SGP_READ)
-			return shmem_swp_map(ZERO_PAGE(0));
-		/*
-		 * Test free_blocks against 1 not 0, since we have 1 data
-		 * page (and perhaps indirect index pages) yet to allocate:
-		 * a waste to allocate index if we cannot allocate data.
-		 */
-		if (sbinfo->max_blocks) {
-			spin_lock(&sbinfo->stat_lock);
-			if (sbinfo->free_blocks <= 1) {
-				spin_unlock(&sbinfo->stat_lock);
-				return ERR_PTR(-ENOSPC);
-			}
-			sbinfo->free_blocks--;
-			inode->i_blocks += BLOCKS_PER_PAGE;
-			spin_unlock(&sbinfo->stat_lock);
-		}
-
-		spin_unlock(&info->lock);
-		page = shmem_dir_alloc(mapping_gfp_mask(inode->i_mapping) | __GFP_ZERO);
-		if (page)
-			set_page_private(page, 0);
-		spin_lock(&info->lock);
-
-		if (!page) {
-			shmem_free_blocks(inode, 1);
-			return ERR_PTR(-ENOMEM);
-		}
-		if (sgp != SGP_WRITE &&
-		    ((loff_t) index << PAGE_CACHE_SHIFT) >= i_size_read(inode)) {
-			entry = ERR_PTR(-EINVAL);
-			break;
-		}
-		if (info->next_index <= index)
-			info->next_index = index + 1;
-	}
-	if (page) {
-		/* another task gave its page, or truncated the file */
-		shmem_free_blocks(inode, 1);
-		shmem_dir_free(page);
-	}
-	if (info->next_index <= index && !IS_ERR(entry))
-		info->next_index = index + 1;
-	return entry;
-}
-
-/*
- * shmem_free_swp - free some swap entries in a directory
- *
- * @dir:        pointer to the directory
- * @edir:       pointer after last entry of the directory
- * @punch_lock: pointer to spinlock when needed for the holepunch case
- */
-static int shmem_free_swp(swp_entry_t *dir, swp_entry_t *edir,
-						spinlock_t *punch_lock)
-{
-	spinlock_t *punch_unlock = NULL;
-	swp_entry_t *ptr;
-	int freed = 0;
-
-	for (ptr = dir; ptr < edir; ptr++) {
-		if (ptr->val) {
-			if (unlikely(punch_lock)) {
-				punch_unlock = punch_lock;
-				punch_lock = NULL;
-				spin_lock(punch_unlock);
-				if (!ptr->val)
-					continue;
-			}
-			free_swap_and_cache(*ptr);
-			*ptr = (swp_entry_t){0};
-			freed++;
-		}
-	}
-	if (punch_unlock)
-		spin_unlock(punch_unlock);
-	return freed;
-}
-
-static int shmem_map_and_free_swp(struct page *subdir, int offset,
-		int limit, struct page ***dir, spinlock_t *punch_lock)
-{
-	swp_entry_t *ptr;
-	int freed = 0;
-
-	ptr = shmem_swp_map(subdir);
-	for (; offset < limit; offset += LATENCY_LIMIT) {
-		int size = limit - offset;
-		if (size > LATENCY_LIMIT)
-			size = LATENCY_LIMIT;
-		freed += shmem_free_swp(ptr+offset, ptr+offset+size,
-							punch_lock);
-		if (need_resched()) {
-			shmem_swp_unmap(ptr);
-			if (*dir) {
-				shmem_dir_unmap(*dir);
-				*dir = NULL;
-			}
-			cond_resched();
-			ptr = shmem_swp_map(subdir);
-		}
-	}
-	shmem_swp_unmap(ptr);
-	return freed;
-}
-
-static void shmem_free_pages(struct list_head *next)
-{
-	struct page *page;
-	int freed = 0;
-
-	do {
-		page = container_of(next, struct page, lru);
-		next = next->next;
-		shmem_dir_free(page);
-		freed++;
-		if (freed >= LATENCY_LIMIT) {
-			cond_resched();
-			freed = 0;
-		}
-	} while (next);
-}
-
-static void shmem_truncate_range(struct inode *inode, loff_t start, loff_t end)
-{
-	struct shmem_inode_info *info = SHMEM_I(inode);
-	unsigned long idx;
-	unsigned long size;
-	unsigned long limit;
-	unsigned long stage;
-	unsigned long diroff;
-	struct page **dir;
-	struct page *topdir;
-	struct page *middir;
-	struct page *subdir;
-	swp_entry_t *ptr;
-	LIST_HEAD(pages_to_free);
-	long nr_pages_to_free = 0;
-	long nr_swaps_freed = 0;
-	int offset;
-	int freed;
-	int punch_hole;
-	spinlock_t *needs_lock;
-	spinlock_t *punch_lock;
-	unsigned long upper_limit;
-
-	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
-	idx = (start + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
-	if (idx >= info->next_index)
-		return;
-
-	spin_lock(&info->lock);
-	info->flags |= SHMEM_TRUNCATE;
-	if (likely(end == (loff_t) -1)) {
-		limit = info->next_index;
-		upper_limit = SHMEM_MAX_INDEX;
-		info->next_index = idx;
-		needs_lock = NULL;
-		punch_hole = 0;
-	} else {
-		if (end + 1 >= inode->i_size) {	/* we may free a little more */
-			limit = (inode->i_size + PAGE_CACHE_SIZE - 1) >>
-							PAGE_CACHE_SHIFT;
-			upper_limit = SHMEM_MAX_INDEX;
-		} else {
-			limit = (end + 1) >> PAGE_CACHE_SHIFT;
-			upper_limit = limit;
-		}
-		needs_lock = &info->lock;
-		punch_hole = 1;
-	}
-
-	topdir = info->i_indirect;
-	if (topdir && idx <= SHMEM_NR_DIRECT && !punch_hole) {
-		info->i_indirect = NULL;
-		nr_pages_to_free++;
-		list_add(&topdir->lru, &pages_to_free);
-	}
-	spin_unlock(&info->lock);
-
-	if (info->swapped && idx < SHMEM_NR_DIRECT) {
-		ptr = info->i_direct;
-		size = limit;
-		if (size > SHMEM_NR_DIRECT)
-			size = SHMEM_NR_DIRECT;
-		nr_swaps_freed = shmem_free_swp(ptr+idx, ptr+size, needs_lock);
-	}
-
-	/*
-	 * If there are no indirect blocks or we are punching a hole
-	 * below indirect blocks, nothing to be done.
-	 */
-	if (!topdir || limit <= SHMEM_NR_DIRECT)
-		goto done2;
-
-	/*
-	 * The truncation case has already dropped info->lock, and we're safe
-	 * because i_size and next_index have already been lowered, preventing
-	 * access beyond.  But in the punch_hole case, we still need to take
-	 * the lock when updating the swap directory, because there might be
-	 * racing accesses by shmem_getpage(SGP_CACHE), shmem_unuse_inode or
-	 * shmem_writepage.  However, whenever we find we can remove a whole
-	 * directory page (not at the misaligned start or end of the range),
-	 * we first NULLify its pointer in the level above, and then have no
-	 * need to take the lock when updating its contents: needs_lock and
-	 * punch_lock (either pointing to info->lock or NULL) manage this.
-	 */
-
-	upper_limit -= SHMEM_NR_DIRECT;
-	limit -= SHMEM_NR_DIRECT;
-	idx = (idx > SHMEM_NR_DIRECT)? (idx - SHMEM_NR_DIRECT): 0;
-	offset = idx % ENTRIES_PER_PAGE;
-	idx -= offset;
-
-	dir = shmem_dir_map(topdir);
-	stage = ENTRIES_PER_PAGEPAGE/2;
-	if (idx < ENTRIES_PER_PAGEPAGE/2) {
-		middir = topdir;
-		diroff = idx/ENTRIES_PER_PAGE;
-	} else {
-		dir += ENTRIES_PER_PAGE/2;
-		dir += (idx - ENTRIES_PER_PAGEPAGE/2)/ENTRIES_PER_PAGEPAGE;
-		while (stage <= idx)
-			stage += ENTRIES_PER_PAGEPAGE;
-		middir = *dir;
-		if (*dir) {
-			diroff = ((idx - ENTRIES_PER_PAGEPAGE/2) %
-				ENTRIES_PER_PAGEPAGE) / ENTRIES_PER_PAGE;
-			if (!diroff && !offset && upper_limit >= stage) {
-				if (needs_lock) {
-					spin_lock(needs_lock);
-					*dir = NULL;
-					spin_unlock(needs_lock);
-					needs_lock = NULL;
-				} else
-					*dir = NULL;
-				nr_pages_to_free++;
-				list_add(&middir->lru, &pages_to_free);
-			}
-			shmem_dir_unmap(dir);
-			dir = shmem_dir_map(middir);
-		} else {
-			diroff = 0;
-			offset = 0;
-			idx = stage;
-		}
-	}
-
-	for (; idx < limit; idx += ENTRIES_PER_PAGE, diroff++) {
-		if (unlikely(idx == stage)) {
-			shmem_dir_unmap(dir);
-			dir = shmem_dir_map(topdir) +
-			    ENTRIES_PER_PAGE/2 + idx/ENTRIES_PER_PAGEPAGE;
-			while (!*dir) {
-				dir++;
-				idx += ENTRIES_PER_PAGEPAGE;
-				if (idx >= limit)
-					goto done1;
-			}
-			stage = idx + ENTRIES_PER_PAGEPAGE;
-			middir = *dir;
-			if (punch_hole)
-				needs_lock = &info->lock;
-			if (upper_limit >= stage) {
-				if (needs_lock) {
-					spin_lock(needs_lock);
-					*dir = NULL;
-					spin_unlock(needs_lock);
-					needs_lock = NULL;
-				} else
-					*dir = NULL;
-				nr_pages_to_free++;
-				list_add(&middir->lru, &pages_to_free);
-			}
-			shmem_dir_unmap(dir);
-			cond_resched();
-			dir = shmem_dir_map(middir);
-			diroff = 0;
-		}
-		punch_lock = needs_lock;
-		subdir = dir[diroff];
-		if (subdir && !offset && upper_limit-idx >= ENTRIES_PER_PAGE) {
-			if (needs_lock) {
-				spin_lock(needs_lock);
-				dir[diroff] = NULL;
-				spin_unlock(needs_lock);
-				punch_lock = NULL;
-			} else
-				dir[diroff] = NULL;
-			nr_pages_to_free++;
-			list_add(&subdir->lru, &pages_to_free);
-		}
-		if (subdir && page_private(subdir) /* has swap entries */) {
-			size = limit - idx;
-			if (size > ENTRIES_PER_PAGE)
-				size = ENTRIES_PER_PAGE;
-			freed = shmem_map_and_free_swp(subdir,
-					offset, size, &dir, punch_lock);
-			if (!dir)
-				dir = shmem_dir_map(middir);
-			nr_swaps_freed += freed;
-			if (offset || punch_lock) {
-				spin_lock(&info->lock);
-				set_page_private(subdir,
-					page_private(subdir) - freed);
-				spin_unlock(&info->lock);
-			} else
-				BUG_ON(page_private(subdir) != freed);
-		}
-		offset = 0;
-	}
-done1:
-	shmem_dir_unmap(dir);
-done2:
-	if (inode->i_mapping->nrpages && (info->flags & SHMEM_PAGEIN)) {
-		/*
-		 * Call truncate_inode_pages again: racing shmem_unuse_inode
-		 * may have swizzled a page in from swap since vmtruncate or
-		 * generic_delete_inode did it, before we lowered next_index.
-		 * Also, though shmem_getpage checks i_size before adding to
-		 * cache, no recheck after: so fix the narrow window there too.
-		 *
-		 * Recalling truncate_inode_pages_range and unmap_mapping_range
-		 * every time for punch_hole (which never got a chance to clear
-		 * SHMEM_PAGEIN at the start of vmtruncate_range) is expensive,
-		 * yet hardly ever necessary: try to optimize them out later.
-		 */
-		truncate_inode_pages_range(inode->i_mapping, start, end);
-		if (punch_hole)
-			unmap_mapping_range(inode->i_mapping, start,
-							end - start, 1);
-	}
-
-	spin_lock(&info->lock);
-	info->flags &= ~SHMEM_TRUNCATE;
-	info->swapped -= nr_swaps_freed;
-	if (nr_pages_to_free)
-		shmem_free_blocks(inode, nr_pages_to_free);
-	shmem_recalc_inode(inode);
-	spin_unlock(&info->lock);
-
-	/*
-	 * Empty swap vector directory pages to be freed?
-	 */
-	if (!list_empty(&pages_to_free)) {
-		pages_to_free.prev->next = NULL;
-		shmem_free_pages(pages_to_free.next);
-	}
-}
-
-static void shmem_truncate(struct inode *inode)
-{
-	shmem_truncate_range(inode, inode->i_size, (loff_t)-1);
-}
-
-static int shmem_notify_change(struct dentry *dentry, struct iattr *attr)
-{
-	struct inode *inode = dentry->d_inode;
-	struct page *page = NULL;
-	int error;
-
-	if (S_ISREG(inode->i_mode) && (attr->ia_valid & ATTR_SIZE)) {
-		if (attr->ia_size < inode->i_size) {
-			/*
-			 * If truncating down to a partial page, then
-			 * if that page is already allocated, hold it
-			 * in memory until the truncation is over, so
-			 * truncate_partial_page cannnot miss it were
-			 * it assigned to swap.
-			 */
-			if (attr->ia_size & (PAGE_CACHE_SIZE-1)) {
-				(void) shmem_getpage(inode,
-					attr->ia_size>>PAGE_CACHE_SHIFT,
-						&page, SGP_READ, NULL);
-			}
-			/*
-			 * Reset SHMEM_PAGEIN flag so that shmem_truncate can
-			 * detect if any pages might have been added to cache
-			 * after truncate_inode_pages.  But we needn't bother
-			 * if it's being fully truncated to zero-length: the
-			 * nrpages check is efficient enough in that case.
-			 */
-			if (attr->ia_size) {
-				struct shmem_inode_info *info = SHMEM_I(inode);
-				spin_lock(&info->lock);
-				info->flags &= ~SHMEM_PAGEIN;
-				spin_unlock(&info->lock);
-			}
-		}
-	}
-
-	error = inode_change_ok(inode, attr);
-	if (!error)
-		error = inode_setattr(inode, attr);
-#ifdef CONFIG_TMPFS_POSIX_ACL
-	if (!error && (attr->ia_valid & ATTR_MODE))
-		error = generic_acl_chmod(inode, &shmem_acl_ops);
-#endif
-	if (page)
-		page_cache_release(page);
-	return error;
-}
-
-static void shmem_delete_inode(struct inode *inode)
-{
-	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
-	struct shmem_inode_info *info = SHMEM_I(inode);
-
-	if (inode->i_op->truncate == shmem_truncate) {
-		truncate_inode_pages(inode->i_mapping, 0);
-		shmem_unacct_size(info->flags, inode->i_size);
-		inode->i_size = 0;
-		shmem_truncate(inode);
-		if (!list_empty(&info->swaplist)) {
-			spin_lock(&shmem_swaplist_lock);
-			list_del_init(&info->swaplist);
-			spin_unlock(&shmem_swaplist_lock);
-		}
-	}
-	BUG_ON(inode->i_blocks);
-	if (sbinfo->max_inodes) {
-		spin_lock(&sbinfo->stat_lock);
-		sbinfo->free_inodes++;
-		spin_unlock(&sbinfo->stat_lock);
-	}
-	clear_inode(inode);
-}
-
-static inline int shmem_find_swp(swp_entry_t entry, swp_entry_t *dir, swp_entry_t *edir)
-{
-	swp_entry_t *ptr;
-
-	for (ptr = dir; ptr < edir; ptr++) {
-		if (ptr->val == entry.val)
-			return ptr - dir;
-	}
-	return -1;
-}
-
-static int shmem_unuse_inode(struct shmem_inode_info *info, swp_entry_t entry, struct page *page)
-{
-	struct inode *inode;
-	unsigned long idx;
-	unsigned long size;
-	unsigned long limit;
-	unsigned long stage;
-	struct page **dir;
-	struct page *subdir;
-	swp_entry_t *ptr;
-	int offset;
-
-	idx = 0;
-	ptr = info->i_direct;
-	spin_lock(&info->lock);
-	limit = info->next_index;
-	size = limit;
-	if (size > SHMEM_NR_DIRECT)
-		size = SHMEM_NR_DIRECT;
-	offset = shmem_find_swp(entry, ptr, ptr+size);
-	if (offset >= 0) {
-		shmem_swp_balance_unmap();
-		goto found;
-	}
-	if (!info->i_indirect)
-		goto lost2;
-
-	dir = shmem_dir_map(info->i_indirect);
-	stage = SHMEM_NR_DIRECT + ENTRIES_PER_PAGEPAGE/2;
-
-	for (idx = SHMEM_NR_DIRECT; idx < limit; idx += ENTRIES_PER_PAGE, dir++) {
-		if (unlikely(idx == stage)) {
-			shmem_dir_unmap(dir-1);
-			dir = shmem_dir_map(info->i_indirect) +
-			    ENTRIES_PER_PAGE/2 + idx/ENTRIES_PER_PAGEPAGE;
-			while (!*dir) {
-				dir++;
-				idx += ENTRIES_PER_PAGEPAGE;
-				if (idx >= limit)
-					goto lost1;
-			}
-			stage = idx + ENTRIES_PER_PAGEPAGE;
-			subdir = *dir;
-			shmem_dir_unmap(dir);
-			dir = shmem_dir_map(subdir);
-		}
-		subdir = *dir;
-		if (subdir && page_private(subdir)) {
-			ptr = shmem_swp_map(subdir);
-			size = limit - idx;
-			if (size > ENTRIES_PER_PAGE)
-				size = ENTRIES_PER_PAGE;
-			offset = shmem_find_swp(entry, ptr, ptr+size);
-			if (offset >= 0) {
-				shmem_dir_unmap(dir);
-				goto found;
-			}
-			shmem_swp_unmap(ptr);
-		}
-	}
-lost1:
-	shmem_dir_unmap(dir-1);
-lost2:
-	spin_unlock(&info->lock);
-	return 0;
-found:
-	idx += offset;
-	inode = &info->vfs_inode;
-	if (move_from_swap_cache(page, idx, inode->i_mapping) == 0) {
-		info->flags |= SHMEM_PAGEIN;
-		shmem_swp_set(info, ptr + offset, 0);
-	}
-	shmem_swp_unmap(ptr);
-	spin_unlock(&info->lock);
-	/*
-	 * Decrement swap count even when the entry is left behind:
-	 * try_to_unuse will skip over mms, then reincrement count.
-	 */
-	swap_free(entry);
-	return 1;
-}
-
-/*
- * shmem_unuse() search for an eventually swapped out shmem page.
- */
-int shmem_unuse(swp_entry_t entry, struct page *page)
-{
-	struct list_head *p, *next;
-	struct shmem_inode_info *info;
-	int found = 0;
-
-	spin_lock(&shmem_swaplist_lock);
-	list_for_each_safe(p, next, &shmem_swaplist) {
-		info = list_entry(p, struct shmem_inode_info, swaplist);
-		if (!info->swapped)
-			list_del_init(&info->swaplist);
-		else if (shmem_unuse_inode(info, entry, page)) {
-			/* move head to start search for next from here */
-			list_move_tail(&shmem_swaplist, &info->swaplist);
-			found = 1;
-			break;
-		}
-	}
-	spin_unlock(&shmem_swaplist_lock);
-	return found;
-}
-
-/*
- * Move the page from the page cache to the swap cache.
- */
-static int shmem_writepage(struct page *page, struct writeback_control *wbc)
-{
-	struct shmem_inode_info *info;
-	swp_entry_t *entry, swap;
-	struct address_space *mapping;
-	unsigned long index;
-	struct inode *inode;
-
-	BUG_ON(!PageLocked(page));
-	/*
-	 * shmem_backing_dev_info's capabilities prevent regular writeback or
-	 * sync from ever calling shmem_writepage; but a stacking filesystem
-	 * may use the ->writepage of its underlying filesystem, in which case
-	 * we want to do nothing when that underlying filesystem is tmpfs
-	 * (writing out to swap is useful as a response to memory pressure, but
-	 * of no use to stabilize the data) - just redirty the page, unlock it
-	 * and claim success in this case.  AOP_WRITEPAGE_ACTIVATE, and the
-	 * page_mapped check below, must be avoided unless we're in reclaim.
-	 */
-	if (!wbc->for_reclaim) {
-		set_page_dirty(page);
-		unlock_page(page);
-		return 0;
-	}
-	BUG_ON(page_mapped(page));
-
-	mapping = page->mapping;
-	index = page->index;
-	inode = mapping->host;
-	info = SHMEM_I(inode);
-	if (info->flags & VM_LOCKED)
-		goto redirty;
-	swap = get_swap_page();
-	if (!swap.val)
-		goto redirty;
-
-	spin_lock(&info->lock);
-	shmem_recalc_inode(inode);
-	if (index >= info->next_index) {
-		BUG_ON(!(info->flags & SHMEM_TRUNCATE));
-		goto unlock;
-	}
-	entry = shmem_swp_entry(info, index, NULL);
-	BUG_ON(!entry);
-	BUG_ON(entry->val);
-
-	if (move_to_swap_cache(page, swap) == 0) {
-		shmem_swp_set(info, entry, swap.val);
-		shmem_swp_unmap(entry);
-		spin_unlock(&info->lock);
-		if (list_empty(&info->swaplist)) {
-			spin_lock(&shmem_swaplist_lock);
-			/* move instead of add in case we're racing */
-			list_move_tail(&info->swaplist, &shmem_swaplist);
-			spin_unlock(&shmem_swaplist_lock);
-		}
-		unlock_page(page);
-		return 0;
-	}
-
-	shmem_swp_unmap(entry);
-unlock:
-	spin_unlock(&info->lock);
-	swap_free(swap);
-redirty:
-	set_page_dirty(page);
-	return AOP_WRITEPAGE_ACTIVATE;	/* Return with the page locked */
-}
-
-#ifdef CONFIG_NUMA
-static inline int shmem_parse_mpol(char *value, int *policy, nodemask_t *policy_nodes)
-{
-	char *nodelist = strchr(value, ':');
-	int err = 1;
-
-	if (nodelist) {
-		/* NUL-terminate policy string */
-		*nodelist++ = '\0';
-		if (nodelist_parse(nodelist, *policy_nodes))
-			goto out;
-		if (!nodes_subset(*policy_nodes, node_online_map))
-			goto out;
-	}
-	if (!strcmp(value, "default")) {
-		*policy = MPOL_DEFAULT;
-		/* Don't allow a nodelist */
-		if (!nodelist)
-			err = 0;
-	} else if (!strcmp(value, "prefer")) {
-		*policy = MPOL_PREFERRED;
-		/* Insist on a nodelist of one node only */
-		if (nodelist) {
-			char *rest = nodelist;
-			while (isdigit(*rest))
-				rest++;
-			if (!*rest)
-				err = 0;
-		}
-	} else if (!strcmp(value, "bind")) {
-		*policy = MPOL_BIND;
-		/* Insist on a nodelist */
-		if (nodelist)
-			err = 0;
-	} else if (!strcmp(value, "interleave")) {
-		*policy = MPOL_INTERLEAVE;
-		/* Default to nodes online if no nodelist */
-		if (!nodelist)
-			*policy_nodes = node_online_map;
-		err = 0;
-	}
-out:
-	/* Restore string for error message */
-	if (nodelist)
-		*--nodelist = ':';
-	return err;
-}
-
-static struct page *shmem_swapin_async(struct shared_policy *p,
-				       swp_entry_t entry, unsigned long idx)
-{
-	struct page *page;
-	struct vm_area_struct pvma;
-
-	/* Create a pseudo vma that just contains the policy */
-	memset(&pvma, 0, sizeof(struct vm_area_struct));
-	pvma.vm_end = PAGE_SIZE;
-	pvma.vm_pgoff = idx;
-	pvma.vm_policy = mpol_shared_policy_lookup(p, idx);
-	page = read_swap_cache_async(entry, &pvma, 0);
-	mpol_free(pvma.vm_policy);
-	return page;
-}
-
-struct page *shmem_swapin(struct shmem_inode_info *info, swp_entry_t entry,
-			  unsigned long idx)
-{
-	struct shared_policy *p = &info->policy;
-	int i, num;
-	struct page *page;
-	unsigned long offset;
-
-	num = valid_swaphandles(entry, &offset);
-	for (i = 0; i < num; offset++, i++) {
-		page = shmem_swapin_async(p,
-				swp_entry(swp_type(entry), offset), idx);
-		if (!page)
-			break;
-		page_cache_release(page);
-	}
-	lru_add_drain();	/* Push any new pages onto the LRU now */
-	return shmem_swapin_async(p, entry, idx);
-}
-
-static struct page *
-shmem_alloc_page(gfp_t gfp, struct shmem_inode_info *info,
-		 unsigned long idx)
-{
-	struct vm_area_struct pvma;
-	struct page *page;
-
-	memset(&pvma, 0, sizeof(struct vm_area_struct));
-	pvma.vm_policy = mpol_shared_policy_lookup(&info->policy, idx);
-	pvma.vm_pgoff = idx;
-	pvma.vm_end = PAGE_SIZE;
-	page = alloc_page_vma(gfp | __GFP_ZERO, &pvma, 0);
-	mpol_free(pvma.vm_policy);
-	return page;
-}
-#else
-static inline int shmem_parse_mpol(char *value, int *policy, nodemask_t *policy_nodes)
-{
-	return 1;
-}
-
-static inline struct page *
-shmem_swapin(struct shmem_inode_info *info,swp_entry_t entry,unsigned long idx)
-{
-	swapin_readahead(entry, 0, NULL);
-	return read_swap_cache_async(entry, NULL, 0);
-}
-
-static inline struct page *
-shmem_alloc_page(gfp_t gfp,struct shmem_inode_info *info, unsigned long idx)
-{
-	return alloc_page(gfp | __GFP_ZERO);
-}
-#endif
-
-/*
- * shmem_getpage - either get the page from swap or allocate a new one
- *
- * If we allocate a new one we do not mark it dirty. That's up to the
- * vm. If we swap it in we mark it dirty since we also free the swap
- * entry since a page cannot live in both the swap and page cache
- */
-static int shmem_getpage(struct inode *inode, unsigned long idx,
-			struct page **pagep, enum sgp_type sgp, int *type)
-{
-	struct address_space *mapping = inode->i_mapping;
-	struct shmem_inode_info *info = SHMEM_I(inode);
-	struct shmem_sb_info *sbinfo;
-	struct page *filepage = *pagep;
-	struct page *swappage;
-	swp_entry_t *entry;
-	swp_entry_t swap;
-	int error;
-
-	if (idx >= SHMEM_MAX_INDEX)
-		return -EFBIG;
-	/*
-	 * Normally, filepage is NULL on entry, and either found
-	 * uptodate immediately, or allocated and zeroed, or read
-	 * in under swappage, which is then assigned to filepage.
-	 * But shmem_prepare_write passes in a locked filepage,
-	 * which may be found not uptodate by other callers too,
-	 * and may need to be copied from the swappage read in.
-	 */
-repeat:
-	if (!filepage)
-		filepage = find_lock_page(mapping, idx);
-	if (filepage && PageUptodate(filepage))
-		goto done;
-	error = 0;
-	if (sgp == SGP_QUICK)
-		goto failed;
-
-	spin_lock(&info->lock);
-	shmem_recalc_inode(inode);
-	entry = shmem_swp_alloc(info, idx, sgp);
-	if (IS_ERR(entry)) {
-		spin_unlock(&info->lock);
-		error = PTR_ERR(entry);
-		goto failed;
-	}
-	swap = *entry;
-
-	if (swap.val) {
-		/* Look it up and read it in.. */
-		swappage = lookup_swap_cache(swap);
-		if (!swappage) {
-			shmem_swp_unmap(entry);
-			/* here we actually do the io */
-			if (type && *type == VM_FAULT_MINOR) {
-				__count_vm_event(PGMAJFAULT);
-				*type = VM_FAULT_MAJOR;
-			}
-			spin_unlock(&info->lock);
-			swappage = shmem_swapin(info, swap, idx);
-			if (!swappage) {
-				spin_lock(&info->lock);
-				entry = shmem_swp_alloc(info, idx, sgp);
-				if (IS_ERR(entry))
-					error = PTR_ERR(entry);
-				else {
-					if (entry->val == swap.val)
-						error = -ENOMEM;
-					shmem_swp_unmap(entry);
-				}
-				spin_unlock(&info->lock);
-				if (error)
-					goto failed;
-				goto repeat;
-			}
-			wait_on_page_locked(swappage);
-			page_cache_release(swappage);
-			goto repeat;
-		}
-
-		/* We have to do this with page locked to prevent races */
-		if (TestSetPageLocked(swappage)) {
-			shmem_swp_unmap(entry);
-			spin_unlock(&info->lock);
-			wait_on_page_locked(swappage);
-			page_cache_release(swappage);
-			goto repeat;
-		}
-		if (PageWriteback(swappage)) {
-			shmem_swp_unmap(entry);
-			spin_unlock(&info->lock);
-			wait_on_page_writeback(swappage);
-			unlock_page(swappage);
-			page_cache_release(swappage);
-			goto repeat;
-		}
-		if (!PageUptodate(swappage)) {
-			shmem_swp_unmap(entry);
-			spin_unlock(&info->lock);
-			unlock_page(swappage);
-			page_cache_release(swappage);
-			error = -EIO;
-			goto failed;
-		}
-
-		if (filepage) {
-			shmem_swp_set(info, entry, 0);
-			shmem_swp_unmap(entry);
-			delete_from_swap_cache(swappage);
-			spin_unlock(&info->lock);
-			copy_highpage(filepage, swappage);
-			unlock_page(swappage);
-			page_cache_release(swappage);
-			flush_dcache_page(filepage);
-			SetPageUptodate(filepage);
-			set_page_dirty(filepage);
-			swap_free(swap);
-		} else if (!(error = move_from_swap_cache(
-				swappage, idx, mapping))) {
-			info->flags |= SHMEM_PAGEIN;
-			shmem_swp_set(info, entry, 0);
-			shmem_swp_unmap(entry);
-			spin_unlock(&info->lock);
-			filepage = swappage;
-			swap_free(swap);
-		} else {
-			shmem_swp_unmap(entry);
-			spin_unlock(&info->lock);
-			unlock_page(swappage);
-			page_cache_release(swappage);
-			if (error == -ENOMEM) {
-				/* let kswapd refresh zone for GFP_ATOMICs */
-				congestion_wait(WRITE, HZ/50);
-			}
-			goto repeat;
-		}
-	} else if (sgp == SGP_READ && !filepage) {
-		shmem_swp_unmap(entry);
-		filepage = find_get_page(mapping, idx);
-		if (filepage &&
-		    (!PageUptodate(filepage) || TestSetPageLocked(filepage))) {
-			spin_unlock(&info->lock);
-			wait_on_page_locked(filepage);
-			page_cache_release(filepage);
-			filepage = NULL;
-			goto repeat;
-		}
-		spin_unlock(&info->lock);
-	} else {
-		shmem_swp_unmap(entry);
-		sbinfo = SHMEM_SB(inode->i_sb);
-		if (sbinfo->max_blocks) {
-			spin_lock(&sbinfo->stat_lock);
-			if (sbinfo->free_blocks == 0 ||
-			    shmem_acct_block(info->flags)) {
-				spin_unlock(&sbinfo->stat_lock);
-				spin_unlock(&info->lock);
-				error = -ENOSPC;
-				goto failed;
-			}
-			sbinfo->free_blocks--;
-			inode->i_blocks += BLOCKS_PER_PAGE;
-			spin_unlock(&sbinfo->stat_lock);
-		} else if (shmem_acct_block(info->flags)) {
-			spin_unlock(&info->lock);
-			error = -ENOSPC;
-			goto failed;
-		}
-
-		if (!filepage) {
-			spin_unlock(&info->lock);
-			filepage = shmem_alloc_page(mapping_gfp_mask(mapping),
-						    info,
-						    idx);
-			if (!filepage) {
-				shmem_unacct_blocks(info->flags, 1);
-				shmem_free_blocks(inode, 1);
-				error = -ENOMEM;
-				goto failed;
-			}
-
-			spin_lock(&info->lock);
-			entry = shmem_swp_alloc(info, idx, sgp);
-			if (IS_ERR(entry))
-				error = PTR_ERR(entry);
-			else {
-				swap = *entry;
-				shmem_swp_unmap(entry);
-			}
-			if (error || swap.val || 0 != add_to_page_cache_lru(
-					filepage, mapping, idx, GFP_ATOMIC)) {
-				spin_unlock(&info->lock);
-				page_cache_release(filepage);
-				shmem_unacct_blocks(info->flags, 1);
-				shmem_free_blocks(inode, 1);
-				filepage = NULL;
-				if (error)
-					goto failed;
-				goto repeat;
-			}
-			info->flags |= SHMEM_PAGEIN;
-		}
-
-		info->alloced++;
-		spin_unlock(&info->lock);
-		flush_dcache_page(filepage);
-		SetPageUptodate(filepage);
-	}
-done:
-	if (*pagep != filepage) {
-		unlock_page(filepage);
-		*pagep = filepage;
-	}
-	return 0;
-
-failed:
-	if (*pagep != filepage) {
-		unlock_page(filepage);
-		page_cache_release(filepage);
-	}
-	return error;
-}
-
-static struct page *shmem_nopage(struct vm_area_struct *vma,
-				 unsigned long address, int *type)
-{
-	struct inode *inode = vma->vm_file->f_path.dentry->d_inode;
-	struct page *page = NULL;
-	unsigned long idx;
-	int error;
-
-	idx = (address - vma->vm_start) >> PAGE_SHIFT;
-	idx += vma->vm_pgoff;
-	idx >>= PAGE_CACHE_SHIFT - PAGE_SHIFT;
-	if (((loff_t) idx << PAGE_CACHE_SHIFT) >= i_size_read(inode))
-		return NOPAGE_SIGBUS;
-
-	error = shmem_getpage(inode, idx, &page, SGP_CACHE, type);
-	if (error)
-		return (error == -ENOMEM)? NOPAGE_OOM: NOPAGE_SIGBUS;
-
-	mark_page_accessed(page);
-	return page;
-}
-
-static int shmem_populate(struct vm_area_struct *vma,
-	unsigned long addr, unsigned long len,
-	pgprot_t prot, unsigned long pgoff, int nonblock)
-{
-	struct inode *inode = vma->vm_file->f_path.dentry->d_inode;
-	struct mm_struct *mm = vma->vm_mm;
-	enum sgp_type sgp = nonblock? SGP_QUICK: SGP_CACHE;
-	unsigned long size;
-
-	size = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;
-	if (pgoff >= size || pgoff + (len >> PAGE_SHIFT) > size)
-		return -EINVAL;
-
-	while ((long) len > 0) {
-		struct page *page = NULL;
-		int err;
-		/*
-		 * Will need changing if PAGE_CACHE_SIZE != PAGE_SIZE
-		 */
-		err = shmem_getpage(inode, pgoff, &page, sgp, NULL);
-		if (err)
-			return err;
-		/* Page may still be null, but only if nonblock was set. */
-		if (page) {
-			mark_page_accessed(page);
-			err = install_page(mm, vma, addr, page, prot);
-			if (err) {
-				page_cache_release(page);
-				return err;
-			}
-		} else if (vma->vm_flags & VM_NONLINEAR) {
-			/* No page was found just because we can't read it in
-			 * now (being here implies nonblock != 0), but the page
-			 * may exist, so set the PTE to fault it in later. */
-    			err = install_file_pte(mm, vma, addr, pgoff, prot);
-			if (err)
-	    			return err;
-		}
-
-		len -= PAGE_SIZE;
-		addr += PAGE_SIZE;
-		pgoff++;
-	}
-	return 0;
-}
-
-#ifdef CONFIG_NUMA
-int shmem_set_policy(struct vm_area_struct *vma, struct mempolicy *new)
-{
-	struct inode *i = vma->vm_file->f_path.dentry->d_inode;
-	return mpol_set_shared_policy(&SHMEM_I(i)->policy, vma, new);
-}
-
-struct mempolicy *
-shmem_get_policy(struct vm_area_struct *vma, unsigned long addr)
-{
-	struct inode *i = vma->vm_file->f_path.dentry->d_inode;
-	unsigned long idx;
-
-	idx = ((addr - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
-	return mpol_shared_policy_lookup(&SHMEM_I(i)->policy, idx);
-}
-#endif
-
-int shmem_lock(struct file *file, int lock, struct user_struct *user)
-{
-	struct inode *inode = file->f_path.dentry->d_inode;
-	struct shmem_inode_info *info = SHMEM_I(inode);
-	int retval = -ENOMEM;
-
-	spin_lock(&info->lock);
-	if (lock && !(info->flags & VM_LOCKED)) {
-		if (!user_shm_lock(inode->i_size, user))
-			goto out_nomem;
-		info->flags |= VM_LOCKED;
-	}
-	if (!lock && (info->flags & VM_LOCKED) && user) {
-		user_shm_unlock(inode->i_size, user);
-		info->flags &= ~VM_LOCKED;
-	}
-	retval = 0;
-out_nomem:
-	spin_unlock(&info->lock);
-	return retval;
-}
-
-static int shmem_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	file_accessed(file);
-	vma->vm_ops = &shmem_vm_ops;
-	return 0;
-}
-
-static struct inode *
-shmem_get_inode(struct super_block *sb, int mode, dev_t dev)
-{
-	struct inode *inode;
-	struct shmem_inode_info *info;
-	struct shmem_sb_info *sbinfo = SHMEM_SB(sb);
-
-	if (sbinfo->max_inodes) {
-		spin_lock(&sbinfo->stat_lock);
-		if (!sbinfo->free_inodes) {
-			spin_unlock(&sbinfo->stat_lock);
-			return NULL;
-		}
-		sbinfo->free_inodes--;
-		spin_unlock(&sbinfo->stat_lock);
-	}
-
-	inode = new_inode(sb);
-	if (inode) {
-		inode->i_mode = mode;
-		inode->i_uid = current->fsuid;
-		inode->i_gid = current->fsgid;
-		inode->i_blocks = 0;
-		inode->i_mapping->a_ops = &shmem_aops;
-		inode->i_mapping->backing_dev_info = &shmem_backing_dev_info;
-		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
-		inode->i_generation = get_seconds();
-		info = SHMEM_I(inode);
-		memset(info, 0, (char *)inode - (char *)info);
-		spin_lock_init(&info->lock);
-		INIT_LIST_HEAD(&info->swaplist);
-
-		switch (mode & S_IFMT) {
-		default:
-			inode->i_op = &shmem_special_inode_operations;
-			init_special_inode(inode, mode, dev);
-			break;
-		case S_IFREG:
-			inode->i_op = &shmem_inode_operations;
-			inode->i_fop = &shmem_file_operations;
-			mpol_shared_policy_init(&info->policy, sbinfo->policy,
-							&sbinfo->policy_nodes);
-			break;
-		case S_IFDIR:
-			inc_nlink(inode);
-			/* Some things misbehave if size == 0 on a directory */
-			inode->i_size = 2 * BOGO_DIRENT_SIZE;
-			inode->i_op = &shmem_dir_inode_operations;
-			inode->i_fop = &simple_dir_operations;
-			break;
-		case S_IFLNK:
-			/*
-			 * Must not load anything in the rbtree,
-			 * mpol_free_shared_policy will not be called.
-			 */
-			mpol_shared_policy_init(&info->policy, MPOL_DEFAULT,
-						NULL);
-			break;
-		}
-	} else if (sbinfo->max_inodes) {
-		spin_lock(&sbinfo->stat_lock);
-		sbinfo->free_inodes++;
-		spin_unlock(&sbinfo->stat_lock);
-	}
-	return inode;
-}
-
-#ifdef CONFIG_TMPFS
-static const struct inode_operations shmem_symlink_inode_operations;
-static const struct inode_operations shmem_symlink_inline_operations;
-
-/*
- * Normally tmpfs makes no use of shmem_prepare_write, but it
- * lets a tmpfs file be used read-write below the loop driver.
- */
-static int
-shmem_prepare_write(struct file *file, struct page *page, unsigned offset, unsigned to)
-{
-	struct inode *inode = page->mapping->host;
-	return shmem_getpage(inode, page->index, &page, SGP_WRITE, NULL);
-}
-
-static ssize_t
-shmem_file_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
-{
-	struct inode	*inode = file->f_path.dentry->d_inode;
-	loff_t		pos;
-	unsigned long	written;
-	ssize_t		err;
-
-	if ((ssize_t) count < 0)
-		return -EINVAL;
-
-	if (!access_ok(VERIFY_READ, buf, count))
-		return -EFAULT;
-
-	mutex_lock(&inode->i_mutex);
-
-	pos = *ppos;
-	written = 0;
-
-	err = generic_write_checks(file, &pos, &count, 0);
-	if (err || !count)
-		goto out;
-
-	err = remove_suid(file->f_path.dentry);
-	if (err)
-		goto out;
-
-	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
-
-	do {
-		struct page *page = NULL;
-		unsigned long bytes, index, offset;
-		char *kaddr;
-		int left;
-
-		offset = (pos & (PAGE_CACHE_SIZE -1)); /* Within page */
-		index = pos >> PAGE_CACHE_SHIFT;
-		bytes = PAGE_CACHE_SIZE - offset;
-		if (bytes > count)
-			bytes = count;
-
-		/*
-		 * We don't hold page lock across copy from user -
-		 * what would it guard against? - so no deadlock here.
-		 * But it still may be a good idea to prefault below.
-		 */
-
-		err = shmem_getpage(inode, index, &page, SGP_WRITE, NULL);
-		if (err)
-			break;
-
-		left = bytes;
-		if (PageHighMem(page)) {
-			volatile unsigned char dummy;
-			__get_user(dummy, buf);
-			__get_user(dummy, buf + bytes - 1);
-
-			kaddr = kmap_atomic(page, KM_USER0);
-			left = __copy_from_user_inatomic(kaddr + offset,
-							buf, bytes);
-			kunmap_atomic(kaddr, KM_USER0);
-		}
-		if (left) {
-			kaddr = kmap(page);
-			left = __copy_from_user(kaddr + offset, buf, bytes);
-			kunmap(page);
-		}
-
-		written += bytes;
-		count -= bytes;
-		pos += bytes;
-		buf += bytes;
-		if (pos > inode->i_size)
-			i_size_write(inode, pos);
-
-		flush_dcache_page(page);
-		set_page_dirty(page);
-		mark_page_accessed(page);
-		page_cache_release(page);
-
-		if (left) {
-			pos -= left;
-			written -= left;
-			err = -EFAULT;
-			break;
-		}
-
-		/*
-		 * Our dirty pages are not counted in nr_dirty,
-		 * and we do not attempt to balance dirty pages.
-		 */
-
-		cond_resched();
-	} while (count);
-
-	*ppos = pos;
-	if (written)
-		err = written;
-out:
-	mutex_unlock(&inode->i_mutex);
-	return err;
-}
-
-static void do_shmem_file_read(struct file *filp, loff_t *ppos, read_descriptor_t *desc, read_actor_t actor)
-{
-	struct inode *inode = filp->f_path.dentry->d_inode;
-	struct address_space *mapping = inode->i_mapping;
-	unsigned long index, offset;
-
-	index = *ppos >> PAGE_CACHE_SHIFT;
-	offset = *ppos & ~PAGE_CACHE_MASK;
-
-	for (;;) {
-		struct page *page = NULL;
-		unsigned long end_index, nr, ret;
-		loff_t i_size = i_size_read(inode);
-
-		end_index = i_size >> PAGE_CACHE_SHIFT;
-		if (index > end_index)
-			break;
-		if (index == end_index) {
-			nr = i_size & ~PAGE_CACHE_MASK;
-			if (nr <= offset)
-				break;
-		}
-
-		desc->error = shmem_getpage(inode, index, &page, SGP_READ, NULL);
-		if (desc->error) {
-			if (desc->error == -EINVAL)
-				desc->error = 0;
-			break;
-		}
-
-		/*
-		 * We must evaluate after, since reads (unlike writes)
-		 * are called without i_mutex protection against truncate
-		 */
-		nr = PAGE_CACHE_SIZE;
-		i_size = i_size_read(inode);
-		end_index = i_size >> PAGE_CACHE_SHIFT;
-		if (index == end_index) {
-			nr = i_size & ~PAGE_CACHE_MASK;
-			if (nr <= offset) {
-				if (page)
-					page_cache_release(page);
-				break;
-			}
-		}
-		nr -= offset;
-
-		if (page) {
-			/*
-			 * If users can be writing to this page using arbitrary
-			 * virtual addresses, take care about potential aliasing
-			 * before reading the page on the kernel side.
-			 */
-			if (mapping_writably_mapped(mapping))
-				flush_dcache_page(page);
-			/*
-			 * Mark the page accessed if we read the beginning.
-			 */
-			if (!offset)
-				mark_page_accessed(page);
-		} else {
-			page = ZERO_PAGE(0);
-			page_cache_get(page);
-		}
-
-		/*
-		 * Ok, we have the page, and it's up-to-date, so
-		 * now we can copy it to user space...
-		 *
-		 * The actor routine returns how many bytes were actually used..
-		 * NOTE! This may not be the same as how much of a user buffer
-		 * we filled up (we may be padding etc), so we can only update
-		 * "pos" here (the actor routine has to update the user buffer
-		 * pointers and the remaining count).
-		 */
-		ret = actor(desc, page, offset, nr);
-		offset += ret;
-		index += offset >> PAGE_CACHE_SHIFT;
-		offset &= ~PAGE_CACHE_MASK;
-
-		page_cache_release(page);
-		if (ret != nr || !desc->count)
-			break;
-
-		cond_resched();
-	}
-
-	*ppos = ((loff_t) index << PAGE_CACHE_SHIFT) + offset;
-	file_accessed(filp);
-}
-
-static ssize_t shmem_file_read(struct file *filp, char __user *buf, size_t count, loff_t *ppos)
-{
-	read_descriptor_t desc;
-
-	if ((ssize_t) count < 0)
-		return -EINVAL;
-	if (!access_ok(VERIFY_WRITE, buf, count))
-		return -EFAULT;
-	if (!count)
-		return 0;
-
-	desc.written = 0;
-	desc.count = count;
-	desc.arg.buf = buf;
-	desc.error = 0;
-
-	do_shmem_file_read(filp, ppos, &desc, file_read_actor);
-	if (desc.written)
-		return desc.written;
-	return desc.error;
-}
-
-static ssize_t shmem_file_sendfile(struct file *in_file, loff_t *ppos,
-			 size_t count, read_actor_t actor, void *target)
-{
-	read_descriptor_t desc;
-
-	if (!count)
-		return 0;
-
-	desc.written = 0;
-	desc.count = count;
-	desc.arg.data = target;
-	desc.error = 0;
-
-	do_shmem_file_read(in_file, ppos, &desc, actor);
-	if (desc.written)
-		return desc.written;
-	return desc.error;
-}
-
-static int shmem_statfs(struct dentry *dentry, struct kstatfs *buf)
-{
-	struct shmem_sb_info *sbinfo = SHMEM_SB(dentry->d_sb);
-
-	buf->f_type = TMPFS_MAGIC;
-	buf->f_bsize = PAGE_CACHE_SIZE;
-	buf->f_namelen = NAME_MAX;
-	spin_lock(&sbinfo->stat_lock);
-	if (sbinfo->max_blocks) {
-		buf->f_blocks = sbinfo->max_blocks;
-		buf->f_bavail = buf->f_bfree = sbinfo->free_blocks;
-	}
-	if (sbinfo->max_inodes) {
-		buf->f_files = sbinfo->max_inodes;
-		buf->f_ffree = sbinfo->free_inodes;
-	}
-	/* else leave those fields 0 like simple_statfs */
-	spin_unlock(&sbinfo->stat_lock);
-	return 0;
-}
-
-/*
- * File creation. Allocate an inode, and we're done..
- */
-static int
-shmem_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
-{
-	struct inode *inode = shmem_get_inode(dir->i_sb, mode, dev);
-	int error = -ENOSPC;
-
-	if (inode) {
-		error = security_inode_init_security(inode, dir, NULL, NULL,
-						     NULL);
-		if (error) {
-			if (error != -EOPNOTSUPP) {
-				iput(inode);
-				return error;
-			}
-		}
-		error = shmem_acl_init(inode, dir);
-		if (error) {
-			iput(inode);
-			return error;
-		}
-		if (dir->i_mode & S_ISGID) {
-			inode->i_gid = dir->i_gid;
-			if (S_ISDIR(mode))
-				inode->i_mode |= S_ISGID;
-		}
-		dir->i_size += BOGO_DIRENT_SIZE;
-		dir->i_ctime = dir->i_mtime = CURRENT_TIME;
-		d_instantiate(dentry, inode);
-		dget(dentry); /* Extra count - pin the dentry in core */
-	}
-	return error;
-}
-
-static int shmem_mkdir(struct inode *dir, struct dentry *dentry, int mode)
-{
-	int error;
-
-	if ((error = shmem_mknod(dir, dentry, mode | S_IFDIR, 0)))
-		return error;
-	inc_nlink(dir);
-	return 0;
-}
-
-static int shmem_create(struct inode *dir, struct dentry *dentry, int mode,
-		struct nameidata *nd)
-{
-	return shmem_mknod(dir, dentry, mode | S_IFREG, 0);
-}
-
-/*
- * Link a file..
- */
-static int shmem_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)
-{
-	struct inode *inode = old_dentry->d_inode;
-	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
-
-	/*
-	 * No ordinary (disk based) filesystem counts links as inodes;
-	 * but each new link needs a new dentry, pinning lowmem, and
-	 * tmpfs dentries cannot be pruned until they are unlinked.
-	 */
-	if (sbinfo->max_inodes) {
-		spin_lock(&sbinfo->stat_lock);
-		if (!sbinfo->free_inodes) {
-			spin_unlock(&sbinfo->stat_lock);
-			return -ENOSPC;
-		}
-		sbinfo->free_inodes--;
-		spin_unlock(&sbinfo->stat_lock);
-	}
-
-	dir->i_size += BOGO_DIRENT_SIZE;
-	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
-	inc_nlink(inode);
-	atomic_inc(&inode->i_count);	/* New dentry reference */
-	dget(dentry);		/* Extra pinning count for the created dentry */
-	d_instantiate(dentry, inode);
-	return 0;
-}
-
-static int shmem_unlink(struct inode *dir, struct dentry *dentry)
-{
-	struct inode *inode = dentry->d_inode;
-
-	if (inode->i_nlink > 1 && !S_ISDIR(inode->i_mode)) {
-		struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
-		if (sbinfo->max_inodes) {
-			spin_lock(&sbinfo->stat_lock);
-			sbinfo->free_inodes++;
-			spin_unlock(&sbinfo->stat_lock);
-		}
-	}
-
-	dir->i_size -= BOGO_DIRENT_SIZE;
-	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
-	drop_nlink(inode);
-	dput(dentry);	/* Undo the count from "create" - this does all the work */
-	return 0;
-}
-
-static int shmem_rmdir(struct inode *dir, struct dentry *dentry)
-{
-	if (!simple_empty(dentry))
-		return -ENOTEMPTY;
-
-	drop_nlink(dentry->d_inode);
-	drop_nlink(dir);
-	return shmem_unlink(dir, dentry);
-}
-
-/*
- * The VFS layer already does all the dentry stuff for rename,
- * we just have to decrement the usage count for the target if
- * it exists so that the VFS layer correctly free's it when it
- * gets overwritten.
- */
-static int shmem_rename(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)
-{
-	struct inode *inode = old_dentry->d_inode;
-	int they_are_dirs = S_ISDIR(inode->i_mode);
-
-	if (!simple_empty(new_dentry))
-		return -ENOTEMPTY;
-
-	if (new_dentry->d_inode) {
-		(void) shmem_unlink(new_dir, new_dentry);
-		if (they_are_dirs)
-			drop_nlink(old_dir);
-	} else if (they_are_dirs) {
-		drop_nlink(old_dir);
-		inc_nlink(new_dir);
-	}
-
-	old_dir->i_size -= BOGO_DIRENT_SIZE;
-	new_dir->i_size += BOGO_DIRENT_SIZE;
-	old_dir->i_ctime = old_dir->i_mtime =
-	new_dir->i_ctime = new_dir->i_mtime =
-	inode->i_ctime = CURRENT_TIME;
-	return 0;
-}
-
-static int shmem_symlink(struct inode *dir, struct dentry *dentry, const char *symname)
-{
-	int error;
-	int len;
-	struct inode *inode;
-	struct page *page = NULL;
-	char *kaddr;
-	struct shmem_inode_info *info;
-
-	len = strlen(symname) + 1;
-	if (len > PAGE_CACHE_SIZE)
-		return -ENAMETOOLONG;
-
-	inode = shmem_get_inode(dir->i_sb, S_IFLNK|S_IRWXUGO, 0);
-	if (!inode)
-		return -ENOSPC;
-
-	error = security_inode_init_security(inode, dir, NULL, NULL,
-					     NULL);
-	if (error) {
-		if (error != -EOPNOTSUPP) {
-			iput(inode);
-			return error;
-		}
-		error = 0;
-	}
-
-	info = SHMEM_I(inode);
-	inode->i_size = len-1;
-	if (len <= (char *)inode - (char *)info) {
-		/* do it inline */
-		memcpy(info, symname, len);
-		inode->i_op = &shmem_symlink_inline_operations;
-	} else {
-		error = shmem_getpage(inode, 0, &page, SGP_WRITE, NULL);
-		if (error) {
-			iput(inode);
-			return error;
-		}
-		inode->i_op = &shmem_symlink_inode_operations;
-		kaddr = kmap_atomic(page, KM_USER0);
-		memcpy(kaddr, symname, len);
-		kunmap_atomic(kaddr, KM_USER0);
-		set_page_dirty(page);
-		page_cache_release(page);
-	}
-	if (dir->i_mode & S_ISGID)
-		inode->i_gid = dir->i_gid;
-	dir->i_size += BOGO_DIRENT_SIZE;
-	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
-	d_instantiate(dentry, inode);
-	dget(dentry);
-	return 0;
-}
-
-static void *shmem_follow_link_inline(struct dentry *dentry, struct nameidata *nd)
-{
-	nd_set_link(nd, (char *)SHMEM_I(dentry->d_inode));
-	return NULL;
-}
-
-static void *shmem_follow_link(struct dentry *dentry, struct nameidata *nd)
-{
-	struct page *page = NULL;
-	int res = shmem_getpage(dentry->d_inode, 0, &page, SGP_READ, NULL);
-	nd_set_link(nd, res ? ERR_PTR(res) : kmap(page));
-	return page;
-}
-
-static void shmem_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)
-{
-	if (!IS_ERR(nd_get_link(nd))) {
-		struct page *page = cookie;
-		kunmap(page);
-		mark_page_accessed(page);
-		page_cache_release(page);
-	}
-}
-
-static const struct inode_operations shmem_symlink_inline_operations = {
-	.readlink	= generic_readlink,
-	.follow_link	= shmem_follow_link_inline,
-};
-
-static const struct inode_operations shmem_symlink_inode_operations = {
-	.truncate	= shmem_truncate,
-	.readlink	= generic_readlink,
-	.follow_link	= shmem_follow_link,
-	.put_link	= shmem_put_link,
-};
-
-#ifdef CONFIG_TMPFS_POSIX_ACL
-/**
- * Superblocks without xattr inode operations will get security.* xattr
- * support from the VFS "for free". As soon as we have any other xattrs
- * like ACLs, we also need to implement the security.* handlers at
- * filesystem level, though.
- */
-
-static size_t shmem_xattr_security_list(struct inode *inode, char *list,
-					size_t list_len, const char *name,
-					size_t name_len)
-{
-	return security_inode_listsecurity(inode, list, list_len);
-}
-
-static int shmem_xattr_security_get(struct inode *inode, const char *name,
-				    void *buffer, size_t size)
-{
-	if (strcmp(name, "") == 0)
-		return -EINVAL;
-	return security_inode_getsecurity(inode, name, buffer, size,
-					  -EOPNOTSUPP);
-}
-
-static int shmem_xattr_security_set(struct inode *inode, const char *name,
-				    const void *value, size_t size, int flags)
-{
-	if (strcmp(name, "") == 0)
-		return -EINVAL;
-	return security_inode_setsecurity(inode, name, value, size, flags);
-}
-
-static struct xattr_handler shmem_xattr_security_handler = {
-	.prefix = XATTR_SECURITY_PREFIX,
-	.list   = shmem_xattr_security_list,
-	.get    = shmem_xattr_security_get,
-	.set    = shmem_xattr_security_set,
-};
-
-static struct xattr_handler *shmem_xattr_handlers[] = {
-	&shmem_xattr_acl_access_handler,
-	&shmem_xattr_acl_default_handler,
-	&shmem_xattr_security_handler,
-	NULL
-};
-#endif
-
-static struct dentry *shmem_get_parent(struct dentry *child)
-{
-	return ERR_PTR(-ESTALE);
-}
-
-static int shmem_match(struct inode *ino, void *vfh)
-{
-	__u32 *fh = vfh;
-	__u64 inum = fh[2];
-	inum = (inum << 32) | fh[1];
-	return ino->i_ino == inum && fh[0] == ino->i_generation;
-}
-
-static struct dentry *shmem_get_dentry(struct super_block *sb, void *vfh)
-{
-	struct dentry *de = NULL;
-	struct inode *inode;
-	__u32 *fh = vfh;
-	__u64 inum = fh[2];
-	inum = (inum << 32) | fh[1];
-
-	inode = ilookup5(sb, (unsigned long)(inum+fh[0]), shmem_match, vfh);
-	if (inode) {
-		de = d_find_alias(inode);
-		iput(inode);
-	}
-
-	return de? de: ERR_PTR(-ESTALE);
-}
-
-static struct dentry *shmem_decode_fh(struct super_block *sb, __u32 *fh,
-		int len, int type,
-		int (*acceptable)(void *context, struct dentry *de),
-		void *context)
-{
-	if (len < 3)
-		return ERR_PTR(-ESTALE);
-
-	return sb->s_export_op->find_exported_dentry(sb, fh, NULL, acceptable,
-							context);
-}
-
-static int shmem_encode_fh(struct dentry *dentry, __u32 *fh, int *len,
-				int connectable)
-{
-	struct inode *inode = dentry->d_inode;
-
-	if (*len < 3)
-		return 255;
-
-	if (hlist_unhashed(&inode->i_hash)) {
-		/* Unfortunately insert_inode_hash is not idempotent,
-		 * so as we hash inodes here rather than at creation
-		 * time, we need a lock to ensure we only try
-		 * to do it once
-		 */
-		static DEFINE_SPINLOCK(lock);
-		spin_lock(&lock);
-		if (hlist_unhashed(&inode->i_hash))
-			__insert_inode_hash(inode,
-					    inode->i_ino + inode->i_generation);
-		spin_unlock(&lock);
-	}
-
-	fh[0] = inode->i_generation;
-	fh[1] = inode->i_ino;
-	fh[2] = ((__u64)inode->i_ino) >> 32;
-
-	*len = 3;
-	return 1;
-}
-
-static struct export_operations shmem_export_ops = {
-	.get_parent     = shmem_get_parent,
-	.get_dentry     = shmem_get_dentry,
-	.encode_fh      = shmem_encode_fh,
-	.decode_fh      = shmem_decode_fh,
-};
-
-static int shmem_parse_options(char *options, int *mode, uid_t *uid,
-	gid_t *gid, unsigned long *blocks, unsigned long *inodes,
-	int *policy, nodemask_t *policy_nodes)
-{
-	char *this_char, *value, *rest;
-
-	while (options != NULL) {
-		this_char = options;
-		for (;;) {
-			/*
-			 * NUL-terminate this option: unfortunately,
-			 * mount options form a comma-separated list,
-			 * but mpol's nodelist may also contain commas.
-			 */
-			options = strchr(options, ',');
-			if (options == NULL)
-				break;
-			options++;
-			if (!isdigit(*options)) {
-				options[-1] = '\0';
-				break;
-			}
-		}
-		if (!*this_char)
-			continue;
-		if ((value = strchr(this_char,'=')) != NULL) {
-			*value++ = 0;
-		} else {
-			printk(KERN_ERR
-			    "tmpfs: No value for mount option '%s'\n",
-			    this_char);
-			return 1;
-		}
-
-		if (!strcmp(this_char,"size")) {
-			unsigned long long size;
-			size = memparse(value,&rest);
-			if (*rest == '%') {
-				size <<= PAGE_SHIFT;
-				size *= totalram_pages;
-				do_div(size, 100);
-				rest++;
-			}
-			if (*rest)
-				goto bad_val;
-			*blocks = size >> PAGE_CACHE_SHIFT;
-		} else if (!strcmp(this_char,"nr_blocks")) {
-			*blocks = memparse(value,&rest);
-			if (*rest)
-				goto bad_val;
-		} else if (!strcmp(this_char,"nr_inodes")) {
-			*inodes = memparse(value,&rest);
-			if (*rest)
-				goto bad_val;
-		} else if (!strcmp(this_char,"mode")) {
-			if (!mode)
-				continue;
-			*mode = simple_strtoul(value,&rest,8);
-			if (*rest)
-				goto bad_val;
-		} else if (!strcmp(this_char,"uid")) {
-			if (!uid)
-				continue;
-			*uid = simple_strtoul(value,&rest,0);
-			if (*rest)
-				goto bad_val;
-		} else if (!strcmp(this_char,"gid")) {
-			if (!gid)
-				continue;
-			*gid = simple_strtoul(value,&rest,0);
-			if (*rest)
-				goto bad_val;
-		} else if (!strcmp(this_char,"mpol")) {
-			if (shmem_parse_mpol(value,policy,policy_nodes))
-				goto bad_val;
-		} else {
-			printk(KERN_ERR "tmpfs: Bad mount option %s\n",
-			       this_char);
-			return 1;
-		}
-	}
-	return 0;
-
-bad_val:
-	printk(KERN_ERR "tmpfs: Bad value '%s' for mount option '%s'\n",
-	       value, this_char);
-	return 1;
-
-}
-
-static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)
-{
-	struct shmem_sb_info *sbinfo = SHMEM_SB(sb);
-	unsigned long max_blocks = sbinfo->max_blocks;
-	unsigned long max_inodes = sbinfo->max_inodes;
-	int policy = sbinfo->policy;
-	nodemask_t policy_nodes = sbinfo->policy_nodes;
-	unsigned long blocks;
-	unsigned long inodes;
-	int error = -EINVAL;
-
-	if (shmem_parse_options(data, NULL, NULL, NULL, &max_blocks,
-				&max_inodes, &policy, &policy_nodes))
-		return error;
-
-	spin_lock(&sbinfo->stat_lock);
-	blocks = sbinfo->max_blocks - sbinfo->free_blocks;
-	inodes = sbinfo->max_inodes - sbinfo->free_inodes;
-	if (max_blocks < blocks)
-		goto out;
-	if (max_inodes < inodes)
-		goto out;
-	/*
-	 * Those tests also disallow limited->unlimited while any are in
-	 * use, so i_blocks will always be zero when max_blocks is zero;
-	 * but we must separately disallow unlimited->limited, because
-	 * in that case we have no record of how much is already in use.
-	 */
-	if (max_blocks && !sbinfo->max_blocks)
-		goto out;
-	if (max_inodes && !sbinfo->max_inodes)
-		goto out;
-
-	error = 0;
-	sbinfo->max_blocks  = max_blocks;
-	sbinfo->free_blocks = max_blocks - blocks;
-	sbinfo->max_inodes  = max_inodes;
-	sbinfo->free_inodes = max_inodes - inodes;
-	sbinfo->policy = policy;
-	sbinfo->policy_nodes = policy_nodes;
-out:
-	spin_unlock(&sbinfo->stat_lock);
-	return error;
-}
-#endif
-
-static void shmem_put_super(struct super_block *sb)
-{
-	kfree(sb->s_fs_info);
-	sb->s_fs_info = NULL;
-}
-
-static int shmem_fill_super(struct super_block *sb,
-			    void *data, int silent)
-{
-	struct inode *inode;
-	struct dentry *root;
-	int mode   = S_IRWXUGO | S_ISVTX;
-	uid_t uid = current->fsuid;
-	gid_t gid = current->fsgid;
-	int err = -ENOMEM;
-	struct shmem_sb_info *sbinfo;
-	unsigned long blocks = 0;
-	unsigned long inodes = 0;
-	int policy = MPOL_DEFAULT;
-	nodemask_t policy_nodes = node_online_map;
-
-#ifdef CONFIG_TMPFS
-	/*
-	 * Per default we only allow half of the physical ram per
-	 * tmpfs instance, limiting inodes to one per page of lowmem;
-	 * but the internal instance is left unlimited.
-	 */
-	if (!(sb->s_flags & MS_NOUSER)) {
-		blocks = totalram_pages / 2;
-		inodes = totalram_pages - totalhigh_pages;
-		if (inodes > blocks)
-			inodes = blocks;
-		if (shmem_parse_options(data, &mode, &uid, &gid, &blocks,
-					&inodes, &policy, &policy_nodes))
-			return -EINVAL;
-	}
-	sb->s_export_op = &shmem_export_ops;
-#else
-	sb->s_flags |= MS_NOUSER;
-#endif
-
-	/* Round up to L1_CACHE_BYTES to resist false sharing */
-	sbinfo = kmalloc(max((int)sizeof(struct shmem_sb_info),
-				L1_CACHE_BYTES), GFP_KERNEL);
-	if (!sbinfo)
-		return -ENOMEM;
-
-	spin_lock_init(&sbinfo->stat_lock);
-	sbinfo->max_blocks = blocks;
-	sbinfo->free_blocks = blocks;
-	sbinfo->max_inodes = inodes;
-	sbinfo->free_inodes = inodes;
-	sbinfo->policy = policy;
-	sbinfo->policy_nodes = policy_nodes;
-
-	sb->s_fs_info = sbinfo;
-	sb->s_maxbytes = SHMEM_MAX_BYTES;
-	sb->s_blocksize = PAGE_CACHE_SIZE;
-	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
-	sb->s_magic = TMPFS_MAGIC;
-	sb->s_op = &shmem_ops;
-	sb->s_time_gran = 1;
-#ifdef CONFIG_TMPFS_POSIX_ACL
-	sb->s_xattr = shmem_xattr_handlers;
-	sb->s_flags |= MS_POSIXACL;
-#endif
-
-	inode = shmem_get_inode(sb, S_IFDIR | mode, 0);
-	if (!inode)
-		goto failed;
-	inode->i_uid = uid;
-	inode->i_gid = gid;
-	root = d_alloc_root(inode);
-	if (!root)
-		goto failed_iput;
-	sb->s_root = root;
-	return 0;
-
-failed_iput:
-	iput(inode);
-failed:
-	shmem_put_super(sb);
-	return err;
-}
-
-static struct kmem_cache *shmem_inode_cachep;
-
-static struct inode *shmem_alloc_inode(struct super_block *sb)
-{
-	struct shmem_inode_info *p;
-	p = (struct shmem_inode_info *)kmem_cache_alloc(shmem_inode_cachep, GFP_KERNEL);
-	if (!p)
-		return NULL;
-	return &p->vfs_inode;
-}
-
-static void shmem_destroy_inode(struct inode *inode)
-{
-	if ((inode->i_mode & S_IFMT) == S_IFREG) {
-		/* only struct inode is valid if it's an inline symlink */
-		mpol_free_shared_policy(&SHMEM_I(inode)->policy);
-	}
-	shmem_acl_destroy_inode(inode);
-	kmem_cache_free(shmem_inode_cachep, SHMEM_I(inode));
-}
-
-static void init_once(void *foo, struct kmem_cache *cachep,
-		      unsigned long flags)
-{
-	struct shmem_inode_info *p = (struct shmem_inode_info *) foo;
-
-	inode_init_once(&p->vfs_inode);
-#ifdef CONFIG_TMPFS_POSIX_ACL
-	p->i_acl = NULL;
-	p->i_default_acl = NULL;
-#endif
-}
-
-static int init_inodecache(void)
-{
-	shmem_inode_cachep = kmem_cache_create("shmem_inode_cache",
-				sizeof(struct shmem_inode_info),
-				0, 0, init_once, NULL);
-	if (shmem_inode_cachep == NULL)
-		return -ENOMEM;
-	return 0;
-}
-
-static void destroy_inodecache(void)
-{
-	kmem_cache_destroy(shmem_inode_cachep);
-}
-
-static const struct address_space_operations shmem_aops = {
-	.writepage	= shmem_writepage,
-	.set_page_dirty	= __set_page_dirty_no_writeback,
-#ifdef CONFIG_TMPFS
-	.prepare_write	= shmem_prepare_write,
-	.commit_write	= simple_commit_write,
-#endif
-	.migratepage	= migrate_page,
-};
-
-static const struct file_operations shmem_file_operations = {
-	.mmap		= shmem_mmap,
-#ifdef CONFIG_TMPFS
-	.llseek		= generic_file_llseek,
-	.read		= shmem_file_read,
-	.write		= shmem_file_write,
-	.fsync		= simple_sync_file,
-	.sendfile	= shmem_file_sendfile,
-#endif
-};
-
-static const struct inode_operations shmem_inode_operations = {
-	.truncate	= shmem_truncate,
-	.setattr	= shmem_notify_change,
-	.truncate_range	= shmem_truncate_range,
-#ifdef CONFIG_TMPFS_POSIX_ACL
-	.setxattr	= generic_setxattr,
-	.getxattr	= generic_getxattr,
-	.listxattr	= generic_listxattr,
-	.removexattr	= generic_removexattr,
-	.permission	= shmem_permission,
-#endif
-
-};
-
-static const struct inode_operations shmem_dir_inode_operations = {
-#ifdef CONFIG_TMPFS
-	.create		= shmem_create,
-	.lookup		= simple_lookup,
-	.link		= shmem_link,
-	.unlink		= shmem_unlink,
-	.symlink	= shmem_symlink,
-	.mkdir		= shmem_mkdir,
-	.rmdir		= shmem_rmdir,
-	.mknod		= shmem_mknod,
-	.rename		= shmem_rename,
-#endif
-#ifdef CONFIG_TMPFS_POSIX_ACL
-	.setattr	= shmem_notify_change,
-	.setxattr	= generic_setxattr,
-	.getxattr	= generic_getxattr,
-	.listxattr	= generic_listxattr,
-	.removexattr	= generic_removexattr,
-	.permission	= shmem_permission,
-#endif
-};
-
-static const struct inode_operations shmem_special_inode_operations = {
-#ifdef CONFIG_TMPFS_POSIX_ACL
-	.setattr	= shmem_notify_change,
-	.setxattr	= generic_setxattr,
-	.getxattr	= generic_getxattr,
-	.listxattr	= generic_listxattr,
-	.removexattr	= generic_removexattr,
-	.permission	= shmem_permission,
-#endif
-};
-
-static const struct super_operations shmem_ops = {
-	.alloc_inode	= shmem_alloc_inode,
-	.destroy_inode	= shmem_destroy_inode,
-#ifdef CONFIG_TMPFS
-	.statfs		= shmem_statfs,
-	.remount_fs	= shmem_remount_fs,
-#endif
-	.delete_inode	= shmem_delete_inode,
-	.drop_inode	= generic_delete_inode,
-	.put_super	= shmem_put_super,
-};
-
-static struct vm_operations_struct shmem_vm_ops = {
-	.nopage		= shmem_nopage,
-	.populate	= shmem_populate,
-#ifdef CONFIG_NUMA
-	.set_policy     = shmem_set_policy,
-	.get_policy     = shmem_get_policy,
-#endif
-};
-
-
-static int shmem_get_sb(struct file_system_type *fs_type,
-	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
-{
-	return get_sb_nodev(fs_type, flags, data, shmem_fill_super, mnt);
-}
-
-static struct file_system_type tmpfs_fs_type = {
-	.owner		= THIS_MODULE,
-	.name		= "tmpfs",
-	.get_sb		= shmem_get_sb,
-	.kill_sb	= kill_litter_super,
-};
-static struct vfsmount *shm_mnt;
-
-static int __init init_tmpfs(void)
-{
-	int error;
-
-	error = init_inodecache();
-	if (error)
-		goto out3;
-
-	error = register_filesystem(&tmpfs_fs_type);
-	if (error) {
-		printk(KERN_ERR "Could not register tmpfs\n");
-		goto out2;
-	}
-
-	shm_mnt = vfs_kern_mount(&tmpfs_fs_type, MS_NOUSER,
-				tmpfs_fs_type.name, NULL);
-	if (IS_ERR(shm_mnt)) {
-		error = PTR_ERR(shm_mnt);
-		printk(KERN_ERR "Could not kern_mount tmpfs\n");
-		goto out1;
-	}
-	return 0;
-
-out1:
-	unregister_filesystem(&tmpfs_fs_type);
-out2:
-	destroy_inodecache();
-out3:
-	shm_mnt = ERR_PTR(error);
-	return error;
-}
-module_init(init_tmpfs)
-
-/*
- * shmem_file_setup - get an unlinked file living in tmpfs
- *
- * @name: name for dentry (to be seen in /proc/<pid>/maps
- * @size: size to be set for the file
- *
- */
-struct file *shmem_file_setup(char *name, loff_t size, unsigned long flags)
-{
-	int error;
-	struct file *file;
-	struct inode *inode;
-	struct dentry *dentry, *root;
-	struct qstr this;
-
-	if (IS_ERR(shm_mnt))
-		return (void *)shm_mnt;
-
-	if (size < 0 || size > SHMEM_MAX_BYTES)
-		return ERR_PTR(-EINVAL);
-
-	if (shmem_acct_size(flags, size))
-		return ERR_PTR(-ENOMEM);
-
-	error = -ENOMEM;
-	this.name = name;
-	this.len = strlen(name);
-	this.hash = 0; /* will go */
-	root = shm_mnt->mnt_root;
-	dentry = d_alloc(root, &this);
-	if (!dentry)
-		goto put_memory;
-
-	error = -ENFILE;
-	file = get_empty_filp();
-	if (!file)
-		goto put_dentry;
-
-	error = -ENOSPC;
-	inode = shmem_get_inode(root->d_sb, S_IFREG | S_IRWXUGO, 0);
-	if (!inode)
-		goto close_file;
-
-	SHMEM_I(inode)->flags = flags & VM_ACCOUNT;
-	d_instantiate(dentry, inode);
-	inode->i_size = size;
-	inode->i_nlink = 0;	/* It is unlinked */
-	file->f_path.mnt = mntget(shm_mnt);
-	file->f_path.dentry = dentry;
-	file->f_mapping = inode->i_mapping;
-	file->f_op = &shmem_file_operations;
-	file->f_mode = FMODE_WRITE | FMODE_READ;
-	return file;
-
-close_file:
-	put_filp(file);
-put_dentry:
-	dput(dentry);
-put_memory:
-	shmem_unacct_size(flags, size);
-	return ERR_PTR(error);
-}
-
-/*
- * shmem_zero_setup - setup a shared anonymous mapping
- *
- * @vma: the vma to be mmapped is prepared by do_mmap_pgoff
- */
-int shmem_zero_setup(struct vm_area_struct *vma)
-{
-	struct file *file;
-	loff_t size = vma->vm_end - vma->vm_start;
-
-	file = shmem_file_setup("dev/zero", size, vma->vm_flags);
-	if (IS_ERR(file))
-		return PTR_ERR(file);
-
-	if (vma->vm_file)
-		fput(vma->vm_file);
-	vma->vm_file = file;
-	vma->vm_ops = &shmem_vm_ops;
-	return 0;
-}
diff -Nurb linux-2.6.22-590/net/802/tr.c linux-2.6.22-try2-netns/net/802/tr.c
--- linux-2.6.22-590/net/802/tr.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/802/tr.c	2007-12-19 22:49:18.000000000 -0500
@@ -36,6 +36,7 @@
 #include <linux/seq_file.h>
 #include <linux/init.h>
 #include <net/arp.h>
+#include <net/net_namespace.h>
 
 static void tr_add_rif_info(struct trh_hdr *trh, struct net_device *dev);
 static void rif_check_expire(unsigned long dummy);
@@ -532,7 +533,7 @@
 		seq_puts(seq,
 		     "if     TR address       TTL   rcf   routing segments\n");
 	else {
-		struct net_device *dev = dev_get_by_index(entry->iface);
+		struct net_device *dev = dev_get_by_index(&init_net, entry->iface);
 		long ttl = (long) (entry->last_used + sysctl_tr_rif_timeout)
 				- (long) jiffies;
 
@@ -639,7 +640,7 @@
 	rif_timer.function = rif_check_expire;
 	add_timer(&rif_timer);
 
-	proc_net_fops_create("tr_rif", S_IRUGO, &rif_seq_fops);
+	proc_net_fops_create(&init_net, "tr_rif", S_IRUGO, &rif_seq_fops);
 	return 0;
 }
 
diff -Nurb linux-2.6.22-590/net/8021q/vlan.c linux-2.6.22-try2-netns/net/8021q/vlan.c
--- linux-2.6.22-590/net/8021q/vlan.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/8021q/vlan.c	2007-12-19 22:49:18.000000000 -0500
@@ -31,6 +31,7 @@
 #include <net/arp.h>
 #include <linux/rtnetlink.h>
 #include <linux/notifier.h>
+#include <net/net_namespace.h>
 
 #include <linux/if_vlan.h>
 #include "vlan.h"
@@ -50,7 +51,7 @@
 static char vlan_buggyright[] = "David S. Miller <davem@redhat.com>";
 
 static int vlan_device_event(struct notifier_block *, unsigned long, void *);
-static int vlan_ioctl_handler(void __user *);
+static int vlan_ioctl_handler(struct net *net, void __user *);
 static int unregister_vlan_dev(struct net_device *, unsigned short );
 
 static struct notifier_block vlan_notifier_block = {
@@ -124,7 +125,7 @@
 	struct net_device *dev, *nxt;
 
 	rtnl_lock();
-	for_each_netdev_safe(dev, nxt) {
+	for_each_netdev_safe(&init_net, dev, nxt) {
 		if (dev->priv_flags & IFF_802_1Q_VLAN) {
 			unregister_vlan_dev(VLAN_DEV_INFO(dev)->real_dev,
 					    VLAN_DEV_INFO(dev)->vlan_id);
@@ -599,6 +600,9 @@
 	int i, flgs;
 	struct net_device *vlandev;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (!grp)
 		goto out;
 
@@ -678,7 +682,7 @@
  *	o execute requested action or pass command to the device driver
  *   arg is really a struct vlan_ioctl_args __user *.
  */
-static int vlan_ioctl_handler(void __user *arg)
+static int vlan_ioctl_handler(struct net *net, void __user *arg)
 {
 	int err;
 	unsigned short vid = 0;
@@ -707,7 +711,7 @@
 	case GET_VLAN_REALDEV_NAME_CMD:
 	case GET_VLAN_VID_CMD:
 		err = -ENODEV;
-		dev = __dev_get_by_name(args.device1);
+		dev = __dev_get_by_name(&init_net, args.device1);
 		if (!dev)
 			goto out;
 
diff -Nurb linux-2.6.22-590/net/8021q/vlan_dev.c linux-2.6.22-try2-netns/net/8021q/vlan_dev.c
--- linux-2.6.22-590/net/8021q/vlan_dev.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/8021q/vlan_dev.c	2007-12-19 22:49:18.000000000 -0500
@@ -132,6 +132,11 @@
 
 	vhdr = (struct vlan_hdr *)(skb->data);
 
+	if (dev->nd_net != &init_net) {
+		kfree_skb(skb);
+		return 0;
+	}
+
 	/* vlan_TCI = ntohs(get_unaligned(&vhdr->h_vlan_TCI)); */
 	vlan_TCI = ntohs(vhdr->h_vlan_TCI);
 
@@ -776,7 +781,7 @@
 		break;
 
 	case SIOCETHTOOL:
-		err = dev_ethtool(&ifrr);
+		err = dev_ethtool(real_dev->nd_net, &ifrr);
 	}
 
 	if (!err)
diff -Nurb linux-2.6.22-590/net/8021q/vlan_netlink.c linux-2.6.22-try2-netns/net/8021q/vlan_netlink.c
--- linux-2.6.22-590/net/8021q/vlan_netlink.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/8021q/vlan_netlink.c	2007-12-19 22:49:18.000000000 -0500
@@ -11,6 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/netdevice.h>
 #include <linux/if_vlan.h>
+#include <net/net_namespace.h>
 #include <net/netlink.h>
 #include <net/rtnetlink.h>
 #include "vlan.h"
@@ -105,7 +106,7 @@
 
 	if (!tb[IFLA_LINK])
 		return -EINVAL;
-	real_dev = __dev_get_by_index(nla_get_u32(tb[IFLA_LINK]));
+	real_dev = __dev_get_by_index(&init_net, nla_get_u32(tb[IFLA_LINK]));
 	if (!real_dev)
 		return -ENODEV;
 
diff -Nurb linux-2.6.22-590/net/8021q/vlanproc.c linux-2.6.22-try2-netns/net/8021q/vlanproc.c
--- linux-2.6.22-590/net/8021q/vlanproc.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/8021q/vlanproc.c	2007-12-19 22:49:18.000000000 -0500
@@ -33,6 +33,7 @@
 #include <linux/fs.h>
 #include <linux/netdevice.h>
 #include <linux/if_vlan.h>
+#include <net/net_namespace.h>
 #include "vlanproc.h"
 #include "vlan.h"
 
@@ -143,7 +144,7 @@
 		remove_proc_entry(name_conf, proc_vlan_dir);
 
 	if (proc_vlan_dir)
-		proc_net_remove(name_root);
+		proc_net_remove(&init_net, name_root);
 
 	/* Dynamically added entries should be cleaned up as their vlan_device
 	 * is removed, so we should not have to take care of it here...
@@ -156,7 +157,7 @@
 
 int __init vlan_proc_init(void)
 {
-	proc_vlan_dir = proc_mkdir(name_root, proc_net);
+	proc_vlan_dir = proc_mkdir(name_root, init_net.proc_net);
 	if (proc_vlan_dir) {
 		proc_vlan_conf = create_proc_entry(name_conf,
 						   S_IFREG|S_IRUSR|S_IWUSR,
@@ -253,7 +254,7 @@
 	if (*pos == 0)
 		return SEQ_START_TOKEN;
 
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if (!is_vlan_dev(dev))
 			continue;
 
@@ -272,9 +273,9 @@
 
 	dev = (struct net_device *)v;
 	if (v == SEQ_START_TOKEN)
-		dev = net_device_entry(&dev_base_head);
+		dev = net_device_entry(&init_net.dev_base_head);
 
-	for_each_netdev_continue(dev) {
+	for_each_netdev_continue(&init_net, dev) {
 		if (!is_vlan_dev(dev))
 			continue;
 
diff -Nurb linux-2.6.22-590/net/Kconfig linux-2.6.22-try2-netns/net/Kconfig
--- linux-2.6.22-590/net/Kconfig	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/Kconfig	2007-12-19 22:49:18.000000000 -0500
@@ -27,6 +27,13 @@
 
 menu "Networking options"
 
+config NET_NS
+	bool "Network namespace support"
+	depends on EXPERIMENTAL
+	help
+	  Support what appear to user space as multiple instances of the 
+ 	  network stack.
+
 source "net/packet/Kconfig"
 source "net/unix/Kconfig"
 source "net/xfrm/Kconfig"
diff -Nurb linux-2.6.22-590/net/appletalk/aarp.c linux-2.6.22-try2-netns/net/appletalk/aarp.c
--- linux-2.6.22-590/net/appletalk/aarp.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/appletalk/aarp.c	2007-12-19 22:49:18.000000000 -0500
@@ -330,15 +330,19 @@
 static int aarp_device_event(struct notifier_block *this, unsigned long event,
 			     void *ptr)
 {
+	struct net_device *dev = ptr;
 	int ct;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (event == NETDEV_DOWN) {
 		write_lock_bh(&aarp_lock);
 
 		for (ct = 0; ct < AARP_HASH_SIZE; ct++) {
-			__aarp_expire_device(&resolved[ct], ptr);
-			__aarp_expire_device(&unresolved[ct], ptr);
-			__aarp_expire_device(&proxies[ct], ptr);
+			__aarp_expire_device(&resolved[ct], dev);
+			__aarp_expire_device(&unresolved[ct], dev);
+			__aarp_expire_device(&proxies[ct], dev);
 		}
 
 		write_unlock_bh(&aarp_lock);
@@ -712,6 +716,9 @@
 	struct atalk_addr sa, *ma, da;
 	struct atalk_iface *ifa;
 
+	if (dev->nd_net != &init_net)
+		goto out0;
+
 	/* We only do Ethernet SNAP AARP. */
 	if (dev->type != ARPHRD_ETHER)
 		goto out0;
diff -Nurb linux-2.6.22-590/net/appletalk/atalk_proc.c linux-2.6.22-try2-netns/net/appletalk/atalk_proc.c
--- linux-2.6.22-590/net/appletalk/atalk_proc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/appletalk/atalk_proc.c	2007-12-19 22:49:18.000000000 -0500
@@ -13,6 +13,7 @@
 #include <linux/seq_file.h>
 #include <net/sock.h>
 #include <linux/atalk.h>
+#include <net/net_namespace.h>
 
 
 static __inline__ struct atalk_iface *atalk_get_interface_idx(loff_t pos)
@@ -271,7 +272,7 @@
 	struct proc_dir_entry *p;
 	int rc = -ENOMEM;
 
-	atalk_proc_dir = proc_mkdir("atalk", proc_net);
+	atalk_proc_dir = proc_mkdir("atalk", init_net.proc_net);
 	if (!atalk_proc_dir)
 		goto out;
 	atalk_proc_dir->owner = THIS_MODULE;
@@ -306,7 +307,7 @@
 out_route:
 	remove_proc_entry("interface", atalk_proc_dir);
 out_interface:
-	remove_proc_entry("atalk", proc_net);
+	remove_proc_entry("atalk", init_net.proc_net);
 	goto out;
 }
 
@@ -316,5 +317,5 @@
 	remove_proc_entry("route", atalk_proc_dir);
 	remove_proc_entry("socket", atalk_proc_dir);
 	remove_proc_entry("arp", atalk_proc_dir);
-	remove_proc_entry("atalk", proc_net);
+	remove_proc_entry("atalk", init_net.proc_net);
 }
diff -Nurb linux-2.6.22-590/net/appletalk/ddp.c linux-2.6.22-try2-netns/net/appletalk/ddp.c
--- linux-2.6.22-590/net/appletalk/ddp.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/appletalk/ddp.c	2007-12-19 22:49:18.000000000 -0500
@@ -647,9 +647,14 @@
 static int ddp_device_event(struct notifier_block *this, unsigned long event,
 			    void *ptr)
 {
+	struct net_device *dev = ptr;
+
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (event == NETDEV_DOWN)
 		/* Discard any use of this */
-		atalk_dev_down(ptr);
+		atalk_dev_down(dev);
 
 	return NOTIFY_DONE;
 }
@@ -672,7 +677,7 @@
 	if (copy_from_user(&atreq, arg, sizeof(atreq)))
 		return -EFAULT;
 
-	dev = __dev_get_by_name(atreq.ifr_name);
+	dev = __dev_get_by_name(&init_net, atreq.ifr_name);
 	if (!dev)
 		return -ENODEV;
 
@@ -896,7 +901,7 @@
 				if (copy_from_user(name, rt.rt_dev, IFNAMSIZ-1))
 					return -EFAULT;
 				name[IFNAMSIZ-1] = '\0';
-				dev = __dev_get_by_name(name);
+				dev = __dev_get_by_name(&init_net, name);
 				if (!dev)
 					return -ENODEV;
 			}
@@ -1024,11 +1029,14 @@
  * Create a socket. Initialise the socket, blank the addresses
  * set the state.
  */
-static int atalk_create(struct socket *sock, int protocol)
+static int atalk_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 	int rc = -ESOCKTNOSUPPORT;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	/*
 	 * We permit SOCK_DGRAM and RAW is an extension. It is trivial to do
 	 * and gives you the full ELAP frame. Should be handy for CAP 8)
@@ -1036,7 +1044,7 @@
 	if (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)
 		goto out;
 	rc = -ENOMEM;
-	sk = sk_alloc(PF_APPLETALK, GFP_KERNEL, &ddp_proto, 1);
+	sk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, 1);
 	if (!sk)
 		goto out;
 	rc = 0;
@@ -1265,7 +1273,7 @@
 
 static int handle_ip_over_ddp(struct sk_buff *skb)
 {
-	struct net_device *dev = __dev_get_by_name("ipddp0");
+	struct net_device *dev = __dev_get_by_name(&init_net, "ipddp0");
 	struct net_device_stats *stats;
 
 	/* This needs to be able to handle ipddp"N" devices */
@@ -1398,6 +1406,9 @@
 	int origlen;
 	__u16 len_hops;
 
+	if (dev->nd_net != &init_net)
+		goto freeit;
+
 	/* Don't mangle buffer if shared */
 	if (!(skb = skb_share_check(skb, GFP_ATOMIC)))
 		goto out;
@@ -1483,6 +1494,9 @@
 static int ltalk_rcv(struct sk_buff *skb, struct net_device *dev,
 		     struct packet_type *pt, struct net_device *orig_dev)
 {
+	if (dev->nd_net != &init_net)
+		goto freeit;
+
 	/* Expand any short form frames */
 	if (skb_mac_header(skb)[2] == 1) {
 		struct ddpehdr *ddp;
diff -Nurb linux-2.6.22-590/net/atm/clip.c linux-2.6.22-try2-netns/net/atm/clip.c
--- linux-2.6.22-590/net/atm/clip.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/atm/clip.c	2007-12-19 22:49:18.000000000 -0500
@@ -293,7 +293,7 @@
 	struct neigh_parms *parms;
 
 	DPRINTK("clip_constructor (neigh %p, entry %p)\n", neigh, entry);
-	neigh->type = inet_addr_type(entry->ip);
+	neigh->type = inet_addr_type(&init_net, entry->ip);
 	if (neigh->type != RTN_UNICAST)
 		return -EINVAL;
 
@@ -525,7 +525,10 @@
 	struct atmarp_entry *entry;
 	int error;
 	struct clip_vcc *clip_vcc;
-	struct flowi fl = { .nl_u = { .ip4_u = { .daddr = ip, .tos = 1}} };
+	struct flowi fl = { 
+		.fl_net = &init_net,
+		.nl_u = { .ip4_u = { .daddr = ip, .tos = 1}} 
+	};
 	struct rtable *rt;
 
 	if (vcc->push != clip_push) {
@@ -620,6 +623,9 @@
 {
 	struct net_device *dev = arg;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (event == NETDEV_UNREGISTER) {
 		neigh_ifdown(&clip_tbl, dev);
 		return NOTIFY_DONE;
@@ -954,6 +960,7 @@
 
 	seq = file->private_data;
 	seq->private = state;
+	state->ns.net = get_net(PROC_NET(inode));
 out:
 	return rc;
 
@@ -962,11 +969,19 @@
 	goto out;
 }
 
+static int arp_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct clip_seq_state *state = seq->private;
+	put_net(state->ns.net);
+	return seq_release_private(inode, file);
+}
+
 static const struct file_operations arp_seq_fops = {
 	.open		= arp_seq_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
-	.release	= seq_release_private,
+	.release	= arp_seq_release,
 	.owner		= THIS_MODULE
 };
 #endif
diff -Nurb linux-2.6.22-590/net/atm/common.c linux-2.6.22-try2-netns/net/atm/common.c
--- linux-2.6.22-590/net/atm/common.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/atm/common.c	2007-12-19 22:49:18.000000000 -0500
@@ -132,7 +132,7 @@
 	.obj_size = sizeof(struct atm_vcc),
 };
 
-int vcc_create(struct socket *sock, int protocol, int family)
+int vcc_create(struct net *net, struct socket *sock, int protocol, int family)
 {
 	struct sock *sk;
 	struct atm_vcc *vcc;
@@ -140,7 +140,7 @@
 	sock->sk = NULL;
 	if (sock->type == SOCK_STREAM)
 		return -EINVAL;
-	sk = sk_alloc(family, GFP_KERNEL, &vcc_proto, 1);
+	sk = sk_alloc(net, family, GFP_KERNEL, &vcc_proto, 1);
 	if (!sk)
 		return -ENOMEM;
 	sock_init_data(sock, sk);
diff -Nurb linux-2.6.22-590/net/atm/common.h linux-2.6.22-try2-netns/net/atm/common.h
--- linux-2.6.22-590/net/atm/common.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/atm/common.h	2007-12-19 22:49:18.000000000 -0500
@@ -10,7 +10,7 @@
 #include <linux/poll.h> /* for poll_table */
 
 
-int vcc_create(struct socket *sock, int protocol, int family);
+int vcc_create(struct net *net, struct socket *sock, int protocol, int family);
 int vcc_release(struct socket *sock);
 int vcc_connect(struct socket *sock, int itf, short vpi, int vci);
 int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
diff -Nurb linux-2.6.22-590/net/atm/mpc.c linux-2.6.22-try2-netns/net/atm/mpc.c
--- linux-2.6.22-590/net/atm/mpc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/atm/mpc.c	2007-12-19 22:49:18.000000000 -0500
@@ -244,7 +244,7 @@
 	char name[IFNAMSIZ];
 
 	sprintf(name, "lec%d", itf);
-	dev = dev_get_by_name(name);
+	dev = dev_get_by_name(&init_net, name);
 
 	return dev;
 }
@@ -956,6 +956,10 @@
 	struct lec_priv *priv;
 
 	dev = (struct net_device *)dev_ptr;
+
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (dev->name == NULL || strncmp(dev->name, "lec", 3))
 		return NOTIFY_DONE; /* we are only interested in lec:s */
 
diff -Nurb linux-2.6.22-590/net/atm/proc.c linux-2.6.22-try2-netns/net/atm/proc.c
--- linux-2.6.22-590/net/atm/proc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/atm/proc.c	2007-12-19 22:49:18.000000000 -0500
@@ -22,6 +22,7 @@
 #include <linux/netdevice.h>
 #include <linux/atmclip.h>
 #include <linux/init.h> /* for __init */
+#include <net/net_namespace.h>
 #include <net/atmclip.h>
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
@@ -475,7 +476,7 @@
 		if (e->dirent)
 			remove_proc_entry(e->name, atm_proc_root);
 	}
-	remove_proc_entry("net/atm", NULL);
+	remove_proc_entry("atm", init_net.proc_net);
 }
 
 int __init atm_proc_init(void)
@@ -483,7 +484,7 @@
 	static struct atm_proc_entry *e;
 	int ret;
 
-	atm_proc_root = proc_mkdir("net/atm",NULL);
+	atm_proc_root = proc_mkdir("atm", init_net.proc_net);
 	if (!atm_proc_root)
 		goto err_out;
 	for (e = atm_proc_ents; e->name; e++) {
diff -Nurb linux-2.6.22-590/net/atm/pvc.c linux-2.6.22-try2-netns/net/atm/pvc.c
--- linux-2.6.22-590/net/atm/pvc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/atm/pvc.c	2007-12-19 22:49:18.000000000 -0500
@@ -124,10 +124,13 @@
 };
 
 
-static int pvc_create(struct socket *sock,int protocol)
+static int pvc_create(struct net *net, struct socket *sock,int protocol)
 {
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	sock->ops = &pvc_proto_ops;
-	return vcc_create(sock, protocol, PF_ATMPVC);
+	return vcc_create(net, sock, protocol, PF_ATMPVC);
 }
 
 
diff -Nurb linux-2.6.22-590/net/atm/svc.c linux-2.6.22-try2-netns/net/atm/svc.c
--- linux-2.6.22-590/net/atm/svc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/atm/svc.c	2007-12-19 22:49:18.000000000 -0500
@@ -33,7 +33,7 @@
 #endif
 
 
-static int svc_create(struct socket *sock,int protocol);
+static int svc_create(struct net *net, struct socket *sock,int protocol);
 
 
 /*
@@ -335,7 +335,7 @@
 
 	lock_sock(sk);
 
-	error = svc_create(newsock,0);
+	error = svc_create(sk->sk_net, newsock,0);
 	if (error)
 		goto out;
 
@@ -636,12 +636,15 @@
 };
 
 
-static int svc_create(struct socket *sock,int protocol)
+static int svc_create(struct net *net, struct socket *sock,int protocol)
 {
 	int error;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	sock->ops = &svc_proto_ops;
-	error = vcc_create(sock, protocol, AF_ATMSVC);
+	error = vcc_create(net, sock, protocol, AF_ATMSVC);
 	if (error) return error;
 	ATM_SD(sock)->local.sas_family = AF_ATMSVC;
 	ATM_SD(sock)->remote.sas_family = AF_ATMSVC;
diff -Nurb linux-2.6.22-590/net/ax25/af_ax25.c linux-2.6.22-try2-netns/net/ax25/af_ax25.c
--- linux-2.6.22-590/net/ax25/af_ax25.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ax25/af_ax25.c	2007-12-19 22:49:18.000000000 -0500
@@ -47,6 +47,7 @@
 #include <net/tcp_states.h>
 #include <net/ip.h>
 #include <net/arp.h>
+#include <net/net_namespace.h>
 
 
 
@@ -103,6 +104,9 @@
 {
 	struct net_device *dev = (struct net_device *)ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	/* Reject non AX.25 devices */
 	if (dev->type != ARPHRD_AX25)
 		return NOTIFY_DONE;
@@ -627,7 +631,7 @@
 			break;
 		}
 
-		dev = dev_get_by_name(devname);
+		dev = dev_get_by_name(&init_net, devname);
 		if (dev == NULL) {
 			res = -ENODEV;
 			break;
@@ -779,11 +783,14 @@
 	.obj_size = sizeof(struct sock),
 };
 
-static int ax25_create(struct socket *sock, int protocol)
+static int ax25_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 	ax25_cb *ax25;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	switch (sock->type) {
 	case SOCK_DGRAM:
 		if (protocol == 0 || protocol == PF_AX25)
@@ -829,7 +836,7 @@
 		return -ESOCKTNOSUPPORT;
 	}
 
-	if ((sk = sk_alloc(PF_AX25, GFP_ATOMIC, &ax25_proto, 1)) == NULL)
+	if ((sk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, 1)) == NULL)
 		return -ENOMEM;
 
 	ax25 = sk->sk_protinfo = ax25_create_cb();
@@ -854,7 +861,7 @@
 	struct sock *sk;
 	ax25_cb *ax25, *oax25;
 
-	if ((sk = sk_alloc(PF_AX25, GFP_ATOMIC, osk->sk_prot, 1)) == NULL)
+	if ((sk = sk_alloc(osk->sk_net, PF_AX25, GFP_ATOMIC, osk->sk_prot, 1)) == NULL)
 		return NULL;
 
 	if ((ax25 = ax25_create_cb()) == NULL) {
@@ -1998,9 +2005,9 @@
 	register_netdevice_notifier(&ax25_dev_notifier);
 	ax25_register_sysctl();
 
-	proc_net_fops_create("ax25_route", S_IRUGO, &ax25_route_fops);
-	proc_net_fops_create("ax25", S_IRUGO, &ax25_info_fops);
-	proc_net_fops_create("ax25_calls", S_IRUGO, &ax25_uid_fops);
+	proc_net_fops_create(&init_net, "ax25_route", S_IRUGO, &ax25_route_fops);
+	proc_net_fops_create(&init_net, "ax25", S_IRUGO, &ax25_info_fops);
+	proc_net_fops_create(&init_net, "ax25_calls", S_IRUGO, &ax25_uid_fops);
 out:
 	return rc;
 }
@@ -2014,9 +2021,9 @@
 
 static void __exit ax25_exit(void)
 {
-	proc_net_remove("ax25_route");
-	proc_net_remove("ax25");
-	proc_net_remove("ax25_calls");
+	proc_net_remove(&init_net, "ax25_route");
+	proc_net_remove(&init_net, "ax25");
+	proc_net_remove(&init_net, "ax25_calls");
 	ax25_rt_free();
 	ax25_uid_free();
 	ax25_dev_free();
diff -Nurb linux-2.6.22-590/net/ax25/ax25_in.c linux-2.6.22-try2-netns/net/ax25/ax25_in.c
--- linux-2.6.22-590/net/ax25/ax25_in.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ax25/ax25_in.c	2007-12-19 22:49:18.000000000 -0500
@@ -451,6 +451,11 @@
 	skb->sk = NULL;		/* Initially we don't know who it's for */
 	skb->destructor = NULL;	/* Who initializes this, dammit?! */
 
+	if (dev->nd_net != &init_net) {
+		kfree_skb(skb);
+		return 0;
+	}
+
 	if ((*skb->data & 0x0F) != 0) {
 		kfree_skb(skb);	/* Not a KISS data frame */
 		return 0;
diff -Nurb linux-2.6.22-590/net/bluetooth/af_bluetooth.c linux-2.6.22-try2-netns/net/bluetooth/af_bluetooth.c
--- linux-2.6.22-590/net/bluetooth/af_bluetooth.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bluetooth/af_bluetooth.c	2007-12-19 22:49:18.000000000 -0500
@@ -95,10 +95,13 @@
 }
 EXPORT_SYMBOL(bt_sock_unregister);
 
-static int bt_sock_create(struct socket *sock, int proto)
+static int bt_sock_create(struct net *net, struct socket *sock, int proto)
 {
 	int err;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	if (proto < 0 || proto >= BT_MAX_PROTO)
 		return -EINVAL;
 
@@ -113,7 +116,7 @@
 	read_lock(&bt_proto_lock);
 
 	if (bt_proto[proto] && try_module_get(bt_proto[proto]->owner)) {
-		err = bt_proto[proto]->create(sock, proto);
+		err = bt_proto[proto]->create(net, sock, proto);
 		module_put(bt_proto[proto]->owner);
 	}
 
diff -Nurb linux-2.6.22-590/net/bluetooth/bnep/sock.c linux-2.6.22-try2-netns/net/bluetooth/bnep/sock.c
--- linux-2.6.22-590/net/bluetooth/bnep/sock.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bluetooth/bnep/sock.c	2007-12-19 22:49:18.000000000 -0500
@@ -204,7 +204,7 @@
 	.obj_size	= sizeof(struct bt_sock)
 };
 
-static int bnep_sock_create(struct socket *sock, int protocol)
+static int bnep_sock_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 
@@ -213,7 +213,7 @@
 	if (sock->type != SOCK_RAW)
 		return -ESOCKTNOSUPPORT;
 
-	sk = sk_alloc(PF_BLUETOOTH, GFP_ATOMIC, &bnep_proto, 1);
+	sk = sk_alloc(net, PF_BLUETOOTH, GFP_ATOMIC, &bnep_proto, 1);
 	if (!sk)
 		return -ENOMEM;
 
diff -Nurb linux-2.6.22-590/net/bluetooth/cmtp/sock.c linux-2.6.22-try2-netns/net/bluetooth/cmtp/sock.c
--- linux-2.6.22-590/net/bluetooth/cmtp/sock.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bluetooth/cmtp/sock.c	2007-12-19 22:49:18.000000000 -0500
@@ -195,7 +195,7 @@
 	.obj_size	= sizeof(struct bt_sock)
 };
 
-static int cmtp_sock_create(struct socket *sock, int protocol)
+static int cmtp_sock_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 
@@ -204,7 +204,7 @@
 	if (sock->type != SOCK_RAW)
 		return -ESOCKTNOSUPPORT;
 
-	sk = sk_alloc(PF_BLUETOOTH, GFP_ATOMIC, &cmtp_proto, 1);
+	sk = sk_alloc(net, PF_BLUETOOTH, GFP_ATOMIC, &cmtp_proto, 1);
 	if (!sk)
 		return -ENOMEM;
 
diff -Nurb linux-2.6.22-590/net/bluetooth/hci_sock.c linux-2.6.22-try2-netns/net/bluetooth/hci_sock.c
--- linux-2.6.22-590/net/bluetooth/hci_sock.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bluetooth/hci_sock.c	2007-12-19 22:49:18.000000000 -0500
@@ -618,7 +618,7 @@
 	.obj_size	= sizeof(struct hci_pinfo)
 };
 
-static int hci_sock_create(struct socket *sock, int protocol)
+static int hci_sock_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 
@@ -629,7 +629,7 @@
 
 	sock->ops = &hci_sock_ops;
 
-	sk = sk_alloc(PF_BLUETOOTH, GFP_ATOMIC, &hci_sk_proto, 1);
+	sk = sk_alloc(net, PF_BLUETOOTH, GFP_ATOMIC, &hci_sk_proto, 1);
 	if (!sk)
 		return -ENOMEM;
 
diff -Nurb linux-2.6.22-590/net/bluetooth/hidp/sock.c linux-2.6.22-try2-netns/net/bluetooth/hidp/sock.c
--- linux-2.6.22-590/net/bluetooth/hidp/sock.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bluetooth/hidp/sock.c	2007-12-19 22:49:18.000000000 -0500
@@ -246,7 +246,7 @@
 	.obj_size	= sizeof(struct bt_sock)
 };
 
-static int hidp_sock_create(struct socket *sock, int protocol)
+static int hidp_sock_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 
@@ -255,7 +255,7 @@
 	if (sock->type != SOCK_RAW)
 		return -ESOCKTNOSUPPORT;
 
-	sk = sk_alloc(PF_BLUETOOTH, GFP_ATOMIC, &hidp_proto, 1);
+	sk = sk_alloc(net, PF_BLUETOOTH, GFP_ATOMIC, &hidp_proto, 1);
 	if (!sk)
 		return -ENOMEM;
 
diff -Nurb linux-2.6.22-590/net/bluetooth/l2cap.c linux-2.6.22-try2-netns/net/bluetooth/l2cap.c
--- linux-2.6.22-590/net/bluetooth/l2cap.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bluetooth/l2cap.c	2007-12-19 22:49:18.000000000 -0500
@@ -518,11 +518,11 @@
 	.obj_size	= sizeof(struct l2cap_pinfo)
 };
 
-static struct sock *l2cap_sock_alloc(struct socket *sock, int proto, gfp_t prio)
+static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)
 {
 	struct sock *sk;
 
-	sk = sk_alloc(PF_BLUETOOTH, prio, &l2cap_proto, 1);
+	sk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto, 1);
 	if (!sk)
 		return NULL;
 
@@ -543,7 +543,7 @@
 	return sk;
 }
 
-static int l2cap_sock_create(struct socket *sock, int protocol)
+static int l2cap_sock_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 
@@ -560,7 +560,7 @@
 
 	sock->ops = &l2cap_sock_ops;
 
-	sk = l2cap_sock_alloc(sock, protocol, GFP_ATOMIC);
+	sk = l2cap_sock_alloc(net, sock, protocol, GFP_ATOMIC);
 	if (!sk)
 		return -ENOMEM;
 
@@ -1425,7 +1425,7 @@
 		goto response;
 	}
 
-	sk = l2cap_sock_alloc(NULL, BTPROTO_L2CAP, GFP_ATOMIC);
+	sk = l2cap_sock_alloc(parent->sk_net, NULL, BTPROTO_L2CAP, GFP_ATOMIC);
 	if (!sk)
 		goto response;
 
diff -Nurb linux-2.6.22-590/net/bluetooth/rfcomm/sock.c linux-2.6.22-try2-netns/net/bluetooth/rfcomm/sock.c
--- linux-2.6.22-590/net/bluetooth/rfcomm/sock.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bluetooth/rfcomm/sock.c	2007-12-19 22:49:18.000000000 -0500
@@ -282,12 +282,12 @@
 	.obj_size	= sizeof(struct rfcomm_pinfo)
 };
 
-static struct sock *rfcomm_sock_alloc(struct socket *sock, int proto, gfp_t prio)
+static struct sock *rfcomm_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)
 {
 	struct rfcomm_dlc *d;
 	struct sock *sk;
 
-	sk = sk_alloc(PF_BLUETOOTH, prio, &rfcomm_proto, 1);
+	sk = sk_alloc(net, PF_BLUETOOTH, prio, &rfcomm_proto, 1);
 	if (!sk)
 		return NULL;
 
@@ -323,7 +323,7 @@
 	return sk;
 }
 
-static int rfcomm_sock_create(struct socket *sock, int protocol)
+static int rfcomm_sock_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 
@@ -336,7 +336,7 @@
 
 	sock->ops = &rfcomm_sock_ops;
 
-	sk = rfcomm_sock_alloc(sock, protocol, GFP_ATOMIC);
+	sk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC);
 	if (!sk)
 		return -ENOMEM;
 
@@ -868,7 +868,7 @@
 		goto done;
 	}
 
-	sk = rfcomm_sock_alloc(NULL, BTPROTO_RFCOMM, GFP_ATOMIC);
+	sk = rfcomm_sock_alloc(parent->sk_net, NULL, BTPROTO_RFCOMM, GFP_ATOMIC);
 	if (!sk)
 		goto done;
 
diff -Nurb linux-2.6.22-590/net/bluetooth/sco.c linux-2.6.22-try2-netns/net/bluetooth/sco.c
--- linux-2.6.22-590/net/bluetooth/sco.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bluetooth/sco.c	2007-12-19 22:49:18.000000000 -0500
@@ -414,11 +414,11 @@
 	.obj_size	= sizeof(struct sco_pinfo)
 };
 
-static struct sock *sco_sock_alloc(struct socket *sock, int proto, gfp_t prio)
+static struct sock *sco_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)
 {
 	struct sock *sk;
 
-	sk = sk_alloc(PF_BLUETOOTH, prio, &sco_proto, 1);
+	sk = sk_alloc(net, PF_BLUETOOTH, prio, &sco_proto, 1);
 	if (!sk)
 		return NULL;
 
@@ -439,7 +439,7 @@
 	return sk;
 }
 
-static int sco_sock_create(struct socket *sock, int protocol)
+static int sco_sock_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 
@@ -452,7 +452,7 @@
 
 	sock->ops = &sco_sock_ops;
 
-	sk = sco_sock_alloc(sock, protocol, GFP_ATOMIC);
+	sk = sco_sock_alloc(net, sock, protocol, GFP_ATOMIC);
 	if (!sk)
 		return -ENOMEM;
 
@@ -807,7 +807,7 @@
 
 		bh_lock_sock(parent);
 
-		sk = sco_sock_alloc(NULL, BTPROTO_SCO, GFP_ATOMIC);
+		sk = sco_sock_alloc(parent->sk_net, NULL, BTPROTO_SCO, GFP_ATOMIC);
 		if (!sk) {
 			bh_unlock_sock(parent);
 			goto done;
diff -Nurb linux-2.6.22-590/net/bridge/br_if.c linux-2.6.22-try2-netns/net/bridge/br_if.c
--- linux-2.6.22-590/net/bridge/br_if.c	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/net/bridge/br_if.c	2007-12-19 22:49:18.000000000 -0500
@@ -45,7 +45,7 @@
 
 	old_fs = get_fs();
 	set_fs(KERNEL_DS);
-	err = dev_ethtool(&ifr);
+	err = dev_ethtool(dev->nd_net, &ifr);
 	set_fs(old_fs);
 
 	if (!err) {
@@ -314,7 +314,7 @@
 	int ret = 0;
 
 	rtnl_lock();
-	dev = __dev_get_by_name(name);
+	dev = __dev_get_by_name(&init_net, name);
 	if (dev == NULL)
 		ret =  -ENXIO; 	/* Could not find device */
 
@@ -455,7 +455,7 @@
 	struct net_device *dev, *nxt;
 
 	rtnl_lock();
-	for_each_netdev_safe(dev, nxt)
+	for_each_netdev_safe(&init_net, dev, nxt)
 		if (dev->priv_flags & IFF_EBRIDGE)
 			del_br(dev->priv);
 	rtnl_unlock();
diff -Nurb linux-2.6.22-590/net/bridge/br_ioctl.c linux-2.6.22-try2-netns/net/bridge/br_ioctl.c
--- linux-2.6.22-590/net/bridge/br_ioctl.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bridge/br_ioctl.c	2007-12-19 22:49:18.000000000 -0500
@@ -18,6 +18,7 @@
 #include <linux/if_bridge.h>
 #include <linux/netdevice.h>
 #include <linux/times.h>
+#include <net/net_namespace.h>
 #include <asm/uaccess.h>
 #include "br_private.h"
 
@@ -27,7 +28,7 @@
 	struct net_device *dev;
 	int i = 0;
 
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if (i >= num)
 			break;
 		if (dev->priv_flags & IFF_EBRIDGE)
@@ -90,7 +91,7 @@
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	dev = dev_get_by_index(ifindex);
+	dev = dev_get_by_index(&init_net, ifindex);
 	if (dev == NULL)
 		return -EINVAL;
 
@@ -364,7 +365,7 @@
 	return -EOPNOTSUPP;
 }
 
-int br_ioctl_deviceless_stub(unsigned int cmd, void __user *uarg)
+int br_ioctl_deviceless_stub(struct net *net, unsigned int cmd, void __user *uarg)
 {
 	switch (cmd) {
 	case SIOCGIFBR:
diff -Nurb linux-2.6.22-590/net/bridge/br_netfilter.c linux-2.6.22-try2-netns/net/bridge/br_netfilter.c
--- linux-2.6.22-590/net/bridge/br_netfilter.c	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/net/bridge/br_netfilter.c	2007-12-19 22:49:18.000000000 -0500
@@ -310,6 +310,7 @@
 		if ((err = ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, dev))) {
 			struct rtable *rt;
 			struct flowi fl = {
+				.fl_net = &init_net,
 				.nl_u = {
 					.ip4_u = {
 						 .daddr = iph->daddr,
@@ -518,6 +519,10 @@
 	if (unlikely(!pskb_may_pull(skb, len)))
 		goto out;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	if (skb->protocol == htons(ETH_P_IPV6) || IS_VLAN_IPV6(skb) ||
 	    IS_PPPOE_IPV6(skb)) {
 #ifdef CONFIG_SYSCTL
@@ -591,6 +596,10 @@
 {
 	struct sk_buff *skb = *pskb;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	if (skb->dst == (struct dst_entry *)&__fake_rtable) {
 		dst_release(skb->dst);
 		skb->dst = NULL;
@@ -635,6 +644,10 @@
 	struct net_device *parent;
 	int pf;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	if (!skb->nf_bridge)
 		return NF_ACCEPT;
 
@@ -674,6 +687,10 @@
 	struct sk_buff *skb = *pskb;
 	struct net_device **d = (struct net_device **)(skb->cb);
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 #ifdef CONFIG_SYSCTL
 	if (!brnf_call_arptables)
 		return NF_ACCEPT;
@@ -718,6 +735,10 @@
 	struct sk_buff *skb = *pskb;
 	struct nf_bridge_info *nf_bridge;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	if (!skb->nf_bridge)
 		return NF_ACCEPT;
 
@@ -762,6 +783,10 @@
 	struct net_device *realoutdev = bridge_parent(skb->dev);
 	int pf;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 #ifdef CONFIG_NETFILTER_DEBUG
 	/* Be very paranoid. This probably won't happen anymore, but let's
 	 * keep the check just to be sure... */
@@ -833,6 +858,10 @@
 				   const struct net_device *out,
 				   int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	if ((*pskb)->nf_bridge &&
 	    !((*pskb)->nf_bridge->mask & BRNF_NF_BRIDGE_PREROUTING)) {
 		return NF_STOP;
diff -Nurb linux-2.6.22-590/net/bridge/br_netlink.c linux-2.6.22-try2-netns/net/bridge/br_netlink.c
--- linux-2.6.22-590/net/bridge/br_netlink.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bridge/br_netlink.c	2007-12-19 22:49:18.000000000 -0500
@@ -12,6 +12,8 @@
 
 #include <linux/kernel.h>
 #include <net/rtnetlink.h>
+#include <net/net_namespace.h>
+#include <net/sock.h>
 #include "br_private.h"
 
 static inline size_t br_nlmsg_size(void)
@@ -95,10 +97,10 @@
 		kfree_skb(skb);
 		goto errout;
 	}
-	err = rtnl_notify(skb, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);
+	err = rtnl_notify(skb, &init_net,0, RTNLGRP_LINK, NULL, GFP_ATOMIC);
 errout:
 	if (err < 0)
-		rtnl_set_sk_err(RTNLGRP_LINK, err);
+		rtnl_set_sk_err(&init_net, RTNLGRP_LINK, err);
 }
 
 /*
@@ -106,11 +108,15 @@
  */
 static int br_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	struct net_device *dev;
 	int idx;
 
+	if (net != &init_net)
+		return 0;
+
 	idx = 0;
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		/* not a bridge port */
 		if (dev->br_port == NULL || idx < cb->args[0])
 			goto skip;
@@ -134,12 +140,16 @@
  */
 static int br_rtm_setlink(struct sk_buff *skb,  struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct ifinfomsg *ifm;
 	struct nlattr *protinfo;
 	struct net_device *dev;
 	struct net_bridge_port *p;
 	u8 new_state;
 
+	if (net != &init_net)
+		return -EINVAL;
+
 	if (nlmsg_len(nlh) < sizeof(*ifm))
 		return -EINVAL;
 
@@ -155,7 +165,7 @@
 	if (new_state > BR_STATE_BLOCKING)
 		return -EINVAL;
 
-	dev = __dev_get_by_index(ifm->ifi_index);
+	dev = __dev_get_by_index(&init_net, ifm->ifi_index);
 	if (!dev)
 		return -ENODEV;
 
diff -Nurb linux-2.6.22-590/net/bridge/br_notify.c linux-2.6.22-try2-netns/net/bridge/br_notify.c
--- linux-2.6.22-590/net/bridge/br_notify.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bridge/br_notify.c	2007-12-19 22:49:18.000000000 -0500
@@ -15,6 +15,7 @@
 
 #include <linux/kernel.h>
 #include <linux/rtnetlink.h>
+#include <net/net_namespace.h>
 
 #include "br_private.h"
 
@@ -36,6 +37,9 @@
 	struct net_bridge_port *p = dev->br_port;
 	struct net_bridge *br;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	/* not a port of a bridge */
 	if (p == NULL)
 		return NOTIFY_DONE;
diff -Nurb linux-2.6.22-590/net/bridge/br_private.h linux-2.6.22-try2-netns/net/bridge/br_private.h
--- linux-2.6.22-590/net/bridge/br_private.h	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bridge/br_private.h	2007-12-19 22:49:18.000000000 -0500
@@ -196,7 +196,7 @@
 
 /* br_ioctl.c */
 extern int br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
-extern int br_ioctl_deviceless_stub(unsigned int cmd, void __user *arg);
+extern int br_ioctl_deviceless_stub(struct net *net, unsigned int cmd, void __user *arg);
 
 /* br_netfilter.c */
 #ifdef CONFIG_BRIDGE_NETFILTER
diff -Nurb linux-2.6.22-590/net/bridge/br_stp_bpdu.c linux-2.6.22-try2-netns/net/bridge/br_stp_bpdu.c
--- linux-2.6.22-590/net/bridge/br_stp_bpdu.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bridge/br_stp_bpdu.c	2007-12-19 22:49:18.000000000 -0500
@@ -17,6 +17,7 @@
 #include <linux/netfilter_bridge.h>
 #include <linux/etherdevice.h>
 #include <linux/llc.h>
+#include <net/net_namespace.h>
 #include <net/llc.h>
 #include <net/llc_pdu.h>
 #include <asm/unaligned.h>
@@ -141,6 +142,9 @@
 	struct net_bridge *br;
 	const unsigned char *buf;
 
+	if (dev->nd_net != &init_net)
+		goto err;
+
 	if (!p)
 		goto err;
 
diff -Nurb linux-2.6.22-590/net/bridge/netfilter/ebt_ulog.c linux-2.6.22-try2-netns/net/bridge/netfilter/ebt_ulog.c
--- linux-2.6.22-590/net/bridge/netfilter/ebt_ulog.c	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/net/bridge/netfilter/ebt_ulog.c	2007-12-19 22:49:18.000000000 -0500
@@ -301,8 +301,9 @@
 		spin_lock_init(&ulog_buffers[i].lock);
 	}
 
-	ebtulognl = netlink_kernel_create(NETLINK_NFLOG, EBT_ULOG_MAXNLGROUPS,
-					  NULL, NULL, THIS_MODULE);
+	ebtulognl = netlink_kernel_create(&init_net, NETLINK_NFLOG,
+					  EBT_ULOG_MAXNLGROUPS, NULL, NULL,
+					  THIS_MODULE);
 	if (!ebtulognl)
 		ret = -ENOMEM;
 	else if ((ret = ebt_register_watcher(&ulog)))
diff -Nurb linux-2.6.22-590/net/bridge/netfilter/ebtable_filter.c linux-2.6.22-try2-netns/net/bridge/netfilter/ebtable_filter.c
--- linux-2.6.22-590/net/bridge/netfilter/ebtable_filter.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bridge/netfilter/ebtable_filter.c	2007-12-19 22:49:18.000000000 -0500
@@ -64,6 +64,10 @@
 ebt_hook (unsigned int hook, struct sk_buff **pskb, const struct net_device *in,
    const struct net_device *out, int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	return ebt_do_table(hook, pskb, in, out, &frame_filter);
 }
 
diff -Nurb linux-2.6.22-590/net/bridge/netfilter/ebtable_nat.c linux-2.6.22-try2-netns/net/bridge/netfilter/ebtable_nat.c
--- linux-2.6.22-590/net/bridge/netfilter/ebtable_nat.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bridge/netfilter/ebtable_nat.c	2007-12-19 22:49:18.000000000 -0500
@@ -64,6 +64,10 @@
 ebt_nat_dst(unsigned int hook, struct sk_buff **pskb, const struct net_device *in
    , const struct net_device *out, int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	return ebt_do_table(hook, pskb, in, out, &frame_nat);
 }
 
@@ -71,6 +75,10 @@
 ebt_nat_src(unsigned int hook, struct sk_buff **pskb, const struct net_device *in
    , const struct net_device *out, int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	return ebt_do_table(hook, pskb, in, out, &frame_nat);
 }
 
diff -Nurb linux-2.6.22-590/net/bridge/netfilter/ebtables.c linux-2.6.22-try2-netns/net/bridge/netfilter/ebtables.c
--- linux-2.6.22-590/net/bridge/netfilter/ebtables.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/bridge/netfilter/ebtables.c	2007-12-19 22:49:18.000000000 -0500
@@ -28,6 +28,7 @@
 #include <linux/smp.h>
 #include <linux/cpumask.h>
 #include <net/sock.h>
+#include <net/net_namespace.h>
 /* needed for logical [in,out]-dev filtering */
 #include "../br_private.h"
 
@@ -1438,6 +1439,9 @@
 {
 	int ret;
 
+	if (sk->sk_net != &init_net)
+		return -ENOPROTOOPT;
+
 	switch(cmd) {
 	case EBT_SO_SET_ENTRIES:
 		ret = do_replace(user, len);
@@ -1457,6 +1461,9 @@
 	struct ebt_replace tmp;
 	struct ebt_table *t;
 
+	if (sk->sk_net != &init_net)
+		return -ENOPROTOOPT;
+
 	if (copy_from_user(&tmp, user, sizeof(tmp)))
 		return -EFAULT;
 
diff -Nurb linux-2.6.22-590/net/core/Makefile linux-2.6.22-try2-netns/net/core/Makefile
--- linux-2.6.22-590/net/core/Makefile	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/core/Makefile	2007-12-19 22:49:18.000000000 -0500
@@ -3,7 +3,7 @@
 #
 
 obj-y := sock.o request_sock.o skbuff.o iovec.o datagram.o stream.o scm.o \
-	 gen_stats.o gen_estimator.o
+	 gen_stats.o gen_estimator.o net_namespace.o
 
 obj-$(CONFIG_SYSCTL) += sysctl_net_core.o
 
diff -Nurb linux-2.6.22-590/net/core/dev.c linux-2.6.22-try2-netns/net/core/dev.c
--- linux-2.6.22-590/net/core/dev.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/core/dev.c	2007-12-19 23:03:34.000000000 -0500
@@ -116,6 +116,7 @@
 #include <linux/dmaengine.h>
 #include <linux/err.h>
 #include <linux/ctype.h>
+#include <net/net_namespace.h>
 #include <linux/if_arp.h>
 #include <linux/vs_inet.h>
 
@@ -189,25 +190,50 @@
  * unregister_netdevice(), which must be called with the rtnl
  * semaphore held.
  */
-LIST_HEAD(dev_base_head);
 DEFINE_RWLOCK(dev_base_lock);
 
-EXPORT_SYMBOL(dev_base_head);
 EXPORT_SYMBOL(dev_base_lock);
 
 #define NETDEV_HASHBITS	8
-static struct hlist_head dev_name_head[1<<NETDEV_HASHBITS];
-static struct hlist_head dev_index_head[1<<NETDEV_HASHBITS];
+#define NETDEV_HASHENTRIES (1 << NETDEV_HASHBITS)
 
-static inline struct hlist_head *dev_name_hash(const char *name)
+static inline struct hlist_head *dev_name_hash(struct net *net, const char *name)
 {
 	unsigned hash = full_name_hash(name, strnlen(name, IFNAMSIZ));
-	return &dev_name_head[hash & ((1<<NETDEV_HASHBITS)-1)];
+	return &net->dev_name_head[hash & ((1 << NETDEV_HASHBITS) - 1)];
 }
 
-static inline struct hlist_head *dev_index_hash(int ifindex)
+static inline struct hlist_head *dev_index_hash(struct net *net, int ifindex)
 {
-	return &dev_index_head[ifindex & ((1<<NETDEV_HASHBITS)-1)];
+	return &net->dev_index_head[ifindex & ((1 << NETDEV_HASHBITS) - 1)];
+}
+
+/* Device list insertion */
+static int list_netdevice(struct net_device *dev)
+{
+	struct net *net = dev->nd_net;
+
+	ASSERT_RTNL();
+
+	write_lock_bh(&dev_base_lock);
+	list_add_tail(&dev->dev_list, &net->dev_base_head);
+	hlist_add_head(&dev->name_hlist, dev_name_hash(net, dev->name));
+	hlist_add_head(&dev->index_hlist, dev_index_hash(net, dev->ifindex));
+	write_unlock_bh(&dev_base_lock);
+	return 0;
+}
+
+/* Device list removal */
+static void unlist_netdevice(struct net_device *dev)
+{
+	ASSERT_RTNL();
+
+	/* Unlink dev from the device chain */
+	write_lock_bh(&dev_base_lock);
+	list_del(&dev->dev_list);
+	hlist_del(&dev->name_hlist);
+	hlist_del(&dev->index_hlist);
+	write_unlock_bh(&dev_base_lock);
 }
 
 /*
@@ -490,7 +516,7 @@
 	 * If device already registered then return base of 1
 	 * to indicate not to probe for this interface
 	 */
-	if (__dev_get_by_name(name))
+	if (__dev_get_by_name(&init_net, name))
 		return 1;
 
 	for (i = 0; i < NETDEV_BOOT_SETUP_MAX; i++)
@@ -545,11 +571,11 @@
  *	careful with locks.
  */
 
-struct net_device *__dev_get_by_name(const char *name)
+struct net_device *__dev_get_by_name(struct net *net, const char *name)
 {
 	struct hlist_node *p;
 
-	hlist_for_each(p, dev_name_hash(name)) {
+	hlist_for_each(p, dev_name_hash(net, name)) {
 		struct net_device *dev
 			= hlist_entry(p, struct net_device, name_hlist);
 		if (!strncmp(dev->name, name, IFNAMSIZ))
@@ -569,12 +595,12 @@
  *	matching device is found.
  */
 
-struct net_device *dev_get_by_name(const char *name)
+struct net_device *dev_get_by_name(struct net *net, const char *name)
 {
 	struct net_device *dev;
 
 	read_lock(&dev_base_lock);
-	dev = __dev_get_by_name(name);
+	dev = __dev_get_by_name(net, name);
 	if (dev)
 		dev_hold(dev);
 	read_unlock(&dev_base_lock);
@@ -592,11 +618,11 @@
  *	or @dev_base_lock.
  */
 
-struct net_device *__dev_get_by_index(int ifindex)
+struct net_device *__dev_get_by_index(struct net *net, int ifindex)
 {
 	struct hlist_node *p;
 
-	hlist_for_each(p, dev_index_hash(ifindex)) {
+	hlist_for_each(p, dev_index_hash(net, ifindex)) {
 		struct net_device *dev
 			= hlist_entry(p, struct net_device, index_hlist);
 		if (dev->ifindex == ifindex)
@@ -616,12 +642,12 @@
  *	dev_put to indicate they have finished with it.
  */
 
-struct net_device *dev_get_by_index(int ifindex)
+struct net_device *dev_get_by_index(struct net *net, int ifindex)
 {
 	struct net_device *dev;
 
 	read_lock(&dev_base_lock);
-	dev = __dev_get_by_index(ifindex);
+	dev = __dev_get_by_index(net, ifindex);
 	if (dev)
 		dev_hold(dev);
 	read_unlock(&dev_base_lock);
@@ -642,13 +668,13 @@
  *	If the API was consistent this would be __dev_get_by_hwaddr
  */
 
-struct net_device *dev_getbyhwaddr(unsigned short type, char *ha)
+struct net_device *dev_getbyhwaddr(struct net *net, unsigned short type, char *ha)
 {
 	struct net_device *dev;
 
 	ASSERT_RTNL();
 
-	for_each_netdev(dev)
+	for_each_netdev(&init_net, dev)
 		if (dev->type == type &&
 		    !memcmp(dev->dev_addr, ha, dev->addr_len))
 			return dev;
@@ -658,12 +684,12 @@
 
 EXPORT_SYMBOL(dev_getbyhwaddr);
 
-struct net_device *__dev_getfirstbyhwtype(unsigned short type)
+struct net_device *__dev_getfirstbyhwtype(struct net *net, unsigned short type)
 {
 	struct net_device *dev;
 
 	ASSERT_RTNL();
-	for_each_netdev(dev)
+	for_each_netdev(net, dev)
 		if (dev->type == type)
 			return dev;
 
@@ -672,12 +698,12 @@
 
 EXPORT_SYMBOL(__dev_getfirstbyhwtype);
 
-struct net_device *dev_getfirstbyhwtype(unsigned short type)
+struct net_device *dev_getfirstbyhwtype(struct net *net, unsigned short type)
 {
 	struct net_device *dev;
 
 	rtnl_lock();
-	dev = __dev_getfirstbyhwtype(type);
+	dev = __dev_getfirstbyhwtype(net, type);
 	if (dev)
 		dev_hold(dev);
 	rtnl_unlock();
@@ -697,13 +723,13 @@
  *	dev_put to indicate they have finished with it.
  */
 
-struct net_device * dev_get_by_flags(unsigned short if_flags, unsigned short mask)
+struct net_device * dev_get_by_flags(struct net *net, unsigned short if_flags, unsigned short mask)
 {
 	struct net_device *dev, *ret;
 
 	ret = NULL;
 	read_lock(&dev_base_lock);
-	for_each_netdev(dev) {
+	for_each_netdev(net, dev) {
 		if (((dev->flags ^ if_flags) & mask) == 0) {
 			dev_hold(dev);
 			ret = dev;
@@ -740,9 +766,10 @@
 }
 
 /**
- *	dev_alloc_name - allocate a name for a device
- *	@dev: device
+ *	__dev_alloc_name - allocate a name for a device
+ *	@net: network namespace to allocate the device name in
  *	@name: name format string
+ *	@buf:  scratch buffer and result name string
  *
  *	Passed a format string - eg "lt%d" it will try and find a suitable
  *	id. It scans list of devices to build up a free map, then chooses
@@ -753,10 +780,9 @@
  *	Returns the number of the unit assigned or a negative errno code.
  */
 
-int dev_alloc_name(struct net_device *dev, const char *name)
+static int __dev_alloc_name(struct net *net, const char *name, char *buf)
 {
 	int i = 0;
-	char buf[IFNAMSIZ];
 	const char *p;
 	const int max_netdevices = 8*PAGE_SIZE;
 	long *inuse;
@@ -777,14 +803,14 @@
 		if (!inuse)
 			return -ENOMEM;
 
-		for_each_netdev(d) {
+		for_each_netdev(net, d) {
 			if (!sscanf(d->name, name, &i))
 				continue;
 			if (i < 0 || i >= max_netdevices)
 				continue;
 
 			/*  avoid cases where sscanf is not exact inverse of printf */
-			snprintf(buf, sizeof(buf), name, i);
+			snprintf(buf, IFNAMSIZ, name, i);
 			if (!strncmp(buf, d->name, IFNAMSIZ))
 				set_bit(i, inuse);
 		}
@@ -793,11 +819,9 @@
 		free_page((unsigned long) inuse);
 	}
 
-	snprintf(buf, sizeof(buf), name, i);
-	if (!__dev_get_by_name(buf)) {
-		strlcpy(dev->name, buf, IFNAMSIZ);
+	snprintf(buf, IFNAMSIZ, name, i);
+	if (!__dev_get_by_name(net, buf))
 		return i;
-	}
 
 	/* It is possible to run out of possible slots
 	 * when the name is long and there isn't enough space left
@@ -806,6 +830,34 @@
 	return -ENFILE;
 }
 
+/**
+ *	dev_alloc_name - allocate a name for a device
+ *	@dev: device
+ *	@name: name format string
+ *
+ *	Passed a format string - eg "lt%d" it will try and find a suitable
+ *	id. It scans list of devices to build up a free map, then chooses
+ *	the first empty slot. The caller must hold the dev_base or rtnl lock
+ *	while allocating the name and adding the device in order to avoid
+ *	duplicates.
+ *	Limited to bits_per_byte * page size devices (ie 32K on most platforms).
+ *	Returns the number of the unit assigned or a negative errno code.
+ */
+
+int dev_alloc_name(struct net_device *dev, const char *name)
+{
+	char buf[IFNAMSIZ];
+	struct net *net;
+	int ret;
+
+	BUG_ON(!dev->nd_net);
+	net = dev->nd_net;
+	ret = __dev_alloc_name(net, name, buf);
+	if (ret >= 0)
+		strlcpy(dev->name, buf, IFNAMSIZ);
+	return ret;
+}
+
 
 /**
  *	dev_change_name - change name of a device
@@ -818,9 +870,12 @@
 int dev_change_name(struct net_device *dev, char *newname)
 {
 	int err = 0;
+	struct net *net;
 
 	ASSERT_RTNL();
+	BUG_ON(!dev->nd_net);
 
+	net = dev->nd_net;
 	if (dev->flags & IFF_UP)
 		return -EBUSY;
 
@@ -833,7 +888,7 @@
 			return err;
 		strcpy(newname, dev->name);
 	}
-	else if (__dev_get_by_name(newname))
+	else if (__dev_get_by_name(net, newname))
 		return -EEXIST;
 	else {
 		if (strncmp(newname, dev->name, IFNAMSIZ))
@@ -844,7 +899,7 @@
 
 	device_rename(&dev->dev, dev->name);
 	hlist_del(&dev->name_hlist);
-	hlist_add_head(&dev->name_hlist, dev_name_hash(dev->name));
+	hlist_add_head(&dev->name_hlist, dev_name_hash(net, dev->name));
 	raw_notifier_call_chain(&netdev_chain, NETDEV_CHANGENAME, dev);
 
 	return err;
@@ -888,12 +943,12 @@
  *	available in this kernel then it becomes a nop.
  */
 
-void dev_load(const char *name)
+void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
 
 	read_lock(&dev_base_lock);
-	dev = __dev_get_by_name(name);
+	dev = __dev_get_by_name(net, name);
 	read_unlock(&dev_base_lock);
 
 	if (!dev && capable(CAP_SYS_MODULE))
@@ -1036,6 +1091,8 @@
 }
 
 
+static int dev_boot_phase = 1;
+
 /*
  *	Device change register/unregister. These are not inline or static
  *	as we export them to the world.
@@ -1062,14 +1119,17 @@
 
 	rtnl_lock();
 	err = raw_notifier_chain_register(&netdev_chain, nb);
-	if (!err) {
-		for_each_netdev(dev) {
+	if (!err && !dev_boot_phase) {
+		struct net *net;
+		for_each_net(net) {
+			for_each_netdev(net, dev) {
 			nb->notifier_call(nb, NETDEV_REGISTER, dev);
 
 			if (dev->flags & IFF_UP)
 				nb->notifier_call(nb, NETDEV_UP, dev);
 		}
 	}
+	}
 	rtnl_unlock();
 	return err;
 }
@@ -1103,9 +1163,9 @@
  *	are as for raw_notifier_call_chain().
  */
 
-int call_netdevice_notifiers(unsigned long val, void *v)
+int call_netdevice_notifiers(unsigned long val, struct net_device *dev)
 {
-	return raw_notifier_call_chain(&netdev_chain, val, v);
+	return raw_notifier_call_chain(&netdev_chain, val, dev);
 }
 
 /* When > 0 there are consumers of rx skb time stamps */
@@ -2083,7 +2143,7 @@
  *	match.  --pb
  */
 
-static int dev_ifname(struct ifreq __user *arg)
+static int dev_ifname(struct net *net, struct ifreq __user *arg)
 {
 	struct net_device *dev;
 	struct ifreq ifr;
@@ -2096,7 +2156,7 @@
 		return -EFAULT;
 
 	read_lock(&dev_base_lock);
-	dev = __dev_get_by_index(ifr.ifr_ifindex);
+	dev = __dev_get_by_index(net, ifr.ifr_ifindex);
 	if (!dev) {
 		read_unlock(&dev_base_lock);
 		return -ENODEV;
@@ -2116,7 +2176,7 @@
  *	Thus we will need a 'compatibility mode'.
  */
 
-static int dev_ifconf(char __user *arg)
+static int dev_ifconf(struct net *net, char __user *arg)
 {
 	struct ifconf ifc;
 	struct net_device *dev;
@@ -2140,7 +2200,7 @@
 	 */
 
 	total = 0;
-	for_each_netdev(dev) {
+	for_each_netdev(net, dev) {
 		if (!nx_dev_visible(current->nx_info, dev))
 			continue;
 		for (i = 0; i < NPROTO; i++) {
@@ -2176,6 +2236,7 @@
  */
 void *dev_seq_start(struct seq_file *seq, loff_t *pos)
 {
+	struct net *net = seq->private;
 	loff_t off;
 	struct net_device *dev;
 
@@ -2184,7 +2245,7 @@
 		return SEQ_START_TOKEN;
 
 	off = 1;
-	for_each_netdev(dev)
+	for_each_netdev(net, dev)
 		if (off++ == *pos)
 			return dev;
 
@@ -2193,9 +2254,10 @@
 
 void *dev_seq_next(struct seq_file *seq, void *v, loff_t *pos)
 {
+	struct net *net = seq->private;
 	++*pos;
 	return v == SEQ_START_TOKEN ?
-		first_net_device() : next_net_device((struct net_device *)v);
+		first_net_device(net) : next_net_device((struct net_device *)v);
 }
 
 void dev_seq_stop(struct seq_file *seq, void *v)
@@ -2294,7 +2356,22 @@
 
 static int dev_seq_open(struct inode *inode, struct file *file)
 {
-	return seq_open(file, &dev_seq_ops);
+	struct seq_file *seq;
+	int res;
+	res =  seq_open(file, &dev_seq_ops);
+	if (!res) {
+		seq = file->private_data;
+		seq->private = get_net(PROC_NET(inode));
+	}
+	return res;
+}
+
+static int dev_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct net *net = seq->private;
+	put_net(net);
+	return seq_release(inode, file);
 }
 
 static const struct file_operations dev_seq_fops = {
@@ -2302,7 +2379,7 @@
 	.open    = dev_seq_open,
 	.read    = seq_read,
 	.llseek  = seq_lseek,
-	.release = seq_release,
+	.release = dev_seq_release,
 };
 
 static const struct seq_operations softnet_seq_ops = {
@@ -2454,30 +2531,49 @@
 };
 
 
-static int __init dev_proc_init(void)
+static int dev_proc_net_init(struct net *net)
 {
 	int rc = -ENOMEM;
 
-	if (!proc_net_fops_create("dev", S_IRUGO, &dev_seq_fops))
+	if (!proc_net_fops_create(net, "dev", S_IRUGO, &dev_seq_fops))
 		goto out;
-	if (!proc_net_fops_create("softnet_stat", S_IRUGO, &softnet_seq_fops))
+	if (!proc_net_fops_create(net, "softnet_stat", S_IRUGO, &softnet_seq_fops))
 		goto out_dev;
-	if (!proc_net_fops_create("ptype", S_IRUGO, &ptype_seq_fops))
-		goto out_dev2;
-
-	if (wext_proc_init())
+	if (!proc_net_fops_create(net, "ptype", S_IRUGO, &ptype_seq_fops))
 		goto out_softnet;
+
+	if (wext_proc_init(net))
+		goto out_ptype;
 	rc = 0;
 out:
 	return rc;
+out_ptype:
+	proc_net_remove(net, "ptype");
 out_softnet:
-	proc_net_remove("ptype");
-out_dev2:
-	proc_net_remove("softnet_stat");
+	proc_net_remove(net, "softnet_stat");
 out_dev:
-	proc_net_remove("dev");
+	proc_net_remove(net, "dev");
 	goto out;
 }
+
+static void dev_proc_net_exit(struct net *net)
+{
+	wext_proc_exit(net);
+
+	proc_net_remove(net, "ptype");
+	proc_net_remove(net, "softnet_stat");
+	proc_net_remove(net, "dev");
+}
+
+static struct pernet_operations dev_proc_ops = {
+	.init = dev_proc_net_init,
+	.exit = dev_proc_net_exit,
+};
+
+static int __init dev_proc_init(void)
+{
+	return register_pernet_subsys(&dev_proc_ops);
+}
 #else
 #define dev_proc_init() 0
 #endif	/* CONFIG_PROC_FS */
@@ -2711,10 +2807,10 @@
 /*
  *	Perform the SIOCxIFxxx calls.
  */
-static int dev_ifsioc(struct ifreq *ifr, unsigned int cmd)
+static int dev_ifsioc(struct net *net, struct ifreq *ifr, unsigned int cmd)
 {
 	int err;
-	struct net_device *dev = __dev_get_by_name(ifr->ifr_name);
+	struct net_device *dev = __dev_get_by_name(net, ifr->ifr_name);
 
 	if (!dev)
 		return -ENODEV;
@@ -2867,7 +2963,7 @@
  *	positive or a negative errno code on error.
  */
 
-int dev_ioctl(unsigned int cmd, void __user *arg)
+int dev_ioctl(struct net *net, unsigned int cmd, void __user *arg)
 {
 	struct ifreq ifr;
 	int ret;
@@ -2880,12 +2976,12 @@
 
 	if (cmd == SIOCGIFCONF) {
 		rtnl_lock();
-		ret = dev_ifconf((char __user *) arg);
+		ret = dev_ifconf(net, (char __user *) arg);
 		rtnl_unlock();
 		return ret;
 	}
 	if (cmd == SIOCGIFNAME)
-		return dev_ifname((struct ifreq __user *)arg);
+		return dev_ifname(net, (struct ifreq __user *)arg);
 
 	if (copy_from_user(&ifr, arg, sizeof(struct ifreq)))
 		return -EFAULT;
@@ -2915,9 +3011,9 @@
 		case SIOCGIFMAP:
 		case SIOCGIFINDEX:
 		case SIOCGIFTXQLEN:
-			dev_load(ifr.ifr_name);
+			dev_load(net, ifr.ifr_name);
 			read_lock(&dev_base_lock);
-			ret = dev_ifsioc(&ifr, cmd);
+			ret = dev_ifsioc(net, &ifr, cmd);
 			read_unlock(&dev_base_lock);
 			if (!ret) {
 				if (colon)
@@ -2929,9 +3025,9 @@
 			return ret;
 
 		case SIOCETHTOOL:
-			dev_load(ifr.ifr_name);
+			dev_load(net, ifr.ifr_name);
 			rtnl_lock();
-			ret = dev_ethtool(&ifr);
+			ret = dev_ethtool(net, &ifr);
 			rtnl_unlock();
 			if (!ret) {
 				if (colon)
@@ -2953,9 +3049,9 @@
 		case SIOCSIFNAME:
 			if (!capable(CAP_NET_ADMIN))
 				return -EPERM;
-			dev_load(ifr.ifr_name);
+			dev_load(net, ifr.ifr_name);
 			rtnl_lock();
-			ret = dev_ifsioc(&ifr, cmd);
+			ret = dev_ifsioc(net, &ifr, cmd);
 			rtnl_unlock();
 			if (!ret) {
 				if (colon)
@@ -2994,9 +3090,9 @@
 			/* fall through */
 		case SIOCBONDSLAVEINFOQUERY:
 		case SIOCBONDINFOQUERY:
-			dev_load(ifr.ifr_name);
+			dev_load(net, ifr.ifr_name);
 			rtnl_lock();
-			ret = dev_ifsioc(&ifr, cmd);
+			ret = dev_ifsioc(net, &ifr, cmd);
 			rtnl_unlock();
 			return ret;
 
@@ -3016,9 +3112,9 @@
 			if (cmd == SIOCWANDEV ||
 			    (cmd >= SIOCDEVPRIVATE &&
 			     cmd <= SIOCDEVPRIVATE + 15)) {
-				dev_load(ifr.ifr_name);
+				dev_load(net, ifr.ifr_name);
 				rtnl_lock();
-				ret = dev_ifsioc(&ifr, cmd);
+				ret = dev_ifsioc(net, &ifr, cmd);
 				rtnl_unlock();
 				if (!ret && copy_to_user(arg, &ifr,
 							 sizeof(struct ifreq)))
@@ -3027,7 +3123,7 @@
 			}
 			/* Take care of Wireless Extensions */
 			if (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST)
-				return wext_handle_ioctl(&ifr, cmd, arg);
+				return wext_handle_ioctl(net, &ifr, cmd, arg);
 			return -EINVAL;
 	}
 }
@@ -3040,19 +3136,17 @@
  *	number.  The caller must hold the rtnl semaphore or the
  *	dev_base_lock to be sure it remains unique.
  */
-static int dev_new_index(void)
+static int dev_new_index(struct net *net)
 {
 	static int ifindex;
 	for (;;) {
 		if (++ifindex <= 0)
 			ifindex = 1;
-		if (!__dev_get_by_index(ifindex))
+		if (!__dev_get_by_index(net, ifindex))
 			return ifindex;
 	}
 }
 
-static int dev_boot_phase = 1;
-
 /* Delayed registration/unregisteration */
 static DEFINE_SPINLOCK(net_todo_list_lock);
 static struct list_head net_todo_list = LIST_HEAD_INIT(net_todo_list);
@@ -3086,6 +3180,7 @@
 	struct hlist_head *head;
 	struct hlist_node *p;
 	int ret;
+	struct net *net;
 
 	BUG_ON(dev_boot_phase);
 	ASSERT_RTNL();
@@ -3094,6 +3189,8 @@
 
 	/* When net_device's are persistent, this will be fatal. */
 	BUG_ON(dev->reg_state != NETREG_UNINITIALIZED);
+	BUG_ON(!dev->nd_net);
+	net = dev->nd_net;
 
 	spin_lock_init(&dev->queue_lock);
 	spin_lock_init(&dev->_xmit_lock);
@@ -3118,12 +3215,12 @@
 		goto out;
 	}
 
-	dev->ifindex = dev_new_index();
+	dev->ifindex = dev_new_index(net);
 	if (dev->iflink == -1)
 		dev->iflink = dev->ifindex;
 
 	/* Check for existence of name */
-	head = dev_name_hash(dev->name);
+	head = dev_name_hash(net, dev->name);
 	hlist_for_each(p, head) {
 		struct net_device *d
 			= hlist_entry(p, struct net_device, name_hlist);
@@ -3200,12 +3297,8 @@
 	set_bit(__LINK_STATE_PRESENT, &dev->state);
 
 	dev_init_scheduler(dev);
-	write_lock_bh(&dev_base_lock);
-	list_add_tail(&dev->dev_list, &dev_base_head);
-	hlist_add_head(&dev->name_hlist, head);
-	hlist_add_head(&dev->index_hlist, dev_index_hash(dev->ifindex));
 	dev_hold(dev);
-	write_unlock_bh(&dev_base_lock);
+	list_netdevice(dev);
 
 	/* Notify protocols, that a new device appeared. */
 	raw_notifier_call_chain(&netdev_chain, NETDEV_REGISTER, dev);
@@ -3415,6 +3508,7 @@
 	dev = (struct net_device *)
 		(((long)p + NETDEV_ALIGN_CONST) & ~NETDEV_ALIGN_CONST);
 	dev->padded = (char *)dev - (char *)p;
+	dev->nd_net = &init_net;
 
 	if (sizeof_priv)
 		dev->priv = netdev_priv(dev);
@@ -3493,11 +3587,7 @@
 		dev_close(dev);
 
 	/* And unlink it from device chain. */
-	write_lock_bh(&dev_base_lock);
-	list_del(&dev->dev_list);
-	hlist_del(&dev->name_hlist);
-	hlist_del(&dev->index_hlist);
-	write_unlock_bh(&dev_base_lock);
+	unlist_netdevice(dev);
 
 	dev->reg_state = NETREG_UNREGISTERING;
 
@@ -3555,6 +3645,122 @@
 
 EXPORT_SYMBOL(unregister_netdev);
 
+/**
+ *	dev_change_net_namespace - move device to different nethost namespace
+ *	@dev: device
+ *	@net: network namespace
+ *	@pat: If not NULL name pattern to try if the current device name
+ *	      is already taken in the destination network namespace.
+ *
+ *	This function shuts down a device interface and moves it
+ *	to a new network namespace. On success 0 is returned, on
+ *	a failure a netagive errno code is returned.
+ *
+ *	Callers must hold the rtnl semaphore.
+ */
+
+int dev_change_net_namespace(struct net_device *dev, struct net *net, const char *pat)
+{
+	char buf[IFNAMSIZ];
+	const char *destname;
+	int err;
+
+	ASSERT_RTNL();
+
+	/* Don't allow namespace local devices to be moved. */
+	err = -EINVAL;
+	if (dev->features & NETIF_F_NETNS_LOCAL)
+		goto out;
+
+	/* Ensure the device has been registrered */
+	err = -EINVAL;
+	if (dev->reg_state != NETREG_REGISTERED)
+		goto out;
+	
+	/* Get out if there is nothing todo */
+	err = 0;
+	if (dev->nd_net == net)
+		goto out;
+
+	/* Pick the destination device name, and ensure
+	 * we can use it in the destination network namespace.
+	 */
+	err = -EEXIST;
+	destname = dev->name;
+	if (__dev_get_by_name(net, destname)) {
+		/* We get here if we can't use the current device name */
+		if (!pat)
+			goto out;
+		if (!dev_valid_name(pat))
+			goto out;
+		if (strchr(pat, '%')) {
+			if (__dev_alloc_name(net, pat, buf) < 0)
+				goto out;
+			destname = buf;
+		} else
+			destname = pat;
+		if (__dev_get_by_name(net, destname))
+			goto out;
+	}
+
+	/*
+	 * And now a mini version of register_netdevice unregister_netdevice. 
+	 */
+
+	/* If device is running close it first. */
+	if (dev->flags & IFF_UP)
+		dev_close(dev);
+
+	/* And unlink it from device chain */
+	err = -ENODEV;
+	unlist_netdevice(dev);
+	
+	synchronize_net();
+	
+	/* Shutdown queueing discipline. */
+	dev_shutdown(dev);
+
+	/* Notify protocols, that we are about to destroy
+	   this device. They should clean all the things.
+	*/
+	call_netdevice_notifiers(NETDEV_UNREGISTER, dev);
+	
+	/*
+	 *	Flush the multicast chain
+	 */
+	dev_mc_discard(dev);
+
+	/* Actually switch the network namespace */
+	dev->nd_net = net;
+	
+	/* Assign the new device name */
+	if (destname != dev->name)
+		strcpy(dev->name, destname);
+
+	/* If there is an ifindex conflict assign a new one */
+	if (__dev_get_by_index(net, dev->ifindex)) {
+		int iflink = (dev->iflink == dev->ifindex);
+		dev->ifindex = dev_new_index(net);
+		if (iflink)
+			dev->iflink = dev->ifindex;
+	}
+
+	/* Fixup sysfs */
+	err = device_rename(&dev->dev, dev->name);
+	BUG_ON(err);
+
+	/* Add the device back in the hashes */
+	list_netdevice(dev);
+
+	/* Notify protocols, that a new device appeared. */
+	call_netdevice_notifiers(NETDEV_REGISTER, dev);
+
+	synchronize_net();
+	err = 0;
+out:
+	return err;
+}
+
 static int dev_cpu_callback(struct notifier_block *nfb,
 			    unsigned long action,
 			    void *ocpu)
@@ -3745,6 +3951,75 @@
 }
 EXPORT_SYMBOL(netdev_compute_features);
 
+/* Initialize per network namespace state */
+static int netdev_init(struct net *net)
+{
+	int i;
+	INIT_LIST_HEAD(&net->dev_base_head);
+	rwlock_init(&dev_base_lock);
+
+	net->dev_name_head = kmalloc(
+		sizeof(*net->dev_name_head)*NETDEV_HASHENTRIES, GFP_KERNEL);
+	if (!net->dev_name_head)
+		return -ENOMEM;
+
+	net->dev_index_head = kmalloc(
+		sizeof(*net->dev_index_head)*NETDEV_HASHENTRIES, GFP_KERNEL);
+	if (!net->dev_index_head) {
+		kfree(net->dev_name_head);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < NETDEV_HASHENTRIES; i++)
+		INIT_HLIST_HEAD(&net->dev_name_head[i]);
+	
+	for (i = 0; i < NETDEV_HASHENTRIES; i++)
+		INIT_HLIST_HEAD(&net->dev_index_head[i]);
+
+	return 0;
+}
+
+static void netdev_exit(struct net *net)
+{
+	kfree(net->dev_name_head);
+	kfree(net->dev_index_head);
+}
+
+static struct pernet_operations netdev_net_ops = {
+	.init = netdev_init,
+	.exit = netdev_exit,
+};
+
+static void default_device_exit(struct net *net)
+{
+	struct net_device *dev, *next;
+	/*
+	 * Push all migratable of the network devices back to the
+	 * initial network namespace 
+	 */
+	rtnl_lock();
+	for_each_netdev_safe(net, dev, next) {
+		int err;
+
+		/* Ignore unmoveable devices (i.e. loopback) */
+		if (dev->features & NETIF_F_NETNS_LOCAL)
+			continue;
+
+		/* Push remaing network devices to init_net */
+		err = dev_change_net_namespace(dev, &init_net, "dev%d");
+		if (err) {
+			printk(KERN_WARNING "%s: failed to move %s to init_net: %d\n",
+				__func__, dev->name, err);
+			unregister_netdevice(dev);
+		}
+	}
+	rtnl_unlock();
+}
+
+static struct pernet_operations default_device_ops = {
+	.exit = default_device_exit,
+};
+
 /*
  *	Initialize the DEV module. At boot time this walks the device list and
  *	unhooks any devices that fail to initialise (normally hardware not
@@ -3772,11 +4047,11 @@
 	for (i = 0; i < 16; i++)
 		INIT_LIST_HEAD(&ptype_base[i]);
 
-	for (i = 0; i < ARRAY_SIZE(dev_name_head); i++)
-		INIT_HLIST_HEAD(&dev_name_head[i]);
+	if (register_pernet_subsys(&netdev_net_ops))
+		goto out;
 
-	for (i = 0; i < ARRAY_SIZE(dev_index_head); i++)
-		INIT_HLIST_HEAD(&dev_index_head[i]);
+	if (register_pernet_device(&default_device_ops))
+		goto out;
 
 	/*
 	 *	Initialise the packet receive queues.
diff -Nurb linux-2.6.22-590/net/core/dev_mcast.c linux-2.6.22-try2-netns/net/core/dev_mcast.c
--- linux-2.6.22-590/net/core/dev_mcast.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/core/dev_mcast.c	2007-12-19 22:49:18.000000000 -0500
@@ -46,6 +46,7 @@
 #include <linux/skbuff.h>
 #include <net/sock.h>
 #include <net/arp.h>
+#include <net/net_namespace.h>
 
 
 /*
@@ -219,11 +220,12 @@
 #ifdef CONFIG_PROC_FS
 static void *dev_mc_seq_start(struct seq_file *seq, loff_t *pos)
 {
+	struct net *net = seq->private;
 	struct net_device *dev;
 	loff_t off = 0;
 
 	read_lock(&dev_base_lock);
-	for_each_netdev(dev) {
+	for_each_netdev(net, dev) {
 		if (off++ == *pos)
 			return dev;
 	}
@@ -272,7 +274,22 @@
 
 static int dev_mc_seq_open(struct inode *inode, struct file *file)
 {
-	return seq_open(file, &dev_mc_seq_ops);
+	struct seq_file *seq;
+	int res;
+	res = seq_open(file, &dev_mc_seq_ops);
+	if (!res) {
+		seq = file->private_data;
+		seq->private = get_net(PROC_NET(inode));
+	}
+	return res;
+}
+
+static int dev_mc_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct net *net = seq->private;
+	put_net(net);
+	return seq_release(inode, file);
 }
 
 static const struct file_operations dev_mc_seq_fops = {
@@ -280,14 +297,31 @@
 	.open    = dev_mc_seq_open,
 	.read    = seq_read,
 	.llseek  = seq_lseek,
-	.release = seq_release,
+	.release = dev_mc_seq_release,
 };
 
 #endif
 
+static int dev_mc_net_init(struct net *net)
+{
+	if (!proc_net_fops_create(net, "dev_mcast", 0, &dev_mc_seq_fops))
+		return -ENOMEM;
+	return 0;
+}
+
+static void dev_mc_net_exit(struct net *net)
+{
+	proc_net_remove(net, "dev_mcast");
+}
+
+static struct pernet_operations dev_mc_net_ops = {
+	.init = dev_mc_net_init,
+	.exit = dev_mc_net_exit,
+};
+
 void __init dev_mcast_init(void)
 {
-	proc_net_fops_create("dev_mcast", 0, &dev_mc_seq_fops);
+	register_pernet_subsys(&dev_mc_net_ops);
 }
 
 EXPORT_SYMBOL(dev_mc_add);
diff -Nurb linux-2.6.22-590/net/core/dst.c linux-2.6.22-try2-netns/net/core/dst.c
--- linux-2.6.22-590/net/core/dst.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/core/dst.c	2007-12-19 22:49:18.000000000 -0500
@@ -15,7 +15,9 @@
 #include <linux/skbuff.h>
 #include <linux/string.h>
 #include <linux/types.h>
+#include <net/net_namespace.h>
 
+#include <net/net_namespace.h>
 #include <net/dst.h>
 
 /* Locking strategy:
@@ -236,13 +238,14 @@
 	if (!unregister) {
 		dst->input = dst->output = dst_discard;
 	} else {
-		dst->dev = &loopback_dev;
-		dev_hold(&loopback_dev);
+		struct net *net = dev->nd_net;
+		dst->dev = &net->loopback_dev;
+		dev_hold(dst->dev);
 		dev_put(dev);
 		if (dst->neighbour && dst->neighbour->dev == dev) {
-			dst->neighbour->dev = &loopback_dev;
+			dst->neighbour->dev = &net->loopback_dev;
 			dev_put(dev);
-			dev_hold(&loopback_dev);
+			dev_hold(dst->neighbour->dev);
 		}
 	}
 }
@@ -252,6 +255,9 @@
 	struct net_device *dev = ptr;
 	struct dst_entry *dst;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	switch (event) {
 	case NETDEV_UNREGISTER:
 	case NETDEV_DOWN:
diff -Nurb linux-2.6.22-590/net/core/ethtool.c linux-2.6.22-try2-netns/net/core/ethtool.c
--- linux-2.6.22-590/net/core/ethtool.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/core/ethtool.c	2007-12-19 22:49:18.000000000 -0500
@@ -798,9 +798,9 @@
 
 /* The main entry point in this file.  Called from net/core/dev.c */
 
-int dev_ethtool(struct ifreq *ifr)
+int dev_ethtool(struct net *net, struct ifreq *ifr)
 {
-	struct net_device *dev = __dev_get_by_name(ifr->ifr_name);
+	struct net_device *dev = __dev_get_by_name(net, ifr->ifr_name);
 	void __user *useraddr = ifr->ifr_data;
 	u32 ethcmd;
 	int rc;
diff -Nurb linux-2.6.22-590/net/core/fib_rules.c linux-2.6.22-try2-netns/net/core/fib_rules.c
--- linux-2.6.22-590/net/core/fib_rules.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/core/fib_rules.c	2007-12-19 22:49:18.000000000 -0500
@@ -11,21 +11,20 @@
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/list.h>
+#include <net/net_namespace.h>
+#include <net/sock.h>
 #include <net/fib_rules.h>
 
-static LIST_HEAD(rules_ops);
-static DEFINE_SPINLOCK(rules_mod_lock);
-
-static void notify_rule_change(int event, struct fib_rule *rule,
+static void notify_rule_change(struct net *net, int event, struct fib_rule *rule,
 			       struct fib_rules_ops *ops, struct nlmsghdr *nlh,
 			       u32 pid);
 
-static struct fib_rules_ops *lookup_rules_ops(int family)
+static struct fib_rules_ops *lookup_rules_ops(struct net *net, int family)
 {
 	struct fib_rules_ops *ops;
 
 	rcu_read_lock();
-	list_for_each_entry_rcu(ops, &rules_ops, list) {
+	list_for_each_entry_rcu(ops, &net->rules_ops, list) {
 		if (ops->family == family) {
 			if (!try_module_get(ops->owner))
 				ops = NULL;
@@ -47,10 +46,10 @@
 static void flush_route_cache(struct fib_rules_ops *ops)
 {
 	if (ops->flush_cache)
-		ops->flush_cache();
+		ops->flush_cache(ops);
 }
 
-int fib_rules_register(struct fib_rules_ops *ops)
+int fib_rules_register(struct net *net, struct fib_rules_ops *ops)
 {
 	int err = -EEXIST;
 	struct fib_rules_ops *o;
@@ -63,15 +62,16 @@
 	    ops->action == NULL)
 		return -EINVAL;
 
-	spin_lock(&rules_mod_lock);
-	list_for_each_entry(o, &rules_ops, list)
+	spin_lock(&net->rules_mod_lock);
+	list_for_each_entry(o, &net->rules_ops, list)
 		if (ops->family == o->family)
 			goto errout;
 
-	list_add_tail_rcu(&ops->list, &rules_ops);
+	hold_net(net);
+	list_add_tail_rcu(&ops->list, &net->rules_ops);
 	err = 0;
 errout:
-	spin_unlock(&rules_mod_lock);
+	spin_unlock(&net->rules_mod_lock);
 
 	return err;
 }
@@ -88,13 +88,13 @@
 	}
 }
 
-int fib_rules_unregister(struct fib_rules_ops *ops)
+int fib_rules_unregister(struct net *net, struct fib_rules_ops *ops)
 {
 	int err = 0;
 	struct fib_rules_ops *o;
 
-	spin_lock(&rules_mod_lock);
-	list_for_each_entry(o, &rules_ops, list) {
+	spin_lock(&net->rules_mod_lock);
+	list_for_each_entry(o, &net->rules_ops, list) {
 		if (o == ops) {
 			list_del_rcu(&o->list);
 			cleanup_ops(ops);
@@ -104,9 +104,11 @@
 
 	err = -ENOENT;
 out:
-	spin_unlock(&rules_mod_lock);
+	spin_unlock(&net->rules_mod_lock);
 
 	synchronize_rcu();
+	if (!err)
+		release_net(net);
 
 	return err;
 }
@@ -197,6 +199,7 @@
 
 static int fib_nl_newrule(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct fib_rule_hdr *frh = nlmsg_data(nlh);
 	struct fib_rules_ops *ops = NULL;
 	struct fib_rule *rule, *r, *last = NULL;
@@ -206,7 +209,7 @@
 	if (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*frh)))
 		goto errout;
 
-	ops = lookup_rules_ops(frh->family);
+	ops = lookup_rules_ops(net, frh->family);
 	if (ops == NULL) {
 		err = EAFNOSUPPORT;
 		goto errout;
@@ -234,7 +237,7 @@
 
 		rule->ifindex = -1;
 		nla_strlcpy(rule->ifname, tb[FRA_IFNAME], IFNAMSIZ);
-		dev = __dev_get_by_name(rule->ifname);
+		dev = __dev_get_by_name(net, rule->ifname);
 		if (dev)
 			rule->ifindex = dev->ifindex;
 	}
@@ -256,7 +259,7 @@
 	rule->table = frh_get_table(frh, tb);
 
 	if (!rule->pref && ops->default_pref)
-		rule->pref = ops->default_pref();
+		rule->pref = ops->default_pref(ops);
 
 	err = -EINVAL;
 	if (tb[FRA_GOTO]) {
@@ -319,7 +322,7 @@
 	else
 		list_add_rcu(&rule->list, ops->rules_list);
 
-	notify_rule_change(RTM_NEWRULE, rule, ops, nlh, NETLINK_CB(skb).pid);
+	notify_rule_change(net, RTM_NEWRULE, rule, ops, nlh, NETLINK_CB(skb).pid);
 	flush_route_cache(ops);
 	rules_ops_put(ops);
 	return 0;
@@ -333,6 +336,7 @@
 
 static int fib_nl_delrule(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct fib_rule_hdr *frh = nlmsg_data(nlh);
 	struct fib_rules_ops *ops = NULL;
 	struct fib_rule *rule, *tmp;
@@ -342,7 +346,7 @@
 	if (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*frh)))
 		goto errout;
 
-	ops = lookup_rules_ops(frh->family);
+	ops = lookup_rules_ops(net, frh->family);
 	if (ops == NULL) {
 		err = EAFNOSUPPORT;
 		goto errout;
@@ -408,7 +412,7 @@
 		}
 
 		synchronize_rcu();
-		notify_rule_change(RTM_DELRULE, rule, ops, nlh,
+		notify_rule_change(net, RTM_DELRULE, rule, ops, nlh,
 				   NETLINK_CB(skb).pid);
 		fib_rule_put(rule);
 		flush_route_cache(ops);
@@ -514,13 +518,17 @@
 
 static int fib_nl_dumprule(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	struct fib_rules_ops *ops;
 	int idx = 0, family;
 
+	if (net != &init_net)
+		return -EINVAL;
+
 	family = rtnl_msg_family(cb->nlh);
 	if (family != AF_UNSPEC) {
 		/* Protocol specific dump request */
-		ops = lookup_rules_ops(family);
+		ops = lookup_rules_ops(net, family);
 		if (ops == NULL)
 			return -EAFNOSUPPORT;
 
@@ -528,7 +536,7 @@
 	}
 
 	rcu_read_lock();
-	list_for_each_entry_rcu(ops, &rules_ops, list) {
+	list_for_each_entry_rcu(ops, &net->rules_ops, list) {
 		if (idx < cb->args[0] || !try_module_get(ops->owner))
 			goto skip;
 
@@ -545,7 +553,7 @@
 	return skb->len;
 }
 
-static void notify_rule_change(int event, struct fib_rule *rule,
+static void notify_rule_change(struct net *net, int event, struct fib_rule *rule,
 			       struct fib_rules_ops *ops, struct nlmsghdr *nlh,
 			       u32 pid)
 {
@@ -563,10 +571,10 @@
 		kfree_skb(skb);
 		goto errout;
 	}
-	err = rtnl_notify(skb, pid, ops->nlgroup, nlh, GFP_KERNEL);
+	err = rtnl_notify(skb, net, pid, ops->nlgroup, nlh, GFP_KERNEL);
 errout:
 	if (err < 0)
-		rtnl_set_sk_err(ops->nlgroup, err);
+		rtnl_set_sk_err(net, ops->nlgroup, err);
 }
 
 static void attach_rules(struct list_head *rules, struct net_device *dev)
@@ -594,19 +602,23 @@
 			    void *ptr)
 {
 	struct net_device *dev = ptr;
+	struct net *net = dev->nd_net;
 	struct fib_rules_ops *ops;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	ASSERT_RTNL();
 	rcu_read_lock();
 
 	switch (event) {
 	case NETDEV_REGISTER:
-		list_for_each_entry(ops, &rules_ops, list)
+		list_for_each_entry(ops, &net->rules_ops, list)
 			attach_rules(ops->rules_list, dev);
 		break;
 
 	case NETDEV_UNREGISTER:
-		list_for_each_entry(ops, &rules_ops, list)
+		list_for_each_entry(ops, &net->rules_ops, list)
 			detach_rules(ops->rules_list, dev);
 		break;
 	}
@@ -620,13 +632,28 @@
 	.notifier_call = fib_rules_event,
 };
 
+static int fib_rules_net_init(struct net *net)
+{
+	INIT_LIST_HEAD(&net->rules_ops);
+	spin_lock_init(&net->rules_mod_lock);
+	return 0;
+}
+
+static struct pernet_operations fib_rules_net_ops = {
+	.init = fib_rules_net_init,
+};
+
 static int __init fib_rules_init(void)
 {
+	int ret;
 	rtnl_register(PF_UNSPEC, RTM_NEWRULE, fib_nl_newrule, NULL);
 	rtnl_register(PF_UNSPEC, RTM_DELRULE, fib_nl_delrule, NULL);
 	rtnl_register(PF_UNSPEC, RTM_GETRULE, NULL, fib_nl_dumprule);
 
-	return register_netdevice_notifier(&fib_rules_notifier);
+	ret = register_pernet_subsys(&fib_rules_net_ops);
+	if (!ret)
+		ret = register_netdevice_notifier(&fib_rules_notifier);
+	return ret;
 }
 
 subsys_initcall(fib_rules_init);
diff -Nurb linux-2.6.22-590/net/core/neighbour.c linux-2.6.22-try2-netns/net/core/neighbour.c
--- linux-2.6.22-590/net/core/neighbour.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/core/neighbour.c	2007-12-19 22:49:18.000000000 -0500
@@ -33,6 +33,7 @@
 #include <linux/rtnetlink.h>
 #include <linux/random.h>
 #include <linux/string.h>
+#include <net/net_namespace.h>
 
 #define NEIGH_DEBUG 1
 
@@ -361,7 +362,7 @@
 	return n;
 }
 
-struct neighbour *neigh_lookup_nodev(struct neigh_table *tbl, const void *pkey)
+struct neighbour *neigh_lookup_nodev(struct neigh_table *tbl, struct net * net, const void *pkey)
 {
 	struct neighbour *n;
 	int key_len = tbl->key_len;
@@ -371,7 +372,8 @@
 
 	read_lock_bh(&tbl->lock);
 	for (n = tbl->hash_buckets[hash_val & tbl->hash_mask]; n; n = n->next) {
-		if (!memcmp(n->primary_key, pkey, key_len)) {
+		if (!memcmp(n->primary_key, pkey, key_len) &&
+		    (net == n->dev->nd_net)) {
 			neigh_hold(n);
 			NEIGH_CACHE_STAT_INC(tbl, hits);
 			break;
@@ -449,7 +451,8 @@
 	goto out;
 }
 
-struct pneigh_entry * pneigh_lookup(struct neigh_table *tbl, const void *pkey,
+struct pneigh_entry * pneigh_lookup(struct neigh_table *tbl,
+				    struct net * net, const void *pkey,
 				    struct net_device *dev, int creat)
 {
 	struct pneigh_entry *n;
@@ -465,6 +468,7 @@
 
 	for (n = tbl->phash_buckets[hash_val]; n; n = n->next) {
 		if (!memcmp(n->key, pkey, key_len) &&
+		    (n->net == net) &&
 		    (n->dev == dev || !n->dev)) {
 			read_unlock_bh(&tbl->lock);
 			goto out;
@@ -479,6 +483,7 @@
 	if (!n)
 		goto out;
 
+	n->net = hold_net(net);
 	memcpy(n->key, pkey, key_len);
 	n->dev = dev;
 	if (dev)
@@ -501,7 +506,7 @@
 }
 
 
-int pneigh_delete(struct neigh_table *tbl, const void *pkey,
+int pneigh_delete(struct neigh_table *tbl, struct net * net, const void *pkey,
 		  struct net_device *dev)
 {
 	struct pneigh_entry *n, **np;
@@ -516,13 +521,15 @@
 	write_lock_bh(&tbl->lock);
 	for (np = &tbl->phash_buckets[hash_val]; (n = *np) != NULL;
 	     np = &n->next) {
-		if (!memcmp(n->key, pkey, key_len) && n->dev == dev) {
+		if (!memcmp(n->key, pkey, key_len) && n->dev == dev &&
+		    (n->net == net)) {
 			*np = n->next;
 			write_unlock_bh(&tbl->lock);
 			if (tbl->pdestructor)
 				tbl->pdestructor(n);
 			if (n->dev)
 				dev_put(n->dev);
+			release_net(n->net);
 			kfree(n);
 			return 0;
 		}
@@ -545,6 +552,7 @@
 					tbl->pdestructor(n);
 				if (n->dev)
 					dev_put(n->dev);
+				release_net(n->net);
 				kfree(n);
 				continue;
 			}
@@ -1266,12 +1274,37 @@
 	spin_unlock(&tbl->proxy_queue.lock);
 }
 
+static inline struct neigh_parms *lookup_neigh_params(struct neigh_table *tbl,
+						      struct net * net, int ifindex)
+{
+	struct neigh_parms *p;
+	
+	for (p = &tbl->parms; p; p = p->next) {
+		if (p->net != net)
+			continue;
+		if ((p->dev && p->dev->ifindex == ifindex) ||
+		    (!p->dev && !ifindex))
+			return p;
+	}
+
+	return NULL;
+}
 
 struct neigh_parms *neigh_parms_alloc(struct net_device *dev,
 				      struct neigh_table *tbl)
 {
-	struct neigh_parms *p = kmemdup(&tbl->parms, sizeof(*p), GFP_KERNEL);
+	struct neigh_parms *p, *ref;
+	struct net * net;
+
+	net = &init_net;
+	if (dev)
+		net = dev->nd_net;
+
+	ref = lookup_neigh_params(tbl, net, 0);
+	if (!ref)
+		return NULL;
 
+	p = kmemdup(ref, sizeof(*p), GFP_KERNEL);
 	if (p) {
 		p->tbl		  = tbl;
 		atomic_set(&p->refcnt, 1);
@@ -1287,6 +1320,7 @@
 			dev_hold(dev);
 			p->dev = dev;
 		}
+		p->net = hold_net(net);
 		p->sysctl_table = NULL;
 		write_lock_bh(&tbl->lock);
 		p->next		= tbl->parms.next;
@@ -1296,6 +1330,20 @@
 	return p;
 }
 
+struct neigh_parms *neigh_parms_alloc_default(struct neigh_table *tbl,
+						struct net *net)
+{
+	struct neigh_parms *parms;
+	if (net != &init_net) {
+		parms = neigh_parms_alloc(NULL, tbl);
+		release_net(parms->net);
+		parms->net = hold_net(net);
+	}
+	else
+		parms = neigh_parms_clone(&tbl->parms);
+	return parms;
+}
+
 static void neigh_rcu_free_parms(struct rcu_head *head)
 {
 	struct neigh_parms *parms =
@@ -1328,6 +1376,7 @@
 
 void neigh_parms_destroy(struct neigh_parms *parms)
 {
+	release_net(parms->net);
 	kfree(parms);
 }
 
@@ -1338,6 +1387,7 @@
 	unsigned long now = jiffies;
 	unsigned long phsize;
 
+	tbl->parms.net = &init_net;
 	atomic_set(&tbl->parms.refcnt, 1);
 	INIT_RCU_HEAD(&tbl->parms.rcu_head);
 	tbl->parms.reachable_time =
@@ -1353,7 +1403,7 @@
 		panic("cannot create neighbour cache statistics");
 
 #ifdef CONFIG_PROC_FS
-	tbl->pde = create_proc_entry(tbl->id, 0, proc_net_stat);
+	tbl->pde = create_proc_entry(tbl->id, 0, init_net.proc_net_stat);
 	if (!tbl->pde)
 		panic("cannot create neighbour proc dir entry");
 	tbl->pde->proc_fops = &neigh_stat_seq_fops;
@@ -1443,6 +1493,7 @@
 
 static int neigh_delete(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct ndmsg *ndm;
 	struct nlattr *dst_attr;
 	struct neigh_table *tbl;
@@ -1458,7 +1509,7 @@
 
 	ndm = nlmsg_data(nlh);
 	if (ndm->ndm_ifindex) {
-		dev = dev_get_by_index(ndm->ndm_ifindex);
+		dev = dev_get_by_index(net, ndm->ndm_ifindex);
 		if (dev == NULL) {
 			err = -ENODEV;
 			goto out;
@@ -1477,7 +1528,7 @@
 			goto out_dev_put;
 
 		if (ndm->ndm_flags & NTF_PROXY) {
-			err = pneigh_delete(tbl, nla_data(dst_attr), dev);
+			err = pneigh_delete(tbl, net, nla_data(dst_attr), dev);
 			goto out_dev_put;
 		}
 
@@ -1508,6 +1559,7 @@
 
 static int neigh_add(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct ndmsg *ndm;
 	struct nlattr *tb[NDA_MAX+1];
 	struct neigh_table *tbl;
@@ -1524,7 +1576,7 @@
 
 	ndm = nlmsg_data(nlh);
 	if (ndm->ndm_ifindex) {
-		dev = dev_get_by_index(ndm->ndm_ifindex);
+		dev = dev_get_by_index(net, ndm->ndm_ifindex);
 		if (dev == NULL) {
 			err = -ENODEV;
 			goto out;
@@ -1553,7 +1605,7 @@
 			struct pneigh_entry *pn;
 
 			err = -ENOBUFS;
-			pn = pneigh_lookup(tbl, dst, dev, 1);
+			pn = pneigh_lookup(tbl, net, dst, dev, 1);
 			if (pn) {
 				pn->flags = ndm->ndm_flags;
 				err = 0;
@@ -1748,19 +1800,6 @@
 	return -EMSGSIZE;
 }
 
-static inline struct neigh_parms *lookup_neigh_params(struct neigh_table *tbl,
-						      int ifindex)
-{
-	struct neigh_parms *p;
-
-	for (p = &tbl->parms; p; p = p->next)
-		if ((p->dev && p->dev->ifindex == ifindex) ||
-		    (!p->dev && !ifindex))
-			return p;
-
-	return NULL;
-}
-
 static const struct nla_policy nl_neightbl_policy[NDTA_MAX+1] = {
 	[NDTA_NAME]		= { .type = NLA_STRING },
 	[NDTA_THRESH1]		= { .type = NLA_U32 },
@@ -1788,6 +1827,7 @@
 
 static int neightbl_set(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct neigh_table *tbl;
 	struct ndtmsg *ndtmsg;
 	struct nlattr *tb[NDTA_MAX+1];
@@ -1837,7 +1877,7 @@
 		if (tbp[NDTPA_IFINDEX])
 			ifindex = nla_get_u32(tbp[NDTPA_IFINDEX]);
 
-		p = lookup_neigh_params(tbl, ifindex);
+		p = lookup_neigh_params(tbl, net, ifindex);
 		if (p == NULL) {
 			err = -ENOENT;
 			goto errout_tbl_lock;
@@ -1912,6 +1952,7 @@
 
 static int neightbl_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	int family, tidx, nidx = 0;
 	int tbl_skip = cb->args[0];
 	int neigh_skip = cb->args[1];
@@ -1931,8 +1972,11 @@
 				       NLM_F_MULTI) <= 0)
 			break;
 
-		for (nidx = 0, p = tbl->parms.next; p; p = p->next, nidx++) {
-			if (nidx < neigh_skip)
+		for (nidx = 0, p = tbl->parms.next; p; p = p->next) {
+			if (net != p->net)
+				continue;
+
+			if (nidx++ < neigh_skip)
 				continue;
 
 			if (neightbl_fill_param_info(skb, tbl, p,
@@ -2003,6 +2047,7 @@
 static int neigh_dump_table(struct neigh_table *tbl, struct sk_buff *skb,
 			    struct netlink_callback *cb)
 {
+	struct net * net = skb->sk->sk_net;
 	struct neighbour *n;
 	int rc, h, s_h = cb->args[1];
 	int idx, s_idx = idx = cb->args[2];
@@ -2013,8 +2058,12 @@
 			continue;
 		if (h > s_h)
 			s_idx = 0;
-		for (n = tbl->hash_buckets[h], idx = 0; n; n = n->next, idx++) {
-			if (idx < s_idx)
+		for (n = tbl->hash_buckets[h], idx = 0; n; n = n->next) {
+			int lidx;
+			if (n->dev->nd_net != net)
+				continue;
+			lidx = idx++;
+			if (lidx < s_idx)
 				continue;
 			if (neigh_fill_info(skb, n, NETLINK_CB(cb->skb).pid,
 					    cb->nlh->nlmsg_seq,
@@ -2109,6 +2158,7 @@
 static struct neighbour *neigh_get_first(struct seq_file *seq)
 {
 	struct neigh_seq_state *state = seq->private;
+	struct net * net = state->net;
 	struct neigh_table *tbl = state->tbl;
 	struct neighbour *n = NULL;
 	int bucket = state->bucket;
@@ -2118,6 +2168,8 @@
 		n = tbl->hash_buckets[bucket];
 
 		while (n) {
+			if (n->dev->nd_net != net)
+				goto next;
 			if (state->neigh_sub_iter) {
 				loff_t fakep = 0;
 				void *v;
@@ -2147,6 +2199,7 @@
 					loff_t *pos)
 {
 	struct neigh_seq_state *state = seq->private;
+	struct net * net = state->net;
 	struct neigh_table *tbl = state->tbl;
 
 	if (state->neigh_sub_iter) {
@@ -2158,6 +2211,8 @@
 
 	while (1) {
 		while (n) {
+			if (n->dev->nd_net != net)
+				goto next;
 			if (state->neigh_sub_iter) {
 				void *v = state->neigh_sub_iter(state, n, pos);
 				if (v)
@@ -2204,6 +2259,7 @@
 static struct pneigh_entry *pneigh_get_first(struct seq_file *seq)
 {
 	struct neigh_seq_state *state = seq->private;
+	struct net * net = state->net;
 	struct neigh_table *tbl = state->tbl;
 	struct pneigh_entry *pn = NULL;
 	int bucket = state->bucket;
@@ -2211,6 +2267,8 @@
 	state->flags |= NEIGH_SEQ_IS_PNEIGH;
 	for (bucket = 0; bucket <= PNEIGH_HASHMASK; bucket++) {
 		pn = tbl->phash_buckets[bucket];
+		while (pn && (pn->net != net))
+			pn = pn->next;
 		if (pn)
 			break;
 	}
@@ -2224,6 +2282,7 @@
 					    loff_t *pos)
 {
 	struct neigh_seq_state *state = seq->private;
+	struct net * net = state->net;
 	struct neigh_table *tbl = state->tbl;
 
 	pn = pn->next;
@@ -2231,6 +2290,8 @@
 		if (++state->bucket > PNEIGH_HASHMASK)
 			break;
 		pn = tbl->phash_buckets[state->bucket];
+		while (pn && (pn->net != net))
+			pn = pn->next;
 		if (pn)
 			break;
 	}
@@ -2433,6 +2494,7 @@
 
 static void __neigh_notify(struct neighbour *n, int type, int flags)
 {
+	struct net * net = n->dev->nd_net;
 	struct sk_buff *skb;
 	int err = -ENOBUFS;
 
@@ -2447,10 +2509,10 @@
 		kfree_skb(skb);
 		goto errout;
 	}
-	err = rtnl_notify(skb, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);
+	err = rtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);
 errout:
 	if (err < 0)
-		rtnl_set_sk_err(RTNLGRP_NEIGH, err);
+		rtnl_set_sk_err(net, RTNLGRP_NEIGH, err);
 }
 
 void neigh_app_ns(struct neighbour *n)
@@ -2648,6 +2710,7 @@
 
 	if (!t)
 		return -ENOBUFS;
+
 	t->neigh_vars[0].data  = &p->mcast_probes;
 	t->neigh_vars[1].data  = &p->ucast_probes;
 	t->neigh_vars[2].data  = &p->app_probes;
@@ -2716,7 +2779,7 @@
 	t->neigh_proto_dir[0].child    = t->neigh_neigh_dir;
 	t->neigh_root_dir[0].child     = t->neigh_proto_dir;
 
-	t->sysctl_header = register_sysctl_table(t->neigh_root_dir);
+	t->sysctl_header = register_net_sysctl_table(p->net, t->neigh_root_dir);
 	if (!t->sysctl_header) {
 		err = -ENOBUFS;
 		goto free_procname;
@@ -2738,7 +2801,7 @@
 	if (p->sysctl_table) {
 		struct neigh_sysctl_table *t = p->sysctl_table;
 		p->sysctl_table = NULL;
-		unregister_sysctl_table(t->sysctl_header);
+		unregister_net_sysctl_table(t->sysctl_header);
 		kfree(t->neigh_dev[0].procname);
 		kfree(t);
 	}
@@ -2771,6 +2834,7 @@
 EXPORT_SYMBOL(neigh_lookup);
 EXPORT_SYMBOL(neigh_lookup_nodev);
 EXPORT_SYMBOL(neigh_parms_alloc);
+EXPORT_SYMBOL(neigh_parms_alloc_default);
 EXPORT_SYMBOL(neigh_parms_release);
 EXPORT_SYMBOL(neigh_rand_reach_time);
 EXPORT_SYMBOL(neigh_resolve_output);
diff -Nurb linux-2.6.22-590/net/core/net-sysfs.c linux-2.6.22-try2-netns/net/core/net-sysfs.c
--- linux-2.6.22-590/net/core/net-sysfs.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/core/net-sysfs.c	2007-12-19 22:49:18.000000000 -0500
@@ -13,7 +13,9 @@
 #include <linux/kernel.h>
 #include <linux/netdevice.h>
 #include <linux/if_arp.h>
+#include <linux/nsproxy.h>
 #include <net/sock.h>
+#include <net/net_namespace.h>
 #include <linux/rtnetlink.h>
 #include <linux/wireless.h>
 #include <net/iw_handler.h>
@@ -29,16 +31,16 @@
 }
 
 /* use same locking rules as GIF* ioctl's */
-static ssize_t netdev_show(const struct device *dev,
+static ssize_t netdev_show(const struct device *device,
 			   struct device_attribute *attr, char *buf,
 			   ssize_t (*format)(const struct net_device *, char *))
 {
-	struct net_device *net = to_net_dev(dev);
+	struct net_device *dev = to_net_dev(device);
 	ssize_t ret = -EINVAL;
 
 	read_lock(&dev_base_lock);
-	if (dev_isalive(net))
-		ret = (*format)(net, buf);
+	if (dev_isalive(dev))
+		ret = (*format)(dev, buf);
 	read_unlock(&dev_base_lock);
 
 	return ret;
@@ -46,9 +48,9 @@
 
 /* generate a show function for simple field */
 #define NETDEVICE_SHOW(field, format_string)				\
-static ssize_t format_##field(const struct net_device *net, char *buf)	\
+static ssize_t format_##field(const struct net_device *dev, char *buf)	\
 {									\
-	return sprintf(buf, format_string, net->field);			\
+	return sprintf(buf, format_string, dev->field);			\
 }									\
 static ssize_t show_##field(struct device *dev,				\
 			    struct device_attribute *attr, char *buf)	\
@@ -58,11 +60,11 @@
 
 
 /* use same locking and permission rules as SIF* ioctl's */
-static ssize_t netdev_store(struct device *dev, struct device_attribute *attr,
+static ssize_t netdev_store(struct device *device, struct device_attribute *attr,
 			    const char *buf, size_t len,
 			    int (*set)(struct net_device *, unsigned long))
 {
-	struct net_device *net = to_net_dev(dev);
+	struct net_device *dev = to_net_dev(device);
 	char *endp;
 	unsigned long new;
 	int ret = -EINVAL;
@@ -75,8 +77,8 @@
 		goto err;
 
 	rtnl_lock();
-	if (dev_isalive(net)) {
-		if ((ret = (*set)(net, new)) == 0)
+	if (dev_isalive(dev)) {
+		if ((ret = (*set)(dev, new)) == 0)
 			ret = len;
 	}
 	rtnl_unlock();
@@ -103,45 +105,45 @@
 	return cp - buf;
 }
 
-static ssize_t show_address(struct device *dev, struct device_attribute *attr,
+static ssize_t show_address(struct device *device, struct device_attribute *attr,
 			    char *buf)
 {
-	struct net_device *net = to_net_dev(dev);
+	struct net_device *dev = to_net_dev(device);
 	ssize_t ret = -EINVAL;
 
 	read_lock(&dev_base_lock);
-	if (dev_isalive(net))
-	    ret = format_addr(buf, net->dev_addr, net->addr_len);
+	if (dev_isalive(dev))
+	    ret = format_addr(buf, dev->dev_addr, dev->addr_len);
 	read_unlock(&dev_base_lock);
 	return ret;
 }
 
-static ssize_t show_broadcast(struct device *dev,
+static ssize_t show_broadcast(struct device *device,
 			    struct device_attribute *attr, char *buf)
 {
-	struct net_device *net = to_net_dev(dev);
-	if (dev_isalive(net))
-		return format_addr(buf, net->broadcast, net->addr_len);
+	struct net_device *dev = to_net_dev(device);
+	if (dev_isalive(dev))
+		return format_addr(buf, dev->broadcast, dev->addr_len);
 	return -EINVAL;
 }
 
-static ssize_t show_carrier(struct device *dev,
+static ssize_t show_carrier(struct device *device,
 			    struct device_attribute *attr, char *buf)
 {
-	struct net_device *netdev = to_net_dev(dev);
-	if (netif_running(netdev)) {
-		return sprintf(buf, fmt_dec, !!netif_carrier_ok(netdev));
+	struct net_device *dev = to_net_dev(device);
+	if (netif_running(dev)) {
+		return sprintf(buf, fmt_dec, !!netif_carrier_ok(dev));
 	}
 	return -EINVAL;
 }
 
-static ssize_t show_dormant(struct device *dev,
+static ssize_t show_dormant(struct device *device,
 			    struct device_attribute *attr, char *buf)
 {
-	struct net_device *netdev = to_net_dev(dev);
+	struct net_device *dev = to_net_dev(device);
 
-	if (netif_running(netdev))
-		return sprintf(buf, fmt_dec, !!netif_dormant(netdev));
+	if (netif_running(dev))
+		return sprintf(buf, fmt_dec, !!netif_dormant(dev));
 
 	return -EINVAL;
 }
@@ -156,15 +158,15 @@
 	"up"
 };
 
-static ssize_t show_operstate(struct device *dev,
+static ssize_t show_operstate(struct device *device,
 			      struct device_attribute *attr, char *buf)
 {
-	const struct net_device *netdev = to_net_dev(dev);
+	const struct net_device *dev = to_net_dev(device);
 	unsigned char operstate;
 
 	read_lock(&dev_base_lock);
-	operstate = netdev->operstate;
-	if (!netif_running(netdev))
+	operstate = dev->operstate;
+	if (!netif_running(dev))
 		operstate = IF_OPER_DOWN;
 	read_unlock(&dev_base_lock);
 
@@ -177,57 +179,57 @@
 /* read-write attributes */
 NETDEVICE_SHOW(mtu, fmt_dec);
 
-static int change_mtu(struct net_device *net, unsigned long new_mtu)
+static int change_mtu(struct net_device *dev, unsigned long new_mtu)
 {
-	return dev_set_mtu(net, (int) new_mtu);
+	return dev_set_mtu(dev, (int) new_mtu);
 }
 
-static ssize_t store_mtu(struct device *dev, struct device_attribute *attr,
+static ssize_t store_mtu(struct device *device, struct device_attribute *attr,
 			 const char *buf, size_t len)
 {
-	return netdev_store(dev, attr, buf, len, change_mtu);
+	return netdev_store(device, attr, buf, len, change_mtu);
 }
 
 NETDEVICE_SHOW(flags, fmt_hex);
 
-static int change_flags(struct net_device *net, unsigned long new_flags)
+static int change_flags(struct net_device *dev, unsigned long new_flags)
 {
-	return dev_change_flags(net, (unsigned) new_flags);
+	return dev_change_flags(dev, (unsigned) new_flags);
 }
 
-static ssize_t store_flags(struct device *dev, struct device_attribute *attr,
+static ssize_t store_flags(struct device *device, struct device_attribute *attr,
 			   const char *buf, size_t len)
 {
-	return netdev_store(dev, attr, buf, len, change_flags);
+	return netdev_store(device, attr, buf, len, change_flags);
 }
 
 NETDEVICE_SHOW(tx_queue_len, fmt_ulong);
 
-static int change_tx_queue_len(struct net_device *net, unsigned long new_len)
+static int change_tx_queue_len(struct net_device *dev, unsigned long new_len)
 {
-	net->tx_queue_len = new_len;
+	dev->tx_queue_len = new_len;
 	return 0;
 }
 
-static ssize_t store_tx_queue_len(struct device *dev,
+static ssize_t store_tx_queue_len(struct device *device,
 				  struct device_attribute *attr,
 				  const char *buf, size_t len)
 {
-	return netdev_store(dev, attr, buf, len, change_tx_queue_len);
+	return netdev_store(device, attr, buf, len, change_tx_queue_len);
 }
 
 NETDEVICE_SHOW(weight, fmt_dec);
 
-static int change_weight(struct net_device *net, unsigned long new_weight)
+static int change_weight(struct net_device *dev, unsigned long new_weight)
 {
-	net->weight = new_weight;
+	dev->weight = new_weight;
 	return 0;
 }
 
-static ssize_t store_weight(struct device *dev, struct device_attribute *attr,
+static ssize_t store_weight(struct device *device, struct device_attribute *attr,
 			    const char *buf, size_t len)
 {
-	return netdev_store(dev, attr, buf, len, change_weight);
+	return netdev_store(device, attr, buf, len, change_weight);
 }
 
 static struct device_attribute net_class_attributes[] = {
@@ -447,6 +449,23 @@
 	kfree((char *)dev - dev->padded);
 }
 
+static const void *net_current_tag(void)
+{
+	return current->nsproxy->net_ns;
+}
+
+static const void *net_kobject_tag(struct kobject *kobj)
+{
+	struct net_device *dev;
+	dev = container_of(kobj, struct net_device, dev.kobj);
+	return dev->nd_net;
+}
+
+static const struct shadow_dir_operations net_shadow_dir_operations = {
+	.current_tag = net_current_tag,
+	.kobject_tag = net_kobject_tag,
+};
+
 static struct class net_class = {
 	.name = "net",
 	.dev_release = netdev_release,
@@ -454,42 +473,43 @@
 #ifdef CONFIG_HOTPLUG
 	.dev_uevent = netdev_uevent,
 #endif
+	.shadow_ops = &net_shadow_dir_operations,
 };
 
 /* Delete sysfs entries but hold kobject reference until after all
  * netdev references are gone.
  */
-void netdev_unregister_sysfs(struct net_device * net)
+void netdev_unregister_sysfs(struct net_device * dev)
 {
-	struct device *dev = &(net->dev);
+	struct device *device = &(dev->dev);
 
-	kobject_get(&dev->kobj);
-	device_del(dev);
+	kobject_get(&device->kobj);
+	device_del(device);
 }
 
 /* Create sysfs entries for network device. */
-int netdev_register_sysfs(struct net_device *net)
+int netdev_register_sysfs(struct net_device *dev)
 {
-	struct device *dev = &(net->dev);
-	struct attribute_group **groups = net->sysfs_groups;
+	struct device *device = &(dev->dev);
+	struct attribute_group **groups = dev->sysfs_groups;
 
-	device_initialize(dev);
-	dev->class = &net_class;
-	dev->platform_data = net;
-	dev->groups = groups;
+	device_initialize(device);
+	device->class = &net_class;
+	device->platform_data = dev;
+	device->groups = groups;
 
 	BUILD_BUG_ON(BUS_ID_SIZE < IFNAMSIZ);
-	strlcpy(dev->bus_id, net->name, BUS_ID_SIZE);
+	strlcpy(device->bus_id, dev->name, BUS_ID_SIZE);
 
-	if (net->get_stats)
+	if (dev->get_stats)
 		*groups++ = &netstat_group;
 
 #ifdef CONFIG_WIRELESS_EXT
-	if (net->wireless_handlers && net->wireless_handlers->get_wireless_stats)
+	if (dev->wireless_handlers && dev->wireless_handlers->get_wireless_stats)
 		*groups++ = &wireless_group;
 #endif
 
-	return device_add(dev);
+	return device_add(device);
 }
 
 int netdev_sysfs_init(void)
diff -Nurb linux-2.6.22-590/net/core/net_namespace.c linux-2.6.22-try2-netns/net/core/net_namespace.c
--- linux-2.6.22-590/net/core/net_namespace.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/net/core/net_namespace.c	2007-12-19 22:49:18.000000000 -0500
@@ -0,0 +1,332 @@
+#include <linux/workqueue.h>
+#include <linux/rtnetlink.h>
+#include <linux/cache.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <net/net_namespace.h>
+
+/*
+ *	Our network namespace constructor/destructor lists
+ */
+
+static LIST_HEAD(pernet_list);
+static struct list_head *first_device = &pernet_list;
+static DEFINE_MUTEX(net_mutex);
+
+static DEFINE_MUTEX(net_list_mutex);
+LIST_HEAD(net_namespace_list);
+
+static struct kmem_cache *net_cachep;
+
+struct net init_net;
+EXPORT_SYMBOL_GPL(init_net);
+
+void net_lock(void)
+{
+	mutex_lock(&net_list_mutex);
+}
+
+void net_unlock(void)
+{
+	mutex_unlock(&net_list_mutex);
+}
+
+static struct net *net_alloc(void)
+{
+	return kmem_cache_alloc(net_cachep, GFP_KERNEL);
+}
+
+static void net_free(struct net *net)
+{
+	if (!net)
+		return;
+
+	if (unlikely(atomic_read(&net->use_count) != 0)) {
+		printk(KERN_EMERG "network namespace not free! Usage: %d\n",
+			atomic_read(&net->use_count));
+		return;
+	}
+
+	kmem_cache_free(net_cachep, net);
+}
+
+static void cleanup_net(struct work_struct *work)
+{
+	struct pernet_operations *ops;
+	struct list_head *ptr;
+	struct net *net;
+
+	net = container_of(work, struct net, work);
+
+	mutex_lock(&net_mutex);
+
+	/* Don't let anyone else find us. */
+	net_lock();
+	list_del(&net->list);
+	net_unlock();
+
+	/* Run all of the network namespace exit methods */
+	list_for_each_prev(ptr, &pernet_list) {
+		ops = list_entry(ptr, struct pernet_operations, list);
+		if (ops->exit)
+			ops->exit(net);
+	}
+
+	mutex_unlock(&net_mutex);
+
+	/* Ensure there are no outstanding rcu callbacks using this
+	 * network namespace.
+	 */
+	rcu_barrier();
+
+	/* Finally it is safe to free my network namespace structure */
+	net_free(net);
+}
+
+
+void __put_net(struct net *net)
+{
+	/* Cleanup the network namespace in process context */
+	INIT_WORK(&net->work, cleanup_net);
+	schedule_work(&net->work);
+}
+EXPORT_SYMBOL_GPL(__put_net);
+
+/*
+ * setup_net runs the initializers for the network namespace object.
+ */
+static int setup_net(struct net *net)
+{
+	/* Must be called with net_mutex held */
+	struct pernet_operations *ops;
+	struct list_head *ptr;
+	int error;
+
+	memset(net, 0, sizeof(struct net));
+	atomic_set(&net->count, 1);
+	atomic_set(&net->use_count, 0);
+
+	error = 0;
+	list_for_each(ptr, &pernet_list) {
+		ops = list_entry(ptr, struct pernet_operations, list);
+		if (ops->init) {
+			error = ops->init(net);
+			if (error < 0)
+				goto out_undo;
+		}
+	}
+out:
+	return error;
+out_undo:
+	/* Walk through the list backwards calling the exit functions
+	 * for the pernet modules whose init functions did not fail.
+	 */
+	for (ptr = ptr->prev; ptr != &pernet_list; ptr = ptr->prev) {
+		ops = list_entry(ptr, struct pernet_operations, list);
+		if (ops->exit)
+			ops->exit(net);
+	}
+	goto out;
+}
+
+struct net *copy_net_ns(unsigned long flags, struct net *old_net)
+{
+	struct net *new_net = NULL;
+	int err;
+
+	get_net(old_net);
+
+	if (!(flags & CLONE_NEWNET))
+		return old_net;
+
+	err = -EPERM;
+	if (!capable(CAP_SYS_ADMIN))
+		goto out;
+
+	err = -ENOMEM;
+	new_net = net_alloc();
+	if (!new_net)
+		goto out;
+
+	mutex_lock(&net_mutex);
+	err = setup_net(new_net);
+	if (err)
+		goto out_unlock;
+
+	net_lock();
+	list_add_tail(&new_net->list, &net_namespace_list);
+	net_unlock();
+
+
+out_unlock:
+	mutex_unlock(&net_mutex);
+out:
+	put_net(old_net);
+	if (err) {
+		net_free(new_net);
+		new_net = ERR_PTR(err);
+	}
+	return new_net;
+}
+
+static int __init net_ns_init(void)
+{
+	int err;
+
+	printk(KERN_INFO "net_namespace: %zd bytes\n", sizeof(struct net));
+	net_cachep = kmem_cache_create("net_namespace", sizeof(struct net),
+					SMP_CACHE_BYTES,
+					SLAB_PANIC, NULL, NULL);
+	mutex_lock(&net_mutex);
+	err = setup_net(&init_net);
+
+	net_lock();
+	list_add_tail(&init_net.list, &net_namespace_list);
+	net_unlock();
+
+	mutex_unlock(&net_mutex);
+	if (err)
+		panic("Could not setup the initial network namespace");
+
+	return 0;
+}
+
+pure_initcall(net_ns_init);
+
+static int register_pernet_operations(struct list_head *list,
+				      struct pernet_operations *ops)
+{
+	struct net *net, *undo_net;
+	int error;
+
+	error = 0;
+	list_add_tail(&ops->list, list);
+	for_each_net(net) {
+		if (ops->init) {
+			error = ops->init(net);
+			if (error)
+				goto out_undo;
+		}
+	}
+out:
+	return error;
+
+out_undo:
+	/* If I have an error cleanup all namespaces I initialized */
+	list_del(&ops->list);
+	for_each_net(undo_net) {
+		if (undo_net == net)
+			goto undone;
+		if (ops->exit)
+			ops->exit(undo_net);
+	}
+undone:
+	goto out;
+}
+
+static void unregister_pernet_operations(struct pernet_operations *ops)
+{
+	struct net *net;
+
+	list_del(&ops->list);
+	for_each_net(net)
+		if (ops->exit)
+			ops->exit(net);
+}
+
+/**
+ *      register_pernet_subsys - register a network namespace subsystem
+ *	@ops:  pernet operations structure for the subsystem
+ *
+ *	Register a subsystem which has init and exit functions
+ *	that are called when network namespaces are created and
+ *	destroyed respectively.
+ *
+ *	When registered all network namespace init functions are
+ *	called for every existing network namespace.  Allowing kernel
+ *	modules to have a race free view of the set of network namespaces.
+ *
+ *	When a new network namespace is created all of the init
+ *	methods are called in the order in which they were registered.
+ *
+ *	When a network namespace is destroyed all of the exit methods
+ *	are called in the reverse of the order with which they were
+ *	registered.
+ */
+int register_pernet_subsys(struct pernet_operations *ops)
+{
+	int error;
+	mutex_lock(&net_mutex);
+	error =  register_pernet_operations(first_device, ops);
+	mutex_unlock(&net_mutex);
+	return error;
+}
+EXPORT_SYMBOL_GPL(register_pernet_subsys);
+
+/**
+ *      unregister_pernet_subsys - unregister a network namespace subsystem
+ *	@ops: pernet operations structure to manipulate
+ *
+ *	Remove the pernet operations structure from the list to be
+ *	used when network namespaces are created or destoryed.  In
+ *	addition run the exit method for all existing network
+ *	namespaces.
+ */
+void unregister_pernet_subsys(struct pernet_operations *module)
+{
+	mutex_lock(&net_mutex);
+	unregister_pernet_operations(module);
+	mutex_unlock(&net_mutex);
+}
+EXPORT_SYMBOL_GPL(unregister_pernet_subsys);
+
+/**
+ *      register_pernet_device - register a network namespace device
+ *	@ops:  pernet operations structure for the subsystem
+ *
+ *	Register a device which has init and exit functions
+ *	that are called when network namespaces are created and
+ *	destroyed respectively.
+ *
+ *	When registered all network namespace init functions are
+ *	called for every existing network namespace.  Allowing kernel
+ *	modules to have a race free view of the set of network namespaces.
+ *
+ *	When a new network namespace is created all of the init
+ *	methods are called in the order in which they were registered.
+ *
+ *	When a network namespace is destroyed all of the exit methods
+ *	are called in the reverse of the order with which they were
+ *	registered.
+ */
+int register_pernet_device(struct pernet_operations *ops)
+{
+	int error;
+	mutex_lock(&net_mutex);
+	error = register_pernet_operations(&pernet_list, ops);
+	if (!error && (first_device == &pernet_list))
+		first_device = &ops->list;
+	mutex_unlock(&net_mutex);
+	return error;
+}
+EXPORT_SYMBOL_GPL(register_pernet_device);
+
+/**
+ *      unregister_pernet_device - unregister a network namespace netdevice
+ *	@ops: pernet operations structure to manipulate
+ *
+ *	Remove the pernet operations structure from the list to be
+ *	used when network namespaces are created or destoryed.  In
+ *	addition run the exit method for all existing network
+ *	namespaces.
+ */
+void unregister_pernet_device(struct pernet_operations *ops)
+{
+	mutex_lock(&net_mutex);
+	if (&ops->list == first_device)
+		first_device = first_device->next;
+	unregister_pernet_operations(ops);
+	mutex_unlock(&net_mutex);
+}
+EXPORT_SYMBOL_GPL(unregister_pernet_device);
diff -Nurb linux-2.6.22-590/net/core/netpoll.c linux-2.6.22-try2-netns/net/core/netpoll.c
--- linux-2.6.22-590/net/core/netpoll.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/core/netpoll.c	2007-12-19 22:49:18.000000000 -0500
@@ -634,7 +634,7 @@
 	int err;
 
 	if (np->dev_name)
-		ndev = dev_get_by_name(np->dev_name);
+		ndev = dev_get_by_name(&init_net, np->dev_name);
 	if (!ndev) {
 		printk(KERN_ERR "%s: %s doesn't exist, aborting.\n",
 		       np->name, np->dev_name);
diff -Nurb linux-2.6.22-590/net/core/pktgen.c linux-2.6.22-try2-netns/net/core/pktgen.c
--- linux-2.6.22-590/net/core/pktgen.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/core/pktgen.c	2007-12-19 22:49:18.000000000 -0500
@@ -155,6 +155,7 @@
 #include <net/checksum.h>
 #include <net/ipv6.h>
 #include <net/addrconf.h>
+#include <net/net_namespace.h>
 #include <asm/byteorder.h>
 #include <linux/rcupdate.h>
 #include <asm/bitops.h>
@@ -1903,6 +1904,9 @@
 {
 	struct net_device *dev = ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	/* It is OK that we do not hold the group lock right now,
 	 * as we run under the RTNL lock.
 	 */
@@ -1933,7 +1937,7 @@
 		pkt_dev->odev = NULL;
 	}
 
-	odev = dev_get_by_name(ifname);
+	odev = dev_get_by_name(&init_net, ifname);
 	if (!odev) {
 		printk("pktgen: no such netdevice: \"%s\"\n", ifname);
 		return -ENODEV;
@@ -3570,7 +3574,7 @@
 
 	printk(version);
 
-	pg_proc_dir = proc_mkdir(PG_PROC_DIR, proc_net);
+	pg_proc_dir = proc_mkdir(PG_PROC_DIR, init_net.proc_net);
 	if (!pg_proc_dir)
 		return -ENODEV;
 	pg_proc_dir->owner = THIS_MODULE;
@@ -3579,7 +3583,7 @@
 	if (pe == NULL) {
 		printk("pktgen: ERROR: cannot create %s procfs entry.\n",
 		       PGCTRL);
-		proc_net_remove(PG_PROC_DIR);
+		proc_net_remove(&init_net, PG_PROC_DIR);
 		return -EINVAL;
 	}
 
@@ -3602,7 +3606,7 @@
 		printk("pktgen: ERROR: Initialization failed for all threads\n");
 		unregister_netdevice_notifier(&pktgen_notifier_block);
 		remove_proc_entry(PGCTRL, pg_proc_dir);
-		proc_net_remove(PG_PROC_DIR);
+		proc_net_remove(&init_net, PG_PROC_DIR);
 		return -ENODEV;
 	}
 
@@ -3629,7 +3633,7 @@
 
 	/* Clean up proc file system */
 	remove_proc_entry(PGCTRL, pg_proc_dir);
-	proc_net_remove(PG_PROC_DIR);
+	proc_net_remove(&init_net, PG_PROC_DIR);
 }
 
 module_init(pg_init);
diff -Nurb linux-2.6.22-590/net/core/rtnetlink.c linux-2.6.22-try2-netns/net/core/rtnetlink.c
--- linux-2.6.22-590/net/core/rtnetlink.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/core/rtnetlink.c	2007-12-19 23:04:00.000000000 -0500
@@ -59,7 +59,6 @@
 };
 
 static DEFINE_MUTEX(rtnl_mutex);
-static struct sock *rtnl;
 
 void rtnl_lock(void)
 {
@@ -73,9 +72,17 @@
 
 void rtnl_unlock(void)
 {
+	struct net *net;
 	mutex_unlock(&rtnl_mutex);
+	
+	net_lock();
+	for_each_net(net) {
+		struct sock *rtnl = net->rtnl;
 	if (rtnl && rtnl->sk_receive_queue.qlen)
 		rtnl->sk_data_ready(rtnl, 0);
+	}
+	net_unlock();
+
 	netdev_run_todo();
 }
 
@@ -446,8 +453,9 @@
 	return ret;
 }
 
-int rtnetlink_send(struct sk_buff *skb, u32 pid, unsigned group, int echo)
+int rtnetlink_send(struct sk_buff *skb, struct net *net, u32 pid, unsigned group, int echo)
 {
+	struct sock *rtnl = net->rtnl;
 	int err = 0;
 
 	NETLINK_CB(skb).dst_group = group;
@@ -459,14 +467,17 @@
 	return err;
 }
 
-int rtnl_unicast(struct sk_buff *skb, u32 pid)
+int rtnl_unicast(struct sk_buff *skb, struct net *net, u32 pid)
 {
+	struct sock *rtnl = net->rtnl;
+
 	return nlmsg_unicast(rtnl, skb, pid);
 }
 
-int rtnl_notify(struct sk_buff *skb, u32 pid, u32 group,
+int rtnl_notify(struct sk_buff *skb, struct net *net, u32 pid, u32 group,
 		struct nlmsghdr *nlh, gfp_t flags)
 {
+	struct sock *rtnl = net->rtnl;
 	int report = 0;
 
 	if (nlh)
@@ -475,8 +486,10 @@
 	return nlmsg_notify(rtnl, skb, pid, group, report, flags);
 }
 
-void rtnl_set_sk_err(u32 group, int error)
+void rtnl_set_sk_err(struct net *net, u32 group, int error)
 {
+	struct sock *rtnl = net->rtnl;
+
 	netlink_set_err(rtnl, 0, group, error);
 }
 
@@ -687,12 +700,13 @@
 
 static int rtnl_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)
 {
+ 	struct net *net = skb->sk->sk_net;
 	int idx;
 	int s_idx = cb->args[0];
 	struct net_device *dev;
 
 	idx = 0;
-	for_each_netdev(dev) {
+	for_each_netdev(net, dev) {
 		if (!nx_dev_visible(skb->sk->sk_nx_info, dev))
 			continue;
 		if (idx < s_idx)
@@ -857,6 +871,7 @@
 
 static int rtnl_setlink(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct ifinfomsg *ifm;
 	struct net_device *dev;
 	int err;
@@ -875,9 +890,9 @@
 	err = -EINVAL;
 	ifm = nlmsg_data(nlh);
 	if (ifm->ifi_index > 0)
-		dev = dev_get_by_index(ifm->ifi_index);
+		dev = dev_get_by_index(net, ifm->ifi_index);
 	else if (tb[IFLA_IFNAME])
-		dev = dev_get_by_name(ifname);
+		dev = dev_get_by_name(net, ifname);
 	else
 		goto errout;
 
@@ -903,6 +918,7 @@
 
 static int rtnl_dellink(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	const struct rtnl_link_ops *ops;
 	struct net_device *dev;
 	struct ifinfomsg *ifm;
@@ -919,9 +935,9 @@
 
 	ifm = nlmsg_data(nlh);
 	if (ifm->ifi_index > 0)
-		dev = __dev_get_by_index(ifm->ifi_index);
+		dev = __dev_get_by_index(net, ifm->ifi_index);
 	else if (tb[IFLA_IFNAME])
-		dev = __dev_get_by_name(ifname);
+		dev = __dev_get_by_name(net, ifname);
 	else
 		return -EINVAL;
 
@@ -938,6 +954,7 @@
 
 static int rtnl_newlink(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	const struct rtnl_link_ops *ops;
 	struct net_device *dev;
 	struct ifinfomsg *ifm;
@@ -959,9 +976,9 @@
 
 	ifm = nlmsg_data(nlh);
 	if (ifm->ifi_index > 0)
-		dev = __dev_get_by_index(ifm->ifi_index);
+		dev = __dev_get_by_index(net, ifm->ifi_index);
 	else if (ifname[0])
-		dev = __dev_get_by_name(ifname);
+		dev = __dev_get_by_name(net, ifname);
 	else
 		dev = NULL;
 
@@ -1079,6 +1096,7 @@
 
 static int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct ifinfomsg *ifm;
 	struct nlattr *tb[IFLA_MAX+1];
 	struct net_device *dev = NULL;
@@ -1091,7 +1109,7 @@
 
 	ifm = nlmsg_data(nlh);
 	if (ifm->ifi_index > 0) {
-		dev = dev_get_by_index(ifm->ifi_index);
+		dev = dev_get_by_index(net, ifm->ifi_index);
 		if (dev == NULL)
 			return -ENODEV;
 	} else
@@ -1111,7 +1129,7 @@
 		kfree_skb(nskb);
 		goto errout;
 	}
-	err = rtnl_unicast(nskb, NETLINK_CB(skb).pid);
+	err = rtnl_unicast(nskb, net, NETLINK_CB(skb).pid);
 errout:
 	dev_put(dev);
 
@@ -1144,6 +1162,7 @@
 
 void rtmsg_ifinfo(int type, struct net_device *dev, unsigned change)
 {
+	struct net *net = dev->nd_net;
 	struct sk_buff *skb;
 	int err = -ENOBUFS;
 
@@ -1161,10 +1180,10 @@
 		kfree_skb(skb);
 		goto errout;
 	}
-	err = rtnl_notify(skb, 0, RTNLGRP_LINK, NULL, GFP_KERNEL);
+	err = rtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_KERNEL);
 errout:
 	if (err < 0)
-		rtnl_set_sk_err(RTNLGRP_LINK, err);
+		rtnl_set_sk_err(net, RTNLGRP_LINK, err);
 }
 
 /* Protected by RTNL sempahore.  */
@@ -1175,6 +1194,7 @@
 
 static int rtnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 {
+	struct net *net = skb->sk->sk_net;
 	rtnl_doit_func doit;
 	int sz_idx, kind;
 	int min_len;
@@ -1203,6 +1223,7 @@
 		return -EPERM;
 
 	if (kind == 2 && nlh->nlmsg_flags&NLM_F_DUMP) {
+		struct sock *rtnl;
 		rtnl_dumpit_func dumpit;
 
 		dumpit = rtnl_get_dumpit(family, type);
@@ -1210,6 +1231,7 @@
 			return -EOPNOTSUPP;
 
 		__rtnl_unlock();
+		rtnl = net->rtnl;
 		err = netlink_dump_start(rtnl, skb, nlh, dumpit, NULL);
 		rtnl_lock();
 		return err;
@@ -1259,6 +1281,10 @@
 static int rtnetlink_event(struct notifier_block *this, unsigned long event, void *ptr)
 {
 	struct net_device *dev = ptr;
+
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	switch (event) {
 	case NETDEV_UNREGISTER:
 		rtmsg_ifinfo(RTM_DELLINK, dev, ~0U);
@@ -1284,6 +1310,36 @@
 	.notifier_call	= rtnetlink_event,
 };
 
+
+static int rtnetlink_net_init(struct net *net)
+{
+	struct sock *sk;
+	sk = netlink_kernel_create(net, NETLINK_ROUTE, RTNLGRP_MAX,
+				   rtnetlink_rcv, &rtnl_mutex, THIS_MODULE);
+	if (!sk)
+		return -ENOMEM;
+
+	/* Don't hold an extra reference on the namespace */
+	put_net(sk->sk_net);
+	net->rtnl = sk;
+	return 0;
+}
+
+static void rtnetlink_net_exit(struct net *net)
+{
+	/* At the last minute lie and say this is a socket for the
+	 * initial network namespace.  So the socket will be safe to
+	 * free.
+	 */
+	net->rtnl->sk_net = get_net(&init_net);
+	sock_put(net->rtnl);
+}
+
+static struct pernet_operations rtnetlink_net_ops = {
+	.init = rtnetlink_net_init,
+	.exit = rtnetlink_net_exit,
+};
+
 void __init rtnetlink_init(void)
 {
 	int i;
@@ -1296,10 +1352,9 @@
 	if (!rta_buf)
 		panic("rtnetlink_init: cannot allocate rta_buf\n");
 
-	rtnl = netlink_kernel_create(NETLINK_ROUTE, RTNLGRP_MAX, rtnetlink_rcv,
-				     &rtnl_mutex, THIS_MODULE);
-	if (rtnl == NULL)
+	if (register_pernet_subsys(&rtnetlink_net_ops))
 		panic("rtnetlink_init: cannot initialize rtnetlink\n");
+
 	netlink_set_nonroot(NETLINK_ROUTE, NL_NONROOT_RECV);
 	register_netdevice_notifier(&rtnetlink_dev_notifier);
 
diff -Nurb linux-2.6.22-590/net/core/sock.c linux-2.6.22-try2-netns/net/core/sock.c
--- linux-2.6.22-590/net/core/sock.c	2007-12-21 15:33:47.000000000 -0500
+++ linux-2.6.22-try2-netns/net/core/sock.c	2007-12-19 23:04:11.000000000 -0500
@@ -123,6 +123,7 @@
 #include <net/sock.h>
 #include <net/xfrm.h>
 #include <linux/ipsec.h>
+#include <net/net_namespace.h>
 
 #include <linux/filter.h>
 #include <linux/vs_socket.h>
@@ -360,6 +361,7 @@
 		    char __user *optval, int optlen)
 {
 	struct sock *sk=sock->sk;
+	struct net *net = sk->sk_net;
 	struct sk_filter *filter;
 	int val;
 	int valbool;
@@ -614,7 +616,7 @@
 			if (devname[0] == '\0') {
 				sk->sk_bound_dev_if = 0;
 			} else {
-				struct net_device *dev = dev_get_by_name(devname);
+				struct net_device *dev = dev_get_by_name(net, devname);
 				if (!dev) {
 					ret = -ENODEV;
 					break;
@@ -867,7 +869,7 @@
  *	@prot: struct proto associated with this new sock instance
  *	@zero_it: if we should zero the newly allocated sock
  */
-struct sock *sk_alloc(int family, gfp_t priority,
+struct sock *sk_alloc(struct net *net, int family, gfp_t priority,
 		      struct proto *prot, int zero_it)
 {
 	struct sock *sk = NULL;
@@ -888,6 +890,7 @@
 			 */
 			sk->sk_prot = sk->sk_prot_creator = prot;
 			sock_lock_init(sk);
+			sk->sk_net = get_net(net);
 		}
 		sock_vx_init(sk);
 		sock_nx_init(sk);
@@ -929,6 +932,7 @@
 		       __FUNCTION__, atomic_read(&sk->sk_omem_alloc));
 
 	security_sk_free(sk);
+ 	put_net(sk->sk_net);
 	vx_sock_dec(sk);
 	clr_vx_info(&sk->sk_vx_info);
 	sk->sk_xid = -1;
@@ -943,7 +947,7 @@
 
 struct sock *sk_clone(const struct sock *sk, const gfp_t priority)
 {
-	struct sock *newsk = sk_alloc(sk->sk_family, priority, sk->sk_prot, 0);
+	struct sock *newsk = sk_alloc(sk->sk_net, sk->sk_family, priority, sk->sk_prot, 0);
 
 	if (newsk != NULL) {
 		struct sk_filter *filter;
@@ -2017,7 +2021,7 @@
 static int __init proto_init(void)
 {
 	/* register /proc/net/protocols */
-	return proc_net_fops_create("protocols", S_IRUGO, &proto_seq_fops) == NULL ? -ENOBUFS : 0;
+	return proc_net_fops_create(&init_net, "protocols", S_IRUGO, &proto_seq_fops) == NULL ? -ENOBUFS : 0;
 }
 
 subsys_initcall(proto_init);
diff -Nurb linux-2.6.22-590/net/core/sysctl_net_core.c linux-2.6.22-try2-netns/net/core/sysctl_net_core.c
--- linux-2.6.22-590/net/core/sysctl_net_core.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/core/sysctl_net_core.c	2007-12-19 22:49:18.000000000 -0500
@@ -9,25 +9,10 @@
 #include <linux/sysctl.h>
 #include <linux/module.h>
 #include <linux/socket.h>
+#include <linux/netdevice.h>
+#include <net/xfrm.h>
 #include <net/sock.h>
 
-#ifdef CONFIG_SYSCTL
-
-extern int netdev_max_backlog;
-extern int weight_p;
-
-extern __u32 sysctl_wmem_max;
-extern __u32 sysctl_rmem_max;
-
-extern int sysctl_core_destroy_delay;
-
-#ifdef CONFIG_XFRM
-extern u32 sysctl_xfrm_aevent_etime;
-extern u32 sysctl_xfrm_aevent_rseqth;
-extern int sysctl_xfrm_larval_drop;
-extern u32 sysctl_xfrm_acq_expires;
-#endif
-
 ctl_table core_table[] = {
 #ifdef CONFIG_NET
 	{
@@ -103,11 +88,32 @@
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec
 	},
+#endif /* CONFIG_NET */
+	{
+		.ctl_name	= NET_CORE_BUDGET,
+		.procname	= "netdev_budget",
+		.data		= &netdev_budget,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.ctl_name	= NET_CORE_WARNINGS,
+		.procname	= "warnings",
+		.data		= &net_msg_warn,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{ .ctl_name = 0 }
+};
+
+struct ctl_table multi_core_table[] = {
 #ifdef CONFIG_XFRM
 	{
 		.ctl_name	= NET_CORE_AEVENT_ETIME,
 		.procname	= "xfrm_aevent_etime",
-		.data		= &sysctl_xfrm_aevent_etime,
+		.data		= &init_net.sysctl_xfrm_aevent_etime,
 		.maxlen		= sizeof(u32),
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec
@@ -115,7 +121,7 @@
 	{
 		.ctl_name	= NET_CORE_AEVENT_RSEQTH,
 		.procname	= "xfrm_aevent_rseqth",
-		.data		= &sysctl_xfrm_aevent_rseqth,
+		.data		= &init_net.sysctl_xfrm_aevent_rseqth,
 		.maxlen		= sizeof(u32),
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec
@@ -123,7 +129,7 @@
 	{
 		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "xfrm_larval_drop",
-		.data		= &sysctl_xfrm_larval_drop,
+		.data		= &init_net.sysctl_xfrm_larval_drop,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec
@@ -131,38 +137,19 @@
 	{
 		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "xfrm_acq_expires",
-		.data		= &sysctl_xfrm_acq_expires,
+		.data		= &init_net.sysctl_xfrm_acq_expires,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec
 	},
 #endif /* CONFIG_XFRM */
-#endif /* CONFIG_NET */
 	{
 		.ctl_name	= NET_CORE_SOMAXCONN,
 		.procname	= "somaxconn",
-		.data		= &sysctl_somaxconn,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec
-	},
-	{
-		.ctl_name	= NET_CORE_BUDGET,
-		.procname	= "netdev_budget",
-		.data		= &netdev_budget,
+		.data		= &init_net.sysctl_somaxconn,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec
 	},
-	{
-		.ctl_name	= NET_CORE_WARNINGS,
-		.procname	= "warnings",
-		.data		= &net_msg_warn,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec
-	},
-	{ .ctl_name = 0 }
+	{}
 };
-
-#endif
diff -Nurb linux-2.6.22-590/net/dccp/ipv4.c linux-2.6.22-try2-netns/net/dccp/ipv4.c
--- linux-2.6.22-590/net/dccp/ipv4.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/dccp/ipv4.c	2007-12-19 22:49:18.000000000 -0500
@@ -202,6 +202,7 @@
  */
 static void dccp_v4_err(struct sk_buff *skb, u32 info)
 {
+	struct net *net = skb->dev->nd_net;
 	const struct iphdr *iph = (struct iphdr *)skb->data;
 	const struct dccp_hdr *dh = (struct dccp_hdr *)(skb->data +
 							(iph->ihl << 2));
@@ -213,13 +214,16 @@
 	__u64 seq;
 	int err;
 
+	if (skb->dev->nd_net != &init_net)
+		return;
+
 	if (skb->len < (iph->ihl << 2) + 8) {
 		ICMP_INC_STATS_BH(ICMP_MIB_INERRORS);
 		return;
 	}
 
 	sk = inet_lookup(&dccp_hashinfo, iph->daddr, dh->dccph_dport,
-			 iph->saddr, dh->dccph_sport, inet_iif(skb));
+			 iph->saddr, dh->dccph_sport, inet_iif(skb), net);
 	if (sk == NULL) {
 		ICMP_INC_STATS_BH(ICMP_MIB_INERRORS);
 		return;
@@ -441,7 +445,7 @@
 	nsk = inet_lookup_established(&dccp_hashinfo,
 				      iph->saddr, dh->dccph_sport,
 				      iph->daddr, dh->dccph_dport,
-				      inet_iif(skb));
+				      inet_iif(skb), sk->sk_net);
 	if (nsk != NULL) {
 		if (nsk->sk_state != DCCP_TIME_WAIT) {
 			bh_lock_sock(nsk);
@@ -458,7 +462,8 @@
 					   struct sk_buff *skb)
 {
 	struct rtable *rt;
-	struct flowi fl = { .oif = ((struct rtable *)skb->dst)->rt_iif,
+	struct flowi fl = { .fl_net = &init_net,
+			    .oif = ((struct rtable *)skb->dst)->rt_iif,
 			    .nl_u = { .ip4_u =
 				      { .daddr = ip_hdr(skb)->saddr,
 					.saddr = ip_hdr(skb)->daddr,
@@ -809,11 +814,16 @@
 /* this is called when real data arrives */
 static int dccp_v4_rcv(struct sk_buff *skb)
 {
+	struct net *net = skb->dev->nd_net;
 	const struct dccp_hdr *dh;
 	const struct iphdr *iph;
 	struct sock *sk;
 	int min_cov;
 
+	if (skb->dev->nd_net != &init_net) {
+		kfree_skb(skb);
+		return 0;
+	}
 	/* Step 1: Check header basics */
 
 	if (dccp_invalid_packet(skb))
@@ -852,7 +862,7 @@
 	 *	Look up flow ID in table and get corresponding socket */
 	sk = __inet_lookup(&dccp_hashinfo,
 			   iph->saddr, dh->dccph_sport,
-			   iph->daddr, dh->dccph_dport, inet_iif(skb));
+			   iph->daddr, dh->dccph_dport, inet_iif(skb), net);
 	/*
 	 * Step 2:
 	 *	If no socket ...
diff -Nurb linux-2.6.22-590/net/dccp/ipv6.c linux-2.6.22-try2-netns/net/dccp/ipv6.c
--- linux-2.6.22-590/net/dccp/ipv6.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/dccp/ipv6.c	2007-12-19 22:49:18.000000000 -0500
@@ -94,6 +94,7 @@
 static void dccp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 			int type, int code, int offset, __be32 info)
 {
+	struct net *net = skb->dev->nd_net;
 	struct ipv6hdr *hdr = (struct ipv6hdr *)skb->data;
 	const struct dccp_hdr *dh = (struct dccp_hdr *)(skb->data + offset);
 	struct ipv6_pinfo *np;
@@ -102,7 +103,7 @@
 	__u64 seq;
 
 	sk = inet6_lookup(&dccp_hashinfo, &hdr->daddr, dh->dccph_dport,
-			  &hdr->saddr, dh->dccph_sport, inet6_iif(skb));
+			  &hdr->saddr, dh->dccph_sport, inet6_iif(skb), net);
 
 	if (sk == NULL) {
 		ICMP6_INC_STATS_BH(__in6_dev_get(skb->dev), ICMP6_MIB_INERRORS);
@@ -142,6 +143,7 @@
 			   for now.
 			 */
 			memset(&fl, 0, sizeof(fl));
+			fl.fl_net = &init_net;
 			fl.proto = IPPROTO_DCCP;
 			ipv6_addr_copy(&fl.fl6_dst, &np->daddr);
 			ipv6_addr_copy(&fl.fl6_src, &np->saddr);
@@ -242,6 +244,7 @@
 	int err = -1;
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net,
 	fl.proto = IPPROTO_DCCP;
 	ipv6_addr_copy(&fl.fl6_dst, &ireq6->rmt_addr);
 	ipv6_addr_copy(&fl.fl6_src, &ireq6->loc_addr);
@@ -358,6 +361,7 @@
 						      &rxip6h->daddr);
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	ipv6_addr_copy(&fl.fl6_dst, &rxip6h->saddr);
 	ipv6_addr_copy(&fl.fl6_src, &rxip6h->daddr);
 
@@ -407,7 +411,7 @@
 	nsk = __inet6_lookup_established(&dccp_hashinfo,
 					 &iph->saddr, dh->dccph_sport,
 					 &iph->daddr, ntohs(dh->dccph_dport),
-					 inet6_iif(skb));
+					 inet6_iif(skb), sk->sk_net);
 	if (nsk != NULL) {
 		if (nsk->sk_state != DCCP_TIME_WAIT) {
 			bh_lock_sock(nsk);
@@ -584,6 +588,7 @@
 		struct flowi fl;
 
 		memset(&fl, 0, sizeof(fl));
+		fl.fl_net = &init_net;
 		fl.proto = IPPROTO_DCCP;
 		ipv6_addr_copy(&fl.fl6_dst, &ireq6->rmt_addr);
 		if (opt != NULL && opt->srcrt != NULL) {
@@ -819,6 +824,7 @@
 {
 	const struct dccp_hdr *dh;
 	struct sk_buff *skb = *pskb;
+	struct net *net = skb->dev->nd_net;
 	struct sock *sk;
 	int min_cov;
 
@@ -849,7 +855,7 @@
 	sk = __inet6_lookup(&dccp_hashinfo, &ipv6_hdr(skb)->saddr,
 			    dh->dccph_sport,
 			    &ipv6_hdr(skb)->daddr, ntohs(dh->dccph_dport),
-			    inet6_iif(skb));
+			    inet6_iif(skb), net);
 	/*
 	 * Step 2:
 	 *	If no socket ...
@@ -937,6 +943,7 @@
 		return -EAFNOSUPPORT;
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 
 	if (np->sndflow) {
 		fl.fl6_flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;
diff -Nurb linux-2.6.22-590/net/dccp/probe.c linux-2.6.22-try2-netns/net/dccp/probe.c
--- linux-2.6.22-590/net/dccp/probe.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/dccp/probe.c	2007-12-19 22:49:18.000000000 -0500
@@ -30,6 +30,7 @@
 #include <linux/module.h>
 #include <linux/kfifo.h>
 #include <linux/vmalloc.h>
+#include <net/net_namespace.h>
 
 #include "dccp.h"
 #include "ccid.h"
@@ -168,7 +169,7 @@
 	if (IS_ERR(dccpw.fifo))
 		return PTR_ERR(dccpw.fifo);
 
-	if (!proc_net_fops_create(procname, S_IRUSR, &dccpprobe_fops))
+	if (!proc_net_fops_create(&init_net, procname, S_IRUSR, &dccpprobe_fops))
 		goto err0;
 
 	ret = register_jprobe(&dccp_send_probe);
@@ -178,7 +179,7 @@
 	pr_info("DCCP watch registered (port=%d)\n", port);
 	return 0;
 err1:
-	proc_net_remove(procname);
+	proc_net_remove(&init_net, procname);
 err0:
 	kfifo_free(dccpw.fifo);
 	return ret;
@@ -188,7 +189,7 @@
 static __exit void dccpprobe_exit(void)
 {
 	kfifo_free(dccpw.fifo);
-	proc_net_remove(procname);
+	proc_net_remove(&init_net, procname);
 	unregister_jprobe(&dccp_send_probe);
 
 }
diff -Nurb linux-2.6.22-590/net/decnet/af_decnet.c linux-2.6.22-try2-netns/net/decnet/af_decnet.c
--- linux-2.6.22-590/net/decnet/af_decnet.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/decnet/af_decnet.c	2007-12-19 22:49:18.000000000 -0500
@@ -131,6 +131,7 @@
 #include <net/neighbour.h>
 #include <net/dst.h>
 #include <net/fib_rules.h>
+#include <net/net_namespace.h>
 #include <net/dn.h>
 #include <net/dn_nsp.h>
 #include <net/dn_dev.h>
@@ -470,10 +471,10 @@
 	.obj_size		= sizeof(struct dn_sock),
 };
 
-static struct sock *dn_alloc_sock(struct socket *sock, gfp_t gfp)
+static struct sock *dn_alloc_sock(struct net *net, struct socket *sock, gfp_t gfp)
 {
 	struct dn_scp *scp;
-	struct sock *sk = sk_alloc(PF_DECnet, gfp, &dn_proto, 1);
+	struct sock *sk = sk_alloc(net, PF_DECnet, gfp, &dn_proto, 1);
 
 	if  (!sk)
 		goto out;
@@ -674,10 +675,13 @@
 
 
 
-static int dn_create(struct socket *sock, int protocol)
+static int dn_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	switch(sock->type) {
 		case SOCK_SEQPACKET:
 			if (protocol != DNPROTO_NSP)
@@ -690,7 +694,7 @@
 	}
 
 
-	if ((sk = dn_alloc_sock(sock, GFP_KERNEL)) == NULL)
+	if ((sk = dn_alloc_sock(net, sock, GFP_KERNEL)) == NULL)
 		return -ENOBUFS;
 
 	sk->sk_protocol = protocol;
@@ -747,7 +751,7 @@
 		if (dn_ntohs(saddr->sdn_nodeaddrl)) {
 			read_lock(&dev_base_lock);
 			ldev = NULL;
-			for_each_netdev(dev) {
+			for_each_netdev(&init_net, dev) {
 				if (!dev->dn_ptr)
 					continue;
 				if (dn_dev_islocal(dev, dn_saddr2dn(saddr))) {
@@ -943,6 +947,7 @@
 
 	err = -EHOSTUNREACH;
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	fl.oif = sk->sk_bound_dev_if;
 	fl.fld_dst = dn_saddr2dn(&scp->peer);
 	fl.fld_src = dn_saddr2dn(&scp->addr);
@@ -1090,7 +1095,7 @@
 
 	cb = DN_SKB_CB(skb);
 	sk->sk_ack_backlog--;
-	newsk = dn_alloc_sock(newsock, sk->sk_allocation);
+	newsk = dn_alloc_sock(sk->sk_net, newsock, sk->sk_allocation);
 	if (newsk == NULL) {
 		release_sock(sk);
 		kfree_skb(skb);
@@ -2085,6 +2090,9 @@
 {
 	struct net_device *dev = (struct net_device *)ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	switch(event) {
 		case NETDEV_UP:
 			dn_dev_up(dev);
@@ -2399,7 +2407,7 @@
 	dev_add_pack(&dn_dix_packet_type);
 	register_netdevice_notifier(&dn_dev_notifier);
 
-	proc_net_fops_create("decnet", S_IRUGO, &dn_socket_seq_fops);
+	proc_net_fops_create(&init_net, "decnet", S_IRUGO, &dn_socket_seq_fops);
 	dn_register_sysctl();
 out:
 	return rc;
@@ -2428,7 +2436,7 @@
 	dn_neigh_cleanup();
 	dn_fib_cleanup();
 
-	proc_net_remove("decnet");
+	proc_net_remove(&init_net, "decnet");
 
 	proto_unregister(&dn_proto);
 }
diff -Nurb linux-2.6.22-590/net/decnet/dn_dev.c linux-2.6.22-try2-netns/net/decnet/dn_dev.c
--- linux-2.6.22-590/net/decnet/dn_dev.c	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/net/decnet/dn_dev.c	2007-12-19 22:49:18.000000000 -0500
@@ -47,6 +47,7 @@
 #include <net/flow.h>
 #include <net/fib_rules.h>
 #include <net/netlink.h>
+#include <net/net_namespace.h>
 #include <net/dn.h>
 #include <net/dn_dev.h>
 #include <net/dn_route.h>
@@ -513,7 +514,7 @@
 	ifr->ifr_name[IFNAMSIZ-1] = 0;
 
 #ifdef CONFIG_KMOD
-	dev_load(ifr->ifr_name);
+	dev_load(&init_net, ifr->ifr_name);
 #endif
 
 	switch(cmd) {
@@ -531,7 +532,7 @@
 
 	rtnl_lock();
 
-	if ((dev = __dev_get_by_name(ifr->ifr_name)) == NULL) {
+	if ((dev = __dev_get_by_name(&init_net, ifr->ifr_name)) == NULL) {
 		ret = -ENODEV;
 		goto done;
 	}
@@ -629,7 +630,7 @@
 {
 	struct net_device *dev;
 	struct dn_dev *dn_dev = NULL;
-	dev = dev_get_by_index(ifindex);
+	dev = dev_get_by_index(&init_net, ifindex);
 	if (dev) {
 		dn_dev = dev->dn_ptr;
 		dev_put(dev);
@@ -647,12 +648,16 @@
 
 static int dn_nl_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct nlattr *tb[IFA_MAX+1];
 	struct dn_dev *dn_db;
 	struct ifaddrmsg *ifm;
 	struct dn_ifaddr *ifa, **ifap;
 	int err = -EADDRNOTAVAIL;
 
+	if (net != &init_net)
+		goto errout;
+
 	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, dn_ifa_policy);
 	if (err < 0)
 		goto errout;
@@ -679,6 +684,7 @@
 
 static int dn_nl_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct nlattr *tb[IFA_MAX+1];
 	struct net_device *dev;
 	struct dn_dev *dn_db;
@@ -686,6 +692,9 @@
 	struct dn_ifaddr *ifa;
 	int err;
 
+	if (net != &init_net)
+		return -EINVAL;
+
 	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, dn_ifa_policy);
 	if (err < 0)
 		return err;
@@ -694,7 +703,7 @@
 		return -EINVAL;
 
 	ifm = nlmsg_data(nlh);
-	if ((dev = __dev_get_by_index(ifm->ifa_index)) == NULL)
+	if ((dev = __dev_get_by_index(&init_net, ifm->ifa_index)) == NULL)
 		return -ENODEV;
 
 	if ((dn_db = dev->dn_ptr) == NULL) {
@@ -783,24 +792,28 @@
 		kfree_skb(skb);
 		goto errout;
 	}
-	err = rtnl_notify(skb, 0, RTNLGRP_DECnet_IFADDR, NULL, GFP_KERNEL);
+	err = rtnl_notify(skb, &init_net, 0, RTNLGRP_DECnet_IFADDR, NULL, GFP_KERNEL);
 errout:
 	if (err < 0)
-		rtnl_set_sk_err(RTNLGRP_DECnet_IFADDR, err);
+		rtnl_set_sk_err(&init_net, RTNLGRP_DECnet_IFADDR, err);
 }
 
 static int dn_nl_dump_ifaddr(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	int idx, dn_idx = 0, skip_ndevs, skip_naddr;
 	struct net_device *dev;
 	struct dn_dev *dn_db;
 	struct dn_ifaddr *ifa;
 
+	if (net != &init_net)
+		return 0;
+
 	skip_ndevs = cb->args[0];
 	skip_naddr = cb->args[1];
 
 	idx = 0;
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if (idx < skip_ndevs)
 			goto cont;
 		else if (idx > skip_ndevs) {
@@ -869,10 +882,10 @@
 		rv = dn_dev_get_first(dev, addr);
 		read_unlock(&dev_base_lock);
 		dev_put(dev);
-		if (rv == 0 || dev == &loopback_dev)
+		if (rv == 0 || dev == &init_net.loopback_dev)
 			return rv;
 	}
-	dev = &loopback_dev;
+	dev = &init_net.loopback_dev;
 	dev_hold(dev);
 	goto last_chance;
 }
@@ -1299,7 +1312,7 @@
 	struct net_device *dev;
 
 	rtnl_lock();
-	for_each_netdev(dev)
+	for_each_netdev(&init_net, dev)
 		dn_dev_down(dev);
 	rtnl_unlock();
 
@@ -1310,7 +1323,7 @@
 	struct net_device *dev;
 
 	rtnl_lock();
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if (dev->flags & IFF_UP)
 			dn_dev_up(dev);
 	}
@@ -1344,7 +1357,7 @@
 		return SEQ_START_TOKEN;
 
 	i = 1;
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if (!is_dn_dev(dev))
 			continue;
 
@@ -1363,9 +1376,9 @@
 
 	dev = (struct net_device *)v;
 	if (v == SEQ_START_TOKEN)
-		dev = net_device_entry(&dev_base_head);
+		dev = net_device_entry(&init_net.dev_base_head);
 
-	for_each_netdev_continue(dev) {
+	for_each_netdev_continue(&init_net, dev) {
 		if (!is_dn_dev(dev))
 			continue;
 
@@ -1465,7 +1478,7 @@
 	rtnl_register(PF_DECnet, RTM_DELADDR, dn_nl_deladdr, NULL);
 	rtnl_register(PF_DECnet, RTM_GETADDR, NULL, dn_nl_dump_ifaddr);
 
-	proc_net_fops_create("decnet_dev", S_IRUGO, &dn_dev_seq_fops);
+	proc_net_fops_create(&init_net, "decnet_dev", S_IRUGO, &dn_dev_seq_fops);
 
 #ifdef CONFIG_SYSCTL
 	{
@@ -1486,7 +1499,7 @@
 	}
 #endif /* CONFIG_SYSCTL */
 
-	proc_net_remove("decnet_dev");
+	proc_net_remove(&init_net, "decnet_dev");
 
 	dn_dev_devices_off();
 }
diff -Nurb linux-2.6.22-590/net/decnet/dn_fib.c linux-2.6.22-try2-netns/net/decnet/dn_fib.c
--- linux-2.6.22-590/net/decnet/dn_fib.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/decnet/dn_fib.c	2007-12-19 22:49:18.000000000 -0500
@@ -203,8 +203,6 @@
 		struct flowi fl;
 		struct dn_fib_res res;
 
-		memset(&fl, 0, sizeof(fl));
-
 		if (nh->nh_flags&RTNH_F_ONLINK) {
 			struct net_device *dev;
 
@@ -212,7 +210,7 @@
 				return -EINVAL;
 			if (dnet_addr_type(nh->nh_gw) != RTN_UNICAST)
 				return -EINVAL;
-			if ((dev = __dev_get_by_index(nh->nh_oif)) == NULL)
+			if ((dev = __dev_get_by_index(&init_net, nh->nh_oif)) == NULL)
 				return -ENODEV;
 			if (!(dev->flags&IFF_UP))
 				return -ENETDOWN;
@@ -223,6 +221,7 @@
 		}
 
 		memset(&fl, 0, sizeof(fl));
+		fl.fl_net = &init_net;
 		fl.fld_dst = nh->nh_gw;
 		fl.oif = nh->nh_oif;
 		fl.fld_scope = r->rtm_scope + 1;
@@ -255,7 +254,7 @@
 		if (nh->nh_flags&(RTNH_F_PERVASIVE|RTNH_F_ONLINK))
 			return -EINVAL;
 
-		dev = __dev_get_by_index(nh->nh_oif);
+		dev = __dev_get_by_index(&init_net, nh->nh_oif);
 		if (dev == NULL || dev->dn_ptr == NULL)
 			return -ENODEV;
 		if (!(dev->flags&IFF_UP))
@@ -355,7 +354,7 @@
 		if (nhs != 1 || nh->nh_gw)
 			goto err_inval;
 		nh->nh_scope = RT_SCOPE_NOWHERE;
-		nh->nh_dev = dev_get_by_index(fi->fib_nh->nh_oif);
+		nh->nh_dev = dev_get_by_index(&init_net, fi->fib_nh->nh_oif);
 		err = -ENODEV;
 		if (nh->nh_dev == NULL)
 			goto failure;
@@ -506,10 +505,14 @@
 
 static int dn_fib_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct dn_fib_table *tb;
 	struct rtattr **rta = arg;
 	struct rtmsg *r = NLMSG_DATA(nlh);
 
+	if (net != &init_net)
+		return -EINVAL;
+
 	if (dn_fib_check_attr(r, rta))
 		return -EINVAL;
 
@@ -522,10 +525,14 @@
 
 static int dn_fib_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct dn_fib_table *tb;
 	struct rtattr **rta = arg;
 	struct rtmsg *r = NLMSG_DATA(nlh);
 
+	if (net != &init_net)
+		return -EINVAL;
+
 	if (dn_fib_check_attr(r, rta))
 		return -EINVAL;
 
@@ -602,7 +609,7 @@
 
 	/* Scan device list */
 	read_lock(&dev_base_lock);
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		dn_db = dev->dn_ptr;
 		if (dn_db == NULL)
 			continue;
diff -Nurb linux-2.6.22-590/net/decnet/dn_neigh.c linux-2.6.22-try2-netns/net/decnet/dn_neigh.c
--- linux-2.6.22-590/net/decnet/dn_neigh.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/decnet/dn_neigh.c	2007-12-19 22:49:18.000000000 -0500
@@ -38,6 +38,7 @@
 #include <linux/rcupdate.h>
 #include <linux/jhash.h>
 #include <asm/atomic.h>
+#include <net/net_namespace.h>
 #include <net/neighbour.h>
 #include <net/dst.h>
 #include <net/flow.h>
@@ -591,6 +592,7 @@
 
 	seq          = file->private_data;
 	seq->private = s;
+	s->net = get_net(PROC_NET(inode));
 out:
 	return rc;
 out_kfree:
@@ -598,12 +600,20 @@
 	goto out;
 }
 
+static int dn_neigh_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct neigh_seq_state *state = seq->private;
+	put_net(state->net);
+	return seq_release_private(inode, file);
+}
+
 static const struct file_operations dn_neigh_seq_fops = {
 	.owner		= THIS_MODULE,
 	.open		= dn_neigh_seq_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
-	.release	= seq_release_private,
+	.release	= dn_neigh_seq_release,
 };
 
 #endif
@@ -611,11 +621,11 @@
 void __init dn_neigh_init(void)
 {
 	neigh_table_init(&dn_neigh_table);
-	proc_net_fops_create("decnet_neigh", S_IRUGO, &dn_neigh_seq_fops);
+	proc_net_fops_create(&init_net, "decnet_neigh", S_IRUGO, &dn_neigh_seq_fops);
 }
 
 void __exit dn_neigh_cleanup(void)
 {
-	proc_net_remove("decnet_neigh");
+	proc_net_remove(&init_net, "decnet_neigh");
 	neigh_table_clear(&dn_neigh_table);
 }
diff -Nurb linux-2.6.22-590/net/decnet/dn_nsp_out.c linux-2.6.22-try2-netns/net/decnet/dn_nsp_out.c
--- linux-2.6.22-590/net/decnet/dn_nsp_out.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/decnet/dn_nsp_out.c	2007-12-19 22:49:18.000000000 -0500
@@ -91,6 +91,7 @@
 	}
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	fl.oif = sk->sk_bound_dev_if;
 	fl.fld_src = dn_saddr2dn(&scp->addr);
 	fl.fld_dst = dn_saddr2dn(&scp->peer);
diff -Nurb linux-2.6.22-590/net/decnet/dn_route.c linux-2.6.22-try2-netns/net/decnet/dn_route.c
--- linux-2.6.22-590/net/decnet/dn_route.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/decnet/dn_route.c	2007-12-19 22:49:18.000000000 -0500
@@ -82,6 +82,7 @@
 #include <net/dst.h>
 #include <net/flow.h>
 #include <net/fib_rules.h>
+#include <net/net_namespace.h>
 #include <net/dn.h>
 #include <net/dn_dev.h>
 #include <net/dn_nsp.h>
@@ -583,6 +584,9 @@
 	struct dn_dev *dn = (struct dn_dev *)dev->dn_ptr;
 	unsigned char padlen = 0;
 
+	if (dev->nd_net != &init_net)
+		goto dump_it;
+
 	if (dn == NULL)
 		goto dump_it;
 
@@ -877,13 +881,14 @@
 
 static int dn_route_output_slow(struct dst_entry **pprt, const struct flowi *oldflp, int try_hard)
 {
-	struct flowi fl = { .nl_u = { .dn_u =
+	struct flowi fl = { .fl_net = &init_net,
+			    .nl_u = { .dn_u =
 				      { .daddr = oldflp->fld_dst,
 					.saddr = oldflp->fld_src,
 					.scope = RT_SCOPE_UNIVERSE,
 				     } },
 			    .mark = oldflp->mark,
-			    .iif = loopback_dev.ifindex,
+			    .iif = init_net.loopback_dev.ifindex,
 			    .oif = oldflp->oif };
 	struct dn_route *rt = NULL;
 	struct net_device *dev_out = NULL, *dev;
@@ -900,11 +905,11 @@
 		       "dn_route_output_slow: dst=%04x src=%04x mark=%d"
 		       " iif=%d oif=%d\n", dn_ntohs(oldflp->fld_dst),
 		       dn_ntohs(oldflp->fld_src),
-		       oldflp->mark, loopback_dev.ifindex, oldflp->oif);
+		       oldflp->mark, init_net.loopback_dev.ifindex, oldflp->oif);
 
 	/* If we have an output interface, verify its a DECnet device */
 	if (oldflp->oif) {
-		dev_out = dev_get_by_index(oldflp->oif);
+		dev_out = dev_get_by_index(&init_net, oldflp->oif);
 		err = -ENODEV;
 		if (dev_out && dev_out->dn_ptr == NULL) {
 			dev_put(dev_out);
@@ -925,7 +930,7 @@
 			goto out;
 		}
 		read_lock(&dev_base_lock);
-		for_each_netdev(dev) {
+		for_each_netdev(&init_net, dev) {
 			if (!dev->dn_ptr)
 				continue;
 			if (!dn_dev_islocal(dev, oldflp->fld_src))
@@ -953,7 +958,7 @@
 		err = -EADDRNOTAVAIL;
 		if (dev_out)
 			dev_put(dev_out);
-		dev_out = &loopback_dev;
+		dev_out = &init_net.loopback_dev;
 		dev_hold(dev_out);
 		if (!fl.fld_dst) {
 			fl.fld_dst =
@@ -962,7 +967,7 @@
 			if (!fl.fld_dst)
 				goto out;
 		}
-		fl.oif = loopback_dev.ifindex;
+		fl.oif = init_net.loopback_dev.ifindex;
 		res.type = RTN_LOCAL;
 		goto make_route;
 	}
@@ -995,7 +1000,7 @@
 		 * here
 		 */
 		if (!try_hard) {
-			neigh = neigh_lookup_nodev(&dn_neigh_table, &fl.fld_dst);
+			neigh = neigh_lookup_nodev(&dn_neigh_table, &init_net, &fl.fld_dst);
 			if (neigh) {
 				if ((oldflp->oif &&
 				    (neigh->dev->ifindex != oldflp->oif)) ||
@@ -1008,7 +1013,7 @@
 					if (dev_out)
 						dev_put(dev_out);
 					if (dn_dev_islocal(neigh->dev, fl.fld_dst)) {
-						dev_out = &loopback_dev;
+						dev_out = &init_net.loopback_dev;
 						res.type = RTN_LOCAL;
 					} else {
 						dev_out = neigh->dev;
@@ -1029,7 +1034,7 @@
 		/* Possible improvement - check all devices for local addr */
 		if (dn_dev_islocal(dev_out, fl.fld_dst)) {
 			dev_put(dev_out);
-			dev_out = &loopback_dev;
+			dev_out = &init_net.loopback_dev;
 			dev_hold(dev_out);
 			res.type = RTN_LOCAL;
 			goto select_source;
@@ -1065,7 +1070,7 @@
 			fl.fld_src = fl.fld_dst;
 		if (dev_out)
 			dev_put(dev_out);
-		dev_out = &loopback_dev;
+		dev_out = &init_net.loopback_dev;
 		dev_hold(dev_out);
 		fl.oif = dev_out->ifindex;
 		if (res.fi)
@@ -1103,6 +1108,7 @@
 	atomic_set(&rt->u.dst.__refcnt, 1);
 	rt->u.dst.flags   = DST_HOST;
 
+	rt->fl.fl_net     = &init_net;
 	rt->fl.fld_src    = oldflp->fld_src;
 	rt->fl.fld_dst    = oldflp->fld_dst;
 	rt->fl.oif        = oldflp->oif;
@@ -1226,7 +1232,8 @@
 	int flags = 0;
 	__le16 gateway = 0;
 	__le16 local_src = 0;
-	struct flowi fl = { .nl_u = { .dn_u =
+	struct flowi fl = { .fl_net = &init_net,
+			    .nl_u = { .dn_u = 
 				     { .daddr = cb->dst,
 				       .saddr = cb->src,
 				       .scope = RT_SCOPE_UNIVERSE,
@@ -1374,6 +1381,7 @@
 	rt->rt_dst_map    = fl.fld_dst;
 	rt->rt_src_map    = fl.fld_src;
 
+	rt->fl.fl_net     = &init_net;
 	rt->fl.fld_src    = cb->src;
 	rt->fl.fld_dst    = cb->dst;
 	rt->fl.oif        = 0;
@@ -1526,6 +1534,7 @@
  */
 static int dn_cache_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = in_skb->sk->sk_net;
 	struct rtattr **rta = arg;
 	struct rtmsg *rtm = NLMSG_DATA(nlh);
 	struct dn_route *rt = NULL;
@@ -1534,7 +1543,11 @@
 	struct sk_buff *skb;
 	struct flowi fl;
 
+	if (net != &init_net)
+		return -EINVAL;
+
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	fl.proto = DNPROTO_NSP;
 
 	skb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);
@@ -1552,7 +1565,7 @@
 
 	if (fl.iif) {
 		struct net_device *dev;
-		if ((dev = dev_get_by_index(fl.iif)) == NULL) {
+		if ((dev = dev_get_by_index(&init_net, fl.iif)) == NULL) {
 			kfree_skb(skb);
 			return -ENODEV;
 		}
@@ -1598,7 +1611,7 @@
 		goto out_free;
 	}
 
-	return rtnl_unicast(skb, NETLINK_CB(in_skb).pid);
+	return rtnl_unicast(skb, &init_net, NETLINK_CB(in_skb).pid);
 
 out_free:
 	kfree_skb(skb);
@@ -1611,10 +1624,14 @@
  */
 int dn_cache_dump(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	struct dn_route *rt;
 	int h, s_h;
 	int idx, s_idx;
 
+	if (net != &init_net)
+		return 0;
+
 	if (NLMSG_PAYLOAD(cb->nlh, 0) < sizeof(struct rtmsg))
 		return -EINVAL;
 	if (!(((struct rtmsg *)NLMSG_DATA(cb->nlh))->rtm_flags&RTM_F_CLONED))
@@ -1814,7 +1831,7 @@
 
 	dn_dst_ops.gc_thresh = (dn_rt_hash_mask + 1);
 
-	proc_net_fops_create("decnet_cache", S_IRUGO, &dn_rt_cache_seq_fops);
+	proc_net_fops_create(&init_net, "decnet_cache", S_IRUGO, &dn_rt_cache_seq_fops);
 
 #ifdef CONFIG_DECNET_ROUTER
 	rtnl_register(PF_DECnet, RTM_GETROUTE, dn_cache_getroute, dn_fib_dump);
@@ -1829,6 +1846,6 @@
 	del_timer(&dn_route_timer);
 	dn_run_flush(0);
 
-	proc_net_remove("decnet_cache");
+	proc_net_remove(&init_net, "decnet_cache");
 }
 
diff -Nurb linux-2.6.22-590/net/decnet/dn_rules.c linux-2.6.22-try2-netns/net/decnet/dn_rules.c
--- linux-2.6.22-590/net/decnet/dn_rules.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/decnet/dn_rules.c	2007-12-19 22:49:18.000000000 -0500
@@ -186,7 +186,10 @@
 
 unsigned dnet_addr_type(__le16 addr)
 {
-	struct flowi fl = { .nl_u = { .dn_u = { .daddr = addr } } };
+	struct flowi fl = { 
+		.fl_net = &init_net,
+		.nl_u = { .dn_u = { .daddr = addr } } 
+	};
 	struct dn_fib_res res;
 	unsigned ret = RTN_UNICAST;
 	struct dn_fib_table *tb = dn_fib_get_table(RT_TABLE_LOCAL, 0);
@@ -223,7 +226,7 @@
 	return -ENOBUFS;
 }
 
-static u32 dn_fib_rule_default_pref(void)
+static u32 dn_fib_rule_default_pref(struct fib_rules_ops *ops)
 {
 	struct list_head *pos;
 	struct fib_rule *rule;
@@ -240,7 +243,7 @@
 	return 0;
 }
 
-static void dn_fib_rule_flush_cache(void)
+static void dn_fib_rule_flush_cache(struct fib_rules_ops *ops)
 {
 	dn_rt_cache_flush(-1);
 }
@@ -265,12 +268,12 @@
 void __init dn_fib_rules_init(void)
 {
 	list_add_tail(&default_rule.common.list, &dn_fib_rules);
-	fib_rules_register(&dn_fib_rules_ops);
+	fib_rules_register(&init_net, &dn_fib_rules_ops);
 }
 
 void __exit dn_fib_rules_cleanup(void)
 {
-	fib_rules_unregister(&dn_fib_rules_ops);
+	fib_rules_unregister(&init_net, &dn_fib_rules_ops);
 }
 
 
diff -Nurb linux-2.6.22-590/net/decnet/dn_table.c linux-2.6.22-try2-netns/net/decnet/dn_table.c
--- linux-2.6.22-590/net/decnet/dn_table.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/decnet/dn_table.c	2007-12-19 22:49:18.000000000 -0500
@@ -375,10 +375,10 @@
 		kfree_skb(skb);
 		goto errout;
 	}
-	err = rtnl_notify(skb, pid, RTNLGRP_DECnet_ROUTE, nlh, GFP_KERNEL);
+	err = rtnl_notify(skb, &init_net, pid, RTNLGRP_DECnet_ROUTE, nlh, GFP_KERNEL);
 errout:
 	if (err < 0)
-		rtnl_set_sk_err(RTNLGRP_DECnet_ROUTE, err);
+		rtnl_set_sk_err(&init_net, RTNLGRP_DECnet_ROUTE, err);
 }
 
 static __inline__ int dn_hash_dump_bucket(struct sk_buff *skb,
@@ -463,12 +463,16 @@
 
 int dn_fib_dump(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	unsigned int h, s_h;
 	unsigned int e = 0, s_e;
 	struct dn_fib_table *tb;
 	struct hlist_node *node;
 	int dumped = 0;
 
+	if (net != &init_net)
+		return 0;
+
 	if (NLMSG_PAYLOAD(cb->nlh, 0) >= sizeof(struct rtmsg) &&
 		((struct rtmsg *)NLMSG_DATA(cb->nlh))->rtm_flags&RTM_F_CLONED)
 			return dn_cache_dump(skb, cb);
diff -Nurb linux-2.6.22-590/net/decnet/netfilter/dn_rtmsg.c linux-2.6.22-try2-netns/net/decnet/netfilter/dn_rtmsg.c
--- linux-2.6.22-590/net/decnet/netfilter/dn_rtmsg.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/decnet/netfilter/dn_rtmsg.c	2007-12-19 22:49:18.000000000 -0500
@@ -93,6 +93,10 @@
 			const struct net_device *out,
 			int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	dnrmg_send_peer(*pskb);
 	return NF_ACCEPT;
 }
@@ -137,7 +141,8 @@
 {
 	int rv = 0;
 
-	dnrmg = netlink_kernel_create(NETLINK_DNRTMSG, DNRNG_NLGRP_MAX,
+	dnrmg = netlink_kernel_create(&init_net,
+				      NETLINK_DNRTMSG, DNRNG_NLGRP_MAX,
 				      dnrmg_receive_user_sk, NULL, THIS_MODULE);
 	if (dnrmg == NULL) {
 		printk(KERN_ERR "dn_rtmsg: Cannot create netlink socket");
diff -Nurb linux-2.6.22-590/net/decnet/sysctl_net_decnet.c linux-2.6.22-try2-netns/net/decnet/sysctl_net_decnet.c
--- linux-2.6.22-590/net/decnet/sysctl_net_decnet.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/decnet/sysctl_net_decnet.c	2007-12-19 22:49:18.000000000 -0500
@@ -259,7 +259,7 @@
 
 		devname[newlen] = 0;
 
-		dev = dev_get_by_name(devname);
+		dev = dev_get_by_name(&init_net, devname);
 		if (dev == NULL)
 			return -ENODEV;
 
@@ -299,7 +299,7 @@
 		devname[*lenp] = 0;
 		strip_it(devname);
 
-		dev = dev_get_by_name(devname);
+		dev = dev_get_by_name(&init_net, devname);
 		if (dev == NULL)
 			return -ENODEV;
 
diff -Nurb linux-2.6.22-590/net/econet/af_econet.c linux-2.6.22-try2-netns/net/econet/af_econet.c
--- linux-2.6.22-590/net/econet/af_econet.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/econet/af_econet.c	2007-12-19 22:49:18.000000000 -0500
@@ -608,12 +608,15 @@
  *	Create an Econet socket
  */
 
-static int econet_create(struct socket *sock, int protocol)
+static int econet_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 	struct econet_sock *eo;
 	int err;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	/* Econet only provides datagram services. */
 	if (sock->type != SOCK_DGRAM)
 		return -ESOCKTNOSUPPORT;
@@ -621,7 +624,7 @@
 	sock->state = SS_UNCONNECTED;
 
 	err = -ENOBUFS;
-	sk = sk_alloc(PF_ECONET, GFP_KERNEL, &econet_proto, 1);
+	sk = sk_alloc(net, PF_ECONET, GFP_KERNEL, &econet_proto, 1);
 	if (sk == NULL)
 		goto out;
 
@@ -659,7 +662,7 @@
 	if (copy_from_user(&ifr, arg, sizeof(struct ifreq)))
 		return -EFAULT;
 
-	if ((dev = dev_get_by_name(ifr.ifr_name)) == NULL)
+	if ((dev = dev_get_by_name(&init_net, ifr.ifr_name)) == NULL)
 		return -ENODEV;
 
 	sec = (struct sockaddr_ec *)&ifr.ifr_addr;
@@ -1062,6 +1065,9 @@
 	struct sock *sk;
 	struct ec_device *edev = dev->ec_ptr;
 
+	if (dev->nd_net != &init_net)
+		goto drop;
+
 	if (skb->pkt_type == PACKET_OTHERHOST)
 		goto drop;
 
@@ -1116,6 +1122,9 @@
 	struct net_device *dev = (struct net_device *)data;
 	struct ec_device *edev;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	switch (msg) {
 	case NETDEV_UNREGISTER:
 		/* A device has gone down - kill any data we hold for it. */
diff -Nurb linux-2.6.22-590/net/ieee80211/ieee80211_module.c linux-2.6.22-try2-netns/net/ieee80211/ieee80211_module.c
--- linux-2.6.22-590/net/ieee80211/ieee80211_module.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ieee80211/ieee80211_module.c	2007-12-19 22:49:18.000000000 -0500
@@ -264,7 +264,7 @@
 	struct proc_dir_entry *e;
 
 	ieee80211_debug_level = debug;
-	ieee80211_proc = proc_mkdir(DRV_NAME, proc_net);
+	ieee80211_proc = proc_mkdir(DRV_NAME, init_net.proc_net);
 	if (ieee80211_proc == NULL) {
 		IEEE80211_ERROR("Unable to create " DRV_NAME
 				" proc directory\n");
@@ -273,7 +273,7 @@
 	e = create_proc_entry("debug_level", S_IFREG | S_IRUGO | S_IWUSR,
 			      ieee80211_proc);
 	if (!e) {
-		remove_proc_entry(DRV_NAME, proc_net);
+		remove_proc_entry(DRV_NAME, init_net.proc_net);
 		ieee80211_proc = NULL;
 		return -EIO;
 	}
@@ -293,7 +293,7 @@
 #ifdef CONFIG_IEEE80211_DEBUG
 	if (ieee80211_proc) {
 		remove_proc_entry("debug_level", ieee80211_proc);
-		remove_proc_entry(DRV_NAME, proc_net);
+		remove_proc_entry(DRV_NAME, init_net.proc_net);
 		ieee80211_proc = NULL;
 	}
 #endif				/* CONFIG_IEEE80211_DEBUG */
diff -Nurb linux-2.6.22-590/net/ipv4/af_inet.c linux-2.6.22-try2-netns/net/ipv4/af_inet.c
--- linux-2.6.22-590/net/ipv4/af_inet.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/af_inet.c	2007-12-19 23:20:19.000000000 -0500
@@ -244,7 +244,7 @@
  *	Create an inet socket.
  */
 
-static int inet_create(struct socket *sock, int protocol)
+static int inet_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 	struct list_head *p;
@@ -310,6 +310,10 @@
 			goto out_rcu_unlock;
 	}
 
+	err = -EPROTONOSUPPORT;
+	if (!(answer->flags & INET_PROTOSW_NETNS) && (net != &init_net))
+		goto out_rcu_unlock;
+
 	err = -EPERM;
 	if ((protocol == IPPROTO_ICMP) &&
 		nx_capable(answer->capability, NXC_RAW_ICMP))
@@ -326,7 +330,7 @@
 	BUG_TRAP(answer_prot->slab != NULL);
 
 	err = -ENOBUFS;
-	sk = sk_alloc(PF_INET, GFP_KERNEL, answer_prot, 1);
+	sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, 1);
 	if (sk == NULL)
 		goto out;
 
@@ -344,7 +348,7 @@
 			inet->hdrincl = 1;
 	}
 
-	if (ipv4_config.no_pmtu_disc)
+	if (net->sysctl_ipv4_no_pmtu_disc)
 		inet->pmtudisc = IP_PMTUDISC_DONT;
 	else
 		inet->pmtudisc = IP_PMTUDISC_WANT;
@@ -423,12 +427,12 @@
 }
 
 /* It is off by default, see below. */
-int sysctl_ip_nonlocal_bind __read_mostly;
 
 int inet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 {
 	struct sockaddr_in *addr = (struct sockaddr_in *)uaddr;
 	struct sock *sk = sock->sk;
+	struct net *net = sk->sk_net;
 	struct inet_sock *inet = inet_sk(sk);
 	struct nx_v4_sock_addr nsa;
 	unsigned short snum;
@@ -448,7 +452,7 @@
 	if (err)
 		goto out;
 
-	chk_addr_ret = inet_addr_type(nsa.saddr);
+	chk_addr_ret = inet_addr_type(net, nsa.saddr);
 
 	/* Not specified by any standard per-se, however it breaks too
 	 * many applications when removed.  It is unfortunate since
@@ -458,7 +462,7 @@
 	 *  is temporarily down)
 	 */
 	err = -EADDRNOTAVAIL;
-	if (!sysctl_ip_nonlocal_bind &&
+	if (!net->sysctl_ip_nonlocal_bind &&
 	    !inet->freebind &&
 	    nsa.saddr != INADDR_ANY &&
 	    chk_addr_ret != RTN_LOCAL &&
@@ -787,6 +791,7 @@
 int inet_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
 {
 	struct sock *sk = sock->sk;
+	struct net *net = sk->sk_net;
 	int err = 0;
 
 	switch (cmd) {
@@ -799,12 +804,12 @@
 		case SIOCADDRT:
 		case SIOCDELRT:
 		case SIOCRTMSG:
-			err = ip_rt_ioctl(cmd, (void __user *)arg);
+			err = ip_rt_ioctl(net, cmd, (void __user *)arg);
 			break;
 		case SIOCDARP:
 		case SIOCGARP:
 		case SIOCSARP:
-			err = arp_ioctl(cmd, (void __user *)arg);
+			err = arp_ioctl(net, cmd, (void __user *)arg);
 			break;
 		case SIOCGIFADDR:
 		case SIOCSIFADDR:
@@ -817,7 +822,7 @@
 		case SIOCSIFPFLAGS:
 		case SIOCGIFPFLAGS:
 		case SIOCSIFFLAGS:
-			err = devinet_ioctl(cmd, (void __user *)arg);
+			err = devinet_ioctl(net, cmd, (void __user *)arg);
 			break;
 		default:
 			if (sk->sk_prot->ioctl)
@@ -927,7 +932,8 @@
 		.capability = -1,
 		.no_check =   0,
 		.flags =      INET_PROTOSW_PERMANENT |
-			      INET_PROTOSW_ICSK,
+			      INET_PROTOSW_ICSK |
+			      INET_PROTOSW_NETNS,
 	},
 
 	{
@@ -937,7 +943,8 @@
 		.ops =        &inet_dgram_ops,
 		.capability = -1,
 		.no_check =   UDP_CSUM_DEFAULT,
-		.flags =      INET_PROTOSW_PERMANENT,
+		.flags =      INET_PROTOSW_PERMANENT |
+			      INET_PROTOSW_NETNS,
        },
 
 
@@ -948,7 +955,8 @@
 	       .ops =        &inet_sockraw_ops,
 	       .capability = CAP_NET_RAW,
 	       .no_check =   UDP_CSUM_DEFAULT,
-	       .flags =      INET_PROTOSW_REUSE,
+	       .flags =      INET_PROTOSW_REUSE |
+			     INET_PROTOSW_NETNS,
        }
 };
 
@@ -1029,8 +1037,6 @@
  *      Shall we try to damage output packets if routing dev changes?
  */
 
-int sysctl_ip_dynaddr __read_mostly;
-
 static int inet_sk_reselect_saddr(struct sock *sk)
 {
 	struct inet_sock *inet = inet_sk(sk);
@@ -1059,7 +1065,7 @@
 	if (new_saddr == old_saddr)
 		return 0;
 
-	if (sysctl_ip_dynaddr > 1) {
+	if (sk->sk_net->sysctl_ip_dynaddr > 1) {
 		printk(KERN_INFO "%s(): shifting inet->"
 				 "saddr from %d.%d.%d.%d to %d.%d.%d.%d\n",
 		       __FUNCTION__,
@@ -1098,6 +1104,7 @@
 		daddr = inet->opt->faddr;
 {
 	struct flowi fl = {
+		.fl_net = sk->sk_net,
 		.oif = sk->sk_bound_dev_if,
 		.nl_u = {
 			.ip4_u = {
@@ -1127,7 +1134,7 @@
 		 * Other protocols have to map its equivalent state to TCP_SYN_SENT.
 		 * DCCP maps its DCCP_REQUESTING state to TCP_SYN_SENT. -acme
 		 */
-		if (!sysctl_ip_dynaddr ||
+		if (!sk->sk_net->sysctl_ip_dynaddr ||
 		    sk->sk_state != TCP_SYN_SENT ||
 		    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||
 		    (err = inet_sk_reselect_saddr(sk)) != 0)
@@ -1356,6 +1363,24 @@
 	.gso_segment = inet_gso_segment,
 };
 
+
+static int inet_net_init(struct net *net)
+{
+	net->sysctl_ip_default_ttl = IPDEFTTL;
+	net->sysctl_ip_dynaddr = 0;
+
+	return 0;
+}
+
+static void inet_net_exit(struct net *net)
+{
+}
+
+static struct pernet_operations inet_net_ops = {
+	.init = inet_net_init,
+	.exit = inet_net_exit,
+};
+
 static int __init inet_init(void)
 {
 	struct sk_buff *dummy_skb;
@@ -1377,6 +1402,10 @@
 	if (rc)
 		goto out_unregister_udp_proto;
 
+	rc = register_pernet_subsys(&inet_net_ops);
+	if (rc)
+		goto out_unregister_raw_proto;
+
 	/*
 	 *	Tell SOCKET that we are alive...
 	 */
@@ -1453,6 +1482,8 @@
 	rc = 0;
 out:
 	return rc;
+out_unregister_raw_proto:
+	proto_unregister(&raw_prot);
 out_unregister_udp_proto:
 	proto_unregister(&udp_prot);
 out_unregister_tcp_proto:
@@ -1475,15 +1506,11 @@
 		goto out_tcp;
 	if (udp4_proc_init())
 		goto out_udp;
-	if (fib_proc_init())
-		goto out_fib;
 	if (ip_misc_proc_init())
 		goto out_misc;
 out:
 	return rc;
 out_misc:
-	fib_proc_exit();
-out_fib:
 	udp4_proc_exit();
 out_udp:
 	tcp4_proc_exit();
@@ -1519,4 +1546,3 @@
 EXPORT_SYMBOL(inet_stream_ops);
 EXPORT_SYMBOL(inet_unregister_protosw);
 EXPORT_SYMBOL(net_statistics);
-EXPORT_SYMBOL(sysctl_ip_nonlocal_bind);
diff -Nurb linux-2.6.22-590/net/ipv4/ah4.c linux-2.6.22-try2-netns/net/ipv4/ah4.c
--- linux-2.6.22-590/net/ipv4/ah4.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/ah4.c	2007-12-19 22:49:18.000000000 -0500
@@ -198,6 +198,9 @@
 	struct ip_auth_hdr *ah = (struct ip_auth_hdr*)(skb->data+(iph->ihl<<2));
 	struct xfrm_state *x;
 
+	if (skb->dev->nd_net != &init_net)
+		return;
+
 	if (icmp_hdr(skb)->type != ICMP_DEST_UNREACH ||
 	    icmp_hdr(skb)->code != ICMP_FRAG_NEEDED)
 		return;
diff -Nurb linux-2.6.22-590/net/ipv4/arp.c linux-2.6.22-try2-netns/net/ipv4/arp.c
--- linux-2.6.22-590/net/ipv4/arp.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/arp.c	2007-12-19 22:49:18.000000000 -0500
@@ -109,6 +109,7 @@
 #include <net/protocol.h>
 #include <net/tcp.h>
 #include <net/sock.h>
+#include <net/net_namespace.h>
 #include <net/arp.h>
 #if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
 #include <net/ax25.h>
@@ -235,10 +236,11 @@
 {
 	__be32 addr = *(__be32*)neigh->primary_key;
 	struct net_device *dev = neigh->dev;
+	struct net *net = dev->nd_net;
 	struct in_device *in_dev;
 	struct neigh_parms *parms;
 
-	neigh->type = inet_addr_type(addr);
+	neigh->type = inet_addr_type(net, addr);
 
 	rcu_read_lock();
 	in_dev = __in_dev_get_rcu(dev);
@@ -332,6 +334,7 @@
 	__be32 saddr = 0;
 	u8  *dst_ha = NULL;
 	struct net_device *dev = neigh->dev;
+	struct net *net = dev->nd_net;
 	__be32 target = *(__be32*)neigh->primary_key;
 	int probes = atomic_read(&neigh->probes);
 	struct in_device *in_dev = in_dev_get(dev);
@@ -342,14 +345,14 @@
 	switch (IN_DEV_ARP_ANNOUNCE(in_dev)) {
 	default:
 	case 0:		/* By default announce any local IP */
-		if (skb && inet_addr_type(ip_hdr(skb)->saddr) == RTN_LOCAL)
+		if (skb && inet_addr_type(net, ip_hdr(skb)->saddr) == RTN_LOCAL)
 			saddr = ip_hdr(skb)->saddr;
 		break;
 	case 1:		/* Restrict announcements of saddr in same subnet */
 		if (!skb)
 			break;
 		saddr = ip_hdr(skb)->saddr;
-		if (inet_addr_type(saddr) == RTN_LOCAL) {
+		if (inet_addr_type(net, saddr) == RTN_LOCAL) {
 			/* saddr should be known to target */
 			if (inet_addr_onlink(in_dev, target, saddr))
 				break;
@@ -386,6 +389,7 @@
 static int arp_ignore(struct in_device *in_dev, struct net_device *dev,
 		      __be32 sip, __be32 tip)
 {
+	struct net *net = dev->nd_net;
 	int scope;
 
 	switch (IN_DEV_ARP_IGNORE(in_dev)) {
@@ -416,13 +420,15 @@
 	default:
 		return 0;
 	}
-	return !inet_confirm_addr(dev, sip, tip, scope);
+	return !inet_confirm_addr(net, dev, sip, tip, scope);
 }
 
 static int arp_filter(__be32 sip, __be32 tip, struct net_device *dev)
 {
-	struct flowi fl = { .nl_u = { .ip4_u = { .daddr = sip,
-						 .saddr = tip } } };
+	struct flowi fl = {
+		.fl_net = dev->nd_net,
+		.nl_u = { .ip4_u = { .daddr = sip, .saddr = tip } }
+	};
 	struct rtable *rt;
 	int flag = 0;
 	/*unsigned long now; */
@@ -469,6 +475,7 @@
 int arp_find(unsigned char *haddr, struct sk_buff *skb)
 {
 	struct net_device *dev = skb->dev;
+	struct net *net = dev->nd_net;
 	__be32 paddr;
 	struct neighbour *n;
 
@@ -480,7 +487,7 @@
 
 	paddr = ((struct rtable*)skb->dst)->rt_gateway;
 
-	if (arp_set_predefined(inet_addr_type(paddr), haddr, paddr, dev))
+	if (arp_set_predefined(inet_addr_type(net, paddr), haddr, paddr, dev))
 		return 0;
 
 	n = __neigh_lookup(&arp_tbl, &paddr, dev, 1);
@@ -704,6 +711,7 @@
 static int arp_process(struct sk_buff *skb)
 {
 	struct net_device *dev = skb->dev;
+	struct net *net = dev->nd_net;
 	struct in_device *in_dev = in_dev_get(dev);
 	struct arphdr *arp;
 	unsigned char *arp_ptr;
@@ -824,7 +832,7 @@
 	/* Special case: IPv4 duplicate address detection packet (RFC2131) */
 	if (sip == 0) {
 		if (arp->ar_op == htons(ARPOP_REQUEST) &&
-		    inet_addr_type(tip) == RTN_LOCAL &&
+		    inet_addr_type(net, tip) == RTN_LOCAL &&
 		    !arp_ignore(in_dev,dev,sip,tip))
 			arp_send(ARPOP_REPLY,ETH_P_ARP,tip,dev,tip,sha,dev->dev_addr,dev->dev_addr);
 		goto out;
@@ -854,7 +862,7 @@
 		} else if (IN_DEV_FORWARD(in_dev)) {
 			if ((rt->rt_flags&RTCF_DNAT) ||
 			    (addr_type == RTN_UNICAST  && rt->u.dst.dev != dev &&
-			     (arp_fwd_proxy(in_dev, rt) || pneigh_lookup(&arp_tbl, &tip, dev, 0)))) {
+			     (arp_fwd_proxy(in_dev, rt) || pneigh_lookup(&arp_tbl, net, &tip, dev, 0)))) {
 				n = neigh_event_ns(&arp_tbl, sha, &sip, dev);
 				if (n)
 					neigh_release(n);
@@ -877,14 +885,14 @@
 
 	n = __neigh_lookup(&arp_tbl, &sip, dev, 0);
 
-	if (IPV4_DEVCONF_ALL(ARP_ACCEPT)) {
+	if (IPV4_DEVCONF_ALL(net, ARP_ACCEPT)) {
 		/* Unsolicited ARP is not accepted by default.
 		   It is possible, that this option should be enabled for some
 		   devices (strip is candidate)
 		 */
 		if (n == NULL &&
 		    arp->ar_op == htons(ARPOP_REPLY) &&
-		    inet_addr_type(sip) == RTN_UNICAST)
+		    inet_addr_type(net, sip) == RTN_UNICAST)
 			n = __neigh_lookup(&arp_tbl, &sip, dev, -1);
 	}
 
@@ -966,7 +974,7 @@
  *	Set (create) an ARP cache entry.
  */
 
-static int arp_req_set(struct arpreq *r, struct net_device * dev)
+static int arp_req_set(struct net *net, struct arpreq *r, struct net_device * dev)
 {
 	__be32 ip = ((struct sockaddr_in *) &r->arp_pa)->sin_addr.s_addr;
 	struct neighbour *neigh;
@@ -977,17 +985,17 @@
 		if (mask && mask != htonl(0xFFFFFFFF))
 			return -EINVAL;
 		if (!dev && (r->arp_flags & ATF_COM)) {
-			dev = dev_getbyhwaddr(r->arp_ha.sa_family, r->arp_ha.sa_data);
+			dev = dev_getbyhwaddr(net, r->arp_ha.sa_family, r->arp_ha.sa_data);
 			if (!dev)
 				return -ENODEV;
 		}
 		if (mask) {
-			if (pneigh_lookup(&arp_tbl, &ip, dev, 1) == NULL)
+			if (pneigh_lookup(&arp_tbl, net, &ip, dev, 1) == NULL)
 				return -ENOBUFS;
 			return 0;
 		}
 		if (dev == NULL) {
-			IPV4_DEVCONF_ALL(PROXY_ARP) = 1;
+			IPV4_DEVCONF_ALL(net, PROXY_ARP) = 1;
 			return 0;
 		}
 		if (__in_dev_get_rtnl(dev)) {
@@ -1000,8 +1008,10 @@
 	if (r->arp_flags & ATF_PERM)
 		r->arp_flags |= ATF_COM;
 	if (dev == NULL) {
-		struct flowi fl = { .nl_u = { .ip4_u = { .daddr = ip,
-							 .tos = RTO_ONLINK } } };
+		struct flowi fl = { 
+			.fl_net = net,
+			.nl_u = { .ip4_u = { .daddr = ip, .tos = RTO_ONLINK } }
+		};
 		struct rtable * rt;
 		if ((err = ip_route_output_key(&rt, &fl)) != 0)
 			return err;
@@ -1080,7 +1090,7 @@
 	return err;
 }
 
-static int arp_req_delete(struct arpreq *r, struct net_device * dev)
+static int arp_req_delete(struct net *net, struct arpreq *r, struct net_device * dev)
 {
 	int err;
 	__be32 ip = ((struct sockaddr_in *)&r->arp_pa)->sin_addr.s_addr;
@@ -1090,10 +1100,10 @@
 		__be32 mask =
 		       ((struct sockaddr_in *)&r->arp_netmask)->sin_addr.s_addr;
 		if (mask == htonl(0xFFFFFFFF))
-			return pneigh_delete(&arp_tbl, &ip, dev);
+			return pneigh_delete(&arp_tbl, net, &ip, dev);
 		if (mask == 0) {
 			if (dev == NULL) {
-				IPV4_DEVCONF_ALL(PROXY_ARP) = 0;
+				IPV4_DEVCONF_ALL(net, PROXY_ARP) = 0;
 				return 0;
 			}
 			if (__in_dev_get_rtnl(dev)) {
@@ -1107,8 +1117,10 @@
 	}
 
 	if (dev == NULL) {
-		struct flowi fl = { .nl_u = { .ip4_u = { .daddr = ip,
-							 .tos = RTO_ONLINK } } };
+		struct flowi fl = {
+			.fl_net = net,
+			.nl_u = { .ip4_u = { .daddr = ip, .tos = RTO_ONLINK } }
+		};
 		struct rtable * rt;
 		if ((err = ip_route_output_key(&rt, &fl)) != 0)
 			return err;
@@ -1133,7 +1145,7 @@
  *	Handle an ARP layer I/O control request.
  */
 
-int arp_ioctl(unsigned int cmd, void __user *arg)
+int arp_ioctl(struct net *net, unsigned int cmd, void __user *arg)
 {
 	int err;
 	struct arpreq r;
@@ -1165,7 +1177,7 @@
 	rtnl_lock();
 	if (r.arp_dev[0]) {
 		err = -ENODEV;
-		if ((dev = __dev_get_by_name(r.arp_dev)) == NULL)
+		if ((dev = __dev_get_by_name(net, r.arp_dev)) == NULL)
 			goto out;
 
 		/* Mmmm... It is wrong... ARPHRD_NETROM==0 */
@@ -1181,10 +1193,10 @@
 
 	switch (cmd) {
 	case SIOCDARP:
-		err = arp_req_delete(&r, dev);
+		err = arp_req_delete(net, &r, dev);
 		break;
 	case SIOCSARP:
-		err = arp_req_set(&r, dev);
+		err = arp_req_set(net, &r, dev);
 		break;
 	case SIOCGARP:
 		err = arp_req_get(&r, dev);
@@ -1201,6 +1213,9 @@
 {
 	struct net_device *dev = ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	switch (event) {
 	case NETDEV_CHANGEADDR:
 		neigh_changeaddr(&arp_tbl, dev);
@@ -1227,6 +1242,54 @@
 }
 
 
+static int arp_proc_init(struct net *net);
+static void arp_proc_exit(struct net *net);
+
+
+static int arp_net_init(struct net *net)
+{
+	int error;
+	if ((error = arp_proc_init(net)))
+		goto out_proc;
+
+	error = -ENOMEM;
+	net->arp_neigh_parms_default = neigh_parms_alloc_default(&arp_tbl, net);
+	if (!net->arp_neigh_parms_default)
+		goto out_parm;
+
+#ifdef CONFIG_SYSCTL
+	if ((error = neigh_sysctl_register(
+		     NULL, net->arp_neigh_parms_default,
+		     NET_IPV4, NET_IPV4_NEIGH, "ipv4", NULL, NULL)))
+		goto out_sysctl;
+#endif
+
+out:
+	return error;
+
+#ifdef CONFIG_SYSCTL
+out_sysctl:
+	neigh_parms_release(&arp_tbl, net->arp_neigh_parms_default);
+#endif
+out_parm:
+	arp_proc_exit(net);
+out_proc:
+	goto out;
+}
+
+static void arp_net_exit(struct net *net)
+{
+#ifdef CONFIG_SYSCTL
+	neigh_sysctl_unregister(net->arp_neigh_parms_default);
+#endif
+	neigh_parms_release(&arp_tbl, net->arp_neigh_parms_default);
+	arp_proc_exit(net);
+}
+
+static struct pernet_operations arp_net_ops = {
+	.init = arp_net_init,
+	.exit = arp_net_exit,
+};
 /*
  *	Called once on startup.
  */
@@ -1236,18 +1299,12 @@
 	.func =	arp_rcv,
 };
 
-static int arp_proc_init(void);
-
 void __init arp_init(void)
 {
 	neigh_table_init(&arp_tbl);
 
 	dev_add_pack(&arp_packet_type);
-	arp_proc_init();
-#ifdef CONFIG_SYSCTL
-	neigh_sysctl_register(NULL, &arp_tbl.parms, NET_IPV4,
-			      NET_IPV4_NEIGH, "ipv4", NULL, NULL);
-#endif
+	register_pernet_subsys(&arp_net_ops);
 	register_netdevice_notifier(&arp_netdev_notifier);
 }
 
@@ -1383,6 +1440,8 @@
 
 	seq	     = file->private_data;
 	seq->private = s;
+	s->net = get_net(PROC_NET(inode));
+
 out:
 	return rc;
 out_kfree:
@@ -1390,28 +1449,46 @@
 	goto out;
 }
 
+static int arp_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct neigh_seq_state *state = seq->private;
+	put_net(state->net);
+	return seq_release_private(inode, file);
+}
+
 static const struct file_operations arp_seq_fops = {
 	.owner		= THIS_MODULE,
 	.open           = arp_seq_open,
 	.read           = seq_read,
 	.llseek         = seq_lseek,
-	.release	= seq_release_private,
+	.release	= arp_seq_release,
 };
 
-static int __init arp_proc_init(void)
+static int arp_proc_init(struct net *net)
 {
-	if (!proc_net_fops_create("arp", S_IRUGO, &arp_seq_fops))
+	if (!proc_net_fops_create(net, "arp", S_IRUGO, &arp_seq_fops))
 		return -ENOMEM;
 	return 0;
 }
 
+static void arp_proc_exit(struct net *net)
+{
+	proc_net_remove(net, "arp");
+}
+
 #else /* CONFIG_PROC_FS */
 
-static int __init arp_proc_init(void)
+static int arp_proc_init(struct net *net)
 {
 	return 0;
 }
 
+static void arp_proc_exit(struct net *net)
+{
+	return;
+}
+
 #endif /* CONFIG_PROC_FS */
 
 EXPORT_SYMBOL(arp_broken_ops);
diff -Nurb linux-2.6.22-590/net/ipv4/devinet.c linux-2.6.22-try2-netns/net/ipv4/devinet.c
--- linux-2.6.22-590/net/ipv4/devinet.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/devinet.c	2007-12-19 22:49:18.000000000 -0500
@@ -63,7 +63,7 @@
 #include <net/ip_fib.h>
 #include <net/rtnetlink.h>
 
-struct ipv4_devconf ipv4_devconf = {
+static struct ipv4_devconf ipv4_devconf_template = {
 	.data = {
 		[NET_IPV4_CONF_ACCEPT_REDIRECTS - 1] = 1,
 		[NET_IPV4_CONF_SEND_REDIRECTS - 1] = 1,
@@ -72,7 +72,7 @@
 	},
 };
 
-static struct ipv4_devconf ipv4_devconf_dflt = {
+static struct ipv4_devconf ipv4_devconf_dflt_template = {
 	.data = {
 		[NET_IPV4_CONF_ACCEPT_REDIRECTS - 1] = 1,
 		[NET_IPV4_CONF_SEND_REDIRECTS - 1] = 1,
@@ -82,7 +82,7 @@
 	},
 };
 
-#define IPV4_DEVCONF_DFLT(attr) IPV4_DEVCONF(ipv4_devconf_dflt, attr)
+#define IPV4_DEVCONF_DFLT(net, attr) IPV4_DEVCONF(*((net)->ipv4_devconf_dflt), attr)
 
 static const struct nla_policy ifa_ipv4_policy[IFA_MAX+1] = {
 	[IFA_LOCAL]     	= { .type = NLA_U32 },
@@ -98,7 +98,7 @@
 static void inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,
 			 int destroy);
 #ifdef CONFIG_SYSCTL
-static void devinet_sysctl_register(struct in_device *in_dev,
+static void devinet_sysctl_register(struct net *net, struct in_device *in_dev,
 				    struct ipv4_devconf *p);
 static void devinet_sysctl_unregister(struct ipv4_devconf *p);
 #endif
@@ -149,6 +149,7 @@
 
 static struct in_device *inetdev_init(struct net_device *dev)
 {
+	struct net *net = dev->nd_net;
 	struct in_device *in_dev;
 
 	ASSERT_RTNL();
@@ -157,7 +158,7 @@
 	if (!in_dev)
 		goto out;
 	INIT_RCU_HEAD(&in_dev->rcu_head);
-	memcpy(&in_dev->cnf, &ipv4_devconf_dflt, sizeof(in_dev->cnf));
+	memcpy(&in_dev->cnf, &net->ipv4_devconf_dflt, sizeof(in_dev->cnf));
 	in_dev->cnf.sysctl = NULL;
 	in_dev->dev = dev;
 	if ((in_dev->arp_parms = neigh_parms_alloc(dev, &arp_tbl)) == NULL)
@@ -173,7 +174,7 @@
 	in_dev_hold(in_dev);
 
 #ifdef CONFIG_SYSCTL
-	devinet_sysctl_register(in_dev, &in_dev->cnf);
+	devinet_sysctl_register(net, in_dev, &in_dev->cnf);
 #endif
 	ip_mc_init_dev(in_dev);
 	if (dev->flags & IFF_UP)
@@ -203,8 +204,6 @@
 	ASSERT_RTNL();
 
 	dev = in_dev->dev;
-	if (dev == &loopback_dev)
-		return;
 
 	in_dev->dead = 1;
 
@@ -415,12 +414,12 @@
 	return inet_insert_ifa(ifa);
 }
 
-struct in_device *inetdev_by_index(int ifindex)
+struct in_device *inetdev_by_index(struct net *net, int ifindex)
 {
 	struct net_device *dev;
 	struct in_device *in_dev = NULL;
 	read_lock(&dev_base_lock);
-	dev = __dev_get_by_index(ifindex);
+	dev = __dev_get_by_index(net, ifindex);
 	if (dev)
 		in_dev = in_dev_get(dev);
 	read_unlock(&dev_base_lock);
@@ -444,6 +443,7 @@
 
 static int inet_rtm_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct nlattr *tb[IFA_MAX+1];
 	struct in_device *in_dev;
 	struct ifaddrmsg *ifm;
@@ -457,7 +457,7 @@
 		goto errout;
 
 	ifm = nlmsg_data(nlh);
-	in_dev = inetdev_by_index(ifm->ifa_index);
+	in_dev = inetdev_by_index(net, ifm->ifa_index);
 	if (in_dev == NULL) {
 		err = -ENODEV;
 		goto errout;
@@ -488,7 +488,7 @@
 	return err;
 }
 
-static struct in_ifaddr *rtm_to_ifaddr(struct nlmsghdr *nlh)
+static struct in_ifaddr *rtm_to_ifaddr(struct net *net, struct nlmsghdr *nlh)
 {
 	struct nlattr *tb[IFA_MAX+1];
 	struct in_ifaddr *ifa;
@@ -507,7 +507,7 @@
 		goto errout;
 	}
 
-	dev = __dev_get_by_index(ifm->ifa_index);
+	dev = __dev_get_by_index(net, ifm->ifa_index);
 	if (dev == NULL) {
 		err = -ENODEV;
 		goto errout;
@@ -564,11 +564,12 @@
 
 static int inet_rtm_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct in_ifaddr *ifa;
 
 	ASSERT_RTNL();
 
-	ifa = rtm_to_ifaddr(nlh);
+	ifa = rtm_to_ifaddr(net, nlh);
 	if (IS_ERR(ifa))
 		return PTR_ERR(ifa);
 
@@ -600,7 +601,7 @@
 }
 
 
-int devinet_ioctl(unsigned int cmd, void __user *arg)
+int devinet_ioctl(struct net *net, unsigned int cmd, void __user *arg)
 {
 	struct ifreq ifr;
 	struct sockaddr_in sin_orig;
@@ -629,7 +630,7 @@
 		*colon = 0;
 
 #ifdef CONFIG_KMOD
-	dev_load(ifr.ifr_name);
+	dev_load(net, ifr.ifr_name);
 #endif
 
 	switch (cmd) {
@@ -670,7 +671,7 @@
 	rtnl_lock();
 
 	ret = -ENODEV;
-	if ((dev = __dev_get_by_name(ifr.ifr_name)) == NULL)
+	if ((dev = __dev_get_by_name(net, ifr.ifr_name)) == NULL)
 		goto done;
 
 	if (colon)
@@ -889,6 +890,7 @@
 
 __be32 inet_select_addr(const struct net_device *dev, __be32 dst, int scope)
 {
+	struct net *net = dev->nd_net;
 	__be32 addr = 0;
 	struct in_device *in_dev;
 
@@ -919,7 +921,7 @@
 	 */
 	read_lock(&dev_base_lock);
 	rcu_read_lock();
-	for_each_netdev(dev) {
+	for_each_netdev(net, dev) {
 		if ((in_dev = __in_dev_get_rcu(dev)) == NULL)
 			continue;
 
@@ -982,7 +984,7 @@
  * - local: address, 0=autoselect the local address
  * - scope: maximum allowed scope value for the local address
  */
-__be32 inet_confirm_addr(const struct net_device *dev, __be32 dst, __be32 local, int scope)
+__be32 inet_confirm_addr(struct net *net, const struct net_device *dev, __be32 dst, __be32 local, int scope)
 {
 	__be32 addr = 0;
 	struct in_device *in_dev;
@@ -998,7 +1000,7 @@
 
 	read_lock(&dev_base_lock);
 	rcu_read_lock();
-	for_each_netdev(dev) {
+	for_each_netdev(net, dev) {
 		if ((in_dev = __in_dev_get_rcu(dev))) {
 			addr = confirm_addr_indev(in_dev, dst, local, scope);
 			if (addr)
@@ -1059,6 +1061,7 @@
 			 void *ptr)
 {
 	struct net_device *dev = ptr;
+	struct net *net = dev->nd_net;
 	struct in_device *in_dev = __in_dev_get_rtnl(dev);
 
 	ASSERT_RTNL();
@@ -1066,7 +1069,7 @@
 	if (!in_dev) {
 		if (event == NETDEV_REGISTER) {
 			in_dev = inetdev_init(dev);
-			if (dev == &loopback_dev) {
+			if (dev == &net->loopback_dev) {
 				if (!in_dev)
 					panic("devinet: "
 					      "Failed to create loopback\n");
@@ -1085,7 +1088,7 @@
 	case NETDEV_UP:
 		if (dev->mtu < 68)
 			break;
-		if (dev == &loopback_dev) {
+		if (dev == &net->loopback_dev) {
 			struct in_ifaddr *ifa;
 			if ((ifa = inet_alloc_ifa()) != NULL) {
 				ifa->ifa_local =
@@ -1122,7 +1125,7 @@
 		neigh_sysctl_unregister(in_dev->arp_parms);
 		neigh_sysctl_register(dev, in_dev->arp_parms, NET_IPV4,
 				      NET_IPV4_NEIGH, "ipv4", NULL, NULL);
-		devinet_sysctl_register(in_dev, &in_dev->cnf);
+		devinet_sysctl_register(net, in_dev, &in_dev->cnf);
 #endif
 		break;
 	}
@@ -1185,6 +1188,7 @@
 
 static int inet_dump_ifaddr(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	int idx, ip_idx;
 	struct net_device *dev;
 	struct in_device *in_dev;
@@ -1194,7 +1198,7 @@
 
 	s_ip_idx = ip_idx = cb->args[1];
 	idx = 0;
-	for_each_netdev(dev) {
+	for_each_netdev(net, dev) {
 		if (idx < s_idx)
 			goto cont;
 		if (idx > s_idx)
@@ -1228,6 +1232,7 @@
 		      u32 pid)
 {
 	struct sk_buff *skb;
+	struct net *net = ifa->ifa_dev->dev->nd_net;
 	u32 seq = nlh ? nlh->nlmsg_seq : 0;
 	int err = -ENOBUFS;
 
@@ -1242,25 +1247,25 @@
 		kfree_skb(skb);
 		goto errout;
 	}
-	err = rtnl_notify(skb, pid, RTNLGRP_IPV4_IFADDR, nlh, GFP_KERNEL);
+	err = rtnl_notify(skb, net, pid, RTNLGRP_IPV4_IFADDR, nlh, GFP_KERNEL);
 errout:
 	if (err < 0)
-		rtnl_set_sk_err(RTNLGRP_IPV4_IFADDR, err);
+		rtnl_set_sk_err(net, RTNLGRP_IPV4_IFADDR, err);
 }
 
 #ifdef CONFIG_SYSCTL
 
-static void devinet_copy_dflt_conf(int i)
+static void devinet_copy_dflt_conf(struct net *net, int i)
 {
 	struct net_device *dev;
 
 	read_lock(&dev_base_lock);
-	for_each_netdev(dev) {
+	for_each_netdev(net, dev) {
 		struct in_device *in_dev;
 		rcu_read_lock();
 		in_dev = __in_dev_get_rcu(dev);
 		if (in_dev && !test_bit(i, in_dev->cnf.state))
-			in_dev->cnf.data[i] = ipv4_devconf_dflt.data[i];
+			in_dev->cnf.data[i] = net->ipv4_devconf_dflt->data[i];
 		rcu_read_unlock();
 	}
 	read_unlock(&dev_base_lock);
@@ -1274,12 +1279,13 @@
 
 	if (write) {
 		struct ipv4_devconf *cnf = ctl->extra1;
+		struct net *net = ctl->extra2;
 		int i = (int *)ctl->data - cnf->data;
 
 		set_bit(i, cnf->state);
 
-		if (cnf == &ipv4_devconf_dflt)
-			devinet_copy_dflt_conf(i);
+		if (cnf == net->ipv4_devconf_dflt)
+			devinet_copy_dflt_conf(net, i);
 	}
 
 	return ret;
@@ -1291,6 +1297,7 @@
 {
 	struct ipv4_devconf *cnf;
 	int *valp = table->data;
+	struct net *net;
 	int new;
 	int i;
 
@@ -1325,26 +1332,27 @@
 	*valp = new;
 
 	cnf = table->extra1;
+	net = table->extra2;
 	i = (int *)table->data - cnf->data;
 
 	set_bit(i, cnf->state);
 
-	if (cnf == &ipv4_devconf_dflt)
-		devinet_copy_dflt_conf(i);
+	if (cnf == net->ipv4_devconf_dflt)
+		devinet_copy_dflt_conf(net, i);
 
 	return 1;
 }
 
-void inet_forward_change(void)
+void inet_forward_change(struct net *net)
 {
 	struct net_device *dev;
-	int on = IPV4_DEVCONF_ALL(FORWARDING);
+	int on = IPV4_DEVCONF_ALL(net, FORWARDING);
 
-	IPV4_DEVCONF_ALL(ACCEPT_REDIRECTS) = !on;
-	IPV4_DEVCONF_DFLT(FORWARDING) = on;
+	IPV4_DEVCONF_ALL(net, ACCEPT_REDIRECTS) = !on;
+	IPV4_DEVCONF_DFLT(net, FORWARDING) = on;
 
 	read_lock(&dev_base_lock);
-	for_each_netdev(dev) {
+	for_each_netdev(net, dev) {
 		struct in_device *in_dev;
 		rcu_read_lock();
 		in_dev = __in_dev_get_rcu(dev);
@@ -1364,11 +1372,12 @@
 	int *valp = ctl->data;
 	int val = *valp;
 	int ret = proc_dointvec(ctl, write, filp, buffer, lenp, ppos);
+	struct net *net = ctl->extra2;
 
 	if (write && *valp != val) {
-		if (valp == &IPV4_DEVCONF_ALL(FORWARDING))
-			inet_forward_change();
-		else if (valp != &IPV4_DEVCONF_DFLT(FORWARDING))
+		if (valp == &IPV4_DEVCONF_ALL(net, FORWARDING))
+			inet_forward_change(net);
+		else if (valp != &IPV4_DEVCONF_DFLT(net, FORWARDING))
 			rt_cache_flush(0);
 	}
 
@@ -1407,13 +1416,14 @@
 	{ \
 		.ctl_name	= NET_IPV4_CONF_ ## attr, \
 		.procname	= name, \
-		.data		= ipv4_devconf.data + \
+		.data		= ipv4_devconf_template.data + \
 				  NET_IPV4_CONF_ ## attr - 1, \
 		.maxlen		= sizeof(int), \
 		.mode		= mval, \
 		.proc_handler	= proc, \
 		.strategy	= sysctl, \
-		.extra1		= &ipv4_devconf, \
+		.extra1		= &ipv4_devconf_template, \
+		.extra2		= &init_net, \
 	}
 
 #define DEVINET_SYSCTL_RW_ENTRY(attr, name) \
@@ -1503,25 +1513,29 @@
 	},
 };
 
-static void devinet_sysctl_register(struct in_device *in_dev,
+static void devinet_sysctl_register(struct net *net, struct in_device *in_dev,
 				    struct ipv4_devconf *p)
 {
 	int i;
 	struct net_device *dev = in_dev ? in_dev->dev : NULL;
-	struct devinet_sysctl_table *t = kmemdup(&devinet_sysctl, sizeof(*t),
-						 GFP_KERNEL);
+	struct devinet_sysctl_table *t;
 	char *dev_name = NULL;
 
+	t = kmemdup(&devinet_sysctl, sizeof(*t), GFP_KERNEL);
 	if (!t)
 		return;
 	for (i = 0; i < ARRAY_SIZE(t->devinet_vars) - 1; i++) {
-		t->devinet_vars[i].data += (char *)p - (char *)&ipv4_devconf;
+		t->devinet_vars[i].data += (char *)p - (char *)&ipv4_devconf_template;
 		t->devinet_vars[i].extra1 = p;
+		t->devinet_vars[i].extra2 = net;
 	}
 
 	if (dev) {
 		dev_name = dev->name;
 		t->devinet_dev[0].ctl_name = dev->ifindex;
+	} else if (p == net->ipv4_devconf) {
+		dev_name = "all";
+		t->devinet_dev[0].ctl_name = NET_PROTO_CONF_ALL;
 	} else {
 		dev_name = "default";
 		t->devinet_dev[0].ctl_name = NET_PROTO_CONF_DEFAULT;
@@ -1542,7 +1556,7 @@
 	t->devinet_proto_dir[0].child = t->devinet_conf_dir;
 	t->devinet_root_dir[0].child  = t->devinet_proto_dir;
 
-	t->sysctl_header = register_sysctl_table(t->devinet_root_dir);
+	t->sysctl_header = register_net_sysctl_table(net, t->devinet_root_dir);
 	if (!t->sysctl_header)
 	    goto free_procname;
 
@@ -1562,26 +1576,59 @@
 	if (p->sysctl) {
 		struct devinet_sysctl_table *t = p->sysctl;
 		p->sysctl = NULL;
-		unregister_sysctl_table(t->sysctl_header);
+		unregister_net_sysctl_table(t->sysctl_header);
 		kfree(t->devinet_dev[0].procname);
 		kfree(t);
 	}
 }
 #endif
 
+static int devinet_net_init(struct net *net)
+{
+#ifdef CONFIG_SYSCTL
+	net->ipv4_devconf = kmemdup(&ipv4_devconf_template, 
+				    sizeof(ipv4_devconf_template), GFP_KERNEL);
+	if (!net->ipv4_devconf)
+		return -ENOMEM;
+	
+	net->ipv4_devconf_dflt = kmemdup(&ipv4_devconf_dflt_template, 
+					 sizeof(ipv4_devconf_template),
+					 GFP_KERNEL);
+	if (!net->ipv4_devconf_dflt) {
+		kfree(net->ipv4_devconf);
+		return -ENOMEM;
+	}
+
+	devinet_sysctl_register(net, NULL, net->ipv4_devconf);
+	devinet_sysctl_register(net, NULL, net->ipv4_devconf_dflt);
+
+	multi_ipv4_table[0].data = &IPV4_DEVCONF_ALL(net, FORWARDING);
+#endif
+	return 0;
+}
+
+static void devinet_net_exit(struct net *net)
+{
+#ifdef CONFIG_SYSCTL
+	devinet_sysctl_unregister(net->ipv4_devconf_dflt);
+	devinet_sysctl_unregister(net->ipv4_devconf);
+#endif
+}
+
+static struct pernet_operations devinet_net_ops = {
+	.init = devinet_net_init,
+	.exit = devinet_net_exit,
+};
+
 void __init devinet_init(void)
 {
+	register_pernet_subsys(&devinet_net_ops);
 	register_gifconf(PF_INET, inet_gifconf);
 	register_netdevice_notifier(&ip_netdev_notifier);
 
 	rtnl_register(PF_INET, RTM_NEWADDR, inet_rtm_newaddr, NULL);
 	rtnl_register(PF_INET, RTM_DELADDR, inet_rtm_deladdr, NULL);
 	rtnl_register(PF_INET, RTM_GETADDR, NULL, inet_dump_ifaddr);
-#ifdef CONFIG_SYSCTL
-	devinet_sysctl.sysctl_header =
-		register_sysctl_table(devinet_sysctl.devinet_root_dir);
-	devinet_sysctl_register(NULL, &ipv4_devconf_dflt);
-#endif
 }
 
 EXPORT_SYMBOL(in_dev_finish_destroy);
diff -Nurb linux-2.6.22-590/net/ipv4/esp4.c linux-2.6.22-try2-netns/net/ipv4/esp4.c
--- linux-2.6.22-590/net/ipv4/esp4.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/esp4.c	2007-12-19 22:49:18.000000000 -0500
@@ -307,6 +307,9 @@
 	struct ip_esp_hdr *esph = (struct ip_esp_hdr*)(skb->data+(iph->ihl<<2));
 	struct xfrm_state *x;
 
+	if (skb->dev->nd_net != &init_net)
+		return;
+
 	if (icmp_hdr(skb)->type != ICMP_DEST_UNREACH ||
 	    icmp_hdr(skb)->code != ICMP_FRAG_NEEDED)
 		return;
diff -Nurb linux-2.6.22-590/net/ipv4/fib_frontend.c linux-2.6.22-try2-netns/net/ipv4/fib_frontend.c
--- linux-2.6.22-590/net/ipv4/fib_frontend.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/fib_frontend.c	2007-12-19 22:49:18.000000000 -0500
@@ -51,38 +51,34 @@
 
 #ifndef CONFIG_IP_MULTIPLE_TABLES
 
-struct fib_table *ip_fib_local_table;
-struct fib_table *ip_fib_main_table;
-
 #define FIB_TABLE_HASHSZ 1
-static struct hlist_head fib_table_hash[FIB_TABLE_HASHSZ];
 
 #else
 
 #define FIB_TABLE_HASHSZ 256
-static struct hlist_head fib_table_hash[FIB_TABLE_HASHSZ];
 
-struct fib_table *fib_new_table(u32 id)
+struct fib_table *fib_new_table(struct net *net, u32 id)
 {
 	struct fib_table *tb;
 	unsigned int h;
 
 	if (id == 0)
 		id = RT_TABLE_MAIN;
-	tb = fib_get_table(id);
+	tb = fib_get_table(net, id);
 	if (tb)
 		return tb;
 	tb = fib_hash_init(id);
 	if (!tb)
 		return NULL;
 	h = id & (FIB_TABLE_HASHSZ - 1);
-	hlist_add_head_rcu(&tb->tb_hlist, &fib_table_hash[h]);
+	hlist_add_head_rcu(&tb->tb_hlist, &net->ip_fib_table_hash[h]);
 	return tb;
 }
 
-struct fib_table *fib_get_table(u32 id)
+struct fib_table *fib_get_table(struct net *net, u32 id)
 {
 	struct fib_table *tb;
+	struct hlist_head *head;
 	struct hlist_node *node;
 	unsigned int h;
 
@@ -90,7 +86,8 @@
 		id = RT_TABLE_MAIN;
 	h = id & (FIB_TABLE_HASHSZ - 1);
 	rcu_read_lock();
-	hlist_for_each_entry_rcu(tb, node, &fib_table_hash[h], tb_hlist) {
+	head = &net->ip_fib_table_hash[h];
+	hlist_for_each_entry_rcu(tb, node, head, tb_hlist) {
 		if (tb->tb_id == id) {
 			rcu_read_unlock();
 			return tb;
@@ -99,9 +96,10 @@
 	rcu_read_unlock();
 	return NULL;
 }
+
 #endif /* CONFIG_IP_MULTIPLE_TABLES */
 
-static void fib_flush(void)
+static void fib_flush(struct net *net)
 {
 	int flushed = 0;
 	struct fib_table *tb;
@@ -109,7 +107,8 @@
 	unsigned int h;
 
 	for (h = 0; h < FIB_TABLE_HASHSZ; h++) {
-		hlist_for_each_entry(tb, node, &fib_table_hash[h], tb_hlist)
+		struct hlist_head *head = &net->ip_fib_table_hash[h];
+		hlist_for_each_entry(tb, node, head, tb_hlist)
 			flushed += tb->tb_flush(tb);
 	}
 
@@ -121,18 +120,23 @@
  *	Find the first device with a given source address.
  */
 
-struct net_device * ip_dev_find(__be32 addr)
+struct net_device * ip_dev_find(struct net *net, __be32 addr)
 {
-	struct flowi fl = { .nl_u = { .ip4_u = { .daddr = addr } } };
+	struct flowi fl = { 
+		.fl_net = net,
+		.nl_u = { .ip4_u = { .daddr = addr } }
+	};
 	struct fib_result res;
 	struct net_device *dev = NULL;
+	struct fib_table *local_table;
 
 #ifdef CONFIG_IP_MULTIPLE_TABLES
 	res.r = NULL;
 #endif
 
-	if (!ip_fib_local_table ||
-	    ip_fib_local_table->tb_lookup(ip_fib_local_table, &fl, &res))
+	local_table = fib_get_table(net, RT_TABLE_LOCAL);
+	if (!local_table ||
+	    local_table->tb_lookup(local_table, &fl, &res))
 		return NULL;
 	if (res.type != RTN_LOCAL)
 		goto out;
@@ -145,11 +149,15 @@
 	return dev;
 }
 
-unsigned inet_addr_type(__be32 addr)
+unsigned inet_addr_type(struct net *net, __be32 addr)
 {
-	struct flowi		fl = { .nl_u = { .ip4_u = { .daddr = addr } } };
+	struct flowi		fl = {
+		.fl_net = net,
+		.nl_u = { .ip4_u = { .daddr = addr } }
+	};
 	struct fib_result	res;
 	unsigned ret = RTN_BROADCAST;
+	struct fib_table *local_table;
 
 	if (ZERONET(addr) || BADCLASS(addr))
 		return RTN_BROADCAST;
@@ -160,10 +168,10 @@
 	res.r = NULL;
 #endif
 
-	if (ip_fib_local_table) {
+	local_table = fib_get_table(net, RT_TABLE_LOCAL);
+	if (local_table) {
 		ret = RTN_UNICAST;
-		if (!ip_fib_local_table->tb_lookup(ip_fib_local_table,
-						   &fl, &res)) {
+		if (!local_table->tb_lookup(local_table, &fl, &res)) {
 			ret = res.type;
 			fib_res_put(&res);
 		}
@@ -183,7 +191,8 @@
 			struct net_device *dev, __be32 *spec_dst, u32 *itag)
 {
 	struct in_device *in_dev;
-	struct flowi fl = { .nl_u = { .ip4_u =
+	struct flowi fl = { .fl_net = dev->nd_net,
+			    .nl_u = { .ip4_u =
 				      { .daddr = src,
 					.saddr = dst,
 					.tos = tos } },
@@ -267,13 +276,16 @@
 	return len + nla_total_size(4);
 }
 
-static int rtentry_to_fib_config(int cmd, struct rtentry *rt,
+static int rtentry_to_fib_config(struct net *net, int cmd, struct rtentry *rt,
 				 struct fib_config *cfg)
 {
 	__be32 addr;
 	int plen;
 
 	memset(cfg, 0, sizeof(*cfg));
+	cfg->fc_nlinfo.pid = 0;
+	cfg->fc_nlinfo.nlh = NULL;
+	cfg->fc_nlinfo.net = net;
 
 	if (rt->rt_dst.sa_family != AF_INET)
 		return -EAFNOSUPPORT;
@@ -334,7 +346,7 @@
 		colon = strchr(devname, ':');
 		if (colon)
 			*colon = 0;
-		dev = __dev_get_by_name(devname);
+		dev = __dev_get_by_name(net, devname);
 		if (!dev)
 			return -ENODEV;
 		cfg->fc_oif = dev->ifindex;
@@ -357,7 +369,7 @@
 	if (rt->rt_gateway.sa_family == AF_INET && addr) {
 		cfg->fc_gw = addr;
 		if (rt->rt_flags & RTF_GATEWAY &&
-		    inet_addr_type(addr) == RTN_UNICAST)
+		    inet_addr_type(net, addr) == RTN_UNICAST)
 			cfg->fc_scope = RT_SCOPE_UNIVERSE;
 	}
 
@@ -398,7 +410,7 @@
  *	Handle IP routing ioctl calls. These are used to manipulate the routing tables
  */
 
-int ip_rt_ioctl(unsigned int cmd, void __user *arg)
+int ip_rt_ioctl(struct net *net, unsigned int cmd, void __user *arg)
 {
 	struct fib_config cfg;
 	struct rtentry rt;
@@ -414,18 +426,18 @@
 			return -EFAULT;
 
 		rtnl_lock();
-		err = rtentry_to_fib_config(cmd, &rt, &cfg);
+		err = rtentry_to_fib_config(net, cmd, &rt, &cfg);
 		if (err == 0) {
 			struct fib_table *tb;
 
 			if (cmd == SIOCDELRT) {
-				tb = fib_get_table(cfg.fc_table);
+				tb = fib_get_table(net, cfg.fc_table);
 				if (tb)
 					err = tb->tb_delete(tb, &cfg);
 				else
 					err = -ESRCH;
 			} else {
-				tb = fib_new_table(cfg.fc_table);
+				tb = fib_new_table(net, cfg.fc_table);
 				if (tb)
 					err = tb->tb_insert(tb, &cfg);
 				else
@@ -480,6 +492,7 @@
 
 	cfg->fc_nlinfo.pid = NETLINK_CB(skb).pid;
 	cfg->fc_nlinfo.nlh = nlh;
+	cfg->fc_nlinfo.net = skb->sk->sk_net;
 
 	if (cfg->fc_type > RTN_MAX) {
 		err = -EINVAL;
@@ -527,6 +540,7 @@
 
 static int inet_rtm_delroute(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct fib_config cfg;
 	struct fib_table *tb;
 	int err;
@@ -535,7 +549,7 @@
 	if (err < 0)
 		goto errout;
 
-	tb = fib_get_table(cfg.fc_table);
+	tb = fib_get_table(net, cfg.fc_table);
 	if (tb == NULL) {
 		err = -ESRCH;
 		goto errout;
@@ -548,6 +562,7 @@
 
 static int inet_rtm_newroute(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct fib_config cfg;
 	struct fib_table *tb;
 	int err;
@@ -556,7 +571,7 @@
 	if (err < 0)
 		goto errout;
 
-	tb = fib_new_table(cfg.fc_table);
+	tb = fib_new_table(net, cfg.fc_table);
 	if (tb == NULL) {
 		err = -ENOBUFS;
 		goto errout;
@@ -569,6 +584,7 @@
 
 static int inet_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	unsigned int h, s_h;
 	unsigned int e = 0, s_e;
 	struct fib_table *tb;
@@ -583,8 +599,9 @@
 	s_e = cb->args[1];
 
 	for (h = s_h; h < FIB_TABLE_HASHSZ; h++, s_e = 0) {
+		struct hlist_head *head = &net->ip_fib_table_hash[h];
 		e = 0;
-		hlist_for_each_entry(tb, node, &fib_table_hash[h], tb_hlist) {
+		hlist_for_each_entry(tb, node, head, tb_hlist) {
 			if (e < s_e)
 				goto next;
 			if (dumped)
@@ -613,6 +630,7 @@
 
 static void fib_magic(int cmd, int type, __be32 dst, int dst_len, struct in_ifaddr *ifa)
 {
+	struct net *net = ifa->ifa_dev->dev->nd_net;
 	struct fib_table *tb;
 	struct fib_config cfg = {
 		.fc_protocol = RTPROT_KERNEL,
@@ -622,12 +640,13 @@
 		.fc_prefsrc = ifa->ifa_local,
 		.fc_oif = ifa->ifa_dev->dev->ifindex,
 		.fc_nlflags = NLM_F_CREATE | NLM_F_APPEND,
+		.fc_nlinfo.net = net,
 	};
 
 	if (type == RTN_UNICAST)
-		tb = fib_new_table(RT_TABLE_MAIN);
+		tb = fib_new_table(net, RT_TABLE_MAIN);
 	else
-		tb = fib_new_table(RT_TABLE_LOCAL);
+		tb = fib_new_table(net, RT_TABLE_LOCAL);
 
 	if (tb == NULL)
 		return;
@@ -688,6 +707,7 @@
 {
 	struct in_device *in_dev = ifa->ifa_dev;
 	struct net_device *dev = in_dev->dev;
+	struct net *net = dev->nd_net;
 	struct in_ifaddr *ifa1;
 	struct in_ifaddr *prim = ifa;
 	__be32 brd = ifa->ifa_address|~ifa->ifa_mask;
@@ -736,15 +756,15 @@
 		fib_magic(RTM_DELROUTE, RTN_LOCAL, ifa->ifa_local, 32, prim);
 
 		/* Check, that this local address finally disappeared. */
-		if (inet_addr_type(ifa->ifa_local) != RTN_LOCAL) {
+		if (inet_addr_type(net, ifa->ifa_local) != RTN_LOCAL) {
 			/* And the last, but not the least thing.
 			   We must flush stray FIB entries.
 
 			   First of all, we scan fib_info list searching
 			   for stray nexthop entries, then ignite fib_flush.
 			*/
-			if (fib_sync_down(ifa->ifa_local, NULL, 0))
-				fib_flush();
+			if (fib_sync_down(net, ifa->ifa_local, NULL, 0))
+				fib_flush(net);
 		}
 	}
 #undef LOCAL_OK
@@ -753,11 +773,12 @@
 #undef BRD1_OK
 }
 
-static void nl_fib_lookup(struct fib_result_nl *frn, struct fib_table *tb )
+static void nl_fib_lookup(struct net *net, struct fib_result_nl *frn, struct fib_table *tb )
 {
 
 	struct fib_result       res;
-	struct flowi            fl = { .mark = frn->fl_mark,
+	struct flowi            fl = { .fl_net = net,
+				       .mark = frn->fl_mark,
 				       .nl_u = { .ip4_u = { .daddr = frn->fl_addr,
 							    .tos = frn->fl_tos,
 							    .scope = frn->fl_scope } } };
@@ -786,6 +807,7 @@
 
 static void nl_fib_input(struct sock *sk, int len)
 {
+	struct net *net = sk->sk_net;
 	struct sk_buff *skb = NULL;
 	struct nlmsghdr *nlh = NULL;
 	struct fib_result_nl *frn;
@@ -804,9 +826,9 @@
 	}
 
 	frn = (struct fib_result_nl *) NLMSG_DATA(nlh);
-	tb = fib_get_table(frn->tb_id_in);
+	tb = fib_get_table(net, frn->tb_id_in);
 
-	nl_fib_lookup(frn, tb);
+	nl_fib_lookup(net, frn, tb);
 
 	pid = NETLINK_CB(skb).pid;       /* pid of sending process */
 	NETLINK_CB(skb).pid = 0;         /* from kernel */
@@ -814,16 +836,36 @@
 	netlink_unicast(sk, skb, pid, MSG_DONTWAIT);
 }
 
-static void nl_fib_lookup_init(void)
+static int nl_fib_lookup_init(struct net *net)
 {
-      netlink_kernel_create(NETLINK_FIB_LOOKUP, 0, nl_fib_input, NULL,
-      			    THIS_MODULE);
+	int error = -ENOMEM;
+	struct sock *sk;
+	sk = netlink_kernel_create(net, NETLINK_FIB_LOOKUP, 0, nl_fib_input,
+					NULL, THIS_MODULE);
+	if (sk) {
+		/* Don't hold an extra reference on the namespace */
+		put_net(sk->sk_net);
+		net->nlfl = sk;
+		error = 0;
+	}
+	return error;
+}
+
+static void nl_fib_lookup_exit(struct net *net)
+{
+	/* At the last minute lie and say this is a socket for the
+	 * initial network namespace.  So the socket will  be safe to
+	 * free. 
+	 */
+	net->nlfl->sk_net = get_net(&init_net);
+	sock_put(net->nlfl);
 }
 
 static void fib_disable_ip(struct net_device *dev, int force)
 {
-	if (fib_sync_down(0, dev, force))
-		fib_flush();
+	struct net *net = dev->nd_net;
+	if (fib_sync_down(net, 0, dev, force))
+		fib_flush(net);
 	rt_cache_flush(0);
 	arp_ifdown(dev);
 }
@@ -860,6 +902,9 @@
 	struct net_device *dev = ptr;
 	struct in_device *in_dev = __in_dev_get_rtnl(dev);
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (event == NETDEV_UNREGISTER) {
 		fib_disable_ip(dev, 2);
 		return NOTIFY_DONE;
@@ -889,6 +934,85 @@
 	return NOTIFY_DONE;
 }
 
+static int ip_fib_net_init(struct net *net)
+{
+	unsigned int i;
+
+	net->ip_fib_table_hash = kzalloc(
+		sizeof(struct hlist_head)*FIB_TABLE_HASHSZ, GFP_KERNEL);
+	if (!net->ip_fib_table_hash)
+		return -ENOMEM;
+
+	for (i = 0; i < FIB_TABLE_HASHSZ; i++)
+		INIT_HLIST_HEAD(&net->ip_fib_table_hash[i]);
+#ifndef CONFIG_IP_MULTIPLE_TABLES
+	net->ip_fib_local_table = fib_hash_init(RT_TABLE_LOCAL);
+	hlist_add_head_rcu(&net->ip_fib_local_table->tb_hlist,
+				&net->ip_fib_table_hash[0]);
+	net->ip_fib_main_table = fib_hash_init(RT_TABLE_MAIN);
+	hlist_add_head_rcu(&net->ip_fib_main_table->tb_hlist,
+				&net->ip_fib_table_hash[0]);
+#else
+	fib4_rules_init(net);
+#endif
+	return 0;
+}
+
+static void ip_fib_net_exit(struct net *net)
+{
+	unsigned int i;
+
+#ifdef CONFIG_IP_MULTIPLE_TABLES
+	fib4_rules_exit(net);
+#endif
+
+	synchronize_rcu(); /* needed? */
+	for (i = 0; i < FIB_TABLE_HASHSZ; i++) {
+		struct fib_table *tb;
+		struct hlist_head *head;
+		struct hlist_node *node, *tmp;
+
+		head = &net->ip_fib_table_hash[i];
+		hlist_for_each_entry_safe(tb, node, tmp, head, tb_hlist) {
+			hlist_del(node);
+			fib_hash_exit(tb);
+		}
+	}
+	kfree(net->ip_fib_table_hash);
+}
+
+static int fib_net_init(struct net *net)
+{
+	int error;
+
+	error = 0;
+	if ((error = ip_fib_net_init(net)))
+		goto out;
+	if ((error = fib_info_init(net)))
+		goto out_info;
+	if ((error = nl_fib_lookup_init(net)))
+		goto out_nlfl;
+	if ((error = fib_proc_init(net)))
+		goto out_proc;
+out:
+	return error;
+out_proc:
+	nl_fib_lookup_exit(net);
+out_nlfl:
+	fib_info_exit(net);
+out_info:
+	ip_fib_net_exit(net);
+	goto out;
+}
+
+static void fib_net_exit(struct net *net)
+{
+	fib_proc_exit(net);
+	nl_fib_lookup_exit(net);
+	fib_info_exit(net);
+	ip_fib_net_exit(net);
+}
+
 static struct notifier_block fib_inetaddr_notifier = {
 	.notifier_call =fib_inetaddr_event,
 };
@@ -897,28 +1021,20 @@
 	.notifier_call =fib_netdev_event,
 };
 
+static struct pernet_operations fib_net_ops = {
+	.init = fib_net_init,
+	.exit = fib_net_exit,
+};
+
 void __init ip_fib_init(void)
 {
-	unsigned int i;
-
-	for (i = 0; i < FIB_TABLE_HASHSZ; i++)
-		INIT_HLIST_HEAD(&fib_table_hash[i]);
-#ifndef CONFIG_IP_MULTIPLE_TABLES
-	ip_fib_local_table = fib_hash_init(RT_TABLE_LOCAL);
-	hlist_add_head_rcu(&ip_fib_local_table->tb_hlist, &fib_table_hash[0]);
-	ip_fib_main_table  = fib_hash_init(RT_TABLE_MAIN);
-	hlist_add_head_rcu(&ip_fib_main_table->tb_hlist, &fib_table_hash[0]);
-#else
-	fib4_rules_init();
-#endif
-
-	register_netdevice_notifier(&fib_netdev_notifier);
-	register_inetaddr_notifier(&fib_inetaddr_notifier);
-	nl_fib_lookup_init();
-
 	rtnl_register(PF_INET, RTM_NEWROUTE, inet_rtm_newroute, NULL);
 	rtnl_register(PF_INET, RTM_DELROUTE, inet_rtm_delroute, NULL);
 	rtnl_register(PF_INET, RTM_GETROUTE, NULL, inet_dump_fib);
+
+	register_pernet_subsys(&fib_net_ops);
+	register_netdevice_notifier(&fib_netdev_notifier);
+	register_inetaddr_notifier(&fib_inetaddr_notifier);
 }
 
 EXPORT_SYMBOL(inet_addr_type);
diff -Nurb linux-2.6.22-590/net/ipv4/fib_hash.c linux-2.6.22-try2-netns/net/ipv4/fib_hash.c
--- linux-2.6.22-590/net/ipv4/fib_hash.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/fib_hash.c	2007-12-19 22:49:18.000000000 -0500
@@ -40,6 +40,7 @@
 #include <net/route.h>
 #include <net/tcp.h>
 #include <net/sock.h>
+#include <net/net_namespace.h>
 #include <net/ip_fib.h>
 
 #include "fib_lookup.h"
@@ -274,11 +275,10 @@
 	return err;
 }
 
-static int fn_hash_last_dflt=-1;
-
 static void
 fn_hash_select_default(struct fib_table *tb, const struct flowi *flp, struct fib_result *res)
 {
+	struct net *net = flp->fl_net;
 	int order, last_idx;
 	struct hlist_node *node;
 	struct fib_node *f;
@@ -316,12 +316,12 @@
 				if (next_fi != res->fi)
 					break;
 			} else if (!fib_detect_death(fi, order, &last_resort,
-						     &last_idx, &fn_hash_last_dflt)) {
+						     &last_idx, &net->fn_hash_last_dflt)) {
 				if (res->fi)
 					fib_info_put(res->fi);
 				res->fi = fi;
 				atomic_inc(&fi->fib_clntref);
-				fn_hash_last_dflt = order;
+				net->fn_hash_last_dflt = order;
 				goto out;
 			}
 			fi = next_fi;
@@ -330,16 +330,16 @@
 	}
 
 	if (order <= 0 || fi == NULL) {
-		fn_hash_last_dflt = -1;
+		net->fn_hash_last_dflt = -1;
 		goto out;
 	}
 
-	if (!fib_detect_death(fi, order, &last_resort, &last_idx, &fn_hash_last_dflt)) {
+	if (!fib_detect_death(fi, order, &last_resort, &last_idx, &net->fn_hash_last_dflt)) {
 		if (res->fi)
 			fib_info_put(res->fi);
 		res->fi = fi;
 		atomic_inc(&fi->fib_clntref);
-		fn_hash_last_dflt = order;
+		net->fn_hash_last_dflt = order;
 		goto out;
 	}
 
@@ -350,7 +350,7 @@
 		if (last_resort)
 			atomic_inc(&last_resort->fib_clntref);
 	}
-	fn_hash_last_dflt = last_idx;
+	net->fn_hash_last_dflt = last_idx;
 out:
 	read_unlock(&fib_hash_lock);
 }
@@ -759,11 +759,15 @@
 	return skb->len;
 }
 
-#ifdef CONFIG_IP_MULTIPLE_TABLES
+void fib_hash_exit(struct fib_table *tb)
+{
+	if (!tb)
+		return;
+	fn_hash_flush(tb);
+	kfree(tb);
+}
+
 struct fib_table * fib_hash_init(u32 id)
-#else
-struct fib_table * __init fib_hash_init(u32 id)
-#endif
 {
 	struct fib_table *tb;
 
@@ -799,6 +803,7 @@
 #ifdef CONFIG_PROC_FS
 
 struct fib_iter_state {
+	struct net *net;
 	struct fn_zone	*zone;
 	int		bucket;
 	struct hlist_head *hash_head;
@@ -812,7 +817,8 @@
 static struct fib_alias *fib_get_first(struct seq_file *seq)
 {
 	struct fib_iter_state *iter = seq->private;
-	struct fn_hash *table = (struct fn_hash *) ip_fib_main_table->tb_data;
+	struct fib_table *main_table = fib_get_table(iter->net, RT_TABLE_MAIN);
+	struct fn_hash *table = (struct fn_hash *) main_table->tb_data;
 
 	iter->bucket    = 0;
 	iter->hash_head = NULL;
@@ -948,10 +954,11 @@
 
 static void *fib_seq_start(struct seq_file *seq, loff_t *pos)
 {
+	struct fib_iter_state *iter = seq->private;
 	void *v = NULL;
 
 	read_lock(&fib_hash_lock);
-	if (ip_fib_main_table)
+	if (fib_get_table(iter->net, RT_TABLE_MAIN))
 		v = *pos ? fib_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;
 	return v;
 }
@@ -1051,6 +1058,7 @@
 
 	seq	     = file->private_data;
 	seq->private = s;
+	s->net = get_net(PROC_NET(inode));
 out:
 	return rc;
 out_kfree:
@@ -1058,23 +1066,32 @@
 	goto out;
 }
 
+static int fib_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct fib_iter_state *iter = seq->private;
+	put_net(iter->net);
+	return seq_release_private(inode, file);
+}
+
 static const struct file_operations fib_seq_fops = {
 	.owner		= THIS_MODULE,
 	.open           = fib_seq_open,
 	.read           = seq_read,
 	.llseek         = seq_lseek,
-	.release	= seq_release_private,
+	.release	= fib_seq_release,
 };
 
-int __init fib_proc_init(void)
+int fib_proc_init(struct net *net)
 {
-	if (!proc_net_fops_create("route", S_IRUGO, &fib_seq_fops))
+	net->fn_hash_last_dflt = -1;
+	if (!proc_net_fops_create(net, "route", S_IRUGO, &fib_seq_fops))
 		return -ENOMEM;
 	return 0;
 }
 
-void __init fib_proc_exit(void)
+void fib_proc_exit(struct net *net)
 {
-	proc_net_remove("route");
+	proc_net_remove(net, "route");
 }
 #endif /* CONFIG_PROC_FS */
diff -Nurb linux-2.6.22-590/net/ipv4/fib_rules.c linux-2.6.22-try2-netns/net/ipv4/fib_rules.c
--- linux-2.6.22-590/net/ipv4/fib_rules.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/fib_rules.c	2007-12-19 22:49:18.000000000 -0500
@@ -32,8 +32,6 @@
 #include <net/ip_fib.h>
 #include <net/fib_rules.h>
 
-static struct fib_rules_ops fib4_rules_ops;
-
 struct fib4_rule
 {
 	struct fib_rule		common;
@@ -49,35 +47,14 @@
 #endif
 };
 
-static struct fib4_rule default_rule = {
-	.common = {
-		.refcnt =	ATOMIC_INIT(2),
-		.pref =		0x7FFF,
-		.table =	RT_TABLE_DEFAULT,
-		.action =	FR_ACT_TO_TBL,
-	},
+struct fib4_rule_table {
+	struct list_head	fib4_rules;
+	struct fib4_rule	default_rule;
+	struct fib4_rule	main_rule;
+	struct fib4_rule	local_rule;
+	struct fib_rules_ops	fib4_rules_ops;
 };
 
-static struct fib4_rule main_rule = {
-	.common = {
-		.refcnt =	ATOMIC_INIT(2),
-		.pref =		0x7FFE,
-		.table =	RT_TABLE_MAIN,
-		.action =	FR_ACT_TO_TBL,
-	},
-};
-
-static struct fib4_rule local_rule = {
-	.common = {
-		.refcnt =	ATOMIC_INIT(2),
-		.table =	RT_TABLE_LOCAL,
-		.action =	FR_ACT_TO_TBL,
-		.flags =	FIB_RULE_PERMANENT,
-	},
-};
-
-static LIST_HEAD(fib4_rules);
-
 #ifdef CONFIG_NET_CLS_ROUTE
 u32 fib_rules_tclass(struct fib_result *res)
 {
@@ -87,12 +64,14 @@
 
 int fib_lookup(struct flowi *flp, struct fib_result *res)
 {
+	struct net *net = flp->fl_net;
+	struct fib4_rule_table *table = net->fib4_table;
 	struct fib_lookup_arg arg = {
 		.result = res,
 	};
 	int err;
 
-	err = fib_rules_lookup(&fib4_rules_ops, flp, 0, &arg);
+	err = fib_rules_lookup(&table->fib4_rules_ops, flp, 0, &arg);
 	res->r = arg.rule;
 
 	return err;
@@ -122,7 +101,7 @@
 		goto errout;
 	}
 
-	if ((tbl = fib_get_table(rule->table)) == NULL)
+	if ((tbl = fib_get_table(flp->fl_net, rule->table)) == NULL)
 		goto errout;
 
 	err = tbl->tb_lookup(tbl, flp, (struct fib_result *) arg->result);
@@ -138,7 +117,7 @@
 	if (res->r && res->r->action == FR_ACT_TO_TBL &&
 	    FIB_RES_GW(*res) && FIB_RES_NH(*res).nh_scope == RT_SCOPE_LINK) {
 		struct fib_table *tb;
-		if ((tb = fib_get_table(res->r->table)) != NULL)
+		if ((tb = fib_get_table(flp->fl_net, res->r->table)) != NULL)
 			tb->tb_select_default(tb, flp, res);
 	}
 }
@@ -159,13 +138,13 @@
 	return 1;
 }
 
-static struct fib_table *fib_empty_table(void)
+static struct fib_table *fib_empty_table(struct net *net)
 {
 	u32 id;
 
 	for (id = 1; id <= RT_TABLE_MAX; id++)
-		if (fib_get_table(id) == NULL)
-			return fib_new_table(id);
+		if (fib_get_table(net, id) == NULL)
+			return fib_new_table(net, id);
 	return NULL;
 }
 
@@ -178,6 +157,7 @@
 			       struct nlmsghdr *nlh, struct fib_rule_hdr *frh,
 			       struct nlattr **tb)
 {
+	struct net *net = skb->sk->sk_net;
 	int err = -EINVAL;
 	struct fib4_rule *rule4 = (struct fib4_rule *) rule;
 
@@ -188,7 +168,7 @@
 		if (rule->action == FR_ACT_TO_TBL) {
 			struct fib_table *table;
 
-			table = fib_empty_table();
+			table = fib_empty_table(net);
 			if (table == NULL) {
 				err = -ENOBUFS;
 				goto errout;
@@ -274,14 +254,15 @@
 	return -ENOBUFS;
 }
 
-static u32 fib4_rule_default_pref(void)
+static u32 fib4_rule_default_pref(struct fib_rules_ops *ops)
 {
-	struct list_head *pos;
+	struct list_head *list, *pos;
 	struct fib_rule *rule;
 
-	if (!list_empty(&fib4_rules)) {
-		pos = fib4_rules.next;
-		if (pos->next != &fib4_rules) {
+	list = ops->rules_list;
+	if (!list_empty(list)) {
+		pos = list->next;
+		if (pos->next != list) {
 			rule = list_entry(pos->next, struct fib_rule, list);
 			if (rule->pref)
 				return rule->pref - 1;
@@ -298,12 +279,37 @@
 	       + nla_total_size(4); /* flow */
 }
 
-static void fib4_rule_flush_cache(void)
+static void fib4_rule_flush_cache(struct fib_rules_ops *ops)
 {
 	rt_cache_flush(-1);
 }
 
-static struct fib_rules_ops fib4_rules_ops = {
+static struct fib4_rule_table fib4_rule_table = {
+	.default_rule = {
+		.common = {
+			.refcnt =	ATOMIC_INIT(2),
+			.pref =		0x7FFF,
+			.table =	RT_TABLE_DEFAULT,
+			.action =	FR_ACT_TO_TBL,
+		},
+	},
+	.main_rule = {
+		.common = {
+			.refcnt =	ATOMIC_INIT(2),
+			.pref =		0x7FFE,
+			.table =	RT_TABLE_MAIN,
+			.action =	FR_ACT_TO_TBL,
+		},
+	},
+	.local_rule = {
+		.common = {
+			.refcnt =	ATOMIC_INIT(2),
+			.table =	RT_TABLE_LOCAL,
+			.action =	FR_ACT_TO_TBL,
+			.flags =	FIB_RULE_PERMANENT,
+		},
+	},
+	.fib4_rules_ops = {
 	.family		= AF_INET,
 	.rule_size	= sizeof(struct fib4_rule),
 	.addr_size	= sizeof(u32),
@@ -317,15 +323,34 @@
 	.flush_cache	= fib4_rule_flush_cache,
 	.nlgroup	= RTNLGRP_IPV4_RULE,
 	.policy		= fib4_rule_policy,
-	.rules_list	= &fib4_rules,
+		.rules_list	= &fib4_rule_table.fib4_rules, /* &fib4_rules, */
 	.owner		= THIS_MODULE,
+	},
 };
 
-void __init fib4_rules_init(void)
+
+void fib4_rules_init(struct net *net)
 {
-	list_add_tail(&local_rule.common.list, &fib4_rules);
-	list_add_tail(&main_rule.common.list, &fib4_rules);
-	list_add_tail(&default_rule.common.list, &fib4_rules);
+	struct fib4_rule_table *table;
+	table = kmemdup(&fib4_rule_table, sizeof(*table), GFP_KERNEL);
+	if (!table)
+		return;
+	INIT_LIST_HEAD(&table->fib4_rules);
+	list_add_tail(&table->local_rule.common.list,   &table->fib4_rules);
+	list_add_tail(&table->main_rule.common.list,    &table->fib4_rules);
+	list_add_tail(&table->default_rule.common.list, &table->fib4_rules);
+	table->fib4_rules_ops.rules_list = &table->fib4_rules;
+	if (fib_rules_register(net, &table->fib4_rules_ops)) {
+		kfree(table);
+		return;
+	}
+	net->fib4_table = table;
+}
 
-	fib_rules_register(&fib4_rules_ops);
+void fib4_rules_exit(struct net *net)
+{
+	struct fib4_rule_table *table = net->fib4_table;
+	if (table)
+		fib_rules_unregister(net, &table->fib4_rules_ops);
+	kfree(table);
 }
diff -Nurb linux-2.6.22-590/net/ipv4/fib_semantics.c linux-2.6.22-try2-netns/net/ipv4/fib_semantics.c
--- linux-2.6.22-590/net/ipv4/fib_semantics.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/fib_semantics.c	2007-12-19 22:49:18.000000000 -0500
@@ -50,14 +50,9 @@
 #define FSprintk(a...)
 
 static DEFINE_SPINLOCK(fib_info_lock);
-static struct hlist_head *fib_info_hash;
-static struct hlist_head *fib_info_laddrhash;
-static unsigned int fib_hash_size;
-static unsigned int fib_info_cnt;
 
 #define DEVINDEX_HASHBITS 8
 #define DEVINDEX_HASHSIZE (1U << DEVINDEX_HASHBITS)
-static struct hlist_head fib_info_devhash[DEVINDEX_HASHSIZE];
 
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
 
@@ -153,7 +148,8 @@
 			dev_put(nh->nh_dev);
 		nh->nh_dev = NULL;
 	} endfor_nexthops(fi);
-	fib_info_cnt--;
+	fi->fib_net->fib_info_cnt--;
+	release_net(fi->fib_net);
 	kfree(fi);
 }
 
@@ -196,9 +192,9 @@
 	return 0;
 }
 
-static inline unsigned int fib_info_hashfn(const struct fib_info *fi)
+static inline unsigned int fib_info_hashfn(struct net *net, const struct fib_info *fi)
 {
-	unsigned int mask = (fib_hash_size - 1);
+	unsigned int mask = net->fib_info_hash_size - 1;
 	unsigned int val = fi->fib_nhs;
 
 	val ^= fi->fib_protocol;
@@ -208,15 +204,15 @@
 	return (val ^ (val >> 7) ^ (val >> 12)) & mask;
 }
 
-static struct fib_info *fib_find_info(const struct fib_info *nfi)
+static struct fib_info *fib_find_info(struct net *net, const struct fib_info *nfi)
 {
 	struct hlist_head *head;
 	struct hlist_node *node;
 	struct fib_info *fi;
 	unsigned int hash;
 
-	hash = fib_info_hashfn(nfi);
-	head = &fib_info_hash[hash];
+	hash = fib_info_hashfn(net, nfi);
+	head = &net->fib_info_hash[hash];
 
 	hlist_for_each_entry(fi, node, head, fib_hash) {
 		if (fi->fib_nhs != nfi->fib_nhs)
@@ -249,6 +245,7 @@
 
 int ip_fib_check_default(__be32 gw, struct net_device *dev)
 {
+	struct net *net = dev->nd_net;
 	struct hlist_head *head;
 	struct hlist_node *node;
 	struct fib_nh *nh;
@@ -257,7 +254,7 @@
 	spin_lock(&fib_info_lock);
 
 	hash = fib_devindex_hashfn(dev->ifindex);
-	head = &fib_info_devhash[hash];
+	head = &net->fib_info_devhash[hash];
 	hlist_for_each_entry(nh, node, head, nh_hash) {
 		if (nh->nh_dev == dev &&
 		    nh->nh_gw == gw &&
@@ -320,11 +317,11 @@
 		kfree_skb(skb);
 		goto errout;
 	}
-	err = rtnl_notify(skb, info->pid, RTNLGRP_IPV4_ROUTE,
+	err = rtnl_notify(skb, info->net, info->pid, RTNLGRP_IPV4_ROUTE,
 			  info->nlh, GFP_KERNEL);
 errout:
 	if (err < 0)
-		rtnl_set_sk_err(RTNLGRP_IPV4_ROUTE, err);
+		rtnl_set_sk_err(info->net, RTNLGRP_IPV4_ROUTE, err);
 }
 
 /* Return the first fib alias matching TOS with
@@ -517,6 +514,7 @@
 static int fib_check_nh(struct fib_config *cfg, struct fib_info *fi,
 			struct fib_nh *nh)
 {
+	struct net *net = cfg->fc_nlinfo.net;
 	int err;
 
 	if (nh->nh_gw) {
@@ -531,9 +529,9 @@
 
 			if (cfg->fc_scope >= RT_SCOPE_LINK)
 				return -EINVAL;
-			if (inet_addr_type(nh->nh_gw) != RTN_UNICAST)
+			if (inet_addr_type(net, nh->nh_gw) != RTN_UNICAST)
 				return -EINVAL;
-			if ((dev = __dev_get_by_index(nh->nh_oif)) == NULL)
+			if ((dev = __dev_get_by_index(net, nh->nh_oif)) == NULL)
 				return -ENODEV;
 			if (!(dev->flags&IFF_UP))
 				return -ENETDOWN;
@@ -544,6 +542,7 @@
 		}
 		{
 			struct flowi fl = {
+				.fl_net = net,
 				.nl_u = {
 					.ip4_u = {
 						.daddr = nh->nh_gw,
@@ -580,7 +579,7 @@
 		if (nh->nh_flags&(RTNH_F_PERVASIVE|RTNH_F_ONLINK))
 			return -EINVAL;
 
-		in_dev = inetdev_by_index(nh->nh_oif);
+		in_dev = inetdev_by_index(net, nh->nh_oif);
 		if (in_dev == NULL)
 			return -ENODEV;
 		if (!(in_dev->dev->flags&IFF_UP)) {
@@ -595,9 +594,9 @@
 	return 0;
 }
 
-static inline unsigned int fib_laddr_hashfn(__be32 val)
+static inline unsigned int fib_laddr_hashfn(struct net *net, __be32 val)
 {
-	unsigned int mask = (fib_hash_size - 1);
+	unsigned int mask = net->fib_info_hash_size - 1;
 
 	return ((__force u32)val ^ ((__force u32)val >> 7) ^ ((__force u32)val >> 14)) & mask;
 }
@@ -622,21 +621,22 @@
 		free_pages((unsigned long) hash, get_order(bytes));
 }
 
-static void fib_hash_move(struct hlist_head *new_info_hash,
+static void fib_hash_move(struct net *net,
+			  struct hlist_head *new_info_hash,
 			  struct hlist_head *new_laddrhash,
 			  unsigned int new_size)
 {
 	struct hlist_head *old_info_hash, *old_laddrhash;
-	unsigned int old_size = fib_hash_size;
+	unsigned int old_size = net->fib_info_hash_size;
 	unsigned int i, bytes;
 
 	spin_lock_bh(&fib_info_lock);
-	old_info_hash = fib_info_hash;
-	old_laddrhash = fib_info_laddrhash;
-	fib_hash_size = new_size;
+	old_info_hash = net->fib_info_hash;
+	old_laddrhash = net->fib_info_laddrhash;
+	net->fib_info_hash_size = new_size;
 
 	for (i = 0; i < old_size; i++) {
-		struct hlist_head *head = &fib_info_hash[i];
+		struct hlist_head *head = &net->fib_info_hash[i];
 		struct hlist_node *node, *n;
 		struct fib_info *fi;
 
@@ -646,15 +646,15 @@
 
 			hlist_del(&fi->fib_hash);
 
-			new_hash = fib_info_hashfn(fi);
+			new_hash = fib_info_hashfn(net, fi);
 			dest = &new_info_hash[new_hash];
 			hlist_add_head(&fi->fib_hash, dest);
 		}
 	}
-	fib_info_hash = new_info_hash;
+	net->fib_info_hash = new_info_hash;
 
 	for (i = 0; i < old_size; i++) {
-		struct hlist_head *lhead = &fib_info_laddrhash[i];
+		struct hlist_head *lhead = &net->fib_info_laddrhash[i];
 		struct hlist_node *node, *n;
 		struct fib_info *fi;
 
@@ -664,12 +664,12 @@
 
 			hlist_del(&fi->fib_lhash);
 
-			new_hash = fib_laddr_hashfn(fi->fib_prefsrc);
+			new_hash = fib_laddr_hashfn(net, fi->fib_prefsrc);
 			ldest = &new_laddrhash[new_hash];
 			hlist_add_head(&fi->fib_lhash, ldest);
 		}
 	}
-	fib_info_laddrhash = new_laddrhash;
+	net->fib_info_laddrhash = new_laddrhash;
 
 	spin_unlock_bh(&fib_info_lock);
 
@@ -680,6 +680,7 @@
 
 struct fib_info *fib_create_info(struct fib_config *cfg)
 {
+	struct net *net = cfg->fc_nlinfo.net;
 	int err;
 	struct fib_info *fi = NULL;
 	struct fib_info *ofi;
@@ -698,8 +699,8 @@
 #endif
 
 	err = -ENOBUFS;
-	if (fib_info_cnt >= fib_hash_size) {
-		unsigned int new_size = fib_hash_size << 1;
+	if (net->fib_info_cnt >= net->fib_info_hash_size) {
+		unsigned int new_size = net->fib_info_hash_size << 1;
 		struct hlist_head *new_info_hash;
 		struct hlist_head *new_laddrhash;
 		unsigned int bytes;
@@ -716,18 +717,19 @@
 			memset(new_info_hash, 0, bytes);
 			memset(new_laddrhash, 0, bytes);
 
-			fib_hash_move(new_info_hash, new_laddrhash, new_size);
+			fib_hash_move(net, new_info_hash, new_laddrhash, new_size);
 		}
 
-		if (!fib_hash_size)
+		if (!net->fib_info_hash_size)
 			goto failure;
 	}
 
 	fi = kzalloc(sizeof(*fi)+nhs*sizeof(struct fib_nh), GFP_KERNEL);
 	if (fi == NULL)
 		goto failure;
-	fib_info_cnt++;
+	net->fib_info_cnt++;
 
+	fi->fib_net = hold_net(net);
 	fi->fib_protocol = cfg->fc_protocol;
 	fi->fib_flags = cfg->fc_flags;
 	fi->fib_priority = cfg->fc_priority;
@@ -799,7 +801,7 @@
 		if (nhs != 1 || nh->nh_gw)
 			goto err_inval;
 		nh->nh_scope = RT_SCOPE_NOWHERE;
-		nh->nh_dev = dev_get_by_index(fi->fib_nh->nh_oif);
+		nh->nh_dev = dev_get_by_index(net, fi->fib_nh->nh_oif);
 		err = -ENODEV;
 		if (nh->nh_dev == NULL)
 			goto failure;
@@ -813,12 +815,12 @@
 	if (fi->fib_prefsrc) {
 		if (cfg->fc_type != RTN_LOCAL || !cfg->fc_dst ||
 		    fi->fib_prefsrc != cfg->fc_dst)
-			if (inet_addr_type(fi->fib_prefsrc) != RTN_LOCAL)
+			if (inet_addr_type(net, fi->fib_prefsrc) != RTN_LOCAL)
 				goto err_inval;
 	}
 
 link_it:
-	if ((ofi = fib_find_info(fi)) != NULL) {
+	if ((ofi = fib_find_info(net, fi)) != NULL) {
 		fi->fib_dead = 1;
 		free_fib_info(fi);
 		ofi->fib_treeref++;
@@ -829,11 +831,13 @@
 	atomic_inc(&fi->fib_clntref);
 	spin_lock_bh(&fib_info_lock);
 	hlist_add_head(&fi->fib_hash,
-		       &fib_info_hash[fib_info_hashfn(fi)]);
+		       &net->fib_info_hash[fib_info_hashfn(net, fi)]);
 	if (fi->fib_prefsrc) {
 		struct hlist_head *head;
+		unsigned int hash;
 
-		head = &fib_info_laddrhash[fib_laddr_hashfn(fi->fib_prefsrc)];
+		hash = fib_laddr_hashfn(net, fi->fib_prefsrc);
+		head = &net->fib_info_laddrhash[hash];
 		hlist_add_head(&fi->fib_lhash, head);
 	}
 	change_nexthops(fi) {
@@ -843,7 +847,7 @@
 		if (!nh->nh_dev)
 			continue;
 		hash = fib_devindex_hashfn(nh->nh_dev->ifindex);
-		head = &fib_info_devhash[hash];
+		head = &net->fib_info_devhash[hash];
 		hlist_add_head(&nh->nh_hash, head);
 	} endfor_nexthops(fi)
 	spin_unlock_bh(&fib_info_lock);
@@ -1030,7 +1034,7 @@
    - device went down -> we must shutdown all nexthops going via it.
  */
 
-int fib_sync_down(__be32 local, struct net_device *dev, int force)
+int fib_sync_down(struct net *net, __be32 local, struct net_device *dev, int force)
 {
 	int ret = 0;
 	int scope = RT_SCOPE_NOWHERE;
@@ -1038,9 +1042,9 @@
 	if (force)
 		scope = -1;
 
-	if (local && fib_info_laddrhash) {
-		unsigned int hash = fib_laddr_hashfn(local);
-		struct hlist_head *head = &fib_info_laddrhash[hash];
+	if (local && net->fib_info_laddrhash) {
+		unsigned int hash = fib_laddr_hashfn(net, local);
+		struct hlist_head *head = &net->fib_info_laddrhash[hash];
 		struct hlist_node *node;
 		struct fib_info *fi;
 
@@ -1055,7 +1059,7 @@
 	if (dev) {
 		struct fib_info *prev_fi = NULL;
 		unsigned int hash = fib_devindex_hashfn(dev->ifindex);
-		struct hlist_head *head = &fib_info_devhash[hash];
+		struct hlist_head *head = &net->fib_info_devhash[hash];
 		struct hlist_node *node;
 		struct fib_nh *nh;
 
@@ -1108,6 +1112,7 @@
 
 int fib_sync_up(struct net_device *dev)
 {
+	struct net *net = dev->nd_net;
 	struct fib_info *prev_fi;
 	unsigned int hash;
 	struct hlist_head *head;
@@ -1120,7 +1125,7 @@
 
 	prev_fi = NULL;
 	hash = fib_devindex_hashfn(dev->ifindex);
-	head = &fib_info_devhash[hash];
+	head = &net->fib_info_devhash[hash];
 	ret = 0;
 
 	hlist_for_each_entry(nh, node, head, nh_hash) {
@@ -1210,3 +1215,17 @@
 	spin_unlock_bh(&fib_multipath_lock);
 }
 #endif
+
+int fib_info_init(struct net *net)
+{
+	net->fib_info_devhash = kzalloc(
+		sizeof(struct hlist_head)*DEVINDEX_HASHSIZE, GFP_KERNEL);
+	if (!net->fib_info_devhash)
+		return -ENOMEM;
+	return 0;
+}
+
+void fib_info_exit(struct net *net)
+{
+	kfree(net->fib_info_devhash);
+}
diff -Nurb linux-2.6.22-590/net/ipv4/fib_trie.c linux-2.6.22-try2-netns/net/ipv4/fib_trie.c
--- linux-2.6.22-590/net/ipv4/fib_trie.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/fib_trie.c	2007-12-19 22:49:18.000000000 -0500
@@ -78,6 +78,7 @@
 #include <net/route.h>
 #include <net/tcp.h>
 #include <net/sock.h>
+#include <net/net_namespace.h>
 #include <net/ip_fib.h>
 #include "fib_lookup.h"
 
@@ -172,7 +173,6 @@
 static void tnode_free(struct tnode *tn);
 
 static struct kmem_cache *fn_alias_kmem __read_mostly;
-static struct trie *trie_local = NULL, *trie_main = NULL;
 
 
 /* rcu_read_lock needs to be hold by caller from readside */
@@ -290,11 +290,10 @@
 	WARN_ON(tn && tn->pos+tn->bits > 32);
 }
 
-static int halve_threshold = 25;
-static int inflate_threshold = 50;
-static int halve_threshold_root = 8;
-static int inflate_threshold_root = 15;
-
+static const int halve_threshold = 25;
+static const int inflate_threshold = 50;
+static const int halve_threshold_root = 15;
+static const int inflate_threshold_root = 25;
 
 static void __alias_free_mem(struct rcu_head *head)
 {
@@ -1771,11 +1770,10 @@
 	return found;
 }
 
-static int trie_last_dflt = -1;
-
 static void
 fn_trie_select_default(struct fib_table *tb, const struct flowi *flp, struct fib_result *res)
 {
+	struct net *net = flp->fl_net;
 	struct trie *t = (struct trie *) tb->tb_data;
 	int order, last_idx;
 	struct fib_info *fi = NULL;
@@ -1819,28 +1817,28 @@
 			if (next_fi != res->fi)
 				break;
 		} else if (!fib_detect_death(fi, order, &last_resort,
-					     &last_idx, &trie_last_dflt)) {
+					     &last_idx, &net->trie_last_dflt)) {
 			if (res->fi)
 				fib_info_put(res->fi);
 			res->fi = fi;
 			atomic_inc(&fi->fib_clntref);
-			trie_last_dflt = order;
+			net->trie_last_dflt = order;
 			goto out;
 		}
 		fi = next_fi;
 		order++;
 	}
 	if (order <= 0 || fi == NULL) {
-		trie_last_dflt = -1;
+		net->trie_last_dflt = -1;
 		goto out;
 	}
 
-	if (!fib_detect_death(fi, order, &last_resort, &last_idx, &trie_last_dflt)) {
+	if (!fib_detect_death(fi, order, &last_resort, &last_idx, &net->trie_last_dflt)) {
 		if (res->fi)
 			fib_info_put(res->fi);
 		res->fi = fi;
 		atomic_inc(&fi->fib_clntref);
-		trie_last_dflt = order;
+		net->trie_last_dflt = order;
 		goto out;
 	}
 	if (last_idx >= 0) {
@@ -1850,7 +1848,7 @@
 		if (last_resort)
 			atomic_inc(&last_resort->fib_clntref);
 	}
-	trie_last_dflt = last_idx;
+	net->trie_last_dflt = last_idx;
  out:;
 	rcu_read_unlock();
 }
@@ -1957,11 +1955,15 @@
 
 /* Fix more generic FIB names for init later */
 
-#ifdef CONFIG_IP_MULTIPLE_TABLES
+void fib_hash_exit(struct fib_table *tb)
+{
+	if (!tb)
+		return;
+	fn_trie_flush(tb);
+	kfree(tb);
+}
+
 struct fib_table * fib_hash_init(u32 id)
-#else
-struct fib_table * __init fib_hash_init(u32 id)
-#endif
 {
 	struct fib_table *tb;
 	struct trie *t;
@@ -1991,11 +1993,6 @@
 	trie_init(t);
 
 	if (id == RT_TABLE_LOCAL)
-		trie_local = t;
-	else if (id == RT_TABLE_MAIN)
-		trie_main = t;
-
-	if (id == RT_TABLE_LOCAL)
 		printk(KERN_INFO "IPv4 FIB: Using LC-trie version %s\n", VERSION);
 
 	return tb;
@@ -2004,6 +2001,8 @@
 #ifdef CONFIG_PROC_FS
 /* Depth first Trie walk iterator */
 struct fib_trie_iter {
+	struct net *net;
+	struct trie *trie_local, *trie_main;
 	struct tnode *tnode;
 	struct trie *trie;
 	unsigned index;
@@ -2170,7 +2169,21 @@
 
 static int fib_triestat_seq_show(struct seq_file *seq, void *v)
 {
+	struct net *net = seq->private;
+	struct trie *trie_local, *trie_main;
 	struct trie_stat *stat;
+	struct fib_table *tb;
+
+	trie_local = NULL;
+	tb = fib_get_table(net, RT_TABLE_LOCAL);
+	if (tb)
+		trie_local = (struct trie *) tb->tb_data;
+
+	trie_main = NULL;
+	tb = fib_get_table(net, RT_TABLE_MAIN);
+	if (tb)
+		trie_main = (struct trie *) tb->tb_data;
+
 
 	stat = kmalloc(sizeof(*stat), GFP_KERNEL);
 	if (!stat)
@@ -2197,7 +2210,15 @@
 
 static int fib_triestat_seq_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, fib_triestat_seq_show, NULL);
+	return single_open(file, fib_triestat_seq_show, 
+				get_net(PROC_NET(inode)));
+}
+
+static int fib_triestat_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	put_net(seq->private);
+	return single_release(inode, file);
 }
 
 static const struct file_operations fib_triestat_fops = {
@@ -2205,7 +2226,7 @@
 	.open	= fib_triestat_seq_open,
 	.read	= seq_read,
 	.llseek	= seq_lseek,
-	.release = single_release,
+	.release = fib_triestat_seq_release,
 };
 
 static struct node *fib_trie_get_idx(struct fib_trie_iter *iter,
@@ -2214,13 +2235,13 @@
 	loff_t idx = 0;
 	struct node *n;
 
-	for (n = fib_trie_get_first(iter, trie_local);
+	for (n = fib_trie_get_first(iter, iter->trie_local);
 	     n; ++idx, n = fib_trie_get_next(iter)) {
 		if (pos == idx)
 			return n;
 	}
 
-	for (n = fib_trie_get_first(iter, trie_main);
+	for (n = fib_trie_get_first(iter, iter->trie_main);
 	     n; ++idx, n = fib_trie_get_next(iter)) {
 		if (pos == idx)
 			return n;
@@ -2230,10 +2251,23 @@
 
 static void *fib_trie_seq_start(struct seq_file *seq, loff_t *pos)
 {
+	struct fib_trie_iter *iter = seq->private;
+	struct fib_table *tb;
+
+	if (!iter->trie_local) {
+		tb = fib_get_table(iter->net, RT_TABLE_LOCAL);
+		if (tb)
+			iter->trie_local = (struct trie *) tb->tb_data;
+	}
+	if (!iter->trie_main) {
+		tb = fib_get_table(iter->net, RT_TABLE_MAIN);
+		if (tb)
+			iter->trie_main = (struct trie *) tb->tb_data;
+	}
 	rcu_read_lock();
 	if (*pos == 0)
 		return SEQ_START_TOKEN;
-	return fib_trie_get_idx(seq->private, *pos - 1);
+	return fib_trie_get_idx(iter, *pos - 1);
 }
 
 static void *fib_trie_seq_next(struct seq_file *seq, void *v, loff_t *pos)
@@ -2251,8 +2285,8 @@
 		return v;
 
 	/* continue scan in next trie */
-	if (iter->trie == trie_local)
-		return fib_trie_get_first(iter, trie_main);
+	if (iter->trie == iter->trie_local)
+		return fib_trie_get_first(iter, iter->trie_main);
 
 	return NULL;
 }
@@ -2318,7 +2352,7 @@
 		return 0;
 
 	if (!NODE_PARENT(n)) {
-		if (iter->trie == trie_local)
+		if (iter->trie == iter->trie_local)
 			seq_puts(seq, "<local>:\n");
 		else
 			seq_puts(seq, "<main>:\n");
@@ -2384,6 +2418,7 @@
 	seq	     = file->private_data;
 	seq->private = s;
 	memset(s, 0, sizeof(*s));
+	s->net = get_net(PROC_NET(inode));
 out:
 	return rc;
 out_kfree:
@@ -2391,12 +2426,20 @@
 	goto out;
 }
 
+static int fib_trie_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct fib_trie_iter *iter = seq->private;
+	put_net(iter->net);
+	return seq_release_private(inode, file);
+}
+
 static const struct file_operations fib_trie_fops = {
 	.owner  = THIS_MODULE,
 	.open   = fib_trie_seq_open,
 	.read   = seq_read,
 	.llseek = seq_lseek,
-	.release = seq_release_private,
+	.release = fib_trie_seq_release,
 };
 
 static unsigned fib_flag_trans(int type, __be32 mask, const struct fib_info *fi)
@@ -2434,7 +2477,7 @@
 		return 0;
 	}
 
-	if (iter->trie == trie_local)
+	if (iter->trie == iter->trie_local)
 		return 0;
 	if (IS_TNODE(l))
 		return 0;
@@ -2505,6 +2548,7 @@
 	seq	     = file->private_data;
 	seq->private = s;
 	memset(s, 0, sizeof(*s));
+	s->net = get_net(PROC_NET(inode));
 out:
 	return rc;
 out_kfree:
@@ -2517,35 +2561,37 @@
 	.open   = fib_route_seq_open,
 	.read   = seq_read,
 	.llseek = seq_lseek,
-	.release = seq_release_private,
+	.release = fib_trie_seq_release,
 };
 
-int __init fib_proc_init(void)
+int fib_proc_init(struct net *net)
 {
-	if (!proc_net_fops_create("fib_trie", S_IRUGO, &fib_trie_fops))
+	net->trie_last_dflt = -1;
+
+	if (!proc_net_fops_create(net, "fib_trie", S_IRUGO, &fib_trie_fops))
 		goto out1;
 
-	if (!proc_net_fops_create("fib_triestat", S_IRUGO, &fib_triestat_fops))
+	if (!proc_net_fops_create(net, "fib_triestat", S_IRUGO, &fib_triestat_fops))
 		goto out2;
 
-	if (!proc_net_fops_create("route", S_IRUGO, &fib_route_fops))
+	if (!proc_net_fops_create(net, "route", S_IRUGO, &fib_route_fops))
 		goto out3;
 
 	return 0;
 
 out3:
-	proc_net_remove("fib_triestat");
+	proc_net_remove(net, "fib_triestat");
 out2:
-	proc_net_remove("fib_trie");
+	proc_net_remove(net, "fib_trie");
 out1:
 	return -ENOMEM;
 }
 
-void __init fib_proc_exit(void)
+void fib_proc_exit(struct net *net)
 {
-	proc_net_remove("fib_trie");
-	proc_net_remove("fib_triestat");
-	proc_net_remove("route");
+	proc_net_remove(net, "fib_trie");
+	proc_net_remove(net, "fib_triestat");
+	proc_net_remove(net, "route");
 }
 
 #endif /* CONFIG_PROC_FS */
diff -Nurb linux-2.6.22-590/net/ipv4/icmp.c linux-2.6.22-try2-netns/net/ipv4/icmp.c
--- linux-2.6.22-590/net/ipv4/icmp.c	2007-12-21 15:33:47.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/icmp.c	2007-12-19 22:49:18.000000000 -0500
@@ -229,14 +229,13 @@
  *
  *	On SMP we have one ICMP socket per-cpu.
  */
-static DEFINE_PER_CPU(struct socket *, __icmp_socket) = NULL;
-#define icmp_socket	__get_cpu_var(__icmp_socket)
+#define icmp_socket(NET) (*per_cpu_ptr((NET)->__icmp_socket, smp_processor_id()))
 
-static __inline__ int icmp_xmit_lock(void)
+static __inline__ int icmp_xmit_lock(struct net *net)
 {
 	local_bh_disable();
 
-	if (unlikely(!spin_trylock(&icmp_socket->sk->sk_lock.slock))) {
+	if (unlikely(!spin_trylock(&icmp_socket(net)->sk->sk_lock.slock))) {
 		/* This can happen if the output path signals a
 		 * dst_link_failure() for an outgoing ICMP packet.
 		 */
@@ -246,9 +245,9 @@
 	return 0;
 }
 
-static void icmp_xmit_unlock(void)
+static void icmp_xmit_unlock(struct net *net)
 {
-	spin_unlock_bh(&icmp_socket->sk->sk_lock.slock);
+	spin_unlock_bh(&icmp_socket(net)->sk->sk_lock.slock);
 }
 
 /*
@@ -347,19 +346,20 @@
 static void icmp_push_reply(struct icmp_bxm *icmp_param,
 			    struct ipcm_cookie *ipc, struct rtable *rt)
 {
+	struct net *net = icmp_param->skb->dev->nd_net;
 	struct sk_buff *skb;
 
-	if (ip_append_data(icmp_socket->sk, icmp_glue_bits, icmp_param,
+	if (ip_append_data(icmp_socket(net)->sk, icmp_glue_bits, icmp_param,
 			   icmp_param->data_len+icmp_param->head_len,
 			   icmp_param->head_len,
 			   ipc, rt, MSG_DONTWAIT) < 0)
-		ip_flush_pending_frames(icmp_socket->sk);
-	else if ((skb = skb_peek(&icmp_socket->sk->sk_write_queue)) != NULL) {
+		ip_flush_pending_frames(icmp_socket(net)->sk);
+	else if ((skb = skb_peek(&icmp_socket(net)->sk->sk_write_queue)) != NULL) {
 		struct icmphdr *icmph = icmp_hdr(skb);
 		__wsum csum = 0;
 		struct sk_buff *skb1;
 
-		skb_queue_walk(&icmp_socket->sk->sk_write_queue, skb1) {
+		skb_queue_walk(&icmp_socket(net)->sk->sk_write_queue, skb1) {
 			csum = csum_add(csum, skb1->csum);
 		}
 		csum = csum_partial_copy_nocheck((void *)&icmp_param->data,
@@ -367,7 +367,7 @@
 						 icmp_param->head_len, csum);
 		icmph->checksum = csum_fold(csum);
 		skb->ip_summed = CHECKSUM_NONE;
-		ip_push_pending_frames(icmp_socket->sk);
+		ip_push_pending_frames(icmp_socket(net)->sk);
 	}
 }
 
@@ -377,7 +377,8 @@
 
 static void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)
 {
-	struct sock *sk = icmp_socket->sk;
+	struct net *net = icmp_param->skb->dev->nd_net;
+	struct sock *sk = icmp_socket(net)->sk;
 	struct inet_sock *inet = inet_sk(sk);
 	struct ipcm_cookie ipc;
 	struct rtable *rt = (struct rtable *)skb->dst;
@@ -386,7 +387,7 @@
 	if (ip_options_echo(&icmp_param->replyopts, skb))
 		return;
 
-	if (icmp_xmit_lock())
+	if (icmp_xmit_lock(net))
 		return;
 
 	icmp_param->data.icmph.checksum = 0;
@@ -401,7 +402,8 @@
 			daddr = icmp_param->replyopts.faddr;
 	}
 	{
-		struct flowi fl = { .nl_u = { .ip4_u =
+		struct flowi fl = { .fl_net = net,
+				    .nl_u = { .ip4_u =
 					      { .daddr = daddr,
 						.saddr = rt->rt_spec_dst,
 						.tos = RT_TOS(ip_hdr(skb)->tos) } },
@@ -415,7 +417,7 @@
 		icmp_push_reply(icmp_param, &ipc, rt);
 	ip_rt_put(rt);
 out_unlock:
-	icmp_xmit_unlock();
+	icmp_xmit_unlock(net);
 }
 
 
@@ -436,6 +438,7 @@
 	int room;
 	struct icmp_bxm icmp_param;
 	struct rtable *rt = (struct rtable *)skb_in->dst;
+	struct net *net;
 	struct ipcm_cookie ipc;
 	__be32 saddr;
 	u8  tos;
@@ -443,6 +446,7 @@
 	if (!rt)
 		goto out;
 
+	net = rt->fl.fl_net;
 	/*
 	 *	Find the original header. It is expected to be valid, of course.
 	 *	Check this, icmp_send is called from the most obscure devices
@@ -505,7 +509,7 @@
 		}
 	}
 
-	if (icmp_xmit_lock())
+	if (icmp_xmit_lock(net))
 		return;
 
 	/*
@@ -517,7 +521,7 @@
 		struct net_device *dev = NULL;
 
 		if (rt->fl.iif && sysctl_icmp_errors_use_inbound_ifaddr)
-			dev = dev_get_by_index(rt->fl.iif);
+			dev = dev_get_by_index(&init_net, rt->fl.iif);
 
 		if (dev) {
 			saddr = inet_select_addr(dev, 0, RT_SCOPE_LINK);
@@ -545,12 +549,13 @@
 	icmp_param.skb	  = skb_in;
 	icmp_param.offset = skb_network_offset(skb_in);
 	icmp_out_count(icmp_param.data.icmph.type);
-	inet_sk(icmp_socket->sk)->tos = tos;
+	inet_sk(icmp_socket(net)->sk)->tos = tos;
 	ipc.addr = iph->saddr;
 	ipc.opt = &icmp_param.replyopts;
 
 	{
 		struct flowi fl = {
+			.fl_net = net,
 			.nl_u = {
 				.ip4_u = {
 					.daddr = icmp_param.replyopts.srr ?
@@ -593,7 +598,7 @@
 ende:
 	ip_rt_put(rt);
 out_unlock:
-	icmp_xmit_unlock();
+	icmp_xmit_unlock(net);
 out:;
 }
 
@@ -604,6 +609,7 @@
 
 static void icmp_unreach(struct sk_buff *skb)
 {
+	struct net *net = skb->dev->nd_net;
 	struct iphdr *iph;
 	struct icmphdr *icmph;
 	int hash, protocol;
@@ -634,7 +640,7 @@
 		case ICMP_PORT_UNREACH:
 			break;
 		case ICMP_FRAG_NEEDED:
-			if (ipv4_config.no_pmtu_disc) {
+			if (net->sysctl_ipv4_no_pmtu_disc) {
 				LIMIT_NETDEBUG(KERN_INFO "ICMP: %u.%u.%u.%u: "
 							 "fragmentation needed "
 							 "and DF set.\n",
@@ -678,7 +684,7 @@
 	 */
 
 	if (!sysctl_icmp_ignore_bogus_error_responses &&
-	    inet_addr_type(iph->daddr) == RTN_BROADCAST) {
+	    inet_addr_type(net, iph->daddr) == RTN_BROADCAST) {
 		if (net_ratelimit())
 			printk(KERN_WARNING "%u.%u.%u.%u sent an invalid ICMP "
 					    "type %u, code %u "
@@ -707,7 +713,7 @@
 	hash = protocol & (MAX_INET_PROTOS - 1);
 	read_lock(&raw_v4_lock);
 	if ((raw_sk = sk_head(&raw_v4_htable[hash])) != NULL) {
-		while ((raw_sk = __raw_v4_lookup(raw_sk, protocol, iph->daddr,
+		while ((raw_sk = __raw_v4_lookup(net, raw_sk, protocol, iph->daddr,
 						 iph->saddr,
 						 skb->dev->ifindex, skb->skb_tag)) != NULL) {
 			raw_err(raw_sk, skb, info);
@@ -1179,29 +1185,54 @@
 	},
 };
 
-void __init icmp_init(struct net_proto_family *ops)
+static void icmp_net_exit(struct net *net)
 {
-	struct inet_sock *inet;
+	struct socket **sock;
 	int i;
 
 	for_each_possible_cpu(i) {
+		sock = percpu_ptr(net->__icmp_socket, i);
+		if (!*sock)
+			continue;
+		/* At the last minute lie and say this is a socket for
+		 * the initial network namespace.  So the socket will
+		 * be safe to free. 
+		 */
+		(*sock)->sk->sk_net = get_net(&init_net);
+		sock_release(*sock);
+		*sock = NULL;
+	}
+	percpu_free(net->__icmp_socket);
+}
+
+static int icmp_net_init(struct net *net)
+{
+	struct socket **sock;
+	struct inet_sock *inet;
 		int err;
+	int i;
+
+	net->__icmp_socket = alloc_percpu(struct socket *);
+	if (!net->__icmp_socket)
+		return -ENOMEM;
+	
+	for_each_possible_cpu(i) {
 
-		err = sock_create_kern(PF_INET, SOCK_RAW, IPPROTO_ICMP,
-				       &per_cpu(__icmp_socket, i));
+		sock = percpu_ptr(net->__icmp_socket, i);
 
+		err = sock_create_kern(PF_INET, SOCK_RAW, IPPROTO_ICMP, sock);
 		if (err < 0)
-			panic("Failed to create the ICMP control socket.\n");
+			goto fail;
 
-		per_cpu(__icmp_socket, i)->sk->sk_allocation = GFP_ATOMIC;
+		(*sock)->sk->sk_allocation = GFP_ATOMIC;
 
 		/* Enough space for 2 64K ICMP packets, including
 		 * sk_buff struct overhead.
 		 */
-		per_cpu(__icmp_socket, i)->sk->sk_sndbuf =
+		(*sock)->sk->sk_sndbuf =
 			(2 * ((64 * 1024) + sizeof(struct sk_buff)));
 
-		inet = inet_sk(per_cpu(__icmp_socket, i)->sk);
+		inet = inet_sk((*sock)->sk);
 		inet->uc_ttl = -1;
 		inet->pmtudisc = IP_PMTUDISC_DONT;
 
@@ -1209,8 +1240,27 @@
 		 * see it, we do not wish this socket to see incoming
 		 * packets.
 		 */
-		per_cpu(__icmp_socket, i)->sk->sk_prot->unhash(per_cpu(__icmp_socket, i)->sk);
+		(*sock)->sk->sk_prot->unhash((*sock)->sk);
+
+		/* Don't hold an extra reference on the namespace */
+		put_net((*sock)->sk->sk_net);
 	}
+	return 0;
+fail:
+	icmp_net_exit(net);
+	return err;
+
+}
+
+static struct pernet_operations icmp_net_ops = {
+	.init = icmp_net_init,
+	.exit = icmp_net_exit,
+};
+
+void __init icmp_init(struct net_proto_family *ops)
+{
+	if (register_pernet_subsys(&icmp_net_ops))
+		panic("Failed to create the ICMP control socket.\n");
 }
 
 EXPORT_SYMBOL(icmp_err_convert);
diff -Nurb linux-2.6.22-590/net/ipv4/igmp.c linux-2.6.22-try2-netns/net/ipv4/igmp.c
--- linux-2.6.22-590/net/ipv4/igmp.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/igmp.c	2007-12-19 22:49:18.000000000 -0500
@@ -97,6 +97,7 @@
 #include <net/route.h>
 #include <net/sock.h>
 #include <net/checksum.h>
+#include <net/net_namespace.h>
 #include <linux/netfilter_ipv4.h>
 #ifdef CONFIG_IP_MROUTE
 #include <linux/mroute.h>
@@ -129,12 +130,12 @@
  */
 
 #define IGMP_V1_SEEN(in_dev) \
-	(IPV4_DEVCONF_ALL(FORCE_IGMP_VERSION) == 1 || \
+	(IPV4_DEVCONF_ALL((in_dev)->dev->nd_net, FORCE_IGMP_VERSION) == 1 || \
 	 IN_DEV_CONF_GET((in_dev), FORCE_IGMP_VERSION) == 1 || \
 	 ((in_dev)->mr_v1_seen && \
 	  time_before(jiffies, (in_dev)->mr_v1_seen)))
 #define IGMP_V2_SEEN(in_dev) \
-	(IPV4_DEVCONF_ALL(FORCE_IGMP_VERSION) == 2 || \
+	(IPV4_DEVCONF_ALL((in_dev)->dev->nd_net, FORCE_IGMP_VERSION) == 2 || \
 	 IN_DEV_CONF_GET((in_dev), FORCE_IGMP_VERSION) == 2 || \
 	 ((in_dev)->mr_v2_seen && \
 	  time_before(jiffies, (in_dev)->mr_v2_seen)))
@@ -296,7 +297,8 @@
 		return NULL;
 
 	{
-		struct flowi fl = { .oif = dev->ifindex,
+		struct flowi fl = { .fl_net = &init_net,
+				    .oif = dev->ifindex,
 				    .nl_u = { .ip4_u = {
 				    .daddr = IGMPV3_ALL_MCR } },
 				    .proto = IPPROTO_IGMP };
@@ -646,7 +648,8 @@
 		dst = group;
 
 	{
-		struct flowi fl = { .oif = dev->ifindex,
+		struct flowi fl = { .fl_net = &init_net,
+				    .oif = dev->ifindex,
 				    .nl_u = { .ip4_u = { .daddr = dst } },
 				    .proto = IPPROTO_IGMP };
 		if (ip_route_output_key(&rt, &fl))
@@ -929,6 +932,11 @@
 	struct in_device *in_dev = in_dev_get(skb->dev);
 	int len = skb->len;
 
+	if (skb->dev->nd_net != &init_net) {
+		kfree_skb(skb);
+		return 0;
+	}
+
 	if (in_dev==NULL) {
 		kfree_skb(skb);
 		return 0;
@@ -1393,20 +1401,22 @@
 
 static struct in_device * ip_mc_find_dev(struct ip_mreqn *imr)
 {
-	struct flowi fl = { .nl_u = { .ip4_u =
-				      { .daddr = imr->imr_multiaddr.s_addr } } };
+	struct flowi fl = { 
+		.fl_net = &init_net,
+		.nl_u = { .ip4_u = { .daddr = imr->imr_multiaddr.s_addr } }
+	};
 	struct rtable *rt;
 	struct net_device *dev = NULL;
 	struct in_device *idev = NULL;
 
 	if (imr->imr_ifindex) {
-		idev = inetdev_by_index(imr->imr_ifindex);
+		idev = inetdev_by_index(&init_net, imr->imr_ifindex);
 		if (idev)
 			__in_dev_put(idev);
 		return idev;
 	}
 	if (imr->imr_address.s_addr) {
-		dev = ip_dev_find(imr->imr_address.s_addr);
+		dev = ip_dev_find(&init_net, imr->imr_address.s_addr);
 		if (!dev)
 			return NULL;
 		dev_put(dev);
@@ -2234,7 +2244,7 @@
 		struct in_device *in_dev;
 		inet->mc_list = iml->next;
 
-		in_dev = inetdev_by_index(iml->multi.imr_ifindex);
+		in_dev = inetdev_by_index(&init_net, iml->multi.imr_ifindex);
 		(void) ip_mc_leave_src(sk, iml, in_dev);
 		if (in_dev != NULL) {
 			ip_mc_dec_group(in_dev, iml->multi.imr_multiaddr.s_addr);
@@ -2291,7 +2301,7 @@
 	struct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);
 
 	state->in_dev = NULL;
-	for_each_netdev(state->dev) {
+	for_each_netdev(&init_net, state->dev) {
 		struct in_device *in_dev;
 		in_dev = in_dev_get(state->dev);
 		if (!in_dev)
@@ -2453,7 +2463,7 @@
 
 	state->idev = NULL;
 	state->im = NULL;
-	for_each_netdev(state->dev) {
+	for_each_netdev(&init_net, state->dev) {
 		struct in_device *idev;
 		idev = in_dev_get(state->dev);
 		if (unlikely(idev == NULL))
@@ -2613,8 +2623,8 @@
 
 int __init igmp_mc_proc_init(void)
 {
-	proc_net_fops_create("igmp", S_IRUGO, &igmp_mc_seq_fops);
-	proc_net_fops_create("mcfilter", S_IRUGO, &igmp_mcf_seq_fops);
+	proc_net_fops_create(&init_net, "igmp", S_IRUGO, &igmp_mc_seq_fops);
+	proc_net_fops_create(&init_net, "mcfilter", S_IRUGO, &igmp_mcf_seq_fops);
 	return 0;
 }
 #endif
diff -Nurb linux-2.6.22-590/net/ipv4/inet_connection_sock.c linux-2.6.22-try2-netns/net/ipv4/inet_connection_sock.c
--- linux-2.6.22-590/net/ipv4/inet_connection_sock.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/inet_connection_sock.c	2007-12-19 23:25:05.000000000 -0500
@@ -32,7 +32,7 @@
 /*
  * This array holds the first and last local port number.
  */
-int sysctl_local_port_range[2] = { 32768, 61000 };
+//int sysctl_local_port_range[2] = { 32768, 61000 };
 
 int ipv4_rcv_saddr_equal(const struct sock *sk1, const struct sock *sk2)
 {
@@ -74,6 +74,7 @@
 
 	sk_for_each_bound(sk2, node, &tb->owners) {
 		if (sk != sk2 &&
+ 		    (sk->sk_net == sk2->sk_net) &&
 		    !inet_v6_ipv6only(sk2) &&
 		    (!sk->sk_bound_dev_if ||
 		     !sk2->sk_bound_dev_if ||
@@ -98,6 +99,7 @@
 		      int (*bind_conflict)(const struct sock *sk,
 					   const struct inet_bind_bucket *tb))
 {
+ 	struct net *net = sk->sk_net;
 	struct inet_bind_hashbucket *head;
 	struct hlist_node *node;
 	struct inet_bind_bucket *tb;
@@ -105,16 +107,16 @@
 
 	local_bh_disable();
 	if (!snum) {
-		int low = sysctl_local_port_range[0];
-		int high = sysctl_local_port_range[1];
+		int low = sk->sk_net->sysctl_local_port_range[0];
+		int high = sk->sk_net->sysctl_local_port_range[1];
 		int remaining = (high - low) + 1;
 		int rover = net_random() % (high - low) + low;
 
 		do {
-			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
+			head = &hashinfo->bhash[inet_bhashfn(net, rover, hashinfo->bhash_size)];
 			spin_lock(&head->lock);
 			inet_bind_bucket_for_each(tb, node, &head->chain)
-				if (tb->port == rover)
+ 				if ((tb->port == rover) && (tb->net == net))
 					goto next;
 			break;
 		next:
@@ -138,10 +140,10 @@
 		 */
 		snum = rover;
 	} else {
-		head = &hashinfo->bhash[inet_bhashfn(snum, hashinfo->bhash_size)];
+		head = &hashinfo->bhash[inet_bhashfn(net, snum, hashinfo->bhash_size)];
 		spin_lock(&head->lock);
 		inet_bind_bucket_for_each(tb, node, &head->chain)
-			if (tb->port == snum)
+			if ((tb->port == snum) && (tb->net==net))
 				goto tb_found;
 	}
 	tb = NULL;
@@ -161,7 +163,7 @@
 	}
 tb_not_found:
 	ret = 1;
-	if (!tb && (tb = inet_bind_bucket_create(hashinfo->bind_bucket_cachep, head, snum)) == NULL)
+	if (!tb && (tb = inet_bind_bucket_create(hashinfo->bind_bucket_cachep, head, net, snum)) == NULL)
 		goto fail_unlock;
 	if (hlist_empty(&tb->owners)) {
 		if (sk->sk_reuse && sk->sk_state != TCP_LISTEN)
@@ -341,7 +343,8 @@
 	struct rtable *rt;
 	const struct inet_request_sock *ireq = inet_rsk(req);
 	struct ip_options *opt = inet_rsk(req)->opt;
-	struct flowi fl = { .oif = sk->sk_bound_dev_if,
+	struct flowi fl = { .fl_net = sk->sk_net,
+			.oif = sk->sk_bound_dev_if,
 			    .nl_u = { .ip4_u =
 				      { .daddr = ((opt && opt->srr) ?
 						  opt->faddr :
diff -Nurb linux-2.6.22-590/net/ipv4/inet_diag.c linux-2.6.22-try2-netns/net/ipv4/inet_diag.c
--- linux-2.6.22-590/net/ipv4/inet_diag.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/inet_diag.c	2007-12-19 22:49:20.000000000 -0500
@@ -227,6 +227,7 @@
 static int inet_diag_get_exact(struct sk_buff *in_skb,
 			       const struct nlmsghdr *nlh)
 {
+	struct net *net = in_skb->sk->sk_net;
 	int err;
 	struct sock *sk;
 	struct inet_diag_req *req = NLMSG_DATA(nlh);
@@ -242,7 +243,7 @@
 		/* TODO: lback */
 		sk = inet_lookup(hashinfo, req->id.idiag_dst[0],
 				 req->id.idiag_dport, req->id.idiag_src[0],
-				 req->id.idiag_sport, req->id.idiag_if);
+				 req->id.idiag_sport, req->id.idiag_if, net);
 	}
 #if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
 	else if (req->idiag_family == AF_INET6) {
@@ -251,7 +252,7 @@
 				  req->id.idiag_dport,
 				  (struct in6_addr *)req->id.idiag_src,
 				  req->id.idiag_sport,
-				  req->id.idiag_if);
+				  req->id.idiag_if, net);
 	}
 #endif
 	else {
@@ -906,8 +907,8 @@
 	if (!inet_diag_table)
 		goto out;
 
-	idiagnl = netlink_kernel_create(NETLINK_INET_DIAG, 0, inet_diag_rcv,
-					NULL, THIS_MODULE);
+	idiagnl = netlink_kernel_create(&init_net, NETLINK_INET_DIAG, 0,
+					inet_diag_rcv, NULL, THIS_MODULE);
 	if (idiagnl == NULL)
 		goto out_free_table;
 	err = 0;
diff -Nurb linux-2.6.22-590/net/ipv4/inet_hashtables.c linux-2.6.22-try2-netns/net/ipv4/inet_hashtables.c
--- linux-2.6.22-590/net/ipv4/inet_hashtables.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/inet_hashtables.c	2007-12-20 01:17:55.000000000 -0500
@@ -29,11 +29,13 @@
  */
 struct inet_bind_bucket *inet_bind_bucket_create(struct kmem_cache *cachep,
 						 struct inet_bind_hashbucket *head,
+						 struct net *net,
 						 const unsigned short snum)
 {
 	struct inet_bind_bucket *tb = kmem_cache_alloc(cachep, GFP_ATOMIC);
 
 	if (tb != NULL) {
+		tb->net	      = net;
 		tb->port      = snum;
 		tb->fastreuse = 0;
 		INIT_HLIST_HEAD(&tb->owners);
@@ -66,7 +68,7 @@
  */
 static void __inet_put_port(struct inet_hashinfo *hashinfo, struct sock *sk)
 {
-	const int bhash = inet_bhashfn(inet_sk(sk)->num, hashinfo->bhash_size);
+	const int bhash = inet_bhashfn(sk->sk_net, inet_sk(sk)->num, hashinfo->bhash_size);
 	struct inet_bind_hashbucket *head = &hashinfo->bhash[bhash];
 	struct inet_bind_bucket *tb;
 
@@ -127,7 +129,7 @@
 static struct sock *inet_lookup_listener_slow(const struct hlist_head *head,
 					      const __be32 daddr,
 					      const unsigned short hnum,
-					      const int dif)
+					      const int dif, struct net *net)
 {
 	struct sock *result = NULL, *sk;
 	const struct hlist_node *node;
@@ -149,6 +151,8 @@
 					continue;
 				score += 2;
 			}
+			if (sk->sk_net != net)
+				continue;
 			if (score == 5)
 				return sk;
 			if (score > hiscore) {
@@ -163,22 +167,22 @@
 /* Optimize the common listener case. */
 struct sock *__inet_lookup_listener(struct inet_hashinfo *hashinfo,
 				    const __be32 daddr, const unsigned short hnum,
-				    const int dif)
+				    const int dif, struct net *net)
 {
 	struct sock *sk = NULL;
 	const struct hlist_head *head;
 
 	read_lock(&hashinfo->lhash_lock);
-	head = &hashinfo->listening_hash[inet_lhashfn(hnum)];
+	head = &hashinfo->listening_hash[net, inet_lhashfn(net, hnum)];
 	if (!hlist_empty(head)) {
 		const struct inet_sock *inet = inet_sk((sk = __sk_head(head)));
 
 		if (inet->num == hnum && !sk->sk_node.next &&
 		    v4_inet_addr_match(sk->sk_nx_info, daddr, inet->rcv_saddr) &&
 		    (sk->sk_family == PF_INET || !ipv6_only_sock(sk)) &&
-		    !sk->sk_bound_dev_if)
+		    !sk->sk_bound_dev_if && (sk->sk_net == net))
 			goto sherry_cache;
-		sk = inet_lookup_listener_slow(head, daddr, hnum, dif);
+		sk = inet_lookup_listener_slow(head, daddr, hnum, dif,net );
 	}
 	if (sk) {
 sherry_cache:
@@ -196,12 +200,13 @@
 {
 	struct inet_hashinfo *hinfo = death_row->hashinfo;
 	struct inet_sock *inet = inet_sk(sk);
+	struct net *net = sk->sk_net;
 	__be32 daddr = inet->rcv_saddr;
 	__be32 saddr = inet->daddr;
 	int dif = sk->sk_bound_dev_if;
 	INET_ADDR_COOKIE(acookie, saddr, daddr)
 	const __portpair ports = INET_COMBINED_PORTS(inet->dport, lport);
-	unsigned int hash = inet_ehashfn(daddr, lport, saddr, inet->dport);
+	unsigned int hash = inet_ehashfn(net, daddr, lport, saddr, inet->dport);
 	struct inet_ehash_bucket *head = inet_ehash_bucket(hinfo, hash);
 	struct sock *sk2;
 	const struct hlist_node *node;
@@ -214,7 +219,7 @@
 	sk_for_each(sk2, node, &head->twchain) {
 		tw = inet_twsk(sk2);
 
-		if (INET_TW_MATCH(sk2, hash, acookie, saddr, daddr, ports, dif)) {
+		if (INET_TW_MATCH(sk2, hash, acookie, saddr, daddr, ports, dif, net)) {
 			if (twsk_unique(sk, sk2, twp))
 				goto unique;
 			else
@@ -225,7 +230,7 @@
 
 	/* And established part... */
 	sk_for_each(sk2, node, &head->chain) {
-		if (INET_MATCH(sk2, hash, acookie, saddr, daddr, ports, dif))
+		if (INET_MATCH(sk2, hash, acookie, saddr, daddr, ports, dif, net))
 			goto not_unique;
 	}
 
@@ -271,6 +276,7 @@
 int inet_hash_connect(struct inet_timewait_death_row *death_row,
 		      struct sock *sk)
 {
+	struct net *net = sk->sk_net;
 	struct inet_hashinfo *hinfo = death_row->hashinfo;
 	const unsigned short snum = inet_sk(sk)->num;
 	struct inet_bind_hashbucket *head;
@@ -278,8 +284,8 @@
 	int ret;
 
 	if (!snum) {
-		int low = sysctl_local_port_range[0];
-		int high = sysctl_local_port_range[1];
+		int low = sk->sk_net->sysctl_local_port_range[0];
+		int high = sk->sk_net->sysctl_local_port_range[1];
 		int range = high - low;
 		int i;
 		int port;
@@ -291,7 +297,7 @@
 		local_bh_disable();
 		for (i = 1; i <= range; i++) {
 			port = low + (i + offset) % range;
-			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
+			head = &hinfo->bhash[inet_bhashfn(net, port, hinfo->bhash_size)];
 			spin_lock(&head->lock);
 
 			/* Does not bother with rcv_saddr checks,
@@ -299,7 +305,7 @@
 			 * unique enough.
 			 */
 			inet_bind_bucket_for_each(tb, node, &head->chain) {
-				if (tb->port == port) {
+				if ((tb->port == port) && (tb->net == net)) {
 					BUG_TRAP(!hlist_empty(&tb->owners));
 					if (tb->fastreuse >= 0)
 						goto next_port;
@@ -311,7 +317,7 @@
 				}
 			}
 
-			tb = inet_bind_bucket_create(hinfo->bind_bucket_cachep, head, port);
+			tb = inet_bind_bucket_create(hinfo->bind_bucket_cachep, head, net, port);
 			if (!tb) {
 				spin_unlock(&head->lock);
 				break;
@@ -346,7 +352,7 @@
 		goto out;
 	}
 
-	head = &hinfo->bhash[inet_bhashfn(snum, hinfo->bhash_size)];
+	head = &hinfo->bhash[inet_bhashfn(net, snum, hinfo->bhash_size)];
 	tb  = inet_csk(sk)->icsk_bind_hash;
 	spin_lock_bh(&head->lock);
 	if (sk_head(&tb->owners) == sk && !sk->sk_bind_node.next) {
diff -Nurb linux-2.6.22-590/net/ipv4/inet_timewait_sock.c linux-2.6.22-try2-netns/net/ipv4/inet_timewait_sock.c
--- linux-2.6.22-590/net/ipv4/inet_timewait_sock.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/inet_timewait_sock.c	2007-12-19 22:49:20.000000000 -0500
@@ -31,7 +31,7 @@
 	write_unlock(&ehead->lock);
 
 	/* Disassociate with bind bucket. */
-	bhead = &hashinfo->bhash[inet_bhashfn(tw->tw_num, hashinfo->bhash_size)];
+	bhead = &hashinfo->bhash[inet_bhashfn(tw->tw_net, tw->tw_num, hashinfo->bhash_size)];
 	spin_lock(&bhead->lock);
 	tb = tw->tw_tb;
 	__hlist_del(&tw->tw_bind_node);
@@ -65,7 +65,7 @@
 	   Note, that any socket with inet->num != 0 MUST be bound in
 	   binding cache, even if it is closed.
 	 */
-	bhead = &hashinfo->bhash[inet_bhashfn(inet->num, hashinfo->bhash_size)];
+	bhead = &hashinfo->bhash[inet_bhashfn(sk->sk_net, inet->num, hashinfo->bhash_size)];
 	spin_lock(&bhead->lock);
 	tw->tw_tb = icsk->icsk_bind_hash;
 	BUG_TRAP(icsk->icsk_bind_hash);
diff -Nurb linux-2.6.22-590/net/ipv4/inetpeer.c linux-2.6.22-try2-netns/net/ipv4/inetpeer.c
--- linux-2.6.22-590/net/ipv4/inetpeer.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/inetpeer.c	2007-12-19 22:49:20.000000000 -0500
@@ -81,71 +81,94 @@
 	.avl_height	= 0
 };
 #define peer_avl_empty (&peer_fake_node)
-static struct inet_peer *peer_root = peer_avl_empty;
 static DEFINE_RWLOCK(peer_pool_lock);
 #define PEER_MAXDEPTH 40 /* sufficient for about 2^27 nodes */
 
-static int peer_total;
-/* Exported for sysctl_net_ipv4.  */
-int inet_peer_threshold __read_mostly = 65536 + 128;	/* start to throw entries more
-					 * aggressively at this stage */
-int inet_peer_minttl __read_mostly = 120 * HZ;	/* TTL under high load: 120 sec */
-int inet_peer_maxttl __read_mostly = 10 * 60 * HZ;	/* usual time to live: 10 min */
-int inet_peer_gc_mintime __read_mostly = 10 * HZ;
-int inet_peer_gc_maxtime __read_mostly = 120 * HZ;
-
-static struct inet_peer *inet_peer_unused_head;
-static struct inet_peer **inet_peer_unused_tailp = &inet_peer_unused_head;
 static DEFINE_SPINLOCK(inet_peer_unused_lock);
 
 static void peer_check_expire(unsigned long dummy);
-static DEFINE_TIMER(peer_periodic_timer, peer_check_expire, 0, 0);
 
+static int inet_peers_net_init(struct net *net);
+static void inet_peers_net_exit(struct net *net);
+static struct pernet_operations inet_peers_net_ops = {
+	.init = inet_peers_net_init,
+	.exit = inet_peers_net_exit,
+};
 
 /* Called from ip_output.c:ip_init  */
 void __init inet_initpeers(void)
 {
+	peer_cachep = kmem_cache_create("inet_peer_cache",
+			sizeof(struct inet_peer),
+			0, SLAB_HWCACHE_ALIGN|SLAB_PANIC,
+			NULL, NULL);
+
+	register_pernet_subsys(&inet_peers_net_ops);
+}
+
+static int inet_peers_net_init(struct net *net)
+{
 	struct sysinfo si;
 
+	net->peer_root = peer_avl_empty;
+	net->inet_peer_unused_tailp = &net->inet_peer_unused_head;
+
+	net->inet_peer_threshold = 65536 + 128;	/* start to throw entries more
+						 * aggressively at this stage */
+	net->inet_peer_minttl = 120 * HZ;	/* TTL under high load: 120 sec */
+	net->inet_peer_maxttl = 10 * 60 * HZ;	/* usual time to live: 10 min */
+	net->inet_peer_gc_mintime = 10 * HZ;
+	net->inet_peer_gc_maxtime = 120 * HZ;
+
 	/* Use the straight interface to information about memory. */
 	si_meminfo(&si);
+
 	/* The values below were suggested by Alexey Kuznetsov
 	 * <kuznet@ms2.inr.ac.ru>.  I don't have any opinion about the values
 	 * myself.  --SAW
 	 */
 	if (si.totalram <= (32768*1024)/PAGE_SIZE)
-		inet_peer_threshold >>= 1; /* max pool size about 1MB on IA32 */
+		net->inet_peer_threshold >>= 1; /* max pool size about 1MB on IA32 */
 	if (si.totalram <= (16384*1024)/PAGE_SIZE)
-		inet_peer_threshold >>= 1; /* about 512KB */
+		net->inet_peer_threshold >>= 1; /* about 512KB */
 	if (si.totalram <= (8192*1024)/PAGE_SIZE)
-		inet_peer_threshold >>= 2; /* about 128KB */
+		net->inet_peer_threshold >>= 2; /* about 128KB */
 
-	peer_cachep = kmem_cache_create("inet_peer_cache",
-			sizeof(struct inet_peer),
-			0, SLAB_HWCACHE_ALIGN|SLAB_PANIC,
-			NULL, NULL);
 
+	init_timer(&net->peer_periodic_timer);
+	net->peer_periodic_timer.function = peer_check_expire;
 	/* All the timers, started at system startup tend
 	   to synchronize. Perturb it a bit.
 	 */
-	peer_periodic_timer.expires = jiffies
-		+ net_random() % inet_peer_gc_maxtime
-		+ inet_peer_gc_maxtime;
-	add_timer(&peer_periodic_timer);
+	net->peer_periodic_timer.expires = jiffies
+		+ net_random() % net->inet_peer_gc_maxtime
+		+ net->inet_peer_gc_maxtime;
+	/* Remember our namespace */
+	net->peer_periodic_timer.data = (unsigned long)net;
+	add_timer(&net->peer_periodic_timer);
+	
+	return 0;
+}
+
+static void inet_peers_net_exit(struct net *net)
+{
+	del_timer(&net->peer_periodic_timer);
+	/* CHECKME do I need to do something to release all of the peers */
 }
 
 /* Called with or without local BH being disabled. */
-static void unlink_from_unused(struct inet_peer *p)
+static void unlink_from_unused(struct net *net, struct inet_peer *p)
 {
 	spin_lock_bh(&inet_peer_unused_lock);
 	if (p->unused_prevp != NULL) {
 		/* On unused list. */
-		*p->unused_prevp = p->unused_next;
-		if (p->unused_next != NULL)
-			p->unused_next->unused_prevp = p->unused_prevp;
+		*p->unused_prevp = p->u.unused_next;
+		if (p->u.unused_next != NULL)
+			p->u.unused_next->unused_prevp = p->unused_prevp;
 		else
-			inet_peer_unused_tailp = p->unused_prevp;
+			net->inet_peer_unused_tailp = p->unused_prevp;
 		p->unused_prevp = NULL; /* mark it as removed */
+		p->u.net = hold_net(net); /* Remember the net */
 	}
 	spin_unlock_bh(&inet_peer_unused_lock);
 }
@@ -160,9 +183,9 @@
 	struct inet_peer *u, **v;				\
 	if (_stack) {						\
 		stackptr = _stack;				\
-		*stackptr++ = &peer_root;			\
+		*stackptr++ = &net->peer_root;			\
 	}							\
-	for (u = peer_root; u != peer_avl_empty; ) {		\
+	for (u = net->peer_root; u != peer_avl_empty; ) {	\
 		if (_daddr == u->v4daddr)			\
 			break;					\
 		if ((__force __u32)_daddr < (__force __u32)u->v4daddr)	\
@@ -279,7 +302,7 @@
 } while(0)
 
 /* May be called with local BH enabled. */
-static void unlink_from_pool(struct inet_peer *p)
+static void unlink_from_pool(struct net *net, struct inet_peer *p)
 {
 	int do_free;
 
@@ -317,7 +340,7 @@
 			delp[1] = &t->avl_left; /* was &p->avl_left */
 		}
 		peer_avl_rebalance(stack, stackptr);
-		peer_total--;
+		net->peer_total--;
 		do_free = 1;
 	}
 	write_unlock_bh(&peer_pool_lock);
@@ -335,13 +358,13 @@
 }
 
 /* May be called with local BH enabled. */
-static int cleanup_once(unsigned long ttl)
+static int cleanup_once(struct net *net, unsigned long ttl)
 {
 	struct inet_peer *p;
 
 	/* Remove the first entry from the list of unused nodes. */
 	spin_lock_bh(&inet_peer_unused_lock);
-	p = inet_peer_unused_head;
+	p = net->inet_peer_unused_head;
 	if (p != NULL) {
 		__u32 delta = (__u32)jiffies - p->dtime;
 		if (delta < ttl) {
@@ -349,12 +372,13 @@
 			spin_unlock_bh(&inet_peer_unused_lock);
 			return -1;
 		}
-		inet_peer_unused_head = p->unused_next;
-		if (p->unused_next != NULL)
-			p->unused_next->unused_prevp = p->unused_prevp;
+		net->inet_peer_unused_head = p->u.unused_next;
+		if (p->u.unused_next != NULL)
+			p->u.unused_next->unused_prevp = p->unused_prevp;
 		else
-			inet_peer_unused_tailp = p->unused_prevp;
+			net->inet_peer_unused_tailp = p->unused_prevp;
 		p->unused_prevp = NULL; /* mark as not on the list */
+		p->u.net = hold_net(net);
 		/* Grab an extra reference to prevent node disappearing
 		 * before unlink_from_pool() call. */
 		atomic_inc(&p->refcnt);
@@ -367,12 +391,12 @@
 		 * happen because of entry limits in route cache. */
 		return -1;
 
-	unlink_from_pool(p);
+	unlink_from_pool(net, p);
 	return 0;
 }
 
 /* Called with or without local BH being disabled. */
-struct inet_peer *inet_getpeer(__be32 daddr, int create)
+struct inet_peer *inet_getpeer(struct net *net, __be32 daddr, int create)
 {
 	struct inet_peer *p, *n;
 	struct inet_peer **stack[PEER_MAXDEPTH], ***stackptr;
@@ -387,7 +411,7 @@
 	if (p != peer_avl_empty) {
 		/* The existing node has been found. */
 		/* Remove the entry from unused list if it was there. */
-		unlink_from_unused(p);
+		unlink_from_unused(net, p);
 		return p;
 	}
 
@@ -413,13 +437,13 @@
 	/* Link the node. */
 	link_to_pool(n);
 	n->unused_prevp = NULL; /* not on the list */
-	peer_total++;
+	n->u.net = hold_net(net); /* Remember the net */
+	net->peer_total++;
 	write_unlock_bh(&peer_pool_lock);
 
-	if (peer_total >= inet_peer_threshold)
+	if (net->peer_total >= net->inet_peer_threshold)
 		/* Remove one less-recently-used entry. */
-		cleanup_once(0);
-
+		cleanup_once(net, 0);
 	return n;
 
 out_free:
@@ -427,25 +451,26 @@
 	atomic_inc(&p->refcnt);
 	write_unlock_bh(&peer_pool_lock);
 	/* Remove the entry from unused list if it was there. */
-	unlink_from_unused(p);
+	unlink_from_unused(net, p);
 	/* Free preallocated the preallocated node. */
 	kmem_cache_free(peer_cachep, n);
 	return p;
 }
 
 /* Called with local BH disabled. */
-static void peer_check_expire(unsigned long dummy)
+static void peer_check_expire(unsigned long arg)
 {
+	struct net *net = (void *)arg;
 	unsigned long now = jiffies;
 	int ttl;
 
-	if (peer_total >= inet_peer_threshold)
-		ttl = inet_peer_minttl;
+	if (net->peer_total >= net->inet_peer_threshold)
+		ttl = net->inet_peer_minttl;
 	else
-		ttl = inet_peer_maxttl
-				- (inet_peer_maxttl - inet_peer_minttl) / HZ *
-					peer_total / inet_peer_threshold * HZ;
-	while (!cleanup_once(ttl)) {
+		ttl = net->inet_peer_maxttl
+			- (net->inet_peer_maxttl - net->inet_peer_minttl) / HZ *
+				net->peer_total / net->inet_peer_threshold * HZ;
+	while (!cleanup_once(net, ttl)) {
 		if (jiffies != now)
 			break;
 	}
@@ -453,25 +478,30 @@
 	/* Trigger the timer after inet_peer_gc_mintime .. inet_peer_gc_maxtime
 	 * interval depending on the total number of entries (more entries,
 	 * less interval). */
-	if (peer_total >= inet_peer_threshold)
-		peer_periodic_timer.expires = jiffies + inet_peer_gc_mintime;
+	if (net->peer_total >= net->inet_peer_threshold)
+		net->peer_periodic_timer.expires = jiffies 
+			+ net->inet_peer_gc_mintime;
 	else
-		peer_periodic_timer.expires = jiffies
-			+ inet_peer_gc_maxtime
-			- (inet_peer_gc_maxtime - inet_peer_gc_mintime) / HZ *
-				peer_total / inet_peer_threshold * HZ;
-	add_timer(&peer_periodic_timer);
+		net->peer_periodic_timer.expires = jiffies
+			+ net->inet_peer_gc_maxtime
+			- (net->inet_peer_gc_maxtime - net->inet_peer_gc_mintime) / HZ *
+				net->peer_total / net->inet_peer_threshold * HZ;
+	add_timer(&net->peer_periodic_timer);
 }
 
 void inet_putpeer(struct inet_peer *p)
 {
 	spin_lock_bh(&inet_peer_unused_lock);
 	if (atomic_dec_and_test(&p->refcnt)) {
-		p->unused_prevp = inet_peer_unused_tailp;
-		p->unused_next = NULL;
-		*inet_peer_unused_tailp = p;
-		inet_peer_unused_tailp = &p->unused_next;
+		struct net *net = p->u.net;
+
+		p->unused_prevp = net->inet_peer_unused_tailp;
+		p->u.unused_next = NULL;
+		*net->inet_peer_unused_tailp = p;
+		net->inet_peer_unused_tailp = &p->u.unused_next;
 		p->dtime = (__u32)jiffies;
+
+		release_net(net);
 	}
 	spin_unlock_bh(&inet_peer_unused_lock);
 }
diff -Nurb linux-2.6.22-590/net/ipv4/ip_fragment.c linux-2.6.22-try2-netns/net/ipv4/ip_fragment.c
--- linux-2.6.22-590/net/ipv4/ip_fragment.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/ip_fragment.c	2007-12-19 22:49:20.000000000 -0500
@@ -49,21 +49,6 @@
  * as well. Or notify me, at least. --ANK
  */
 
-/* Fragment cache limits. We will commit 256K at one time. Should we
- * cross that limit we will prune down to 192K. This should cope with
- * even the most extreme cases without allowing an attacker to measurably
- * harm machine performance.
- */
-int sysctl_ipfrag_high_thresh __read_mostly = 256*1024;
-int sysctl_ipfrag_low_thresh __read_mostly = 192*1024;
-
-int sysctl_ipfrag_max_dist __read_mostly = 64;
-
-/* Important NOTE! Fragment queue must be destroyed before MSL expires.
- * RFC791 is wrong proposing to prolongate timer each fragment arrival by TTL.
- */
-int sysctl_ipfrag_time __read_mostly = IP_FRAG_TIME;
-
 struct ipfrag_skb_cb
 {
 	struct inet_skb_parm	h;
@@ -96,6 +81,7 @@
 	int             iif;
 	unsigned int    rid;
 	struct inet_peer *peer;
+	struct net 	*net;
 };
 
 /* Hash table. */
@@ -103,17 +89,13 @@
 #define IPQ_HASHSZ	64
 
 /* Per-bucket lock is easy to add now. */
-static struct hlist_head ipq_hash[IPQ_HASHSZ];
 static DEFINE_RWLOCK(ipfrag_lock);
-static u32 ipfrag_hash_rnd;
-static LIST_HEAD(ipq_lru_list);
-int ip_frag_nqueues = 0;
 
 static __inline__ void __ipq_unlink(struct ipq *qp)
 {
 	hlist_del(&qp->list);
 	list_del(&qp->lru_list);
-	ip_frag_nqueues--;
+	qp->net->ip_frag_nqueues--;
 }
 
 static __inline__ void ipq_unlink(struct ipq *ipq)
@@ -123,70 +105,71 @@
 	write_unlock(&ipfrag_lock);
 }
 
-static unsigned int ipqhashfn(__be16 id, __be32 saddr, __be32 daddr, u8 prot)
+static unsigned int ipqhashfn(struct net *net, __be16 id, __be32 saddr, __be32 daddr, u8 prot)
 {
 	return jhash_3words((__force u32)id << 16 | prot,
 			    (__force u32)saddr, (__force u32)daddr,
-			    ipfrag_hash_rnd) & (IPQ_HASHSZ - 1);
+			    net->ipfrag_hash_rnd) & (IPQ_HASHSZ - 1);
 }
 
-static struct timer_list ipfrag_secret_timer;
-int sysctl_ipfrag_secret_interval __read_mostly = 10 * 60 * HZ;
-
-static void ipfrag_secret_rebuild(unsigned long dummy)
+static void ipfrag_secret_rebuild(unsigned long arg)
 {
+	struct net *net = (void *)arg;
 	unsigned long now = jiffies;
 	int i;
 
 	write_lock(&ipfrag_lock);
-	get_random_bytes(&ipfrag_hash_rnd, sizeof(u32));
+	get_random_bytes(&net->ipfrag_hash_rnd, sizeof(u32));
 	for (i = 0; i < IPQ_HASHSZ; i++) {
 		struct ipq *q;
+		struct hlist_head *head;
 		struct hlist_node *p, *n;
 
-		hlist_for_each_entry_safe(q, p, n, &ipq_hash[i], list) {
-			unsigned int hval = ipqhashfn(q->id, q->saddr,
+		head = &net->ipq_hash[i];
+		hlist_for_each_entry_safe(q, p, n, head, list) {
+			unsigned int hval = ipqhashfn(net, q->id, q->saddr,
 						      q->daddr, q->protocol);
 
 			if (hval != i) {
 				hlist_del(&q->list);
 
 				/* Relink to new hash chain. */
-				hlist_add_head(&q->list, &ipq_hash[hval]);
+				hlist_add_head(&q->list, &net->ipq_hash[hval]);
 			}
 		}
 	}
 	write_unlock(&ipfrag_lock);
 
-	mod_timer(&ipfrag_secret_timer, now + sysctl_ipfrag_secret_interval);
+	mod_timer(&net->ipfrag_secret_timer, 
+		now + net->sysctl_ipfrag_secret_interval);
 }
 
-atomic_t ip_frag_mem = ATOMIC_INIT(0);	/* Memory used for fragments */
-
 /* Memory Tracking Functions. */
-static __inline__ void frag_kfree_skb(struct sk_buff *skb, int *work)
+static __inline__ void frag_kfree_skb(struct net *net, struct sk_buff *skb, int *work)
 {
 	if (work)
 		*work -= skb->truesize;
-	atomic_sub(skb->truesize, &ip_frag_mem);
+	atomic_sub(skb->truesize, &net->ip_frag_mem);
 	kfree_skb(skb);
 }
 
 static __inline__ void frag_free_queue(struct ipq *qp, int *work)
 {
+	struct net *net = qp->net;
 	if (work)
 		*work -= sizeof(struct ipq);
-	atomic_sub(sizeof(struct ipq), &ip_frag_mem);
+	atomic_sub(sizeof(struct ipq), &net->ip_frag_mem);
+	release_net(net);
 	kfree(qp);
 }
 
-static __inline__ struct ipq *frag_alloc_queue(void)
+static __inline__ struct ipq *frag_alloc_queue(struct net *net)
 {
 	struct ipq *qp = kmalloc(sizeof(struct ipq), GFP_ATOMIC);
 
 	if (!qp)
 		return NULL;
-	atomic_add(sizeof(struct ipq), &ip_frag_mem);
+	atomic_add(sizeof(struct ipq), &net->ip_frag_mem);
 	return qp;
 }
 
@@ -209,7 +192,7 @@
 	while (fp) {
 		struct sk_buff *xp = fp->next;
 
-		frag_kfree_skb(fp, work);
+		frag_kfree_skb(qp->net, fp, work);
 		fp = xp;
 	}
 
@@ -241,23 +224,23 @@
 /* Memory limiting on fragments.  Evictor trashes the oldest
  * fragment queue until we are back under the threshold.
  */
-static void ip_evictor(void)
+static void ip_evictor(struct net *net)
 {
 	struct ipq *qp;
 	struct list_head *tmp;
 	int work;
 
-	work = atomic_read(&ip_frag_mem) - sysctl_ipfrag_low_thresh;
+	work = atomic_read(&net->ip_frag_mem) - net->sysctl_ipfrag_low_thresh;
 	if (work <= 0)
 		return;
 
 	while (work > 0) {
 		read_lock(&ipfrag_lock);
-		if (list_empty(&ipq_lru_list)) {
+		if (list_empty(&net->ipq_lru_list)) {
 			read_unlock(&ipfrag_lock);
 			return;
 		}
-		tmp = ipq_lru_list.next;
+		tmp = net->ipq_lru_list.next;
 		qp = list_entry(tmp, struct ipq, lru_list);
 		atomic_inc(&qp->refcnt);
 		read_unlock(&ipfrag_lock);
@@ -292,7 +275,7 @@
 	if ((qp->last_in&FIRST_IN) && qp->fragments != NULL) {
 		struct sk_buff *head = qp->fragments;
 		/* Send an ICMP "Fragment Reassembly Timeout" message. */
-		if ((head->dev = dev_get_by_index(qp->iif)) != NULL) {
+		if ((head->dev = dev_get_by_index(qp->net, qp->iif)) != NULL) {
 			icmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);
 			dev_put(head->dev);
 		}
@@ -304,7 +287,7 @@
 
 /* Creation primitives. */
 
-static struct ipq *ip_frag_intern(struct ipq *qp_in)
+static struct ipq *ip_frag_intern(struct net *net, struct ipq *qp_in)
 {
 	struct ipq *qp;
 #ifdef CONFIG_SMP
@@ -313,14 +296,14 @@
 	unsigned int hash;
 
 	write_lock(&ipfrag_lock);
-	hash = ipqhashfn(qp_in->id, qp_in->saddr, qp_in->daddr,
+	hash = ipqhashfn(net, qp_in->id, qp_in->saddr, qp_in->daddr,
 			 qp_in->protocol);
 #ifdef CONFIG_SMP
 	/* With SMP race we have to recheck hash table, because
 	 * such entry could be created on other cpu, while we
 	 * promoted read lock to write lock.
 	 */
-	hlist_for_each_entry(qp, n, &ipq_hash[hash], list) {
+	hlist_for_each_entry(qp, n, &net->ipq_hash[hash], list) {
 		if (qp->id == qp_in->id		&&
 		    qp->saddr == qp_in->saddr	&&
 		    qp->daddr == qp_in->daddr	&&
@@ -336,26 +319,27 @@
 #endif
 	qp = qp_in;
 
-	if (!mod_timer(&qp->timer, jiffies + sysctl_ipfrag_time))
+	if (!mod_timer(&qp->timer, jiffies + net->sysctl_ipfrag_time))
 		atomic_inc(&qp->refcnt);
 
 	atomic_inc(&qp->refcnt);
-	hlist_add_head(&qp->list, &ipq_hash[hash]);
+	hlist_add_head(&qp->list, &net->ipq_hash[hash]);
 	INIT_LIST_HEAD(&qp->lru_list);
-	list_add_tail(&qp->lru_list, &ipq_lru_list);
-	ip_frag_nqueues++;
+	list_add_tail(&qp->lru_list, &net->ipq_lru_list);
+	net->ip_frag_nqueues++;
 	write_unlock(&ipfrag_lock);
 	return qp;
 }
 
 /* Add an entry to the 'ipq' queue for a newly received IP datagram. */
-static struct ipq *ip_frag_create(struct iphdr *iph, u32 user)
+static struct ipq *ip_frag_create(struct net *net, struct iphdr *iph, u32 user)
 {
 	struct ipq *qp;
 
-	if ((qp = frag_alloc_queue()) == NULL)
+	if ((qp = frag_alloc_queue(net)) == NULL)
 		goto out_nomem;
 
+	qp->net = hold_net(net);
 	qp->protocol = iph->protocol;
 	qp->last_in = 0;
 	qp->id = iph->id;
@@ -366,7 +350,8 @@
 	qp->meat = 0;
 	qp->fragments = NULL;
 	qp->iif = 0;
-	qp->peer = sysctl_ipfrag_max_dist ? inet_getpeer(iph->saddr, 1) : NULL;
+	qp->peer = net->sysctl_ipfrag_max_dist ?
+		inet_getpeer(net, iph->saddr, 1) : NULL;
 
 	/* Initialize a timer for this entry. */
 	init_timer(&qp->timer);
@@ -375,7 +360,7 @@
 	spin_lock_init(&qp->lock);
 	atomic_set(&qp->refcnt, 1);
 
-	return ip_frag_intern(qp);
+	return ip_frag_intern(net, qp);
 
 out_nomem:
 	LIMIT_NETDEBUG(KERN_ERR "ip_frag_create: no memory left !\n");
@@ -385,7 +370,7 @@
 /* Find the correct entry in the "incomplete datagrams" queue for
  * this IP datagram, and create new one, if nothing is found.
  */
-static inline struct ipq *ip_find(struct iphdr *iph, u32 user)
+static inline struct ipq *ip_find(struct net *net, struct iphdr *iph, u32 user)
 {
 	__be16 id = iph->id;
 	__be32 saddr = iph->saddr;
@@ -396,8 +381,8 @@
 	struct hlist_node *n;
 
 	read_lock(&ipfrag_lock);
-	hash = ipqhashfn(id, saddr, daddr, protocol);
-	hlist_for_each_entry(qp, n, &ipq_hash[hash], list) {
+	hash = ipqhashfn(net, id, saddr, daddr, protocol);
+	hlist_for_each_entry(qp, n, &net->ipq_hash[hash], list) {
 		if (qp->id == id		&&
 		    qp->saddr == saddr	&&
 		    qp->daddr == daddr	&&
@@ -410,14 +395,14 @@
 	}
 	read_unlock(&ipfrag_lock);
 
-	return ip_frag_create(iph, user);
+	return ip_frag_create(net, iph, user);
 }
 
 /* Is the fragment too far ahead to be part of ipq? */
 static inline int ip_frag_too_far(struct ipq *qp)
 {
 	struct inet_peer *peer = qp->peer;
-	unsigned int max = sysctl_ipfrag_max_dist;
+	unsigned int max = qp->net->sysctl_ipfrag_max_dist;
 	unsigned int start, end;
 
 	int rc;
@@ -442,7 +427,7 @@
 {
 	struct sk_buff *fp;
 
-	if (!mod_timer(&qp->timer, jiffies + sysctl_ipfrag_time)) {
+	if (!mod_timer(&qp->timer, jiffies + qp->net->sysctl_ipfrag_time)) {
 		atomic_inc(&qp->refcnt);
 		return -ETIMEDOUT;
 	}
@@ -450,7 +435,7 @@
 	fp = qp->fragments;
 	do {
 		struct sk_buff *xp = fp->next;
-		frag_kfree_skb(fp, NULL);
+		frag_kfree_skb(qp->net, fp, NULL);
 		fp = xp;
 	} while (fp);
 
@@ -466,6 +451,7 @@
 /* Add new segment to existing queue. */
 static void ip_frag_queue(struct ipq *qp, struct sk_buff *skb)
 {
+	struct net *net = qp->net;
 	struct sk_buff *prev, *next;
 	int flags, offset;
 	int ihl, end;
@@ -576,7 +562,7 @@
 				qp->fragments = next;
 
 			qp->meat -= free_it->len;
-			frag_kfree_skb(free_it, NULL);
+			frag_kfree_skb(net, free_it, NULL);
 		}
 	}
 
@@ -594,12 +580,12 @@
 	skb->dev = NULL;
 	qp->stamp = skb->tstamp;
 	qp->meat += skb->len;
-	atomic_add(skb->truesize, &ip_frag_mem);
+	atomic_add(skb->truesize, &net->ip_frag_mem);
 	if (offset == 0)
 		qp->last_in |= FIRST_IN;
 
 	write_lock(&ipfrag_lock);
-	list_move_tail(&qp->lru_list, &ipq_lru_list);
+	list_move_tail(&qp->lru_list, &net->ipq_lru_list);
 	write_unlock(&ipfrag_lock);
 
 	return;
@@ -613,6 +599,7 @@
 
 static struct sk_buff *ip_frag_reasm(struct ipq *qp, struct net_device *dev)
 {
+	struct net *net = qp->net;
 	struct iphdr *iph;
 	struct sk_buff *fp, *head = qp->fragments;
 	int len;
@@ -654,12 +641,12 @@
 		head->len -= clone->len;
 		clone->csum = 0;
 		clone->ip_summed = head->ip_summed;
-		atomic_add(clone->truesize, &ip_frag_mem);
+		atomic_add(clone->truesize, &net->ip_frag_mem);
 	}
 
 	skb_shinfo(head)->frag_list = head->next;
 	skb_push(head, head->data - skb_network_header(head));
-	atomic_sub(head->truesize, &ip_frag_mem);
+	atomic_sub(head->truesize, &net->ip_frag_mem);
 
 	for (fp=head->next; fp; fp = fp->next) {
 		head->data_len += fp->len;
@@ -669,7 +656,7 @@
 		else if (head->ip_summed == CHECKSUM_COMPLETE)
 			head->csum = csum_add(head->csum, fp->csum);
 		head->truesize += fp->truesize;
-		atomic_sub(fp->truesize, &ip_frag_mem);
+		atomic_sub(fp->truesize, &net->ip_frag_mem);
 	}
 
 	head->next = NULL;
@@ -700,19 +687,20 @@
 /* Process an incoming IP datagram fragment. */
 struct sk_buff *ip_defrag(struct sk_buff *skb, u32 user)
 {
+	struct net *net = skb->dev->nd_net;
 	struct ipq *qp;
 	struct net_device *dev;
 
 	IP_INC_STATS_BH(IPSTATS_MIB_REASMREQDS);
 
 	/* Start by cleaning up the memory. */
-	if (atomic_read(&ip_frag_mem) > sysctl_ipfrag_high_thresh)
-		ip_evictor();
+	if (atomic_read(&net->ip_frag_mem) > net->sysctl_ipfrag_high_thresh)
+		ip_evictor(net);
 
 	dev = skb->dev;
 
 	/* Lookup (or create) queue header */
-	if ((qp = ip_find(ip_hdr(skb), user)) != NULL) {
+	if ((qp = ip_find(net, ip_hdr(skb), user)) != NULL) {
 		struct sk_buff *ret = NULL;
 
 		spin_lock(&qp->lock);
@@ -733,15 +721,70 @@
 	return NULL;
 }
 
-void __init ipfrag_init(void)
+static int ipfrag_net_init(struct net *net)
 {
-	ipfrag_hash_rnd = (u32) ((num_physpages ^ (num_physpages>>7)) ^
+	struct timer_list *secret_timer;
+	int i;
+
+	/* Fragment cache limits. We will commit 256K at one time. Should we
+	 * cross that limit we will prune down to 192K. This should cope with
+	 * even the most extreme cases without allowing an attacker to measurably
+	 * harm machine performance.
+	 */
+	net->sysctl_ipfrag_high_thresh = 256*1024;
+	net->sysctl_ipfrag_low_thresh = 192*1024;
+	net->sysctl_ipfrag_max_dist = 64;
+
+	/* Important NOTE! Fragment queue must be destroyed before MSL expires.
+	 * RFC791 is wrong proposing to prolongate timer each fragment arrival by TTL.
+	 */
+	net->sysctl_ipfrag_time = IP_FRAG_TIME;
+
+	net->sysctl_ipfrag_secret_interval = 10 * 60 * HZ;
+
+	net->ipq_hash = kzalloc(sizeof(*net->ipq_hash)*IPQ_HASHSZ, GFP_KERNEL);
+	if (!net->ipq_hash)
+		return -ENOMEM;
+
+	for (i = 0; i < IPQ_HASHSZ; i++)
+		INIT_HLIST_HEAD(&net->ipq_hash[i]);
+	INIT_LIST_HEAD(&net->ipq_lru_list);
+	net->ip_frag_nqueues = 0;
+	atomic_set(&net->ip_frag_mem, 0);
+
+
+	net->ipfrag_hash_rnd = (u32) ((num_physpages ^ (num_physpages>>7)) ^
 				 (jiffies ^ (jiffies >> 6)));
 
-	init_timer(&ipfrag_secret_timer);
-	ipfrag_secret_timer.function = ipfrag_secret_rebuild;
-	ipfrag_secret_timer.expires = jiffies + sysctl_ipfrag_secret_interval;
-	add_timer(&ipfrag_secret_timer);
+	secret_timer = &net->ipfrag_secret_timer;
+	init_timer(secret_timer);
+	secret_timer->function = ipfrag_secret_rebuild;
+	secret_timer->expires = jiffies + net->sysctl_ipfrag_secret_interval;
+	secret_timer->data = (unsigned long)net;
+	add_timer(secret_timer);
+
+	return 0;
+}
+
+static void ipfrag_net_exit(struct net *net)
+{
+	del_timer(&net->ipfrag_secret_timer);
+
+	net->sysctl_ipfrag_low_thresh = 0;
+	while (atomic_read(&net->ip_frag_mem))
+		ip_evictor(net);
+
+	kfree(net->ipq_hash);
+}
+
+static struct pernet_operations ipfrag_net_ops = {
+	.init = ipfrag_net_init,
+	.exit = ipfrag_net_exit,
+};
+
+void ipfrag_init(void)
+{
+	register_pernet_subsys(&ipfrag_net_ops);
 }
 
 EXPORT_SYMBOL(ip_defrag);
diff -Nurb linux-2.6.22-590/net/ipv4/ip_gre.c linux-2.6.22-try2-netns/net/ipv4/ip_gre.c
--- linux-2.6.22-590/net/ipv4/ip_gre.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/ip_gre.c	2007-12-19 22:49:20.000000000 -0500
@@ -262,7 +262,7 @@
 		int i;
 		for (i=1; i<100; i++) {
 			sprintf(name, "gre%d", i);
-			if (__dev_get_by_name(name) == NULL)
+			if (__dev_get_by_name(&init_net, name) == NULL)
 				break;
 		}
 		if (i==100)
@@ -397,6 +397,9 @@
 	struct flowi fl;
 	struct rtable *rt;
 
+	if (skb->dev->nd_net != &init_net)
+		return;
+
 	if (p[1] != htons(ETH_P_IP))
 		return;
 
@@ -475,6 +478,7 @@
 
 	/* Try to guess incoming interface */
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	fl.fl4_dst = eiph->saddr;
 	fl.fl4_tos = RT_TOS(eiph->tos);
 	fl.proto = IPPROTO_GRE;
@@ -559,6 +563,10 @@
 	struct ip_tunnel *tunnel;
 	int    offset = 4;
 
+	if (skb->dev->nd_net != &init_net) {
+		kfree_skb(skb);
+		return 0;
+	}
 	if (!pskb_may_pull(skb, 16))
 		goto drop_nolock;
 
@@ -740,7 +748,8 @@
 	}
 
 	{
-		struct flowi fl = { .oif = tunnel->parms.link,
+		struct flowi fl = { .fl_net = &init_net,
+				    .oif = tunnel->parms.link,
 				    .nl_u = { .ip4_u =
 					      { .daddr = dst,
 						.saddr = tiph->saddr,
@@ -1095,7 +1104,8 @@
 	struct ip_tunnel *t = netdev_priv(dev);
 
 	if (MULTICAST(t->parms.iph.daddr)) {
-		struct flowi fl = { .oif = t->parms.link,
+		struct flowi fl = { .fl_net = &init_net,
+				    .oif = t->parms.link,
 				    .nl_u = { .ip4_u =
 					      { .daddr = t->parms.iph.daddr,
 						.saddr = t->parms.iph.saddr,
@@ -1118,7 +1128,7 @@
 {
 	struct ip_tunnel *t = netdev_priv(dev);
 	if (MULTICAST(t->parms.iph.daddr) && t->mlink) {
-		struct in_device *in_dev = inetdev_by_index(t->mlink);
+		struct in_device *in_dev = inetdev_by_index(&init_net, t->mlink);
 		if (in_dev) {
 			ip_mc_dec_group(in_dev, t->parms.iph.daddr);
 			in_dev_put(in_dev);
@@ -1168,7 +1178,8 @@
 	/* Guess output device to choose reasonable mtu and hard_header_len */
 
 	if (iph->daddr) {
-		struct flowi fl = { .oif = tunnel->parms.link,
+		struct flowi fl = { .fl_net = &init_net,
+				    .oif = tunnel->parms.link,
 				    .nl_u = { .ip4_u =
 					      { .daddr = iph->daddr,
 						.saddr = iph->saddr,
@@ -1195,7 +1206,7 @@
 	}
 
 	if (!tdev && tunnel->parms.link)
-		tdev = __dev_get_by_index(tunnel->parms.link);
+		tdev = __dev_get_by_index(&init_net, tunnel->parms.link);
 
 	if (tdev) {
 		hlen = tdev->hard_header_len;
diff -Nurb linux-2.6.22-590/net/ipv4/ip_input.c linux-2.6.22-try2-netns/net/ipv4/ip_input.c
--- linux-2.6.22-590/net/ipv4/ip_input.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/ip_input.c	2007-12-19 22:49:20.000000000 -0500
@@ -280,6 +280,10 @@
 	struct iphdr *iph;
 	struct net_device *dev = skb->dev;
 
+
+	if (skb->dev->nd_net != &init_net)
+		goto drop;
+
 	/* It looks as overkill, because not all
 	   IP options require packet mangling.
 	   But it is the easiest for now, especially taking
diff -Nurb linux-2.6.22-590/net/ipv4/ip_options.c linux-2.6.22-try2-netns/net/ipv4/ip_options.c
--- linux-2.6.22-590/net/ipv4/ip_options.c	2007-12-21 15:33:47.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/ip_options.c	2007-12-19 22:49:20.000000000 -0500
@@ -151,7 +151,7 @@
 						__be32 addr;
 
 						memcpy(&addr, sptr+soffset-1, 4);
-						if (inet_addr_type(addr) != RTN_LOCAL) {
+						if (inet_addr_type(&init_net, addr) != RTN_LOCAL) {
 							dopt->ts_needtime = 1;
 							soffset += 8;
 						}
@@ -400,7 +400,7 @@
 					{
 						__be32 addr;
 						memcpy(&addr, &optptr[optptr[2]-1], 4);
-						if (inet_addr_type(addr) == RTN_UNICAST)
+						if (inet_addr_type(&init_net, addr) == RTN_UNICAST)
 							break;
 						if (skb)
 							timeptr = (__be32*)&optptr[optptr[2]+3];
diff -Nurb linux-2.6.22-590/net/ipv4/ip_output.c linux-2.6.22-try2-netns/net/ipv4/ip_output.c
--- linux-2.6.22-590/net/ipv4/ip_output.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/ip_output.c	2007-12-19 22:49:20.000000000 -0500
@@ -83,8 +83,6 @@
 #include <linux/netlink.h>
 #include <linux/tcp.h>
 
-int sysctl_ip_default_ttl __read_mostly = IPDEFTTL;
-
 /* Generate a checksum for an outgoing IP datagram. */
 __inline__ void ip_send_check(struct iphdr *iph)
 {
@@ -317,7 +315,8 @@
 			daddr = opt->faddr;
 
 		{
-			struct flowi fl = { .oif = sk->sk_bound_dev_if,
+			struct flowi fl = { .fl_net = sk->sk_net,
+					    .oif = sk->sk_bound_dev_if,
 					    .nl_u = { .ip4_u =
 						      { .daddr = daddr,
 							.saddr = inet->saddr,
@@ -1352,7 +1351,8 @@
 	}
 
 	{
-		struct flowi fl = { .oif = arg->bound_dev_if,
+		struct flowi fl = { .fl_net = sk->sk_net,
+				    .oif = arg->bound_dev_if,
 				    .nl_u = { .ip4_u =
 					      { .daddr = daddr,
 						.saddr = rt->rt_spec_dst,
diff -Nurb linux-2.6.22-590/net/ipv4/ip_sockglue.c linux-2.6.22-try2-netns/net/ipv4/ip_sockglue.c
--- linux-2.6.22-590/net/ipv4/ip_sockglue.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/ip_sockglue.c	2007-12-19 22:49:20.000000000 -0500
@@ -411,6 +411,7 @@
 static int do_ip_setsockopt(struct sock *sk, int level,
 			    int optname, char __user *optval, int optlen)
 {
+	struct net *net = sk->sk_net;
 	struct inet_sock *inet = inet_sk(sk);
 	int val=0,err;
 
@@ -596,13 +597,13 @@
 				err = 0;
 				break;
 			}
-			dev = ip_dev_find(mreq.imr_address.s_addr);
+			dev = ip_dev_find(net, mreq.imr_address.s_addr);
 			if (dev) {
 				mreq.imr_ifindex = dev->ifindex;
 				dev_put(dev);
 			}
 		} else
-			dev = __dev_get_by_index(mreq.imr_ifindex);
+			dev = __dev_get_by_index(net, mreq.imr_ifindex);
 
 
 		err = -EADDRNOTAVAIL;
@@ -956,6 +957,7 @@
 static int do_ip_getsockopt(struct sock *sk, int level, int optname,
 			    char __user *optval, int __user *optlen)
 {
+	struct net *net = sk->sk_net;
 	struct inet_sock *inet = inet_sk(sk);
 	int val;
 	int len;
@@ -1023,7 +1025,7 @@
 		break;
 	case IP_TTL:
 		val = (inet->uc_ttl == -1 ?
-		       sysctl_ip_default_ttl :
+		       net->sysctl_ip_default_ttl :
 		       inet->uc_ttl);
 		break;
 	case IP_HDRINCL:
diff -Nurb linux-2.6.22-590/net/ipv4/ipcomp.c linux-2.6.22-try2-netns/net/ipv4/ipcomp.c
--- linux-2.6.22-590/net/ipv4/ipcomp.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/ipcomp.c	2007-12-19 22:49:20.000000000 -0500
@@ -175,6 +175,9 @@
 	struct ip_comp_hdr *ipch = (struct ip_comp_hdr *)(skb->data+(iph->ihl<<2));
 	struct xfrm_state *x;
 
+	if (skb->dev->nd_net != &init_net)
+		return;
+
 	if (icmp_hdr(skb)->type != ICMP_DEST_UNREACH ||
 	    icmp_hdr(skb)->code != ICMP_FRAG_NEEDED)
 		return;
diff -Nurb linux-2.6.22-590/net/ipv4/ipconfig.c linux-2.6.22-try2-netns/net/ipv4/ipconfig.c
--- linux-2.6.22-590/net/ipv4/ipconfig.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/ipconfig.c	2007-12-19 22:49:20.000000000 -0500
@@ -59,6 +59,7 @@
 #include <net/ip.h>
 #include <net/ipconfig.h>
 #include <net/route.h>
+#include <net/net_namespace.h>
 
 #include <asm/uaccess.h>
 #include <net/checksum.h>
@@ -184,16 +185,18 @@
 	struct ic_device *d, **last;
 	struct net_device *dev;
 	unsigned short oflags;
+	struct net_device *lo;
 
 	last = &ic_first_dev;
 	rtnl_lock();
 
 	/* bring loopback device up first */
-	if (dev_change_flags(&loopback_dev, loopback_dev.flags | IFF_UP) < 0)
-		printk(KERN_ERR "IP-Config: Failed to open %s\n", loopback_dev.name);
+	lo = &init_net.loopback_dev;
+	if (dev_change_flags(lo, lo->flags | IFF_UP) < 0)
+		printk(KERN_ERR "IP-Config: Failed to open %s\n", lo->name);
 
-	for_each_netdev(dev) {
-		if (dev == &loopback_dev)
+	for_each_netdev(&init_net, dev) {
+		if (dev == lo)
 			continue;
 		if (user_dev_name[0] ? !strcmp(dev->name, user_dev_name) :
 		    (!(dev->flags & IFF_LOOPBACK) &&
@@ -283,7 +286,7 @@
 
 	mm_segment_t oldfs = get_fs();
 	set_fs(get_ds());
-	res = devinet_ioctl(cmd, (struct ifreq __user *) arg);
+	res = devinet_ioctl(&init_net, cmd, (struct ifreq __user *) arg);
 	set_fs(oldfs);
 	return res;
 }
@@ -294,7 +297,7 @@
 
 	mm_segment_t oldfs = get_fs();
 	set_fs(get_ds());
-	res = ip_rt_ioctl(cmd, (void __user *) arg);
+	res = ip_rt_ioctl(&init_net, cmd, (void __user *) arg);
 	set_fs(oldfs);
 	return res;
 }
@@ -425,6 +428,9 @@
 	unsigned char *sha, *tha;		/* s for "source", t for "target" */
 	struct ic_device *d;
 
+	if (dev->nd_net != &init_net)
+		goto drop;
+
 	if ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)
 		return NET_RX_DROP;
 
@@ -834,6 +840,9 @@
 	struct ic_device *d;
 	int len, ext_len;
 
+	if (dev->nd_net != &init_net)
+		goto drop;
+
 	/* Perform verifications before taking the lock.  */
 	if (skb->pkt_type == PACKET_OTHERHOST)
 		goto drop;
@@ -1253,7 +1262,7 @@
 	__be32 addr;
 
 #ifdef CONFIG_PROC_FS
-	proc_net_fops_create("pnp", S_IRUGO, &pnp_seq_fops);
+	proc_net_fops_create(&init_net, "pnp", S_IRUGO, &pnp_seq_fops);
 #endif /* CONFIG_PROC_FS */
 
 	if (!ic_enable)
diff -Nurb linux-2.6.22-590/net/ipv4/ipip.c linux-2.6.22-try2-netns/net/ipv4/ipip.c
--- linux-2.6.22-590/net/ipv4/ipip.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/ipip.c	2007-12-19 22:49:20.000000000 -0500
@@ -225,7 +225,7 @@
 		int i;
 		for (i=1; i<100; i++) {
 			sprintf(name, "tunl%d", i);
-			if (__dev_get_by_name(name) == NULL)
+			if (__dev_get_by_name(&init_net, name) == NULL)
 				break;
 		}
 		if (i==100)
@@ -403,6 +403,7 @@
 
 	/* Try to guess incoming interface */
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	fl.fl4_daddr = eiph->saddr;
 	fl.fl4_tos = RT_TOS(eiph->tos);
 	fl.proto = IPPROTO_IPIP;
@@ -542,7 +543,8 @@
 	}
 
 	{
-		struct flowi fl = { .oif = tunnel->parms.link,
+		struct flowi fl = { .fl_net = &init_net,
+				    .oif = tunnel->parms.link,
 				    .nl_u = { .ip4_u =
 					      { .daddr = dst,
 						.saddr = tiph->saddr,
@@ -806,7 +808,8 @@
 	memcpy(dev->broadcast, &tunnel->parms.iph.daddr, 4);
 
 	if (iph->daddr) {
-		struct flowi fl = { .oif = tunnel->parms.link,
+		struct flowi fl = { .fl_net = &init_net,
+				    .oif = tunnel->parms.link,
 				    .nl_u = { .ip4_u =
 					      { .daddr = iph->daddr,
 						.saddr = iph->saddr,
@@ -821,7 +824,7 @@
 	}
 
 	if (!tdev && tunnel->parms.link)
-		tdev = __dev_get_by_index(tunnel->parms.link);
+		tdev = __dev_get_by_index(&init_net, tunnel->parms.link);
 
 	if (tdev) {
 		dev->hard_header_len = tdev->hard_header_len + sizeof(struct iphdr);
diff -Nurb linux-2.6.22-590/net/ipv4/ipmr.c linux-2.6.22-try2-netns/net/ipv4/ipmr.c
--- linux-2.6.22-590/net/ipv4/ipmr.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/ipmr.c	2007-12-19 22:49:20.000000000 -0500
@@ -62,6 +62,7 @@
 #include <linux/netfilter_ipv4.h>
 #include <net/ipip.h>
 #include <net/checksum.h>
+#include <net/net_namespace.h>
 #include <net/netlink.h>
 
 #if defined(CONFIG_IP_PIMSM_V1) || defined(CONFIG_IP_PIMSM_V2)
@@ -124,7 +125,7 @@
 {
 	struct net_device  *dev;
 
-	dev = __dev_get_by_name("tunl0");
+	dev = __dev_get_by_name(&init_net, "tunl0");
 
 	if (dev) {
 		int err;
@@ -148,7 +149,7 @@
 
 		dev = NULL;
 
-		if (err == 0 && (dev = __dev_get_by_name(p.name)) != NULL) {
+		if (err == 0 && (dev = __dev_get_by_name(&init_net, p.name)) != NULL) {
 			dev->flags |= IFF_MULTICAST;
 
 			in_dev = __in_dev_get_rtnl(dev);
@@ -320,7 +321,7 @@
 			e->error = -ETIMEDOUT;
 			memset(&e->msg, 0, sizeof(e->msg));
 
-			rtnl_unicast(skb, NETLINK_CB(skb).pid);
+			rtnl_unicast(skb, &init_net, NETLINK_CB(skb).pid);
 		} else
 			kfree_skb(skb);
 	}
@@ -422,7 +423,7 @@
 			return -ENOBUFS;
 		break;
 	case 0:
-		dev = ip_dev_find(vifc->vifc_lcl_addr.s_addr);
+		dev = ip_dev_find(&init_net, vifc->vifc_lcl_addr.s_addr);
 		if (!dev)
 			return -EADDRNOTAVAIL;
 		dev_put(dev);
@@ -532,7 +533,7 @@
 				memset(&e->msg, 0, sizeof(e->msg));
 			}
 
-			rtnl_unicast(skb, NETLINK_CB(skb).pid);
+			rtnl_unicast(skb, &init_net, NETLINK_CB(skb).pid);
 		} else
 			ip_mr_forward(skb, c, 0);
 	}
@@ -848,7 +849,7 @@
 {
 	rtnl_lock();
 	if (sk == mroute_socket) {
-		IPV4_DEVCONF_ALL(MC_FORWARDING)--;
+		IPV4_DEVCONF_ALL(sk->sk_net, MC_FORWARDING)--;
 
 		write_lock_bh(&mrt_lock);
 		mroute_socket=NULL;
@@ -897,7 +898,7 @@
 			mroute_socket=sk;
 			write_unlock_bh(&mrt_lock);
 
-			IPV4_DEVCONF_ALL(MC_FORWARDING)++;
+			IPV4_DEVCONF_ALL(sk->sk_net, MC_FORWARDING)++;
 		}
 		rtnl_unlock();
 		return ret;
@@ -1082,13 +1083,18 @@
 
 static int ipmr_device_event(struct notifier_block *this, unsigned long event, void *ptr)
 {
+	struct net_device *dev = ptr;
 	struct vif_device *v;
 	int ct;
+
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (event != NETDEV_UNREGISTER)
 		return NOTIFY_DONE;
 	v=&vif_table[0];
 	for (ct=0;ct<maxvif;ct++,v++) {
-		if (v->dev==ptr)
+		if (v->dev==dev)
 			vif_delete(ct);
 	}
 	return NOTIFY_DONE;
@@ -1171,7 +1177,8 @@
 #endif
 
 	if (vif->flags&VIFF_TUNNEL) {
-		struct flowi fl = { .oif = vif->link,
+		struct flowi fl = { .fl_net = &init_net,
+				    .oif = vif->link,
 				    .nl_u = { .ip4_u =
 					      { .daddr = vif->remote,
 						.saddr = vif->local,
@@ -1181,7 +1188,8 @@
 			goto out_free;
 		encap = sizeof(struct iphdr);
 	} else {
-		struct flowi fl = { .oif = vif->link,
+		struct flowi fl = { .fl_net = &init_net,
+				    .oif = vif->link,
 				    .nl_u = { .ip4_u =
 					      { .daddr = iph->daddr,
 						.tos = RT_TOS(iph->tos) } },
@@ -1498,6 +1506,10 @@
 	struct iphdr   *encap;
 	struct net_device  *reg_dev = NULL;
 
+	if (skb->dev->nd_net != &init_net) {
+		kfree_skb(skb);
+		return 0;
+	}
 	if (!pskb_may_pull(skb, sizeof(*pim) + sizeof(*encap)))
 		goto drop;
 
@@ -1922,7 +1934,7 @@
 	ipmr_expire_timer.function=ipmr_expire_process;
 	register_netdevice_notifier(&ip_mr_notifier);
 #ifdef CONFIG_PROC_FS
-	proc_net_fops_create("ip_mr_vif", 0, &ipmr_vif_fops);
-	proc_net_fops_create("ip_mr_cache", 0, &ipmr_mfc_fops);
+	proc_net_fops_create(&init_net, "ip_mr_vif", 0, &ipmr_vif_fops);
+	proc_net_fops_create(&init_net, "ip_mr_cache", 0, &ipmr_mfc_fops);
 #endif
 }
diff -Nurb linux-2.6.22-590/net/ipv4/ipvs/ip_vs_app.c linux-2.6.22-try2-netns/net/ipv4/ipvs/ip_vs_app.c
--- linux-2.6.22-590/net/ipv4/ipvs/ip_vs_app.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/ipvs/ip_vs_app.c	2007-12-19 22:49:20.000000000 -0500
@@ -32,6 +32,7 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/mutex.h>
+#include <net/net_namespace.h>
 
 #include <net/ip_vs.h>
 
@@ -616,12 +617,12 @@
 int ip_vs_app_init(void)
 {
 	/* we will replace it with proc_net_ipvs_create() soon */
-	proc_net_fops_create("ip_vs_app", 0, &ip_vs_app_fops);
+	proc_net_fops_create(&init_net, "ip_vs_app", 0, &ip_vs_app_fops);
 	return 0;
 }
 
 
 void ip_vs_app_cleanup(void)
 {
-	proc_net_remove("ip_vs_app");
+	proc_net_remove(&init_net, "ip_vs_app");
 }
diff -Nurb linux-2.6.22-590/net/ipv4/ipvs/ip_vs_conn.c linux-2.6.22-try2-netns/net/ipv4/ipvs/ip_vs_conn.c
--- linux-2.6.22-590/net/ipv4/ipvs/ip_vs_conn.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/ipvs/ip_vs_conn.c	2007-12-19 22:49:20.000000000 -0500
@@ -34,6 +34,7 @@
 #include <linux/seq_file.h>
 #include <linux/jhash.h>
 #include <linux/random.h>
+#include <net/net_namespace.h>
 
 #include <net/ip_vs.h>
 
@@ -922,7 +923,7 @@
 		rwlock_init(&__ip_vs_conntbl_lock_array[idx].l);
 	}
 
-	proc_net_fops_create("ip_vs_conn", 0, &ip_vs_conn_fops);
+	proc_net_fops_create(&init_net, "ip_vs_conn", 0, &ip_vs_conn_fops);
 
 	/* calculate the random value for connection hash */
 	get_random_bytes(&ip_vs_conn_rnd, sizeof(ip_vs_conn_rnd));
@@ -938,6 +939,6 @@
 
 	/* Release the empty cache */
 	kmem_cache_destroy(ip_vs_conn_cachep);
-	proc_net_remove("ip_vs_conn");
+	proc_net_remove(&init_net, "ip_vs_conn");
 	vfree(ip_vs_conn_tab);
 }
diff -Nurb linux-2.6.22-590/net/ipv4/ipvs/ip_vs_core.c linux-2.6.22-try2-netns/net/ipv4/ipvs/ip_vs_core.c
--- linux-2.6.22-590/net/ipv4/ipvs/ip_vs_core.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/ipvs/ip_vs_core.c	2007-12-19 22:49:20.000000000 -0500
@@ -460,7 +460,7 @@
 	   and the destination is RTN_UNICAST (and not local), then create
 	   a cache_bypass connection entry */
 	if (sysctl_ip_vs_cache_bypass && svc->fwmark
-	    && (inet_addr_type(iph->daddr) == RTN_UNICAST)) {
+	    && (inet_addr_type(&init_net, iph->daddr) == RTN_UNICAST)) {
 		int ret, cs;
 		struct ip_vs_conn *cp;
 
@@ -530,6 +530,10 @@
 				       const struct net_device *out,
 				       int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	if (!((*pskb)->ipvs_property))
 		return NF_ACCEPT;
 	/* The packet was sent from IPVS, exit this chain */
@@ -734,6 +738,10 @@
 	struct ip_vs_conn *cp;
 	int ihl;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	EnterFunction(11);
 
 	if (skb->ipvs_property)
@@ -818,7 +826,7 @@
 	 * if it came from this machine itself.  So re-compute
 	 * the routing information.
 	 */
-	if (ip_route_me_harder(pskb, RTN_LOCAL) != 0)
+	if (ip_route_me_harder(&init_net, pskb, RTN_LOCAL) != 0)
 		goto drop;
 	skb = *pskb;
 
@@ -956,12 +964,16 @@
 	int ret, restart;
 	int ihl;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	/*
 	 *	Big tappo: only PACKET_HOST (neither loopback nor mcasts)
 	 *	... don't know why 1st test DOES NOT include 2nd (?)
 	 */
 	if (unlikely(skb->pkt_type != PACKET_HOST
-		     || skb->dev == &loopback_dev || skb->sk)) {
+		     || skb->dev == &init_net.loopback_dev || skb->sk)) {
 		IP_VS_DBG(12, "packet type=%d proto=%d daddr=%d.%d.%d.%d ignored\n",
 			  skb->pkt_type,
 			  ip_hdr(skb)->protocol,
@@ -1062,6 +1074,10 @@
 {
 	int r;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	if (ip_hdr(*pskb)->protocol != IPPROTO_ICMP)
 		return NF_ACCEPT;
 
diff -Nurb linux-2.6.22-590/net/ipv4/ipvs/ip_vs_ctl.c linux-2.6.22-try2-netns/net/ipv4/ipvs/ip_vs_ctl.c
--- linux-2.6.22-590/net/ipv4/ipvs/ip_vs_ctl.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/ipvs/ip_vs_ctl.c	2007-12-19 22:49:20.000000000 -0500
@@ -39,6 +39,7 @@
 #include <net/ip.h>
 #include <net/route.h>
 #include <net/sock.h>
+#include <net/net_namespace.h>
 
 #include <asm/uaccess.h>
 
@@ -679,7 +680,7 @@
 	conn_flags = udest->conn_flags | IP_VS_CONN_F_INACTIVE;
 
 	/* check if local node and update the flags */
-	if (inet_addr_type(udest->addr) == RTN_LOCAL) {
+	if (inet_addr_type(&init_net, udest->addr) == RTN_LOCAL) {
 		conn_flags = (conn_flags & ~IP_VS_CONN_F_FWD_MASK)
 			| IP_VS_CONN_F_LOCALNODE;
 	}
@@ -731,7 +732,7 @@
 
 	EnterFunction(2);
 
-	atype = inet_addr_type(udest->addr);
+	atype = inet_addr_type(&init_net, udest->addr);
 	if (atype != RTN_LOCAL && atype != RTN_UNICAST)
 		return -EINVAL;
 
@@ -1932,6 +1933,9 @@
 	struct ip_vs_service *svc;
 	struct ip_vs_dest_user *udest;
 
+	if (sk->sk_net != &init_net)
+		return -ENOPROTOOPT;
+
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
@@ -2196,6 +2200,9 @@
 	unsigned char arg[128];
 	int ret = 0;
 
+	if (sk->sk_net != &init_net)
+		return -ENOPROTOOPT;
+
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
@@ -2356,8 +2363,8 @@
 		return ret;
 	}
 
-	proc_net_fops_create("ip_vs", 0, &ip_vs_info_fops);
-	proc_net_fops_create("ip_vs_stats",0, &ip_vs_stats_fops);
+	proc_net_fops_create(&init_net, "ip_vs", 0, &ip_vs_info_fops);
+	proc_net_fops_create(&init_net, "ip_vs_stats",0, &ip_vs_stats_fops);
 
 	sysctl_header = register_sysctl_table(vs_root_table);
 
@@ -2390,8 +2397,8 @@
 	cancel_work_sync(&defense_work.work);
 	ip_vs_kill_estimator(&ip_vs_stats);
 	unregister_sysctl_table(sysctl_header);
-	proc_net_remove("ip_vs_stats");
-	proc_net_remove("ip_vs");
+	proc_net_remove(&init_net, "ip_vs_stats");
+	proc_net_remove(&init_net, "ip_vs");
 	nf_unregister_sockopt(&ip_vs_sockopts);
 	LeaveFunction(2);
 }
diff -Nurb linux-2.6.22-590/net/ipv4/ipvs/ip_vs_lblcr.c linux-2.6.22-try2-netns/net/ipv4/ipvs/ip_vs_lblcr.c
--- linux-2.6.22-590/net/ipv4/ipvs/ip_vs_lblcr.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/ipvs/ip_vs_lblcr.c	2007-12-19 22:49:20.000000000 -0500
@@ -843,7 +843,7 @@
 	INIT_LIST_HEAD(&ip_vs_lblcr_scheduler.n_list);
 	sysctl_header = register_sysctl_table(lblcr_root_table);
 #ifdef CONFIG_IP_VS_LBLCR_DEBUG
-	proc_net_create("ip_vs_lblcr", 0, ip_vs_lblcr_getinfo);
+	proc_net_create(&init_net, "ip_vs_lblcr", 0, ip_vs_lblcr_getinfo);
 #endif
 	return register_ip_vs_scheduler(&ip_vs_lblcr_scheduler);
 }
@@ -852,7 +852,7 @@
 static void __exit ip_vs_lblcr_cleanup(void)
 {
 #ifdef CONFIG_IP_VS_LBLCR_DEBUG
-	proc_net_remove("ip_vs_lblcr");
+	proc_net_remove(&init_net, "ip_vs_lblcr");
 #endif
 	unregister_sysctl_table(sysctl_header);
 	unregister_ip_vs_scheduler(&ip_vs_lblcr_scheduler);
diff -Nurb linux-2.6.22-590/net/ipv4/ipvs/ip_vs_sync.c linux-2.6.22-try2-netns/net/ipv4/ipvs/ip_vs_sync.c
--- linux-2.6.22-590/net/ipv4/ipvs/ip_vs_sync.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/ipvs/ip_vs_sync.c	2007-12-19 22:49:20.000000000 -0500
@@ -387,7 +387,7 @@
 	struct net_device *dev;
 	struct inet_sock *inet = inet_sk(sk);
 
-	if ((dev = __dev_get_by_name(ifname)) == NULL)
+	if ((dev = __dev_get_by_name(&init_net, ifname)) == NULL)
 		return -ENODEV;
 
 	if (sk->sk_bound_dev_if && dev->ifindex != sk->sk_bound_dev_if)
@@ -412,7 +412,7 @@
 	int num;
 
 	if (sync_state == IP_VS_STATE_MASTER) {
-		if ((dev = __dev_get_by_name(ip_vs_master_mcast_ifn)) == NULL)
+		if ((dev = __dev_get_by_name(&init_net, ip_vs_master_mcast_ifn)) == NULL)
 			return -ENODEV;
 
 		num = (dev->mtu - sizeof(struct iphdr) -
@@ -423,7 +423,7 @@
 		IP_VS_DBG(7, "setting the maximum length of sync sending "
 			  "message %d.\n", sync_send_mesg_maxlen);
 	} else if (sync_state == IP_VS_STATE_BACKUP) {
-		if ((dev = __dev_get_by_name(ip_vs_backup_mcast_ifn)) == NULL)
+		if ((dev = __dev_get_by_name(&init_net, ip_vs_backup_mcast_ifn)) == NULL)
 			return -ENODEV;
 
 		sync_recv_mesg_maxlen = dev->mtu -
@@ -451,7 +451,7 @@
 	memset(&mreq, 0, sizeof(mreq));
 	memcpy(&mreq.imr_multiaddr, addr, sizeof(struct in_addr));
 
-	if ((dev = __dev_get_by_name(ifname)) == NULL)
+	if ((dev = __dev_get_by_name(&init_net, ifname)) == NULL)
 		return -ENODEV;
 	if (sk->sk_bound_dev_if && dev->ifindex != sk->sk_bound_dev_if)
 		return -EINVAL;
@@ -472,7 +472,7 @@
 	__be32 addr;
 	struct sockaddr_in sin;
 
-	if ((dev = __dev_get_by_name(ifname)) == NULL)
+	if ((dev = __dev_get_by_name(&init_net, ifname)) == NULL)
 		return -ENODEV;
 
 	addr = inet_select_addr(dev, 0, RT_SCOPE_UNIVERSE);
diff -Nurb linux-2.6.22-590/net/ipv4/ipvs/ip_vs_xmit.c linux-2.6.22-try2-netns/net/ipv4/ipvs/ip_vs_xmit.c
--- linux-2.6.22-590/net/ipv4/ipvs/ip_vs_xmit.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/ipvs/ip_vs_xmit.c	2007-12-19 22:49:20.000000000 -0500
@@ -70,6 +70,7 @@
 		if (!(rt = (struct rtable *)
 		      __ip_vs_dst_check(dest, rtos, 0))) {
 			struct flowi fl = {
+				.fl_net = &init_net,
 				.oif = 0,
 				.nl_u = {
 					.ip4_u = {
@@ -93,6 +94,7 @@
 		spin_unlock(&dest->dst_lock);
 	} else {
 		struct flowi fl = {
+			.fl_net = &init_net,
 			.oif = 0,
 			.nl_u = {
 				.ip4_u = {
@@ -160,6 +162,7 @@
 	u8     tos = iph->tos;
 	int    mtu;
 	struct flowi fl = {
+		.fl_net = &init_net,
 		.oif = 0,
 		.nl_u = {
 			.ip4_u = {
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/arp_tables.c linux-2.6.22-try2-netns/net/ipv4/netfilter/arp_tables.c
--- linux-2.6.22-590/net/ipv4/netfilter/arp_tables.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/arp_tables.c	2007-12-19 22:49:20.000000000 -0500
@@ -19,6 +19,7 @@
 #include <linux/proc_fs.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <net/sock.h>
 
 #include <asm/uaccess.h>
 #include <linux/mutex.h>
@@ -773,7 +774,7 @@
 	int ret;
 	struct arpt_table *t;
 
-	t = xt_find_table_lock(NF_ARP, entries->name);
+	t = xt_find_table_lock(&init_net, NF_ARP, entries->name);
 	if (t && !IS_ERR(t)) {
 		struct xt_table_info *private = t->private;
 		duprintf("t->private->number = %u\n",
@@ -843,7 +844,7 @@
 
 	duprintf("arp_tables: Translated table\n");
 
-	t = try_then_request_module(xt_find_table_lock(NF_ARP, tmp.name),
+	t = try_then_request_module(xt_find_table_lock(&init_net, NF_ARP, tmp.name),
 				    "arptable_%s", tmp.name);
 	if (!t || IS_ERR(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
@@ -936,7 +937,7 @@
 		goto free;
 	}
 
-	t = xt_find_table_lock(NF_ARP, tmp.name);
+	t = xt_find_table_lock(&init_net, NF_ARP, tmp.name);
 	if (!t || IS_ERR(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
 		goto free;
@@ -971,6 +972,9 @@
 {
 	int ret;
 
+	if (sk->sk_net != &init_net)
+		return -ENOPROTOOPT;
+
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
@@ -995,6 +999,9 @@
 {
 	int ret;
 
+	if (sk->sk_net != &init_net)
+		return -ENOPROTOOPT;
+
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
@@ -1016,7 +1023,7 @@
 		}
 		name[ARPT_TABLE_MAXNAMELEN-1] = '\0';
 
-		t = try_then_request_module(xt_find_table_lock(NF_ARP, name),
+		t = try_then_request_module(xt_find_table_lock(&init_net, NF_ARP, name),
 					    "arptable_%s", name);
 		if (t && !IS_ERR(t)) {
 			struct arpt_getinfo info;
@@ -1116,7 +1123,7 @@
 		return ret;
 	}
 
-	ret = xt_register_table(table, &bootstrap, newinfo);
+	ret = xt_register_table(&init_net, table, &bootstrap, newinfo);
 	if (ret != 0) {
 		xt_free_table_info(newinfo);
 		return ret;
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/arptable_filter.c linux-2.6.22-try2-netns/net/ipv4/netfilter/arptable_filter.c
--- linux-2.6.22-590/net/ipv4/netfilter/arptable_filter.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/arptable_filter.c	2007-12-19 22:49:20.000000000 -0500
@@ -61,6 +61,10 @@
 			      const struct net_device *out,
 			      int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	return arpt_do_table(pskb, hook, in, out, &packet_filter);
 }
 
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/ip_queue.c linux-2.6.22-try2-netns/net/ipv4/netfilter/ip_queue.c
--- linux-2.6.22-590/net/ipv4/netfilter/ip_queue.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/ip_queue.c	2007-12-19 22:49:20.000000000 -0500
@@ -26,6 +26,7 @@
 #include <linux/mutex.h>
 #include <net/sock.h>
 #include <net/route.h>
+#include <net/net_namespace.h>
 
 #define IPQ_QMAX_DEFAULT 1024
 #define IPQ_PROC_FS_NAME "ip_queue"
@@ -556,6 +557,9 @@
 {
 	struct net_device *dev = ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	/* Drop any packets associated with the downed device */
 	if (event == NETDEV_DOWN)
 		ipq_dev_drop(dev->ifindex);
@@ -575,7 +579,7 @@
 	if (event == NETLINK_URELEASE &&
 	    n->protocol == NETLINK_FIREWALL && n->pid) {
 		write_lock_bh(&queue_lock);
-		if (n->pid == peer_pid)
+		if ((n->net == &init_net) && (n->pid == peer_pid))
 			__ipq_reset();
 		write_unlock_bh(&queue_lock);
 	}
@@ -667,14 +671,14 @@
 	struct proc_dir_entry *proc;
 
 	netlink_register_notifier(&ipq_nl_notifier);
-	ipqnl = netlink_kernel_create(NETLINK_FIREWALL, 0, ipq_rcv_sk,
-				      NULL, THIS_MODULE);
+	ipqnl = netlink_kernel_create(&init_net, NETLINK_FIREWALL, 0,
+				      ipq_rcv_sk, NULL, THIS_MODULE);
 	if (ipqnl == NULL) {
 		printk(KERN_ERR "ip_queue: failed to create netlink socket\n");
 		goto cleanup_netlink_notifier;
 	}
 
-	proc = proc_net_create(IPQ_PROC_FS_NAME, 0, ipq_get_info);
+	proc = proc_net_create(&init_net, IPQ_PROC_FS_NAME, 0, ipq_get_info);
 	if (proc)
 		proc->owner = THIS_MODULE;
 	else {
@@ -695,8 +699,7 @@
 cleanup_sysctl:
 	unregister_sysctl_table(ipq_sysctl_header);
 	unregister_netdevice_notifier(&ipq_dev_notifier);
-	proc_net_remove(IPQ_PROC_FS_NAME);
-
+	proc_net_remove(&init_net, IPQ_PROC_FS_NAME);
 cleanup_ipqnl:
 	sock_release(ipqnl->sk_socket);
 	mutex_lock(&ipqnl_mutex);
@@ -715,7 +718,7 @@
 
 	unregister_sysctl_table(ipq_sysctl_header);
 	unregister_netdevice_notifier(&ipq_dev_notifier);
-	proc_net_remove(IPQ_PROC_FS_NAME);
+	proc_net_remove(&init_net, IPQ_PROC_FS_NAME);
 
 	sock_release(ipqnl->sk_socket);
 	mutex_lock(&ipqnl_mutex);
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/ip_tables.c linux-2.6.22-try2-netns/net/ipv4/netfilter/ip_tables.c
--- linux-2.6.22-590/net/ipv4/netfilter/ip_tables.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/ip_tables.c	2007-12-19 22:49:20.000000000 -0500
@@ -1039,7 +1039,7 @@
 }
 #endif
 
-static int get_info(void __user *user, int *len, int compat)
+static int get_info(struct net *net, void __user *user, int *len, int compat)
 {
 	char name[IPT_TABLE_MAXNAMELEN];
 	struct xt_table *t;
@@ -1059,7 +1059,7 @@
 	if (compat)
 		xt_compat_lock(AF_INET);
 #endif
-	t = try_then_request_module(xt_find_table_lock(AF_INET, name),
+	t = try_then_request_module(xt_find_table_lock(net, AF_INET, name),
 			"iptable_%s", name);
 	if (t && !IS_ERR(t)) {
 		struct ipt_getinfo info;
@@ -1099,7 +1099,7 @@
 }
 
 static int
-get_entries(struct ipt_get_entries __user *uptr, int *len)
+get_entries(struct net *net, struct ipt_get_entries __user *uptr, int *len)
 {
 	int ret;
 	struct ipt_get_entries get;
@@ -1119,7 +1119,7 @@
 		return -EINVAL;
 	}
 
-	t = xt_find_table_lock(AF_INET, get.name);
+	t = xt_find_table_lock(net, AF_INET, get.name);
 	if (t && !IS_ERR(t)) {
 		struct xt_table_info *private = t->private;
 		duprintf("t->private->number = %u\n",
@@ -1142,7 +1142,7 @@
 }
 
 static int
-__do_replace(const char *name, unsigned int valid_hooks,
+__do_replace(struct net *net, const char *name, unsigned int valid_hooks,
 		struct xt_table_info *newinfo, unsigned int num_counters,
 		void __user *counters_ptr)
 {
@@ -1159,7 +1159,7 @@
 		goto out;
 	}
 
-	t = try_then_request_module(xt_find_table_lock(AF_INET, name),
+	t = try_then_request_module(xt_find_table_lock(net, AF_INET, name),
 				    "iptable_%s", name);
 	if (!t || IS_ERR(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
@@ -1211,7 +1211,7 @@
 }
 
 static int
-do_replace(void __user *user, unsigned int len)
+do_replace(struct net *net, void __user *user, unsigned int len)
 {
 	int ret;
 	struct ipt_replace tmp;
@@ -1252,7 +1252,7 @@
 
 	duprintf("ip_tables: Translated table\n");
 
-	ret = __do_replace(tmp.name, tmp.valid_hooks,
+	ret = __do_replace(net, tmp.name, tmp.valid_hooks,
 			      newinfo, tmp.num_counters,
 			      tmp.counters);
 	if (ret)
@@ -1289,7 +1289,7 @@
 }
 
 static int
-do_add_counters(void __user *user, unsigned int len, int compat)
+do_add_counters(struct net *net, void __user *user, unsigned int len, int compat)
 {
 	unsigned int i;
 	struct xt_counters_info tmp;
@@ -1341,7 +1341,7 @@
 		goto free;
 	}
 
-	t = xt_find_table_lock(AF_INET, name);
+	t = xt_find_table_lock(net, AF_INET, name);
 	if (!t || IS_ERR(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
 		goto free;
@@ -1745,7 +1745,7 @@
 }
 
 static int
-compat_do_replace(void __user *user, unsigned int len)
+compat_do_replace(struct net *net, void __user *user, unsigned int len)
 {
 	int ret;
 	struct compat_ipt_replace tmp;
@@ -1786,7 +1786,7 @@
 
 	duprintf("compat_do_replace: Translated table\n");
 
-	ret = __do_replace(tmp.name, tmp.valid_hooks,
+	ret = __do_replace(net, tmp.name, tmp.valid_hooks,
 			      newinfo, tmp.num_counters,
 			      compat_ptr(tmp.counters));
 	if (ret)
@@ -1811,11 +1811,11 @@
 
 	switch (cmd) {
 	case IPT_SO_SET_REPLACE:
-		ret = compat_do_replace(user, len);
+		ret = compat_do_replace(sk->sk_net, user, len);
 		break;
 
 	case IPT_SO_SET_ADD_COUNTERS:
-		ret = do_add_counters(user, len, 1);
+		ret = do_add_counters(sk->sk_net, user, len, 1);
 		break;
 
 	default:
@@ -1904,7 +1904,7 @@
 }
 
 static int
-compat_get_entries(struct compat_ipt_get_entries __user *uptr, int *len)
+compat_get_entries(struct net *net, struct compat_ipt_get_entries __user *uptr, int *len)
 {
 	int ret;
 	struct compat_ipt_get_entries get;
@@ -1928,7 +1928,7 @@
 	}
 
 	xt_compat_lock(AF_INET);
-	t = xt_find_table_lock(AF_INET, get.name);
+	t = xt_find_table_lock(net, AF_INET, get.name);
 	if (t && !IS_ERR(t)) {
 		struct xt_table_info *private = t->private;
 		struct xt_table_info info;
@@ -1966,10 +1966,10 @@
 
 	switch (cmd) {
 	case IPT_SO_GET_INFO:
-		ret = get_info(user, len, 1);
+		ret = get_info(sk->sk_net, user, len, 1);
 		break;
 	case IPT_SO_GET_ENTRIES:
-		ret = compat_get_entries(user, len);
+		ret = compat_get_entries(sk->sk_net, user, len);
 		break;
 	default:
 		ret = do_ipt_get_ctl(sk, cmd, user, len);
@@ -1988,11 +1988,11 @@
 
 	switch (cmd) {
 	case IPT_SO_SET_REPLACE:
-		ret = do_replace(user, len);
+		ret = do_replace(sk->sk_net, user, len);
 		break;
 
 	case IPT_SO_SET_ADD_COUNTERS:
-		ret = do_add_counters(user, len, 0);
+		ret = do_add_counters(sk->sk_net, user, len, 0);
 		break;
 
 	default:
@@ -2013,11 +2013,11 @@
 
 	switch (cmd) {
 	case IPT_SO_GET_INFO:
-		ret = get_info(user, len, 0);
+		ret = get_info(sk->sk_net, user, len, 0);
 		break;
 
 	case IPT_SO_GET_ENTRIES:
-		ret = get_entries(user, len);
+		ret = get_entries(sk->sk_net, user, len);
 		break;
 
 	case IPT_SO_GET_REVISION_MATCH:
@@ -2054,7 +2054,7 @@
 	return ret;
 }
 
-int ipt_register_table(struct xt_table *table, const struct ipt_replace *repl)
+int ipt_register_table(struct net *net, struct xt_table *table, const struct ipt_replace *repl)
 {
 	int ret;
 	struct xt_table_info *newinfo;
@@ -2082,7 +2082,7 @@
 		return ret;
 	}
 
-	ret = xt_register_table(table, &bootstrap, newinfo);
+	ret = xt_register_table(net, table, &bootstrap, newinfo);
 	if (ret != 0) {
 		xt_free_table_info(newinfo);
 		return ret;
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/ipt_CLUSTERIP.c linux-2.6.22-try2-netns/net/ipv4/netfilter/ipt_CLUSTERIP.c
--- linux-2.6.22-590/net/ipv4/netfilter/ipt_CLUSTERIP.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/ipt_CLUSTERIP.c	2007-12-19 22:49:20.000000000 -0500
@@ -27,6 +27,7 @@
 #include <linux/netfilter_ipv4/ipt_CLUSTERIP.h>
 #include <net/netfilter/nf_conntrack.h>
 #include <net/checksum.h>
+#include <net/net_namespace.h>
 
 #define CLUSTERIP_VERSION "0.8"
 
@@ -427,7 +428,7 @@
 				return 0;
 			}
 
-			dev = dev_get_by_name(e->ip.iniface);
+			dev = dev_get_by_name(&init_net, e->ip.iniface);
 			if (!dev) {
 				printk(KERN_WARNING "CLUSTERIP: no such interface %s\n", e->ip.iniface);
 				return 0;
@@ -523,6 +524,10 @@
 	struct arp_payload *payload;
 	struct clusterip_config *c;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	/* we don't care about non-ethernet and non-ipv4 ARP */
 	if (arp->ar_hrd != htons(ARPHRD_ETHER)
 	    || arp->ar_pro != htons(ETH_P_IP)
@@ -735,7 +740,7 @@
 		goto cleanup_target;
 
 #ifdef CONFIG_PROC_FS
-	clusterip_procdir = proc_mkdir("ipt_CLUSTERIP", proc_net);
+	clusterip_procdir = proc_mkdir("ipt_CLUSTERIP", init_net.proc_net);
 	if (!clusterip_procdir) {
 		printk(KERN_ERR "CLUSTERIP: Unable to proc dir entry\n");
 		ret = -ENOMEM;
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/ipt_MASQUERADE.c linux-2.6.22-try2-netns/net/ipv4/netfilter/ipt_MASQUERADE.c
--- linux-2.6.22-590/net/ipv4/netfilter/ipt_MASQUERADE.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/ipt_MASQUERADE.c	2007-12-19 22:49:20.000000000 -0500
@@ -131,6 +131,9 @@
 {
 	struct net_device *dev = ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (event == NETDEV_DOWN) {
 		/* Device was downed.  Search entire table for
 		   conntracks which were associated with that device,
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/ipt_REJECT.c linux-2.6.22-try2-netns/net/ipv4/netfilter/ipt_REJECT.c
--- linux-2.6.22-590/net/ipv4/netfilter/ipt_REJECT.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/ipt_REJECT.c	2007-12-19 22:49:20.000000000 -0500
@@ -137,7 +137,7 @@
 	   )
 		addr_type = RTN_LOCAL;
 
-	if (ip_route_me_harder(&nskb, addr_type))
+	if (ip_route_me_harder(&init_net, &nskb, addr_type))
 		goto free_nskb;
 
 	nskb->ip_summed = CHECKSUM_NONE;
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/ipt_ULOG.c linux-2.6.22-try2-netns/net/ipv4/netfilter/ipt_ULOG.c
--- linux-2.6.22-590/net/ipv4/netfilter/ipt_ULOG.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/ipt_ULOG.c	2007-12-19 22:49:20.000000000 -0500
@@ -419,7 +419,8 @@
 	for (i = 0; i < ULOG_MAXNLGROUPS; i++)
 		setup_timer(&ulog_buffers[i].timer, ulog_timer, i);
 
-	nflognl = netlink_kernel_create(NETLINK_NFLOG, ULOG_MAXNLGROUPS, NULL,
+	nflognl = netlink_kernel_create(&init_net,
+					NETLINK_NFLOG, ULOG_MAXNLGROUPS, NULL,
 					NULL, THIS_MODULE);
 	if (!nflognl)
 		return -ENOMEM;
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/ipt_addrtype.c linux-2.6.22-try2-netns/net/ipv4/netfilter/ipt_addrtype.c
--- linux-2.6.22-590/net/ipv4/netfilter/ipt_addrtype.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/ipt_addrtype.c	2007-12-19 22:49:20.000000000 -0500
@@ -24,7 +24,7 @@
 
 static inline int match_type(__be32 addr, u_int16_t mask)
 {
-	return !!(mask & (1 << inet_addr_type(addr)));
+	return !!(mask & (1 << inet_addr_type(&init_net, addr)));
 }
 
 static int match(const struct sk_buff *skb,
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/ipt_recent.c linux-2.6.22-try2-netns/net/ipv4/netfilter/ipt_recent.c
--- linux-2.6.22-590/net/ipv4/netfilter/ipt_recent.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/ipt_recent.c	2007-12-19 22:49:20.000000000 -0500
@@ -24,6 +24,7 @@
 #include <linux/bitops.h>
 #include <linux/skbuff.h>
 #include <linux/inet.h>
+#include <net/net_namespace.h>
 
 #include <linux/netfilter/x_tables.h>
 #include <linux/netfilter_ipv4/ipt_recent.h>
@@ -485,7 +486,7 @@
 #ifdef CONFIG_PROC_FS
 	if (err)
 		return err;
-	proc_dir = proc_mkdir("ipt_recent", proc_net);
+	proc_dir = proc_mkdir("ipt_recent", init_net.proc_net);
 	if (proc_dir == NULL) {
 		xt_unregister_match(&recent_match);
 		err = -ENOMEM;
@@ -499,7 +500,7 @@
 	BUG_ON(!list_empty(&tables));
 	xt_unregister_match(&recent_match);
 #ifdef CONFIG_PROC_FS
-	remove_proc_entry("ipt_recent", proc_net);
+	remove_proc_entry("ipt_recent", init_net.proc_net);
 #endif
 }
 
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/iptable_filter.c linux-2.6.22-try2-netns/net/ipv4/netfilter/iptable_filter.c
--- linux-2.6.22-590/net/ipv4/netfilter/iptable_filter.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/iptable_filter.c	2007-12-19 22:49:20.000000000 -0500
@@ -26,7 +26,7 @@
 	struct ipt_replace repl;
 	struct ipt_standard entries[3];
 	struct ipt_error term;
-} initial_table __initdata = {
+} initial_table = {
 	.repl = {
 		.name = "filter",
 		.valid_hooks = FILTER_VALID_HOOKS,
@@ -51,7 +51,7 @@
 	.term = IPT_ERROR_INIT,			/* ERROR */
 };
 
-static struct xt_table packet_filter = {
+static struct xt_table ip_packet_filter_dflt = {
 	.name		= "filter",
 	.valid_hooks	= FILTER_VALID_HOOKS,
 	.lock		= RW_LOCK_UNLOCKED,
@@ -67,7 +67,9 @@
 	 const struct net_device *out,
 	 int (*okfn)(struct sk_buff *))
 {
-	return ipt_do_table(pskb, hook, in, out, &packet_filter);
+	struct net *net = (in?in:out)->nd_net;
+
+	return ipt_do_table(pskb, hook, in, out, net->ip_packet_filter);
 }
 
 static unsigned int
@@ -77,6 +79,8 @@
 		   const struct net_device *out,
 		   int (*okfn)(struct sk_buff *))
 {
+	struct net *net = (in?in:out)->nd_net;
+
 	/* root is playing with raw sockets. */
 	if ((*pskb)->len < sizeof(struct iphdr)
 	    || ip_hdrlen(*pskb) < sizeof(struct iphdr)) {
@@ -86,7 +90,7 @@
 		return NF_ACCEPT;
 	}
 
-	return ipt_do_table(pskb, hook, in, out, &packet_filter);
+	return ipt_do_table(pskb, hook, in, out, net->ip_packet_filter);
 }
 
 static struct nf_hook_ops ipt_ops[] = {
@@ -117,6 +121,30 @@
 static int forward = NF_ACCEPT;
 module_param(forward, bool, 0000);
 
+static int iptable_filter_net_init(struct net *net)
+{
+	/* Allocate the table */
+	net->ip_packet_filter = kmemdup(&ip_packet_filter_dflt,
+					sizeof(*net->ip_packet_filter),
+					GFP_KERNEL);
+	if (!net->ip_packet_filter)
+		return -ENOMEM;
+
+	/* Register table */
+	return ipt_register_table(net, net->ip_packet_filter, &initial_table.repl);
+}
+
+static void iptable_filter_net_exit(struct net *net)
+{
+	ipt_unregister_table(net->ip_packet_filter);
+	kfree(net->ip_packet_filter);
+}
+
+static struct pernet_operations iptable_filter_net_ops = {
+	.init = iptable_filter_net_init,
+	.exit = iptable_filter_net_exit,
+};
+
 static int __init iptable_filter_init(void)
 {
 	int ret;
@@ -130,7 +158,7 @@
 	initial_table.entries[1].target.verdict = -forward - 1;
 
 	/* Register table */
-	ret = ipt_register_table(&packet_filter, &initial_table.repl);
+	ret = register_pernet_subsys(&iptable_filter_net_ops);
 	if (ret < 0)
 		return ret;
 
@@ -142,14 +170,14 @@
 	return ret;
 
  cleanup_table:
-	ipt_unregister_table(&packet_filter);
+	unregister_pernet_subsys(&iptable_filter_net_ops);
 	return ret;
 }
 
 static void __exit iptable_filter_fini(void)
 {
 	nf_unregister_hooks(ipt_ops, ARRAY_SIZE(ipt_ops));
-	ipt_unregister_table(&packet_filter);
+	unregister_pernet_subsys(&iptable_filter_net_ops);
 }
 
 module_init(iptable_filter_init);
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/iptable_mangle.c linux-2.6.22-try2-netns/net/ipv4/netfilter/iptable_mangle.c
--- linux-2.6.22-590/net/ipv4/netfilter/iptable_mangle.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/iptable_mangle.c	2007-12-19 22:49:20.000000000 -0500
@@ -80,6 +80,10 @@
 	 const struct net_device *out,
 	 int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	return ipt_do_table(pskb, hook, in, out, &packet_mangler);
 }
 
@@ -96,6 +100,10 @@
 	__be32 saddr, daddr;
 	u_int32_t mark;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	/* root is playing with raw sockets. */
 	if ((*pskb)->len < sizeof(struct iphdr)
 	    || ip_hdrlen(*pskb) < sizeof(struct iphdr)) {
@@ -121,7 +129,7 @@
 		    iph->daddr != daddr ||
 		    (*pskb)->mark != mark ||
 		    iph->tos != tos)
-			if (ip_route_me_harder(pskb, RTN_UNSPEC))
+			if (ip_route_me_harder(&init_net, pskb, RTN_UNSPEC))
 				ret = NF_DROP;
 	}
 
@@ -171,7 +179,7 @@
 	int ret;
 
 	/* Register table */
-	ret = ipt_register_table(&packet_mangler, &initial_table.repl);
+	ret = ipt_register_table(&init_net, &packet_mangler, &initial_table.repl);
 	if (ret < 0)
 		return ret;
 
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/iptable_raw.c linux-2.6.22-try2-netns/net/ipv4/netfilter/iptable_raw.c
--- linux-2.6.22-590/net/ipv4/netfilter/iptable_raw.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/iptable_raw.c	2007-12-19 22:49:20.000000000 -0500
@@ -52,6 +52,10 @@
 	 const struct net_device *out,
 	 int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	return ipt_do_table(pskb, hook, in, out, &packet_raw);
 }
 
@@ -96,7 +100,7 @@
 	int ret;
 
 	/* Register table */
-	ret = ipt_register_table(&packet_raw, &initial_table.repl);
+	ret = ipt_register_table(&init_net, &packet_raw, &initial_table.repl);
 	if (ret < 0)
 		return ret;
 
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c linux-2.6.22-try2-netns/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
--- linux-2.6.22-590/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2007-12-19 22:49:20.000000000 -0500
@@ -120,6 +120,10 @@
 				 const struct net_device *out,
 				 int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	/* We've seen it coming out the other side: confirm it */
 	return nf_conntrack_confirm(pskb);
 }
@@ -135,6 +139,10 @@
 	struct nf_conn_help *help;
 	struct nf_conntrack_helper *helper;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	/* This is where we call the helper: as the packet goes out. */
 	ct = nf_ct_get(*pskb, &ctinfo);
 	if (!ct || ctinfo == IP_CT_RELATED + IP_CT_IS_REPLY)
@@ -157,6 +165,10 @@
 					  const struct net_device *out,
 					  int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	/* Previously seen (loopback)?  Ignore.  Do this before
 	   fragment check. */
 	if ((*pskb)->nfct)
@@ -180,6 +192,10 @@
 				      const struct net_device *out,
 				      int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	return nf_conntrack_in(PF_INET, hooknum, pskb);
 }
 
@@ -189,6 +205,10 @@
 					 const struct net_device *out,
 					 int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	/* root is playing with raw sockets. */
 	if ((*pskb)->len < sizeof(struct iphdr)
 	    || ip_hdrlen(*pskb) < sizeof(struct iphdr)) {
@@ -325,6 +345,9 @@
 	struct nf_conntrack_tuple_hash *h;
 	struct nf_conntrack_tuple tuple;
 
+	if (sk->sk_net != &init_net)
+		return -ENOPROTOOPT;
+
 	NF_CT_TUPLE_U_BLANK(&tuple);
 	tuple.src.u3.ip = inet->rcv_saddr;
 	tuple.src.u.tcp.port = inet->sport;
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c linux-2.6.22-try2-netns/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c
--- linux-2.6.22-590/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c	2007-12-19 22:49:20.000000000 -0500
@@ -11,6 +11,7 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/percpu.h>
+#include <net/net_namespace.h>
 
 #include <linux/netfilter.h>
 #include <net/netfilter/nf_conntrack_core.h>
@@ -378,16 +379,16 @@
 {
 	struct proc_dir_entry *proc, *proc_exp, *proc_stat;
 
-	proc = proc_net_fops_create("ip_conntrack", 0440, &ct_file_ops);
+	proc = proc_net_fops_create(&init_net, "ip_conntrack", 0440, &ct_file_ops);
 	if (!proc)
 		goto err1;
 
-	proc_exp = proc_net_fops_create("ip_conntrack_expect", 0440,
+	proc_exp = proc_net_fops_create(&init_net, "ip_conntrack_expect", 0440,
 					&ip_exp_file_ops);
 	if (!proc_exp)
 		goto err2;
 
-	proc_stat = create_proc_entry("ip_conntrack", S_IRUGO, proc_net_stat);
+	proc_stat = create_proc_entry("ip_conntrack", S_IRUGO, init_net.proc_net_stat);
 	if (!proc_stat)
 		goto err3;
 
@@ -397,16 +398,16 @@
 	return 0;
 
 err3:
-	proc_net_remove("ip_conntrack_expect");
+	proc_net_remove(&init_net, "ip_conntrack_expect");
 err2:
-	proc_net_remove("ip_conntrack");
+	proc_net_remove(&init_net, "ip_conntrack");
 err1:
 	return -ENOMEM;
 }
 
 void __exit nf_conntrack_ipv4_compat_fini(void)
 {
-	remove_proc_entry("ip_conntrack", proc_net_stat);
-	proc_net_remove("ip_conntrack_expect");
-	proc_net_remove("ip_conntrack");
+	remove_proc_entry("ip_conntrack", init_net.proc_net_stat);
+	proc_net_remove(&init_net, "ip_conntrack_expect");
+	proc_net_remove(&init_net, "ip_conntrack");
 }
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/nf_nat_rule.c linux-2.6.22-try2-netns/net/ipv4/netfilter/nf_nat_rule.c
--- linux-2.6.22-590/net/ipv4/netfilter/nf_nat_rule.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/nf_nat_rule.c	2007-12-19 22:49:20.000000000 -0500
@@ -98,7 +98,10 @@
 static void warn_if_extra_mangle(__be32 dstip, __be32 srcip)
 {
 	static int warned = 0;
-	struct flowi fl = { .nl_u = { .ip4_u = { .daddr = dstip } } };
+	struct flowi fl = {
+		.fl_net = &init_net,
+		.nl_u = { .ip4_u = { .daddr = dstip } }
+	};
 	struct rtable *rt;
 
 	if (ip_route_output_key(&rt, &fl) != 0)
@@ -252,7 +255,7 @@
 {
 	int ret;
 
-	ret = ipt_register_table(&nat_table, &nat_initial_table.repl);
+	ret = ipt_register_table(&init_net, &nat_table, &nat_initial_table.repl);
 	if (ret != 0)
 		return ret;
 	ret = xt_register_target(&ipt_snat_reg);
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter/nf_nat_standalone.c linux-2.6.22-try2-netns/net/ipv4/netfilter/nf_nat_standalone.c
--- linux-2.6.22-590/net/ipv4/netfilter/nf_nat_standalone.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter/nf_nat_standalone.c	2007-12-19 22:49:20.000000000 -0500
@@ -83,6 +83,10 @@
 	/* maniptype == SRC for postrouting. */
 	enum nf_nat_manip_type maniptype = HOOK2MANIP(hooknum);
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	/* We never see fragments: conntrack defrags on pre-routing
 	   and local-out, and nf_nat_out protects post-routing. */
 	NF_CT_ASSERT(!(ip_hdr(*pskb)->frag_off & htons(IP_MF | IP_OFFSET)));
@@ -172,6 +176,10 @@
 	unsigned int ret;
 	__be32 daddr = ip_hdr(*pskb)->daddr;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	ret = nf_nat_fn(hooknum, pskb, in, out, okfn);
 	if (ret != NF_DROP && ret != NF_STOLEN &&
 	    daddr != ip_hdr(*pskb)->daddr) {
@@ -194,6 +202,10 @@
 #endif
 	unsigned int ret;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	/* root is playing with raw sockets. */
 	if ((*pskb)->len < sizeof(struct iphdr) ||
 	    ip_hdrlen(*pskb) < sizeof(struct iphdr))
@@ -227,6 +239,10 @@
 	enum ip_conntrack_info ctinfo;
 	unsigned int ret;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	/* root is playing with raw sockets. */
 	if ((*pskb)->len < sizeof(struct iphdr) ||
 	    ip_hdrlen(*pskb) < sizeof(struct iphdr))
@@ -239,7 +255,7 @@
 
 		if (ct->tuplehash[dir].tuple.dst.u3.ip !=
 		    ct->tuplehash[!dir].tuple.src.u3.ip) {
-			if (ip_route_me_harder(pskb, RTN_UNSPEC))
+			if (ip_route_me_harder(&init_net, pskb, RTN_UNSPEC))
 				ret = NF_DROP;
 		}
 #ifdef CONFIG_XFRM
@@ -262,6 +278,10 @@
 	struct nf_conn *ct;
 	enum ip_conntrack_info ctinfo;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	ct = nf_ct_get(*pskb, &ctinfo);
 	if (ct && test_bit(IPS_SEQ_ADJUST_BIT, &ct->status)) {
 		DEBUGP("nf_nat_standalone: adjusting sequence number\n");
diff -Nurb linux-2.6.22-590/net/ipv4/netfilter.c linux-2.6.22-try2-netns/net/ipv4/netfilter.c
--- linux-2.6.22-590/net/ipv4/netfilter.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/netfilter.c	2007-12-19 22:49:20.000000000 -0500
@@ -8,7 +8,7 @@
 #include <net/ip.h>
 
 /* route_me_harder function, used by iptable_nat, iptable_mangle + ip_queue */
-int ip_route_me_harder(struct sk_buff **pskb, unsigned addr_type)
+int ip_route_me_harder(struct net *net, struct sk_buff **pskb, unsigned addr_type)
 {
 	const struct iphdr *iph = ip_hdr(*pskb);
 	struct rtable *rt;
@@ -17,7 +17,8 @@
 	unsigned int hh_len;
 	unsigned int type;
 
-	type = inet_addr_type(iph->saddr);
+	fl.fl_net = net;
+	type = inet_addr_type(net, iph->saddr);
 	if (addr_type == RTN_UNSPEC)
 		addr_type = type;
 
@@ -155,12 +156,13 @@
 	const struct ip_rt_info *rt_info = nf_info_reroute(info);
 
 	if (info->hook == NF_IP_LOCAL_OUT) {
+		struct net *net = (info->indev?info->indev:info->outdev)->nd_net;
 		const struct iphdr *iph = ip_hdr(*pskb);
 
 		if (!(iph->tos == rt_info->tos
 		      && iph->daddr == rt_info->daddr
 		      && iph->saddr == rt_info->saddr))
-			return ip_route_me_harder(pskb, RTN_UNSPEC);
+			return ip_route_me_harder(net, pskb, RTN_UNSPEC);
 	}
 	return 0;
 }
diff -Nurb linux-2.6.22-590/net/ipv4/proc.c linux-2.6.22-try2-netns/net/ipv4/proc.c
--- linux-2.6.22-590/net/ipv4/proc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/proc.c	2007-12-19 22:49:20.000000000 -0500
@@ -44,6 +44,7 @@
 #include <linux/seq_file.h>
 #include <net/sock.h>
 #include <net/raw.h>
+#include <net/net_namespace.h>
 
 static int fold_prot_inuse(struct proto *proto)
 {
@@ -69,8 +70,9 @@
 	seq_printf(seq, "UDP: inuse %d\n", fold_prot_inuse(&udp_prot));
 	seq_printf(seq, "UDPLITE: inuse %d\n", fold_prot_inuse(&udplite_prot));
 	seq_printf(seq, "RAW: inuse %d\n", fold_prot_inuse(&raw_prot));
-	seq_printf(seq,  "FRAG: inuse %d memory %d\n", ip_frag_nqueues,
-		   atomic_read(&ip_frag_mem));
+	seq_printf(seq,  "FRAG: inuse %d memory %d\n", 
+		   init_net.ip_frag_nqueues,
+		   atomic_read(&init_net.ip_frag_mem));
 	return 0;
 }
 
@@ -260,7 +262,8 @@
 		seq_printf(seq, " %s", snmp4_ipstats_list[i].name);
 
 	seq_printf(seq, "\nIp: %d %d",
-		   IPV4_DEVCONF_ALL(FORWARDING) ? 1 : 2, sysctl_ip_default_ttl);
+		   IPV4_DEVCONF_ALL(&init_net, FORWARDING) ? 1 : 2,
+		   init_net.sysctl_ip_default_ttl);
 
 	for (i = 0; snmp4_ipstats_list[i].name != NULL; i++)
 		seq_printf(seq, " %lu",
@@ -380,20 +383,20 @@
 {
 	int rc = 0;
 
-	if (!proc_net_fops_create("netstat", S_IRUGO, &netstat_seq_fops))
+	if (!proc_net_fops_create(&init_net, "netstat", S_IRUGO, &netstat_seq_fops))
 		goto out_netstat;
 
-	if (!proc_net_fops_create("snmp", S_IRUGO, &snmp_seq_fops))
+	if (!proc_net_fops_create(&init_net, "snmp", S_IRUGO, &snmp_seq_fops))
 		goto out_snmp;
 
-	if (!proc_net_fops_create("sockstat", S_IRUGO, &sockstat_seq_fops))
+	if (!proc_net_fops_create(&init_net, "sockstat", S_IRUGO, &sockstat_seq_fops))
 		goto out_sockstat;
 out:
 	return rc;
 out_sockstat:
-	proc_net_remove("snmp");
+	proc_net_remove(&init_net, "snmp");
 out_snmp:
-	proc_net_remove("netstat");
+	proc_net_remove(&init_net, "netstat");
 out_netstat:
 	rc = -ENOMEM;
 	goto out;
diff -Nurb linux-2.6.22-590/net/ipv4/raw.c linux-2.6.22-try2-netns/net/ipv4/raw.c
--- linux-2.6.22-590/net/ipv4/raw.c	2007-12-21 15:33:47.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/raw.c	2007-12-19 23:30:30.000000000 -0500
@@ -73,6 +73,7 @@
 #include <net/inet_common.h>
 #include <net/checksum.h>
 #include <net/xfrm.h>
+#include <net/net_namespace.h>
 #include <linux/rtnetlink.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
@@ -101,7 +102,7 @@
 	write_unlock_bh(&raw_v4_lock);
 }
 
-struct sock *__raw_v4_lookup(struct sock *sk, unsigned short num,
+struct sock *__raw_v4_lookup(struct net *net, struct sock *sk, unsigned short num,
 			     __be32 raddr, __be32 laddr,
 			     int dif, int tag)
 {
@@ -110,6 +111,9 @@
 	sk_for_each_from(sk, node) {
 		struct inet_sock *inet = inet_sk(sk);
 
+		if (sk->sk_net != net)
+			continue;
+
 		if (inet->num == num 					&&
 		    !(inet->daddr && inet->daddr != raddr) 		&&
 		    (!sk->sk_nx_info || tag == 1 || sk->sk_nid == tag)	&&
@@ -152,6 +156,7 @@
  */
 int raw_v4_input(struct sk_buff *skb, struct iphdr *iph, int hash)
 {
+	struct net *net = skb->dev->nd_net;
 	struct sock *sk;
 	struct hlist_head *head;
 	int delivered = 0;
@@ -160,7 +165,7 @@
 	head = &raw_v4_htable[hash];
 	if (hlist_empty(head))
 		goto out;
-	sk = __raw_v4_lookup(__sk_head(head), iph->protocol,
+	sk = __raw_v4_lookup(net, __sk_head(head), iph->protocol,
 			     iph->saddr, iph->daddr,
 			     skb->dev->ifindex, skb->skb_tag);
 
@@ -173,7 +178,7 @@
 			if (clone)
 				raw_rcv(sk, clone);
 		}
-		sk = __raw_v4_lookup(sk_next(sk), iph->protocol,
+		sk = __raw_v4_lookup(net, sk_next(sk), iph->protocol,
 				     iph->saddr, iph->daddr,
 				     skb->dev->ifindex, skb->skb_tag);
 	}
@@ -484,7 +489,8 @@
 	}
 
 	{
-		struct flowi fl = { .oif = ipc.oif,
+		struct flowi fl = { .fl_net = sk->sk_net,
+				    .oif = ipc.oif,
 				    .nl_u = { .ip4_u =
 					      { .daddr = daddr,
 						.saddr = saddr,
@@ -574,7 +580,7 @@
 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_in))
 		goto out;
 	v4_map_sock_addr(inet, addr, &nsa);
-	chk_addr_ret = inet_addr_type(nsa.saddr);
+	chk_addr_ret = inet_addr_type(sk->sk_net, nsa.saddr);
 	ret = -EADDRNOTAVAIL;
 	if (nsa.saddr && chk_addr_ret != RTN_LOCAL &&
 	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
@@ -798,6 +804,7 @@
 
 #ifdef CONFIG_PROC_FS
 struct raw_iter_state {
+	struct net *net;
 	int bucket;
 };
 
@@ -811,11 +818,14 @@
 	for (state->bucket = 0; state->bucket < RAWV4_HTABLE_SIZE; ++state->bucket) {
 		struct hlist_node *node;
 
-		sk_for_each(sk, node, &raw_v4_htable[state->bucket])
+		sk_for_each(sk, node, &raw_v4_htable[state->bucket]) {
+ 			if (sk->sk_net != state->net)
+ 				continue;
 			if (sk->sk_family == PF_INET &&
 				nx_check(sk->sk_nid, VS_WATCH_P | VS_IDENT))
 				goto found;
 	}
+	}
 	sk = NULL;
 found:
 	return sk;
@@ -830,7 +840,7 @@
 try_again:
 		;
 	} while (sk && (sk->sk_family != PF_INET ||
-		!nx_check(sk->sk_nid, VS_WATCH_P | VS_IDENT)));
+		!nx_check(sk->sk_nid, VS_WATCH_P | VS_IDENT) || (sk->sk_net != state->net)));
 
 	if (!sk && ++state->bucket < RAWV4_HTABLE_SIZE) {
 		sk = sk_head(&raw_v4_htable[state->bucket]);
@@ -933,6 +943,7 @@
 	seq = file->private_data;
 	seq->private = s;
 	memset(s, 0, sizeof(*s));
+	s->net = get_net(PROC_NET(inode));
 out:
 	return rc;
 out_kfree:
@@ -940,23 +951,46 @@
 	goto out;
 }
 
+static int raw_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct raw_iter_state *state = seq->private;
+	put_net(state->net);
+	return seq_release_private(inode, file);
+}
+
 static const struct file_operations raw_seq_fops = {
 	.owner	 = THIS_MODULE,
 	.open	 = raw_seq_open,
 	.read	 = seq_read,
 	.llseek	 = seq_lseek,
-	.release = seq_release_private,
+	.release = raw_seq_release,
 };
 
-int __init raw_proc_init(void)
+static int raw_proc_net_init(struct net *net)
 {
-	if (!proc_net_fops_create("raw", S_IRUGO, &raw_seq_fops))
+	if (!proc_net_fops_create(net, "raw", S_IRUGO, &raw_seq_fops))
 		return -ENOMEM;
 	return 0;
 }
 
+static void raw_proc_net_exit(struct net *net)
+{
+	proc_net_remove(net, "raw");
+}
+
+static struct pernet_operations raw_proc_net_ops = {
+	.init = raw_proc_net_init,
+	.exit = raw_proc_net_exit,
+};
+
+int __init raw_proc_init(void)
+{
+	return register_pernet_subsys(&raw_proc_net_ops);
+}
+
 void __init raw_proc_exit(void)
 {
-	proc_net_remove("raw");
+	unregister_pernet_subsys(&raw_proc_net_ops);
 }
 #endif /* CONFIG_PROC_FS */
diff -Nurb linux-2.6.22-590/net/ipv4/route.c linux-2.6.22-try2-netns/net/ipv4/route.c
--- linux-2.6.22-590/net/ipv4/route.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/route.c	2007-12-19 22:49:20.000000000 -0500
@@ -102,6 +102,7 @@
 #include <net/icmp.h>
 #include <net/xfrm.h>
 #include <net/netevent.h>
+#include <net/net_namespace.h>
 #include <net/rtnetlink.h>
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
@@ -265,6 +266,7 @@
 
 #ifdef CONFIG_PROC_FS
 struct rt_cache_iter_state {
+	struct net *net;
 	int bucket;
 };
 
@@ -333,6 +335,7 @@
 
 static int rt_cache_seq_show(struct seq_file *seq, void *v)
 {
+	struct rt_cache_iter_state *st = seq->private;
 	if (v == SEQ_START_TOKEN)
 		seq_printf(seq, "%-127s\n",
 			   "Iface\tDestination\tGateway \tFlags\t\tRefCnt\tUse\t"
@@ -342,6 +345,9 @@
 		struct rtable *r = v;
 		char temp[256];
 
+		if (r->fl.fl_net != st->net)
+			return 0;
+
 		sprintf(temp, "%s\t%08lX\t%08lX\t%8X\t%d\t%u\t%d\t"
 			      "%08lX\t%d\t%u\t%u\t%02X\t%d\t%1d\t%08X",
 			r->u.dst.dev ? r->u.dst.dev->name : "*",
@@ -384,6 +390,7 @@
 	seq          = file->private_data;
 	seq->private = s;
 	memset(s, 0, sizeof(*s));
+	s->net = get_net(PROC_NET(inode));
 out:
 	return rc;
 out_kfree:
@@ -391,12 +398,20 @@
 	goto out;
 }
 
+static int rt_cache_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct rt_cache_iter_state *st = seq->private;
+	put_net(st->net);
+	return seq_release_private(inode, file);
+}
+
 static const struct file_operations rt_cache_seq_fops = {
 	.owner	 = THIS_MODULE,
 	.open	 = rt_cache_seq_open,
 	.read	 = seq_read,
 	.llseek	 = seq_lseek,
-	.release = seq_release_private,
+	.release = rt_cache_seq_release,
 };
 
 
@@ -562,13 +577,14 @@
 
 static inline int compare_keys(struct flowi *fl1, struct flowi *fl2)
 {
-	return ((__force u32)((fl1->nl_u.ip4_u.daddr ^ fl2->nl_u.ip4_u.daddr) |
+	return (((__force u32)((fl1->nl_u.ip4_u.daddr ^ fl2->nl_u.ip4_u.daddr) |
 		(fl1->nl_u.ip4_u.saddr ^ fl2->nl_u.ip4_u.saddr)) |
 		(fl1->mark ^ fl2->mark) |
 		(*(u16 *)&fl1->nl_u.ip4_u.tos ^
 		 *(u16 *)&fl2->nl_u.ip4_u.tos) |
 		(fl1->oif ^ fl2->oif) |
-		(fl1->iif ^ fl2->iif)) == 0;
+		(fl1->iif ^ fl2->iif)) == 0) &&
+		fl1->fl_net == fl2->fl_net;
 }
 
 /* This runs via a timer and thus is always in BH context. */
@@ -963,7 +979,7 @@
 	static DEFINE_SPINLOCK(rt_peer_lock);
 	struct inet_peer *peer;
 
-	peer = inet_getpeer(rt->rt_dst, create);
+	peer = inet_getpeer(rt->fl.fl_net, rt->rt_dst, create);
 
 	spin_lock_bh(&rt_peer_lock);
 	if (rt->peer == NULL) {
@@ -1056,7 +1072,7 @@
 		if (IN_DEV_SEC_REDIRECTS(in_dev) && ip_fib_check_default(new_gw, dev))
 			goto reject_redirect;
 	} else {
-		if (inet_addr_type(new_gw) != RTN_UNICAST)
+		if (inet_addr_type(dev->nd_net, new_gw) != RTN_UNICAST)
 			goto reject_redirect;
 	}
 
@@ -1097,6 +1113,7 @@
 
 				/* Copy all the information. */
 				*rt = *rth;
+				hold_net(rt->fl.fl_net);
 				INIT_RCU_HEAD(&rt->u.dst.rcu_head);
 				rt->u.dst.__use		= 1;
 				atomic_set(&rt->u.dst.__refcnt, 1);
@@ -1315,7 +1332,7 @@
 	__be32  daddr = iph->daddr;
 	unsigned short est_mtu = 0;
 
-	if (ipv4_config.no_pmtu_disc)
+	if (init_net.sysctl_ipv4_no_pmtu_disc)
 		return 0;
 
 	for (i = 0; i < 2; i++) {
@@ -1397,6 +1414,7 @@
 		rt->idev = NULL;
 		in_dev_put(idev);
 	}
+	release_net(rt->fl.fl_net);
 }
 
 static void ipv4_dst_ifdown(struct dst_entry *dst, struct net_device *dev,
@@ -1404,8 +1422,9 @@
 {
 	struct rtable *rt = (struct rtable *) dst;
 	struct in_device *idev = rt->idev;
-	if (dev != &loopback_dev && idev && idev->dev == dev) {
-		struct in_device *loopback_idev = in_dev_get(&loopback_dev);
+	struct net *net = dev->nd_net;
+	if (dev != &net->loopback_dev && idev && idev->dev == dev) {
+		struct in_device *loopback_idev = in_dev_get(&net->loopback_dev);
 		if (loopback_idev) {
 			rt->idev = loopback_idev;
 			in_dev_put(idev);
@@ -1492,7 +1511,7 @@
 		rt->u.dst.metrics[RTAX_MTU-1]= rt->u.dst.dev->mtu;
 
 	if (rt->u.dst.metrics[RTAX_HOPLIMIT-1] == 0)
-		rt->u.dst.metrics[RTAX_HOPLIMIT-1] = sysctl_ip_default_ttl;
+		rt->u.dst.metrics[RTAX_HOPLIMIT-1] = init_net.sysctl_ip_default_ttl;
 	if (rt->u.dst.metrics[RTAX_MTU-1] > IP_MAX_MTU)
 		rt->u.dst.metrics[RTAX_MTU-1] = IP_MAX_MTU;
 	if (rt->u.dst.metrics[RTAX_ADVMSS-1] == 0)
@@ -1513,6 +1532,7 @@
 static int ip_route_input_mc(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 				u8 tos, struct net_device *dev, int our)
 {
+	struct net *net = dev->nd_net;
 	unsigned hash;
 	struct rtable *rth;
 	__be32 spec_dst;
@@ -1546,6 +1566,7 @@
 	rth->u.dst.flags= DST_HOST;
 	if (IN_DEV_CONF_GET(in_dev, NOPOLICY))
 		rth->u.dst.flags |= DST_NOPOLICY;
+	rth->fl.fl_net	= hold_net(net);
 	rth->fl.fl4_dst	= daddr;
 	rth->rt_dst	= daddr;
 	rth->fl.fl4_tos	= tos;
@@ -1557,7 +1578,7 @@
 #endif
 	rth->rt_iif	=
 	rth->fl.iif	= dev->ifindex;
-	rth->u.dst.dev	= &loopback_dev;
+	rth->u.dst.dev	= &net->loopback_dev;
 	dev_hold(rth->u.dst.dev);
 	rth->idev	= in_dev_get(rth->u.dst.dev);
 	rth->fl.oif	= 0;
@@ -1686,6 +1707,7 @@
 		rth->u.dst.flags |= DST_NOPOLICY;
 	if (IN_DEV_CONF_GET(out_dev, NOXFRM))
 		rth->u.dst.flags |= DST_NOXFRM;
+	rth->fl.fl_net	= hold_net(in_dev->dev->nd_net);
 	rth->fl.fl4_dst	= daddr;
 	rth->rt_dst	= daddr;
 	rth->fl.fl4_tos	= tos;
@@ -1754,9 +1776,11 @@
 static int ip_route_input_slow(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 			       u8 tos, struct net_device *dev)
 {
+	struct net *net = dev->nd_net;
 	struct fib_result res;
 	struct in_device *in_dev = in_dev_get(dev);
-	struct flowi fl = { .nl_u = { .ip4_u =
+	struct flowi fl = { .fl_net = net,
+			    .nl_u = { .ip4_u =
 				      { .daddr = daddr,
 					.saddr = saddr,
 					.tos = tos,
@@ -1814,7 +1838,7 @@
 	if (res.type == RTN_LOCAL) {
 		int result;
 		result = fib_validate_source(saddr, daddr, tos,
-					     loopback_dev.ifindex,
+					     net->loopback_dev.ifindex,
 					     dev, &spec_dst, &itag);
 		if (result < 0)
 			goto martian_source;
@@ -1870,6 +1894,7 @@
 	rth->u.dst.flags= DST_HOST;
 	if (IN_DEV_CONF_GET(in_dev, NOPOLICY))
 		rth->u.dst.flags |= DST_NOPOLICY;
+	rth->fl.fl_net	= hold_net(net);
 	rth->fl.fl4_dst	= daddr;
 	rth->rt_dst	= daddr;
 	rth->fl.fl4_tos	= tos;
@@ -1881,7 +1906,7 @@
 #endif
 	rth->rt_iif	=
 	rth->fl.iif	= dev->ifindex;
-	rth->u.dst.dev	= &loopback_dev;
+	rth->u.dst.dev	= &net->loopback_dev;
 	dev_hold(rth->u.dst.dev);
 	rth->idev	= in_dev_get(rth->u.dst.dev);
 	rth->rt_gateway	= daddr;
@@ -1939,6 +1964,7 @@
 	struct rtable * rth;
 	unsigned	hash;
 	int iif = dev->ifindex;
+	struct net *net = dev->nd_net;
 
 	tos &= IPTOS_RT_MASK;
 	hash = rt_hash(daddr, saddr, iif);
@@ -1951,7 +1977,8 @@
 		    rth->fl.iif == iif &&
 		    rth->fl.oif == 0 &&
 		    rth->fl.mark == skb->mark &&
-		    rth->fl.fl4_tos == tos) {
+		    rth->fl.fl4_tos == tos &&
+		    rth->fl.fl_net == net) {
 			rth->u.dst.lastuse = jiffies;
 			dst_hold(&rth->u.dst);
 			rth->u.dst.__use++;
@@ -2063,6 +2090,7 @@
 	if (IN_DEV_CONF_GET(in_dev, NOPOLICY))
 		rth->u.dst.flags |= DST_NOPOLICY;
 
+	rth->fl.fl_net	= hold_net(oldflp->fl_net);
 	rth->fl.fl4_dst	= oldflp->fl4_dst;
 	rth->fl.fl4_tos	= tos;
 	rth->fl.fl4_src	= oldflp->fl4_src;
@@ -2142,7 +2170,9 @@
 static int ip_route_output_slow(struct rtable **rp, const struct flowi *oldflp)
 {
 	u32 tos	= RT_FL_TOS(oldflp);
-	struct flowi fl = { .nl_u = { .ip4_u =
+	struct net *net = oldflp->fl_net;
+	struct flowi fl = { .fl_net = net,
+			    .nl_u = { .ip4_u =
 				      { .daddr = oldflp->fl4_dst,
 					.saddr = oldflp->fl4_src,
 					.tos = tos & IPTOS_RT_MASK,
@@ -2151,7 +2181,7 @@
 						  RT_SCOPE_UNIVERSE),
 				      } },
 			    .mark = oldflp->mark,
-			    .iif = loopback_dev.ifindex,
+			    .iif = net->loopback_dev.ifindex,
 			    .oif = oldflp->oif };
 	struct fib_result res;
 	unsigned flags = 0;
@@ -2173,7 +2203,7 @@
 			goto out;
 
 		/* It is equivalent to inet_addr_type(saddr) == RTN_LOCAL */
-		dev_out = ip_dev_find(oldflp->fl4_src);
+		dev_out = ip_dev_find(net, oldflp->fl4_src);
 		if (dev_out == NULL)
 			goto out;
 
@@ -2212,7 +2242,7 @@
 
 
 	if (oldflp->oif) {
-		dev_out = dev_get_by_index(oldflp->oif);
+		dev_out = dev_get_by_index(net, oldflp->oif);
 		err = -ENODEV;
 		if (dev_out == NULL)
 			goto out;
@@ -2245,9 +2275,9 @@
 			fl.fl4_dst = fl.fl4_src = htonl(INADDR_LOOPBACK);
 		if (dev_out)
 			dev_put(dev_out);
-		dev_out = &loopback_dev;
+		dev_out = &net->loopback_dev;
 		dev_hold(dev_out);
-		fl.oif = loopback_dev.ifindex;
+		fl.oif = net->loopback_dev.ifindex;
 		res.type = RTN_LOCAL;
 		flags |= RTCF_LOCAL;
 		goto make_route;
@@ -2292,7 +2322,7 @@
 			fl.fl4_src = fl.fl4_dst;
 		if (dev_out)
 			dev_put(dev_out);
-		dev_out = &loopback_dev;
+		dev_out = &net->loopback_dev;
 		dev_hold(dev_out);
 		fl.oif = dev_out->ifindex;
 		if (res.fi)
@@ -2346,6 +2376,7 @@
 		    rth->fl.iif == 0 &&
 		    rth->fl.oif == flp->oif &&
 		    rth->fl.mark == flp->mark &&
+		    rth->fl.fl_net == flp->fl_net &&
 		    !((rth->fl.fl4_tos ^ flp->fl4_tos) &
 			    (IPTOS_RT_MASK | RTO_ONLINK))) {
 			rth->u.dst.lastuse = jiffies;
@@ -2522,7 +2553,7 @@
 		__be32 dst = rt->rt_dst;
 
 		if (MULTICAST(dst) && !LOCAL_MCAST(dst) &&
-		    IPV4_DEVCONF_ALL(MC_FORWARDING)) {
+		    IPV4_DEVCONF_ALL(&init_net, MC_FORWARDING)) {
 			int err = ipmr_get_route(skb, r, nowait);
 			if (err <= 0) {
 				if (!nowait) {
@@ -2553,6 +2584,7 @@
 
 static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh, void *arg)
 {
+	struct net *net = in_skb->sk->sk_net;
 	struct rtmsg *rtm;
 	struct nlattr *tb[RTA_MAX+1];
 	struct rtable *rt = NULL;
@@ -2591,7 +2623,7 @@
 	if (iif) {
 		struct net_device *dev;
 
-		dev = __dev_get_by_index(iif);
+		dev = __dev_get_by_index(net, iif);
 		if (dev == NULL) {
 			err = -ENODEV;
 			goto errout_free;
@@ -2608,6 +2640,7 @@
 			err = -rt->u.dst.error;
 	} else {
 		struct flowi fl = {
+			.fl_net = net,
 			.nl_u = {
 				.ip4_u = {
 					.daddr = dst,
@@ -2632,7 +2665,7 @@
 	if (err <= 0)
 		goto errout_free;
 
-	err = rtnl_unicast(skb, NETLINK_CB(in_skb).pid);
+	err = rtnl_unicast(skb, net, NETLINK_CB(in_skb).pid);
 errout:
 	return err;
 
@@ -2945,6 +2978,48 @@
 }
 __setup("rhash_entries=", set_rhash_entries);
 
+
+static void ip_rt_net_exit(struct net *net)
+{
+#ifdef CONFIG_PROC_FS
+# ifdef CONFIG_NET_CLS_ROUTE
+	proc_net_remove(net, "rt_acct");
+# endif
+	remove_proc_entry("rt_cache", net->proc_net_stat);
+	proc_net_remove(net, "rt_cache");
+#endif
+	rt_run_flush(0);
+}
+
+static int ip_rt_net_init(struct net *net)
+{
+	int error = -ENOMEM;
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *rtstat_pde;
+	if (!proc_net_fops_create(net, "rt_cache", S_IRUGO, &rt_cache_seq_fops))
+		goto out;
+	if (!(rtstat_pde = create_proc_entry("rt_cache", S_IRUGO,
+			net->proc_net_stat)))
+		goto out;
+	rtstat_pde->proc_fops = &rt_cpu_seq_fops;
+# ifdef CONFIG_NET_CLS_ROUTE
+	if (!create_proc_read_entry("rt_acct", 0, net->proc_net,
+		    ip_rt_acct_read, NULL))
+		goto out;
+# endif
+#endif
+	error = 0;
+out:
+	if (error)
+		ip_rt_net_exit(net);
+	return error;
+}
+
+struct pernet_operations ip_rt_net_ops = {
+	.init = ip_rt_net_init,
+	.exit = ip_rt_net_exit,
+};
+ 
 int __init ip_rt_init(void)
 {
 	int rc = 0;
@@ -3008,20 +3083,7 @@
 		ip_rt_secret_interval;
 	add_timer(&rt_secret_timer);
 
-#ifdef CONFIG_PROC_FS
-	{
-	struct proc_dir_entry *rtstat_pde = NULL; /* keep gcc happy */
-	if (!proc_net_fops_create("rt_cache", S_IRUGO, &rt_cache_seq_fops) ||
-	    !(rtstat_pde = create_proc_entry("rt_cache", S_IRUGO,
-					     proc_net_stat))) {
-		return -ENOMEM;
-	}
-	rtstat_pde->proc_fops = &rt_cpu_seq_fops;
-	}
-#ifdef CONFIG_NET_CLS_ROUTE
-	create_proc_read_entry("rt_acct", 0, proc_net, ip_rt_acct_read, NULL);
-#endif
-#endif
+	register_pernet_subsys(&ip_rt_net_ops);
 #ifdef CONFIG_XFRM
 	xfrm_init();
 	xfrm4_init();
diff -Nurb linux-2.6.22-590/net/ipv4/syncookies.c linux-2.6.22-try2-netns/net/ipv4/syncookies.c
--- linux-2.6.22-590/net/ipv4/syncookies.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/syncookies.c	2007-12-19 22:49:20.000000000 -0500
@@ -253,7 +253,8 @@
 	 * no easy way to do this.
 	 */
 	{
-		struct flowi fl = { .nl_u = { .ip4_u =
+		struct flowi fl = { .fl_net = &init_net,
+				    .nl_u = { .ip4_u =
 					      { .daddr = ((opt && opt->srr) ?
 							  opt->faddr :
 							  ireq->rmt_addr),
diff -Nurb linux-2.6.22-590/net/ipv4/sysctl_net_ipv4.c linux-2.6.22-try2-netns/net/ipv4/sysctl_net_ipv4.c
--- linux-2.6.22-590/net/ipv4/sysctl_net_ipv4.c	2007-12-21 15:33:46.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/sysctl_net_ipv4.c	2007-12-19 22:49:20.000000000 -0500
@@ -29,21 +29,21 @@
 static int ip_local_port_range_max[] = { 65535, 65535 };
 #endif
 
-struct ipv4_config ipv4_config;
-
 #ifdef CONFIG_SYSCTL
 
 static
 int ipv4_sysctl_forward(ctl_table *ctl, int write, struct file * filp,
 			void __user *buffer, size_t *lenp, loff_t *ppos)
 {
-	int val = IPV4_DEVCONF_ALL(FORWARDING);
+	struct net *net = ctl->extra2;
+	int *valp = ctl->data;
+	int old = *valp;
 	int ret;
 
 	ret = proc_dointvec(ctl, write, filp, buffer, lenp, ppos);
 
-	if (write && IPV4_DEVCONF_ALL(FORWARDING) != val)
-		inet_forward_change();
+	if (write && *valp != old)
+		inet_forward_change(net);
 
 	return ret;
 }
@@ -53,6 +53,7 @@
 			 void __user *oldval, size_t __user *oldlenp,
 			 void __user *newval, size_t newlen)
 {
+	struct net *net = table->extra2;
 	int *valp = table->data;
 	int new;
 
@@ -85,7 +86,7 @@
 	}
 
 	*valp = new;
-	inet_forward_change();
+	inet_forward_change(net);
 	return 1;
 }
 
@@ -188,22 +189,6 @@
 
 ctl_table ipv4_table[] = {
 	{
-		.ctl_name	= NET_IPV4_TCP_TIMESTAMPS,
-		.procname	= "tcp_timestamps",
-		.data		= &sysctl_tcp_timestamps,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec
-	},
-	{
-		.ctl_name	= NET_IPV4_TCP_WINDOW_SCALING,
-		.procname	= "tcp_window_scaling",
-		.data		= &sysctl_tcp_window_scaling,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec
-	},
-	{
 		.ctl_name	= NET_IPV4_TCP_SACK,
 		.procname	= "tcp_sack",
 		.data		= &sysctl_tcp_sack,
@@ -220,40 +205,6 @@
 		.proc_handler	= &proc_dointvec
 	},
 	{
-		.ctl_name	= NET_IPV4_FORWARD,
-		.procname	= "ip_forward",
-		.data		= &IPV4_DEVCONF_ALL(FORWARDING),
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &ipv4_sysctl_forward,
-		.strategy	= &ipv4_sysctl_forward_strategy
-	},
-	{
-		.ctl_name	= NET_IPV4_DEFAULT_TTL,
-		.procname	= "ip_default_ttl",
-		.data		= &sysctl_ip_default_ttl,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &ipv4_doint_and_flush,
-		.strategy	= &ipv4_doint_and_flush_strategy,
-	},
-	{
-		.ctl_name	= NET_IPV4_NO_PMTU_DISC,
-		.procname	= "ip_no_pmtu_disc",
-		.data		= &ipv4_config.no_pmtu_disc,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec
-	},
-	{
-		.ctl_name	= NET_IPV4_NONLOCAL_BIND,
-		.procname	= "ip_nonlocal_bind",
-		.data		= &sysctl_ip_nonlocal_bind,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec
-	},
-	{
 		.ctl_name	= NET_IPV4_TCP_SYN_RETRIES,
 		.procname	= "tcp_syn_retries",
 		.data		= &sysctl_tcp_syn_retries,
@@ -286,39 +237,6 @@
 		.proc_handler	= &proc_dointvec
 	},
 	{
-		.ctl_name	= NET_IPV4_IPFRAG_HIGH_THRESH,
-		.procname	= "ipfrag_high_thresh",
-		.data		= &sysctl_ipfrag_high_thresh,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec
-	},
-	{
-		.ctl_name	= NET_IPV4_IPFRAG_LOW_THRESH,
-		.procname	= "ipfrag_low_thresh",
-		.data		= &sysctl_ipfrag_low_thresh,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec
-	},
-	{
-		.ctl_name	= NET_IPV4_DYNADDR,
-		.procname	= "ip_dynaddr",
-		.data		= &sysctl_ip_dynaddr,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec
-	},
-	{
-		.ctl_name	= NET_IPV4_IPFRAG_TIME,
-		.procname	= "ipfrag_time",
-		.data		= &sysctl_ipfrag_time,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec_jiffies,
-		.strategy	= &sysctl_jiffies
-	},
-	{
 		.ctl_name	= NET_IPV4_TCP_KEEPALIVE_TIME,
 		.procname	= "tcp_keepalive_time",
 		.data		= &sysctl_tcp_keepalive_time,
@@ -422,17 +340,6 @@
 		.proc_handler	= &proc_dointvec
 	},
 	{
-		.ctl_name	= NET_IPV4_LOCAL_PORT_RANGE,
-		.procname	= "ip_local_port_range",
-		.data		= &sysctl_local_port_range,
-		.maxlen		= sizeof(sysctl_local_port_range),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec_minmax,
-		.strategy	= &sysctl_intvec,
-		.extra1		= ip_local_port_range_min,
-		.extra2		= ip_local_port_range_max
-	},
-	{
 		.ctl_name	= NET_IPV4_ICMP_ECHO_IGNORE_ALL,
 		.procname	= "icmp_echo_ignore_all",
 		.data		= &sysctl_icmp_echo_ignore_all,
@@ -534,50 +441,6 @@
 		.proc_handler	= &proc_dointvec
 	},
 	{
-		.ctl_name	= NET_IPV4_INET_PEER_THRESHOLD,
-		.procname	= "inet_peer_threshold",
-		.data		= &inet_peer_threshold,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec
-	},
-	{
-		.ctl_name	= NET_IPV4_INET_PEER_MINTTL,
-		.procname	= "inet_peer_minttl",
-		.data		= &inet_peer_minttl,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec_jiffies,
-		.strategy	= &sysctl_jiffies
-	},
-	{
-		.ctl_name	= NET_IPV4_INET_PEER_MAXTTL,
-		.procname	= "inet_peer_maxttl",
-		.data		= &inet_peer_maxttl,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec_jiffies,
-		.strategy	= &sysctl_jiffies
-	},
-	{
-		.ctl_name	= NET_IPV4_INET_PEER_GC_MINTIME,
-		.procname	= "inet_peer_gc_mintime",
-		.data		= &inet_peer_gc_mintime,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec_jiffies,
-		.strategy	= &sysctl_jiffies
-	},
-	{
-		.ctl_name	= NET_IPV4_INET_PEER_GC_MAXTIME,
-		.procname	= "inet_peer_gc_maxtime",
-		.data		= &inet_peer_gc_maxtime,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec_jiffies,
-		.strategy	= &sysctl_jiffies
-	},
-	{
 		.ctl_name	= NET_TCP_ORPHAN_RETRIES,
 		.procname	= "tcp_orphan_retries",
 		.data		= &sysctl_tcp_orphan_retries,
@@ -706,24 +569,6 @@
 		.proc_handler	= &proc_dointvec
 	},
 	{
-		.ctl_name	= NET_IPV4_IPFRAG_SECRET_INTERVAL,
-		.procname	= "ipfrag_secret_interval",
-		.data		= &sysctl_ipfrag_secret_interval,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec_jiffies,
-		.strategy	= &sysctl_jiffies
-	},
-	{
-		.ctl_name	= NET_IPV4_IPFRAG_MAX_DIST,
-		.procname	= "ipfrag_max_dist",
-		.data		= &sysctl_ipfrag_max_dist,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec_minmax,
-		.extra1		= &zero
-	},
-	{
 		.ctl_name	= NET_TCP_NO_METRICS_SAVE,
 		.procname	= "tcp_no_metrics_save",
 		.data		= &sysctl_tcp_nometrics_save,
@@ -865,6 +710,181 @@
 	{ .ctl_name = 0 }
 };
 
-#endif /* CONFIG_SYSCTL */
+struct ctl_table multi_ipv4_table[] = {
+	{
+		/* .data is filled in by devinet_net_init.
+		 * As a consequence this table entry must be the first
+		 * entry in multi_ipv4_table.
+		 */
+		.ctl_name	= NET_IPV4_FORWARD,
+		.procname	= "ip_forward",
+		.data		= NULL,
+		.extra2		= &init_net,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &ipv4_sysctl_forward,
+		.strategy	= &ipv4_sysctl_forward_strategy
+	},
+	{
+		.ctl_name	= NET_IPV4_DEFAULT_TTL,
+		.procname	= "ip_default_ttl",
+		.data		= &init_net.sysctl_ip_default_ttl,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &ipv4_doint_and_flush,
+		.strategy	= &ipv4_doint_and_flush_strategy,
+	},
+	{
+		.ctl_name	= NET_IPV4_NO_PMTU_DISC,
+		.procname	= "ip_no_pmtu_disc",
+		.data		= &init_net.sysctl_ipv4_no_pmtu_disc,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.ctl_name	= NET_IPV4_NONLOCAL_BIND,
+		.procname	= "ip_nonlocal_bind",
+		.data		= &init_net.sysctl_ip_nonlocal_bind,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.ctl_name	= NET_IPV4_LOCAL_PORT_RANGE,
+		.procname	= "ip_local_port_range",
+		.data		= &init_net.sysctl_local_port_range,
+		.maxlen		= sizeof(init_net.sysctl_local_port_range),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.strategy	= &sysctl_intvec,
+		.extra1		= ip_local_port_range_min,
+		.extra2		= ip_local_port_range_max
+	},
+	{
+		.ctl_name	= NET_IPV4_IPFRAG_HIGH_THRESH,
+		.procname	= "ipfrag_high_thresh",
+		.data		= &init_net.sysctl_ipfrag_high_thresh,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.ctl_name	= NET_IPV4_IPFRAG_LOW_THRESH,
+		.procname	= "ipfrag_low_thresh",
+		.data		= &init_net.sysctl_ipfrag_low_thresh,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.ctl_name	= NET_IPV4_IPFRAG_TIME,
+		.procname	= "ipfrag_time",
+		.data		= &init_net.sysctl_ipfrag_time,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_jiffies,
+		.strategy	= &sysctl_jiffies
+	},
+	{
+		.ctl_name	= NET_IPV4_IPFRAG_SECRET_INTERVAL,
+		.procname	= "ipfrag_secret_interval",
+		.data		= &init_net.sysctl_ipfrag_secret_interval,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_jiffies,
+		.strategy	= &sysctl_jiffies
+	},
+	{
+		.ctl_name	= NET_IPV4_IPFRAG_MAX_DIST,
+		.procname	= "ipfrag_max_dist",
+		.data		= &init_net.sysctl_ipfrag_max_dist,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= &zero
+	},
+	{
+		.ctl_name	= NET_IPV4_DYNADDR,
+		.procname	= "ip_dynaddr",
+		.data		= &init_net.sysctl_ip_dynaddr,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.ctl_name	= NET_IPV4_LOCAL_PORT_RANGE,
+		.procname	= "ip_local_port_range",
+		.data		= &init_net.sysctl_local_port_range,
+		.maxlen		= sizeof(init_net.sysctl_local_port_range),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.strategy	= &sysctl_intvec,
+		.extra1		= ip_local_port_range_min,
+		.extra2		= ip_local_port_range_max
+	},
+	{
+		.ctl_name	= NET_IPV4_INET_PEER_THRESHOLD,
+		.procname	= "inet_peer_threshold",
+		.data		= &init_net.inet_peer_threshold,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.ctl_name	= NET_IPV4_INET_PEER_MINTTL,
+		.procname	= "inet_peer_minttl",
+		.data		= &init_net.inet_peer_minttl,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_jiffies,
+		.strategy	= &sysctl_jiffies
+	},
+	{
+		.ctl_name	= NET_IPV4_INET_PEER_MAXTTL,
+		.procname	= "inet_peer_maxttl",
+		.data		= &init_net.inet_peer_maxttl,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_jiffies,
+		.strategy	= &sysctl_jiffies
+	},
+	{
+		.ctl_name	= NET_IPV4_INET_PEER_GC_MINTIME,
+		.procname	= "inet_peer_gc_mintime",
+		.data		= &init_net.inet_peer_gc_mintime,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_jiffies,
+		.strategy	= &sysctl_jiffies
+	},
+	{
+		.ctl_name	= NET_IPV4_INET_PEER_GC_MAXTIME,
+		.procname	= "inet_peer_gc_maxtime",
+		.data		= &init_net.inet_peer_gc_maxtime,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_jiffies,
+		.strategy	= &sysctl_jiffies
+	},
+	{
+		.ctl_name	= NET_IPV4_TCP_TIMESTAMPS,
+		.procname	= "tcp_timestamps",
+		.data		= &init_net.sysctl_tcp_timestamps,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+
+	},
+	{
+		.ctl_name	= NET_IPV4_TCP_WINDOW_SCALING,
+		.procname	= "tcp_window_scaling",
+		.data		= &init_net.sysctl_tcp_window_scaling,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{}
+};
 
-EXPORT_SYMBOL(ipv4_config);
+#endif /* CONFIG_SYSCTL */
diff -Nurb linux-2.6.22-590/net/ipv4/tcp.c linux-2.6.22-try2-netns/net/ipv4/tcp.c
--- linux-2.6.22-590/net/ipv4/tcp.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/tcp.c	2007-12-19 22:49:20.000000000 -0500
@@ -2409,6 +2409,23 @@
 }
 __setup("thash_entries=", set_thash_entries);
 
+static int tcp_net_init(struct net *net)
+{
+	/*
+	 * This array holds the first and last local port number.
+	 */
+	net->sysctl_local_port_range[0] = 32768;
+	net->sysctl_local_port_range[1] = 61000;
+
+	net->sysctl_tcp_timestamps = 1;
+	net->sysctl_tcp_window_scaling = 1;
+	return 0;
+}
+
+static struct pernet_operations tcp_net_ops = {
+	.init = tcp_net_init,
+};
+
 void __init tcp_init(void)
 {
 	struct sk_buff *skb = NULL;
@@ -2502,6 +2519,8 @@
 	sysctl_tcp_rmem[1] = 87380;
 	sysctl_tcp_rmem[2] = max(87380, max_share);
 
+	register_pernet_subsys(&tcp_net_ops);
+
 	printk(KERN_INFO "TCP: Hash tables configured "
 	       "(established %d bind %d)\n",
 	       tcp_hashinfo.ehash_size, tcp_hashinfo.bhash_size);
diff -Nurb linux-2.6.22-590/net/ipv4/tcp_input.c linux-2.6.22-try2-netns/net/ipv4/tcp_input.c
--- linux-2.6.22-590/net/ipv4/tcp_input.c	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/tcp_input.c	2007-12-19 22:49:20.000000000 -0500
@@ -72,8 +72,6 @@
 #include <asm/unaligned.h>
 #include <net/netdma.h>
 
-int sysctl_tcp_timestamps __read_mostly = 1;
-int sysctl_tcp_window_scaling __read_mostly = 1;
 int sysctl_tcp_sack __read_mostly = 1;
 int sysctl_tcp_fack __read_mostly = 1;
 int sysctl_tcp_reordering __read_mostly = TCP_FASTRETRANS_THRESH;
@@ -2922,7 +2920,7 @@
 					break;
 				case TCPOPT_WINDOW:
 					if (opsize==TCPOLEN_WINDOW && th->syn && !estab)
-						if (sysctl_tcp_window_scaling) {
+						if (init_net.sysctl_tcp_window_scaling) {
 							__u8 snd_wscale = *(__u8 *) ptr;
 							opt_rx->wscale_ok = 1;
 							if (snd_wscale > 14) {
@@ -2938,7 +2936,7 @@
 				case TCPOPT_TIMESTAMP:
 					if (opsize==TCPOLEN_TIMESTAMP) {
 						if ((estab && opt_rx->tstamp_ok) ||
-						    (!estab && sysctl_tcp_timestamps)) {
+						    (!estab && init_net.sysctl_tcp_timestamps)) {
 							opt_rx->saw_tstamp = 1;
 							opt_rx->rcv_tsval = ntohl(get_unaligned((__be32 *)ptr));
 							opt_rx->rcv_tsecr = ntohl(get_unaligned((__be32 *)(ptr+4)));
diff -Nurb linux-2.6.22-590/net/ipv4/tcp_ipv4.c linux-2.6.22-try2-netns/net/ipv4/tcp_ipv4.c
--- linux-2.6.22-590/net/ipv4/tcp_ipv4.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/tcp_ipv4.c	2007-12-19 23:33:32.000000000 -0500
@@ -71,6 +71,7 @@
 #include <net/timewait_sock.h>
 #include <net/xfrm.h>
 #include <net/netdma.h>
+#include <net/net_namespace.h>
 
 #include <linux/inet.h>
 #include <linux/ipv6.h>
@@ -353,6 +354,7 @@
 
 void tcp_v4_err(struct sk_buff *skb, u32 info)
 {
+	struct net *net = skb->dev->nd_net;
 	struct iphdr *iph = (struct iphdr *)skb->data;
 	struct tcphdr *th = (struct tcphdr *)(skb->data + (iph->ihl << 2));
 	struct tcp_sock *tp;
@@ -369,7 +371,7 @@
 	}
 
 	sk = inet_lookup(&tcp_hashinfo, iph->daddr, th->dest, iph->saddr,
-			 th->source, inet_iif(skb));
+			 th->source, inet_iif(skb), net);
 	if (!sk) {
 		ICMP_INC_STATS_BH(ICMP_MIB_INERRORS);
 		return;
@@ -1499,7 +1501,8 @@
 		return tcp_check_req(sk, skb, req, prev);
 
 	nsk = inet_lookup_established(&tcp_hashinfo, iph->saddr, th->source,
-				      iph->daddr, th->dest, inet_iif(skb));
+				      iph->daddr, th->dest, inet_iif(skb),
+				      sk->sk_net);
 
 	if (nsk) {
 		if (nsk->sk_state != TCP_TIME_WAIT) {
@@ -1618,6 +1621,7 @@
 
 int tcp_v4_rcv(struct sk_buff *skb)
 {
+	struct net *net = skb->dev->nd_net;
 	const struct iphdr *iph;
 	struct tcphdr *th;
 	struct sock *sk;
@@ -1657,7 +1661,7 @@
 	TCP_SKB_CB(skb)->sacked	 = 0;
 
 	sk = __inet_lookup(&tcp_hashinfo, iph->saddr, th->source,
-			   iph->daddr, th->dest, inet_iif(skb));
+			   iph->daddr, th->dest, inet_iif(skb), net);
 	if (!sk)
 		goto no_tcp_socket;
 
@@ -1732,7 +1736,7 @@
 	case TCP_TW_SYN: {
 		struct sock *sk2 = inet_lookup_listener(&tcp_hashinfo,
 							iph->daddr, th->dest,
-							inet_iif(skb));
+							inet_iif(skb), net);
 		if (sk2) {
 			inet_twsk_deschedule(inet_twsk(sk), &tcp_death_row);
 			inet_twsk_put(inet_twsk(sk));
@@ -1766,7 +1770,7 @@
 	int release_it = 0;
 
 	if (!rt || rt->rt_dst != inet->daddr) {
-		peer = inet_getpeer(inet->daddr, 1);
+		peer = inet_getpeer(sk->sk_net, inet->daddr, 1);
 		release_it = 1;
 	} else {
 		if (!rt->peer)
@@ -1791,7 +1795,7 @@
 
 int tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw)
 {
-	struct inet_peer *peer = inet_getpeer(tw->tw_daddr, 1);
+	struct inet_peer *peer = inet_getpeer(tw->tw_net, tw->tw_daddr, 1);
 
 	if (peer) {
 		const struct tcp_timewait_sock *tcptw = tcp_twsk((struct sock *)tw);
@@ -1980,7 +1984,8 @@
 				if (req->sk &&
 					!nx_check(req->sk->sk_nid, VS_WATCH_P | VS_IDENT))
 					continue;
-				if (req->rsk_ops->family == st->family) {
+ 				if ((req->rsk_ops->family == st->family) &&
+ 				    (req->sk->sk_net == st->net)) {
 					cur = req;
 					goto out;
 				}
@@ -2004,6 +2009,8 @@
 	}
 get_sk:
 	sk_for_each_from(sk, node) {
+ 		if (sk->sk_net != st->net)
+ 			continue;
 		vxdprintk(VXD_CBIT(net, 6), "sk: %p [#%d] (from %d)",
 			sk, sk->sk_nid, nx_current_nid());
 		if (!nx_check(sk->sk_nid, VS_WATCH_P | VS_IDENT))
@@ -2056,6 +2063,8 @@
 
 		read_lock_bh(&tcp_hashinfo.ehash[st->bucket].lock);
 		sk_for_each(sk, node, &tcp_hashinfo.ehash[st->bucket].chain) {
+ 			if (sk->sk_net != st->net)
+ 				continue;
 			vxdprintk(VXD_CBIT(net, 6),
 				"sk,egf: %p [#%d] (from %d)",
 				sk, sk->sk_nid, nx_current_nid());
@@ -2069,6 +2078,8 @@
 		st->state = TCP_SEQ_STATE_TIME_WAIT;
 		inet_twsk_for_each(tw, node,
 				   &tcp_hashinfo.ehash[st->bucket].twchain) {
+ 			if (tw->tw_net != st->net)
+ 				continue;
 			vxdprintk(VXD_CBIT(net, 6),
 				"tw: %p [#%d] (from %d)",
 				tw, tw->tw_nid, nx_current_nid());
@@ -2099,7 +2110,8 @@
 		tw = cur;
 		tw = tw_next(tw);
 get_tw:
-		while (tw && (tw->tw_family != st->family ||
+		while (tw && ((tw->tw_net != st->net) || 
+					(tw->tw_family != st->family) ||
 			!nx_check(tw->tw_nid, VS_WATCH_P | VS_IDENT))) {
 			tw = tw_next(tw);
 		}
@@ -2124,6 +2136,8 @@
 		vxdprintk(VXD_CBIT(net, 6),
 			"sk,egn: %p [#%d] (from %d)",
 			sk, sk->sk_nid, nx_current_nid());
+ 		if (sk->sk_net != st->net)
+ 			continue;
 		if (!nx_check(sk->sk_nid, VS_WATCH_P | VS_IDENT))
 			continue;
 		if (sk->sk_family == st->family)
@@ -2253,6 +2267,7 @@
 		goto out_kfree;
 	seq	     = file->private_data;
 	seq->private = s;
+	s->net = get_net(PROC_NET(inode));
 out:
 	return rc;
 out_kfree:
@@ -2260,20 +2275,30 @@
 	goto out;
 }
 
-int tcp_proc_register(struct tcp_seq_afinfo *afinfo)
+static int tcp_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct tcp_iter_state *st = seq->private;
+	put_net(st->net);
+	return seq_release_private(inode, file);
+}
+
+int tcp_proc_register(struct net *net, struct tcp_seq_afinfo *afinfo)
 {
 	int rc = 0;
 	struct proc_dir_entry *p;
 
 	if (!afinfo)
 		return -EINVAL;
+	if (net == &init_net) {
 	afinfo->seq_fops->owner		= afinfo->owner;
 	afinfo->seq_fops->open		= tcp_seq_open;
 	afinfo->seq_fops->read		= seq_read;
 	afinfo->seq_fops->llseek	= seq_lseek;
-	afinfo->seq_fops->release	= seq_release_private;
+		afinfo->seq_fops->release	= tcp_seq_release;
+	}
 
-	p = proc_net_fops_create(afinfo->name, S_IRUGO, afinfo->seq_fops);
+	p = proc_net_fops_create(net, afinfo->name, S_IRUGO, afinfo->seq_fops);
 	if (p)
 		p->data = afinfo;
 	else
@@ -2281,11 +2306,12 @@
 	return rc;
 }
 
-void tcp_proc_unregister(struct tcp_seq_afinfo *afinfo)
+void tcp_proc_unregister(struct net *net, struct tcp_seq_afinfo *afinfo)
 {
 	if (!afinfo)
 		return;
-	proc_net_remove(afinfo->name);
+	proc_net_remove(net, afinfo->name);
+	if (net == &init_net)
 	memset(afinfo->seq_fops, 0, sizeof(*afinfo->seq_fops));
 }
 
@@ -2430,14 +2456,29 @@
 	.seq_fops	= &tcp4_seq_fops,
 };
 
+static int tcp4_proc_net_init(struct net *net)
+{
+	return tcp_proc_register(net, &tcp4_seq_afinfo);
+}
+
+static void tcp4_proc_net_exit(struct net *net)
+{
+	tcp_proc_unregister(net, &tcp4_seq_afinfo);
+}
+
+static struct pernet_operations tcp4_proc_net_ops = {
+	.init = tcp4_proc_net_init,
+	.exit = tcp4_proc_net_exit,
+};
+
 int __init tcp4_proc_init(void)
 {
-	return tcp_proc_register(&tcp4_seq_afinfo);
+	return register_pernet_subsys(&tcp4_proc_net_ops);
 }
 
 void tcp4_proc_exit(void)
 {
-	tcp_proc_unregister(&tcp4_seq_afinfo);
+	unregister_pernet_subsys(&tcp4_proc_net_ops);
 }
 #endif /* CONFIG_PROC_FS */
 
@@ -2499,6 +2540,5 @@
 EXPORT_SYMBOL(tcp_proc_register);
 EXPORT_SYMBOL(tcp_proc_unregister);
 #endif
-EXPORT_SYMBOL(sysctl_local_port_range);
 EXPORT_SYMBOL(sysctl_tcp_low_latency);
 
diff -Nurb linux-2.6.22-590/net/ipv4/tcp_ipv4.c.orig linux-2.6.22-try2-netns/net/ipv4/tcp_ipv4.c.orig
--- linux-2.6.22-590/net/ipv4/tcp_ipv4.c.orig	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/tcp_ipv4.c.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,2483 +0,0 @@
-/*
- * INET		An implementation of the TCP/IP protocol suite for the LINUX
- *		operating system.  INET is implemented using the  BSD Socket
- *		interface as the means of communication with the user level.
- *
- *		Implementation of the Transmission Control Protocol(TCP).
- *
- * Version:	$Id: tcp_ipv4.c,v 1.240 2002/02/01 22:01:04 davem Exp $
- *
- *		IPv4 specific functions
- *
- *
- *		code split from:
- *		linux/ipv4/tcp.c
- *		linux/ipv4/tcp_input.c
- *		linux/ipv4/tcp_output.c
- *
- *		See tcp.c for author information
- *
- *	This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
- */
-
-/*
- * Changes:
- *		David S. Miller	:	New socket lookup architecture.
- *					This code is dedicated to John Dyson.
- *		David S. Miller :	Change semantics of established hash,
- *					half is devoted to TIME_WAIT sockets
- *					and the rest go in the other half.
- *		Andi Kleen :		Add support for syncookies and fixed
- *					some bugs: ip options weren't passed to
- *					the TCP layer, missed a check for an
- *					ACK bit.
- *		Andi Kleen :		Implemented fast path mtu discovery.
- *	     				Fixed many serious bugs in the
- *					request_sock handling and moved
- *					most of it into the af independent code.
- *					Added tail drop and some other bugfixes.
- *					Added new listen semantics.
- *		Mike McLagan	:	Routing by source
- *	Juan Jose Ciarlante:		ip_dynaddr bits
- *		Andi Kleen:		various fixes.
- *	Vitaly E. Lavrov	:	Transparent proxy revived after year
- *					coma.
- *	Andi Kleen		:	Fix new listen.
- *	Andi Kleen		:	Fix accept error reporting.
- *	YOSHIFUJI Hideaki @USAGI and:	Support IPV6_V6ONLY socket option, which
- *	Alexey Kuznetsov		allow both IPv4 and IPv6 sockets to bind
- *					a single port at the same time.
- */
-
-
-#include <linux/types.h>
-#include <linux/fcntl.h>
-#include <linux/module.h>
-#include <linux/random.h>
-#include <linux/cache.h>
-#include <linux/jhash.h>
-#include <linux/init.h>
-#include <linux/times.h>
-
-#include <net/icmp.h>
-#include <net/inet_hashtables.h>
-#include <net/tcp.h>
-#include <net/transp_v6.h>
-#include <net/ipv6.h>
-#include <net/inet_common.h>
-#include <net/timewait_sock.h>
-#include <net/xfrm.h>
-#include <net/netdma.h>
-
-#include <linux/inet.h>
-#include <linux/ipv6.h>
-#include <linux/stddef.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-
-#include <linux/crypto.h>
-#include <linux/scatterlist.h>
-
-int sysctl_tcp_tw_reuse __read_mostly;
-int sysctl_tcp_low_latency __read_mostly;
-
-/* Check TCP sequence numbers in ICMP packets. */
-#define ICMP_MIN_LENGTH 8
-
-/* Socket used for sending RSTs */
-static struct socket *tcp_socket __read_mostly;
-
-void tcp_v4_send_check(struct sock *sk, int len, struct sk_buff *skb);
-
-#ifdef CONFIG_TCP_MD5SIG
-static struct tcp_md5sig_key *tcp_v4_md5_do_lookup(struct sock *sk,
-						   __be32 addr);
-static int tcp_v4_do_calc_md5_hash(char *md5_hash, struct tcp_md5sig_key *key,
-				   __be32 saddr, __be32 daddr,
-				   struct tcphdr *th, int protocol,
-				   int tcplen);
-#endif
-
-struct inet_hashinfo __cacheline_aligned tcp_hashinfo = {
-	.lhash_lock  = __RW_LOCK_UNLOCKED(tcp_hashinfo.lhash_lock),
-	.lhash_users = ATOMIC_INIT(0),
-	.lhash_wait  = __WAIT_QUEUE_HEAD_INITIALIZER(tcp_hashinfo.lhash_wait),
-};
-
-static int tcp_v4_get_port(struct sock *sk, unsigned short snum)
-{
-	return inet_csk_get_port(&tcp_hashinfo, sk, snum,
-				 inet_csk_bind_conflict);
-}
-
-static void tcp_v4_hash(struct sock *sk)
-{
-	inet_hash(&tcp_hashinfo, sk);
-}
-
-void tcp_unhash(struct sock *sk)
-{
-	inet_unhash(&tcp_hashinfo, sk);
-}
-
-static inline __u32 tcp_v4_init_sequence(struct sk_buff *skb)
-{
-	return secure_tcp_sequence_number(ip_hdr(skb)->daddr,
-					  ip_hdr(skb)->saddr,
-					  tcp_hdr(skb)->dest,
-					  tcp_hdr(skb)->source);
-}
-
-int tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp)
-{
-	const struct tcp_timewait_sock *tcptw = tcp_twsk(sktw);
-	struct tcp_sock *tp = tcp_sk(sk);
-
-	/* With PAWS, it is safe from the viewpoint
-	   of data integrity. Even without PAWS it is safe provided sequence
-	   spaces do not overlap i.e. at data rates <= 80Mbit/sec.
-
-	   Actually, the idea is close to VJ's one, only timestamp cache is
-	   held not per host, but per port pair and TW bucket is used as state
-	   holder.
-
-	   If TW bucket has been already destroyed we fall back to VJ's scheme
-	   and use initial timestamp retrieved from peer table.
-	 */
-	if (tcptw->tw_ts_recent_stamp &&
-	    (twp == NULL || (sysctl_tcp_tw_reuse &&
-			     get_seconds() - tcptw->tw_ts_recent_stamp > 1))) {
-		tp->write_seq = tcptw->tw_snd_nxt + 65535 + 2;
-		if (tp->write_seq == 0)
-			tp->write_seq = 1;
-		tp->rx_opt.ts_recent	   = tcptw->tw_ts_recent;
-		tp->rx_opt.ts_recent_stamp = tcptw->tw_ts_recent_stamp;
-		sock_hold(sktw);
-		return 1;
-	}
-
-	return 0;
-}
-
-EXPORT_SYMBOL_GPL(tcp_twsk_unique);
-
-/* This will initiate an outgoing connection. */
-int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
-{
-	struct inet_sock *inet = inet_sk(sk);
-	struct tcp_sock *tp = tcp_sk(sk);
-	struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;
-	struct rtable *rt;
-	__be32 daddr, nexthop;
-	int tmp;
-	int err;
-
-	if (addr_len < sizeof(struct sockaddr_in))
-		return -EINVAL;
-
-	if (usin->sin_family != AF_INET)
-		return -EAFNOSUPPORT;
-
-	nexthop = daddr = usin->sin_addr.s_addr;
-	if (inet->opt && inet->opt->srr) {
-		if (!daddr)
-			return -EINVAL;
-		nexthop = inet->opt->faddr;
-	}
-
-	tmp = ip_route_connect(&rt, nexthop, inet->saddr,
-			       RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,
-			       IPPROTO_TCP,
-			       inet->sport, usin->sin_port, sk, 1);
-	if (tmp < 0) {
-		if (tmp == -ENETUNREACH)
-			IP_INC_STATS_BH(IPSTATS_MIB_OUTNOROUTES);
-		return tmp;
-	}
-
-	if (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {
-		ip_rt_put(rt);
-		return -ENETUNREACH;
-	}
-
-	if (!inet->opt || !inet->opt->srr)
-		daddr = rt->rt_dst;
-
-	if (!inet->saddr)
-		inet->saddr = rt->rt_src;
-	inet->rcv_saddr = inet->saddr;
-
-	if (tp->rx_opt.ts_recent_stamp && inet->daddr != daddr) {
-		/* Reset inherited state */
-		tp->rx_opt.ts_recent	   = 0;
-		tp->rx_opt.ts_recent_stamp = 0;
-		tp->write_seq		   = 0;
-	}
-
-	if (tcp_death_row.sysctl_tw_recycle &&
-	    !tp->rx_opt.ts_recent_stamp && rt->rt_dst == daddr) {
-		struct inet_peer *peer = rt_get_peer(rt);
-		/*
-		 * VJ's idea. We save last timestamp seen from
-		 * the destination in peer table, when entering state
-		 * TIME-WAIT * and initialize rx_opt.ts_recent from it,
-		 * when trying new connection.
-		 */
-		if (peer != NULL &&
-		    peer->tcp_ts_stamp + TCP_PAWS_MSL >= get_seconds()) {
-			tp->rx_opt.ts_recent_stamp = peer->tcp_ts_stamp;
-			tp->rx_opt.ts_recent = peer->tcp_ts;
-		}
-	}
-
-	inet->dport = usin->sin_port;
-	inet->daddr = daddr;
-
-	inet_csk(sk)->icsk_ext_hdr_len = 0;
-	if (inet->opt)
-		inet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;
-
-	tp->rx_opt.mss_clamp = 536;
-
-	/* Socket identity is still unknown (sport may be zero).
-	 * However we set state to SYN-SENT and not releasing socket
-	 * lock select source port, enter ourselves into the hash tables and
-	 * complete initialization after this.
-	 */
-	tcp_set_state(sk, TCP_SYN_SENT);
-	err = inet_hash_connect(&tcp_death_row, sk);
-	if (err)
-		goto failure;
-
-	err = ip_route_newports(&rt, IPPROTO_TCP,
-				inet->sport, inet->dport, sk);
-	if (err)
-		goto failure;
-
-	/* OK, now commit destination to socket.  */
-	sk->sk_gso_type = SKB_GSO_TCPV4;
-	sk_setup_caps(sk, &rt->u.dst);
-
-	if (!tp->write_seq)
-		tp->write_seq = secure_tcp_sequence_number(inet->saddr,
-							   inet->daddr,
-							   inet->sport,
-							   usin->sin_port);
-
-	inet->id = tp->write_seq ^ jiffies;
-
-	err = tcp_connect(sk);
-	rt = NULL;
-	if (err)
-		goto failure;
-
-	return 0;
-
-failure:
-	/*
-	 * This unhashes the socket and releases the local port,
-	 * if necessary.
-	 */
-	tcp_set_state(sk, TCP_CLOSE);
-	ip_rt_put(rt);
-	sk->sk_route_caps = 0;
-	inet->dport = 0;
-	return err;
-}
-
-/*
- * This routine does path mtu discovery as defined in RFC1191.
- */
-static void do_pmtu_discovery(struct sock *sk, struct iphdr *iph, u32 mtu)
-{
-	struct dst_entry *dst;
-	struct inet_sock *inet = inet_sk(sk);
-
-	/* We are not interested in TCP_LISTEN and open_requests (SYN-ACKs
-	 * send out by Linux are always <576bytes so they should go through
-	 * unfragmented).
-	 */
-	if (sk->sk_state == TCP_LISTEN)
-		return;
-
-	/* We don't check in the destentry if pmtu discovery is forbidden
-	 * on this route. We just assume that no packet_to_big packets
-	 * are send back when pmtu discovery is not active.
-	 * There is a small race when the user changes this flag in the
-	 * route, but I think that's acceptable.
-	 */
-	if ((dst = __sk_dst_check(sk, 0)) == NULL)
-		return;
-
-	dst->ops->update_pmtu(dst, mtu);
-
-	/* Something is about to be wrong... Remember soft error
-	 * for the case, if this connection will not able to recover.
-	 */
-	if (mtu < dst_mtu(dst) && ip_dont_fragment(sk, dst))
-		sk->sk_err_soft = EMSGSIZE;
-
-	mtu = dst_mtu(dst);
-
-	if (inet->pmtudisc != IP_PMTUDISC_DONT &&
-	    inet_csk(sk)->icsk_pmtu_cookie > mtu) {
-		tcp_sync_mss(sk, mtu);
-
-		/* Resend the TCP packet because it's
-		 * clear that the old packet has been
-		 * dropped. This is the new "fast" path mtu
-		 * discovery.
-		 */
-		tcp_simple_retransmit(sk);
-	} /* else let the usual retransmit timer handle it */
-}
-
-/*
- * This routine is called by the ICMP module when it gets some
- * sort of error condition.  If err < 0 then the socket should
- * be closed and the error returned to the user.  If err > 0
- * it's just the icmp type << 8 | icmp code.  After adjustment
- * header points to the first 8 bytes of the tcp header.  We need
- * to find the appropriate port.
- *
- * The locking strategy used here is very "optimistic". When
- * someone else accesses the socket the ICMP is just dropped
- * and for some paths there is no check at all.
- * A more general error queue to queue errors for later handling
- * is probably better.
- *
- */
-
-void tcp_v4_err(struct sk_buff *skb, u32 info)
-{
-	struct iphdr *iph = (struct iphdr *)skb->data;
-	struct tcphdr *th = (struct tcphdr *)(skb->data + (iph->ihl << 2));
-	struct tcp_sock *tp;
-	struct inet_sock *inet;
-	const int type = icmp_hdr(skb)->type;
-	const int code = icmp_hdr(skb)->code;
-	struct sock *sk;
-	__u32 seq;
-	int err;
-
-	if (skb->len < (iph->ihl << 2) + 8) {
-		ICMP_INC_STATS_BH(ICMP_MIB_INERRORS);
-		return;
-	}
-
-	sk = inet_lookup(&tcp_hashinfo, iph->daddr, th->dest, iph->saddr,
-			 th->source, inet_iif(skb));
-	if (!sk) {
-		ICMP_INC_STATS_BH(ICMP_MIB_INERRORS);
-		return;
-	}
-	if (sk->sk_state == TCP_TIME_WAIT) {
-		inet_twsk_put(inet_twsk(sk));
-		return;
-	}
-
-	bh_lock_sock(sk);
-	/* If too many ICMPs get dropped on busy
-	 * servers this needs to be solved differently.
-	 */
-	if (sock_owned_by_user(sk))
-		NET_INC_STATS_BH(LINUX_MIB_LOCKDROPPEDICMPS);
-
-	if (sk->sk_state == TCP_CLOSE)
-		goto out;
-
-	tp = tcp_sk(sk);
-	seq = ntohl(th->seq);
-	if (sk->sk_state != TCP_LISTEN &&
-	    !between(seq, tp->snd_una, tp->snd_nxt)) {
-		NET_INC_STATS_BH(LINUX_MIB_OUTOFWINDOWICMPS);
-		goto out;
-	}
-
-	switch (type) {
-	case ICMP_SOURCE_QUENCH:
-		/* Just silently ignore these. */
-		goto out;
-	case ICMP_PARAMETERPROB:
-		err = EPROTO;
-		break;
-	case ICMP_DEST_UNREACH:
-		if (code > NR_ICMP_UNREACH)
-			goto out;
-
-		if (code == ICMP_FRAG_NEEDED) { /* PMTU discovery (RFC1191) */
-			if (!sock_owned_by_user(sk))
-				do_pmtu_discovery(sk, iph, info);
-			goto out;
-		}
-
-		err = icmp_err_convert[code].errno;
-		break;
-	case ICMP_TIME_EXCEEDED:
-		err = EHOSTUNREACH;
-		break;
-	default:
-		goto out;
-	}
-
-	switch (sk->sk_state) {
-		struct request_sock *req, **prev;
-	case TCP_LISTEN:
-		if (sock_owned_by_user(sk))
-			goto out;
-
-		req = inet_csk_search_req(sk, &prev, th->dest,
-					  iph->daddr, iph->saddr);
-		if (!req)
-			goto out;
-
-		/* ICMPs are not backlogged, hence we cannot get
-		   an established socket here.
-		 */
-		BUG_TRAP(!req->sk);
-
-		if (seq != tcp_rsk(req)->snt_isn) {
-			NET_INC_STATS_BH(LINUX_MIB_OUTOFWINDOWICMPS);
-			goto out;
-		}
-
-		/*
-		 * Still in SYN_RECV, just remove it silently.
-		 * There is no good way to pass the error to the newly
-		 * created socket, and POSIX does not want network
-		 * errors returned from accept().
-		 */
-		inet_csk_reqsk_queue_drop(sk, req, prev);
-		goto out;
-
-	case TCP_SYN_SENT:
-	case TCP_SYN_RECV:  /* Cannot happen.
-			       It can f.e. if SYNs crossed.
-			     */
-		if (!sock_owned_by_user(sk)) {
-			sk->sk_err = err;
-
-			sk->sk_error_report(sk);
-
-			tcp_done(sk);
-		} else {
-			sk->sk_err_soft = err;
-		}
-		goto out;
-	}
-
-	/* If we've already connected we will keep trying
-	 * until we time out, or the user gives up.
-	 *
-	 * rfc1122 4.2.3.9 allows to consider as hard errors
-	 * only PROTO_UNREACH and PORT_UNREACH (well, FRAG_FAILED too,
-	 * but it is obsoleted by pmtu discovery).
-	 *
-	 * Note, that in modern internet, where routing is unreliable
-	 * and in each dark corner broken firewalls sit, sending random
-	 * errors ordered by their masters even this two messages finally lose
-	 * their original sense (even Linux sends invalid PORT_UNREACHs)
-	 *
-	 * Now we are in compliance with RFCs.
-	 *							--ANK (980905)
-	 */
-
-	inet = inet_sk(sk);
-	if (!sock_owned_by_user(sk) && inet->recverr) {
-		sk->sk_err = err;
-		sk->sk_error_report(sk);
-	} else	{ /* Only an error on timeout */
-		sk->sk_err_soft = err;
-	}
-
-out:
-	bh_unlock_sock(sk);
-	sock_put(sk);
-}
-
-/* This routine computes an IPv4 TCP checksum. */
-void tcp_v4_send_check(struct sock *sk, int len, struct sk_buff *skb)
-{
-	struct inet_sock *inet = inet_sk(sk);
-	struct tcphdr *th = tcp_hdr(skb);
-
-	if (skb->ip_summed == CHECKSUM_PARTIAL) {
-		th->check = ~tcp_v4_check(len, inet->saddr,
-					  inet->daddr, 0);
-		skb->csum_start = skb_transport_header(skb) - skb->head;
-		skb->csum_offset = offsetof(struct tcphdr, check);
-	} else {
-		th->check = tcp_v4_check(len, inet->saddr, inet->daddr,
-					 csum_partial((char *)th,
-						      th->doff << 2,
-						      skb->csum));
-	}
-}
-
-int tcp_v4_gso_send_check(struct sk_buff *skb)
-{
-	const struct iphdr *iph;
-	struct tcphdr *th;
-
-	if (!pskb_may_pull(skb, sizeof(*th)))
-		return -EINVAL;
-
-	iph = ip_hdr(skb);
-	th = tcp_hdr(skb);
-
-	th->check = 0;
-	th->check = ~tcp_v4_check(skb->len, iph->saddr, iph->daddr, 0);
-	skb->csum_start = skb_transport_header(skb) - skb->head;
-	skb->csum_offset = offsetof(struct tcphdr, check);
-	skb->ip_summed = CHECKSUM_PARTIAL;
-	return 0;
-}
-
-/*
- *	This routine will send an RST to the other tcp.
- *
- *	Someone asks: why I NEVER use socket parameters (TOS, TTL etc.)
- *		      for reset.
- *	Answer: if a packet caused RST, it is not for a socket
- *		existing in our system, if it is matched to a socket,
- *		it is just duplicate segment or bug in other side's TCP.
- *		So that we build reply only basing on parameters
- *		arrived with segment.
- *	Exception: precedence violation. We do not implement it in any case.
- */
-
-static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
-{
-	struct tcphdr *th = tcp_hdr(skb);
-	struct {
-		struct tcphdr th;
-#ifdef CONFIG_TCP_MD5SIG
-		__be32 opt[(TCPOLEN_MD5SIG_ALIGNED >> 2)];
-#endif
-	} rep;
-	struct ip_reply_arg arg;
-#ifdef CONFIG_TCP_MD5SIG
-	struct tcp_md5sig_key *key;
-#endif
-
-	/* Never send a reset in response to a reset. */
-	if (th->rst)
-		return;
-
-	if (((struct rtable *)skb->dst)->rt_type != RTN_LOCAL)
-		return;
-
-	/* Swap the send and the receive. */
-	memset(&rep, 0, sizeof(rep));
-	rep.th.dest   = th->source;
-	rep.th.source = th->dest;
-	rep.th.doff   = sizeof(struct tcphdr) / 4;
-	rep.th.rst    = 1;
-
-	if (th->ack) {
-		rep.th.seq = th->ack_seq;
-	} else {
-		rep.th.ack = 1;
-		rep.th.ack_seq = htonl(ntohl(th->seq) + th->syn + th->fin +
-				       skb->len - (th->doff << 2));
-	}
-
-	memset(&arg, 0, sizeof(arg));
-	arg.iov[0].iov_base = (unsigned char *)&rep;
-	arg.iov[0].iov_len  = sizeof(rep.th);
-
-#ifdef CONFIG_TCP_MD5SIG
-	key = sk ? tcp_v4_md5_do_lookup(sk, ip_hdr(skb)->daddr) : NULL;
-	if (key) {
-		rep.opt[0] = htonl((TCPOPT_NOP << 24) |
-				   (TCPOPT_NOP << 16) |
-				   (TCPOPT_MD5SIG << 8) |
-				   TCPOLEN_MD5SIG);
-		/* Update length and the length the header thinks exists */
-		arg.iov[0].iov_len += TCPOLEN_MD5SIG_ALIGNED;
-		rep.th.doff = arg.iov[0].iov_len / 4;
-
-		tcp_v4_do_calc_md5_hash((__u8 *)&rep.opt[1],
-					key,
-					ip_hdr(skb)->daddr,
-					ip_hdr(skb)->saddr,
-					&rep.th, IPPROTO_TCP,
-					arg.iov[0].iov_len);
-	}
-#endif
-	arg.csum = csum_tcpudp_nofold(ip_hdr(skb)->daddr,
-				      ip_hdr(skb)->saddr, /* XXX */
-				      sizeof(struct tcphdr), IPPROTO_TCP, 0);
-	arg.csumoffset = offsetof(struct tcphdr, check) / 2;
-
-	ip_send_reply(tcp_socket->sk, skb, &arg, arg.iov[0].iov_len);
-
-	TCP_INC_STATS_BH(TCP_MIB_OUTSEGS);
-	TCP_INC_STATS_BH(TCP_MIB_OUTRSTS);
-}
-
-/* The code following below sending ACKs in SYN-RECV and TIME-WAIT states
-   outside socket context is ugly, certainly. What can I do?
- */
-
-static void tcp_v4_send_ack(struct tcp_timewait_sock *twsk,
-			    struct sk_buff *skb, u32 seq, u32 ack,
-			    u32 win, u32 ts)
-{
-	struct tcphdr *th = tcp_hdr(skb);
-	struct {
-		struct tcphdr th;
-		__be32 opt[(TCPOLEN_TSTAMP_ALIGNED >> 2)
-#ifdef CONFIG_TCP_MD5SIG
-			   + (TCPOLEN_MD5SIG_ALIGNED >> 2)
-#endif
-			];
-	} rep;
-	struct ip_reply_arg arg;
-#ifdef CONFIG_TCP_MD5SIG
-	struct tcp_md5sig_key *key;
-	struct tcp_md5sig_key tw_key;
-#endif
-
-	memset(&rep.th, 0, sizeof(struct tcphdr));
-	memset(&arg, 0, sizeof(arg));
-
-	arg.iov[0].iov_base = (unsigned char *)&rep;
-	arg.iov[0].iov_len  = sizeof(rep.th);
-	if (ts) {
-		rep.opt[0] = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
-				   (TCPOPT_TIMESTAMP << 8) |
-				   TCPOLEN_TIMESTAMP);
-		rep.opt[1] = htonl(tcp_time_stamp);
-		rep.opt[2] = htonl(ts);
-		arg.iov[0].iov_len += TCPOLEN_TSTAMP_ALIGNED;
-	}
-
-	/* Swap the send and the receive. */
-	rep.th.dest    = th->source;
-	rep.th.source  = th->dest;
-	rep.th.doff    = arg.iov[0].iov_len / 4;
-	rep.th.seq     = htonl(seq);
-	rep.th.ack_seq = htonl(ack);
-	rep.th.ack     = 1;
-	rep.th.window  = htons(win);
-
-#ifdef CONFIG_TCP_MD5SIG
-	/*
-	 * The SKB holds an imcoming packet, but may not have a valid ->sk
-	 * pointer. This is especially the case when we're dealing with a
-	 * TIME_WAIT ack, because the sk structure is long gone, and only
-	 * the tcp_timewait_sock remains. So the md5 key is stashed in that
-	 * structure, and we use it in preference.  I believe that (twsk ||
-	 * skb->sk) holds true, but we program defensively.
-	 */
-	if (!twsk && skb->sk) {
-		key = tcp_v4_md5_do_lookup(skb->sk, ip_hdr(skb)->daddr);
-	} else if (twsk && twsk->tw_md5_keylen) {
-		tw_key.key = twsk->tw_md5_key;
-		tw_key.keylen = twsk->tw_md5_keylen;
-		key = &tw_key;
-	} else
-		key = NULL;
-
-	if (key) {
-		int offset = (ts) ? 3 : 0;
-
-		rep.opt[offset++] = htonl((TCPOPT_NOP << 24) |
-					  (TCPOPT_NOP << 16) |
-					  (TCPOPT_MD5SIG << 8) |
-					  TCPOLEN_MD5SIG);
-		arg.iov[0].iov_len += TCPOLEN_MD5SIG_ALIGNED;
-		rep.th.doff = arg.iov[0].iov_len/4;
-
-		tcp_v4_do_calc_md5_hash((__u8 *)&rep.opt[offset],
-					key,
-					ip_hdr(skb)->daddr,
-					ip_hdr(skb)->saddr,
-					&rep.th, IPPROTO_TCP,
-					arg.iov[0].iov_len);
-	}
-#endif
-	arg.csum = csum_tcpudp_nofold(ip_hdr(skb)->daddr,
-				      ip_hdr(skb)->saddr, /* XXX */
-				      arg.iov[0].iov_len, IPPROTO_TCP, 0);
-	arg.csumoffset = offsetof(struct tcphdr, check) / 2;
-	if (twsk)
-		arg.bound_dev_if = twsk->tw_sk.tw_bound_dev_if;
-
-	ip_send_reply(tcp_socket->sk, skb, &arg, arg.iov[0].iov_len);
-
-	TCP_INC_STATS_BH(TCP_MIB_OUTSEGS);
-}
-
-static void tcp_v4_timewait_ack(struct sock *sk, struct sk_buff *skb)
-{
-	struct inet_timewait_sock *tw = inet_twsk(sk);
-	struct tcp_timewait_sock *tcptw = tcp_twsk(sk);
-
-	tcp_v4_send_ack(tcptw, skb, tcptw->tw_snd_nxt, tcptw->tw_rcv_nxt,
-			tcptw->tw_rcv_wnd >> tw->tw_rcv_wscale,
-			tcptw->tw_ts_recent);
-
-	inet_twsk_put(tw);
-}
-
-static void tcp_v4_reqsk_send_ack(struct sk_buff *skb,
-				  struct request_sock *req)
-{
-	tcp_v4_send_ack(NULL, skb, tcp_rsk(req)->snt_isn + 1,
-			tcp_rsk(req)->rcv_isn + 1, req->rcv_wnd,
-			req->ts_recent);
-}
-
-/*
- *	Send a SYN-ACK after having received an ACK.
- *	This still operates on a request_sock only, not on a big
- *	socket.
- */
-static int tcp_v4_send_synack(struct sock *sk, struct request_sock *req,
-			      struct dst_entry *dst)
-{
-	const struct inet_request_sock *ireq = inet_rsk(req);
-	int err = -1;
-	struct sk_buff * skb;
-
-	/* First, grab a route. */
-	if (!dst && (dst = inet_csk_route_req(sk, req)) == NULL)
-		goto out;
-
-	skb = tcp_make_synack(sk, dst, req);
-
-	if (skb) {
-		struct tcphdr *th = tcp_hdr(skb);
-
-		th->check = tcp_v4_check(skb->len,
-					 ireq->loc_addr,
-					 ireq->rmt_addr,
-					 csum_partial((char *)th, skb->len,
-						      skb->csum));
-
-		err = ip_build_and_send_pkt(skb, sk, ireq->loc_addr,
-					    ireq->rmt_addr,
-					    ireq->opt);
-		err = net_xmit_eval(err);
-	}
-
-out:
-	dst_release(dst);
-	return err;
-}
-
-/*
- *	IPv4 request_sock destructor.
- */
-static void tcp_v4_reqsk_destructor(struct request_sock *req)
-{
-	kfree(inet_rsk(req)->opt);
-}
-
-#ifdef CONFIG_SYN_COOKIES
-static void syn_flood_warning(struct sk_buff *skb)
-{
-	static unsigned long warntime;
-
-	if (time_after(jiffies, (warntime + HZ * 60))) {
-		warntime = jiffies;
-		printk(KERN_INFO
-		       "possible SYN flooding on port %d. Sending cookies.\n",
-		       ntohs(tcp_hdr(skb)->dest));
-	}
-}
-#endif
-
-/*
- * Save and compile IPv4 options into the request_sock if needed.
- */
-static struct ip_options *tcp_v4_save_options(struct sock *sk,
-					      struct sk_buff *skb)
-{
-	struct ip_options *opt = &(IPCB(skb)->opt);
-	struct ip_options *dopt = NULL;
-
-	if (opt && opt->optlen) {
-		int opt_size = optlength(opt);
-		dopt = kmalloc(opt_size, GFP_ATOMIC);
-		if (dopt) {
-			if (ip_options_echo(dopt, skb)) {
-				kfree(dopt);
-				dopt = NULL;
-			}
-		}
-	}
-	return dopt;
-}
-
-#ifdef CONFIG_TCP_MD5SIG
-/*
- * RFC2385 MD5 checksumming requires a mapping of
- * IP address->MD5 Key.
- * We need to maintain these in the sk structure.
- */
-
-/* Find the Key structure for an address.  */
-static struct tcp_md5sig_key *
-			tcp_v4_md5_do_lookup(struct sock *sk, __be32 addr)
-{
-	struct tcp_sock *tp = tcp_sk(sk);
-	int i;
-
-	if (!tp->md5sig_info || !tp->md5sig_info->entries4)
-		return NULL;
-	for (i = 0; i < tp->md5sig_info->entries4; i++) {
-		if (tp->md5sig_info->keys4[i].addr == addr)
-			return &tp->md5sig_info->keys4[i].base;
-	}
-	return NULL;
-}
-
-struct tcp_md5sig_key *tcp_v4_md5_lookup(struct sock *sk,
-					 struct sock *addr_sk)
-{
-	return tcp_v4_md5_do_lookup(sk, inet_sk(addr_sk)->daddr);
-}
-
-EXPORT_SYMBOL(tcp_v4_md5_lookup);
-
-static struct tcp_md5sig_key *tcp_v4_reqsk_md5_lookup(struct sock *sk,
-						      struct request_sock *req)
-{
-	return tcp_v4_md5_do_lookup(sk, inet_rsk(req)->rmt_addr);
-}
-
-/* This can be called on a newly created socket, from other files */
-int tcp_v4_md5_do_add(struct sock *sk, __be32 addr,
-		      u8 *newkey, u8 newkeylen)
-{
-	/* Add Key to the list */
-	struct tcp4_md5sig_key *key;
-	struct tcp_sock *tp = tcp_sk(sk);
-	struct tcp4_md5sig_key *keys;
-
-	key = (struct tcp4_md5sig_key *)tcp_v4_md5_do_lookup(sk, addr);
-	if (key) {
-		/* Pre-existing entry - just update that one. */
-		kfree(key->base.key);
-		key->base.key = newkey;
-		key->base.keylen = newkeylen;
-	} else {
-		struct tcp_md5sig_info *md5sig;
-
-		if (!tp->md5sig_info) {
-			tp->md5sig_info = kzalloc(sizeof(*tp->md5sig_info),
-						  GFP_ATOMIC);
-			if (!tp->md5sig_info) {
-				kfree(newkey);
-				return -ENOMEM;
-			}
-			sk->sk_route_caps &= ~NETIF_F_GSO_MASK;
-		}
-		if (tcp_alloc_md5sig_pool() == NULL) {
-			kfree(newkey);
-			return -ENOMEM;
-		}
-		md5sig = tp->md5sig_info;
-
-		if (md5sig->alloced4 == md5sig->entries4) {
-			keys = kmalloc((sizeof(*keys) *
-					(md5sig->entries4 + 1)), GFP_ATOMIC);
-			if (!keys) {
-				kfree(newkey);
-				tcp_free_md5sig_pool();
-				return -ENOMEM;
-			}
-
-			if (md5sig->entries4)
-				memcpy(keys, md5sig->keys4,
-				       sizeof(*keys) * md5sig->entries4);
-
-			/* Free old key list, and reference new one */
-			if (md5sig->keys4)
-				kfree(md5sig->keys4);
-			md5sig->keys4 = keys;
-			md5sig->alloced4++;
-		}
-		md5sig->entries4++;
-		md5sig->keys4[md5sig->entries4 - 1].addr        = addr;
-		md5sig->keys4[md5sig->entries4 - 1].base.key    = newkey;
-		md5sig->keys4[md5sig->entries4 - 1].base.keylen = newkeylen;
-	}
-	return 0;
-}
-
-EXPORT_SYMBOL(tcp_v4_md5_do_add);
-
-static int tcp_v4_md5_add_func(struct sock *sk, struct sock *addr_sk,
-			       u8 *newkey, u8 newkeylen)
-{
-	return tcp_v4_md5_do_add(sk, inet_sk(addr_sk)->daddr,
-				 newkey, newkeylen);
-}
-
-int tcp_v4_md5_do_del(struct sock *sk, __be32 addr)
-{
-	struct tcp_sock *tp = tcp_sk(sk);
-	int i;
-
-	for (i = 0; i < tp->md5sig_info->entries4; i++) {
-		if (tp->md5sig_info->keys4[i].addr == addr) {
-			/* Free the key */
-			kfree(tp->md5sig_info->keys4[i].base.key);
-			tp->md5sig_info->entries4--;
-
-			if (tp->md5sig_info->entries4 == 0) {
-				kfree(tp->md5sig_info->keys4);
-				tp->md5sig_info->keys4 = NULL;
-				tp->md5sig_info->alloced4 = 0;
-			} else if (tp->md5sig_info->entries4 != i) {
-				/* Need to do some manipulation */
-				memcpy(&tp->md5sig_info->keys4[i],
-				       &tp->md5sig_info->keys4[i+1],
-				       (tp->md5sig_info->entries4 - i) *
-					sizeof(struct tcp4_md5sig_key));
-			}
-			tcp_free_md5sig_pool();
-			return 0;
-		}
-	}
-	return -ENOENT;
-}
-
-EXPORT_SYMBOL(tcp_v4_md5_do_del);
-
-static void tcp_v4_clear_md5_list(struct sock *sk)
-{
-	struct tcp_sock *tp = tcp_sk(sk);
-
-	/* Free each key, then the set of key keys,
-	 * the crypto element, and then decrement our
-	 * hold on the last resort crypto.
-	 */
-	if (tp->md5sig_info->entries4) {
-		int i;
-		for (i = 0; i < tp->md5sig_info->entries4; i++)
-			kfree(tp->md5sig_info->keys4[i].base.key);
-		tp->md5sig_info->entries4 = 0;
-		tcp_free_md5sig_pool();
-	}
-	if (tp->md5sig_info->keys4) {
-		kfree(tp->md5sig_info->keys4);
-		tp->md5sig_info->keys4 = NULL;
-		tp->md5sig_info->alloced4  = 0;
-	}
-}
-
-static int tcp_v4_parse_md5_keys(struct sock *sk, char __user *optval,
-				 int optlen)
-{
-	struct tcp_md5sig cmd;
-	struct sockaddr_in *sin = (struct sockaddr_in *)&cmd.tcpm_addr;
-	u8 *newkey;
-
-	if (optlen < sizeof(cmd))
-		return -EINVAL;
-
-	if (copy_from_user(&cmd, optval, sizeof(cmd)))
-		return -EFAULT;
-
-	if (sin->sin_family != AF_INET)
-		return -EINVAL;
-
-	if (!cmd.tcpm_key || !cmd.tcpm_keylen) {
-		if (!tcp_sk(sk)->md5sig_info)
-			return -ENOENT;
-		return tcp_v4_md5_do_del(sk, sin->sin_addr.s_addr);
-	}
-
-	if (cmd.tcpm_keylen > TCP_MD5SIG_MAXKEYLEN)
-		return -EINVAL;
-
-	if (!tcp_sk(sk)->md5sig_info) {
-		struct tcp_sock *tp = tcp_sk(sk);
-		struct tcp_md5sig_info *p = kzalloc(sizeof(*p), GFP_KERNEL);
-
-		if (!p)
-			return -EINVAL;
-
-		tp->md5sig_info = p;
-		sk->sk_route_caps &= ~NETIF_F_GSO_MASK;
-	}
-
-	newkey = kmemdup(cmd.tcpm_key, cmd.tcpm_keylen, GFP_KERNEL);
-	if (!newkey)
-		return -ENOMEM;
-	return tcp_v4_md5_do_add(sk, sin->sin_addr.s_addr,
-				 newkey, cmd.tcpm_keylen);
-}
-
-static int tcp_v4_do_calc_md5_hash(char *md5_hash, struct tcp_md5sig_key *key,
-				   __be32 saddr, __be32 daddr,
-				   struct tcphdr *th, int protocol,
-				   int tcplen)
-{
-	struct scatterlist sg[4];
-	__u16 data_len;
-	int block = 0;
-	__sum16 old_checksum;
-	struct tcp_md5sig_pool *hp;
-	struct tcp4_pseudohdr *bp;
-	struct hash_desc *desc;
-	int err;
-	unsigned int nbytes = 0;
-
-	/*
-	 * Okay, so RFC2385 is turned on for this connection,
-	 * so we need to generate the MD5 hash for the packet now.
-	 */
-
-	hp = tcp_get_md5sig_pool();
-	if (!hp)
-		goto clear_hash_noput;
-
-	bp = &hp->md5_blk.ip4;
-	desc = &hp->md5_desc;
-
-	/*
-	 * 1. the TCP pseudo-header (in the order: source IP address,
-	 * destination IP address, zero-padded protocol number, and
-	 * segment length)
-	 */
-	bp->saddr = saddr;
-	bp->daddr = daddr;
-	bp->pad = 0;
-	bp->protocol = protocol;
-	bp->len = htons(tcplen);
-	sg_set_buf(&sg[block++], bp, sizeof(*bp));
-	nbytes += sizeof(*bp);
-
-	/* 2. the TCP header, excluding options, and assuming a
-	 * checksum of zero/
-	 */
-	old_checksum = th->check;
-	th->check = 0;
-	sg_set_buf(&sg[block++], th, sizeof(struct tcphdr));
-	nbytes += sizeof(struct tcphdr);
-
-	/* 3. the TCP segment data (if any) */
-	data_len = tcplen - (th->doff << 2);
-	if (data_len > 0) {
-		unsigned char *data = (unsigned char *)th + (th->doff << 2);
-		sg_set_buf(&sg[block++], data, data_len);
-		nbytes += data_len;
-	}
-
-	/* 4. an independently-specified key or password, known to both
-	 * TCPs and presumably connection-specific
-	 */
-	sg_set_buf(&sg[block++], key->key, key->keylen);
-	nbytes += key->keylen;
-
-	/* Now store the Hash into the packet */
-	err = crypto_hash_init(desc);
-	if (err)
-		goto clear_hash;
-	err = crypto_hash_update(desc, sg, nbytes);
-	if (err)
-		goto clear_hash;
-	err = crypto_hash_final(desc, md5_hash);
-	if (err)
-		goto clear_hash;
-
-	/* Reset header, and free up the crypto */
-	tcp_put_md5sig_pool();
-	th->check = old_checksum;
-
-out:
-	return 0;
-clear_hash:
-	tcp_put_md5sig_pool();
-clear_hash_noput:
-	memset(md5_hash, 0, 16);
-	goto out;
-}
-
-int tcp_v4_calc_md5_hash(char *md5_hash, struct tcp_md5sig_key *key,
-			 struct sock *sk,
-			 struct dst_entry *dst,
-			 struct request_sock *req,
-			 struct tcphdr *th, int protocol,
-			 int tcplen)
-{
-	__be32 saddr, daddr;
-
-	if (sk) {
-		saddr = inet_sk(sk)->saddr;
-		daddr = inet_sk(sk)->daddr;
-	} else {
-		struct rtable *rt = (struct rtable *)dst;
-		BUG_ON(!rt);
-		saddr = rt->rt_src;
-		daddr = rt->rt_dst;
-	}
-	return tcp_v4_do_calc_md5_hash(md5_hash, key,
-				       saddr, daddr,
-				       th, protocol, tcplen);
-}
-
-EXPORT_SYMBOL(tcp_v4_calc_md5_hash);
-
-static int tcp_v4_inbound_md5_hash(struct sock *sk, struct sk_buff *skb)
-{
-	/*
-	 * This gets called for each TCP segment that arrives
-	 * so we want to be efficient.
-	 * We have 3 drop cases:
-	 * o No MD5 hash and one expected.
-	 * o MD5 hash and we're not expecting one.
-	 * o MD5 hash and its wrong.
-	 */
-	__u8 *hash_location = NULL;
-	struct tcp_md5sig_key *hash_expected;
-	const struct iphdr *iph = ip_hdr(skb);
-	struct tcphdr *th = tcp_hdr(skb);
-	int length = (th->doff << 2) - sizeof(struct tcphdr);
-	int genhash;
-	unsigned char *ptr;
-	unsigned char newhash[16];
-
-	hash_expected = tcp_v4_md5_do_lookup(sk, iph->saddr);
-
-	/*
-	 * If the TCP option length is less than the TCP_MD5SIG
-	 * option length, then we can shortcut
-	 */
-	if (length < TCPOLEN_MD5SIG) {
-		if (hash_expected)
-			return 1;
-		else
-			return 0;
-	}
-
-	/* Okay, we can't shortcut - we have to grub through the options */
-	ptr = (unsigned char *)(th + 1);
-	while (length > 0) {
-		int opcode = *ptr++;
-		int opsize;
-
-		switch (opcode) {
-		case TCPOPT_EOL:
-			goto done_opts;
-		case TCPOPT_NOP:
-			length--;
-			continue;
-		default:
-			opsize = *ptr++;
-			if (opsize < 2)
-				goto done_opts;
-			if (opsize > length)
-				goto done_opts;
-
-			if (opcode == TCPOPT_MD5SIG) {
-				hash_location = ptr;
-				goto done_opts;
-			}
-		}
-		ptr += opsize-2;
-		length -= opsize;
-	}
-done_opts:
-	/* We've parsed the options - do we have a hash? */
-	if (!hash_expected && !hash_location)
-		return 0;
-
-	if (hash_expected && !hash_location) {
-		LIMIT_NETDEBUG(KERN_INFO "MD5 Hash expected but NOT found "
-			       "(" NIPQUAD_FMT ", %d)->(" NIPQUAD_FMT ", %d)\n",
-			       NIPQUAD(iph->saddr), ntohs(th->source),
-			       NIPQUAD(iph->daddr), ntohs(th->dest));
-		return 1;
-	}
-
-	if (!hash_expected && hash_location) {
-		LIMIT_NETDEBUG(KERN_INFO "MD5 Hash NOT expected but found "
-			       "(" NIPQUAD_FMT ", %d)->(" NIPQUAD_FMT ", %d)\n",
-			       NIPQUAD(iph->saddr), ntohs(th->source),
-			       NIPQUAD(iph->daddr), ntohs(th->dest));
-		return 1;
-	}
-
-	/* Okay, so this is hash_expected and hash_location -
-	 * so we need to calculate the checksum.
-	 */
-	genhash = tcp_v4_do_calc_md5_hash(newhash,
-					  hash_expected,
-					  iph->saddr, iph->daddr,
-					  th, sk->sk_protocol,
-					  skb->len);
-
-	if (genhash || memcmp(hash_location, newhash, 16) != 0) {
-		if (net_ratelimit()) {
-			printk(KERN_INFO "MD5 Hash failed for "
-			       "(" NIPQUAD_FMT ", %d)->(" NIPQUAD_FMT ", %d)%s\n",
-			       NIPQUAD(iph->saddr), ntohs(th->source),
-			       NIPQUAD(iph->daddr), ntohs(th->dest),
-			       genhash ? " tcp_v4_calc_md5_hash failed" : "");
-		}
-		return 1;
-	}
-	return 0;
-}
-
-#endif
-
-struct request_sock_ops tcp_request_sock_ops __read_mostly = {
-	.family		=	PF_INET,
-	.obj_size	=	sizeof(struct tcp_request_sock),
-	.rtx_syn_ack	=	tcp_v4_send_synack,
-	.send_ack	=	tcp_v4_reqsk_send_ack,
-	.destructor	=	tcp_v4_reqsk_destructor,
-	.send_reset	=	tcp_v4_send_reset,
-};
-
-#ifdef CONFIG_TCP_MD5SIG
-static struct tcp_request_sock_ops tcp_request_sock_ipv4_ops = {
-	.md5_lookup	=	tcp_v4_reqsk_md5_lookup,
-};
-#endif
-
-static struct timewait_sock_ops tcp_timewait_sock_ops = {
-	.twsk_obj_size	= sizeof(struct tcp_timewait_sock),
-	.twsk_unique	= tcp_twsk_unique,
-	.twsk_destructor= tcp_twsk_destructor,
-};
-
-int tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb)
-{
-	struct inet_request_sock *ireq;
-	struct tcp_options_received tmp_opt;
-	struct request_sock *req;
-	__be32 saddr = ip_hdr(skb)->saddr;
-	__be32 daddr = ip_hdr(skb)->daddr;
-	__u32 isn = TCP_SKB_CB(skb)->when;
-	struct dst_entry *dst = NULL;
-#ifdef CONFIG_SYN_COOKIES
-	int want_cookie = 0;
-#else
-#define want_cookie 0 /* Argh, why doesn't gcc optimize this :( */
-#endif
-
-	/* Never answer to SYNs send to broadcast or multicast */
-	if (((struct rtable *)skb->dst)->rt_flags &
-	    (RTCF_BROADCAST | RTCF_MULTICAST))
-		goto drop;
-
-	/* TW buckets are converted to open requests without
-	 * limitations, they conserve resources and peer is
-	 * evidently real one.
-	 */
-	if (inet_csk_reqsk_queue_is_full(sk) && !isn) {
-#ifdef CONFIG_SYN_COOKIES
-		if (sysctl_tcp_syncookies) {
-			want_cookie = 1;
-		} else
-#endif
-		goto drop;
-	}
-
-	/* Accept backlog is full. If we have already queued enough
-	 * of warm entries in syn queue, drop request. It is better than
-	 * clogging syn queue with openreqs with exponentially increasing
-	 * timeout.
-	 */
-	if (sk_acceptq_is_full(sk) && inet_csk_reqsk_queue_young(sk) > 1)
-		goto drop;
-
-	req = reqsk_alloc(&tcp_request_sock_ops);
-	if (!req)
-		goto drop;
-
-#ifdef CONFIG_TCP_MD5SIG
-	tcp_rsk(req)->af_specific = &tcp_request_sock_ipv4_ops;
-#endif
-
-	tcp_clear_options(&tmp_opt);
-	tmp_opt.mss_clamp = 536;
-	tmp_opt.user_mss  = tcp_sk(sk)->rx_opt.user_mss;
-
-	tcp_parse_options(skb, &tmp_opt, 0);
-
-	if (want_cookie) {
-		tcp_clear_options(&tmp_opt);
-		tmp_opt.saw_tstamp = 0;
-	}
-
-	if (tmp_opt.saw_tstamp && !tmp_opt.rcv_tsval) {
-		/* Some OSes (unknown ones, but I see them on web server, which
-		 * contains information interesting only for windows'
-		 * users) do not send their stamp in SYN. It is easy case.
-		 * We simply do not advertise TS support.
-		 */
-		tmp_opt.saw_tstamp = 0;
-		tmp_opt.tstamp_ok  = 0;
-	}
-	tmp_opt.tstamp_ok = tmp_opt.saw_tstamp;
-
-	tcp_openreq_init(req, &tmp_opt, skb);
-
-	if (security_inet_conn_request(sk, skb, req))
-		goto drop_and_free;
-
-	ireq = inet_rsk(req);
-	ireq->loc_addr = daddr;
-	ireq->rmt_addr = saddr;
-	ireq->opt = tcp_v4_save_options(sk, skb);
-	if (!want_cookie)
-		TCP_ECN_create_request(req, tcp_hdr(skb));
-
-	if (want_cookie) {
-#ifdef CONFIG_SYN_COOKIES
-		syn_flood_warning(skb);
-#endif
-		isn = cookie_v4_init_sequence(sk, skb, &req->mss);
-	} else if (!isn) {
-		struct inet_peer *peer = NULL;
-
-		/* VJ's idea. We save last timestamp seen
-		 * from the destination in peer table, when entering
-		 * state TIME-WAIT, and check against it before
-		 * accepting new connection request.
-		 *
-		 * If "isn" is not zero, this request hit alive
-		 * timewait bucket, so that all the necessary checks
-		 * are made in the function processing timewait state.
-		 */
-		if (tmp_opt.saw_tstamp &&
-		    tcp_death_row.sysctl_tw_recycle &&
-		    (dst = inet_csk_route_req(sk, req)) != NULL &&
-		    (peer = rt_get_peer((struct rtable *)dst)) != NULL &&
-		    peer->v4daddr == saddr) {
-			if (get_seconds() < peer->tcp_ts_stamp + TCP_PAWS_MSL &&
-			    (s32)(peer->tcp_ts - req->ts_recent) >
-							TCP_PAWS_WINDOW) {
-				NET_INC_STATS_BH(LINUX_MIB_PAWSPASSIVEREJECTED);
-				dst_release(dst);
-				goto drop_and_free;
-			}
-		}
-		/* Kill the following clause, if you dislike this way. */
-		else if (!sysctl_tcp_syncookies &&
-			 (sysctl_max_syn_backlog - inet_csk_reqsk_queue_len(sk) <
-			  (sysctl_max_syn_backlog >> 2)) &&
-			 (!peer || !peer->tcp_ts_stamp) &&
-			 (!dst || !dst_metric(dst, RTAX_RTT))) {
-			/* Without syncookies last quarter of
-			 * backlog is filled with destinations,
-			 * proven to be alive.
-			 * It means that we continue to communicate
-			 * to destinations, already remembered
-			 * to the moment of synflood.
-			 */
-			LIMIT_NETDEBUG(KERN_DEBUG "TCP: drop open "
-				       "request from %u.%u.%u.%u/%u\n",
-				       NIPQUAD(saddr),
-				       ntohs(tcp_hdr(skb)->source));
-			dst_release(dst);
-			goto drop_and_free;
-		}
-
-		isn = tcp_v4_init_sequence(skb);
-	}
-	tcp_rsk(req)->snt_isn = isn;
-
-	if (tcp_v4_send_synack(sk, req, dst))
-		goto drop_and_free;
-
-	if (want_cookie) {
-		reqsk_free(req);
-	} else {
-		inet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);
-	}
-	return 0;
-
-drop_and_free:
-	reqsk_free(req);
-drop:
-	return 0;
-}
-
-
-/*
- * The three way handshake has completed - we got a valid synack -
- * now create the new socket.
- */
-struct sock *tcp_v4_syn_recv_sock(struct sock *sk, struct sk_buff *skb,
-				  struct request_sock *req,
-				  struct dst_entry *dst)
-{
-	struct inet_request_sock *ireq;
-	struct inet_sock *newinet;
-	struct tcp_sock *newtp;
-	struct sock *newsk;
-#ifdef CONFIG_TCP_MD5SIG
-	struct tcp_md5sig_key *key;
-#endif
-
-	if (sk_acceptq_is_full(sk))
-		goto exit_overflow;
-
-	if (!dst && (dst = inet_csk_route_req(sk, req)) == NULL)
-		goto exit;
-
-	newsk = tcp_create_openreq_child(sk, req, skb);
-	if (!newsk)
-		goto exit;
-
-	newsk->sk_gso_type = SKB_GSO_TCPV4;
-	sk_setup_caps(newsk, dst);
-
-	newtp		      = tcp_sk(newsk);
-	newinet		      = inet_sk(newsk);
-	ireq		      = inet_rsk(req);
-	newinet->daddr	      = ireq->rmt_addr;
-	newinet->rcv_saddr    = ireq->loc_addr;
-	newinet->saddr	      = ireq->loc_addr;
-	newinet->opt	      = ireq->opt;
-	ireq->opt	      = NULL;
-	newinet->mc_index     = inet_iif(skb);
-	newinet->mc_ttl	      = ip_hdr(skb)->ttl;
-	inet_csk(newsk)->icsk_ext_hdr_len = 0;
-	if (newinet->opt)
-		inet_csk(newsk)->icsk_ext_hdr_len = newinet->opt->optlen;
-	newinet->id = newtp->write_seq ^ jiffies;
-
-	tcp_mtup_init(newsk);
-	tcp_sync_mss(newsk, dst_mtu(dst));
-	newtp->advmss = dst_metric(dst, RTAX_ADVMSS);
-	tcp_initialize_rcv_mss(newsk);
-
-#ifdef CONFIG_TCP_MD5SIG
-	/* Copy over the MD5 key from the original socket */
-	if ((key = tcp_v4_md5_do_lookup(sk, newinet->daddr)) != NULL) {
-		/*
-		 * We're using one, so create a matching key
-		 * on the newsk structure. If we fail to get
-		 * memory, then we end up not copying the key
-		 * across. Shucks.
-		 */
-		char *newkey = kmemdup(key->key, key->keylen, GFP_ATOMIC);
-		if (newkey != NULL)
-			tcp_v4_md5_do_add(newsk, inet_sk(sk)->daddr,
-					  newkey, key->keylen);
-	}
-#endif
-
-	__inet_hash(&tcp_hashinfo, newsk, 0);
-	__inet_inherit_port(&tcp_hashinfo, sk, newsk);
-
-	return newsk;
-
-exit_overflow:
-	NET_INC_STATS_BH(LINUX_MIB_LISTENOVERFLOWS);
-exit:
-	NET_INC_STATS_BH(LINUX_MIB_LISTENDROPS);
-	dst_release(dst);
-	return NULL;
-}
-
-static struct sock *tcp_v4_hnd_req(struct sock *sk, struct sk_buff *skb)
-{
-	struct tcphdr *th = tcp_hdr(skb);
-	const struct iphdr *iph = ip_hdr(skb);
-	struct sock *nsk;
-	struct request_sock **prev;
-	/* Find possible connection requests. */
-	struct request_sock *req = inet_csk_search_req(sk, &prev, th->source,
-						       iph->saddr, iph->daddr);
-	if (req)
-		return tcp_check_req(sk, skb, req, prev);
-
-	nsk = inet_lookup_established(&tcp_hashinfo, iph->saddr, th->source,
-				      iph->daddr, th->dest, inet_iif(skb));
-
-	if (nsk) {
-		if (nsk->sk_state != TCP_TIME_WAIT) {
-			bh_lock_sock(nsk);
-			return nsk;
-		}
-		inet_twsk_put(inet_twsk(nsk));
-		return NULL;
-	}
-
-#ifdef CONFIG_SYN_COOKIES
-	if (!th->rst && !th->syn && th->ack)
-		sk = cookie_v4_check(sk, skb, &(IPCB(skb)->opt));
-#endif
-	return sk;
-}
-
-static __sum16 tcp_v4_checksum_init(struct sk_buff *skb)
-{
-	const struct iphdr *iph = ip_hdr(skb);
-
-	if (skb->ip_summed == CHECKSUM_COMPLETE) {
-		if (!tcp_v4_check(skb->len, iph->saddr,
-				  iph->daddr, skb->csum)) {
-			skb->ip_summed = CHECKSUM_UNNECESSARY;
-			return 0;
-		}
-	}
-
-	skb->csum = csum_tcpudp_nofold(iph->saddr, iph->daddr,
-				       skb->len, IPPROTO_TCP, 0);
-
-	if (skb->len <= 76) {
-		return __skb_checksum_complete(skb);
-	}
-	return 0;
-}
-
-
-/* The socket must have it's spinlock held when we get
- * here.
- *
- * We have a potential double-lock case here, so even when
- * doing backlog processing we use the BH locking scheme.
- * This is because we cannot sleep with the original spinlock
- * held.
- */
-int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)
-{
-	struct sock *rsk;
-#ifdef CONFIG_TCP_MD5SIG
-	/*
-	 * We really want to reject the packet as early as possible
-	 * if:
-	 *  o We're expecting an MD5'd packet and this is no MD5 tcp option
-	 *  o There is an MD5 option and we're not expecting one
-	 */
-	if (tcp_v4_inbound_md5_hash(sk, skb))
-		goto discard;
-#endif
-
-	if (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */
-		TCP_CHECK_TIMER(sk);
-		if (tcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len)) {
-			rsk = sk;
-			goto reset;
-		}
-		TCP_CHECK_TIMER(sk);
-		return 0;
-	}
-
-	if (skb->len < tcp_hdrlen(skb) || tcp_checksum_complete(skb))
-		goto csum_err;
-
-	if (sk->sk_state == TCP_LISTEN) {
-		struct sock *nsk = tcp_v4_hnd_req(sk, skb);
-		if (!nsk)
-			goto discard;
-
-		if (nsk != sk) {
-			if (tcp_child_process(sk, nsk, skb)) {
-				rsk = nsk;
-				goto reset;
-			}
-			return 0;
-		}
-	}
-
-	TCP_CHECK_TIMER(sk);
-	if (tcp_rcv_state_process(sk, skb, tcp_hdr(skb), skb->len)) {
-		rsk = sk;
-		goto reset;
-	}
-	TCP_CHECK_TIMER(sk);
-	return 0;
-
-reset:
-	tcp_v4_send_reset(rsk, skb);
-discard:
-	kfree_skb(skb);
-	/* Be careful here. If this function gets more complicated and
-	 * gcc suffers from register pressure on the x86, sk (in %ebx)
-	 * might be destroyed here. This current version compiles correctly,
-	 * but you have been warned.
-	 */
-	return 0;
-
-csum_err:
-	TCP_INC_STATS_BH(TCP_MIB_INERRS);
-	goto discard;
-}
-
-/*
- *	From tcp_input.c
- */
-
-int tcp_v4_rcv(struct sk_buff *skb)
-{
-	const struct iphdr *iph;
-	struct tcphdr *th;
-	struct sock *sk;
-	int ret;
-
-	if (skb->pkt_type != PACKET_HOST)
-		goto discard_it;
-
-	/* Count it even if it's bad */
-	TCP_INC_STATS_BH(TCP_MIB_INSEGS);
-
-	if (!pskb_may_pull(skb, sizeof(struct tcphdr)))
-		goto discard_it;
-
-	th = tcp_hdr(skb);
-
-	if (th->doff < sizeof(struct tcphdr) / 4)
-		goto bad_packet;
-	if (!pskb_may_pull(skb, th->doff * 4))
-		goto discard_it;
-
-	/* An explanation is required here, I think.
-	 * Packet length and doff are validated by header prediction,
-	 * provided case of th->doff==0 is eliminated.
-	 * So, we defer the checks. */
-	if (!skb_csum_unnecessary(skb) && tcp_v4_checksum_init(skb))
-		goto bad_packet;
-
-	th = tcp_hdr(skb);
-	iph = ip_hdr(skb);
-	TCP_SKB_CB(skb)->seq = ntohl(th->seq);
-	TCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +
-				    skb->len - th->doff * 4);
-	TCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);
-	TCP_SKB_CB(skb)->when	 = 0;
-	TCP_SKB_CB(skb)->flags	 = iph->tos;
-	TCP_SKB_CB(skb)->sacked	 = 0;
-
-	sk = __inet_lookup(&tcp_hashinfo, iph->saddr, th->source,
-			   iph->daddr, th->dest, inet_iif(skb));
-	if (!sk)
-		goto no_tcp_socket;
-
-process:
-	if (sk->sk_state == TCP_TIME_WAIT)
-		goto do_time_wait;
-
-	if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
-		goto discard_and_relse;
-	nf_reset(skb);
-
-	if (sk_filter(sk, skb))
-		goto discard_and_relse;
-
-	skb->dev = NULL;
-
-	bh_lock_sock_nested(sk);
-	ret = 0;
-	if (!sock_owned_by_user(sk)) {
-#ifdef CONFIG_NET_DMA
-		struct tcp_sock *tp = tcp_sk(sk);
-		if (!tp->ucopy.dma_chan && tp->ucopy.pinned_list)
-			tp->ucopy.dma_chan = get_softnet_dma();
-		if (tp->ucopy.dma_chan)
-			ret = tcp_v4_do_rcv(sk, skb);
-		else
-#endif
-		{
-			if (!tcp_prequeue(sk, skb))
-			ret = tcp_v4_do_rcv(sk, skb);
-		}
-	} else
-		sk_add_backlog(sk, skb);
-	bh_unlock_sock(sk);
-
-	sock_put(sk);
-
-	return ret;
-
-no_tcp_socket:
-	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
-		goto discard_it;
-
-	if (skb->len < (th->doff << 2) || tcp_checksum_complete(skb)) {
-bad_packet:
-		TCP_INC_STATS_BH(TCP_MIB_INERRS);
-	} else {
-		tcp_v4_send_reset(NULL, skb);
-	}
-
-discard_it:
-	/* Discard frame. */
-	kfree_skb(skb);
-	return 0;
-
-discard_and_relse:
-	sock_put(sk);
-	goto discard_it;
-
-do_time_wait:
-	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
-		inet_twsk_put(inet_twsk(sk));
-		goto discard_it;
-	}
-
-	if (skb->len < (th->doff << 2) || tcp_checksum_complete(skb)) {
-		TCP_INC_STATS_BH(TCP_MIB_INERRS);
-		inet_twsk_put(inet_twsk(sk));
-		goto discard_it;
-	}
-	switch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {
-	case TCP_TW_SYN: {
-		struct sock *sk2 = inet_lookup_listener(&tcp_hashinfo,
-							iph->daddr, th->dest,
-							inet_iif(skb));
-		if (sk2) {
-			inet_twsk_deschedule(inet_twsk(sk), &tcp_death_row);
-			inet_twsk_put(inet_twsk(sk));
-			sk = sk2;
-			goto process;
-		}
-		/* Fall through to ACK */
-	}
-	case TCP_TW_ACK:
-		tcp_v4_timewait_ack(sk, skb);
-		break;
-	case TCP_TW_RST:
-		goto no_tcp_socket;
-	case TCP_TW_SUCCESS:;
-	}
-	goto discard_it;
-}
-
-/* VJ's idea. Save last timestamp seen from this destination
- * and hold it at least for normal timewait interval to use for duplicate
- * segment detection in subsequent connections, before they enter synchronized
- * state.
- */
-
-int tcp_v4_remember_stamp(struct sock *sk)
-{
-	struct inet_sock *inet = inet_sk(sk);
-	struct tcp_sock *tp = tcp_sk(sk);
-	struct rtable *rt = (struct rtable *)__sk_dst_get(sk);
-	struct inet_peer *peer = NULL;
-	int release_it = 0;
-
-	if (!rt || rt->rt_dst != inet->daddr) {
-		peer = inet_getpeer(inet->daddr, 1);
-		release_it = 1;
-	} else {
-		if (!rt->peer)
-			rt_bind_peer(rt, 1);
-		peer = rt->peer;
-	}
-
-	if (peer) {
-		if ((s32)(peer->tcp_ts - tp->rx_opt.ts_recent) <= 0 ||
-		    (peer->tcp_ts_stamp + TCP_PAWS_MSL < get_seconds() &&
-		     peer->tcp_ts_stamp <= tp->rx_opt.ts_recent_stamp)) {
-			peer->tcp_ts_stamp = tp->rx_opt.ts_recent_stamp;
-			peer->tcp_ts = tp->rx_opt.ts_recent;
-		}
-		if (release_it)
-			inet_putpeer(peer);
-		return 1;
-	}
-
-	return 0;
-}
-
-int tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw)
-{
-	struct inet_peer *peer = inet_getpeer(tw->tw_daddr, 1);
-
-	if (peer) {
-		const struct tcp_timewait_sock *tcptw = tcp_twsk((struct sock *)tw);
-
-		if ((s32)(peer->tcp_ts - tcptw->tw_ts_recent) <= 0 ||
-		    (peer->tcp_ts_stamp + TCP_PAWS_MSL < get_seconds() &&
-		     peer->tcp_ts_stamp <= tcptw->tw_ts_recent_stamp)) {
-			peer->tcp_ts_stamp = tcptw->tw_ts_recent_stamp;
-			peer->tcp_ts	   = tcptw->tw_ts_recent;
-		}
-		inet_putpeer(peer);
-		return 1;
-	}
-
-	return 0;
-}
-
-struct inet_connection_sock_af_ops ipv4_specific = {
-	.queue_xmit	   = ip_queue_xmit,
-	.send_check	   = tcp_v4_send_check,
-	.rebuild_header	   = inet_sk_rebuild_header,
-	.conn_request	   = tcp_v4_conn_request,
-	.syn_recv_sock	   = tcp_v4_syn_recv_sock,
-	.remember_stamp	   = tcp_v4_remember_stamp,
-	.net_header_len	   = sizeof(struct iphdr),
-	.setsockopt	   = ip_setsockopt,
-	.getsockopt	   = ip_getsockopt,
-	.addr2sockaddr	   = inet_csk_addr2sockaddr,
-	.sockaddr_len	   = sizeof(struct sockaddr_in),
-#ifdef CONFIG_COMPAT
-	.compat_setsockopt = compat_ip_setsockopt,
-	.compat_getsockopt = compat_ip_getsockopt,
-#endif
-};
-
-#ifdef CONFIG_TCP_MD5SIG
-static struct tcp_sock_af_ops tcp_sock_ipv4_specific = {
-	.md5_lookup		= tcp_v4_md5_lookup,
-	.calc_md5_hash		= tcp_v4_calc_md5_hash,
-	.md5_add		= tcp_v4_md5_add_func,
-	.md5_parse		= tcp_v4_parse_md5_keys,
-};
-#endif
-
-/* NOTE: A lot of things set to zero explicitly by call to
- *       sk_alloc() so need not be done here.
- */
-static int tcp_v4_init_sock(struct sock *sk)
-{
-	struct inet_connection_sock *icsk = inet_csk(sk);
-	struct tcp_sock *tp = tcp_sk(sk);
-
-	skb_queue_head_init(&tp->out_of_order_queue);
-	tcp_init_xmit_timers(sk);
-	tcp_prequeue_init(tp);
-
-	icsk->icsk_rto = TCP_TIMEOUT_INIT;
-	tp->mdev = TCP_TIMEOUT_INIT;
-
-	/* So many TCP implementations out there (incorrectly) count the
-	 * initial SYN frame in their delayed-ACK and congestion control
-	 * algorithms that we must have the following bandaid to talk
-	 * efficiently to them.  -DaveM
-	 */
-	tp->snd_cwnd = 2;
-
-	/* See draft-stevens-tcpca-spec-01 for discussion of the
-	 * initialization of these values.
-	 */
-	tp->snd_ssthresh = 0x7fffffff;	/* Infinity */
-	tp->snd_cwnd_clamp = ~0;
-	tp->mss_cache = 536;
-
-	tp->reordering = sysctl_tcp_reordering;
-	icsk->icsk_ca_ops = &tcp_init_congestion_ops;
-
-	sk->sk_state = TCP_CLOSE;
-
-	sk->sk_write_space = sk_stream_write_space;
-	sock_set_flag(sk, SOCK_USE_WRITE_QUEUE);
-
-	icsk->icsk_af_ops = &ipv4_specific;
-	icsk->icsk_sync_mss = tcp_sync_mss;
-#ifdef CONFIG_TCP_MD5SIG
-	tp->af_specific = &tcp_sock_ipv4_specific;
-#endif
-
-	sk->sk_sndbuf = sysctl_tcp_wmem[1];
-	sk->sk_rcvbuf = sysctl_tcp_rmem[1];
-
-	atomic_inc(&tcp_sockets_allocated);
-
-	return 0;
-}
-
-int tcp_v4_destroy_sock(struct sock *sk)
-{
-	struct tcp_sock *tp = tcp_sk(sk);
-
-	tcp_clear_xmit_timers(sk);
-
-	tcp_cleanup_congestion_control(sk);
-
-	/* Cleanup up the write buffer. */
-	tcp_write_queue_purge(sk);
-
-	/* Cleans up our, hopefully empty, out_of_order_queue. */
-	__skb_queue_purge(&tp->out_of_order_queue);
-
-#ifdef CONFIG_TCP_MD5SIG
-	/* Clean up the MD5 key list, if any */
-	if (tp->md5sig_info) {
-		tcp_v4_clear_md5_list(sk);
-		kfree(tp->md5sig_info);
-		tp->md5sig_info = NULL;
-	}
-#endif
-
-#ifdef CONFIG_NET_DMA
-	/* Cleans up our sk_async_wait_queue */
-	__skb_queue_purge(&sk->sk_async_wait_queue);
-#endif
-
-	/* Clean prequeue, it must be empty really */
-	__skb_queue_purge(&tp->ucopy.prequeue);
-
-	/* Clean up a referenced TCP bind bucket. */
-	if (inet_csk(sk)->icsk_bind_hash)
-		inet_put_port(&tcp_hashinfo, sk);
-
-	/*
-	 * If sendmsg cached page exists, toss it.
-	 */
-	if (sk->sk_sndmsg_page) {
-		__free_page(sk->sk_sndmsg_page);
-		sk->sk_sndmsg_page = NULL;
-	}
-
-	atomic_dec(&tcp_sockets_allocated);
-
-	return 0;
-}
-
-EXPORT_SYMBOL(tcp_v4_destroy_sock);
-
-#ifdef CONFIG_PROC_FS
-/* Proc filesystem TCP sock list dumping. */
-
-static inline struct inet_timewait_sock *tw_head(struct hlist_head *head)
-{
-	return hlist_empty(head) ? NULL :
-		list_entry(head->first, struct inet_timewait_sock, tw_node);
-}
-
-static inline struct inet_timewait_sock *tw_next(struct inet_timewait_sock *tw)
-{
-	return tw->tw_node.next ?
-		hlist_entry(tw->tw_node.next, typeof(*tw), tw_node) : NULL;
-}
-
-static void *listening_get_next(struct seq_file *seq, void *cur)
-{
-	struct inet_connection_sock *icsk;
-	struct hlist_node *node;
-	struct sock *sk = cur;
-	struct tcp_iter_state* st = seq->private;
-
-	if (!sk) {
-		st->bucket = 0;
-		sk = sk_head(&tcp_hashinfo.listening_hash[0]);
-		goto get_sk;
-	}
-
-	++st->num;
-
-	if (st->state == TCP_SEQ_STATE_OPENREQ) {
-		struct request_sock *req = cur;
-
-		icsk = inet_csk(st->syn_wait_sk);
-		req = req->dl_next;
-		while (1) {
-			while (req) {
-				if (req->rsk_ops->family == st->family) {
-					cur = req;
-					goto out;
-				}
-				req = req->dl_next;
-			}
-			if (++st->sbucket >= icsk->icsk_accept_queue.listen_opt->nr_table_entries)
-				break;
-get_req:
-			req = icsk->icsk_accept_queue.listen_opt->syn_table[st->sbucket];
-		}
-		sk	  = sk_next(st->syn_wait_sk);
-		st->state = TCP_SEQ_STATE_LISTENING;
-		read_unlock_bh(&icsk->icsk_accept_queue.syn_wait_lock);
-	} else {
-		icsk = inet_csk(sk);
-		read_lock_bh(&icsk->icsk_accept_queue.syn_wait_lock);
-		if (reqsk_queue_len(&icsk->icsk_accept_queue))
-			goto start_req;
-		read_unlock_bh(&icsk->icsk_accept_queue.syn_wait_lock);
-		sk = sk_next(sk);
-	}
-get_sk:
-	sk_for_each_from(sk, node) {
-		if (sk->sk_family == st->family) {
-			cur = sk;
-			goto out;
-		}
-		icsk = inet_csk(sk);
-		read_lock_bh(&icsk->icsk_accept_queue.syn_wait_lock);
-		if (reqsk_queue_len(&icsk->icsk_accept_queue)) {
-start_req:
-			st->uid		= sock_i_uid(sk);
-			st->syn_wait_sk = sk;
-			st->state	= TCP_SEQ_STATE_OPENREQ;
-			st->sbucket	= 0;
-			goto get_req;
-		}
-		read_unlock_bh(&icsk->icsk_accept_queue.syn_wait_lock);
-	}
-	if (++st->bucket < INET_LHTABLE_SIZE) {
-		sk = sk_head(&tcp_hashinfo.listening_hash[st->bucket]);
-		goto get_sk;
-	}
-	cur = NULL;
-out:
-	return cur;
-}
-
-static void *listening_get_idx(struct seq_file *seq, loff_t *pos)
-{
-	void *rc = listening_get_next(seq, NULL);
-
-	while (rc && *pos) {
-		rc = listening_get_next(seq, rc);
-		--*pos;
-	}
-	return rc;
-}
-
-static void *established_get_first(struct seq_file *seq)
-{
-	struct tcp_iter_state* st = seq->private;
-	void *rc = NULL;
-
-	for (st->bucket = 0; st->bucket < tcp_hashinfo.ehash_size; ++st->bucket) {
-		struct sock *sk;
-		struct hlist_node *node;
-		struct inet_timewait_sock *tw;
-
-		/* We can reschedule _before_ having picked the target: */
-		cond_resched_softirq();
-
-		read_lock(&tcp_hashinfo.ehash[st->bucket].lock);
-		sk_for_each(sk, node, &tcp_hashinfo.ehash[st->bucket].chain) {
-			if (sk->sk_family != st->family) {
-				continue;
-			}
-			rc = sk;
-			goto out;
-		}
-		st->state = TCP_SEQ_STATE_TIME_WAIT;
-		inet_twsk_for_each(tw, node,
-				   &tcp_hashinfo.ehash[st->bucket].twchain) {
-			if (tw->tw_family != st->family) {
-				continue;
-			}
-			rc = tw;
-			goto out;
-		}
-		read_unlock(&tcp_hashinfo.ehash[st->bucket].lock);
-		st->state = TCP_SEQ_STATE_ESTABLISHED;
-	}
-out:
-	return rc;
-}
-
-static void *established_get_next(struct seq_file *seq, void *cur)
-{
-	struct sock *sk = cur;
-	struct inet_timewait_sock *tw;
-	struct hlist_node *node;
-	struct tcp_iter_state* st = seq->private;
-
-	++st->num;
-
-	if (st->state == TCP_SEQ_STATE_TIME_WAIT) {
-		tw = cur;
-		tw = tw_next(tw);
-get_tw:
-		while (tw && tw->tw_family != st->family) {
-			tw = tw_next(tw);
-		}
-		if (tw) {
-			cur = tw;
-			goto out;
-		}
-		read_unlock(&tcp_hashinfo.ehash[st->bucket].lock);
-		st->state = TCP_SEQ_STATE_ESTABLISHED;
-
-		/* We can reschedule between buckets: */
-		cond_resched_softirq();
-
-		if (++st->bucket < tcp_hashinfo.ehash_size) {
-			read_lock(&tcp_hashinfo.ehash[st->bucket].lock);
-			sk = sk_head(&tcp_hashinfo.ehash[st->bucket].chain);
-		} else {
-			cur = NULL;
-			goto out;
-		}
-	} else
-		sk = sk_next(sk);
-
-	sk_for_each_from(sk, node) {
-		if (sk->sk_family == st->family)
-			goto found;
-	}
-
-	st->state = TCP_SEQ_STATE_TIME_WAIT;
-	tw = tw_head(&tcp_hashinfo.ehash[st->bucket].twchain);
-	goto get_tw;
-found:
-	cur = sk;
-out:
-	return cur;
-}
-
-static void *established_get_idx(struct seq_file *seq, loff_t pos)
-{
-	void *rc = established_get_first(seq);
-
-	while (rc && pos) {
-		rc = established_get_next(seq, rc);
-		--pos;
-	}
-	return rc;
-}
-
-static void *tcp_get_idx(struct seq_file *seq, loff_t pos)
-{
-	void *rc;
-	struct tcp_iter_state* st = seq->private;
-
-	inet_listen_lock(&tcp_hashinfo);
-	st->state = TCP_SEQ_STATE_LISTENING;
-	rc	  = listening_get_idx(seq, &pos);
-
-	if (!rc) {
-		inet_listen_unlock(&tcp_hashinfo);
-		local_bh_disable();
-		st->state = TCP_SEQ_STATE_ESTABLISHED;
-		rc	  = established_get_idx(seq, pos);
-	}
-
-	return rc;
-}
-
-static void *tcp_seq_start(struct seq_file *seq, loff_t *pos)
-{
-	struct tcp_iter_state* st = seq->private;
-	st->state = TCP_SEQ_STATE_LISTENING;
-	st->num = 0;
-	return *pos ? tcp_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;
-}
-
-static void *tcp_seq_next(struct seq_file *seq, void *v, loff_t *pos)
-{
-	void *rc = NULL;
-	struct tcp_iter_state* st;
-
-	if (v == SEQ_START_TOKEN) {
-		rc = tcp_get_idx(seq, 0);
-		goto out;
-	}
-	st = seq->private;
-
-	switch (st->state) {
-	case TCP_SEQ_STATE_OPENREQ:
-	case TCP_SEQ_STATE_LISTENING:
-		rc = listening_get_next(seq, v);
-		if (!rc) {
-			inet_listen_unlock(&tcp_hashinfo);
-			local_bh_disable();
-			st->state = TCP_SEQ_STATE_ESTABLISHED;
-			rc	  = established_get_first(seq);
-		}
-		break;
-	case TCP_SEQ_STATE_ESTABLISHED:
-	case TCP_SEQ_STATE_TIME_WAIT:
-		rc = established_get_next(seq, v);
-		break;
-	}
-out:
-	++*pos;
-	return rc;
-}
-
-static void tcp_seq_stop(struct seq_file *seq, void *v)
-{
-	struct tcp_iter_state* st = seq->private;
-
-	switch (st->state) {
-	case TCP_SEQ_STATE_OPENREQ:
-		if (v) {
-			struct inet_connection_sock *icsk = inet_csk(st->syn_wait_sk);
-			read_unlock_bh(&icsk->icsk_accept_queue.syn_wait_lock);
-		}
-	case TCP_SEQ_STATE_LISTENING:
-		if (v != SEQ_START_TOKEN)
-			inet_listen_unlock(&tcp_hashinfo);
-		break;
-	case TCP_SEQ_STATE_TIME_WAIT:
-	case TCP_SEQ_STATE_ESTABLISHED:
-		if (v)
-			read_unlock(&tcp_hashinfo.ehash[st->bucket].lock);
-		local_bh_enable();
-		break;
-	}
-}
-
-static int tcp_seq_open(struct inode *inode, struct file *file)
-{
-	struct tcp_seq_afinfo *afinfo = PDE(inode)->data;
-	struct seq_file *seq;
-	struct tcp_iter_state *s;
-	int rc;
-
-	if (unlikely(afinfo == NULL))
-		return -EINVAL;
-
-	s = kzalloc(sizeof(*s), GFP_KERNEL);
-	if (!s)
-		return -ENOMEM;
-	s->family		= afinfo->family;
-	s->seq_ops.start	= tcp_seq_start;
-	s->seq_ops.next		= tcp_seq_next;
-	s->seq_ops.show		= afinfo->seq_show;
-	s->seq_ops.stop		= tcp_seq_stop;
-
-	rc = seq_open(file, &s->seq_ops);
-	if (rc)
-		goto out_kfree;
-	seq	     = file->private_data;
-	seq->private = s;
-out:
-	return rc;
-out_kfree:
-	kfree(s);
-	goto out;
-}
-
-int tcp_proc_register(struct tcp_seq_afinfo *afinfo)
-{
-	int rc = 0;
-	struct proc_dir_entry *p;
-
-	if (!afinfo)
-		return -EINVAL;
-	afinfo->seq_fops->owner		= afinfo->owner;
-	afinfo->seq_fops->open		= tcp_seq_open;
-	afinfo->seq_fops->read		= seq_read;
-	afinfo->seq_fops->llseek	= seq_lseek;
-	afinfo->seq_fops->release	= seq_release_private;
-
-	p = proc_net_fops_create(afinfo->name, S_IRUGO, afinfo->seq_fops);
-	if (p)
-		p->data = afinfo;
-	else
-		rc = -ENOMEM;
-	return rc;
-}
-
-void tcp_proc_unregister(struct tcp_seq_afinfo *afinfo)
-{
-	if (!afinfo)
-		return;
-	proc_net_remove(afinfo->name);
-	memset(afinfo->seq_fops, 0, sizeof(*afinfo->seq_fops));
-}
-
-static void get_openreq4(struct sock *sk, struct request_sock *req,
-			 char *tmpbuf, int i, int uid)
-{
-	const struct inet_request_sock *ireq = inet_rsk(req);
-	int ttd = req->expires - jiffies;
-
-	sprintf(tmpbuf, "%4d: %08X:%04X %08X:%04X"
-		" %02X %08X:%08X %02X:%08lX %08X %5d %8d %u %d %p",
-		i,
-		ireq->loc_addr,
-		ntohs(inet_sk(sk)->sport),
-		ireq->rmt_addr,
-		ntohs(ireq->rmt_port),
-		TCP_SYN_RECV,
-		0, 0, /* could print option size, but that is af dependent. */
-		1,    /* timers active (only the expire timer) */
-		jiffies_to_clock_t(ttd),
-		req->retrans,
-		uid,
-		0,  /* non standard timer */
-		0, /* open_requests have no inode */
-		atomic_read(&sk->sk_refcnt),
-		req);
-}
-
-static void get_tcp4_sock(struct sock *sk, char *tmpbuf, int i)
-{
-	int timer_active;
-	unsigned long timer_expires;
-	struct tcp_sock *tp = tcp_sk(sk);
-	const struct inet_connection_sock *icsk = inet_csk(sk);
-	struct inet_sock *inet = inet_sk(sk);
-	__be32 dest = inet->daddr;
-	__be32 src = inet->rcv_saddr;
-	__u16 destp = ntohs(inet->dport);
-	__u16 srcp = ntohs(inet->sport);
-
-	if (icsk->icsk_pending == ICSK_TIME_RETRANS) {
-		timer_active	= 1;
-		timer_expires	= icsk->icsk_timeout;
-	} else if (icsk->icsk_pending == ICSK_TIME_PROBE0) {
-		timer_active	= 4;
-		timer_expires	= icsk->icsk_timeout;
-	} else if (timer_pending(&sk->sk_timer)) {
-		timer_active	= 2;
-		timer_expires	= sk->sk_timer.expires;
-	} else {
-		timer_active	= 0;
-		timer_expires = jiffies;
-	}
-
-	sprintf(tmpbuf, "%4d: %08X:%04X %08X:%04X %02X %08X:%08X %02X:%08lX "
-			"%08X %5d %8d %lu %d %p %u %u %u %u %d",
-		i, src, srcp, dest, destp, sk->sk_state,
-		tp->write_seq - tp->snd_una,
-		sk->sk_state == TCP_LISTEN ? sk->sk_ack_backlog :
-					     (tp->rcv_nxt - tp->copied_seq),
-		timer_active,
-		jiffies_to_clock_t(timer_expires - jiffies),
-		icsk->icsk_retransmits,
-		sock_i_uid(sk),
-		icsk->icsk_probes_out,
-		sock_i_ino(sk),
-		atomic_read(&sk->sk_refcnt), sk,
-		icsk->icsk_rto,
-		icsk->icsk_ack.ato,
-		(icsk->icsk_ack.quick << 1) | icsk->icsk_ack.pingpong,
-		tp->snd_cwnd,
-		tp->snd_ssthresh >= 0xFFFF ? -1 : tp->snd_ssthresh);
-}
-
-static void get_timewait4_sock(struct inet_timewait_sock *tw,
-			       char *tmpbuf, int i)
-{
-	__be32 dest, src;
-	__u16 destp, srcp;
-	int ttd = tw->tw_ttd - jiffies;
-
-	if (ttd < 0)
-		ttd = 0;
-
-	dest  = tw->tw_daddr;
-	src   = tw->tw_rcv_saddr;
-	destp = ntohs(tw->tw_dport);
-	srcp  = ntohs(tw->tw_sport);
-
-	sprintf(tmpbuf, "%4d: %08X:%04X %08X:%04X"
-		" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p",
-		i, src, srcp, dest, destp, tw->tw_substate, 0, 0,
-		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
-		atomic_read(&tw->tw_refcnt), tw);
-}
-
-#define TMPSZ 150
-
-static int tcp4_seq_show(struct seq_file *seq, void *v)
-{
-	struct tcp_iter_state* st;
-	char tmpbuf[TMPSZ + 1];
-
-	if (v == SEQ_START_TOKEN) {
-		seq_printf(seq, "%-*s\n", TMPSZ - 1,
-			   "  sl  local_address rem_address   st tx_queue "
-			   "rx_queue tr tm->when retrnsmt   uid  timeout "
-			   "inode");
-		goto out;
-	}
-	st = seq->private;
-
-	switch (st->state) {
-	case TCP_SEQ_STATE_LISTENING:
-	case TCP_SEQ_STATE_ESTABLISHED:
-		get_tcp4_sock(v, tmpbuf, st->num);
-		break;
-	case TCP_SEQ_STATE_OPENREQ:
-		get_openreq4(st->syn_wait_sk, v, tmpbuf, st->num, st->uid);
-		break;
-	case TCP_SEQ_STATE_TIME_WAIT:
-		get_timewait4_sock(v, tmpbuf, st->num);
-		break;
-	}
-	seq_printf(seq, "%-*s\n", TMPSZ - 1, tmpbuf);
-out:
-	return 0;
-}
-
-static struct file_operations tcp4_seq_fops;
-static struct tcp_seq_afinfo tcp4_seq_afinfo = {
-	.owner		= THIS_MODULE,
-	.name		= "tcp",
-	.family		= AF_INET,
-	.seq_show	= tcp4_seq_show,
-	.seq_fops	= &tcp4_seq_fops,
-};
-
-int __init tcp4_proc_init(void)
-{
-	return tcp_proc_register(&tcp4_seq_afinfo);
-}
-
-void tcp4_proc_exit(void)
-{
-	tcp_proc_unregister(&tcp4_seq_afinfo);
-}
-#endif /* CONFIG_PROC_FS */
-
-struct proto tcp_prot = {
-	.name			= "TCP",
-	.owner			= THIS_MODULE,
-	.close			= tcp_close,
-	.connect		= tcp_v4_connect,
-	.disconnect		= tcp_disconnect,
-	.accept			= inet_csk_accept,
-	.ioctl			= tcp_ioctl,
-	.init			= tcp_v4_init_sock,
-	.destroy		= tcp_v4_destroy_sock,
-	.shutdown		= tcp_shutdown,
-	.setsockopt		= tcp_setsockopt,
-	.getsockopt		= tcp_getsockopt,
-	.recvmsg		= tcp_recvmsg,
-	.backlog_rcv		= tcp_v4_do_rcv,
-	.hash			= tcp_v4_hash,
-	.unhash			= tcp_unhash,
-	.get_port		= tcp_v4_get_port,
-	.enter_memory_pressure	= tcp_enter_memory_pressure,
-	.sockets_allocated	= &tcp_sockets_allocated,
-	.orphan_count		= &tcp_orphan_count,
-	.memory_allocated	= &tcp_memory_allocated,
-	.memory_pressure	= &tcp_memory_pressure,
-	.sysctl_mem		= sysctl_tcp_mem,
-	.sysctl_wmem		= sysctl_tcp_wmem,
-	.sysctl_rmem		= sysctl_tcp_rmem,
-	.max_header		= MAX_TCP_HEADER,
-	.obj_size		= sizeof(struct tcp_sock),
-	.twsk_prot		= &tcp_timewait_sock_ops,
-	.rsk_prot		= &tcp_request_sock_ops,
-#ifdef CONFIG_COMPAT
-	.compat_setsockopt	= compat_tcp_setsockopt,
-	.compat_getsockopt	= compat_tcp_getsockopt,
-#endif
-};
-
-void __init tcp_v4_init(struct net_proto_family *ops)
-{
-	if (inet_csk_ctl_sock_create(&tcp_socket, PF_INET, SOCK_RAW,
-				     IPPROTO_TCP) < 0)
-		panic("Failed to create the TCP control socket.\n");
-}
-
-EXPORT_SYMBOL(ipv4_specific);
-EXPORT_SYMBOL(tcp_hashinfo);
-EXPORT_SYMBOL(tcp_prot);
-EXPORT_SYMBOL(tcp_unhash);
-EXPORT_SYMBOL(tcp_v4_conn_request);
-EXPORT_SYMBOL(tcp_v4_connect);
-EXPORT_SYMBOL(tcp_v4_do_rcv);
-EXPORT_SYMBOL(tcp_v4_remember_stamp);
-EXPORT_SYMBOL(tcp_v4_send_check);
-EXPORT_SYMBOL(tcp_v4_syn_recv_sock);
-
-#ifdef CONFIG_PROC_FS
-EXPORT_SYMBOL(tcp_proc_register);
-EXPORT_SYMBOL(tcp_proc_unregister);
-#endif
-EXPORT_SYMBOL(sysctl_local_port_range);
-EXPORT_SYMBOL(sysctl_tcp_low_latency);
-
diff -Nurb linux-2.6.22-590/net/ipv4/tcp_output.c linux-2.6.22-try2-netns/net/ipv4/tcp_output.c
--- linux-2.6.22-590/net/ipv4/tcp_output.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/tcp_output.c	2007-12-19 22:49:20.000000000 -0500
@@ -432,11 +432,11 @@
 	sysctl_flags = 0;
 	if (unlikely(tcb->flags & TCPCB_FLAG_SYN)) {
 		tcp_header_size = sizeof(struct tcphdr) + TCPOLEN_MSS;
-		if (sysctl_tcp_timestamps) {
+		if (sk->sk_net->sysctl_tcp_timestamps) {
 			tcp_header_size += TCPOLEN_TSTAMP_ALIGNED;
 			sysctl_flags |= SYSCTL_FLAG_TSTAMPS;
 		}
-		if (sysctl_tcp_window_scaling) {
+		if (sk->sk_net->sysctl_tcp_window_scaling) {
 			tcp_header_size += TCPOLEN_WSCALE_ALIGNED;
 			sysctl_flags |= SYSCTL_FLAG_WSCALE;
 		}
@@ -2215,7 +2215,7 @@
 	 * See tcp_input.c:tcp_rcv_state_process case TCP_SYN_SENT.
 	 */
 	tp->tcp_header_len = sizeof(struct tcphdr) +
-		(sysctl_tcp_timestamps ? TCPOLEN_TSTAMP_ALIGNED : 0);
+		(sk->sk_net->sysctl_tcp_timestamps ? TCPOLEN_TSTAMP_ALIGNED : 0);
 
 #ifdef CONFIG_TCP_MD5SIG
 	if (tp->af_specific->md5_lookup(sk, sk) != NULL)
@@ -2238,7 +2238,7 @@
 				  tp->advmss - (tp->rx_opt.ts_recent_stamp ? tp->tcp_header_len - sizeof(struct tcphdr) : 0),
 				  &tp->rcv_wnd,
 				  &tp->window_clamp,
-				  sysctl_tcp_window_scaling,
+				  sk->sk_net->sysctl_tcp_window_scaling,
 				  &rcv_wscale);
 
 	tp->rx_opt.rcv_wscale = rcv_wscale;
diff -Nurb linux-2.6.22-590/net/ipv4/tcp_probe.c linux-2.6.22-try2-netns/net/ipv4/tcp_probe.c
--- linux-2.6.22-590/net/ipv4/tcp_probe.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/tcp_probe.c	2007-12-19 22:49:20.000000000 -0500
@@ -172,7 +172,7 @@
 	if (IS_ERR(tcpw.fifo))
 		return PTR_ERR(tcpw.fifo);
 
-	if (!proc_net_fops_create(procname, S_IRUSR, &tcpprobe_fops))
+	if (!proc_net_fops_create(&init_net, procname, S_IRUSR, &tcpprobe_fops))
 		goto err0;
 
 	ret = register_jprobe(&tcp_probe);
@@ -182,7 +182,7 @@
 	pr_info("TCP watch registered (port=%d)\n", port);
 	return 0;
  err1:
-	proc_net_remove(procname);
+	proc_net_remove(&init_net, procname);
  err0:
 	kfifo_free(tcpw.fifo);
 	return ret;
@@ -192,7 +192,7 @@
 static __exit void tcpprobe_exit(void)
 {
 	kfifo_free(tcpw.fifo);
-	proc_net_remove(procname);
+	proc_net_remove(&init_net, procname);
 	unregister_jprobe(&tcp_probe);
 
 }
diff -Nurb linux-2.6.22-590/net/ipv4/tunnel4.c linux-2.6.22-try2-netns/net/ipv4/tunnel4.c
--- linux-2.6.22-590/net/ipv4/tunnel4.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/tunnel4.c	2007-12-19 22:49:20.000000000 -0500
@@ -75,6 +75,10 @@
 {
 	struct xfrm_tunnel *handler;
 
+	if (skb->dev->nd_net != &init_net) {
+		kfree_skb(skb);
+		return 0;
+	}
 	if (!pskb_may_pull(skb, sizeof(struct iphdr)))
 		goto drop;
 
@@ -113,6 +117,9 @@
 {
 	struct xfrm_tunnel *handler;
 
+	if (skb->dev->nd_net != &init_net)
+		return;
+
 	for (handler = tunnel4_handlers; handler; handler = handler->next)
 		if (!handler->err_handler(skb, info))
 			break;
diff -Nurb linux-2.6.22-590/net/ipv4/udp.c linux-2.6.22-try2-netns/net/ipv4/udp.c
--- linux-2.6.22-590/net/ipv4/udp.c	2007-12-21 15:33:46.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv4/udp.c	2007-12-19 23:34:00.000000000 -0500
@@ -101,6 +101,7 @@
 #include <net/route.h>
 #include <net/checksum.h>
 #include <net/xfrm.h>
+#include <net/net_namespace.h>
 #include "udp_impl.h"
 
 /*
@@ -112,16 +113,17 @@
 struct hlist_head udp_hash[UDP_HTABLE_SIZE];
 DEFINE_RWLOCK(udp_hash_lock);
 
-static int udp_port_rover;
-
-static inline int __udp_lib_lport_inuse(__u16 num, struct hlist_head udptable[])
+static inline int __udp_lib_lport_inuse(struct net *net, __u16 num, struct hlist_head udptable[])
 {
 	struct sock *sk;
 	struct hlist_node *node;
 
-	sk_for_each(sk, node, &udptable[num & (UDP_HTABLE_SIZE - 1)])
+	sk_for_each(sk, node, &udptable[num & (UDP_HTABLE_SIZE - 1)]) {
+		if (sk->sk_net != net)
+			continue;
 		if (sk->sk_hash == num)
 			return 1;
+	}
 	return 0;
 }
 
@@ -148,9 +150,9 @@
 	if (snum == 0) {
 		int best_size_so_far, best, result, i;
 
-		if (*port_rover > sysctl_local_port_range[1] ||
-		    *port_rover < sysctl_local_port_range[0])
-			*port_rover = sysctl_local_port_range[0];
+		if (*port_rover > sk->sk_net->sysctl_local_port_range[1] ||
+		    *port_rover < sk->sk_net->sysctl_local_port_range[0])
+			*port_rover = sk->sk_net->sysctl_local_port_range[0];
 		best_size_so_far = 32767;
 		best = result = *port_rover;
 		for (i = 0; i < UDP_HTABLE_SIZE; i++, result++) {
@@ -158,9 +160,9 @@
 
 			head = &udptable[result & (UDP_HTABLE_SIZE - 1)];
 			if (hlist_empty(head)) {
-				if (result > sysctl_local_port_range[1])
-					result = sysctl_local_port_range[0] +
-						((result - sysctl_local_port_range[0]) &
+				if (result > sk->sk_net->sysctl_local_port_range[1])
+					result = sk->sk_net->sysctl_local_port_range[0] +
+						((result - sk->sk_net->sysctl_local_port_range[0]) &
 						 (UDP_HTABLE_SIZE - 1));
 				goto gotit;
 			}
@@ -177,11 +179,11 @@
 		result = best;
 		for (i = 0; i < (1 << 16) / UDP_HTABLE_SIZE;
 		     i++, result += UDP_HTABLE_SIZE) {
-			if (result > sysctl_local_port_range[1])
-				result = sysctl_local_port_range[0]
-					+ ((result - sysctl_local_port_range[0]) &
+			if (result > sk->sk_net->sysctl_local_port_range[1])
+				result = sk->sk_net->sysctl_local_port_range[0]
+					+ ((result - sk->sk_net->sysctl_local_port_range[0]) &
 					   (UDP_HTABLE_SIZE - 1));
-			if (! __udp_lib_lport_inuse(result, udptable))
+			if (! __udp_lib_lport_inuse(sk->sk_net, result, udptable))
 				break;
 		}
 		if (i >= (1 << 16) / UDP_HTABLE_SIZE)
@@ -194,6 +196,7 @@
 		sk_for_each(sk2, node, head)
 			if (sk2->sk_hash == snum                             &&
 			    sk2 != sk                                        &&
+			    sk->sk_net == sk2->sk_net			     &&
 			    (!sk2->sk_reuse        || !sk->sk_reuse)         &&
 			    (!sk2->sk_bound_dev_if || !sk->sk_bound_dev_if
 			     || sk2->sk_bound_dev_if == sk->sk_bound_dev_if) &&
@@ -216,7 +219,7 @@
 int udp_get_port(struct sock *sk, unsigned short snum,
 			int (*scmp)(const struct sock *, const struct sock *))
 {
-	return  __udp_lib_get_port(sk, snum, udp_hash, &udp_port_rover, scmp);
+	return  __udp_lib_get_port(sk, snum, udp_hash, &sk->sk_net->udp_port_rover, scmp);
 }
 
 extern int ipv4_rcv_saddr_equal(const struct sock *sk1, const struct sock *sk2);
@@ -229,7 +232,8 @@
 /* UDP is nearly always wildcards out the wazoo, it makes no sense to try
  * harder than this. -DaveM
  */
-static struct sock *__udp4_lib_lookup(__be32 saddr, __be16 sport,
+static struct sock *__udp4_lib_lookup(struct net *net,
+				      __be32 saddr, __be16 sport,
 				      __be32 daddr, __be16 dport,
 				      int dif, struct hlist_head udptable[])
 {
@@ -243,6 +247,9 @@
 	sk_for_each(sk, node, &udptable[hnum & (UDP_HTABLE_SIZE - 1)]) {
 		struct inet_sock *inet = inet_sk(sk);
 
+		if (sk->sk_net != net)
+			continue;
+
 		if (sk->sk_hash == hnum && !ipv6_only_sock(sk)) {
 			int score = (sk->sk_family == PF_INET ? 1 : 0);
 
@@ -299,6 +306,9 @@
 	sk_for_each_from(s, node) {
 		struct inet_sock *inet = inet_sk(s);
 
+		if (s->sk_net != sk->sk_net)
+			continue;
+
 		if (s->sk_hash != hnum					||
 		    (inet->daddr && inet->daddr != rmt_addr)		||
 		    (inet->dport != rmt_port && inet->dport)		||
@@ -328,6 +338,7 @@
 
 void __udp4_lib_err(struct sk_buff *skb, u32 info, struct hlist_head udptable[])
 {
+	struct net *net = skb->dev->nd_net;
 	struct inet_sock *inet;
 	struct iphdr *iph = (struct iphdr*)skb->data;
 	struct udphdr *uh = (struct udphdr*)(skb->data+(iph->ihl<<2));
@@ -337,7 +348,7 @@
 	int harderr;
 	int err;
 
-	sk = __udp4_lib_lookup(iph->daddr, uh->dest, iph->saddr, uh->source,
+	sk = __udp4_lib_lookup(net, iph->daddr, uh->dest, iph->saddr, uh->source,
 			       skb->dev->ifindex, udptable		    );
 	if (sk == NULL) {
 		ICMP_INC_STATS_BH(ICMP_MIB_INERRORS);
@@ -623,7 +634,8 @@
 		rt = (struct rtable*)sk_dst_check(sk, 0);
 
 	if (rt == NULL) {
-		struct flowi fl = { .oif = ipc.oif,
+		struct flowi fl = { .fl_net = sk->sk_net,
+				    .oif = ipc.oif,
 				    .nl_u = { .ip4_u =
 					      { .daddr = faddr,
 						.saddr = saddr,
@@ -1288,6 +1300,7 @@
 int __udp4_lib_rcv(struct sk_buff *skb, struct hlist_head udptable[],
 		   int proto)
 {
+	struct net *net = skb->dev->nd_net;
 	struct sock *sk;
 	struct udphdr *uh = udp_hdr(skb);
 	unsigned short ulen;
@@ -1322,7 +1335,7 @@
 	udp_ping_of_death(skb, uh, saddr);
 #endif
 
-	sk = __udp4_lib_lookup(saddr, uh->source, daddr, uh->dest,
+	sk = __udp4_lib_lookup(net, saddr, uh->source, daddr, uh->dest,
 			       skb->dev->ifindex, udptable        );
 
 	if (sk != NULL) {
@@ -1651,7 +1664,7 @@
 		sk = sk_next(sk);
 try_again:
 		;
-	} while (sk && (sk->sk_family != state->family ||
+	} while (sk && ((sk->sk_net != state->net) || sk->sk_family != state->family ||
 		!nx_check(sk->sk_nid, VS_WATCH_P | VS_IDENT)));
 
 	if (!sk && ++state->bucket < UDP_HTABLE_SIZE) {
@@ -1717,6 +1730,7 @@
 
 	seq	     = file->private_data;
 	seq->private = s;
+	s->net	     = get_net(PROC_NET(inode));
 out:
 	return rc;
 out_kfree:
@@ -1724,21 +1738,31 @@
 	goto out;
 }
 
+static int udp_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct udp_iter_state *state = seq->private;
+	put_net(state->net);
+	return seq_release_private(inode, file);
+}
+
 /* ------------------------------------------------------------------------ */
-int udp_proc_register(struct udp_seq_afinfo *afinfo)
+int udp_proc_register(struct net *net, struct udp_seq_afinfo *afinfo)
 {
 	struct proc_dir_entry *p;
 	int rc = 0;
 
 	if (!afinfo)
 		return -EINVAL;
+	if (net == &init_net) {
 	afinfo->seq_fops->owner		= afinfo->owner;
 	afinfo->seq_fops->open		= udp_seq_open;
 	afinfo->seq_fops->read		= seq_read;
 	afinfo->seq_fops->llseek	= seq_lseek;
-	afinfo->seq_fops->release	= seq_release_private;
+		afinfo->seq_fops->release	= udp_seq_release;
+	}
 
-	p = proc_net_fops_create(afinfo->name, S_IRUGO, afinfo->seq_fops);
+	p = proc_net_fops_create(net, afinfo->name, S_IRUGO, afinfo->seq_fops);
 	if (p)
 		p->data = afinfo;
 	else
@@ -1746,11 +1770,12 @@
 	return rc;
 }
 
-void udp_proc_unregister(struct udp_seq_afinfo *afinfo)
+void udp_proc_unregister(struct net *net, struct udp_seq_afinfo *afinfo)
 {
 	if (!afinfo)
 		return;
-	proc_net_remove(afinfo->name);
+	proc_net_remove(net, afinfo->name);
+	if (net == &init_net)
 	memset(afinfo->seq_fops, 0, sizeof(*afinfo->seq_fops));
 }
 
@@ -1803,14 +1828,30 @@
 	.seq_fops	= &udp4_seq_fops,
 };
 
+
+static int udp4_proc_net_init(struct net *net)
+{
+	return udp_proc_register(net, &udp4_seq_afinfo);
+}
+
+static void udp4_proc_net_exit(struct net *net)
+{
+	udp_proc_unregister(net, &udp4_seq_afinfo);
+}
+
+static struct pernet_operations udp4_proc_net_ops = {
+	.init = udp4_proc_net_init,
+	.exit = udp4_proc_net_exit,
+};
+
 int __init udp4_proc_init(void)
 {
-	return udp_proc_register(&udp4_seq_afinfo);
+	return register_pernet_subsys(&udp4_proc_net_ops);
 }
 
 void udp4_proc_exit(void)
 {
-	udp_proc_unregister(&udp4_seq_afinfo);
+	unregister_pernet_subsys(&udp4_proc_net_ops);
 }
 #endif /* CONFIG_PROC_FS */
 
diff -Nurb linux-2.6.22-590/net/ipv4/udplite.c linux-2.6.22-try2-netns/net/ipv4/udplite.c
--- linux-2.6.22-590/net/ipv4/udplite.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/udplite.c	2007-12-19 22:49:20.000000000 -0500
@@ -31,11 +31,18 @@
 
 static int udplite_rcv(struct sk_buff *skb)
 {
+	if (skb->dev->nd_net != &init_net) {
+		kfree_skb(skb);
+		return 0;
+	}
 	return __udp4_lib_rcv(skb, udplite_hash, IPPROTO_UDPLITE);
 }
 
 static void udplite_err(struct sk_buff *skb, u32 info)
 {
+	if (skb->dev->nd_net != &init_net)
+		return;
+
 	return __udp4_lib_err(skb, info, udplite_hash);
 }
 
@@ -103,7 +110,7 @@
 	inet_register_protosw(&udplite4_protosw);
 
 #ifdef CONFIG_PROC_FS
-	if (udp_proc_register(&udplite4_seq_afinfo)) /* udplite4_proc_init() */
+	if (udp_proc_register(&init_net, &udplite4_seq_afinfo)) /* udplite4_proc_init() */
 		printk(KERN_ERR "%s: Cannot register /proc!\n", __FUNCTION__);
 #endif
 	return;
diff -Nurb linux-2.6.22-590/net/ipv4/xfrm4_input.c linux-2.6.22-try2-netns/net/ipv4/xfrm4_input.c
--- linux-2.6.22-590/net/ipv4/xfrm4_input.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/xfrm4_input.c	2007-12-19 22:49:20.000000000 -0500
@@ -18,6 +18,10 @@
 
 int xfrm4_rcv(struct sk_buff *skb)
 {
+	if (skb->dev->nd_net != &init_net) {
+		kfree_skb(skb);
+		return 0;
+	}
 	return xfrm4_rcv_encap(skb, 0);
 }
 
diff -Nurb linux-2.6.22-590/net/ipv4/xfrm4_policy.c linux-2.6.22-try2-netns/net/ipv4/xfrm4_policy.c
--- linux-2.6.22-590/net/ipv4/xfrm4_policy.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/xfrm4_policy.c	2007-12-19 22:49:20.000000000 -0500
@@ -25,6 +25,7 @@
 {
 	struct rtable *rt;
 	struct flowi fl_tunnel = {
+		.fl_net = &init_net,
 		.nl_u = {
 			.ip4_u = {
 				.daddr = daddr->a4,
@@ -73,6 +74,7 @@
 	struct rtable *rt0 = (struct rtable*)(*dst_p);
 	struct rtable *rt = rt0;
 	struct flowi fl_tunnel = {
+		.fl_net = &init_net,
 		.nl_u = {
 			.ip4_u = {
 				.saddr = fl->fl4_src,
@@ -213,6 +215,7 @@
 	u8 *xprth = skb_network_header(skb) + iph->ihl * 4;
 
 	memset(fl, 0, sizeof(struct flowi));
+	fl->fl_net = &init_net;
 	if (!(iph->frag_off & htons(IP_MF | IP_OFFSET))) {
 		switch (iph->protocol) {
 		case IPPROTO_UDP:
@@ -306,7 +309,7 @@
 
 	xdst = (struct xfrm_dst *)dst;
 	if (xdst->u.rt.idev->dev == dev) {
-		struct in_device *loopback_idev = in_dev_get(&loopback_dev);
+		struct in_device *loopback_idev = in_dev_get(&init_net.loopback_dev);
 		BUG_ON(!loopback_idev);
 
 		do {
diff -Nurb linux-2.6.22-590/net/ipv4/xfrm4_state.c linux-2.6.22-try2-netns/net/ipv4/xfrm4_state.c
--- linux-2.6.22-590/net/ipv4/xfrm4_state.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv4/xfrm4_state.c	2007-12-19 22:49:20.000000000 -0500
@@ -16,7 +16,7 @@
 
 static int xfrm4_init_flags(struct xfrm_state *x)
 {
-	if (ipv4_config.no_pmtu_disc)
+	if (init_net.sysctl_ipv4_no_pmtu_disc)
 		x->props.flags |= XFRM_STATE_NOPMTUDISC;
 	return 0;
 }
diff -Nurb linux-2.6.22-590/net/ipv6/addrconf.c linux-2.6.22-try2-netns/net/ipv6/addrconf.c
--- linux-2.6.22-590/net/ipv6/addrconf.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/addrconf.c	2007-12-19 23:35:57.000000000 -0500
@@ -73,6 +73,7 @@
 #include <net/tcp.h>
 #include <net/ip.h>
 #include <net/netlink.h>
+#include <net/net_namespace.h>
 #include <net/pkt_sched.h>
 #include <linux/if_tunnel.h>
 #include <linux/rtnetlink.h>
@@ -457,7 +458,7 @@
 	struct inet6_dev *idev;
 
 	read_lock(&dev_base_lock);
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		rcu_read_lock();
 		idev = __in6_dev_get(dev);
 		if (idev) {
@@ -920,7 +921,7 @@
 	read_lock(&dev_base_lock);
 	rcu_read_lock();
 
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		struct inet6_dev *idev;
 		struct inet6_ifaddr *ifa;
 
@@ -1882,7 +1883,7 @@
 	if (copy_from_user(&ireq, arg, sizeof(struct in6_ifreq)))
 		goto err_exit;
 
-	dev = __dev_get_by_index(ireq.ifr6_ifindex);
+	dev = __dev_get_by_index(&init_net, ireq.ifr6_ifindex);
 
 	err = -ENODEV;
 	if (dev == NULL)
@@ -1913,7 +1914,7 @@
 
 		if (err == 0) {
 			err = -ENOBUFS;
-			if ((dev = __dev_get_by_name(p.name)) == NULL)
+			if ((dev = __dev_get_by_name(&init_net, p.name)) == NULL)
 				goto err_exit;
 			err = dev_open(dev);
 		}
@@ -1943,7 +1944,7 @@
 	if (!valid_lft || prefered_lft > valid_lft)
 		return -EINVAL;
 
-	if ((dev = __dev_get_by_index(ifindex)) == NULL)
+	if ((dev = __dev_get_by_index(&init_net, ifindex)) == NULL)
 		return -ENODEV;
 
 	if ((idev = addrconf_add_dev(dev)) == NULL)
@@ -1994,7 +1995,7 @@
 	struct inet6_dev *idev;
 	struct net_device *dev;
 
-	if ((dev = __dev_get_by_index(ifindex)) == NULL)
+	if ((dev = __dev_get_by_index(&init_net, ifindex)) == NULL)
 		return -ENODEV;
 
 	if ((idev = __in6_dev_get(dev)) == NULL)
@@ -2089,7 +2090,7 @@
 		return;
 	}
 
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		struct in_device * in_dev = __in_dev_get_rtnl(dev);
 		if (in_dev && (dev->flags & IFF_UP)) {
 			struct in_ifaddr * ifa;
@@ -2245,12 +2246,12 @@
 
 	/* first try to inherit the link-local address from the link device */
 	if (idev->dev->iflink &&
-	    (link_dev = __dev_get_by_index(idev->dev->iflink))) {
+	    (link_dev = __dev_get_by_index(&init_net, idev->dev->iflink))) {
 		if (!ipv6_inherit_linklocal(idev, link_dev))
 			return;
 	}
 	/* then try to inherit it from any device */
-	for_each_netdev(link_dev) {
+	for_each_netdev(&init_net, link_dev) {
 		if (!ipv6_inherit_linklocal(idev, link_dev))
 			return;
 	}
@@ -2282,6 +2283,9 @@
 	struct inet6_dev *idev = __in6_dev_get(dev);
 	int run_pending = 0;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	switch(event) {
 	case NETDEV_REGISTER:
 		if (!idev && dev->mtu >= IPV6_MIN_MTU) {
@@ -2419,7 +2423,7 @@
 
 	ASSERT_RTNL();
 
-	if (dev == &loopback_dev && how == 1)
+	if (dev == &init_net.loopback_dev && how == 1)
 		how = 0;
 
 	rt6_ifdown(dev);
@@ -2850,14 +2854,14 @@
 
 int __init if6_proc_init(void)
 {
-	if (!proc_net_fops_create("if_inet6", S_IRUGO, &if6_fops))
+	if (!proc_net_fops_create(&init_net, "if_inet6", S_IRUGO, &if6_fops))
 		return -ENOMEM;
 	return 0;
 }
 
 void if6_proc_exit(void)
 {
-	proc_net_remove("if_inet6");
+	proc_net_remove(&init_net, "if_inet6");
 }
 #endif	/* CONFIG_PROC_FS */
 
@@ -3017,11 +3021,15 @@
 static int
 inet6_rtm_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct ifaddrmsg *ifm;
 	struct nlattr *tb[IFA_MAX+1];
 	struct in6_addr *pfx;
 	int err;
 
+	if (net != &init_net)
+		return -EINVAL;
+
 	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv6_policy);
 	if (err < 0)
 		return err;
@@ -3074,6 +3082,7 @@
 static int
 inet6_rtm_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct ifaddrmsg *ifm;
 	struct nlattr *tb[IFA_MAX+1];
 	struct in6_addr *pfx;
@@ -3083,6 +3092,9 @@
 	u8 ifa_flags;
 	int err;
 
+	if (net != &init_net)
+		return -EINVAL;
+
 	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv6_policy);
 	if (err < 0)
 		return err;
@@ -3103,7 +3115,7 @@
 		valid_lft = INFINITY_LIFE_TIME;
 	}
 
-	dev =  __dev_get_by_index(ifm->ifa_index);
+	dev =  __dev_get_by_index(&init_net, ifm->ifa_index);
 	if (dev == NULL)
 		return -ENODEV;
 
@@ -3292,7 +3304,7 @@
 	s_ip_idx = ip_idx = cb->args[1];
 
 	idx = 0;
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if (idx < s_idx)
 			goto cont;
 		if (idx > s_idx)
@@ -3367,26 +3379,42 @@
 
 static int inet6_dump_ifaddr(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	enum addr_type_t type = UNICAST_ADDR;
+
+	if (net != &init_net)
+		return 0;
+
 	return inet6_dump_addr(skb, cb, type);
 }
 
 static int inet6_dump_ifmcaddr(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	enum addr_type_t type = MULTICAST_ADDR;
+
+	if (net != &init_net)
+		return 0;
+
 	return inet6_dump_addr(skb, cb, type);
 }
 
 
 static int inet6_dump_ifacaddr(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	enum addr_type_t type = ANYCAST_ADDR;
+
+	if (net != &init_net)
+		return 0;
+
 	return inet6_dump_addr(skb, cb, type);
 }
 
 static int inet6_rtm_getaddr(struct sk_buff *in_skb, struct nlmsghdr* nlh,
 			     void *arg)
 {
+	struct net *net = in_skb->sk->sk_net;
 	struct ifaddrmsg *ifm;
 	struct nlattr *tb[IFA_MAX+1];
 	struct in6_addr *addr = NULL;
@@ -3395,6 +3423,9 @@
 	struct sk_buff *skb;
 	int err;
 
+	if (net != &init_net)
+		return -EINVAL;
+
 	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv6_policy);
 	if (err < 0)
 		goto errout;
@@ -3407,7 +3438,7 @@
 
 	ifm = nlmsg_data(nlh);
 	if (ifm->ifa_index)
-		dev = __dev_get_by_index(ifm->ifa_index);
+		dev = __dev_get_by_index(&init_net, ifm->ifa_index);
 
 	if ((ifa = ipv6_get_ifaddr(addr, dev, 1)) == NULL) {
 		err = -EADDRNOTAVAIL;
@@ -3427,7 +3458,7 @@
 		kfree_skb(skb);
 		goto errout_ifa;
 	}
-	err = rtnl_unicast(skb, NETLINK_CB(in_skb).pid);
+	err = rtnl_unicast(skb, &init_net, NETLINK_CB(in_skb).pid);
 errout_ifa:
 	in6_ifa_put(ifa);
 errout:
@@ -3450,10 +3481,10 @@
 		kfree_skb(skb);
 		goto errout;
 	}
-	err = rtnl_notify(skb, 0, RTNLGRP_IPV6_IFADDR, NULL, GFP_ATOMIC);
+	err = rtnl_notify(skb, &init_net, 0, RTNLGRP_IPV6_IFADDR, NULL, GFP_ATOMIC);
 errout:
 	if (err < 0)
-		rtnl_set_sk_err(RTNLGRP_IPV6_IFADDR, err);
+		rtnl_set_sk_err(&init_net, RTNLGRP_IPV6_IFADDR, err);
 }
 
 static inline void ipv6_store_devconf(struct ipv6_devconf *cnf,
@@ -3612,19 +3643,22 @@
 
 static int inet6_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)
 {
+ 	struct net *net = skb->sk->sk_net;
 	int idx, err;
 	int s_idx = cb->args[0];
 	struct net_device *dev;
 	struct inet6_dev *idev;
 	struct nx_info *nxi = skb->sk ? skb->sk->sk_nx_info : NULL;
 
+ 	if (net != &init_net)
+ 		return 0;
 	/* FIXME: maybe disable ipv6 on non v6 guests?
 	if (skb->sk && skb->sk->sk_vx_info)
 		return skb->len;	*/
 
 	read_lock(&dev_base_lock);
 	idx = 0;
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if (idx < s_idx)
 			goto cont;
 		if (!v6_dev_in_nx_info(dev, nxi))
@@ -3661,10 +3695,10 @@
 		kfree_skb(skb);
 		goto errout;
 	}
-	err = rtnl_notify(skb, 0, RTNLGRP_IPV6_IFADDR, NULL, GFP_ATOMIC);
+	err = rtnl_notify(skb, &init_net, 0, RTNLGRP_IPV6_IFADDR, NULL, GFP_ATOMIC);
 errout:
 	if (err < 0)
-		rtnl_set_sk_err(RTNLGRP_IPV6_IFADDR, err);
+		rtnl_set_sk_err(&init_net, RTNLGRP_IPV6_IFADDR, err);
 }
 
 static inline size_t inet6_prefix_nlmsg_size(void)
@@ -3730,10 +3764,10 @@
 		kfree_skb(skb);
 		goto errout;
 	}
-	err = rtnl_notify(skb, 0, RTNLGRP_IPV6_PREFIX, NULL, GFP_ATOMIC);
+	err = rtnl_notify(skb, &init_net, 0, RTNLGRP_IPV6_PREFIX, NULL, GFP_ATOMIC);
 errout:
 	if (err < 0)
-		rtnl_set_sk_err(RTNLGRP_IPV6_PREFIX, err);
+		rtnl_set_sk_err(&init_net, RTNLGRP_IPV6_PREFIX, err);
 }
 
 static void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)
@@ -4244,16 +4278,16 @@
 	 * device and it being up should be removed.
 	 */
 	rtnl_lock();
-	if (!ipv6_add_dev(&loopback_dev))
+	if (!ipv6_add_dev(&init_net.loopback_dev))
 		err = -ENOMEM;
 	rtnl_unlock();
 	if (err)
 		return err;
 
-	ip6_null_entry.rt6i_idev = in6_dev_get(&loopback_dev);
+	ip6_null_entry.rt6i_idev = in6_dev_get(&init_net.loopback_dev);
 #ifdef CONFIG_IPV6_MULTIPLE_TABLES
-	ip6_prohibit_entry.rt6i_idev = in6_dev_get(&loopback_dev);
-	ip6_blk_hole_entry.rt6i_idev = in6_dev_get(&loopback_dev);
+	ip6_prohibit_entry.rt6i_idev = in6_dev_get(&init_net.loopback_dev);
+	ip6_blk_hole_entry.rt6i_idev = in6_dev_get(&init_net.loopback_dev);
 #endif
 
 	register_netdevice_notifier(&ipv6_dev_notf);
@@ -4304,12 +4338,12 @@
 	 *	clean dev list.
 	 */
 
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if ((idev = __in6_dev_get(dev)) == NULL)
 			continue;
 		addrconf_ifdown(dev, 1);
 	}
-	addrconf_ifdown(&loopback_dev, 2);
+	addrconf_ifdown(&init_net.loopback_dev, 2);
 
 	/*
 	 *	Check hash table.
@@ -4335,6 +4369,6 @@
 	rtnl_unlock();
 
 #ifdef CONFIG_PROC_FS
-	proc_net_remove("if_inet6");
+	proc_net_remove(&init_net, "if_inet6");
 #endif
 }
diff -Nurb linux-2.6.22-590/net/ipv6/addrconf.c.orig linux-2.6.22-try2-netns/net/ipv6/addrconf.c.orig
--- linux-2.6.22-590/net/ipv6/addrconf.c.orig	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/addrconf.c.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,4301 +0,0 @@
-/*
- *	IPv6 Address [auto]configuration
- *	Linux INET6 implementation
- *
- *	Authors:
- *	Pedro Roque		<roque@di.fc.ul.pt>
- *	Alexey Kuznetsov	<kuznet@ms2.inr.ac.ru>
- *
- *	$Id: addrconf.c,v 1.69 2001/10/31 21:55:54 davem Exp $
- *
- *	This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
- */
-
-/*
- *	Changes:
- *
- *	Janos Farkas			:	delete timer on ifdown
- *	<chexum@bankinf.banki.hu>
- *	Andi Kleen			:	kill double kfree on module
- *						unload.
- *	Maciej W. Rozycki		:	FDDI support
- *	sekiya@USAGI			:	Don't send too many RS
- *						packets.
- *	yoshfuji@USAGI			:       Fixed interval between DAD
- *						packets.
- *	YOSHIFUJI Hideaki @USAGI	:	improved accuracy of
- *						address validation timer.
- *	YOSHIFUJI Hideaki @USAGI	:	Privacy Extensions (RFC3041)
- *						support.
- *	Yuji SEKIYA @USAGI		:	Don't assign a same IPv6
- *						address on a same interface.
- *	YOSHIFUJI Hideaki @USAGI	:	ARCnet support
- *	YOSHIFUJI Hideaki @USAGI	:	convert /proc/net/if_inet6 to
- *						seq_file.
- *	YOSHIFUJI Hideaki @USAGI	:	improved source address
- *						selection; consider scope,
- *						status etc.
- */
-
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <linux/socket.h>
-#include <linux/sockios.h>
-#include <linux/net.h>
-#include <linux/in6.h>
-#include <linux/netdevice.h>
-#include <linux/if_addr.h>
-#include <linux/if_arp.h>
-#include <linux/if_arcnet.h>
-#include <linux/if_infiniband.h>
-#include <linux/route.h>
-#include <linux/inetdevice.h>
-#include <linux/init.h>
-#ifdef CONFIG_SYSCTL
-#include <linux/sysctl.h>
-#endif
-#include <linux/capability.h>
-#include <linux/delay.h>
-#include <linux/notifier.h>
-#include <linux/string.h>
-
-#include <net/sock.h>
-#include <net/snmp.h>
-
-#include <net/ipv6.h>
-#include <net/protocol.h>
-#include <net/ndisc.h>
-#include <net/ip6_route.h>
-#include <net/addrconf.h>
-#include <net/tcp.h>
-#include <net/ip.h>
-#include <net/netlink.h>
-#include <net/pkt_sched.h>
-#include <linux/if_tunnel.h>
-#include <linux/rtnetlink.h>
-
-#ifdef CONFIG_IPV6_PRIVACY
-#include <linux/random.h>
-#endif
-
-#include <asm/uaccess.h>
-#include <asm/unaligned.h>
-
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-
-/* Set to 3 to get tracing... */
-#define ACONF_DEBUG 2
-
-#if ACONF_DEBUG >= 3
-#define ADBG(x) printk x
-#else
-#define ADBG(x)
-#endif
-
-#define	INFINITY_LIFE_TIME	0xFFFFFFFF
-#define TIME_DELTA(a,b) ((unsigned long)((long)(a) - (long)(b)))
-
-#ifdef CONFIG_SYSCTL
-static void addrconf_sysctl_register(struct inet6_dev *idev, struct ipv6_devconf *p);
-static void addrconf_sysctl_unregister(struct ipv6_devconf *p);
-#endif
-
-#ifdef CONFIG_IPV6_PRIVACY
-static int __ipv6_regen_rndid(struct inet6_dev *idev);
-static int __ipv6_try_regen_rndid(struct inet6_dev *idev, struct in6_addr *tmpaddr);
-static void ipv6_regen_rndid(unsigned long data);
-
-static int desync_factor = MAX_DESYNC_FACTOR * HZ;
-#endif
-
-static int ipv6_count_addresses(struct inet6_dev *idev);
-
-/*
- *	Configured unicast address hash table
- */
-static struct inet6_ifaddr		*inet6_addr_lst[IN6_ADDR_HSIZE];
-static DEFINE_RWLOCK(addrconf_hash_lock);
-
-static void addrconf_verify(unsigned long);
-
-static DEFINE_TIMER(addr_chk_timer, addrconf_verify, 0, 0);
-static DEFINE_SPINLOCK(addrconf_verify_lock);
-
-static void addrconf_join_anycast(struct inet6_ifaddr *ifp);
-static void addrconf_leave_anycast(struct inet6_ifaddr *ifp);
-
-static int addrconf_ifdown(struct net_device *dev, int how);
-
-static void addrconf_dad_start(struct inet6_ifaddr *ifp, u32 flags);
-static void addrconf_dad_timer(unsigned long data);
-static void addrconf_dad_completed(struct inet6_ifaddr *ifp);
-static void addrconf_dad_run(struct inet6_dev *idev);
-static void addrconf_rs_timer(unsigned long data);
-static void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifa);
-static void ipv6_ifa_notify(int event, struct inet6_ifaddr *ifa);
-
-static void inet6_prefix_notify(int event, struct inet6_dev *idev,
-				struct prefix_info *pinfo);
-static int ipv6_chk_same_addr(const struct in6_addr *addr, struct net_device *dev);
-
-static ATOMIC_NOTIFIER_HEAD(inet6addr_chain);
-
-struct ipv6_devconf ipv6_devconf __read_mostly = {
-	.forwarding		= 0,
-	.hop_limit		= IPV6_DEFAULT_HOPLIMIT,
-	.mtu6			= IPV6_MIN_MTU,
-	.accept_ra		= 1,
-	.accept_redirects	= 1,
-	.autoconf		= 1,
-	.force_mld_version	= 0,
-	.dad_transmits		= 1,
-	.rtr_solicits		= MAX_RTR_SOLICITATIONS,
-	.rtr_solicit_interval	= RTR_SOLICITATION_INTERVAL,
-	.rtr_solicit_delay	= MAX_RTR_SOLICITATION_DELAY,
-#ifdef CONFIG_IPV6_PRIVACY
-	.use_tempaddr 		= 0,
-	.temp_valid_lft		= TEMP_VALID_LIFETIME,
-	.temp_prefered_lft	= TEMP_PREFERRED_LIFETIME,
-	.regen_max_retry	= REGEN_MAX_RETRY,
-	.max_desync_factor	= MAX_DESYNC_FACTOR,
-#endif
-	.max_addresses		= IPV6_MAX_ADDRESSES,
-	.accept_ra_defrtr	= 1,
-	.accept_ra_pinfo	= 1,
-#ifdef CONFIG_IPV6_ROUTER_PREF
-	.accept_ra_rtr_pref	= 1,
-	.rtr_probe_interval	= 60 * HZ,
-#ifdef CONFIG_IPV6_ROUTE_INFO
-	.accept_ra_rt_info_max_plen = 0,
-#endif
-#endif
-	.proxy_ndp		= 0,
-	.accept_source_route	= 0,	/* we do not accept RH0 by default. */
-};
-
-static struct ipv6_devconf ipv6_devconf_dflt __read_mostly = {
-	.forwarding		= 0,
-	.hop_limit		= IPV6_DEFAULT_HOPLIMIT,
-	.mtu6			= IPV6_MIN_MTU,
-	.accept_ra		= 1,
-	.accept_redirects	= 1,
-	.autoconf		= 1,
-	.dad_transmits		= 1,
-	.rtr_solicits		= MAX_RTR_SOLICITATIONS,
-	.rtr_solicit_interval	= RTR_SOLICITATION_INTERVAL,
-	.rtr_solicit_delay	= MAX_RTR_SOLICITATION_DELAY,
-#ifdef CONFIG_IPV6_PRIVACY
-	.use_tempaddr		= 0,
-	.temp_valid_lft		= TEMP_VALID_LIFETIME,
-	.temp_prefered_lft	= TEMP_PREFERRED_LIFETIME,
-	.regen_max_retry	= REGEN_MAX_RETRY,
-	.max_desync_factor	= MAX_DESYNC_FACTOR,
-#endif
-	.max_addresses		= IPV6_MAX_ADDRESSES,
-	.accept_ra_defrtr	= 1,
-	.accept_ra_pinfo	= 1,
-#ifdef CONFIG_IPV6_ROUTER_PREF
-	.accept_ra_rtr_pref	= 1,
-	.rtr_probe_interval	= 60 * HZ,
-#ifdef CONFIG_IPV6_ROUTE_INFO
-	.accept_ra_rt_info_max_plen = 0,
-#endif
-#endif
-	.proxy_ndp		= 0,
-	.accept_source_route	= 0,	/* we do not accept RH0 by default. */
-};
-
-/* IPv6 Wildcard Address and Loopback Address defined by RFC2553 */
-const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;
-const struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;
-
-/* Check if a valid qdisc is available */
-static inline int addrconf_qdisc_ok(struct net_device *dev)
-{
-	return (dev->qdisc != &noop_qdisc);
-}
-
-static void addrconf_del_timer(struct inet6_ifaddr *ifp)
-{
-	if (del_timer(&ifp->timer))
-		__in6_ifa_put(ifp);
-}
-
-enum addrconf_timer_t
-{
-	AC_NONE,
-	AC_DAD,
-	AC_RS,
-};
-
-static void addrconf_mod_timer(struct inet6_ifaddr *ifp,
-			       enum addrconf_timer_t what,
-			       unsigned long when)
-{
-	if (!del_timer(&ifp->timer))
-		in6_ifa_hold(ifp);
-
-	switch (what) {
-	case AC_DAD:
-		ifp->timer.function = addrconf_dad_timer;
-		break;
-	case AC_RS:
-		ifp->timer.function = addrconf_rs_timer;
-		break;
-	default:;
-	}
-	ifp->timer.expires = jiffies + when;
-	add_timer(&ifp->timer);
-}
-
-static int snmp6_alloc_dev(struct inet6_dev *idev)
-{
-	int err = -ENOMEM;
-
-	if (!idev || !idev->dev)
-		return -EINVAL;
-
-	if (snmp_mib_init((void **)idev->stats.ipv6,
-			  sizeof(struct ipstats_mib),
-			  __alignof__(struct ipstats_mib)) < 0)
-		goto err_ip;
-	if (snmp_mib_init((void **)idev->stats.icmpv6,
-			  sizeof(struct icmpv6_mib),
-			  __alignof__(struct icmpv6_mib)) < 0)
-		goto err_icmp;
-
-	return 0;
-
-err_icmp:
-	snmp_mib_free((void **)idev->stats.ipv6);
-err_ip:
-	return err;
-}
-
-static int snmp6_free_dev(struct inet6_dev *idev)
-{
-	snmp_mib_free((void **)idev->stats.icmpv6);
-	snmp_mib_free((void **)idev->stats.ipv6);
-	return 0;
-}
-
-/* Nobody refers to this device, we may destroy it. */
-
-static void in6_dev_finish_destroy_rcu(struct rcu_head *head)
-{
-	struct inet6_dev *idev = container_of(head, struct inet6_dev, rcu);
-	kfree(idev);
-}
-
-void in6_dev_finish_destroy(struct inet6_dev *idev)
-{
-	struct net_device *dev = idev->dev;
-	BUG_TRAP(idev->addr_list==NULL);
-	BUG_TRAP(idev->mc_list==NULL);
-#ifdef NET_REFCNT_DEBUG
-	printk(KERN_DEBUG "in6_dev_finish_destroy: %s\n", dev ? dev->name : "NIL");
-#endif
-	dev_put(dev);
-	if (!idev->dead) {
-		printk("Freeing alive inet6 device %p\n", idev);
-		return;
-	}
-	snmp6_free_dev(idev);
-	call_rcu(&idev->rcu, in6_dev_finish_destroy_rcu);
-}
-
-EXPORT_SYMBOL(in6_dev_finish_destroy);
-
-static struct inet6_dev * ipv6_add_dev(struct net_device *dev)
-{
-	struct inet6_dev *ndev;
-	struct in6_addr maddr;
-
-	ASSERT_RTNL();
-
-	if (dev->mtu < IPV6_MIN_MTU)
-		return NULL;
-
-	ndev = kzalloc(sizeof(struct inet6_dev), GFP_KERNEL);
-
-	if (ndev == NULL)
-		return NULL;
-
-	rwlock_init(&ndev->lock);
-	ndev->dev = dev;
-	memcpy(&ndev->cnf, &ipv6_devconf_dflt, sizeof(ndev->cnf));
-	ndev->cnf.mtu6 = dev->mtu;
-	ndev->cnf.sysctl = NULL;
-	ndev->nd_parms = neigh_parms_alloc(dev, &nd_tbl);
-	if (ndev->nd_parms == NULL) {
-		kfree(ndev);
-		return NULL;
-	}
-	/* We refer to the device */
-	dev_hold(dev);
-
-	if (snmp6_alloc_dev(ndev) < 0) {
-		ADBG((KERN_WARNING
-			"%s(): cannot allocate memory for statistics; dev=%s.\n",
-			__FUNCTION__, dev->name));
-		neigh_parms_release(&nd_tbl, ndev->nd_parms);
-		ndev->dead = 1;
-		in6_dev_finish_destroy(ndev);
-		return NULL;
-	}
-
-	if (snmp6_register_dev(ndev) < 0) {
-		ADBG((KERN_WARNING
-			"%s(): cannot create /proc/net/dev_snmp6/%s\n",
-			__FUNCTION__, dev->name));
-		neigh_parms_release(&nd_tbl, ndev->nd_parms);
-		ndev->dead = 1;
-		in6_dev_finish_destroy(ndev);
-		return NULL;
-	}
-
-	/* One reference from device.  We must do this before
-	 * we invoke __ipv6_regen_rndid().
-	 */
-	in6_dev_hold(ndev);
-
-#ifdef CONFIG_IPV6_PRIVACY
-	init_timer(&ndev->regen_timer);
-	ndev->regen_timer.function = ipv6_regen_rndid;
-	ndev->regen_timer.data = (unsigned long) ndev;
-	if ((dev->flags&IFF_LOOPBACK) ||
-	    dev->type == ARPHRD_TUNNEL ||
-#if defined(CONFIG_IPV6_SIT) || defined(CONFIG_IPV6_SIT_MODULE)
-	    dev->type == ARPHRD_SIT ||
-#endif
-	    dev->type == ARPHRD_NONE) {
-		printk(KERN_INFO
-		       "%s: Disabled Privacy Extensions\n",
-		       dev->name);
-		ndev->cnf.use_tempaddr = -1;
-	} else {
-		in6_dev_hold(ndev);
-		ipv6_regen_rndid((unsigned long) ndev);
-	}
-#endif
-
-	if (netif_running(dev) && addrconf_qdisc_ok(dev))
-		ndev->if_flags |= IF_READY;
-
-	ipv6_mc_init_dev(ndev);
-	ndev->tstamp = jiffies;
-#ifdef CONFIG_SYSCTL
-	neigh_sysctl_register(dev, ndev->nd_parms, NET_IPV6,
-			      NET_IPV6_NEIGH, "ipv6",
-			      &ndisc_ifinfo_sysctl_change,
-			      NULL);
-	addrconf_sysctl_register(ndev, &ndev->cnf);
-#endif
-	/* protected by rtnl_lock */
-	rcu_assign_pointer(dev->ip6_ptr, ndev);
-
-	/* Join all-node multicast group */
-	ipv6_addr_all_nodes(&maddr);
-	ipv6_dev_mc_inc(dev, &maddr);
-
-	return ndev;
-}
-
-static struct inet6_dev * ipv6_find_idev(struct net_device *dev)
-{
-	struct inet6_dev *idev;
-
-	ASSERT_RTNL();
-
-	if ((idev = __in6_dev_get(dev)) == NULL) {
-		if ((idev = ipv6_add_dev(dev)) == NULL)
-			return NULL;
-	}
-
-	if (dev->flags&IFF_UP)
-		ipv6_mc_up(idev);
-	return idev;
-}
-
-#ifdef CONFIG_SYSCTL
-static void dev_forward_change(struct inet6_dev *idev)
-{
-	struct net_device *dev;
-	struct inet6_ifaddr *ifa;
-	struct in6_addr addr;
-
-	if (!idev)
-		return;
-	dev = idev->dev;
-	if (dev && (dev->flags & IFF_MULTICAST)) {
-		ipv6_addr_all_routers(&addr);
-
-		if (idev->cnf.forwarding)
-			ipv6_dev_mc_inc(dev, &addr);
-		else
-			ipv6_dev_mc_dec(dev, &addr);
-	}
-	for (ifa=idev->addr_list; ifa; ifa=ifa->if_next) {
-		if (ifa->flags&IFA_F_TENTATIVE)
-			continue;
-		if (idev->cnf.forwarding)
-			addrconf_join_anycast(ifa);
-		else
-			addrconf_leave_anycast(ifa);
-	}
-}
-
-
-static void addrconf_forward_change(void)
-{
-	struct net_device *dev;
-	struct inet6_dev *idev;
-
-	read_lock(&dev_base_lock);
-	for_each_netdev(dev) {
-		rcu_read_lock();
-		idev = __in6_dev_get(dev);
-		if (idev) {
-			int changed = (!idev->cnf.forwarding) ^ (!ipv6_devconf.forwarding);
-			idev->cnf.forwarding = ipv6_devconf.forwarding;
-			if (changed)
-				dev_forward_change(idev);
-		}
-		rcu_read_unlock();
-	}
-	read_unlock(&dev_base_lock);
-}
-#endif
-
-/* Nobody refers to this ifaddr, destroy it */
-
-void inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp)
-{
-	BUG_TRAP(ifp->if_next==NULL);
-	BUG_TRAP(ifp->lst_next==NULL);
-#ifdef NET_REFCNT_DEBUG
-	printk(KERN_DEBUG "inet6_ifa_finish_destroy\n");
-#endif
-
-	in6_dev_put(ifp->idev);
-
-	if (del_timer(&ifp->timer))
-		printk("Timer is still running, when freeing ifa=%p\n", ifp);
-
-	if (!ifp->dead) {
-		printk("Freeing alive inet6 address %p\n", ifp);
-		return;
-	}
-	dst_release(&ifp->rt->u.dst);
-
-	kfree(ifp);
-}
-
-static void
-ipv6_link_dev_addr(struct inet6_dev *idev, struct inet6_ifaddr *ifp)
-{
-	struct inet6_ifaddr *ifa, **ifap;
-	int ifp_scope = ipv6_addr_src_scope(&ifp->addr);
-
-	/*
-	 * Each device address list is sorted in order of scope -
-	 * global before linklocal.
-	 */
-	for (ifap = &idev->addr_list; (ifa = *ifap) != NULL;
-	     ifap = &ifa->if_next) {
-		if (ifp_scope >= ipv6_addr_src_scope(&ifa->addr))
-			break;
-	}
-
-	ifp->if_next = *ifap;
-	*ifap = ifp;
-}
-
-/* On success it returns ifp with increased reference count */
-
-static struct inet6_ifaddr *
-ipv6_add_addr(struct inet6_dev *idev, const struct in6_addr *addr, int pfxlen,
-	      int scope, u32 flags)
-{
-	struct inet6_ifaddr *ifa = NULL;
-	struct rt6_info *rt;
-	int hash;
-	int err = 0;
-
-	rcu_read_lock_bh();
-	if (idev->dead) {
-		err = -ENODEV;			/*XXX*/
-		goto out2;
-	}
-
-	write_lock(&addrconf_hash_lock);
-
-	/* Ignore adding duplicate addresses on an interface */
-	if (ipv6_chk_same_addr(addr, idev->dev)) {
-		ADBG(("ipv6_add_addr: already assigned\n"));
-		err = -EEXIST;
-		goto out;
-	}
-
-	ifa = kzalloc(sizeof(struct inet6_ifaddr), GFP_ATOMIC);
-
-	if (ifa == NULL) {
-		ADBG(("ipv6_add_addr: malloc failed\n"));
-		err = -ENOBUFS;
-		goto out;
-	}
-
-	rt = addrconf_dst_alloc(idev, addr, 0);
-	if (IS_ERR(rt)) {
-		err = PTR_ERR(rt);
-		goto out;
-	}
-
-	ipv6_addr_copy(&ifa->addr, addr);
-
-	spin_lock_init(&ifa->lock);
-	init_timer(&ifa->timer);
-	ifa->timer.data = (unsigned long) ifa;
-	ifa->scope = scope;
-	ifa->prefix_len = pfxlen;
-	ifa->flags = flags | IFA_F_TENTATIVE;
-	ifa->cstamp = ifa->tstamp = jiffies;
-
-	ifa->rt = rt;
-
-	/*
-	 * part one of RFC 4429, section 3.3
-	 * We should not configure an address as
-	 * optimistic if we do not yet know the link
-	 * layer address of our nexhop router
-	 */
-
-	if (rt->rt6i_nexthop == NULL)
-		ifa->flags &= ~IFA_F_OPTIMISTIC;
-
-	ifa->idev = idev;
-	in6_dev_hold(idev);
-	/* For caller */
-	in6_ifa_hold(ifa);
-
-	/* Add to big hash table */
-	hash = ipv6_addr_hash(addr);
-
-	ifa->lst_next = inet6_addr_lst[hash];
-	inet6_addr_lst[hash] = ifa;
-	in6_ifa_hold(ifa);
-	write_unlock(&addrconf_hash_lock);
-
-	write_lock(&idev->lock);
-	/* Add to inet6_dev unicast addr list. */
-	ipv6_link_dev_addr(idev, ifa);
-
-#ifdef CONFIG_IPV6_PRIVACY
-	if (ifa->flags&IFA_F_TEMPORARY) {
-		ifa->tmp_next = idev->tempaddr_list;
-		idev->tempaddr_list = ifa;
-		in6_ifa_hold(ifa);
-	}
-#endif
-
-	in6_ifa_hold(ifa);
-	write_unlock(&idev->lock);
-out2:
-	rcu_read_unlock_bh();
-
-	if (likely(err == 0))
-		atomic_notifier_call_chain(&inet6addr_chain, NETDEV_UP, ifa);
-	else {
-		kfree(ifa);
-		ifa = ERR_PTR(err);
-	}
-
-	return ifa;
-out:
-	write_unlock(&addrconf_hash_lock);
-	goto out2;
-}
-
-/* This function wants to get referenced ifp and releases it before return */
-
-static void ipv6_del_addr(struct inet6_ifaddr *ifp)
-{
-	struct inet6_ifaddr *ifa, **ifap;
-	struct inet6_dev *idev = ifp->idev;
-	int hash;
-	int deleted = 0, onlink = 0;
-	unsigned long expires = jiffies;
-
-	hash = ipv6_addr_hash(&ifp->addr);
-
-	ifp->dead = 1;
-
-	write_lock_bh(&addrconf_hash_lock);
-	for (ifap = &inet6_addr_lst[hash]; (ifa=*ifap) != NULL;
-	     ifap = &ifa->lst_next) {
-		if (ifa == ifp) {
-			*ifap = ifa->lst_next;
-			__in6_ifa_put(ifp);
-			ifa->lst_next = NULL;
-			break;
-		}
-	}
-	write_unlock_bh(&addrconf_hash_lock);
-
-	write_lock_bh(&idev->lock);
-#ifdef CONFIG_IPV6_PRIVACY
-	if (ifp->flags&IFA_F_TEMPORARY) {
-		for (ifap = &idev->tempaddr_list; (ifa=*ifap) != NULL;
-		     ifap = &ifa->tmp_next) {
-			if (ifa == ifp) {
-				*ifap = ifa->tmp_next;
-				if (ifp->ifpub) {
-					in6_ifa_put(ifp->ifpub);
-					ifp->ifpub = NULL;
-				}
-				__in6_ifa_put(ifp);
-				ifa->tmp_next = NULL;
-				break;
-			}
-		}
-	}
-#endif
-
-	for (ifap = &idev->addr_list; (ifa=*ifap) != NULL;) {
-		if (ifa == ifp) {
-			*ifap = ifa->if_next;
-			__in6_ifa_put(ifp);
-			ifa->if_next = NULL;
-			if (!(ifp->flags & IFA_F_PERMANENT) || onlink > 0)
-				break;
-			deleted = 1;
-			continue;
-		} else if (ifp->flags & IFA_F_PERMANENT) {
-			if (ipv6_prefix_equal(&ifa->addr, &ifp->addr,
-					      ifp->prefix_len)) {
-				if (ifa->flags & IFA_F_PERMANENT) {
-					onlink = 1;
-					if (deleted)
-						break;
-				} else {
-					unsigned long lifetime;
-
-					if (!onlink)
-						onlink = -1;
-
-					spin_lock(&ifa->lock);
-					lifetime = min_t(unsigned long,
-							 ifa->valid_lft, 0x7fffffffUL/HZ);
-					if (time_before(expires,
-							ifa->tstamp + lifetime * HZ))
-						expires = ifa->tstamp + lifetime * HZ;
-					spin_unlock(&ifa->lock);
-				}
-			}
-		}
-		ifap = &ifa->if_next;
-	}
-	write_unlock_bh(&idev->lock);
-
-	ipv6_ifa_notify(RTM_DELADDR, ifp);
-
-	atomic_notifier_call_chain(&inet6addr_chain, NETDEV_DOWN, ifp);
-
-	addrconf_del_timer(ifp);
-
-	/*
-	 * Purge or update corresponding prefix
-	 *
-	 * 1) we don't purge prefix here if address was not permanent.
-	 *    prefix is managed by its own lifetime.
-	 * 2) if there're no addresses, delete prefix.
-	 * 3) if there're still other permanent address(es),
-	 *    corresponding prefix is still permanent.
-	 * 4) otherwise, update prefix lifetime to the
-	 *    longest valid lifetime among the corresponding
-	 *    addresses on the device.
-	 *    Note: subsequent RA will update lifetime.
-	 *
-	 * --yoshfuji
-	 */
-	if ((ifp->flags & IFA_F_PERMANENT) && onlink < 1) {
-		struct in6_addr prefix;
-		struct rt6_info *rt;
-
-		ipv6_addr_prefix(&prefix, &ifp->addr, ifp->prefix_len);
-		rt = rt6_lookup(&prefix, NULL, ifp->idev->dev->ifindex, 1);
-
-		if (rt && ((rt->rt6i_flags & (RTF_GATEWAY | RTF_DEFAULT)) == 0)) {
-			if (onlink == 0) {
-				ip6_del_rt(rt);
-				rt = NULL;
-			} else if (!(rt->rt6i_flags & RTF_EXPIRES)) {
-				rt->rt6i_expires = expires;
-				rt->rt6i_flags |= RTF_EXPIRES;
-			}
-		}
-		dst_release(&rt->u.dst);
-	}
-
-	in6_ifa_put(ifp);
-}
-
-#ifdef CONFIG_IPV6_PRIVACY
-static int ipv6_create_tempaddr(struct inet6_ifaddr *ifp, struct inet6_ifaddr *ift)
-{
-	struct inet6_dev *idev = ifp->idev;
-	struct in6_addr addr, *tmpaddr;
-	unsigned long tmp_prefered_lft, tmp_valid_lft, tmp_cstamp, tmp_tstamp;
-	int tmp_plen;
-	int ret = 0;
-	int max_addresses;
-	u32 addr_flags;
-
-	write_lock(&idev->lock);
-	if (ift) {
-		spin_lock_bh(&ift->lock);
-		memcpy(&addr.s6_addr[8], &ift->addr.s6_addr[8], 8);
-		spin_unlock_bh(&ift->lock);
-		tmpaddr = &addr;
-	} else {
-		tmpaddr = NULL;
-	}
-retry:
-	in6_dev_hold(idev);
-	if (idev->cnf.use_tempaddr <= 0) {
-		write_unlock(&idev->lock);
-		printk(KERN_INFO
-			"ipv6_create_tempaddr(): use_tempaddr is disabled.\n");
-		in6_dev_put(idev);
-		ret = -1;
-		goto out;
-	}
-	spin_lock_bh(&ifp->lock);
-	if (ifp->regen_count++ >= idev->cnf.regen_max_retry) {
-		idev->cnf.use_tempaddr = -1;	/*XXX*/
-		spin_unlock_bh(&ifp->lock);
-		write_unlock(&idev->lock);
-		printk(KERN_WARNING
-			"ipv6_create_tempaddr(): regeneration time exceeded. disabled temporary address support.\n");
-		in6_dev_put(idev);
-		ret = -1;
-		goto out;
-	}
-	in6_ifa_hold(ifp);
-	memcpy(addr.s6_addr, ifp->addr.s6_addr, 8);
-	if (__ipv6_try_regen_rndid(idev, tmpaddr) < 0) {
-		spin_unlock_bh(&ifp->lock);
-		write_unlock(&idev->lock);
-		printk(KERN_WARNING
-			"ipv6_create_tempaddr(): regeneration of randomized interface id failed.\n");
-		in6_ifa_put(ifp);
-		in6_dev_put(idev);
-		ret = -1;
-		goto out;
-	}
-	memcpy(&addr.s6_addr[8], idev->rndid, 8);
-	tmp_valid_lft = min_t(__u32,
-			      ifp->valid_lft,
-			      idev->cnf.temp_valid_lft);
-	tmp_prefered_lft = min_t(__u32,
-				 ifp->prefered_lft,
-				 idev->cnf.temp_prefered_lft - desync_factor / HZ);
-	tmp_plen = ifp->prefix_len;
-	max_addresses = idev->cnf.max_addresses;
-	tmp_cstamp = ifp->cstamp;
-	tmp_tstamp = ifp->tstamp;
-	spin_unlock_bh(&ifp->lock);
-
-	write_unlock(&idev->lock);
-
-	addr_flags = IFA_F_TEMPORARY;
-	/* set in addrconf_prefix_rcv() */
-	if (ifp->flags & IFA_F_OPTIMISTIC)
-		addr_flags |= IFA_F_OPTIMISTIC;
-
-	ift = !max_addresses ||
-	      ipv6_count_addresses(idev) < max_addresses ?
-		ipv6_add_addr(idev, &addr, tmp_plen,
-			      ipv6_addr_type(&addr)&IPV6_ADDR_SCOPE_MASK,
-			      addr_flags) : NULL;
-	if (!ift || IS_ERR(ift)) {
-		in6_ifa_put(ifp);
-		in6_dev_put(idev);
-		printk(KERN_INFO
-			"ipv6_create_tempaddr(): retry temporary address regeneration.\n");
-		tmpaddr = &addr;
-		write_lock(&idev->lock);
-		goto retry;
-	}
-
-	spin_lock_bh(&ift->lock);
-	ift->ifpub = ifp;
-	ift->valid_lft = tmp_valid_lft;
-	ift->prefered_lft = tmp_prefered_lft;
-	ift->cstamp = tmp_cstamp;
-	ift->tstamp = tmp_tstamp;
-	spin_unlock_bh(&ift->lock);
-
-	addrconf_dad_start(ift, 0);
-	in6_ifa_put(ift);
-	in6_dev_put(idev);
-out:
-	return ret;
-}
-#endif
-
-/*
- *	Choose an appropriate source address (RFC3484)
- */
-struct ipv6_saddr_score {
-	int		addr_type;
-	unsigned int	attrs;
-	int		matchlen;
-	int		scope;
-	unsigned int	rule;
-};
-
-#define IPV6_SADDR_SCORE_LOCAL		0x0001
-#define IPV6_SADDR_SCORE_PREFERRED	0x0004
-#define IPV6_SADDR_SCORE_HOA		0x0008
-#define IPV6_SADDR_SCORE_OIF		0x0010
-#define IPV6_SADDR_SCORE_LABEL		0x0020
-#define IPV6_SADDR_SCORE_PRIVACY	0x0040
-
-static inline int ipv6_saddr_preferred(int type)
-{
-	if (type & (IPV6_ADDR_MAPPED|IPV6_ADDR_COMPATv4|
-		    IPV6_ADDR_LOOPBACK|IPV6_ADDR_RESERVED))
-		return 1;
-	return 0;
-}
-
-/* static matching label */
-static inline int ipv6_saddr_label(const struct in6_addr *addr, int type)
-{
- /*
-  * 	prefix (longest match)	label
-  * 	-----------------------------
-  * 	::1/128			0
-  * 	::/0			1
-  * 	2002::/16		2
-  * 	::/96			3
-  * 	::ffff:0:0/96		4
-  *	fc00::/7		5
-  * 	2001::/32		6
-  */
-	if (type & IPV6_ADDR_LOOPBACK)
-		return 0;
-	else if (type & IPV6_ADDR_COMPATv4)
-		return 3;
-	else if (type & IPV6_ADDR_MAPPED)
-		return 4;
-	else if (addr->s6_addr32[0] == htonl(0x20010000))
-		return 6;
-	else if (addr->s6_addr16[0] == htons(0x2002))
-		return 2;
-	else if ((addr->s6_addr[0] & 0xfe) == 0xfc)
-		return 5;
-	return 1;
-}
-
-int ipv6_dev_get_saddr(struct net_device *daddr_dev,
-		       struct in6_addr *daddr, struct in6_addr *saddr)
-{
-	struct ipv6_saddr_score hiscore;
-	struct inet6_ifaddr *ifa_result = NULL;
-	int daddr_type = __ipv6_addr_type(daddr);
-	int daddr_scope = __ipv6_addr_src_scope(daddr_type);
-	u32 daddr_label = ipv6_saddr_label(daddr, daddr_type);
-	struct net_device *dev;
-
-	memset(&hiscore, 0, sizeof(hiscore));
-
-	read_lock(&dev_base_lock);
-	rcu_read_lock();
-
-	for_each_netdev(dev) {
-		struct inet6_dev *idev;
-		struct inet6_ifaddr *ifa;
-
-		/* Rule 0: Candidate Source Address (section 4)
-		 *  - multicast and link-local destination address,
-		 *    the set of candidate source address MUST only
-		 *    include addresses assigned to interfaces
-		 *    belonging to the same link as the outgoing
-		 *    interface.
-		 * (- For site-local destination addresses, the
-		 *    set of candidate source addresses MUST only
-		 *    include addresses assigned to interfaces
-		 *    belonging to the same site as the outgoing
-		 *    interface.)
-		 */
-		if ((daddr_type & IPV6_ADDR_MULTICAST ||
-		     daddr_scope <= IPV6_ADDR_SCOPE_LINKLOCAL) &&
-		    daddr_dev && dev != daddr_dev)
-			continue;
-
-		idev = __in6_dev_get(dev);
-		if (!idev)
-			continue;
-
-		read_lock_bh(&idev->lock);
-		for (ifa = idev->addr_list; ifa; ifa = ifa->if_next) {
-			struct ipv6_saddr_score score;
-
-			score.addr_type = __ipv6_addr_type(&ifa->addr);
-
-			/* Rule 0:
-			 * - Tentative Address (RFC2462 section 5.4)
-			 *  - A tentative address is not considered
-			 *    "assigned to an interface" in the traditional
-			 *    sense, unless it is also flagged as optimistic.
-			 * - Candidate Source Address (section 4)
-			 *  - In any case, anycast addresses, multicast
-			 *    addresses, and the unspecified address MUST
-			 *    NOT be included in a candidate set.
-			 */
-			if ((ifa->flags & IFA_F_TENTATIVE) &&
-			    (!(ifa->flags & IFA_F_OPTIMISTIC)))
-				continue;
-			if (unlikely(score.addr_type == IPV6_ADDR_ANY ||
-				     score.addr_type & IPV6_ADDR_MULTICAST)) {
-				LIMIT_NETDEBUG(KERN_DEBUG
-					       "ADDRCONF: unspecified / multicast address"
-					       "assigned as unicast address on %s",
-					       dev->name);
-				continue;
-			}
-
-			score.attrs = 0;
-			score.matchlen = 0;
-			score.scope = 0;
-			score.rule = 0;
-
-			if (ifa_result == NULL) {
-				/* record it if the first available entry */
-				goto record_it;
-			}
-
-			/* Rule 1: Prefer same address */
-			if (hiscore.rule < 1) {
-				if (ipv6_addr_equal(&ifa_result->addr, daddr))
-					hiscore.attrs |= IPV6_SADDR_SCORE_LOCAL;
-				hiscore.rule++;
-			}
-			if (ipv6_addr_equal(&ifa->addr, daddr)) {
-				score.attrs |= IPV6_SADDR_SCORE_LOCAL;
-				if (!(hiscore.attrs & IPV6_SADDR_SCORE_LOCAL)) {
-					score.rule = 1;
-					goto record_it;
-				}
-			} else {
-				if (hiscore.attrs & IPV6_SADDR_SCORE_LOCAL)
-					continue;
-			}
-
-			/* Rule 2: Prefer appropriate scope */
-			if (hiscore.rule < 2) {
-				hiscore.scope = __ipv6_addr_src_scope(hiscore.addr_type);
-				hiscore.rule++;
-			}
-			score.scope = __ipv6_addr_src_scope(score.addr_type);
-			if (hiscore.scope < score.scope) {
-				if (hiscore.scope < daddr_scope) {
-					score.rule = 2;
-					goto record_it;
-				} else
-					continue;
-			} else if (score.scope < hiscore.scope) {
-				if (score.scope < daddr_scope)
-					break; /* addresses sorted by scope */
-				else {
-					score.rule = 2;
-					goto record_it;
-				}
-			}
-
-			/* Rule 3: Avoid deprecated and optimistic addresses */
-			if (hiscore.rule < 3) {
-				if (ipv6_saddr_preferred(hiscore.addr_type) ||
-				   (((ifa_result->flags &
-				    (IFA_F_DEPRECATED|IFA_F_OPTIMISTIC)) == 0)))
-					hiscore.attrs |= IPV6_SADDR_SCORE_PREFERRED;
-				hiscore.rule++;
-			}
-			if (ipv6_saddr_preferred(score.addr_type) ||
-			   (((ifa->flags &
-			    (IFA_F_DEPRECATED|IFA_F_OPTIMISTIC)) == 0))) {
-				score.attrs |= IPV6_SADDR_SCORE_PREFERRED;
-				if (!(hiscore.attrs & IPV6_SADDR_SCORE_PREFERRED)) {
-					score.rule = 3;
-					goto record_it;
-				}
-			} else {
-				if (hiscore.attrs & IPV6_SADDR_SCORE_PREFERRED)
-					continue;
-			}
-
-			/* Rule 4: Prefer home address */
-#ifdef CONFIG_IPV6_MIP6
-			if (hiscore.rule < 4) {
-				if (ifa_result->flags & IFA_F_HOMEADDRESS)
-					hiscore.attrs |= IPV6_SADDR_SCORE_HOA;
-				hiscore.rule++;
-			}
-			if (ifa->flags & IFA_F_HOMEADDRESS) {
-				score.attrs |= IPV6_SADDR_SCORE_HOA;
-				if (!(ifa_result->flags & IFA_F_HOMEADDRESS)) {
-					score.rule = 4;
-					goto record_it;
-				}
-			} else {
-				if (hiscore.attrs & IPV6_SADDR_SCORE_HOA)
-					continue;
-			}
-#else
-			if (hiscore.rule < 4)
-				hiscore.rule++;
-#endif
-
-			/* Rule 5: Prefer outgoing interface */
-			if (hiscore.rule < 5) {
-				if (daddr_dev == NULL ||
-				    daddr_dev == ifa_result->idev->dev)
-					hiscore.attrs |= IPV6_SADDR_SCORE_OIF;
-				hiscore.rule++;
-			}
-			if (daddr_dev == NULL ||
-			    daddr_dev == ifa->idev->dev) {
-				score.attrs |= IPV6_SADDR_SCORE_OIF;
-				if (!(hiscore.attrs & IPV6_SADDR_SCORE_OIF)) {
-					score.rule = 5;
-					goto record_it;
-				}
-			} else {
-				if (hiscore.attrs & IPV6_SADDR_SCORE_OIF)
-					continue;
-			}
-
-			/* Rule 6: Prefer matching label */
-			if (hiscore.rule < 6) {
-				if (ipv6_saddr_label(&ifa_result->addr, hiscore.addr_type) == daddr_label)
-					hiscore.attrs |= IPV6_SADDR_SCORE_LABEL;
-				hiscore.rule++;
-			}
-			if (ipv6_saddr_label(&ifa->addr, score.addr_type) == daddr_label) {
-				score.attrs |= IPV6_SADDR_SCORE_LABEL;
-				if (!(hiscore.attrs & IPV6_SADDR_SCORE_LABEL)) {
-					score.rule = 6;
-					goto record_it;
-				}
-			} else {
-				if (hiscore.attrs & IPV6_SADDR_SCORE_LABEL)
-					continue;
-			}
-
-#ifdef CONFIG_IPV6_PRIVACY
-			/* Rule 7: Prefer public address
-			 * Note: prefer temprary address if use_tempaddr >= 2
-			 */
-			if (hiscore.rule < 7) {
-				if ((!(ifa_result->flags & IFA_F_TEMPORARY)) ^
-				    (ifa_result->idev->cnf.use_tempaddr >= 2))
-					hiscore.attrs |= IPV6_SADDR_SCORE_PRIVACY;
-				hiscore.rule++;
-			}
-			if ((!(ifa->flags & IFA_F_TEMPORARY)) ^
-			    (ifa->idev->cnf.use_tempaddr >= 2)) {
-				score.attrs |= IPV6_SADDR_SCORE_PRIVACY;
-				if (!(hiscore.attrs & IPV6_SADDR_SCORE_PRIVACY)) {
-					score.rule = 7;
-					goto record_it;
-				}
-			} else {
-				if (hiscore.attrs & IPV6_SADDR_SCORE_PRIVACY)
-					continue;
-			}
-#else
-			if (hiscore.rule < 7)
-				hiscore.rule++;
-#endif
-			/* Rule 8: Use longest matching prefix */
-			if (hiscore.rule < 8) {
-				hiscore.matchlen = ipv6_addr_diff(&ifa_result->addr, daddr);
-				hiscore.rule++;
-			}
-			score.matchlen = ipv6_addr_diff(&ifa->addr, daddr);
-			if (score.matchlen > hiscore.matchlen) {
-				score.rule = 8;
-				goto record_it;
-			}
-#if 0
-			else if (score.matchlen < hiscore.matchlen)
-				continue;
-#endif
-
-			/* Final Rule: choose first available one */
-			continue;
-record_it:
-			if (ifa_result)
-				in6_ifa_put(ifa_result);
-			in6_ifa_hold(ifa);
-			ifa_result = ifa;
-			hiscore = score;
-		}
-		read_unlock_bh(&idev->lock);
-	}
-	rcu_read_unlock();
-	read_unlock(&dev_base_lock);
-
-	if (!ifa_result)
-		return -EADDRNOTAVAIL;
-
-	ipv6_addr_copy(saddr, &ifa_result->addr);
-	in6_ifa_put(ifa_result);
-	return 0;
-}
-
-
-int ipv6_get_saddr(struct dst_entry *dst,
-		   struct in6_addr *daddr, struct in6_addr *saddr)
-{
-	return ipv6_dev_get_saddr(dst ? ip6_dst_idev(dst)->dev : NULL, daddr, saddr);
-}
-
-EXPORT_SYMBOL(ipv6_get_saddr);
-
-int ipv6_get_lladdr(struct net_device *dev, struct in6_addr *addr,
-		    unsigned char banned_flags)
-{
-	struct inet6_dev *idev;
-	int err = -EADDRNOTAVAIL;
-
-	rcu_read_lock();
-	if ((idev = __in6_dev_get(dev)) != NULL) {
-		struct inet6_ifaddr *ifp;
-
-		read_lock_bh(&idev->lock);
-		for (ifp=idev->addr_list; ifp; ifp=ifp->if_next) {
-			if (ifp->scope == IFA_LINK && !(ifp->flags & banned_flags)) {
-				ipv6_addr_copy(addr, &ifp->addr);
-				err = 0;
-				break;
-			}
-		}
-		read_unlock_bh(&idev->lock);
-	}
-	rcu_read_unlock();
-	return err;
-}
-
-static int ipv6_count_addresses(struct inet6_dev *idev)
-{
-	int cnt = 0;
-	struct inet6_ifaddr *ifp;
-
-	read_lock_bh(&idev->lock);
-	for (ifp=idev->addr_list; ifp; ifp=ifp->if_next)
-		cnt++;
-	read_unlock_bh(&idev->lock);
-	return cnt;
-}
-
-int ipv6_chk_addr(struct in6_addr *addr, struct net_device *dev, int strict)
-{
-	struct inet6_ifaddr * ifp;
-	u8 hash = ipv6_addr_hash(addr);
-
-	read_lock_bh(&addrconf_hash_lock);
-	for(ifp = inet6_addr_lst[hash]; ifp; ifp=ifp->lst_next) {
-		if (ipv6_addr_equal(&ifp->addr, addr) &&
-		    !(ifp->flags&IFA_F_TENTATIVE)) {
-			if (dev == NULL || ifp->idev->dev == dev ||
-			    !(ifp->scope&(IFA_LINK|IFA_HOST) || strict))
-				break;
-		}
-	}
-	read_unlock_bh(&addrconf_hash_lock);
-	return ifp != NULL;
-}
-
-EXPORT_SYMBOL(ipv6_chk_addr);
-
-static
-int ipv6_chk_same_addr(const struct in6_addr *addr, struct net_device *dev)
-{
-	struct inet6_ifaddr * ifp;
-	u8 hash = ipv6_addr_hash(addr);
-
-	for(ifp = inet6_addr_lst[hash]; ifp; ifp=ifp->lst_next) {
-		if (ipv6_addr_equal(&ifp->addr, addr)) {
-			if (dev == NULL || ifp->idev->dev == dev)
-				break;
-		}
-	}
-	return ifp != NULL;
-}
-
-struct inet6_ifaddr * ipv6_get_ifaddr(struct in6_addr *addr, struct net_device *dev, int strict)
-{
-	struct inet6_ifaddr * ifp;
-	u8 hash = ipv6_addr_hash(addr);
-
-	read_lock_bh(&addrconf_hash_lock);
-	for(ifp = inet6_addr_lst[hash]; ifp; ifp=ifp->lst_next) {
-		if (ipv6_addr_equal(&ifp->addr, addr)) {
-			if (dev == NULL || ifp->idev->dev == dev ||
-			    !(ifp->scope&(IFA_LINK|IFA_HOST) || strict)) {
-				in6_ifa_hold(ifp);
-				break;
-			}
-		}
-	}
-	read_unlock_bh(&addrconf_hash_lock);
-
-	return ifp;
-}
-
-int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2)
-{
-	const struct in6_addr *sk_rcv_saddr6 = &inet6_sk(sk)->rcv_saddr;
-	const struct in6_addr *sk2_rcv_saddr6 = inet6_rcv_saddr(sk2);
-	__be32 sk_rcv_saddr = inet_sk(sk)->rcv_saddr;
-	__be32 sk2_rcv_saddr = inet_rcv_saddr(sk2);
-	int sk_ipv6only = ipv6_only_sock(sk);
-	int sk2_ipv6only = inet_v6_ipv6only(sk2);
-	int addr_type = ipv6_addr_type(sk_rcv_saddr6);
-	int addr_type2 = sk2_rcv_saddr6 ? ipv6_addr_type(sk2_rcv_saddr6) : IPV6_ADDR_MAPPED;
-
-	if (!sk2_rcv_saddr && !sk_ipv6only)
-		return 1;
-
-	if (addr_type2 == IPV6_ADDR_ANY &&
-	    !(sk2_ipv6only && addr_type == IPV6_ADDR_MAPPED))
-		return 1;
-
-	if (addr_type == IPV6_ADDR_ANY &&
-	    !(sk_ipv6only && addr_type2 == IPV6_ADDR_MAPPED))
-		return 1;
-
-	if (sk2_rcv_saddr6 &&
-	    ipv6_addr_equal(sk_rcv_saddr6, sk2_rcv_saddr6))
-		return 1;
-
-	if (addr_type == IPV6_ADDR_MAPPED &&
-	    !sk2_ipv6only &&
-	    (!sk2_rcv_saddr || !sk_rcv_saddr || sk_rcv_saddr == sk2_rcv_saddr))
-		return 1;
-
-	return 0;
-}
-
-/* Gets referenced address, destroys ifaddr */
-
-static void addrconf_dad_stop(struct inet6_ifaddr *ifp)
-{
-	if (ifp->flags&IFA_F_PERMANENT) {
-		spin_lock_bh(&ifp->lock);
-		addrconf_del_timer(ifp);
-		ifp->flags |= IFA_F_TENTATIVE;
-		spin_unlock_bh(&ifp->lock);
-		in6_ifa_put(ifp);
-#ifdef CONFIG_IPV6_PRIVACY
-	} else if (ifp->flags&IFA_F_TEMPORARY) {
-		struct inet6_ifaddr *ifpub;
-		spin_lock_bh(&ifp->lock);
-		ifpub = ifp->ifpub;
-		if (ifpub) {
-			in6_ifa_hold(ifpub);
-			spin_unlock_bh(&ifp->lock);
-			ipv6_create_tempaddr(ifpub, ifp);
-			in6_ifa_put(ifpub);
-		} else {
-			spin_unlock_bh(&ifp->lock);
-		}
-		ipv6_del_addr(ifp);
-#endif
-	} else
-		ipv6_del_addr(ifp);
-}
-
-void addrconf_dad_failure(struct inet6_ifaddr *ifp)
-{
-	if (net_ratelimit())
-		printk(KERN_INFO "%s: duplicate address detected!\n", ifp->idev->dev->name);
-	addrconf_dad_stop(ifp);
-}
-
-/* Join to solicited addr multicast group. */
-
-void addrconf_join_solict(struct net_device *dev, struct in6_addr *addr)
-{
-	struct in6_addr maddr;
-
-	if (dev->flags&(IFF_LOOPBACK|IFF_NOARP))
-		return;
-
-	addrconf_addr_solict_mult(addr, &maddr);
-	ipv6_dev_mc_inc(dev, &maddr);
-}
-
-void addrconf_leave_solict(struct inet6_dev *idev, struct in6_addr *addr)
-{
-	struct in6_addr maddr;
-
-	if (idev->dev->flags&(IFF_LOOPBACK|IFF_NOARP))
-		return;
-
-	addrconf_addr_solict_mult(addr, &maddr);
-	__ipv6_dev_mc_dec(idev, &maddr);
-}
-
-static void addrconf_join_anycast(struct inet6_ifaddr *ifp)
-{
-	struct in6_addr addr;
-	ipv6_addr_prefix(&addr, &ifp->addr, ifp->prefix_len);
-	if (ipv6_addr_any(&addr))
-		return;
-	ipv6_dev_ac_inc(ifp->idev->dev, &addr);
-}
-
-static void addrconf_leave_anycast(struct inet6_ifaddr *ifp)
-{
-	struct in6_addr addr;
-	ipv6_addr_prefix(&addr, &ifp->addr, ifp->prefix_len);
-	if (ipv6_addr_any(&addr))
-		return;
-	__ipv6_dev_ac_dec(ifp->idev, &addr);
-}
-
-static int addrconf_ifid_eui48(u8 *eui, struct net_device *dev)
-{
-	if (dev->addr_len != ETH_ALEN)
-		return -1;
-	memcpy(eui, dev->dev_addr, 3);
-	memcpy(eui + 5, dev->dev_addr + 3, 3);
-
-	/*
-	 * The zSeries OSA network cards can be shared among various
-	 * OS instances, but the OSA cards have only one MAC address.
-	 * This leads to duplicate address conflicts in conjunction
-	 * with IPv6 if more than one instance uses the same card.
-	 *
-	 * The driver for these cards can deliver a unique 16-bit
-	 * identifier for each instance sharing the same card.  It is
-	 * placed instead of 0xFFFE in the interface identifier.  The
-	 * "u" bit of the interface identifier is not inverted in this
-	 * case.  Hence the resulting interface identifier has local
-	 * scope according to RFC2373.
-	 */
-	if (dev->dev_id) {
-		eui[3] = (dev->dev_id >> 8) & 0xFF;
-		eui[4] = dev->dev_id & 0xFF;
-	} else {
-		eui[3] = 0xFF;
-		eui[4] = 0xFE;
-		eui[0] ^= 2;
-	}
-	return 0;
-}
-
-static int addrconf_ifid_arcnet(u8 *eui, struct net_device *dev)
-{
-	/* XXX: inherit EUI-64 from other interface -- yoshfuji */
-	if (dev->addr_len != ARCNET_ALEN)
-		return -1;
-	memset(eui, 0, 7);
-	eui[7] = *(u8*)dev->dev_addr;
-	return 0;
-}
-
-static int addrconf_ifid_infiniband(u8 *eui, struct net_device *dev)
-{
-	if (dev->addr_len != INFINIBAND_ALEN)
-		return -1;
-	memcpy(eui, dev->dev_addr + 12, 8);
-	eui[0] |= 2;
-	return 0;
-}
-
-static int ipv6_generate_eui64(u8 *eui, struct net_device *dev)
-{
-	switch (dev->type) {
-	case ARPHRD_ETHER:
-	case ARPHRD_FDDI:
-	case ARPHRD_IEEE802_TR:
-		return addrconf_ifid_eui48(eui, dev);
-	case ARPHRD_ARCNET:
-		return addrconf_ifid_arcnet(eui, dev);
-	case ARPHRD_INFINIBAND:
-		return addrconf_ifid_infiniband(eui, dev);
-	}
-	return -1;
-}
-
-static int ipv6_inherit_eui64(u8 *eui, struct inet6_dev *idev)
-{
-	int err = -1;
-	struct inet6_ifaddr *ifp;
-
-	read_lock_bh(&idev->lock);
-	for (ifp=idev->addr_list; ifp; ifp=ifp->if_next) {
-		if (ifp->scope == IFA_LINK && !(ifp->flags&IFA_F_TENTATIVE)) {
-			memcpy(eui, ifp->addr.s6_addr+8, 8);
-			err = 0;
-			break;
-		}
-	}
-	read_unlock_bh(&idev->lock);
-	return err;
-}
-
-#ifdef CONFIG_IPV6_PRIVACY
-/* (re)generation of randomized interface identifier (RFC 3041 3.2, 3.5) */
-static int __ipv6_regen_rndid(struct inet6_dev *idev)
-{
-regen:
-	get_random_bytes(idev->rndid, sizeof(idev->rndid));
-	idev->rndid[0] &= ~0x02;
-
-	/*
-	 * <draft-ietf-ipngwg-temp-addresses-v2-00.txt>:
-	 * check if generated address is not inappropriate
-	 *
-	 *  - Reserved subnet anycast (RFC 2526)
-	 *	11111101 11....11 1xxxxxxx
-	 *  - ISATAP (draft-ietf-ngtrans-isatap-13.txt) 5.1
-	 *	00-00-5E-FE-xx-xx-xx-xx
-	 *  - value 0
-	 *  - XXX: already assigned to an address on the device
-	 */
-	if (idev->rndid[0] == 0xfd &&
-	    (idev->rndid[1]&idev->rndid[2]&idev->rndid[3]&idev->rndid[4]&idev->rndid[5]&idev->rndid[6]) == 0xff &&
-	    (idev->rndid[7]&0x80))
-		goto regen;
-	if ((idev->rndid[0]|idev->rndid[1]) == 0) {
-		if (idev->rndid[2] == 0x5e && idev->rndid[3] == 0xfe)
-			goto regen;
-		if ((idev->rndid[2]|idev->rndid[3]|idev->rndid[4]|idev->rndid[5]|idev->rndid[6]|idev->rndid[7]) == 0x00)
-			goto regen;
-	}
-
-	return 0;
-}
-
-static void ipv6_regen_rndid(unsigned long data)
-{
-	struct inet6_dev *idev = (struct inet6_dev *) data;
-	unsigned long expires;
-
-	rcu_read_lock_bh();
-	write_lock_bh(&idev->lock);
-
-	if (idev->dead)
-		goto out;
-
-	if (__ipv6_regen_rndid(idev) < 0)
-		goto out;
-
-	expires = jiffies +
-		idev->cnf.temp_prefered_lft * HZ -
-		idev->cnf.regen_max_retry * idev->cnf.dad_transmits * idev->nd_parms->retrans_time - desync_factor;
-	if (time_before(expires, jiffies)) {
-		printk(KERN_WARNING
-			"ipv6_regen_rndid(): too short regeneration interval; timer disabled for %s.\n",
-			idev->dev->name);
-		goto out;
-	}
-
-	if (!mod_timer(&idev->regen_timer, expires))
-		in6_dev_hold(idev);
-
-out:
-	write_unlock_bh(&idev->lock);
-	rcu_read_unlock_bh();
-	in6_dev_put(idev);
-}
-
-static int __ipv6_try_regen_rndid(struct inet6_dev *idev, struct in6_addr *tmpaddr) {
-	int ret = 0;
-
-	if (tmpaddr && memcmp(idev->rndid, &tmpaddr->s6_addr[8], 8) == 0)
-		ret = __ipv6_regen_rndid(idev);
-	return ret;
-}
-#endif
-
-/*
- *	Add prefix route.
- */
-
-static void
-addrconf_prefix_route(struct in6_addr *pfx, int plen, struct net_device *dev,
-		      unsigned long expires, u32 flags)
-{
-	struct fib6_config cfg = {
-		.fc_table = RT6_TABLE_PREFIX,
-		.fc_metric = IP6_RT_PRIO_ADDRCONF,
-		.fc_ifindex = dev->ifindex,
-		.fc_expires = expires,
-		.fc_dst_len = plen,
-		.fc_flags = RTF_UP | flags,
-	};
-
-	ipv6_addr_copy(&cfg.fc_dst, pfx);
-
-	/* Prevent useless cloning on PtP SIT.
-	   This thing is done here expecting that the whole
-	   class of non-broadcast devices need not cloning.
-	 */
-#if defined(CONFIG_IPV6_SIT) || defined(CONFIG_IPV6_SIT_MODULE)
-	if (dev->type == ARPHRD_SIT && (dev->flags & IFF_POINTOPOINT))
-		cfg.fc_flags |= RTF_NONEXTHOP;
-#endif
-
-	ip6_route_add(&cfg);
-}
-
-/* Create "default" multicast route to the interface */
-
-static void addrconf_add_mroute(struct net_device *dev)
-{
-	struct fib6_config cfg = {
-		.fc_table = RT6_TABLE_LOCAL,
-		.fc_metric = IP6_RT_PRIO_ADDRCONF,
-		.fc_ifindex = dev->ifindex,
-		.fc_dst_len = 8,
-		.fc_flags = RTF_UP,
-	};
-
-	ipv6_addr_set(&cfg.fc_dst, htonl(0xFF000000), 0, 0, 0);
-
-	ip6_route_add(&cfg);
-}
-
-#if defined(CONFIG_IPV6_SIT) || defined(CONFIG_IPV6_SIT_MODULE)
-static void sit_route_add(struct net_device *dev)
-{
-	struct fib6_config cfg = {
-		.fc_table = RT6_TABLE_MAIN,
-		.fc_metric = IP6_RT_PRIO_ADDRCONF,
-		.fc_ifindex = dev->ifindex,
-		.fc_dst_len = 96,
-		.fc_flags = RTF_UP | RTF_NONEXTHOP,
-	};
-
-	/* prefix length - 96 bits "::d.d.d.d" */
-	ip6_route_add(&cfg);
-}
-#endif
-
-static void addrconf_add_lroute(struct net_device *dev)
-{
-	struct in6_addr addr;
-
-	ipv6_addr_set(&addr,  htonl(0xFE800000), 0, 0, 0);
-	addrconf_prefix_route(&addr, 64, dev, 0, 0);
-}
-
-static struct inet6_dev *addrconf_add_dev(struct net_device *dev)
-{
-	struct inet6_dev *idev;
-
-	ASSERT_RTNL();
-
-	if ((idev = ipv6_find_idev(dev)) == NULL)
-		return NULL;
-
-	/* Add default multicast route */
-	addrconf_add_mroute(dev);
-
-	/* Add link local route */
-	addrconf_add_lroute(dev);
-	return idev;
-}
-
-void addrconf_prefix_rcv(struct net_device *dev, u8 *opt, int len)
-{
-	struct prefix_info *pinfo;
-	__u32 valid_lft;
-	__u32 prefered_lft;
-	int addr_type;
-	unsigned long rt_expires;
-	struct inet6_dev *in6_dev;
-
-	pinfo = (struct prefix_info *) opt;
-
-	if (len < sizeof(struct prefix_info)) {
-		ADBG(("addrconf: prefix option too short\n"));
-		return;
-	}
-
-	/*
-	 *	Validation checks ([ADDRCONF], page 19)
-	 */
-
-	addr_type = ipv6_addr_type(&pinfo->prefix);
-
-	if (addr_type & (IPV6_ADDR_MULTICAST|IPV6_ADDR_LINKLOCAL))
-		return;
-
-	valid_lft = ntohl(pinfo->valid);
-	prefered_lft = ntohl(pinfo->prefered);
-
-	if (prefered_lft > valid_lft) {
-		if (net_ratelimit())
-			printk(KERN_WARNING "addrconf: prefix option has invalid lifetime\n");
-		return;
-	}
-
-	in6_dev = in6_dev_get(dev);
-
-	if (in6_dev == NULL) {
-		if (net_ratelimit())
-			printk(KERN_DEBUG "addrconf: device %s not configured\n", dev->name);
-		return;
-	}
-
-	/*
-	 *	Two things going on here:
-	 *	1) Add routes for on-link prefixes
-	 *	2) Configure prefixes with the auto flag set
-	 */
-
-	/* Avoid arithmetic overflow. Really, we could
-	   save rt_expires in seconds, likely valid_lft,
-	   but it would require division in fib gc, that it
-	   not good.
-	 */
-	if (valid_lft >= 0x7FFFFFFF/HZ)
-		rt_expires = 0x7FFFFFFF - (0x7FFFFFFF % HZ);
-	else
-		rt_expires = valid_lft * HZ;
-
-	/*
-	 * We convert this (in jiffies) to clock_t later.
-	 * Avoid arithmetic overflow there as well.
-	 * Overflow can happen only if HZ < USER_HZ.
-	 */
-	if (HZ < USER_HZ && rt_expires > 0x7FFFFFFF / USER_HZ)
-		rt_expires = 0x7FFFFFFF / USER_HZ;
-
-	if (pinfo->onlink) {
-		struct rt6_info *rt;
-		rt = rt6_lookup(&pinfo->prefix, NULL, dev->ifindex, 1);
-
-		if (rt && ((rt->rt6i_flags & (RTF_GATEWAY | RTF_DEFAULT)) == 0)) {
-			if (rt->rt6i_flags&RTF_EXPIRES) {
-				if (valid_lft == 0) {
-					ip6_del_rt(rt);
-					rt = NULL;
-				} else {
-					rt->rt6i_expires = jiffies + rt_expires;
-				}
-			}
-		} else if (valid_lft) {
-			addrconf_prefix_route(&pinfo->prefix, pinfo->prefix_len,
-					      dev, jiffies_to_clock_t(rt_expires), RTF_ADDRCONF|RTF_EXPIRES|RTF_PREFIX_RT);
-		}
-		if (rt)
-			dst_release(&rt->u.dst);
-	}
-
-	/* Try to figure out our local address for this prefix */
-
-	if (pinfo->autoconf && in6_dev->cnf.autoconf) {
-		struct inet6_ifaddr * ifp;
-		struct in6_addr addr;
-		int create = 0, update_lft = 0;
-
-		if (pinfo->prefix_len == 64) {
-			memcpy(&addr, &pinfo->prefix, 8);
-			if (ipv6_generate_eui64(addr.s6_addr + 8, dev) &&
-			    ipv6_inherit_eui64(addr.s6_addr + 8, in6_dev)) {
-				in6_dev_put(in6_dev);
-				return;
-			}
-			goto ok;
-		}
-		if (net_ratelimit())
-			printk(KERN_DEBUG "IPv6 addrconf: prefix with wrong length %d\n",
-			       pinfo->prefix_len);
-		in6_dev_put(in6_dev);
-		return;
-
-ok:
-
-		ifp = ipv6_get_ifaddr(&addr, dev, 1);
-
-		if (ifp == NULL && valid_lft) {
-			int max_addresses = in6_dev->cnf.max_addresses;
-			u32 addr_flags = 0;
-
-#ifdef CONFIG_IPV6_OPTIMISTIC_DAD
-			if (in6_dev->cnf.optimistic_dad &&
-			    !ipv6_devconf.forwarding)
-				addr_flags = IFA_F_OPTIMISTIC;
-#endif
-
-			/* Do not allow to create too much of autoconfigured
-			 * addresses; this would be too easy way to crash kernel.
-			 */
-			if (!max_addresses ||
-			    ipv6_count_addresses(in6_dev) < max_addresses)
-				ifp = ipv6_add_addr(in6_dev, &addr, pinfo->prefix_len,
-						    addr_type&IPV6_ADDR_SCOPE_MASK,
-						    addr_flags);
-
-			if (!ifp || IS_ERR(ifp)) {
-				in6_dev_put(in6_dev);
-				return;
-			}
-
-			update_lft = create = 1;
-			ifp->cstamp = jiffies;
-			addrconf_dad_start(ifp, RTF_ADDRCONF|RTF_PREFIX_RT);
-		}
-
-		if (ifp) {
-			int flags;
-			unsigned long now;
-#ifdef CONFIG_IPV6_PRIVACY
-			struct inet6_ifaddr *ift;
-#endif
-			u32 stored_lft;
-
-			/* update lifetime (RFC2462 5.5.3 e) */
-			spin_lock(&ifp->lock);
-			now = jiffies;
-			if (ifp->valid_lft > (now - ifp->tstamp) / HZ)
-				stored_lft = ifp->valid_lft - (now - ifp->tstamp) / HZ;
-			else
-				stored_lft = 0;
-			if (!update_lft && stored_lft) {
-				if (valid_lft > MIN_VALID_LIFETIME ||
-				    valid_lft > stored_lft)
-					update_lft = 1;
-				else if (stored_lft <= MIN_VALID_LIFETIME) {
-					/* valid_lft <= stored_lft is always true */
-					/* XXX: IPsec */
-					update_lft = 0;
-				} else {
-					valid_lft = MIN_VALID_LIFETIME;
-					if (valid_lft < prefered_lft)
-						prefered_lft = valid_lft;
-					update_lft = 1;
-				}
-			}
-
-			if (update_lft) {
-				ifp->valid_lft = valid_lft;
-				ifp->prefered_lft = prefered_lft;
-				ifp->tstamp = now;
-				flags = ifp->flags;
-				ifp->flags &= ~IFA_F_DEPRECATED;
-				spin_unlock(&ifp->lock);
-
-				if (!(flags&IFA_F_TENTATIVE))
-					ipv6_ifa_notify(0, ifp);
-			} else
-				spin_unlock(&ifp->lock);
-
-#ifdef CONFIG_IPV6_PRIVACY
-			read_lock_bh(&in6_dev->lock);
-			/* update all temporary addresses in the list */
-			for (ift=in6_dev->tempaddr_list; ift; ift=ift->tmp_next) {
-				/*
-				 * When adjusting the lifetimes of an existing
-				 * temporary address, only lower the lifetimes.
-				 * Implementations must not increase the
-				 * lifetimes of an existing temporary address
-				 * when processing a Prefix Information Option.
-				 */
-				spin_lock(&ift->lock);
-				flags = ift->flags;
-				if (ift->valid_lft > valid_lft &&
-				    ift->valid_lft - valid_lft > (jiffies - ift->tstamp) / HZ)
-					ift->valid_lft = valid_lft + (jiffies - ift->tstamp) / HZ;
-				if (ift->prefered_lft > prefered_lft &&
-				    ift->prefered_lft - prefered_lft > (jiffies - ift->tstamp) / HZ)
-					ift->prefered_lft = prefered_lft + (jiffies - ift->tstamp) / HZ;
-				spin_unlock(&ift->lock);
-				if (!(flags&IFA_F_TENTATIVE))
-					ipv6_ifa_notify(0, ift);
-			}
-
-			if (create && in6_dev->cnf.use_tempaddr > 0) {
-				/*
-				 * When a new public address is created as described in [ADDRCONF],
-				 * also create a new temporary address.
-				 */
-				read_unlock_bh(&in6_dev->lock);
-				ipv6_create_tempaddr(ifp, NULL);
-			} else {
-				read_unlock_bh(&in6_dev->lock);
-			}
-#endif
-			in6_ifa_put(ifp);
-			addrconf_verify(0);
-		}
-	}
-	inet6_prefix_notify(RTM_NEWPREFIX, in6_dev, pinfo);
-	in6_dev_put(in6_dev);
-}
-
-/*
- *	Set destination address.
- *	Special case for SIT interfaces where we create a new "virtual"
- *	device.
- */
-int addrconf_set_dstaddr(void __user *arg)
-{
-	struct in6_ifreq ireq;
-	struct net_device *dev;
-	int err = -EINVAL;
-
-	rtnl_lock();
-
-	err = -EFAULT;
-	if (copy_from_user(&ireq, arg, sizeof(struct in6_ifreq)))
-		goto err_exit;
-
-	dev = __dev_get_by_index(ireq.ifr6_ifindex);
-
-	err = -ENODEV;
-	if (dev == NULL)
-		goto err_exit;
-
-#if defined(CONFIG_IPV6_SIT) || defined(CONFIG_IPV6_SIT_MODULE)
-	if (dev->type == ARPHRD_SIT) {
-		struct ifreq ifr;
-		mm_segment_t	oldfs;
-		struct ip_tunnel_parm p;
-
-		err = -EADDRNOTAVAIL;
-		if (!(ipv6_addr_type(&ireq.ifr6_addr) & IPV6_ADDR_COMPATv4))
-			goto err_exit;
-
-		memset(&p, 0, sizeof(p));
-		p.iph.daddr = ireq.ifr6_addr.s6_addr32[3];
-		p.iph.saddr = 0;
-		p.iph.version = 4;
-		p.iph.ihl = 5;
-		p.iph.protocol = IPPROTO_IPV6;
-		p.iph.ttl = 64;
-		ifr.ifr_ifru.ifru_data = (void __user *)&p;
-
-		oldfs = get_fs(); set_fs(KERNEL_DS);
-		err = dev->do_ioctl(dev, &ifr, SIOCADDTUNNEL);
-		set_fs(oldfs);
-
-		if (err == 0) {
-			err = -ENOBUFS;
-			if ((dev = __dev_get_by_name(p.name)) == NULL)
-				goto err_exit;
-			err = dev_open(dev);
-		}
-	}
-#endif
-
-err_exit:
-	rtnl_unlock();
-	return err;
-}
-
-/*
- *	Manual configuration of address on an interface
- */
-static int inet6_addr_add(int ifindex, struct in6_addr *pfx, int plen,
-			  __u8 ifa_flags, __u32 prefered_lft, __u32 valid_lft)
-{
-	struct inet6_ifaddr *ifp;
-	struct inet6_dev *idev;
-	struct net_device *dev;
-	int scope;
-	u32 flags = RTF_EXPIRES;
-
-	ASSERT_RTNL();
-
-	/* check the lifetime */
-	if (!valid_lft || prefered_lft > valid_lft)
-		return -EINVAL;
-
-	if ((dev = __dev_get_by_index(ifindex)) == NULL)
-		return -ENODEV;
-
-	if ((idev = addrconf_add_dev(dev)) == NULL)
-		return -ENOBUFS;
-
-	scope = ipv6_addr_scope(pfx);
-
-	if (valid_lft == INFINITY_LIFE_TIME) {
-		ifa_flags |= IFA_F_PERMANENT;
-		flags = 0;
-	} else if (valid_lft >= 0x7FFFFFFF/HZ)
-		valid_lft = 0x7FFFFFFF/HZ;
-
-	if (prefered_lft == 0)
-		ifa_flags |= IFA_F_DEPRECATED;
-	else if ((prefered_lft >= 0x7FFFFFFF/HZ) &&
-		 (prefered_lft != INFINITY_LIFE_TIME))
-		prefered_lft = 0x7FFFFFFF/HZ;
-
-	ifp = ipv6_add_addr(idev, pfx, plen, scope, ifa_flags);
-
-	if (!IS_ERR(ifp)) {
-		spin_lock_bh(&ifp->lock);
-		ifp->valid_lft = valid_lft;
-		ifp->prefered_lft = prefered_lft;
-		ifp->tstamp = jiffies;
-		spin_unlock_bh(&ifp->lock);
-
-		addrconf_prefix_route(&ifp->addr, ifp->prefix_len, dev,
-				      jiffies_to_clock_t(valid_lft * HZ), flags);
-		/*
-		 * Note that section 3.1 of RFC 4429 indicates
-		 * that the Optimistic flag should not be set for
-		 * manually configured addresses
-		 */
-		addrconf_dad_start(ifp, 0);
-		in6_ifa_put(ifp);
-		addrconf_verify(0);
-		return 0;
-	}
-
-	return PTR_ERR(ifp);
-}
-
-static int inet6_addr_del(int ifindex, struct in6_addr *pfx, int plen)
-{
-	struct inet6_ifaddr *ifp;
-	struct inet6_dev *idev;
-	struct net_device *dev;
-
-	if ((dev = __dev_get_by_index(ifindex)) == NULL)
-		return -ENODEV;
-
-	if ((idev = __in6_dev_get(dev)) == NULL)
-		return -ENXIO;
-
-	read_lock_bh(&idev->lock);
-	for (ifp = idev->addr_list; ifp; ifp=ifp->if_next) {
-		if (ifp->prefix_len == plen &&
-		    ipv6_addr_equal(pfx, &ifp->addr)) {
-			in6_ifa_hold(ifp);
-			read_unlock_bh(&idev->lock);
-
-			ipv6_del_addr(ifp);
-
-			/* If the last address is deleted administratively,
-			   disable IPv6 on this interface.
-			 */
-			if (idev->addr_list == NULL)
-				addrconf_ifdown(idev->dev, 1);
-			return 0;
-		}
-	}
-	read_unlock_bh(&idev->lock);
-	return -EADDRNOTAVAIL;
-}
-
-
-int addrconf_add_ifaddr(void __user *arg)
-{
-	struct in6_ifreq ireq;
-	int err;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	if (copy_from_user(&ireq, arg, sizeof(struct in6_ifreq)))
-		return -EFAULT;
-
-	rtnl_lock();
-	err = inet6_addr_add(ireq.ifr6_ifindex, &ireq.ifr6_addr, ireq.ifr6_prefixlen,
-			     IFA_F_PERMANENT, INFINITY_LIFE_TIME, INFINITY_LIFE_TIME);
-	rtnl_unlock();
-	return err;
-}
-
-int addrconf_del_ifaddr(void __user *arg)
-{
-	struct in6_ifreq ireq;
-	int err;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	if (copy_from_user(&ireq, arg, sizeof(struct in6_ifreq)))
-		return -EFAULT;
-
-	rtnl_lock();
-	err = inet6_addr_del(ireq.ifr6_ifindex, &ireq.ifr6_addr, ireq.ifr6_prefixlen);
-	rtnl_unlock();
-	return err;
-}
-
-#if defined(CONFIG_IPV6_SIT) || defined(CONFIG_IPV6_SIT_MODULE)
-static void sit_add_v4_addrs(struct inet6_dev *idev)
-{
-	struct inet6_ifaddr * ifp;
-	struct in6_addr addr;
-	struct net_device *dev;
-	int scope;
-
-	ASSERT_RTNL();
-
-	memset(&addr, 0, sizeof(struct in6_addr));
-	memcpy(&addr.s6_addr32[3], idev->dev->dev_addr, 4);
-
-	if (idev->dev->flags&IFF_POINTOPOINT) {
-		addr.s6_addr32[0] = htonl(0xfe800000);
-		scope = IFA_LINK;
-	} else {
-		scope = IPV6_ADDR_COMPATv4;
-	}
-
-	if (addr.s6_addr32[3]) {
-		ifp = ipv6_add_addr(idev, &addr, 128, scope, IFA_F_PERMANENT);
-		if (!IS_ERR(ifp)) {
-			spin_lock_bh(&ifp->lock);
-			ifp->flags &= ~IFA_F_TENTATIVE;
-			spin_unlock_bh(&ifp->lock);
-			ipv6_ifa_notify(RTM_NEWADDR, ifp);
-			in6_ifa_put(ifp);
-		}
-		return;
-	}
-
-	for_each_netdev(dev) {
-		struct in_device * in_dev = __in_dev_get_rtnl(dev);
-		if (in_dev && (dev->flags & IFF_UP)) {
-			struct in_ifaddr * ifa;
-
-			int flag = scope;
-
-			for (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {
-				int plen;
-
-				addr.s6_addr32[3] = ifa->ifa_local;
-
-				if (ifa->ifa_scope == RT_SCOPE_LINK)
-					continue;
-				if (ifa->ifa_scope >= RT_SCOPE_HOST) {
-					if (idev->dev->flags&IFF_POINTOPOINT)
-						continue;
-					flag |= IFA_HOST;
-				}
-				if (idev->dev->flags&IFF_POINTOPOINT)
-					plen = 64;
-				else
-					plen = 96;
-
-				ifp = ipv6_add_addr(idev, &addr, plen, flag,
-						    IFA_F_PERMANENT);
-				if (!IS_ERR(ifp)) {
-					spin_lock_bh(&ifp->lock);
-					ifp->flags &= ~IFA_F_TENTATIVE;
-					spin_unlock_bh(&ifp->lock);
-					ipv6_ifa_notify(RTM_NEWADDR, ifp);
-					in6_ifa_put(ifp);
-				}
-			}
-		}
-	}
-}
-#endif
-
-static void init_loopback(struct net_device *dev)
-{
-	struct inet6_dev  *idev;
-	struct inet6_ifaddr * ifp;
-
-	/* ::1 */
-
-	ASSERT_RTNL();
-
-	if ((idev = ipv6_find_idev(dev)) == NULL) {
-		printk(KERN_DEBUG "init loopback: add_dev failed\n");
-		return;
-	}
-
-	ifp = ipv6_add_addr(idev, &in6addr_loopback, 128, IFA_HOST, IFA_F_PERMANENT);
-	if (!IS_ERR(ifp)) {
-		spin_lock_bh(&ifp->lock);
-		ifp->flags &= ~IFA_F_TENTATIVE;
-		spin_unlock_bh(&ifp->lock);
-		ipv6_ifa_notify(RTM_NEWADDR, ifp);
-		in6_ifa_put(ifp);
-	}
-}
-
-static void addrconf_add_linklocal(struct inet6_dev *idev, struct in6_addr *addr)
-{
-	struct inet6_ifaddr * ifp;
-	u32 addr_flags = IFA_F_PERMANENT;
-
-#ifdef CONFIG_IPV6_OPTIMISTIC_DAD
-	if (idev->cnf.optimistic_dad &&
-	    !ipv6_devconf.forwarding)
-		addr_flags |= IFA_F_OPTIMISTIC;
-#endif
-
-
-	ifp = ipv6_add_addr(idev, addr, 64, IFA_LINK, addr_flags);
-	if (!IS_ERR(ifp)) {
-		addrconf_prefix_route(&ifp->addr, ifp->prefix_len, idev->dev, 0, 0);
-		addrconf_dad_start(ifp, 0);
-		in6_ifa_put(ifp);
-	}
-}
-
-static void addrconf_dev_config(struct net_device *dev)
-{
-	struct in6_addr addr;
-	struct inet6_dev    * idev;
-
-	ASSERT_RTNL();
-
-	if ((dev->type != ARPHRD_ETHER) &&
-	    (dev->type != ARPHRD_FDDI) &&
-	    (dev->type != ARPHRD_IEEE802_TR) &&
-	    (dev->type != ARPHRD_ARCNET) &&
-	    (dev->type != ARPHRD_INFINIBAND)) {
-		/* Alas, we support only Ethernet autoconfiguration. */
-		return;
-	}
-
-	idev = addrconf_add_dev(dev);
-	if (idev == NULL)
-		return;
-
-	memset(&addr, 0, sizeof(struct in6_addr));
-	addr.s6_addr32[0] = htonl(0xFE800000);
-
-	if (ipv6_generate_eui64(addr.s6_addr + 8, dev) == 0)
-		addrconf_add_linklocal(idev, &addr);
-}
-
-#if defined(CONFIG_IPV6_SIT) || defined(CONFIG_IPV6_SIT_MODULE)
-static void addrconf_sit_config(struct net_device *dev)
-{
-	struct inet6_dev *idev;
-
-	ASSERT_RTNL();
-
-	/*
-	 * Configure the tunnel with one of our IPv4
-	 * addresses... we should configure all of
-	 * our v4 addrs in the tunnel
-	 */
-
-	if ((idev = ipv6_find_idev(dev)) == NULL) {
-		printk(KERN_DEBUG "init sit: add_dev failed\n");
-		return;
-	}
-
-	sit_add_v4_addrs(idev);
-
-	if (dev->flags&IFF_POINTOPOINT) {
-		addrconf_add_mroute(dev);
-		addrconf_add_lroute(dev);
-	} else
-		sit_route_add(dev);
-}
-#endif
-
-static inline int
-ipv6_inherit_linklocal(struct inet6_dev *idev, struct net_device *link_dev)
-{
-	struct in6_addr lladdr;
-
-	if (!ipv6_get_lladdr(link_dev, &lladdr, IFA_F_TENTATIVE)) {
-		addrconf_add_linklocal(idev, &lladdr);
-		return 0;
-	}
-	return -1;
-}
-
-static void ip6_tnl_add_linklocal(struct inet6_dev *idev)
-{
-	struct net_device *link_dev;
-
-	/* first try to inherit the link-local address from the link device */
-	if (idev->dev->iflink &&
-	    (link_dev = __dev_get_by_index(idev->dev->iflink))) {
-		if (!ipv6_inherit_linklocal(idev, link_dev))
-			return;
-	}
-	/* then try to inherit it from any device */
-	for_each_netdev(link_dev) {
-		if (!ipv6_inherit_linklocal(idev, link_dev))
-			return;
-	}
-	printk(KERN_DEBUG "init ip6-ip6: add_linklocal failed\n");
-}
-
-/*
- * Autoconfigure tunnel with a link-local address so routing protocols,
- * DHCPv6, MLD etc. can be run over the virtual link
- */
-
-static void addrconf_ip6_tnl_config(struct net_device *dev)
-{
-	struct inet6_dev *idev;
-
-	ASSERT_RTNL();
-
-	if ((idev = addrconf_add_dev(dev)) == NULL) {
-		printk(KERN_DEBUG "init ip6-ip6: add_dev failed\n");
-		return;
-	}
-	ip6_tnl_add_linklocal(idev);
-}
-
-static int addrconf_notify(struct notifier_block *this, unsigned long event,
-			   void * data)
-{
-	struct net_device *dev = (struct net_device *) data;
-	struct inet6_dev *idev = __in6_dev_get(dev);
-	int run_pending = 0;
-
-	switch(event) {
-	case NETDEV_REGISTER:
-		if (!idev && dev->mtu >= IPV6_MIN_MTU) {
-			idev = ipv6_add_dev(dev);
-			if (!idev)
-				printk(KERN_WARNING "IPv6: add_dev failed for %s\n",
-					dev->name);
-		}
-		break;
-	case NETDEV_UP:
-	case NETDEV_CHANGE:
-		if (event == NETDEV_UP) {
-			if (!addrconf_qdisc_ok(dev)) {
-				/* device is not ready yet. */
-				printk(KERN_INFO
-					"ADDRCONF(NETDEV_UP): %s: "
-					"link is not ready\n",
-					dev->name);
-				break;
-			}
-
-			if (idev)
-				idev->if_flags |= IF_READY;
-		} else {
-			if (!addrconf_qdisc_ok(dev)) {
-				/* device is still not ready. */
-				break;
-			}
-
-			if (idev) {
-				if (idev->if_flags & IF_READY) {
-					/* device is already configured. */
-					break;
-				}
-				idev->if_flags |= IF_READY;
-			}
-
-			printk(KERN_INFO
-					"ADDRCONF(NETDEV_CHANGE): %s: "
-					"link becomes ready\n",
-					dev->name);
-
-			run_pending = 1;
-		}
-
-		switch(dev->type) {
-#if defined(CONFIG_IPV6_SIT) || defined(CONFIG_IPV6_SIT_MODULE)
-		case ARPHRD_SIT:
-			addrconf_sit_config(dev);
-			break;
-#endif
-		case ARPHRD_TUNNEL6:
-			addrconf_ip6_tnl_config(dev);
-			break;
-		case ARPHRD_LOOPBACK:
-			init_loopback(dev);
-			break;
-
-		default:
-			addrconf_dev_config(dev);
-			break;
-		}
-		if (idev) {
-			if (run_pending)
-				addrconf_dad_run(idev);
-
-			/* If the MTU changed during the interface down, when the
-			   interface up, the changed MTU must be reflected in the
-			   idev as well as routers.
-			 */
-			if (idev->cnf.mtu6 != dev->mtu && dev->mtu >= IPV6_MIN_MTU) {
-				rt6_mtu_change(dev, dev->mtu);
-				idev->cnf.mtu6 = dev->mtu;
-			}
-			idev->tstamp = jiffies;
-			inet6_ifinfo_notify(RTM_NEWLINK, idev);
-			/* If the changed mtu during down is lower than IPV6_MIN_MTU
-			   stop IPv6 on this interface.
-			 */
-			if (dev->mtu < IPV6_MIN_MTU)
-				addrconf_ifdown(dev, event != NETDEV_DOWN);
-		}
-		break;
-
-	case NETDEV_CHANGEMTU:
-		if ( idev && dev->mtu >= IPV6_MIN_MTU) {
-			rt6_mtu_change(dev, dev->mtu);
-			idev->cnf.mtu6 = dev->mtu;
-			break;
-		}
-
-		/* MTU falled under IPV6_MIN_MTU. Stop IPv6 on this interface. */
-
-	case NETDEV_DOWN:
-	case NETDEV_UNREGISTER:
-		/*
-		 *	Remove all addresses from this interface.
-		 */
-		addrconf_ifdown(dev, event != NETDEV_DOWN);
-		break;
-
-	case NETDEV_CHANGENAME:
-		if (idev) {
-			snmp6_unregister_dev(idev);
-#ifdef CONFIG_SYSCTL
-			addrconf_sysctl_unregister(&idev->cnf);
-			neigh_sysctl_unregister(idev->nd_parms);
-			neigh_sysctl_register(dev, idev->nd_parms,
-					      NET_IPV6, NET_IPV6_NEIGH, "ipv6",
-					      &ndisc_ifinfo_sysctl_change,
-					      NULL);
-			addrconf_sysctl_register(idev, &idev->cnf);
-#endif
-			snmp6_register_dev(idev);
-		}
-		break;
-	}
-
-	return NOTIFY_OK;
-}
-
-/*
- *	addrconf module should be notified of a device going up
- */
-static struct notifier_block ipv6_dev_notf = {
-	.notifier_call = addrconf_notify,
-	.priority = 0
-};
-
-static int addrconf_ifdown(struct net_device *dev, int how)
-{
-	struct inet6_dev *idev;
-	struct inet6_ifaddr *ifa, **bifa;
-	int i;
-
-	ASSERT_RTNL();
-
-	if (dev == &loopback_dev && how == 1)
-		how = 0;
-
-	rt6_ifdown(dev);
-	neigh_ifdown(&nd_tbl, dev);
-
-	idev = __in6_dev_get(dev);
-	if (idev == NULL)
-		return -ENODEV;
-
-	/* Step 1: remove reference to ipv6 device from parent device.
-		   Do not dev_put!
-	 */
-	if (how == 1) {
-		idev->dead = 1;
-
-		/* protected by rtnl_lock */
-		rcu_assign_pointer(dev->ip6_ptr, NULL);
-
-		/* Step 1.5: remove snmp6 entry */
-		snmp6_unregister_dev(idev);
-
-	}
-
-	/* Step 2: clear hash table */
-	for (i=0; i<IN6_ADDR_HSIZE; i++) {
-		bifa = &inet6_addr_lst[i];
-
-		write_lock_bh(&addrconf_hash_lock);
-		while ((ifa = *bifa) != NULL) {
-			if (ifa->idev == idev) {
-				*bifa = ifa->lst_next;
-				ifa->lst_next = NULL;
-				addrconf_del_timer(ifa);
-				in6_ifa_put(ifa);
-				continue;
-			}
-			bifa = &ifa->lst_next;
-		}
-		write_unlock_bh(&addrconf_hash_lock);
-	}
-
-	write_lock_bh(&idev->lock);
-
-	/* Step 3: clear flags for stateless addrconf */
-	if (how != 1)
-		idev->if_flags &= ~(IF_RS_SENT|IF_RA_RCVD|IF_READY);
-
-	/* Step 4: clear address list */
-#ifdef CONFIG_IPV6_PRIVACY
-	if (how == 1 && del_timer(&idev->regen_timer))
-		in6_dev_put(idev);
-
-	/* clear tempaddr list */
-	while ((ifa = idev->tempaddr_list) != NULL) {
-		idev->tempaddr_list = ifa->tmp_next;
-		ifa->tmp_next = NULL;
-		ifa->dead = 1;
-		write_unlock_bh(&idev->lock);
-		spin_lock_bh(&ifa->lock);
-
-		if (ifa->ifpub) {
-			in6_ifa_put(ifa->ifpub);
-			ifa->ifpub = NULL;
-		}
-		spin_unlock_bh(&ifa->lock);
-		in6_ifa_put(ifa);
-		write_lock_bh(&idev->lock);
-	}
-#endif
-	while ((ifa = idev->addr_list) != NULL) {
-		idev->addr_list = ifa->if_next;
-		ifa->if_next = NULL;
-		ifa->dead = 1;
-		addrconf_del_timer(ifa);
-		write_unlock_bh(&idev->lock);
-
-		__ipv6_ifa_notify(RTM_DELADDR, ifa);
-		atomic_notifier_call_chain(&inet6addr_chain, NETDEV_DOWN, ifa);
-		in6_ifa_put(ifa);
-
-		write_lock_bh(&idev->lock);
-	}
-	write_unlock_bh(&idev->lock);
-
-	/* Step 5: Discard multicast list */
-
-	if (how == 1)
-		ipv6_mc_destroy_dev(idev);
-	else
-		ipv6_mc_down(idev);
-
-	/* Step 5: netlink notification of this interface */
-	idev->tstamp = jiffies;
-	inet6_ifinfo_notify(RTM_DELLINK, idev);
-
-	/* Shot the device (if unregistered) */
-
-	if (how == 1) {
-#ifdef CONFIG_SYSCTL
-		addrconf_sysctl_unregister(&idev->cnf);
-		neigh_sysctl_unregister(idev->nd_parms);
-#endif
-		neigh_parms_release(&nd_tbl, idev->nd_parms);
-		neigh_ifdown(&nd_tbl, dev);
-		in6_dev_put(idev);
-	}
-	return 0;
-}
-
-static void addrconf_rs_timer(unsigned long data)
-{
-	struct inet6_ifaddr *ifp = (struct inet6_ifaddr *) data;
-
-	if (ifp->idev->cnf.forwarding)
-		goto out;
-
-	if (ifp->idev->if_flags & IF_RA_RCVD) {
-		/*
-		 *	Announcement received after solicitation
-		 *	was sent
-		 */
-		goto out;
-	}
-
-	spin_lock(&ifp->lock);
-	if (ifp->probes++ < ifp->idev->cnf.rtr_solicits) {
-		struct in6_addr all_routers;
-
-		/* The wait after the last probe can be shorter */
-		addrconf_mod_timer(ifp, AC_RS,
-				   (ifp->probes == ifp->idev->cnf.rtr_solicits) ?
-				   ifp->idev->cnf.rtr_solicit_delay :
-				   ifp->idev->cnf.rtr_solicit_interval);
-		spin_unlock(&ifp->lock);
-
-		ipv6_addr_all_routers(&all_routers);
-
-		ndisc_send_rs(ifp->idev->dev, &ifp->addr, &all_routers);
-	} else {
-		spin_unlock(&ifp->lock);
-		/*
-		 * Note: we do not support deprecated "all on-link"
-		 * assumption any longer.
-		 */
-		printk(KERN_DEBUG "%s: no IPv6 routers present\n",
-		       ifp->idev->dev->name);
-	}
-
-out:
-	in6_ifa_put(ifp);
-}
-
-/*
- *	Duplicate Address Detection
- */
-static void addrconf_dad_kick(struct inet6_ifaddr *ifp)
-{
-	unsigned long rand_num;
-	struct inet6_dev *idev = ifp->idev;
-
-	if (ifp->flags & IFA_F_OPTIMISTIC)
-		rand_num = 0;
-	else
-		rand_num = net_random() % (idev->cnf.rtr_solicit_delay ? : 1);
-
-	ifp->probes = idev->cnf.dad_transmits;
-	addrconf_mod_timer(ifp, AC_DAD, rand_num);
-}
-
-static void addrconf_dad_start(struct inet6_ifaddr *ifp, u32 flags)
-{
-	struct inet6_dev *idev = ifp->idev;
-	struct net_device *dev = idev->dev;
-
-	addrconf_join_solict(dev, &ifp->addr);
-
-	net_srandom(ifp->addr.s6_addr32[3]);
-
-	read_lock_bh(&idev->lock);
-	if (ifp->dead)
-		goto out;
-	spin_lock_bh(&ifp->lock);
-
-	if (dev->flags&(IFF_NOARP|IFF_LOOPBACK) ||
-	    !(ifp->flags&IFA_F_TENTATIVE) ||
-	    ifp->flags & IFA_F_NODAD) {
-		ifp->flags &= ~(IFA_F_TENTATIVE|IFA_F_OPTIMISTIC);
-		spin_unlock_bh(&ifp->lock);
-		read_unlock_bh(&idev->lock);
-
-		addrconf_dad_completed(ifp);
-		return;
-	}
-
-	if (!(idev->if_flags & IF_READY)) {
-		spin_unlock_bh(&ifp->lock);
-		read_unlock_bh(&idev->lock);
-		/*
-		 * If the defice is not ready:
-		 * - keep it tentative if it is a permanent address.
-		 * - otherwise, kill it.
-		 */
-		in6_ifa_hold(ifp);
-		addrconf_dad_stop(ifp);
-		return;
-	}
-
-	/*
-	 * Optimistic nodes can start receiving
-	 * Frames right away
-	 */
-	if(ifp->flags & IFA_F_OPTIMISTIC)
-		ip6_ins_rt(ifp->rt);
-
-	addrconf_dad_kick(ifp);
-	spin_unlock_bh(&ifp->lock);
-out:
-	read_unlock_bh(&idev->lock);
-}
-
-static void addrconf_dad_timer(unsigned long data)
-{
-	struct inet6_ifaddr *ifp = (struct inet6_ifaddr *) data;
-	struct inet6_dev *idev = ifp->idev;
-	struct in6_addr unspec;
-	struct in6_addr mcaddr;
-
-	read_lock_bh(&idev->lock);
-	if (idev->dead) {
-		read_unlock_bh(&idev->lock);
-		goto out;
-	}
-	spin_lock_bh(&ifp->lock);
-	if (ifp->probes == 0) {
-		/*
-		 * DAD was successful
-		 */
-
-		ifp->flags &= ~(IFA_F_TENTATIVE|IFA_F_OPTIMISTIC);
-		spin_unlock_bh(&ifp->lock);
-		read_unlock_bh(&idev->lock);
-
-		addrconf_dad_completed(ifp);
-
-		goto out;
-	}
-
-	ifp->probes--;
-	addrconf_mod_timer(ifp, AC_DAD, ifp->idev->nd_parms->retrans_time);
-	spin_unlock_bh(&ifp->lock);
-	read_unlock_bh(&idev->lock);
-
-	/* send a neighbour solicitation for our addr */
-	memset(&unspec, 0, sizeof(unspec));
-	addrconf_addr_solict_mult(&ifp->addr, &mcaddr);
-	ndisc_send_ns(ifp->idev->dev, NULL, &ifp->addr, &mcaddr, &unspec);
-out:
-	in6_ifa_put(ifp);
-}
-
-static void addrconf_dad_completed(struct inet6_ifaddr *ifp)
-{
-	struct net_device *	dev = ifp->idev->dev;
-
-	/*
-	 *	Configure the address for reception. Now it is valid.
-	 */
-
-	ipv6_ifa_notify(RTM_NEWADDR, ifp);
-
-	/* If added prefix is link local and forwarding is off,
-	   start sending router solicitations.
-	 */
-
-	if (ifp->idev->cnf.forwarding == 0 &&
-	    ifp->idev->cnf.rtr_solicits > 0 &&
-	    (dev->flags&IFF_LOOPBACK) == 0 &&
-	    (ipv6_addr_type(&ifp->addr) & IPV6_ADDR_LINKLOCAL)) {
-		struct in6_addr all_routers;
-
-		ipv6_addr_all_routers(&all_routers);
-
-		/*
-		 *	If a host as already performed a random delay
-		 *	[...] as part of DAD [...] there is no need
-		 *	to delay again before sending the first RS
-		 */
-		ndisc_send_rs(ifp->idev->dev, &ifp->addr, &all_routers);
-
-		spin_lock_bh(&ifp->lock);
-		ifp->probes = 1;
-		ifp->idev->if_flags |= IF_RS_SENT;
-		addrconf_mod_timer(ifp, AC_RS, ifp->idev->cnf.rtr_solicit_interval);
-		spin_unlock_bh(&ifp->lock);
-	}
-}
-
-static void addrconf_dad_run(struct inet6_dev *idev) {
-	struct inet6_ifaddr *ifp;
-
-	read_lock_bh(&idev->lock);
-	for (ifp = idev->addr_list; ifp; ifp = ifp->if_next) {
-		spin_lock_bh(&ifp->lock);
-		if (!(ifp->flags & IFA_F_TENTATIVE)) {
-			spin_unlock_bh(&ifp->lock);
-			continue;
-		}
-		spin_unlock_bh(&ifp->lock);
-		addrconf_dad_kick(ifp);
-	}
-	read_unlock_bh(&idev->lock);
-}
-
-#ifdef CONFIG_PROC_FS
-struct if6_iter_state {
-	int bucket;
-};
-
-static struct inet6_ifaddr *if6_get_first(struct seq_file *seq)
-{
-	struct inet6_ifaddr *ifa = NULL;
-	struct if6_iter_state *state = seq->private;
-
-	for (state->bucket = 0; state->bucket < IN6_ADDR_HSIZE; ++state->bucket) {
-		ifa = inet6_addr_lst[state->bucket];
-		if (ifa)
-			break;
-	}
-	return ifa;
-}
-
-static struct inet6_ifaddr *if6_get_next(struct seq_file *seq, struct inet6_ifaddr *ifa)
-{
-	struct if6_iter_state *state = seq->private;
-
-	ifa = ifa->lst_next;
-try_again:
-	if (!ifa && ++state->bucket < IN6_ADDR_HSIZE) {
-		ifa = inet6_addr_lst[state->bucket];
-		goto try_again;
-	}
-	return ifa;
-}
-
-static struct inet6_ifaddr *if6_get_idx(struct seq_file *seq, loff_t pos)
-{
-	struct inet6_ifaddr *ifa = if6_get_first(seq);
-
-	if (ifa)
-		while(pos && (ifa = if6_get_next(seq, ifa)) != NULL)
-			--pos;
-	return pos ? NULL : ifa;
-}
-
-static void *if6_seq_start(struct seq_file *seq, loff_t *pos)
-{
-	read_lock_bh(&addrconf_hash_lock);
-	return if6_get_idx(seq, *pos);
-}
-
-static void *if6_seq_next(struct seq_file *seq, void *v, loff_t *pos)
-{
-	struct inet6_ifaddr *ifa;
-
-	ifa = if6_get_next(seq, v);
-	++*pos;
-	return ifa;
-}
-
-static void if6_seq_stop(struct seq_file *seq, void *v)
-{
-	read_unlock_bh(&addrconf_hash_lock);
-}
-
-static int if6_seq_show(struct seq_file *seq, void *v)
-{
-	struct inet6_ifaddr *ifp = (struct inet6_ifaddr *)v;
-	seq_printf(seq,
-		   NIP6_SEQFMT " %02x %02x %02x %02x %8s\n",
-		   NIP6(ifp->addr),
-		   ifp->idev->dev->ifindex,
-		   ifp->prefix_len,
-		   ifp->scope,
-		   ifp->flags,
-		   ifp->idev->dev->name);
-	return 0;
-}
-
-static struct seq_operations if6_seq_ops = {
-	.start	= if6_seq_start,
-	.next	= if6_seq_next,
-	.show	= if6_seq_show,
-	.stop	= if6_seq_stop,
-};
-
-static int if6_seq_open(struct inode *inode, struct file *file)
-{
-	struct seq_file *seq;
-	int rc = -ENOMEM;
-	struct if6_iter_state *s = kzalloc(sizeof(*s), GFP_KERNEL);
-
-	if (!s)
-		goto out;
-
-	rc = seq_open(file, &if6_seq_ops);
-	if (rc)
-		goto out_kfree;
-
-	seq = file->private_data;
-	seq->private = s;
-out:
-	return rc;
-out_kfree:
-	kfree(s);
-	goto out;
-}
-
-static const struct file_operations if6_fops = {
-	.owner		= THIS_MODULE,
-	.open		= if6_seq_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= seq_release_private,
-};
-
-int __init if6_proc_init(void)
-{
-	if (!proc_net_fops_create("if_inet6", S_IRUGO, &if6_fops))
-		return -ENOMEM;
-	return 0;
-}
-
-void if6_proc_exit(void)
-{
-	proc_net_remove("if_inet6");
-}
-#endif	/* CONFIG_PROC_FS */
-
-#ifdef CONFIG_IPV6_MIP6
-/* Check if address is a home address configured on any interface. */
-int ipv6_chk_home_addr(struct in6_addr *addr)
-{
-	int ret = 0;
-	struct inet6_ifaddr * ifp;
-	u8 hash = ipv6_addr_hash(addr);
-	read_lock_bh(&addrconf_hash_lock);
-	for (ifp = inet6_addr_lst[hash]; ifp; ifp = ifp->lst_next) {
-		if (ipv6_addr_cmp(&ifp->addr, addr) == 0 &&
-		    (ifp->flags & IFA_F_HOMEADDRESS)) {
-			ret = 1;
-			break;
-		}
-	}
-	read_unlock_bh(&addrconf_hash_lock);
-	return ret;
-}
-#endif
-
-/*
- *	Periodic address status verification
- */
-
-static void addrconf_verify(unsigned long foo)
-{
-	struct inet6_ifaddr *ifp;
-	unsigned long now, next;
-	int i;
-
-	spin_lock_bh(&addrconf_verify_lock);
-	now = jiffies;
-	next = now + ADDR_CHECK_FREQUENCY;
-
-	del_timer(&addr_chk_timer);
-
-	for (i=0; i < IN6_ADDR_HSIZE; i++) {
-
-restart:
-		read_lock(&addrconf_hash_lock);
-		for (ifp=inet6_addr_lst[i]; ifp; ifp=ifp->lst_next) {
-			unsigned long age;
-#ifdef CONFIG_IPV6_PRIVACY
-			unsigned long regen_advance;
-#endif
-
-			if (ifp->flags & IFA_F_PERMANENT)
-				continue;
-
-			spin_lock(&ifp->lock);
-			age = (now - ifp->tstamp) / HZ;
-
-#ifdef CONFIG_IPV6_PRIVACY
-			regen_advance = ifp->idev->cnf.regen_max_retry *
-					ifp->idev->cnf.dad_transmits *
-					ifp->idev->nd_parms->retrans_time / HZ;
-#endif
-
-			if (ifp->valid_lft != INFINITY_LIFE_TIME &&
-			    age >= ifp->valid_lft) {
-				spin_unlock(&ifp->lock);
-				in6_ifa_hold(ifp);
-				read_unlock(&addrconf_hash_lock);
-				ipv6_del_addr(ifp);
-				goto restart;
-			} else if (ifp->prefered_lft == INFINITY_LIFE_TIME) {
-				spin_unlock(&ifp->lock);
-				continue;
-			} else if (age >= ifp->prefered_lft) {
-				/* jiffies - ifp->tsamp > age >= ifp->prefered_lft */
-				int deprecate = 0;
-
-				if (!(ifp->flags&IFA_F_DEPRECATED)) {
-					deprecate = 1;
-					ifp->flags |= IFA_F_DEPRECATED;
-				}
-
-				if (time_before(ifp->tstamp + ifp->valid_lft * HZ, next))
-					next = ifp->tstamp + ifp->valid_lft * HZ;
-
-				spin_unlock(&ifp->lock);
-
-				if (deprecate) {
-					in6_ifa_hold(ifp);
-					read_unlock(&addrconf_hash_lock);
-
-					ipv6_ifa_notify(0, ifp);
-					in6_ifa_put(ifp);
-					goto restart;
-				}
-#ifdef CONFIG_IPV6_PRIVACY
-			} else if ((ifp->flags&IFA_F_TEMPORARY) &&
-				   !(ifp->flags&IFA_F_TENTATIVE)) {
-				if (age >= ifp->prefered_lft - regen_advance) {
-					struct inet6_ifaddr *ifpub = ifp->ifpub;
-					if (time_before(ifp->tstamp + ifp->prefered_lft * HZ, next))
-						next = ifp->tstamp + ifp->prefered_lft * HZ;
-					if (!ifp->regen_count && ifpub) {
-						ifp->regen_count++;
-						in6_ifa_hold(ifp);
-						in6_ifa_hold(ifpub);
-						spin_unlock(&ifp->lock);
-						read_unlock(&addrconf_hash_lock);
-						spin_lock(&ifpub->lock);
-						ifpub->regen_count = 0;
-						spin_unlock(&ifpub->lock);
-						ipv6_create_tempaddr(ifpub, ifp);
-						in6_ifa_put(ifpub);
-						in6_ifa_put(ifp);
-						goto restart;
-					}
-				} else if (time_before(ifp->tstamp + ifp->prefered_lft * HZ - regen_advance * HZ, next))
-					next = ifp->tstamp + ifp->prefered_lft * HZ - regen_advance * HZ;
-				spin_unlock(&ifp->lock);
-#endif
-			} else {
-				/* ifp->prefered_lft <= ifp->valid_lft */
-				if (time_before(ifp->tstamp + ifp->prefered_lft * HZ, next))
-					next = ifp->tstamp + ifp->prefered_lft * HZ;
-				spin_unlock(&ifp->lock);
-			}
-		}
-		read_unlock(&addrconf_hash_lock);
-	}
-
-	addr_chk_timer.expires = time_before(next, jiffies + HZ) ? jiffies + HZ : next;
-	add_timer(&addr_chk_timer);
-	spin_unlock_bh(&addrconf_verify_lock);
-}
-
-static struct in6_addr *extract_addr(struct nlattr *addr, struct nlattr *local)
-{
-	struct in6_addr *pfx = NULL;
-
-	if (addr)
-		pfx = nla_data(addr);
-
-	if (local) {
-		if (pfx && nla_memcmp(local, pfx, sizeof(*pfx)))
-			pfx = NULL;
-		else
-			pfx = nla_data(local);
-	}
-
-	return pfx;
-}
-
-static const struct nla_policy ifa_ipv6_policy[IFA_MAX+1] = {
-	[IFA_ADDRESS]		= { .len = sizeof(struct in6_addr) },
-	[IFA_LOCAL]		= { .len = sizeof(struct in6_addr) },
-	[IFA_CACHEINFO]		= { .len = sizeof(struct ifa_cacheinfo) },
-};
-
-static int
-inet6_rtm_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
-{
-	struct ifaddrmsg *ifm;
-	struct nlattr *tb[IFA_MAX+1];
-	struct in6_addr *pfx;
-	int err;
-
-	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv6_policy);
-	if (err < 0)
-		return err;
-
-	ifm = nlmsg_data(nlh);
-	pfx = extract_addr(tb[IFA_ADDRESS], tb[IFA_LOCAL]);
-	if (pfx == NULL)
-		return -EINVAL;
-
-	return inet6_addr_del(ifm->ifa_index, pfx, ifm->ifa_prefixlen);
-}
-
-static int inet6_addr_modify(struct inet6_ifaddr *ifp, u8 ifa_flags,
-			     u32 prefered_lft, u32 valid_lft)
-{
-	u32 flags = RTF_EXPIRES;
-
-	if (!valid_lft || (prefered_lft > valid_lft))
-		return -EINVAL;
-
-	if (valid_lft == INFINITY_LIFE_TIME) {
-		ifa_flags |= IFA_F_PERMANENT;
-		flags = 0;
-	} else if (valid_lft >= 0x7FFFFFFF/HZ)
-		valid_lft = 0x7FFFFFFF/HZ;
-
-	if (prefered_lft == 0)
-		ifa_flags |= IFA_F_DEPRECATED;
-	else if ((prefered_lft >= 0x7FFFFFFF/HZ) &&
-		 (prefered_lft != INFINITY_LIFE_TIME))
-		prefered_lft = 0x7FFFFFFF/HZ;
-
-	spin_lock_bh(&ifp->lock);
-	ifp->flags = (ifp->flags & ~(IFA_F_DEPRECATED | IFA_F_PERMANENT | IFA_F_NODAD | IFA_F_HOMEADDRESS)) | ifa_flags;
-	ifp->tstamp = jiffies;
-	ifp->valid_lft = valid_lft;
-	ifp->prefered_lft = prefered_lft;
-
-	spin_unlock_bh(&ifp->lock);
-	if (!(ifp->flags&IFA_F_TENTATIVE))
-		ipv6_ifa_notify(0, ifp);
-
-	addrconf_prefix_route(&ifp->addr, ifp->prefix_len, ifp->idev->dev,
-			      jiffies_to_clock_t(valid_lft * HZ), flags);
-	addrconf_verify(0);
-
-	return 0;
-}
-
-static int
-inet6_rtm_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
-{
-	struct ifaddrmsg *ifm;
-	struct nlattr *tb[IFA_MAX+1];
-	struct in6_addr *pfx;
-	struct inet6_ifaddr *ifa;
-	struct net_device *dev;
-	u32 valid_lft = INFINITY_LIFE_TIME, preferred_lft = INFINITY_LIFE_TIME;
-	u8 ifa_flags;
-	int err;
-
-	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv6_policy);
-	if (err < 0)
-		return err;
-
-	ifm = nlmsg_data(nlh);
-	pfx = extract_addr(tb[IFA_ADDRESS], tb[IFA_LOCAL]);
-	if (pfx == NULL)
-		return -EINVAL;
-
-	if (tb[IFA_CACHEINFO]) {
-		struct ifa_cacheinfo *ci;
-
-		ci = nla_data(tb[IFA_CACHEINFO]);
-		valid_lft = ci->ifa_valid;
-		preferred_lft = ci->ifa_prefered;
-	} else {
-		preferred_lft = INFINITY_LIFE_TIME;
-		valid_lft = INFINITY_LIFE_TIME;
-	}
-
-	dev =  __dev_get_by_index(ifm->ifa_index);
-	if (dev == NULL)
-		return -ENODEV;
-
-	/* We ignore other flags so far. */
-	ifa_flags = ifm->ifa_flags & (IFA_F_NODAD | IFA_F_HOMEADDRESS);
-
-	ifa = ipv6_get_ifaddr(pfx, dev, 1);
-	if (ifa == NULL) {
-		/*
-		 * It would be best to check for !NLM_F_CREATE here but
-		 * userspace alreay relies on not having to provide this.
-		 */
-		return inet6_addr_add(ifm->ifa_index, pfx, ifm->ifa_prefixlen,
-				      ifa_flags, preferred_lft, valid_lft);
-	}
-
-	if (nlh->nlmsg_flags & NLM_F_EXCL ||
-	    !(nlh->nlmsg_flags & NLM_F_REPLACE))
-		err = -EEXIST;
-	else
-		err = inet6_addr_modify(ifa, ifa_flags, preferred_lft, valid_lft);
-
-	in6_ifa_put(ifa);
-
-	return err;
-}
-
-static void put_ifaddrmsg(struct nlmsghdr *nlh, u8 prefixlen, u8 flags,
-			  u8 scope, int ifindex)
-{
-	struct ifaddrmsg *ifm;
-
-	ifm = nlmsg_data(nlh);
-	ifm->ifa_family = AF_INET6;
-	ifm->ifa_prefixlen = prefixlen;
-	ifm->ifa_flags = flags;
-	ifm->ifa_scope = scope;
-	ifm->ifa_index = ifindex;
-}
-
-static int put_cacheinfo(struct sk_buff *skb, unsigned long cstamp,
-			 unsigned long tstamp, u32 preferred, u32 valid)
-{
-	struct ifa_cacheinfo ci;
-
-	ci.cstamp = (u32)(TIME_DELTA(cstamp, INITIAL_JIFFIES) / HZ * 100
-			+ TIME_DELTA(cstamp, INITIAL_JIFFIES) % HZ * 100 / HZ);
-	ci.tstamp = (u32)(TIME_DELTA(tstamp, INITIAL_JIFFIES) / HZ * 100
-			+ TIME_DELTA(tstamp, INITIAL_JIFFIES) % HZ * 100 / HZ);
-	ci.ifa_prefered = preferred;
-	ci.ifa_valid = valid;
-
-	return nla_put(skb, IFA_CACHEINFO, sizeof(ci), &ci);
-}
-
-static inline int rt_scope(int ifa_scope)
-{
-	if (ifa_scope & IFA_HOST)
-		return RT_SCOPE_HOST;
-	else if (ifa_scope & IFA_LINK)
-		return RT_SCOPE_LINK;
-	else if (ifa_scope & IFA_SITE)
-		return RT_SCOPE_SITE;
-	else
-		return RT_SCOPE_UNIVERSE;
-}
-
-static inline int inet6_ifaddr_msgsize(void)
-{
-	return NLMSG_ALIGN(sizeof(struct ifaddrmsg))
-	       + nla_total_size(16) /* IFA_ADDRESS */
-	       + nla_total_size(sizeof(struct ifa_cacheinfo));
-}
-
-static int inet6_fill_ifaddr(struct sk_buff *skb, struct inet6_ifaddr *ifa,
-			     u32 pid, u32 seq, int event, unsigned int flags)
-{
-	struct nlmsghdr  *nlh;
-	u32 preferred, valid;
-
-	nlh = nlmsg_put(skb, pid, seq, event, sizeof(struct ifaddrmsg), flags);
-	if (nlh == NULL)
-		return -EMSGSIZE;
-
-	put_ifaddrmsg(nlh, ifa->prefix_len, ifa->flags, rt_scope(ifa->scope),
-		      ifa->idev->dev->ifindex);
-
-	if (!(ifa->flags&IFA_F_PERMANENT)) {
-		preferred = ifa->prefered_lft;
-		valid = ifa->valid_lft;
-		if (preferred != INFINITY_LIFE_TIME) {
-			long tval = (jiffies - ifa->tstamp)/HZ;
-			preferred -= tval;
-			if (valid != INFINITY_LIFE_TIME)
-				valid -= tval;
-		}
-	} else {
-		preferred = INFINITY_LIFE_TIME;
-		valid = INFINITY_LIFE_TIME;
-	}
-
-	if (nla_put(skb, IFA_ADDRESS, 16, &ifa->addr) < 0 ||
-	    put_cacheinfo(skb, ifa->cstamp, ifa->tstamp, preferred, valid) < 0) {
-		nlmsg_cancel(skb, nlh);
-		return -EMSGSIZE;
-	}
-
-	return nlmsg_end(skb, nlh);
-}
-
-static int inet6_fill_ifmcaddr(struct sk_buff *skb, struct ifmcaddr6 *ifmca,
-				u32 pid, u32 seq, int event, u16 flags)
-{
-	struct nlmsghdr  *nlh;
-	u8 scope = RT_SCOPE_UNIVERSE;
-	int ifindex = ifmca->idev->dev->ifindex;
-
-	if (ipv6_addr_scope(&ifmca->mca_addr) & IFA_SITE)
-		scope = RT_SCOPE_SITE;
-
-	nlh = nlmsg_put(skb, pid, seq, event, sizeof(struct ifaddrmsg), flags);
-	if (nlh == NULL)
-		return -EMSGSIZE;
-
-	put_ifaddrmsg(nlh, 128, IFA_F_PERMANENT, scope, ifindex);
-	if (nla_put(skb, IFA_MULTICAST, 16, &ifmca->mca_addr) < 0 ||
-	    put_cacheinfo(skb, ifmca->mca_cstamp, ifmca->mca_tstamp,
-			  INFINITY_LIFE_TIME, INFINITY_LIFE_TIME) < 0) {
-		nlmsg_cancel(skb, nlh);
-		return -EMSGSIZE;
-	}
-
-	return nlmsg_end(skb, nlh);
-}
-
-static int inet6_fill_ifacaddr(struct sk_buff *skb, struct ifacaddr6 *ifaca,
-				u32 pid, u32 seq, int event, unsigned int flags)
-{
-	struct nlmsghdr  *nlh;
-	u8 scope = RT_SCOPE_UNIVERSE;
-	int ifindex = ifaca->aca_idev->dev->ifindex;
-
-	if (ipv6_addr_scope(&ifaca->aca_addr) & IFA_SITE)
-		scope = RT_SCOPE_SITE;
-
-	nlh = nlmsg_put(skb, pid, seq, event, sizeof(struct ifaddrmsg), flags);
-	if (nlh == NULL)
-		return -EMSGSIZE;
-
-	put_ifaddrmsg(nlh, 128, IFA_F_PERMANENT, scope, ifindex);
-	if (nla_put(skb, IFA_ANYCAST, 16, &ifaca->aca_addr) < 0 ||
-	    put_cacheinfo(skb, ifaca->aca_cstamp, ifaca->aca_tstamp,
-			  INFINITY_LIFE_TIME, INFINITY_LIFE_TIME) < 0) {
-		nlmsg_cancel(skb, nlh);
-		return -EMSGSIZE;
-	}
-
-	return nlmsg_end(skb, nlh);
-}
-
-enum addr_type_t
-{
-	UNICAST_ADDR,
-	MULTICAST_ADDR,
-	ANYCAST_ADDR,
-};
-
-static int inet6_dump_addr(struct sk_buff *skb, struct netlink_callback *cb,
-			   enum addr_type_t type)
-{
-	int idx, ip_idx;
-	int s_idx, s_ip_idx;
-	int err = 1;
-	struct net_device *dev;
-	struct inet6_dev *idev = NULL;
-	struct inet6_ifaddr *ifa;
-	struct ifmcaddr6 *ifmca;
-	struct ifacaddr6 *ifaca;
-
-	s_idx = cb->args[0];
-	s_ip_idx = ip_idx = cb->args[1];
-
-	idx = 0;
-	for_each_netdev(dev) {
-		if (idx < s_idx)
-			goto cont;
-		if (idx > s_idx)
-			s_ip_idx = 0;
-		ip_idx = 0;
-		if ((idev = in6_dev_get(dev)) == NULL)
-			goto cont;
-		read_lock_bh(&idev->lock);
-		switch (type) {
-		case UNICAST_ADDR:
-			/* unicast address incl. temp addr */
-			for (ifa = idev->addr_list; ifa;
-			     ifa = ifa->if_next, ip_idx++) {
-				if (ip_idx < s_ip_idx)
-					continue;
-				if ((err = inet6_fill_ifaddr(skb, ifa,
-				    NETLINK_CB(cb->skb).pid,
-				    cb->nlh->nlmsg_seq, RTM_NEWADDR,
-				    NLM_F_MULTI)) <= 0)
-					goto done;
-			}
-			break;
-		case MULTICAST_ADDR:
-			/* multicast address */
-			for (ifmca = idev->mc_list; ifmca;
-			     ifmca = ifmca->next, ip_idx++) {
-				if (ip_idx < s_ip_idx)
-					continue;
-				if ((err = inet6_fill_ifmcaddr(skb, ifmca,
-				    NETLINK_CB(cb->skb).pid,
-				    cb->nlh->nlmsg_seq, RTM_GETMULTICAST,
-				    NLM_F_MULTI)) <= 0)
-					goto done;
-			}
-			break;
-		case ANYCAST_ADDR:
-			/* anycast address */
-			for (ifaca = idev->ac_list; ifaca;
-			     ifaca = ifaca->aca_next, ip_idx++) {
-				if (ip_idx < s_ip_idx)
-					continue;
-				if ((err = inet6_fill_ifacaddr(skb, ifaca,
-				    NETLINK_CB(cb->skb).pid,
-				    cb->nlh->nlmsg_seq, RTM_GETANYCAST,
-				    NLM_F_MULTI)) <= 0)
-					goto done;
-			}
-			break;
-		default:
-			break;
-		}
-		read_unlock_bh(&idev->lock);
-		in6_dev_put(idev);
-cont:
-		idx++;
-	}
-done:
-	if (err <= 0) {
-		read_unlock_bh(&idev->lock);
-		in6_dev_put(idev);
-	}
-	cb->args[0] = idx;
-	cb->args[1] = ip_idx;
-	return skb->len;
-}
-
-static int inet6_dump_ifaddr(struct sk_buff *skb, struct netlink_callback *cb)
-{
-	enum addr_type_t type = UNICAST_ADDR;
-	return inet6_dump_addr(skb, cb, type);
-}
-
-static int inet6_dump_ifmcaddr(struct sk_buff *skb, struct netlink_callback *cb)
-{
-	enum addr_type_t type = MULTICAST_ADDR;
-	return inet6_dump_addr(skb, cb, type);
-}
-
-
-static int inet6_dump_ifacaddr(struct sk_buff *skb, struct netlink_callback *cb)
-{
-	enum addr_type_t type = ANYCAST_ADDR;
-	return inet6_dump_addr(skb, cb, type);
-}
-
-static int inet6_rtm_getaddr(struct sk_buff *in_skb, struct nlmsghdr* nlh,
-			     void *arg)
-{
-	struct ifaddrmsg *ifm;
-	struct nlattr *tb[IFA_MAX+1];
-	struct in6_addr *addr = NULL;
-	struct net_device *dev = NULL;
-	struct inet6_ifaddr *ifa;
-	struct sk_buff *skb;
-	int err;
-
-	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv6_policy);
-	if (err < 0)
-		goto errout;
-
-	addr = extract_addr(tb[IFA_ADDRESS], tb[IFA_LOCAL]);
-	if (addr == NULL) {
-		err = -EINVAL;
-		goto errout;
-	}
-
-	ifm = nlmsg_data(nlh);
-	if (ifm->ifa_index)
-		dev = __dev_get_by_index(ifm->ifa_index);
-
-	if ((ifa = ipv6_get_ifaddr(addr, dev, 1)) == NULL) {
-		err = -EADDRNOTAVAIL;
-		goto errout;
-	}
-
-	if ((skb = nlmsg_new(inet6_ifaddr_msgsize(), GFP_KERNEL)) == NULL) {
-		err = -ENOBUFS;
-		goto errout_ifa;
-	}
-
-	err = inet6_fill_ifaddr(skb, ifa, NETLINK_CB(in_skb).pid,
-				nlh->nlmsg_seq, RTM_NEWADDR, 0);
-	if (err < 0) {
-		/* -EMSGSIZE implies BUG in inet6_ifaddr_msgsize() */
-		WARN_ON(err == -EMSGSIZE);
-		kfree_skb(skb);
-		goto errout_ifa;
-	}
-	err = rtnl_unicast(skb, NETLINK_CB(in_skb).pid);
-errout_ifa:
-	in6_ifa_put(ifa);
-errout:
-	return err;
-}
-
-static void inet6_ifa_notify(int event, struct inet6_ifaddr *ifa)
-{
-	struct sk_buff *skb;
-	int err = -ENOBUFS;
-
-	skb = nlmsg_new(inet6_ifaddr_msgsize(), GFP_ATOMIC);
-	if (skb == NULL)
-		goto errout;
-
-	err = inet6_fill_ifaddr(skb, ifa, 0, 0, event, 0);
-	if (err < 0) {
-		/* -EMSGSIZE implies BUG in inet6_ifaddr_msgsize() */
-		WARN_ON(err == -EMSGSIZE);
-		kfree_skb(skb);
-		goto errout;
-	}
-	err = rtnl_notify(skb, 0, RTNLGRP_IPV6_IFADDR, NULL, GFP_ATOMIC);
-errout:
-	if (err < 0)
-		rtnl_set_sk_err(RTNLGRP_IPV6_IFADDR, err);
-}
-
-static inline void ipv6_store_devconf(struct ipv6_devconf *cnf,
-				__s32 *array, int bytes)
-{
-	BUG_ON(bytes < (DEVCONF_MAX * 4));
-
-	memset(array, 0, bytes);
-	array[DEVCONF_FORWARDING] = cnf->forwarding;
-	array[DEVCONF_HOPLIMIT] = cnf->hop_limit;
-	array[DEVCONF_MTU6] = cnf->mtu6;
-	array[DEVCONF_ACCEPT_RA] = cnf->accept_ra;
-	array[DEVCONF_ACCEPT_REDIRECTS] = cnf->accept_redirects;
-	array[DEVCONF_AUTOCONF] = cnf->autoconf;
-	array[DEVCONF_DAD_TRANSMITS] = cnf->dad_transmits;
-	array[DEVCONF_RTR_SOLICITS] = cnf->rtr_solicits;
-	array[DEVCONF_RTR_SOLICIT_INTERVAL] = cnf->rtr_solicit_interval;
-	array[DEVCONF_RTR_SOLICIT_DELAY] = cnf->rtr_solicit_delay;
-	array[DEVCONF_FORCE_MLD_VERSION] = cnf->force_mld_version;
-#ifdef CONFIG_IPV6_PRIVACY
-	array[DEVCONF_USE_TEMPADDR] = cnf->use_tempaddr;
-	array[DEVCONF_TEMP_VALID_LFT] = cnf->temp_valid_lft;
-	array[DEVCONF_TEMP_PREFERED_LFT] = cnf->temp_prefered_lft;
-	array[DEVCONF_REGEN_MAX_RETRY] = cnf->regen_max_retry;
-	array[DEVCONF_MAX_DESYNC_FACTOR] = cnf->max_desync_factor;
-#endif
-	array[DEVCONF_MAX_ADDRESSES] = cnf->max_addresses;
-	array[DEVCONF_ACCEPT_RA_DEFRTR] = cnf->accept_ra_defrtr;
-	array[DEVCONF_ACCEPT_RA_PINFO] = cnf->accept_ra_pinfo;
-#ifdef CONFIG_IPV6_ROUTER_PREF
-	array[DEVCONF_ACCEPT_RA_RTR_PREF] = cnf->accept_ra_rtr_pref;
-	array[DEVCONF_RTR_PROBE_INTERVAL] = cnf->rtr_probe_interval;
-#ifdef CONFIG_IPV6_ROUTE_INFO
-	array[DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN] = cnf->accept_ra_rt_info_max_plen;
-#endif
-#endif
-	array[DEVCONF_PROXY_NDP] = cnf->proxy_ndp;
-	array[DEVCONF_ACCEPT_SOURCE_ROUTE] = cnf->accept_source_route;
-#ifdef CONFIG_IPV6_OPTIMISTIC_DAD
-	array[DEVCONF_OPTIMISTIC_DAD] = cnf->optimistic_dad;
-#endif
-}
-
-static inline size_t inet6_if_nlmsg_size(void)
-{
-	return NLMSG_ALIGN(sizeof(struct ifinfomsg))
-	       + nla_total_size(IFNAMSIZ) /* IFLA_IFNAME */
-	       + nla_total_size(MAX_ADDR_LEN) /* IFLA_ADDRESS */
-	       + nla_total_size(4) /* IFLA_MTU */
-	       + nla_total_size(4) /* IFLA_LINK */
-	       + nla_total_size( /* IFLA_PROTINFO */
-			nla_total_size(4) /* IFLA_INET6_FLAGS */
-			+ nla_total_size(sizeof(struct ifla_cacheinfo))
-			+ nla_total_size(DEVCONF_MAX * 4) /* IFLA_INET6_CONF */
-			+ nla_total_size(IPSTATS_MIB_MAX * 8) /* IFLA_INET6_STATS */
-			+ nla_total_size(ICMP6_MIB_MAX * 8) /* IFLA_INET6_ICMP6STATS */
-		 );
-}
-
-static inline void __snmp6_fill_stats(u64 *stats, void **mib, int items,
-				      int bytes)
-{
-	int i;
-	int pad = bytes - sizeof(u64) * items;
-	BUG_ON(pad < 0);
-
-	/* Use put_unaligned() because stats may not be aligned for u64. */
-	put_unaligned(items, &stats[0]);
-	for (i = 1; i < items; i++)
-		put_unaligned(snmp_fold_field(mib, i), &stats[i]);
-
-	memset(&stats[items], 0, pad);
-}
-
-static void snmp6_fill_stats(u64 *stats, struct inet6_dev *idev, int attrtype,
-			     int bytes)
-{
-	switch(attrtype) {
-	case IFLA_INET6_STATS:
-		__snmp6_fill_stats(stats, (void **)idev->stats.ipv6, IPSTATS_MIB_MAX, bytes);
-		break;
-	case IFLA_INET6_ICMP6STATS:
-		__snmp6_fill_stats(stats, (void **)idev->stats.icmpv6, ICMP6_MIB_MAX, bytes);
-		break;
-	}
-}
-
-static int inet6_fill_ifinfo(struct sk_buff *skb, struct inet6_dev *idev,
-			     u32 pid, u32 seq, int event, unsigned int flags)
-{
-	struct net_device *dev = idev->dev;
-	struct nlattr *nla;
-	struct ifinfomsg *hdr;
-	struct nlmsghdr *nlh;
-	void *protoinfo;
-	struct ifla_cacheinfo ci;
-
-	nlh = nlmsg_put(skb, pid, seq, event, sizeof(*hdr), flags);
-	if (nlh == NULL)
-		return -EMSGSIZE;
-
-	hdr = nlmsg_data(nlh);
-	hdr->ifi_family = AF_INET6;
-	hdr->__ifi_pad = 0;
-	hdr->ifi_type = dev->type;
-	hdr->ifi_index = dev->ifindex;
-	hdr->ifi_flags = dev_get_flags(dev);
-	hdr->ifi_change = 0;
-
-	NLA_PUT_STRING(skb, IFLA_IFNAME, dev->name);
-
-	if (dev->addr_len)
-		NLA_PUT(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr);
-
-	NLA_PUT_U32(skb, IFLA_MTU, dev->mtu);
-	if (dev->ifindex != dev->iflink)
-		NLA_PUT_U32(skb, IFLA_LINK, dev->iflink);
-
-	protoinfo = nla_nest_start(skb, IFLA_PROTINFO);
-	if (protoinfo == NULL)
-		goto nla_put_failure;
-
-	NLA_PUT_U32(skb, IFLA_INET6_FLAGS, idev->if_flags);
-
-	ci.max_reasm_len = IPV6_MAXPLEN;
-	ci.tstamp = (__u32)(TIME_DELTA(idev->tstamp, INITIAL_JIFFIES) / HZ * 100
-		    + TIME_DELTA(idev->tstamp, INITIAL_JIFFIES) % HZ * 100 / HZ);
-	ci.reachable_time = idev->nd_parms->reachable_time;
-	ci.retrans_time = idev->nd_parms->retrans_time;
-	NLA_PUT(skb, IFLA_INET6_CACHEINFO, sizeof(ci), &ci);
-
-	nla = nla_reserve(skb, IFLA_INET6_CONF, DEVCONF_MAX * sizeof(s32));
-	if (nla == NULL)
-		goto nla_put_failure;
-	ipv6_store_devconf(&idev->cnf, nla_data(nla), nla_len(nla));
-
-	/* XXX - MC not implemented */
-
-	nla = nla_reserve(skb, IFLA_INET6_STATS, IPSTATS_MIB_MAX * sizeof(u64));
-	if (nla == NULL)
-		goto nla_put_failure;
-	snmp6_fill_stats(nla_data(nla), idev, IFLA_INET6_STATS, nla_len(nla));
-
-	nla = nla_reserve(skb, IFLA_INET6_ICMP6STATS, ICMP6_MIB_MAX * sizeof(u64));
-	if (nla == NULL)
-		goto nla_put_failure;
-	snmp6_fill_stats(nla_data(nla), idev, IFLA_INET6_ICMP6STATS, nla_len(nla));
-
-	nla_nest_end(skb, protoinfo);
-	return nlmsg_end(skb, nlh);
-
-nla_put_failure:
-	nlmsg_cancel(skb, nlh);
-	return -EMSGSIZE;
-}
-
-static int inet6_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)
-{
-	int idx, err;
-	int s_idx = cb->args[0];
-	struct net_device *dev;
-	struct inet6_dev *idev;
-
-	read_lock(&dev_base_lock);
-	idx = 0;
-	for_each_netdev(dev) {
-		if (idx < s_idx)
-			goto cont;
-		if ((idev = in6_dev_get(dev)) == NULL)
-			goto cont;
-		err = inet6_fill_ifinfo(skb, idev, NETLINK_CB(cb->skb).pid,
-				cb->nlh->nlmsg_seq, RTM_NEWLINK, NLM_F_MULTI);
-		in6_dev_put(idev);
-		if (err <= 0)
-			break;
-cont:
-		idx++;
-	}
-	read_unlock(&dev_base_lock);
-	cb->args[0] = idx;
-
-	return skb->len;
-}
-
-void inet6_ifinfo_notify(int event, struct inet6_dev *idev)
-{
-	struct sk_buff *skb;
-	int err = -ENOBUFS;
-
-	skb = nlmsg_new(inet6_if_nlmsg_size(), GFP_ATOMIC);
-	if (skb == NULL)
-		goto errout;
-
-	err = inet6_fill_ifinfo(skb, idev, 0, 0, event, 0);
-	if (err < 0) {
-		/* -EMSGSIZE implies BUG in inet6_if_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
-		kfree_skb(skb);
-		goto errout;
-	}
-	err = rtnl_notify(skb, 0, RTNLGRP_IPV6_IFADDR, NULL, GFP_ATOMIC);
-errout:
-	if (err < 0)
-		rtnl_set_sk_err(RTNLGRP_IPV6_IFADDR, err);
-}
-
-static inline size_t inet6_prefix_nlmsg_size(void)
-{
-	return NLMSG_ALIGN(sizeof(struct prefixmsg))
-	       + nla_total_size(sizeof(struct in6_addr))
-	       + nla_total_size(sizeof(struct prefix_cacheinfo));
-}
-
-static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
-			     struct prefix_info *pinfo, u32 pid, u32 seq,
-			     int event, unsigned int flags)
-{
-	struct prefixmsg *pmsg;
-	struct nlmsghdr *nlh;
-	struct prefix_cacheinfo	ci;
-
-	nlh = nlmsg_put(skb, pid, seq, event, sizeof(*pmsg), flags);
-	if (nlh == NULL)
-		return -EMSGSIZE;
-
-	pmsg = nlmsg_data(nlh);
-	pmsg->prefix_family = AF_INET6;
-	pmsg->prefix_pad1 = 0;
-	pmsg->prefix_pad2 = 0;
-	pmsg->prefix_ifindex = idev->dev->ifindex;
-	pmsg->prefix_len = pinfo->prefix_len;
-	pmsg->prefix_type = pinfo->type;
-	pmsg->prefix_pad3 = 0;
-	pmsg->prefix_flags = 0;
-	if (pinfo->onlink)
-		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
-	if (pinfo->autoconf)
-		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;
-
-	NLA_PUT(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix);
-
-	ci.preferred_time = ntohl(pinfo->prefered);
-	ci.valid_time = ntohl(pinfo->valid);
-	NLA_PUT(skb, PREFIX_CACHEINFO, sizeof(ci), &ci);
-
-	return nlmsg_end(skb, nlh);
-
-nla_put_failure:
-	nlmsg_cancel(skb, nlh);
-	return -EMSGSIZE;
-}
-
-static void inet6_prefix_notify(int event, struct inet6_dev *idev,
-			 struct prefix_info *pinfo)
-{
-	struct sk_buff *skb;
-	int err = -ENOBUFS;
-
-	skb = nlmsg_new(inet6_prefix_nlmsg_size(), GFP_ATOMIC);
-	if (skb == NULL)
-		goto errout;
-
-	err = inet6_fill_prefix(skb, idev, pinfo, 0, 0, event, 0);
-	if (err < 0) {
-		/* -EMSGSIZE implies BUG in inet6_prefix_nlmsg_size() */
-		WARN_ON(err == -EMSGSIZE);
-		kfree_skb(skb);
-		goto errout;
-	}
-	err = rtnl_notify(skb, 0, RTNLGRP_IPV6_PREFIX, NULL, GFP_ATOMIC);
-errout:
-	if (err < 0)
-		rtnl_set_sk_err(RTNLGRP_IPV6_PREFIX, err);
-}
-
-static void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)
-{
-	inet6_ifa_notify(event ? : RTM_NEWADDR, ifp);
-
-	switch (event) {
-	case RTM_NEWADDR:
-		/*
-		 * If the address was optimistic
-		 * we inserted the route at the start of
-		 * our DAD process, so we don't need
-		 * to do it again
-		 */
-		if (!(ifp->rt->rt6i_node))
-			ip6_ins_rt(ifp->rt);
-		if (ifp->idev->cnf.forwarding)
-			addrconf_join_anycast(ifp);
-		break;
-	case RTM_DELADDR:
-		if (ifp->idev->cnf.forwarding)
-			addrconf_leave_anycast(ifp);
-		addrconf_leave_solict(ifp->idev, &ifp->addr);
-		dst_hold(&ifp->rt->u.dst);
-		if (ip6_del_rt(ifp->rt))
-			dst_free(&ifp->rt->u.dst);
-		break;
-	}
-}
-
-static void ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)
-{
-	rcu_read_lock_bh();
-	if (likely(ifp->idev->dead == 0))
-		__ipv6_ifa_notify(event, ifp);
-	rcu_read_unlock_bh();
-}
-
-#ifdef CONFIG_SYSCTL
-
-static
-int addrconf_sysctl_forward(ctl_table *ctl, int write, struct file * filp,
-			   void __user *buffer, size_t *lenp, loff_t *ppos)
-{
-	int *valp = ctl->data;
-	int val = *valp;
-	int ret;
-
-	ret = proc_dointvec(ctl, write, filp, buffer, lenp, ppos);
-
-	if (write && valp != &ipv6_devconf_dflt.forwarding) {
-		if (valp != &ipv6_devconf.forwarding) {
-			if ((!*valp) ^ (!val)) {
-				struct inet6_dev *idev = (struct inet6_dev *)ctl->extra1;
-				if (idev == NULL)
-					return ret;
-				dev_forward_change(idev);
-			}
-		} else {
-			ipv6_devconf_dflt.forwarding = ipv6_devconf.forwarding;
-			addrconf_forward_change();
-		}
-		if (*valp)
-			rt6_purge_dflt_routers();
-	}
-
-	return ret;
-}
-
-static int addrconf_sysctl_forward_strategy(ctl_table *table,
-					    int __user *name, int nlen,
-					    void __user *oldval,
-					    size_t __user *oldlenp,
-					    void __user *newval, size_t newlen)
-{
-	int *valp = table->data;
-	int new;
-
-	if (!newval || !newlen)
-		return 0;
-	if (newlen != sizeof(int))
-		return -EINVAL;
-	if (get_user(new, (int __user *)newval))
-		return -EFAULT;
-	if (new == *valp)
-		return 0;
-	if (oldval && oldlenp) {
-		size_t len;
-		if (get_user(len, oldlenp))
-			return -EFAULT;
-		if (len) {
-			if (len > table->maxlen)
-				len = table->maxlen;
-			if (copy_to_user(oldval, valp, len))
-				return -EFAULT;
-			if (put_user(len, oldlenp))
-				return -EFAULT;
-		}
-	}
-
-	if (valp != &ipv6_devconf_dflt.forwarding) {
-		if (valp != &ipv6_devconf.forwarding) {
-			struct inet6_dev *idev = (struct inet6_dev *)table->extra1;
-			int changed;
-			if (unlikely(idev == NULL))
-				return -ENODEV;
-			changed = (!*valp) ^ (!new);
-			*valp = new;
-			if (changed)
-				dev_forward_change(idev);
-		} else {
-			*valp = new;
-			addrconf_forward_change();
-		}
-
-		if (*valp)
-			rt6_purge_dflt_routers();
-	} else
-		*valp = new;
-
-	return 1;
-}
-
-static struct addrconf_sysctl_table
-{
-	struct ctl_table_header *sysctl_header;
-	ctl_table addrconf_vars[__NET_IPV6_MAX];
-	ctl_table addrconf_dev[2];
-	ctl_table addrconf_conf_dir[2];
-	ctl_table addrconf_proto_dir[2];
-	ctl_table addrconf_root_dir[2];
-} addrconf_sysctl __read_mostly = {
-	.sysctl_header = NULL,
-	.addrconf_vars = {
-		{
-			.ctl_name	=	NET_IPV6_FORWARDING,
-			.procname	=	"forwarding",
-			.data		=	&ipv6_devconf.forwarding,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&addrconf_sysctl_forward,
-			.strategy	=	&addrconf_sysctl_forward_strategy,
-		},
-		{
-			.ctl_name	=	NET_IPV6_HOP_LIMIT,
-			.procname	=	"hop_limit",
-			.data		=	&ipv6_devconf.hop_limit,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_MTU,
-			.procname	=	"mtu",
-			.data		=	&ipv6_devconf.mtu6,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_ACCEPT_RA,
-			.procname	=	"accept_ra",
-			.data		=	&ipv6_devconf.accept_ra,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_ACCEPT_REDIRECTS,
-			.procname	=	"accept_redirects",
-			.data		=	&ipv6_devconf.accept_redirects,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_AUTOCONF,
-			.procname	=	"autoconf",
-			.data		=	&ipv6_devconf.autoconf,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_DAD_TRANSMITS,
-			.procname	=	"dad_transmits",
-			.data		=	&ipv6_devconf.dad_transmits,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_RTR_SOLICITS,
-			.procname	=	"router_solicitations",
-			.data		=	&ipv6_devconf.rtr_solicits,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_RTR_SOLICIT_INTERVAL,
-			.procname	=	"router_solicitation_interval",
-			.data		=	&ipv6_devconf.rtr_solicit_interval,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec_jiffies,
-			.strategy	=	&sysctl_jiffies,
-		},
-		{
-			.ctl_name	=	NET_IPV6_RTR_SOLICIT_DELAY,
-			.procname	=	"router_solicitation_delay",
-			.data		=	&ipv6_devconf.rtr_solicit_delay,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec_jiffies,
-			.strategy	=	&sysctl_jiffies,
-		},
-		{
-			.ctl_name	=	NET_IPV6_FORCE_MLD_VERSION,
-			.procname	=	"force_mld_version",
-			.data		=	&ipv6_devconf.force_mld_version,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-#ifdef CONFIG_IPV6_PRIVACY
-		{
-			.ctl_name	=	NET_IPV6_USE_TEMPADDR,
-			.procname	=	"use_tempaddr",
-			.data		=	&ipv6_devconf.use_tempaddr,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_TEMP_VALID_LFT,
-			.procname	=	"temp_valid_lft",
-			.data		=	&ipv6_devconf.temp_valid_lft,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_TEMP_PREFERED_LFT,
-			.procname	=	"temp_prefered_lft",
-			.data		=	&ipv6_devconf.temp_prefered_lft,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_REGEN_MAX_RETRY,
-			.procname	=	"regen_max_retry",
-			.data		=	&ipv6_devconf.regen_max_retry,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_MAX_DESYNC_FACTOR,
-			.procname	=	"max_desync_factor",
-			.data		=	&ipv6_devconf.max_desync_factor,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-#endif
-		{
-			.ctl_name	=	NET_IPV6_MAX_ADDRESSES,
-			.procname	=	"max_addresses",
-			.data		=	&ipv6_devconf.max_addresses,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_ACCEPT_RA_DEFRTR,
-			.procname	=	"accept_ra_defrtr",
-			.data		=	&ipv6_devconf.accept_ra_defrtr,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_ACCEPT_RA_PINFO,
-			.procname	=	"accept_ra_pinfo",
-			.data		=	&ipv6_devconf.accept_ra_pinfo,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-#ifdef CONFIG_IPV6_ROUTER_PREF
-		{
-			.ctl_name	=	NET_IPV6_ACCEPT_RA_RTR_PREF,
-			.procname	=	"accept_ra_rtr_pref",
-			.data		=	&ipv6_devconf.accept_ra_rtr_pref,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_RTR_PROBE_INTERVAL,
-			.procname	=	"router_probe_interval",
-			.data		=	&ipv6_devconf.rtr_probe_interval,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec_jiffies,
-			.strategy	=	&sysctl_jiffies,
-		},
-#ifdef CONFIG_IPV6_ROUTE_INFO
-		{
-			.ctl_name	=	NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN,
-			.procname	=	"accept_ra_rt_info_max_plen",
-			.data		=	&ipv6_devconf.accept_ra_rt_info_max_plen,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-#endif
-#endif
-		{
-			.ctl_name	=	NET_IPV6_PROXY_NDP,
-			.procname	=	"proxy_ndp",
-			.data		=	&ipv6_devconf.proxy_ndp,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-		{
-			.ctl_name	=	NET_IPV6_ACCEPT_SOURCE_ROUTE,
-			.procname	=	"accept_source_route",
-			.data		=	&ipv6_devconf.accept_source_route,
-			.maxlen		=	sizeof(int),
-			.mode		=	0644,
-			.proc_handler	=	&proc_dointvec,
-		},
-#ifdef CONFIG_IPV6_OPTIMISTIC_DAD
-		{
-			.ctl_name	=	CTL_UNNUMBERED,
-			.procname       =       "optimistic_dad",
-			.data           =       &ipv6_devconf.optimistic_dad,
-			.maxlen         =       sizeof(int),
-			.mode           =       0644,
-			.proc_handler   =       &proc_dointvec,
-
-		},
-#endif
-		{
-			.ctl_name	=	0,	/* sentinel */
-		}
-	},
-	.addrconf_dev = {
-		{
-			.ctl_name	=	NET_PROTO_CONF_ALL,
-			.procname	=	"all",
-			.mode		=	0555,
-			.child		=	addrconf_sysctl.addrconf_vars,
-		},
-		{
-			.ctl_name	=	0,	/* sentinel */
-		}
-	},
-	.addrconf_conf_dir = {
-		{
-			.ctl_name	=	NET_IPV6_CONF,
-			.procname	=	"conf",
-			.mode		=	0555,
-			.child		=	addrconf_sysctl.addrconf_dev,
-		},
-		{
-			.ctl_name	=	0,	/* sentinel */
-		}
-	},
-	.addrconf_proto_dir = {
-		{
-			.ctl_name	=	NET_IPV6,
-			.procname	=	"ipv6",
-			.mode		=	0555,
-			.child		=	addrconf_sysctl.addrconf_conf_dir,
-		},
-		{
-			.ctl_name	=	0,	/* sentinel */
-		}
-	},
-	.addrconf_root_dir = {
-		{
-			.ctl_name	=	CTL_NET,
-			.procname	=	"net",
-			.mode		=	0555,
-			.child		=	addrconf_sysctl.addrconf_proto_dir,
-		},
-		{
-			.ctl_name	=	0,	/* sentinel */
-		}
-	},
-};
-
-static void addrconf_sysctl_register(struct inet6_dev *idev, struct ipv6_devconf *p)
-{
-	int i;
-	struct net_device *dev = idev ? idev->dev : NULL;
-	struct addrconf_sysctl_table *t;
-	char *dev_name = NULL;
-
-	t = kmemdup(&addrconf_sysctl, sizeof(*t), GFP_KERNEL);
-	if (t == NULL)
-		return;
-	for (i=0; t->addrconf_vars[i].data; i++) {
-		t->addrconf_vars[i].data += (char*)p - (char*)&ipv6_devconf;
-		t->addrconf_vars[i].extra1 = idev; /* embedded; no ref */
-	}
-	if (dev) {
-		dev_name = dev->name;
-		t->addrconf_dev[0].ctl_name = dev->ifindex;
-	} else {
-		dev_name = "default";
-		t->addrconf_dev[0].ctl_name = NET_PROTO_CONF_DEFAULT;
-	}
-
-	/*
-	 * Make a copy of dev_name, because '.procname' is regarded as const
-	 * by sysctl and we wouldn't want anyone to change it under our feet
-	 * (see SIOCSIFNAME).
-	 */
-	dev_name = kstrdup(dev_name, GFP_KERNEL);
-	if (!dev_name)
-	    goto free;
-
-	t->addrconf_dev[0].procname = dev_name;
-
-	t->addrconf_dev[0].child = t->addrconf_vars;
-	t->addrconf_conf_dir[0].child = t->addrconf_dev;
-	t->addrconf_proto_dir[0].child = t->addrconf_conf_dir;
-	t->addrconf_root_dir[0].child = t->addrconf_proto_dir;
-
-	t->sysctl_header = register_sysctl_table(t->addrconf_root_dir);
-	if (t->sysctl_header == NULL)
-		goto free_procname;
-	else
-		p->sysctl = t;
-	return;
-
-	/* error path */
- free_procname:
-	kfree(dev_name);
- free:
-	kfree(t);
-
-	return;
-}
-
-static void addrconf_sysctl_unregister(struct ipv6_devconf *p)
-{
-	if (p->sysctl) {
-		struct addrconf_sysctl_table *t = p->sysctl;
-		p->sysctl = NULL;
-		unregister_sysctl_table(t->sysctl_header);
-		kfree(t->addrconf_dev[0].procname);
-		kfree(t);
-	}
-}
-
-
-#endif
-
-/*
- *      Device notifier
- */
-
-int register_inet6addr_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&inet6addr_chain, nb);
-}
-
-EXPORT_SYMBOL(register_inet6addr_notifier);
-
-int unregister_inet6addr_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&inet6addr_chain,nb);
-}
-
-EXPORT_SYMBOL(unregister_inet6addr_notifier);
-
-/*
- *	Init / cleanup code
- */
-
-int __init addrconf_init(void)
-{
-	int err = 0;
-
-	/* The addrconf netdev notifier requires that loopback_dev
-	 * has it's ipv6 private information allocated and setup
-	 * before it can bring up and give link-local addresses
-	 * to other devices which are up.
-	 *
-	 * Unfortunately, loopback_dev is not necessarily the first
-	 * entry in the global dev_base list of net devices.  In fact,
-	 * it is likely to be the very last entry on that list.
-	 * So this causes the notifier registry below to try and
-	 * give link-local addresses to all devices besides loopback_dev
-	 * first, then loopback_dev, which cases all the non-loopback_dev
-	 * devices to fail to get a link-local address.
-	 *
-	 * So, as a temporary fix, allocate the ipv6 structure for
-	 * loopback_dev first by hand.
-	 * Longer term, all of the dependencies ipv6 has upon the loopback
-	 * device and it being up should be removed.
-	 */
-	rtnl_lock();
-	if (!ipv6_add_dev(&loopback_dev))
-		err = -ENOMEM;
-	rtnl_unlock();
-	if (err)
-		return err;
-
-	ip6_null_entry.rt6i_idev = in6_dev_get(&loopback_dev);
-#ifdef CONFIG_IPV6_MULTIPLE_TABLES
-	ip6_prohibit_entry.rt6i_idev = in6_dev_get(&loopback_dev);
-	ip6_blk_hole_entry.rt6i_idev = in6_dev_get(&loopback_dev);
-#endif
-
-	register_netdevice_notifier(&ipv6_dev_notf);
-
-	addrconf_verify(0);
-
-	err = __rtnl_register(PF_INET6, RTM_GETLINK, NULL, inet6_dump_ifinfo);
-	if (err < 0)
-		goto errout;
-
-	/* Only the first call to __rtnl_register can fail */
-	__rtnl_register(PF_INET6, RTM_NEWADDR, inet6_rtm_newaddr, NULL);
-	__rtnl_register(PF_INET6, RTM_DELADDR, inet6_rtm_deladdr, NULL);
-	__rtnl_register(PF_INET6, RTM_GETADDR, inet6_rtm_getaddr, inet6_dump_ifaddr);
-	__rtnl_register(PF_INET6, RTM_GETMULTICAST, NULL, inet6_dump_ifmcaddr);
-	__rtnl_register(PF_INET6, RTM_GETANYCAST, NULL, inet6_dump_ifacaddr);
-
-#ifdef CONFIG_SYSCTL
-	addrconf_sysctl.sysctl_header =
-		register_sysctl_table(addrconf_sysctl.addrconf_root_dir);
-	addrconf_sysctl_register(NULL, &ipv6_devconf_dflt);
-#endif
-
-	return 0;
-errout:
-	unregister_netdevice_notifier(&ipv6_dev_notf);
-
-	return err;
-}
-
-void __exit addrconf_cleanup(void)
-{
-	struct net_device *dev;
-	struct inet6_dev *idev;
-	struct inet6_ifaddr *ifa;
-	int i;
-
-	unregister_netdevice_notifier(&ipv6_dev_notf);
-
-#ifdef CONFIG_SYSCTL
-	addrconf_sysctl_unregister(&ipv6_devconf_dflt);
-	addrconf_sysctl_unregister(&ipv6_devconf);
-#endif
-
-	rtnl_lock();
-
-	/*
-	 *	clean dev list.
-	 */
-
-	for_each_netdev(dev) {
-		if ((idev = __in6_dev_get(dev)) == NULL)
-			continue;
-		addrconf_ifdown(dev, 1);
-	}
-	addrconf_ifdown(&loopback_dev, 2);
-
-	/*
-	 *	Check hash table.
-	 */
-
-	write_lock_bh(&addrconf_hash_lock);
-	for (i=0; i < IN6_ADDR_HSIZE; i++) {
-		for (ifa=inet6_addr_lst[i]; ifa; ) {
-			struct inet6_ifaddr *bifa;
-
-			bifa = ifa;
-			ifa = ifa->lst_next;
-			printk(KERN_DEBUG "bug: IPv6 address leakage detected: ifa=%p\n", bifa);
-			/* Do not free it; something is wrong.
-			   Now we can investigate it with debugger.
-			 */
-		}
-	}
-	write_unlock_bh(&addrconf_hash_lock);
-
-	del_timer(&addr_chk_timer);
-
-	rtnl_unlock();
-
-#ifdef CONFIG_PROC_FS
-	proc_net_remove("if_inet6");
-#endif
-}
diff -Nurb linux-2.6.22-590/net/ipv6/af_inet6.c linux-2.6.22-try2-netns/net/ipv6/af_inet6.c
--- linux-2.6.22-590/net/ipv6/af_inet6.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/af_inet6.c	2007-12-19 22:49:20.000000000 -0500
@@ -82,7 +82,7 @@
 	return (struct ipv6_pinfo *)(((u8 *)sk) + offset);
 }
 
-static int inet6_create(struct socket *sock, int protocol)
+static int inet6_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct inet_sock *inet;
 	struct ipv6_pinfo *np;
@@ -95,6 +95,9 @@
 	int try_loading_module = 0;
 	int err;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	if (sock->type != SOCK_RAW &&
 	    sock->type != SOCK_DGRAM &&
 	    !inet_ehash_secret)
@@ -163,7 +166,7 @@
 	BUG_TRAP(answer_prot->slab != NULL);
 
 	err = -ENOBUFS;
-	sk = sk_alloc(PF_INET6, GFP_KERNEL, answer_prot, 1);
+	sk = sk_alloc(net, PF_INET6, GFP_KERNEL, answer_prot, 1);
 	if (sk == NULL)
 		goto out;
 
@@ -206,7 +209,7 @@
 	inet->mc_index	= 0;
 	inet->mc_list	= NULL;
 
-	if (ipv4_config.no_pmtu_disc)
+	if (init_net.sysctl_ipv4_no_pmtu_disc)
 		inet->pmtudisc = IP_PMTUDISC_DONT;
 	else
 		inet->pmtudisc = IP_PMTUDISC_WANT;
@@ -287,7 +290,7 @@
 	/* Check if the address belongs to the host. */
 	if (addr_type == IPV6_ADDR_MAPPED) {
 		v4addr = addr->sin6_addr.s6_addr32[3];
-		if (inet_addr_type(v4addr) != RTN_LOCAL) {
+		if (inet_addr_type(&init_net, v4addr) != RTN_LOCAL) {
 			err = -EADDRNOTAVAIL;
 			goto out;
 		}
@@ -313,7 +316,7 @@
 					err = -EINVAL;
 					goto out;
 				}
-				dev = dev_get_by_index(sk->sk_bound_dev_if);
+				dev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);
 				if (!dev) {
 					err = -ENODEV;
 					goto out;
@@ -672,6 +675,7 @@
 		struct flowi fl;
 
 		memset(&fl, 0, sizeof(fl));
+		fl.fl_net = &init_net;
 		fl.proto = sk->sk_protocol;
 		ipv6_addr_copy(&fl.fl6_dst, &np->daddr);
 		ipv6_addr_copy(&fl.fl6_src, &np->saddr);
diff -Nurb linux-2.6.22-590/net/ipv6/anycast.c linux-2.6.22-try2-netns/net/ipv6/anycast.c
--- linux-2.6.22-590/net/ipv6/anycast.c	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/anycast.c	2007-12-19 22:49:20.000000000 -0500
@@ -32,6 +32,7 @@
 
 #include <net/sock.h>
 #include <net/snmp.h>
+#include <net/net_namespace.h>
 
 #include <net/ipv6.h>
 #include <net/protocol.h>
@@ -112,10 +113,10 @@
 		} else {
 			/* router, no matching interface: just pick one */
 
-			dev = dev_get_by_flags(IFF_UP, IFF_UP|IFF_LOOPBACK);
+			dev = dev_get_by_flags(&init_net, IFF_UP, IFF_UP|IFF_LOOPBACK);
 		}
 	} else
-		dev = dev_get_by_index(ifindex);
+		dev = dev_get_by_index(&init_net, ifindex);
 
 	if (dev == NULL) {
 		err = -ENODEV;
@@ -196,7 +197,7 @@
 
 	write_unlock_bh(&ipv6_sk_ac_lock);
 
-	dev = dev_get_by_index(pac->acl_ifindex);
+	dev = dev_get_by_index(&init_net, pac->acl_ifindex);
 	if (dev) {
 		ipv6_dev_ac_dec(dev, &pac->acl_addr);
 		dev_put(dev);
@@ -224,7 +225,7 @@
 		if (pac->acl_ifindex != prev_index) {
 			if (dev)
 				dev_put(dev);
-			dev = dev_get_by_index(pac->acl_ifindex);
+			dev = dev_get_by_index(&init_net, pac->acl_ifindex);
 			prev_index = pac->acl_ifindex;
 		}
 		if (dev)
@@ -429,7 +430,7 @@
 	if (dev)
 		return ipv6_chk_acast_dev(dev, addr);
 	read_lock(&dev_base_lock);
-	for_each_netdev(dev)
+	for_each_netdev(&init_net, dev)
 		if (ipv6_chk_acast_dev(dev, addr)) {
 			found = 1;
 			break;
@@ -453,7 +454,7 @@
 	struct ac6_iter_state *state = ac6_seq_private(seq);
 
 	state->idev = NULL;
-	for_each_netdev(state->dev) {
+	for_each_netdev(&init_net, state->dev) {
 		struct inet6_dev *idev;
 		idev = in6_dev_get(state->dev);
 		if (!idev)
@@ -579,7 +580,7 @@
 
 int __init ac6_proc_init(void)
 {
-	if (!proc_net_fops_create("anycast6", S_IRUGO, &ac6_seq_fops))
+	if (!proc_net_fops_create(&init_net, "anycast6", S_IRUGO, &ac6_seq_fops))
 		return -ENOMEM;
 
 	return 0;
@@ -587,7 +588,7 @@
 
 void ac6_proc_exit(void)
 {
-	proc_net_remove("anycast6");
+	proc_net_remove(&init_net, "anycast6");
 }
 #endif
 
diff -Nurb linux-2.6.22-590/net/ipv6/datagram.c linux-2.6.22-try2-netns/net/ipv6/datagram.c
--- linux-2.6.22-590/net/ipv6/datagram.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/datagram.c	2007-12-19 22:49:20.000000000 -0500
@@ -60,6 +60,7 @@
 		return -EAFNOSUPPORT;
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	if (np->sndflow) {
 		fl.fl6_flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;
 		if (fl.fl6_flowlabel&IPV6_FLOWLABEL_MASK) {
@@ -544,7 +545,7 @@
 				if (!src_info->ipi6_ifindex)
 					return -EINVAL;
 				else {
-					dev = dev_get_by_index(src_info->ipi6_ifindex);
+					dev = dev_get_by_index(&init_net, src_info->ipi6_ifindex);
 					if (!dev)
 						return -ENODEV;
 				}
diff -Nurb linux-2.6.22-590/net/ipv6/fib6_rules.c linux-2.6.22-try2-netns/net/ipv6/fib6_rules.c
--- linux-2.6.22-590/net/ipv6/fib6_rules.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/fib6_rules.c	2007-12-19 22:49:20.000000000 -0500
@@ -244,7 +244,7 @@
 	return -ENOBUFS;
 }
 
-static u32 fib6_rule_default_pref(void)
+static u32 fib6_rule_default_pref(struct fib_rules_ops *ops)
 {
 	return 0x3FFF;
 }
@@ -277,10 +277,10 @@
 	list_add_tail(&local_rule.common.list, &fib6_rules);
 	list_add_tail(&main_rule.common.list, &fib6_rules);
 
-	fib_rules_register(&fib6_rules_ops);
+	fib_rules_register(&init_net, &fib6_rules_ops);
 }
 
 void fib6_rules_cleanup(void)
 {
-	fib_rules_unregister(&fib6_rules_ops);
+	fib_rules_unregister(&init_net, &fib6_rules_ops);
 }
diff -Nurb linux-2.6.22-590/net/ipv6/icmp.c linux-2.6.22-try2-netns/net/ipv6/icmp.c
--- linux-2.6.22-590/net/ipv6/icmp.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/icmp.c	2007-12-19 22:49:20.000000000 -0500
@@ -377,6 +377,7 @@
 	mip6_addr_swap(skb);
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	fl.proto = IPPROTO_ICMPV6;
 	ipv6_addr_copy(&fl.fl6_dst, &hdr->saddr);
 	if (saddr)
@@ -495,6 +496,7 @@
 	tmp_hdr.icmp6_type = ICMPV6_ECHO_REPLY;
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	fl.proto = IPPROTO_ICMPV6;
 	ipv6_addr_copy(&fl.fl6_dst, &ipv6_hdr(skb)->saddr);
 	if (saddr)
diff -Nurb linux-2.6.22-590/net/ipv6/inet6_connection_sock.c linux-2.6.22-try2-netns/net/ipv6/inet6_connection_sock.c
--- linux-2.6.22-590/net/ipv6/inet6_connection_sock.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/inet6_connection_sock.c	2007-12-19 22:49:20.000000000 -0500
@@ -149,6 +149,7 @@
 	struct in6_addr *final_p = NULL, final;
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	fl.proto = sk->sk_protocol;
 	ipv6_addr_copy(&fl.fl6_dst, &np->daddr);
 	ipv6_addr_copy(&fl.fl6_src, &np->saddr);
diff -Nurb linux-2.6.22-590/net/ipv6/inet6_hashtables.c linux-2.6.22-try2-netns/net/ipv6/inet6_hashtables.c
--- linux-2.6.22-590/net/ipv6/inet6_hashtables.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/inet6_hashtables.c	2007-12-19 22:49:20.000000000 -0500
@@ -61,7 +61,7 @@
 					   const __be16 sport,
 					   const struct in6_addr *daddr,
 					   const u16 hnum,
-					   const int dif)
+					   const int dif, struct net *net)
 {
 	struct sock *sk;
 	const struct hlist_node *node;
@@ -105,7 +105,7 @@
 
 struct sock *inet6_lookup_listener(struct inet_hashinfo *hashinfo,
 				   const struct in6_addr *daddr,
-				   const unsigned short hnum, const int dif)
+				   const unsigned short hnum, const int dif, struct net *net)
 {
 	struct sock *sk;
 	const struct hlist_node *node;
@@ -113,7 +113,7 @@
 	int score, hiscore = 0;
 
 	read_lock(&hashinfo->lhash_lock);
-	sk_for_each(sk, node, &hashinfo->listening_hash[inet_lhashfn(hnum)]) {
+	sk_for_each(sk, node, &hashinfo->listening_hash[inet_lhashfn(net, hnum)]) {
 		if (inet_sk(sk)->num == hnum && sk->sk_family == PF_INET6) {
 			const struct ipv6_pinfo *np = inet6_sk(sk);
 
@@ -152,12 +152,12 @@
 struct sock *inet6_lookup(struct inet_hashinfo *hashinfo,
 			  const struct in6_addr *saddr, const __be16 sport,
 			  const struct in6_addr *daddr, const __be16 dport,
-			  const int dif)
+			  const int dif, struct net *net)
 {
 	struct sock *sk;
 
 	local_bh_disable();
-	sk = __inet6_lookup(hashinfo, saddr, sport, daddr, ntohs(dport), dif);
+	sk = __inet6_lookup(hashinfo, saddr, sport, daddr, ntohs(dport), dif, net);
 	local_bh_enable();
 
 	return sk;
@@ -251,6 +251,7 @@
 int inet6_hash_connect(struct inet_timewait_death_row *death_row,
 		       struct sock *sk)
 {
+	struct net *net = sk->sk_net;
 	struct inet_hashinfo *hinfo = death_row->hashinfo;
 	const unsigned short snum = inet_sk(sk)->num;
 	struct inet_bind_hashbucket *head;
@@ -258,8 +259,8 @@
 	int ret;
 
 	if (snum == 0) {
-		const int low = sysctl_local_port_range[0];
-		const int high = sysctl_local_port_range[1];
+		const int low = sk->sk_net->sysctl_local_port_range[0];
+		const int high = sk->sk_net->sysctl_local_port_range[1];
 		const int range = high - low;
 		int i, port;
 		static u32 hint;
@@ -270,7 +271,7 @@
 		local_bh_disable();
 		for (i = 1; i <= range; i++) {
 			port = low + (i + offset) % range;
-			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
+			head = &hinfo->bhash[inet_bhashfn(net, port, hinfo->bhash_size)];
 			spin_lock(&head->lock);
 
 			/* Does not bother with rcv_saddr checks,
@@ -278,7 +279,7 @@
 			 * unique enough.
 			 */
 			inet_bind_bucket_for_each(tb, node, &head->chain) {
-				if (tb->port == port) {
+				if ((tb->port == port) && (tb->net == net)) {
 					BUG_TRAP(!hlist_empty(&tb->owners));
 					if (tb->fastreuse >= 0)
 						goto next_port;
@@ -291,7 +292,7 @@
 			}
 
 			tb = inet_bind_bucket_create(hinfo->bind_bucket_cachep,
-						     head, port);
+						     head, net, port);
 			if (!tb) {
 				spin_unlock(&head->lock);
 				break;
@@ -326,7 +327,7 @@
 		goto out;
 	}
 
-	head = &hinfo->bhash[inet_bhashfn(snum, hinfo->bhash_size)];
+	head = &hinfo->bhash[inet_bhashfn(net, snum, hinfo->bhash_size)];
 	tb   = inet_csk(sk)->icsk_bind_hash;
 	spin_lock_bh(&head->lock);
 
diff -Nurb linux-2.6.22-590/net/ipv6/ip6_fib.c linux-2.6.22-try2-netns/net/ipv6/ip6_fib.c
--- linux-2.6.22-590/net/ipv6/ip6_fib.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/ip6_fib.c	2007-12-19 22:49:20.000000000 -0500
@@ -361,6 +361,7 @@
 
 static int inet6_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	unsigned int h, s_h;
 	unsigned int e = 0, s_e;
 	struct rt6_rtnl_dump_arg arg;
@@ -369,6 +370,9 @@
 	struct hlist_node *node;
 	int res = 0;
 
+	if (net != &init_net)
+		return 0;
+
 	s_h = cb->args[0];
 	s_e = cb->args[1];
 
@@ -1311,6 +1315,11 @@
 
 static int fib6_clean_node(struct fib6_walker_t *w)
 {
+	struct nl_info info = {
+		.nlh = NULL,
+		.pid = 0,
+		.net = &init_net,
+	};
 	int res;
 	struct rt6_info *rt;
 	struct fib6_cleaner_t *c = (struct fib6_cleaner_t*)w;
@@ -1319,7 +1328,7 @@
 		res = c->func(rt, c->arg);
 		if (res < 0) {
 			w->leaf = rt;
-			res = fib6_del(rt, NULL);
+			res = fib6_del(rt, &info);
 			if (res) {
 #if RT6_DEBUG >= 2
 				printk(KERN_DEBUG "fib6_clean_node: del failed: rt=%p@%p err=%d\n", rt, rt->rt6i_node, res);
diff -Nurb linux-2.6.22-590/net/ipv6/ip6_flowlabel.c linux-2.6.22-try2-netns/net/ipv6/ip6_flowlabel.c
--- linux-2.6.22-590/net/ipv6/ip6_flowlabel.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/ip6_flowlabel.c	2007-12-19 22:49:20.000000000 -0500
@@ -22,6 +22,7 @@
 #include <linux/seq_file.h>
 
 #include <net/sock.h>
+#include <net/net_namespace.h>
 
 #include <net/ipv6.h>
 #include <net/ndisc.h>
@@ -309,6 +310,7 @@
 
 		msg.msg_controllen = olen;
 		msg.msg_control = (void*)(fl->opt+1);
+		flowi.fl_net = &init_net;
 		flowi.oif = 0;
 
 		err = datagram_send_ctl(&msg, &flowi, fl->opt, &junk, &junk);
@@ -690,7 +692,7 @@
 void ip6_flowlabel_init(void)
 {
 #ifdef CONFIG_PROC_FS
-	proc_net_fops_create("ip6_flowlabel", S_IRUGO, &ip6fl_seq_fops);
+	proc_net_fops_create(&init_net, "ip6_flowlabel", S_IRUGO, &ip6fl_seq_fops);
 #endif
 }
 
@@ -698,6 +700,6 @@
 {
 	del_timer(&ip6_fl_gc_timer);
 #ifdef CONFIG_PROC_FS
-	proc_net_remove("ip6_flowlabel");
+	proc_net_remove(&init_net, "ip6_flowlabel");
 #endif
 }
diff -Nurb linux-2.6.22-590/net/ipv6/ip6_input.c linux-2.6.22-try2-netns/net/ipv6/ip6_input.c
--- linux-2.6.22-590/net/ipv6/ip6_input.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/ip6_input.c	2007-12-19 22:49:20.000000000 -0500
@@ -61,6 +61,11 @@
 	u32 		pkt_len;
 	struct inet6_dev *idev;
 
+	if (dev->nd_net != &init_net) {
+		kfree_skb(skb);
+		return 0;
+	}
+
 	if (skb->pkt_type == PACKET_OTHERHOST) {
 		kfree_skb(skb);
 		return 0;
diff -Nurb linux-2.6.22-590/net/ipv6/ip6_output.c linux-2.6.22-try2-netns/net/ipv6/ip6_output.c
--- linux-2.6.22-590/net/ipv6/ip6_output.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/ip6_output.c	2007-12-19 22:49:20.000000000 -0500
@@ -423,7 +423,7 @@
 
 	/* XXX: idev->cnf.proxy_ndp? */
 	if (ipv6_devconf.proxy_ndp &&
-	    pneigh_lookup(&nd_tbl, &hdr->daddr, skb->dev, 0)) {
+	    pneigh_lookup(&nd_tbl, &init_net, &hdr->daddr, skb->dev, 0)) {
 		int proxied = ip6_forward_proxy_check(skb);
 		if (proxied > 0)
 			return ip6_input(skb);
diff -Nurb linux-2.6.22-590/net/ipv6/ip6_tunnel.c linux-2.6.22-try2-netns/net/ipv6/ip6_tunnel.c
--- linux-2.6.22-590/net/ipv6/ip6_tunnel.c	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/ip6_tunnel.c	2007-12-19 22:49:20.000000000 -0500
@@ -235,7 +235,7 @@
 		int i;
 		for (i = 1; i < IP6_TNL_MAX; i++) {
 			sprintf(name, "ip6tnl%d", i);
-			if (__dev_get_by_name(name) == NULL)
+			if (__dev_get_by_name(&init_net, name) == NULL)
 				break;
 		}
 		if (i == IP6_TNL_MAX)
@@ -651,7 +651,7 @@
 		struct net_device *ldev = NULL;
 
 		if (p->link)
-			ldev = dev_get_by_index(p->link);
+			ldev = dev_get_by_index(&init_net, p->link);
 
 		if ((ipv6_addr_is_multicast(&p->laddr) ||
 		     likely(ipv6_chk_addr(&p->laddr, ldev, 0))) &&
@@ -787,7 +787,7 @@
 		struct net_device *ldev = NULL;
 
 		if (p->link)
-			ldev = dev_get_by_index(p->link);
+			ldev = dev_get_by_index(&init_net, p->link);
 
 		if (unlikely(!ipv6_chk_addr(&p->laddr, ldev, 0)))
 			printk(KERN_WARNING
diff -Nurb linux-2.6.22-590/net/ipv6/ipv6_sockglue.c linux-2.6.22-try2-netns/net/ipv6/ipv6_sockglue.c
--- linux-2.6.22-590/net/ipv6/ipv6_sockglue.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/ipv6_sockglue.c	2007-12-19 22:49:20.000000000 -0500
@@ -463,6 +463,7 @@
 		struct flowi fl;
 		int junk;
 
+		fl.fl_net = &init_net;
 		fl.fl6_flowlabel = 0;
 		fl.oif = sk->sk_bound_dev_if;
 
@@ -547,7 +548,7 @@
 		if (sk->sk_bound_dev_if && sk->sk_bound_dev_if != val)
 			goto e_inval;
 
-		if (__dev_get_by_index(val) == NULL) {
+		if (__dev_get_by_index(&init_net, val) == NULL) {
 			retv = -ENODEV;
 			break;
 		}
diff -Nurb linux-2.6.22-590/net/ipv6/mcast.c linux-2.6.22-try2-netns/net/ipv6/mcast.c
--- linux-2.6.22-590/net/ipv6/mcast.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/mcast.c	2007-12-19 22:49:20.000000000 -0500
@@ -51,6 +51,7 @@
 
 #include <net/sock.h>
 #include <net/snmp.h>
+#include <net/net_namespace.h>
 
 #include <net/ipv6.h>
 #include <net/protocol.h>
@@ -214,7 +215,7 @@
 			dst_release(&rt->u.dst);
 		}
 	} else
-		dev = dev_get_by_index(ifindex);
+		dev = dev_get_by_index(&init_net, ifindex);
 
 	if (dev == NULL) {
 		sock_kfree_s(sk, mc_lst, sizeof(*mc_lst));
@@ -265,7 +266,7 @@
 			*lnk = mc_lst->next;
 			write_unlock_bh(&ipv6_sk_mc_lock);
 
-			if ((dev = dev_get_by_index(mc_lst->ifindex)) != NULL) {
+			if ((dev = dev_get_by_index(&init_net, mc_lst->ifindex)) != NULL) {
 				struct inet6_dev *idev = in6_dev_get(dev);
 
 				(void) ip6_mc_leave_src(sk, mc_lst, idev);
@@ -300,7 +301,7 @@
 			dst_release(&rt->u.dst);
 		}
 	} else
-		dev = dev_get_by_index(ifindex);
+		dev = dev_get_by_index(&init_net, ifindex);
 
 	if (!dev)
 		return NULL;
@@ -331,7 +332,7 @@
 		np->ipv6_mc_list = mc_lst->next;
 		write_unlock_bh(&ipv6_sk_mc_lock);
 
-		dev = dev_get_by_index(mc_lst->ifindex);
+		dev = dev_get_by_index(&init_net, mc_lst->ifindex);
 		if (dev) {
 			struct inet6_dev *idev = in6_dev_get(dev);
 
@@ -2332,7 +2333,7 @@
 	struct igmp6_mc_iter_state *state = igmp6_mc_seq_private(seq);
 
 	state->idev = NULL;
-	for_each_netdev(state->dev) {
+	for_each_netdev(&init_net, state->dev) {
 		struct inet6_dev *idev;
 		idev = in6_dev_get(state->dev);
 		if (!idev)
@@ -2476,7 +2477,7 @@
 
 	state->idev = NULL;
 	state->im = NULL;
-	for_each_netdev(state->dev) {
+	for_each_netdev(&init_net, state->dev) {
 		struct inet6_dev *idev;
 		idev = in6_dev_get(state->dev);
 		if (unlikely(idev == NULL))
@@ -2658,8 +2659,8 @@
 	np->hop_limit = 1;
 
 #ifdef CONFIG_PROC_FS
-	proc_net_fops_create("igmp6", S_IRUGO, &igmp6_mc_seq_fops);
-	proc_net_fops_create("mcfilter6", S_IRUGO, &igmp6_mcf_seq_fops);
+	proc_net_fops_create(&init_net, "igmp6", S_IRUGO, &igmp6_mc_seq_fops);
+	proc_net_fops_create(&init_net, "mcfilter6", S_IRUGO, &igmp6_mcf_seq_fops);
 #endif
 
 	return 0;
@@ -2671,7 +2672,7 @@
 	igmp6_socket = NULL; /* for safety */
 
 #ifdef CONFIG_PROC_FS
-	proc_net_remove("mcfilter6");
-	proc_net_remove("igmp6");
+	proc_net_remove(&init_net, "mcfilter6");
+	proc_net_remove(&init_net, "igmp6");
 #endif
 }
diff -Nurb linux-2.6.22-590/net/ipv6/ndisc.c linux-2.6.22-try2-netns/net/ipv6/ndisc.c
--- linux-2.6.22-590/net/ipv6/ndisc.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/ndisc.c	2007-12-19 22:49:20.000000000 -0500
@@ -418,6 +418,7 @@
 			    int oif)
 {
 	memset(fl, 0, sizeof(*fl));
+	fl->fl_net = &init_net;
 	ipv6_addr_copy(&fl->fl6_src, saddr);
 	ipv6_addr_copy(&fl->fl6_dst, daddr);
 	fl->proto	 	= IPPROTO_ICMPV6;
@@ -760,7 +761,7 @@
 		if (ipv6_chk_acast_addr(dev, &msg->target) ||
 		    (idev->cnf.forwarding &&
 		     (ipv6_devconf.proxy_ndp || idev->cnf.proxy_ndp) &&
-		     (pneigh = pneigh_lookup(&nd_tbl,
+		     (pneigh = pneigh_lookup(&nd_tbl, &init_net,
 					     &msg->target, dev, 0)) != NULL)) {
 			if (!(NEIGH_CB(skb)->flags & LOCALLY_ENQUEUED) &&
 			    skb->pkt_type != PACKET_HOST &&
@@ -901,7 +902,7 @@
 		 */
 		if (lladdr && !memcmp(lladdr, dev->dev_addr, dev->addr_len) &&
 		    ipv6_devconf.forwarding && ipv6_devconf.proxy_ndp &&
-		    pneigh_lookup(&nd_tbl, &msg->target, dev, 0)) {
+		    pneigh_lookup(&nd_tbl, &init_net, &msg->target, dev, 0)) {
 			/* XXX: idev->cnf.prixy_ndp */
 			goto out;
 		}
@@ -1525,6 +1526,9 @@
 {
 	struct net_device *dev = ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	switch (event) {
 	case NETDEV_CHANGEADDR:
 		neigh_changeaddr(&nd_tbl, dev);
diff -Nurb linux-2.6.22-590/net/ipv6/netfilter/ip6_queue.c linux-2.6.22-try2-netns/net/ipv6/netfilter/ip6_queue.c
--- linux-2.6.22-590/net/ipv6/netfilter/ip6_queue.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/netfilter/ip6_queue.c	2007-12-19 22:49:20.000000000 -0500
@@ -24,6 +24,7 @@
 #include <linux/sysctl.h>
 #include <linux/proc_fs.h>
 #include <linux/mutex.h>
+#include <net/net_namespace.h>
 #include <net/sock.h>
 #include <net/ipv6.h>
 #include <net/ip6_route.h>
@@ -546,6 +547,9 @@
 {
 	struct net_device *dev = ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	/* Drop any packets associated with the downed device */
 	if (event == NETDEV_DOWN)
 		ipq_dev_drop(dev->ifindex);
@@ -565,7 +569,7 @@
 	if (event == NETLINK_URELEASE &&
 	    n->protocol == NETLINK_IP6_FW && n->pid) {
 		write_lock_bh(&queue_lock);
-		if (n->pid == peer_pid)
+		if ((n->net == &init_net) && (n->pid == peer_pid))
 			__ipq_reset();
 		write_unlock_bh(&queue_lock);
 	}
@@ -657,14 +661,14 @@
 	struct proc_dir_entry *proc;
 
 	netlink_register_notifier(&ipq_nl_notifier);
-	ipqnl = netlink_kernel_create(NETLINK_IP6_FW, 0, ipq_rcv_sk, NULL,
-				      THIS_MODULE);
+	ipqnl = netlink_kernel_create(&init_net, NETLINK_IP6_FW, 0, ipq_rcv_sk,
+					NULL, THIS_MODULE);
 	if (ipqnl == NULL) {
 		printk(KERN_ERR "ip6_queue: failed to create netlink socket\n");
 		goto cleanup_netlink_notifier;
 	}
 
-	proc = proc_net_create(IPQ_PROC_FS_NAME, 0, ipq_get_info);
+	proc = proc_net_create(&init_net, IPQ_PROC_FS_NAME, 0, ipq_get_info);
 	if (proc)
 		proc->owner = THIS_MODULE;
 	else {
@@ -685,7 +689,7 @@
 cleanup_sysctl:
 	unregister_sysctl_table(ipq_sysctl_header);
 	unregister_netdevice_notifier(&ipq_dev_notifier);
-	proc_net_remove(IPQ_PROC_FS_NAME);
+	proc_net_remove(&init_net, IPQ_PROC_FS_NAME);
 
 cleanup_ipqnl:
 	sock_release(ipqnl->sk_socket);
@@ -705,7 +709,7 @@
 
 	unregister_sysctl_table(ipq_sysctl_header);
 	unregister_netdevice_notifier(&ipq_dev_notifier);
-	proc_net_remove(IPQ_PROC_FS_NAME);
+	proc_net_remove(&init_net, IPQ_PROC_FS_NAME);
 
 	sock_release(ipqnl->sk_socket);
 	mutex_lock(&ipqnl_mutex);
diff -Nurb linux-2.6.22-590/net/ipv6/netfilter/ip6_tables.c linux-2.6.22-try2-netns/net/ipv6/netfilter/ip6_tables.c
--- linux-2.6.22-590/net/ipv6/netfilter/ip6_tables.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/netfilter/ip6_tables.c	2007-12-19 22:49:20.000000000 -0500
@@ -906,7 +906,7 @@
 	int ret;
 	struct xt_table *t;
 
-	t = xt_find_table_lock(AF_INET6, entries->name);
+	t = xt_find_table_lock(&init_net, AF_INET6, entries->name);
 	if (t && !IS_ERR(t)) {
 		struct xt_table_info *private = t->private;
 		duprintf("t->private->number = %u\n", private->number);
@@ -972,7 +972,7 @@
 
 	duprintf("ip_tables: Translated table\n");
 
-	t = try_then_request_module(xt_find_table_lock(AF_INET6, tmp.name),
+	t = try_then_request_module(xt_find_table_lock(&init_net, AF_INET6, tmp.name),
 				    "ip6table_%s", tmp.name);
 	if (!t || IS_ERR(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
@@ -1073,7 +1073,7 @@
 		goto free;
 	}
 
-	t = xt_find_table_lock(AF_INET6, tmp.name);
+	t = xt_find_table_lock(&init_net, AF_INET6, tmp.name);
 	if (!t || IS_ERR(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
 		goto free;
@@ -1109,6 +1109,9 @@
 {
 	int ret;
 
+	if (sk->sk_net != &init_net)
+		return -ENOPROTOOPT;
+
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
@@ -1134,6 +1137,9 @@
 {
 	int ret;
 
+	if (sk->sk_net != &init_net)
+		return -ENOPROTOOPT;
+
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
@@ -1155,7 +1161,7 @@
 		}
 		name[IP6T_TABLE_MAXNAMELEN-1] = '\0';
 
-		t = try_then_request_module(xt_find_table_lock(AF_INET6, name),
+		t = try_then_request_module(xt_find_table_lock(&init_net, AF_INET6, name),
 					    "ip6table_%s", name);
 		if (t && !IS_ERR(t)) {
 			struct ip6t_getinfo info;
@@ -1259,7 +1265,7 @@
 		return ret;
 	}
 
-	ret = xt_register_table(table, &bootstrap, newinfo);
+	ret = xt_register_table(&init_net, table, &bootstrap, newinfo);
 	if (ret != 0) {
 		xt_free_table_info(newinfo);
 		return ret;
diff -Nurb linux-2.6.22-590/net/ipv6/netfilter/ip6t_REJECT.c linux-2.6.22-try2-netns/net/ipv6/netfilter/ip6t_REJECT.c
--- linux-2.6.22-590/net/ipv6/netfilter/ip6t_REJECT.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/netfilter/ip6t_REJECT.c	2007-12-19 22:49:20.000000000 -0500
@@ -92,6 +92,7 @@
 	}
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	fl.proto = IPPROTO_TCP;
 	ipv6_addr_copy(&fl.fl6_src, &oip6h->daddr);
 	ipv6_addr_copy(&fl.fl6_dst, &oip6h->saddr);
@@ -172,7 +173,7 @@
 send_unreach(struct sk_buff *skb_in, unsigned char code, unsigned int hooknum)
 {
 	if (hooknum == NF_IP6_LOCAL_OUT && skb_in->dev == NULL)
-		skb_in->dev = &loopback_dev;
+		skb_in->dev = &init_net.loopback_dev;
 
 	icmpv6_send(skb_in, ICMPV6_DEST_UNREACH, code, 0, NULL);
 }
diff -Nurb linux-2.6.22-590/net/ipv6/netfilter/ip6table_filter.c linux-2.6.22-try2-netns/net/ipv6/netfilter/ip6table_filter.c
--- linux-2.6.22-590/net/ipv6/netfilter/ip6table_filter.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/netfilter/ip6table_filter.c	2007-12-19 22:49:20.000000000 -0500
@@ -65,6 +65,10 @@
 	 const struct net_device *out,
 	 int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	return ip6t_do_table(pskb, hook, in, out, &packet_filter);
 }
 
@@ -75,6 +79,10 @@
 		   const struct net_device *out,
 		   int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 #if 0
 	/* root is playing with raw sockets. */
 	if ((*pskb)->len < sizeof(struct iphdr)
diff -Nurb linux-2.6.22-590/net/ipv6/netfilter/ip6table_mangle.c linux-2.6.22-try2-netns/net/ipv6/netfilter/ip6table_mangle.c
--- linux-2.6.22-590/net/ipv6/netfilter/ip6table_mangle.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/netfilter/ip6table_mangle.c	2007-12-19 22:49:20.000000000 -0500
@@ -79,6 +79,10 @@
 	 const struct net_device *out,
 	 int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	return ip6t_do_table(pskb, hook, in, out, &packet_mangler);
 }
 
@@ -95,6 +99,10 @@
 	u_int8_t hop_limit;
 	u_int32_t flowlabel, mark;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 #if 0
 	/* root is playing with raw sockets. */
 	if ((*pskb)->len < sizeof(struct iphdr)
diff -Nurb linux-2.6.22-590/net/ipv6/netfilter/ip6table_raw.c linux-2.6.22-try2-netns/net/ipv6/netfilter/ip6table_raw.c
--- linux-2.6.22-590/net/ipv6/netfilter/ip6table_raw.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/netfilter/ip6table_raw.c	2007-12-19 22:49:20.000000000 -0500
@@ -57,6 +57,10 @@
 	 const struct net_device *out,
 	 int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	return ip6t_do_table(pskb, hook, in, out, &packet_raw);
 }
 
diff -Nurb linux-2.6.22-590/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c linux-2.6.22-try2-netns/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
--- linux-2.6.22-590/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c	2007-12-19 22:49:20.000000000 -0500
@@ -167,6 +167,10 @@
 	unsigned char pnum = ipv6_hdr(*pskb)->nexthdr;
 
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	/* This is where we call the helper: as the packet goes out. */
 	ct = nf_ct_get(*pskb, &ctinfo);
 	if (!ct || ctinfo == IP_CT_RELATED + IP_CT_IS_REPLY)
@@ -203,6 +207,10 @@
 {
 	struct sk_buff *reasm;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	/* Previously seen (loopback)?  */
 	if ((*pskb)->nfct)
 		return NF_ACCEPT;
@@ -231,6 +239,10 @@
 {
 	struct sk_buff *reasm = (*pskb)->nfct_reasm;
 
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	/* This packet is fragmented and has reassembled packet. */
 	if (reasm) {
 		/* Reassembled packet isn't parsed yet ? */
@@ -256,6 +268,10 @@
 					 const struct net_device *out,
 					 int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	/* root is playing with raw sockets. */
 	if ((*pskb)->len < sizeof(struct ipv6hdr)) {
 		if (net_ratelimit())
diff -Nurb linux-2.6.22-590/net/ipv6/netfilter.c linux-2.6.22-try2-netns/net/ipv6/netfilter.c
--- linux-2.6.22-590/net/ipv6/netfilter.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/netfilter.c	2007-12-19 22:49:20.000000000 -0500
@@ -14,6 +14,7 @@
 	struct ipv6hdr *iph = ipv6_hdr(skb);
 	struct dst_entry *dst;
 	struct flowi fl = {
+		.fl_net = &init_net,
 		.oif = skb->sk ? skb->sk->sk_bound_dev_if : 0,
 		.mark = skb->mark,
 		.nl_u =
diff -Nurb linux-2.6.22-590/net/ipv6/proc.c linux-2.6.22-try2-netns/net/ipv6/proc.c
--- linux-2.6.22-590/net/ipv6/proc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/proc.c	2007-12-19 22:49:20.000000000 -0500
@@ -28,6 +28,7 @@
 #include <net/tcp.h>
 #include <net/transp_v6.h>
 #include <net/ipv6.h>
+#include <net/net_namespace.h>
 
 static struct proc_dir_entry *proc_net_devsnmp6;
 
@@ -231,22 +232,22 @@
 {
 	int rc = 0;
 
-	if (!proc_net_fops_create("snmp6", S_IRUGO, &snmp6_seq_fops))
+	if (!proc_net_fops_create(&init_net, "snmp6", S_IRUGO, &snmp6_seq_fops))
 		goto proc_snmp6_fail;
 
-	proc_net_devsnmp6 = proc_mkdir("dev_snmp6", proc_net);
+	proc_net_devsnmp6 = proc_mkdir("dev_snmp6", init_net.proc_net);
 	if (!proc_net_devsnmp6)
 		goto proc_dev_snmp6_fail;
 
-	if (!proc_net_fops_create("sockstat6", S_IRUGO, &sockstat6_seq_fops))
+	if (!proc_net_fops_create(&init_net, "sockstat6", S_IRUGO, &sockstat6_seq_fops))
 		goto proc_sockstat6_fail;
 out:
 	return rc;
 
 proc_sockstat6_fail:
-	proc_net_remove("dev_snmp6");
+	proc_net_remove(&init_net, "dev_snmp6");
 proc_dev_snmp6_fail:
-	proc_net_remove("snmp6");
+	proc_net_remove(&init_net, "snmp6");
 proc_snmp6_fail:
 	rc = -ENOMEM;
 	goto out;
@@ -254,8 +255,8 @@
 
 void ipv6_misc_proc_exit(void)
 {
-	proc_net_remove("sockstat6");
-	proc_net_remove("dev_snmp6");
-	proc_net_remove("snmp6");
+	proc_net_remove(&init_net, "sockstat6");
+	proc_net_remove(&init_net, "dev_snmp6");
+	proc_net_remove(&init_net, "snmp6");
 }
 
diff -Nurb linux-2.6.22-590/net/ipv6/raw.c linux-2.6.22-try2-netns/net/ipv6/raw.c
--- linux-2.6.22-590/net/ipv6/raw.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/raw.c	2007-12-19 22:49:20.000000000 -0500
@@ -49,6 +49,7 @@
 #include <net/udp.h>
 #include <net/inet_common.h>
 #include <net/tcp_states.h>
+#include <net/net_namespace.h>
 #if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
 #include <net/mip6.h>
 #endif
@@ -282,7 +283,7 @@
 			if (!sk->sk_bound_dev_if)
 				goto out;
 
-			dev = dev_get_by_index(sk->sk_bound_dev_if);
+			dev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);
 			if (!dev) {
 				err = -ENODEV;
 				goto out;
@@ -728,6 +729,7 @@
 	 *	Get and verify the address.
 	 */
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 
 	if (sin6) {
 		if (addr_len < SIN6_LEN_RFC2133)
@@ -1315,13 +1317,13 @@
 
 int __init raw6_proc_init(void)
 {
-	if (!proc_net_fops_create("raw6", S_IRUGO, &raw6_seq_fops))
+	if (!proc_net_fops_create(&init_net, "raw6", S_IRUGO, &raw6_seq_fops))
 		return -ENOMEM;
 	return 0;
 }
 
 void raw6_proc_exit(void)
 {
-	proc_net_remove("raw6");
+	proc_net_remove(&init_net, "raw6");
 }
 #endif	/* CONFIG_PROC_FS */
diff -Nurb linux-2.6.22-590/net/ipv6/reassembly.c linux-2.6.22-try2-netns/net/ipv6/reassembly.c
--- linux-2.6.22-590/net/ipv6/reassembly.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/reassembly.c	2007-12-19 22:49:20.000000000 -0500
@@ -301,7 +301,7 @@
 
 	fq_kill(fq);
 
-	dev = dev_get_by_index(fq->iif);
+	dev = dev_get_by_index(&init_net, fq->iif);
 	if (!dev)
 		goto out;
 
diff -Nurb linux-2.6.22-590/net/ipv6/route.c linux-2.6.22-try2-netns/net/ipv6/route.c
--- linux-2.6.22-590/net/ipv6/route.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/route.c	2007-12-19 22:49:20.000000000 -0500
@@ -56,6 +56,7 @@
 #include <net/xfrm.h>
 #include <net/netevent.h>
 #include <net/netlink.h>
+#include <net/net_namespace.h>
 
 #include <asm/uaccess.h>
 
@@ -137,7 +138,7 @@
 		.dst = {
 			.__refcnt	= ATOMIC_INIT(1),
 			.__use		= 1,
-			.dev		= &loopback_dev,
+			.dev		= NULL,
 			.obsolete	= -1,
 			.error		= -ENETUNREACH,
 			.metrics	= { [RTAX_HOPLIMIT - 1] = 255, },
@@ -163,7 +164,7 @@
 		.dst = {
 			.__refcnt	= ATOMIC_INIT(1),
 			.__use		= 1,
-			.dev		= &loopback_dev,
+			.dev		= NULL,
 			.obsolete	= -1,
 			.error		= -EACCES,
 			.metrics	= { [RTAX_HOPLIMIT - 1] = 255, },
@@ -183,7 +184,7 @@
 		.dst = {
 			.__refcnt	= ATOMIC_INIT(1),
 			.__use		= 1,
-			.dev		= &loopback_dev,
+			.dev		= NULL,
 			.obsolete	= -1,
 			.error		= -EINVAL,
 			.metrics	= { [RTAX_HOPLIMIT - 1] = 255, },
@@ -223,8 +224,8 @@
 	struct rt6_info *rt = (struct rt6_info *)dst;
 	struct inet6_dev *idev = rt->rt6i_idev;
 
-	if (dev != &loopback_dev && idev != NULL && idev->dev == dev) {
-		struct inet6_dev *loopback_idev = in6_dev_get(&loopback_dev);
+	if (dev != &init_net.loopback_dev && idev != NULL && idev->dev == dev) {
+		struct inet6_dev *loopback_idev = in6_dev_get(&init_net.loopback_dev);
 		if (loopback_idev != NULL) {
 			rt->rt6i_idev = loopback_idev;
 			in6_dev_put(idev);
@@ -564,6 +565,7 @@
 			    int oif, int strict)
 {
 	struct flowi fl = {
+		.fl_net = &init_net,
 		.oif = oif,
 		.nl_u = {
 			.ip6_u = {
@@ -611,7 +613,12 @@
 
 int ip6_ins_rt(struct rt6_info *rt)
 {
-	return __ip6_ins_rt(rt, NULL);
+	struct nl_info info = {
+		.nlh = NULL,
+		.pid = 0,
+		.net = &init_net,
+	};
+	return __ip6_ins_rt(rt, &info);
 }
 
 static struct rt6_info *rt6_alloc_cow(struct rt6_info *ort, struct in6_addr *daddr,
@@ -742,6 +749,7 @@
 	struct ipv6hdr *iph = ipv6_hdr(skb);
 	int flags = RT6_LOOKUP_F_HAS_SADDR;
 	struct flowi fl = {
+		.fl_net = &init_net,
 		.iif = skb->dev->ifindex,
 		.nl_u = {
 			.ip6_u = {
@@ -1129,7 +1137,7 @@
 #endif
 	if (cfg->fc_ifindex) {
 		err = -ENODEV;
-		dev = dev_get_by_index(cfg->fc_ifindex);
+		dev = dev_get_by_index(&init_net, cfg->fc_ifindex);
 		if (!dev)
 			goto out;
 		idev = in6_dev_get(dev);
@@ -1187,12 +1195,12 @@
 	if ((cfg->fc_flags & RTF_REJECT) ||
 	    (dev && (dev->flags&IFF_LOOPBACK) && !(addr_type&IPV6_ADDR_LOOPBACK))) {
 		/* hold loopback dev/idev if we haven't done so. */
-		if (dev != &loopback_dev) {
+		if (dev != &init_net.loopback_dev) {
 			if (dev) {
 				dev_put(dev);
 				in6_dev_put(idev);
 			}
-			dev = &loopback_dev;
+			dev = &init_net.loopback_dev;
 			dev_hold(dev);
 			idev = in6_dev_get(dev);
 			if (!idev) {
@@ -1333,7 +1341,12 @@
 
 int ip6_del_rt(struct rt6_info *rt)
 {
-	return __ip6_del_rt(rt, NULL);
+	struct nl_info info = {
+		.nlh = NULL,
+		.pid = 0,
+		.net = &init_net,
+	};
+	return __ip6_del_rt(rt, &info);
 }
 
 static int ip6_route_del(struct fib6_config *cfg)
@@ -1444,6 +1457,7 @@
 	int flags = RT6_LOOKUP_F_HAS_SADDR;
 	struct ip6rd_flowi rdfl = {
 		.fl = {
+			.fl_net = &init_net,
 			.oif = dev->ifindex,
 			.nl_u = {
 				.ip6_u = {
@@ -1896,13 +1910,13 @@
 	if (rt == NULL)
 		return ERR_PTR(-ENOMEM);
 
-	dev_hold(&loopback_dev);
+	dev_hold(&init_net.loopback_dev);
 	in6_dev_hold(idev);
 
 	rt->u.dst.flags = DST_HOST;
 	rt->u.dst.input = ip6_input;
 	rt->u.dst.output = ip6_output;
-	rt->rt6i_dev = &loopback_dev;
+	rt->rt6i_dev = &init_net.loopback_dev;
 	rt->rt6i_idev = idev;
 	rt->u.dst.metrics[RTAX_MTU-1] = ipv6_get_mtu(rt->rt6i_dev);
 	rt->u.dst.metrics[RTAX_ADVMSS-1] = ipv6_advmss(dst_mtu(&rt->u.dst));
@@ -2033,6 +2047,7 @@
 
 	cfg->fc_nlinfo.pid = NETLINK_CB(skb).pid;
 	cfg->fc_nlinfo.nlh = nlh;
+	cfg->fc_nlinfo.net = skb->sk->sk_net;
 
 	if (tb[RTA_GATEWAY]) {
 		nla_memcpy(&cfg->fc_gateway, tb[RTA_GATEWAY], 16);
@@ -2078,9 +2093,13 @@
 
 static int inet6_rtm_delroute(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct fib6_config cfg;
 	int err;
 
+	if (net != &init_net)
+		return -EINVAL;
+
 	err = rtm_to_fib6_config(skb, nlh, &cfg);
 	if (err < 0)
 		return err;
@@ -2090,9 +2109,13 @@
 
 static int inet6_rtm_newroute(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct fib6_config cfg;
 	int err;
 
+	if (net != &init_net)
+		return -EINVAL;
+
 	err = rtm_to_fib6_config(skb, nlh, &cfg);
 	if (err < 0)
 		return err;
@@ -2227,6 +2250,7 @@
 
 static int inet6_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr* nlh, void *arg)
 {
+	struct net *net = in_skb->sk->sk_net;
 	struct nlattr *tb[RTA_MAX+1];
 	struct rt6_info *rt;
 	struct sk_buff *skb;
@@ -2234,12 +2258,16 @@
 	struct flowi fl;
 	int err, iif = 0;
 
+	if (net != &init_net)
+		return -EINVAL;
+
 	err = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv6_policy);
 	if (err < 0)
 		goto errout;
 
 	err = -EINVAL;
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 
 	if (tb[RTA_SRC]) {
 		if (nla_len(tb[RTA_SRC]) < sizeof(struct in6_addr))
@@ -2263,7 +2291,7 @@
 
 	if (iif) {
 		struct net_device *dev;
-		dev = __dev_get_by_index(iif);
+		dev = __dev_get_by_index(&init_net, iif);
 		if (!dev) {
 			err = -ENODEV;
 			goto errout;
@@ -2293,7 +2321,7 @@
 		goto errout;
 	}
 
-	err = rtnl_unicast(skb, NETLINK_CB(in_skb).pid);
+	err = rtnl_unicast(skb, &init_net, NETLINK_CB(in_skb).pid);
 errout:
 	return err;
 }
@@ -2301,17 +2329,10 @@
 void inet6_rt_notify(int event, struct rt6_info *rt, struct nl_info *info)
 {
 	struct sk_buff *skb;
-	u32 pid = 0, seq = 0;
-	struct nlmsghdr *nlh = NULL;
+	u32 pid = info->pid, seq = info->nlh ? info->nlh->nlmsg_seq : 0;
+	struct nlmsghdr *nlh = info->nlh;
 	int err = -ENOBUFS;
 
-	if (info) {
-		pid = info->pid;
-		nlh = info->nlh;
-		if (nlh)
-			seq = nlh->nlmsg_seq;
-	}
-
 	skb = nlmsg_new(rt6_nlmsg_size(), gfp_any());
 	if (skb == NULL)
 		goto errout;
@@ -2323,10 +2344,10 @@
 		kfree_skb(skb);
 		goto errout;
 	}
-	err = rtnl_notify(skb, pid, RTNLGRP_IPV6_ROUTE, nlh, gfp_any());
+	err = rtnl_notify(skb, &init_net, pid, RTNLGRP_IPV6_ROUTE, nlh, gfp_any());
 errout:
 	if (err < 0)
-		rtnl_set_sk_err(RTNLGRP_IPV6_ROUTE, err);
+		rtnl_set_sk_err(&init_net, RTNLGRP_IPV6_ROUTE, err);
 }
 
 /*
@@ -2558,13 +2579,19 @@
 				  SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL, NULL);
 	ip6_dst_blackhole_ops.kmem_cachep = ip6_dst_ops.kmem_cachep;
 
+	/* Perform the initialization we can't perform at compile time */
+	ip6_null_entry.u.dst.dev = &init_net.loopback_dev;
+#ifdef CONFIG_IPV6_MULTIPLE_TABLES
+	ip6_prohibit_entry.u.dst.dev = &init_net.loopback_dev;
+	ip6_blk_hole_entry.u.dst.dev = &init_net.loopback_dev;
+#endif	
 	fib6_init();
 #ifdef 	CONFIG_PROC_FS
-	p = proc_net_create("ipv6_route", 0, rt6_proc_info);
+	p = proc_net_create(&init_net, "ipv6_route", 0, rt6_proc_info);
 	if (p)
 		p->owner = THIS_MODULE;
 
-	proc_net_fops_create("rt6_stats", S_IRUGO, &rt6_stats_seq_fops);
+	proc_net_fops_create(&init_net, "rt6_stats", S_IRUGO, &rt6_stats_seq_fops);
 #endif
 #ifdef CONFIG_XFRM
 	xfrm6_init();
@@ -2584,8 +2611,8 @@
 	fib6_rules_cleanup();
 #endif
 #ifdef CONFIG_PROC_FS
-	proc_net_remove("ipv6_route");
-	proc_net_remove("rt6_stats");
+	proc_net_remove(&init_net, "ipv6_route");
+	proc_net_remove(&init_net, "rt6_stats");
 #endif
 #ifdef CONFIG_XFRM
 	xfrm6_fini();
diff -Nurb linux-2.6.22-590/net/ipv6/sit.c linux-2.6.22-try2-netns/net/ipv6/sit.c
--- linux-2.6.22-590/net/ipv6/sit.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/sit.c	2007-12-19 22:49:20.000000000 -0500
@@ -167,7 +167,7 @@
 		int i;
 		for (i=1; i<100; i++) {
 			sprintf(name, "sit%d", i);
-			if (__dev_get_by_name(name) == NULL)
+			if (__dev_get_by_name(&init_net, name) == NULL)
 				break;
 		}
 		if (i==100)
@@ -283,6 +283,9 @@
 	struct sk_buff *skb2;
 	struct rt6_info *rt6i;
 
+	if (skb->dev->nd_net != &init_net)
+		return;
+
 	if (len < hlen + sizeof(struct ipv6hdr))
 		return;
 	iph6 = (struct ipv6hdr*)(dp + hlen);
@@ -369,6 +372,10 @@
 	struct iphdr *iph;
 	struct ip_tunnel *tunnel;
 
+	if (skb->dev->nd_net != &init_net) {
+		kfree_skb(skb);
+		return 0;
+	}
 	if (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))
 		goto out;
 
@@ -474,7 +481,8 @@
 	}
 
 	{
-		struct flowi fl = { .nl_u = { .ip4_u =
+		struct flowi fl = { .fl_net = &init_net,
+				    .nl_u = { .ip4_u =
 					      { .daddr = dst,
 						.saddr = tiph->saddr,
 						.tos = RT_TOS(tos) } },
@@ -745,7 +753,8 @@
 	memcpy(dev->broadcast, &tunnel->parms.iph.daddr, 4);
 
 	if (iph->daddr) {
-		struct flowi fl = { .nl_u = { .ip4_u =
+		struct flowi fl = { .fl_net = &init_net,
+				    .nl_u = { .ip4_u =
 					      { .daddr = iph->daddr,
 						.saddr = iph->saddr,
 						.tos = RT_TOS(iph->tos) } },
@@ -760,7 +769,7 @@
 	}
 
 	if (!tdev && tunnel->parms.link)
-		tdev = __dev_get_by_index(tunnel->parms.link);
+		tdev = __dev_get_by_index(&init_net, tunnel->parms.link);
 
 	if (tdev) {
 		dev->hard_header_len = tdev->hard_header_len + sizeof(struct iphdr);
diff -Nurb linux-2.6.22-590/net/ipv6/tcp_ipv6.c linux-2.6.22-try2-netns/net/ipv6/tcp_ipv6.c
--- linux-2.6.22-590/net/ipv6/tcp_ipv6.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/tcp_ipv6.c	2007-12-19 22:49:20.000000000 -0500
@@ -143,6 +143,7 @@
 		return(-EAFNOSUPPORT);
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 
 	if (np->sndflow) {
 		fl.fl6_flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;
@@ -330,6 +331,7 @@
 static void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		int type, int code, int offset, __be32 info)
 {
+	struct net *net = skb->dev->nd_net;
 	struct ipv6hdr *hdr = (struct ipv6hdr*)skb->data;
 	const struct tcphdr *th = (struct tcphdr *)(skb->data+offset);
 	struct ipv6_pinfo *np;
@@ -339,7 +341,7 @@
 	__u32 seq;
 
 	sk = inet6_lookup(&tcp_hashinfo, &hdr->daddr, th->dest, &hdr->saddr,
-			  th->source, skb->dev->ifindex);
+			  th->source, skb->dev->ifindex, net);
 
 	if (sk == NULL) {
 		ICMP6_INC_STATS_BH(__in6_dev_get(skb->dev), ICMP6_MIB_INERRORS);
@@ -388,6 +390,7 @@
 			   for now.
 			 */
 			memset(&fl, 0, sizeof(fl));
+			fl.fl_net = &init_net;
 			fl.proto = IPPROTO_TCP;
 			ipv6_addr_copy(&fl.fl6_dst, &np->daddr);
 			ipv6_addr_copy(&fl.fl6_src, &np->saddr);
@@ -481,6 +484,7 @@
 	int err = -1;
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	fl.proto = IPPROTO_TCP;
 	ipv6_addr_copy(&fl.fl6_dst, &treq->rmt_addr);
 	ipv6_addr_copy(&fl.fl6_src, &treq->loc_addr);
@@ -1066,6 +1070,7 @@
 	buff->csum = csum_partial((char *)t1, sizeof(*t1), 0);
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	ipv6_addr_copy(&fl.fl6_dst, &ipv6_hdr(skb)->saddr);
 	ipv6_addr_copy(&fl.fl6_src, &ipv6_hdr(skb)->daddr);
 
@@ -1167,6 +1172,7 @@
 	buff->csum = csum_partial((char *)t1, tot_len, 0);
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	ipv6_addr_copy(&fl.fl6_dst, &ipv6_hdr(skb)->saddr);
 	ipv6_addr_copy(&fl.fl6_src, &ipv6_hdr(skb)->daddr);
 
@@ -1224,7 +1230,8 @@
 
 	nsk = __inet6_lookup_established(&tcp_hashinfo, &ipv6_hdr(skb)->saddr,
 					 th->source, &ipv6_hdr(skb)->daddr,
-					 ntohs(th->dest), inet6_iif(skb));
+					 ntohs(th->dest), inet6_iif(skb),
+					 sk->sk_net);
 
 	if (nsk) {
 		if (nsk->sk_state != TCP_TIME_WAIT) {
@@ -1414,6 +1421,7 @@
 		struct flowi fl;
 
 		memset(&fl, 0, sizeof(fl));
+		fl.fl_net = &init_net;
 		fl.proto = IPPROTO_TCP;
 		ipv6_addr_copy(&fl.fl6_dst, &treq->rmt_addr);
 		if (opt && opt->srcrt) {
@@ -1700,6 +1708,7 @@
 static int tcp_v6_rcv(struct sk_buff **pskb)
 {
 	struct sk_buff *skb = *pskb;
+	struct net *net = skb->dev->nd_net;
 	struct tcphdr *th;
 	struct sock *sk;
 	int ret;
@@ -1736,7 +1745,7 @@
 
 	sk = __inet6_lookup(&tcp_hashinfo, &ipv6_hdr(skb)->saddr, th->source,
 			    &ipv6_hdr(skb)->daddr, ntohs(th->dest),
-			    inet6_iif(skb));
+			    inet6_iif(skb), net);
 
 	if (!sk)
 		goto no_tcp_socket;
@@ -1816,7 +1825,8 @@
 
 		sk2 = inet6_lookup_listener(&tcp_hashinfo,
 					    &ipv6_hdr(skb)->daddr,
-					    ntohs(th->dest), inet6_iif(skb));
+					    ntohs(th->dest), inet6_iif(skb),
+					    net);
 		if (sk2 != NULL) {
 			struct inet_timewait_sock *tw = inet_twsk(sk);
 			inet_twsk_deschedule(tw, &tcp_death_row);
@@ -2121,12 +2131,12 @@
 
 int __init tcp6_proc_init(void)
 {
-	return tcp_proc_register(&tcp6_seq_afinfo);
+	return tcp_proc_register(&init_net, &tcp6_seq_afinfo);
 }
 
 void tcp6_proc_exit(void)
 {
-	tcp_proc_unregister(&tcp6_seq_afinfo);
+	tcp_proc_unregister(&init_net, &tcp6_seq_afinfo);
 }
 #endif
 
diff -Nurb linux-2.6.22-590/net/ipv6/udp.c linux-2.6.22-try2-netns/net/ipv6/udp.c
--- linux-2.6.22-590/net/ipv6/udp.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/udp.c	2007-12-19 22:49:20.000000000 -0500
@@ -657,6 +657,7 @@
 	ulen += sizeof(struct udphdr);
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 
 	if (sin6) {
 		if (sin6->sin6_port == 0)
@@ -967,11 +968,11 @@
 
 int __init udp6_proc_init(void)
 {
-	return udp_proc_register(&udp6_seq_afinfo);
+	return udp_proc_register(&init_net, &udp6_seq_afinfo);
 }
 
 void udp6_proc_exit(void) {
-	udp_proc_unregister(&udp6_seq_afinfo);
+	udp_proc_unregister(&init_net, &udp6_seq_afinfo);
 }
 #endif /* CONFIG_PROC_FS */
 
diff -Nurb linux-2.6.22-590/net/ipv6/udplite.c linux-2.6.22-try2-netns/net/ipv6/udplite.c
--- linux-2.6.22-590/net/ipv6/udplite.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipv6/udplite.c	2007-12-19 22:49:20.000000000 -0500
@@ -95,11 +95,11 @@
 
 int __init udplite6_proc_init(void)
 {
-	return udp_proc_register(&udplite6_seq_afinfo);
+	return udp_proc_register(&init_net, &udplite6_seq_afinfo);
 }
 
 void udplite6_proc_exit(void)
 {
-	udp_proc_unregister(&udplite6_seq_afinfo);
+	udp_proc_unregister(&init_net, &udplite6_seq_afinfo);
 }
 #endif
diff -Nurb linux-2.6.22-590/net/ipv6/xfrm6_policy.c linux-2.6.22-try2-netns/net/ipv6/xfrm6_policy.c
--- linux-2.6.22-590/net/ipv6/xfrm6_policy.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/ipv6/xfrm6_policy.c	2007-12-19 22:49:20.000000000 -0500
@@ -40,6 +40,7 @@
 {
 	struct rt6_info *rt;
 	struct flowi fl_tunnel = {
+		.fl_net = &init_net,
 		.nl_u = {
 			.ip6_u = {
 				.daddr = *(struct in6_addr *)&daddr->a6,
@@ -132,6 +133,7 @@
 	struct rt6_info *rt0 = (struct rt6_info*)(*dst_p);
 	struct rt6_info *rt  = rt0;
 	struct flowi fl_tunnel = {
+		.fl_net = &init_net,
 		.nl_u = {
 			.ip6_u = {
 				.saddr = fl->fl6_src,
@@ -278,6 +280,7 @@
 	u8 nexthdr = nh[IP6CB(skb)->nhoff];
 
 	memset(fl, 0, sizeof(struct flowi));
+	fl->fl_net = &init_net;
 	ipv6_addr_copy(&fl->fl6_dst, &hdr->daddr);
 	ipv6_addr_copy(&fl->fl6_src, &hdr->saddr);
 
@@ -375,7 +378,7 @@
 
 	xdst = (struct xfrm_dst *)dst;
 	if (xdst->u.rt6.rt6i_idev->dev == dev) {
-		struct inet6_dev *loopback_idev = in6_dev_get(&loopback_dev);
+		struct inet6_dev *loopback_idev = in6_dev_get(&init_net.loopback_dev);
 		BUG_ON(!loopback_idev);
 
 		do {
diff -Nurb linux-2.6.22-590/net/ipx/af_ipx.c linux-2.6.22-try2-netns/net/ipx/af_ipx.c
--- linux-2.6.22-590/net/ipx/af_ipx.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipx/af_ipx.c	2007-12-19 22:49:20.000000000 -0500
@@ -347,6 +347,9 @@
 	struct net_device *dev = ptr;
 	struct ipx_interface *i, *tmp;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (event != NETDEV_DOWN && event != NETDEV_UP)
 		goto out;
 
@@ -986,7 +989,7 @@
 	if (intrfc)
 		ipxitf_put(intrfc);
 
-	dev = dev_get_by_name(idef->ipx_device);
+	dev = dev_get_by_name(&init_net, idef->ipx_device);
 	rc = -ENODEV;
 	if (!dev)
 		goto out;
@@ -1094,7 +1097,7 @@
 	if (!dlink_type)
 		goto out;
 
-	dev = __dev_get_by_name(idef->ipx_device);
+	dev = __dev_get_by_name(&init_net, idef->ipx_device);
 	rc = -ENODEV;
 	if (!dev)
 		goto out;
@@ -1189,7 +1192,7 @@
 		if (copy_from_user(&ifr, arg, sizeof(ifr)))
 			break;
 		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
-		dev  = __dev_get_by_name(ifr.ifr_name);
+		dev  = __dev_get_by_name(&init_net, ifr.ifr_name);
 		rc   = -ENODEV;
 		if (!dev)
 			break;
@@ -1360,11 +1363,14 @@
 	.obj_size = sizeof(struct ipx_sock),
 };
 
-static int ipx_create(struct socket *sock, int protocol)
+static int ipx_create(struct net *net, struct socket *sock, int protocol)
 {
 	int rc = -ESOCKTNOSUPPORT;
 	struct sock *sk;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	/*
 	 * SPX support is not anymore in the kernel sources. If you want to
 	 * ressurrect it, completing it and making it understand shared skbs,
@@ -1375,7 +1381,7 @@
 		goto out;
 
 	rc = -ENOMEM;
-	sk = sk_alloc(PF_IPX, GFP_KERNEL, &ipx_proto, 1);
+	sk = sk_alloc(net, PF_IPX, GFP_KERNEL, &ipx_proto, 1);
 	if (!sk)
 		goto out;
 #ifdef IPX_REFCNT_DEBUG
@@ -1644,6 +1650,9 @@
 	u16 ipx_pktsize;
 	int rc = 0;
 
+	if (dev->nd_net != &init_net)
+		goto drop;
+
 	/* Not ours */
 	if (skb->pkt_type == PACKET_OTHERHOST)
 		goto drop;
diff -Nurb linux-2.6.22-590/net/ipx/ipx_proc.c linux-2.6.22-try2-netns/net/ipx/ipx_proc.c
--- linux-2.6.22-590/net/ipx/ipx_proc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/ipx/ipx_proc.c	2007-12-19 22:49:20.000000000 -0500
@@ -9,6 +9,7 @@
 #include <linux/proc_fs.h>
 #include <linux/spinlock.h>
 #include <linux/seq_file.h>
+#include <net/net_namespace.h>
 #include <net/tcp_states.h>
 #include <net/ipx.h>
 
@@ -353,7 +354,7 @@
 	struct proc_dir_entry *p;
 	int rc = -ENOMEM;
 
-	ipx_proc_dir = proc_mkdir("ipx", proc_net);
+	ipx_proc_dir = proc_mkdir("ipx", init_net.proc_net);
 
 	if (!ipx_proc_dir)
 		goto out;
@@ -381,7 +382,7 @@
 out_route:
 	remove_proc_entry("interface", ipx_proc_dir);
 out_interface:
-	remove_proc_entry("ipx", proc_net);
+	remove_proc_entry("ipx", init_net.proc_net);
 	goto out;
 }
 
@@ -390,7 +391,7 @@
 	remove_proc_entry("interface", ipx_proc_dir);
 	remove_proc_entry("route", ipx_proc_dir);
 	remove_proc_entry("socket", ipx_proc_dir);
-	remove_proc_entry("ipx", proc_net);
+	remove_proc_entry("ipx", init_net.proc_net);
 }
 
 #else /* CONFIG_PROC_FS */
diff -Nurb linux-2.6.22-590/net/irda/af_irda.c linux-2.6.22-try2-netns/net/irda/af_irda.c
--- linux-2.6.22-590/net/irda/af_irda.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/irda/af_irda.c	2007-12-19 22:49:20.000000000 -0500
@@ -60,7 +60,7 @@
 
 #include <net/irda/af_irda.h>
 
-static int irda_create(struct socket *sock, int protocol);
+static int irda_create(struct net *net, struct socket *sock, int protocol);
 
 static const struct proto_ops irda_stream_ops;
 static const struct proto_ops irda_seqpacket_ops;
@@ -831,7 +831,7 @@
 
 	IRDA_DEBUG(2, "%s()\n", __FUNCTION__);
 
-	err = irda_create(newsock, sk->sk_protocol);
+	err = irda_create(sk->sk_net, newsock, sk->sk_protocol);
 	if (err)
 		return err;
 
@@ -1057,13 +1057,16 @@
  *    Create IrDA socket
  *
  */
-static int irda_create(struct socket *sock, int protocol)
+static int irda_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 	struct irda_sock *self;
 
 	IRDA_DEBUG(2, "%s()\n", __FUNCTION__);
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	/* Check for valid socket type */
 	switch (sock->type) {
 	case SOCK_STREAM:     /* For TTP connections with SAR disabled */
@@ -1075,7 +1078,7 @@
 	}
 
 	/* Allocate networking socket */
-	sk = sk_alloc(PF_IRDA, GFP_ATOMIC, &irda_proto, 1);
+	sk = sk_alloc(net, PF_IRDA, GFP_ATOMIC, &irda_proto, 1);
 	if (sk == NULL)
 		return -ENOMEM;
 
diff -Nurb linux-2.6.22-590/net/irda/irlap_frame.c linux-2.6.22-try2-netns/net/irda/irlap_frame.c
--- linux-2.6.22-590/net/irda/irlap_frame.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/irda/irlap_frame.c	2007-12-19 22:49:20.000000000 -0500
@@ -1319,6 +1319,9 @@
 	int command;
 	__u8 control;
 
+	if (dev->nd_net != &init_net)
+		goto out;
+
 	/* FIXME: should we get our own field? */
 	self = (struct irlap_cb *) dev->atalk_ptr;
 
diff -Nurb linux-2.6.22-590/net/irda/irproc.c linux-2.6.22-try2-netns/net/irda/irproc.c
--- linux-2.6.22-590/net/irda/irproc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/irda/irproc.c	2007-12-19 22:49:20.000000000 -0500
@@ -28,6 +28,7 @@
 #include <linux/seq_file.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <net/net_namespace.h>
 
 #include <net/irda/irda.h>
 #include <net/irda/irlap.h>
@@ -66,7 +67,7 @@
 	int i;
 	struct proc_dir_entry *d;
 
-	proc_irda = proc_mkdir("irda", proc_net);
+	proc_irda = proc_mkdir("irda", init_net.proc_net);
 	if (proc_irda == NULL)
 		return;
 	proc_irda->owner = THIS_MODULE;
@@ -92,7 +93,7 @@
 		for (i=0; i<ARRAY_SIZE(irda_dirs); i++)
 			remove_proc_entry(irda_dirs[i].name, proc_irda);
 
-		remove_proc_entry("irda", proc_net);
+		remove_proc_entry("irda", init_net.proc_net);
 		proc_irda = NULL;
 	}
 }
diff -Nurb linux-2.6.22-590/net/key/af_key.c linux-2.6.22-try2-netns/net/key/af_key.c
--- linux-2.6.22-590/net/key/af_key.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/key/af_key.c	2007-12-19 22:49:20.000000000 -0500
@@ -28,6 +28,7 @@
 #include <linux/init.h>
 #include <net/xfrm.h>
 #include <linux/audit.h>
+#include <net/net_namespace.h>
 
 #include <net/sock.h>
 
@@ -136,11 +137,14 @@
 	.obj_size = sizeof(struct pfkey_sock),
 };
 
-static int pfkey_create(struct socket *sock, int protocol)
+static int pfkey_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 	int err;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 	if (sock->type != SOCK_RAW)
@@ -149,7 +153,7 @@
 		return -EPROTONOSUPPORT;
 
 	err = -ENOMEM;
-	sk = sk_alloc(PF_KEY, GFP_KERNEL, &key_proto, 1);
+	sk = sk_alloc(net, PF_KEY, GFP_KERNEL, &key_proto, 1);
 	if (sk == NULL)
 		goto out;
 
@@ -3781,7 +3785,7 @@
 static void __exit ipsec_pfkey_exit(void)
 {
 	xfrm_unregister_km(&pfkeyv2_mgr);
-	remove_proc_entry("net/pfkey", NULL);
+	remove_proc_entry("pfkey", init_net.proc_net);
 	sock_unregister(PF_KEY);
 	proto_unregister(&key_proto);
 }
@@ -3798,7 +3802,7 @@
 		goto out_unregister_key_proto;
 #ifdef CONFIG_PROC_FS
 	err = -ENOMEM;
-	if (create_proc_read_entry("net/pfkey", 0, NULL, pfkey_read_proc, NULL) == NULL)
+	if (create_proc_read_entry("pfkey", 0, init_net.proc_net, pfkey_read_proc, NULL) == NULL)
 		goto out_sock_unregister;
 #endif
 	err = xfrm_register_km(&pfkeyv2_mgr);
diff -Nurb linux-2.6.22-590/net/llc/af_llc.c linux-2.6.22-try2-netns/net/llc/af_llc.c
--- linux-2.6.22-590/net/llc/af_llc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/llc/af_llc.c	2007-12-19 22:49:20.000000000 -0500
@@ -150,14 +150,17 @@
  *	socket type we have available.
  *	Returns 0 upon success, negative upon failure.
  */
-static int llc_ui_create(struct socket *sock, int protocol)
+static int llc_ui_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 	int rc = -ESOCKTNOSUPPORT;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	if (likely(sock->type == SOCK_DGRAM || sock->type == SOCK_STREAM)) {
 		rc = -ENOMEM;
-		sk = llc_sk_alloc(PF_LLC, GFP_KERNEL, &llc_proto);
+		sk = llc_sk_alloc(net, PF_LLC, GFP_KERNEL, &llc_proto);
 		if (sk) {
 			rc = 0;
 			llc_ui_sk_init(sock, sk);
@@ -249,7 +252,7 @@
 	if (!sock_flag(sk, SOCK_ZAPPED))
 		goto out;
 	rc = -ENODEV;
-	llc->dev = dev_getfirstbyhwtype(addr->sllc_arphrd);
+	llc->dev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);
 	if (!llc->dev)
 		goto out;
 	rc = -EUSERS;
@@ -300,7 +303,7 @@
 		goto out;
 	rc = -ENODEV;
 	rtnl_lock();
-	llc->dev = dev_getbyhwaddr(addr->sllc_arphrd, addr->sllc_mac);
+	llc->dev = dev_getbyhwaddr(&init_net, addr->sllc_arphrd, addr->sllc_mac);
 	rtnl_unlock();
 	if (!llc->dev)
 		goto out;
diff -Nurb linux-2.6.22-590/net/llc/llc_conn.c linux-2.6.22-try2-netns/net/llc/llc_conn.c
--- linux-2.6.22-590/net/llc/llc_conn.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/llc/llc_conn.c	2007-12-19 22:49:20.000000000 -0500
@@ -700,7 +700,7 @@
 					     struct llc_addr *saddr,
 					     struct llc_addr *daddr)
 {
-	struct sock *newsk = llc_sk_alloc(sk->sk_family, GFP_ATOMIC,
+	struct sock *newsk = llc_sk_alloc(sk->sk_net, sk->sk_family, GFP_ATOMIC,
 					  sk->sk_prot);
 	struct llc_sock *newllc, *llc = llc_sk(sk);
 
@@ -867,9 +867,9 @@
  *	Allocates a LLC sock and initializes it. Returns the new LLC sock
  *	or %NULL if there's no memory available for one
  */
-struct sock *llc_sk_alloc(int family, gfp_t priority, struct proto *prot)
+struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot)
 {
-	struct sock *sk = sk_alloc(family, priority, prot, 1);
+	struct sock *sk = sk_alloc(net, family, priority, prot, 1);
 
 	if (!sk)
 		goto out;
diff -Nurb linux-2.6.22-590/net/llc/llc_core.c linux-2.6.22-try2-netns/net/llc/llc_core.c
--- linux-2.6.22-590/net/llc/llc_core.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/llc/llc_core.c	2007-12-19 22:49:20.000000000 -0500
@@ -19,6 +19,7 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/init.h>
+#include <net/net_namespace.h>
 #include <net/llc.h>
 
 LIST_HEAD(llc_sap_list);
@@ -162,7 +163,7 @@
 {
 	struct net_device *dev;
 
-	dev = first_net_device();
+	dev = first_net_device(&init_net);
 	if (dev != NULL)
 		dev = next_net_device(dev);
 
diff -Nurb linux-2.6.22-590/net/llc/llc_input.c linux-2.6.22-try2-netns/net/llc/llc_input.c
--- linux-2.6.22-590/net/llc/llc_input.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/llc/llc_input.c	2007-12-19 22:49:20.000000000 -0500
@@ -12,6 +12,7 @@
  * See the GNU General Public License for more details.
  */
 #include <linux/netdevice.h>
+#include <net/net_namespace.h>
 #include <net/llc.h>
 #include <net/llc_pdu.h>
 #include <net/llc_sap.h>
@@ -145,6 +146,9 @@
 	int (*rcv)(struct sk_buff *, struct net_device *,
 		   struct packet_type *, struct net_device *);
 
+	if (dev->nd_net != &init_net)
+		goto drop;
+
 	/*
 	 * When the interface is in promisc. mode, drop all the crap that it
 	 * receives, do not try to analyse it.
diff -Nurb linux-2.6.22-590/net/llc/llc_proc.c linux-2.6.22-try2-netns/net/llc/llc_proc.c
--- linux-2.6.22-590/net/llc/llc_proc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/llc/llc_proc.c	2007-12-19 22:49:20.000000000 -0500
@@ -18,6 +18,7 @@
 #include <linux/errno.h>
 #include <linux/seq_file.h>
 #include <net/sock.h>
+#include <net/net_namespace.h>
 #include <net/llc.h>
 #include <net/llc_c_ac.h>
 #include <net/llc_c_ev.h>
@@ -231,7 +232,7 @@
 	int rc = -ENOMEM;
 	struct proc_dir_entry *p;
 
-	llc_proc_dir = proc_mkdir("llc", proc_net);
+	llc_proc_dir = proc_mkdir("llc", init_net.proc_net);
 	if (!llc_proc_dir)
 		goto out;
 	llc_proc_dir->owner = THIS_MODULE;
@@ -254,7 +255,7 @@
 out_core:
 	remove_proc_entry("socket", llc_proc_dir);
 out_socket:
-	remove_proc_entry("llc", proc_net);
+	remove_proc_entry("llc", init_net.proc_net);
 	goto out;
 }
 
@@ -262,5 +263,5 @@
 {
 	remove_proc_entry("socket", llc_proc_dir);
 	remove_proc_entry("core", llc_proc_dir);
-	remove_proc_entry("llc", proc_net);
+	remove_proc_entry("llc", init_net.proc_net);
 }
diff -Nurb linux-2.6.22-590/net/netfilter/core.c linux-2.6.22-try2-netns/net/netfilter/core.c
--- linux-2.6.22-590/net/netfilter/core.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/netfilter/core.c	2007-12-19 22:49:20.000000000 -0500
@@ -20,6 +20,7 @@
 #include <linux/proc_fs.h>
 #include <linux/mutex.h>
 #include <net/sock.h>
+#include <net/net_namespace.h>
 
 #include "nf_internals.h"
 
@@ -280,8 +281,28 @@
 #endif /* CONFIG_NF_CONNTRACK */
 
 #ifdef CONFIG_PROC_FS
-struct proc_dir_entry *proc_net_netfilter;
-EXPORT_SYMBOL(proc_net_netfilter);
+static int netfilter_proc_init(struct net * net)
+{
+	int error = -ENOMEM;
+	net->proc_net_netfilter = proc_mkdir("netfilter", net->proc_net);
+
+	if (net->proc_net_netfilter) {
+		net->proc_net_netfilter->data = net;
+		error = 0;
+	}
+	return error;
+}
+
+static void netfilter_proc_exit(struct net *net)
+{
+	remove_proc_entry("netfilter", net->proc_net);
+}
+
+static struct pernet_operations netfilter_proc_ops = {
+	.init = netfilter_proc_init,
+	.exit = netfilter_proc_exit,
+};
+
 #endif
 
 void __init netfilter_init(void)
@@ -293,8 +314,7 @@
 	}
 
 #ifdef CONFIG_PROC_FS
-	proc_net_netfilter = proc_mkdir("netfilter", proc_net);
-	if (!proc_net_netfilter)
+	if (register_pernet_subsys(&netfilter_proc_ops) < 0)
 		panic("cannot create netfilter proc entry");
 #endif
 
diff -Nurb linux-2.6.22-590/net/netfilter/nf_conntrack_h323_main.c linux-2.6.22-try2-netns/net/netfilter/nf_conntrack_h323_main.c
--- linux-2.6.22-590/net/netfilter/nf_conntrack_h323_main.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/netfilter/nf_conntrack_h323_main.c	2007-12-19 22:49:20.000000000 -0500
@@ -724,6 +724,8 @@
 
 	memset(&fl1, 0, sizeof(fl1));
 	memset(&fl2, 0, sizeof(fl2));
+	fl1.fl_net = &init_net;
+	fl2.fl_net = &init_net;
 
 	switch (family) {
 	case AF_INET: {
diff -Nurb linux-2.6.22-590/net/netfilter/nf_conntrack_standalone.c linux-2.6.22-try2-netns/net/netfilter/nf_conntrack_standalone.c
--- linux-2.6.22-590/net/netfilter/nf_conntrack_standalone.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/netfilter/nf_conntrack_standalone.c	2007-12-19 22:49:20.000000000 -0500
@@ -14,6 +14,7 @@
 #include <linux/seq_file.h>
 #include <linux/percpu.h>
 #include <linux/netdevice.h>
+#include <net/net_namespace.h>
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
 #endif
@@ -419,14 +420,14 @@
 		return ret;
 
 #ifdef CONFIG_PROC_FS
-	proc = proc_net_fops_create("nf_conntrack", 0440, &ct_file_ops);
+	proc = proc_net_fops_create(&init_net, "nf_conntrack", 0440, &ct_file_ops);
 	if (!proc) goto cleanup_init;
 
-	proc_exp = proc_net_fops_create("nf_conntrack_expect", 0440,
+	proc_exp = proc_net_fops_create(&init_net, "nf_conntrack_expect", 0440,
 					&exp_file_ops);
 	if (!proc_exp) goto cleanup_proc;
 
-	proc_stat = create_proc_entry("nf_conntrack", S_IRUGO, proc_net_stat);
+	proc_stat = create_proc_entry("nf_conntrack", S_IRUGO, init_net.proc_net_stat);
 	if (!proc_stat)
 		goto cleanup_proc_exp;
 
@@ -447,11 +448,11 @@
  cleanup_proc_stat:
 #endif
 #ifdef CONFIG_PROC_FS
-	remove_proc_entry("nf_conntrack", proc_net_stat);
+	remove_proc_entry("nf_conntrack", init_net.proc_net_stat);
  cleanup_proc_exp:
-	proc_net_remove("nf_conntrack_expect");
+	proc_net_remove(&init_net, "nf_conntrack_expect");
  cleanup_proc:
-	proc_net_remove("nf_conntrack");
+	proc_net_remove(&init_net, "nf_conntrack");
  cleanup_init:
 #endif /* CNFIG_PROC_FS */
 	nf_conntrack_cleanup();
@@ -464,9 +465,9 @@
 	unregister_sysctl_table(nf_ct_sysctl_header);
 #endif
 #ifdef CONFIG_PROC_FS
-	remove_proc_entry("nf_conntrack", proc_net_stat);
-	proc_net_remove("nf_conntrack_expect");
-	proc_net_remove("nf_conntrack");
+	remove_proc_entry("nf_conntrack", init_net.proc_net_stat);
+	proc_net_remove(&init_net, "nf_conntrack_expect");
+	proc_net_remove(&init_net, "nf_conntrack");
 #endif /* CNFIG_PROC_FS */
 	nf_conntrack_cleanup();
 }
diff -Nurb linux-2.6.22-590/net/netfilter/nf_log.c linux-2.6.22-try2-netns/net/netfilter/nf_log.c
--- linux-2.6.22-590/net/netfilter/nf_log.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/netfilter/nf_log.c	2007-12-19 22:49:20.000000000 -0500
@@ -168,7 +168,8 @@
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry *pde;
 
-	pde = create_proc_entry("nf_log", S_IRUGO, proc_net_netfilter);
+	pde = create_proc_entry("nf_log", S_IRUGO,
+		init_net.proc_net_netfilter);
 	if (!pde)
 		return -1;
 
diff -Nurb linux-2.6.22-590/net/netfilter/nf_queue.c linux-2.6.22-try2-netns/net/netfilter/nf_queue.c
--- linux-2.6.22-590/net/netfilter/nf_queue.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/netfilter/nf_queue.c	2007-12-19 22:49:20.000000000 -0500
@@ -346,7 +346,7 @@
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry *pde;
 
-	pde = create_proc_entry("nf_queue", S_IRUGO, proc_net_netfilter);
+	pde = create_proc_entry("nf_queue", S_IRUGO, init_net.proc_net_netfilter);
 	if (!pde)
 		return -1;
 	pde->proc_fops = &nfqueue_file_ops;
diff -Nurb linux-2.6.22-590/net/netfilter/nfnetlink.c linux-2.6.22-try2-netns/net/netfilter/nfnetlink.c
--- linux-2.6.22-590/net/netfilter/nfnetlink.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/netfilter/nfnetlink.c	2007-12-19 22:49:20.000000000 -0500
@@ -264,7 +264,7 @@
 {
 	printk("Netfilter messages via NETLINK v%s.\n", nfversion);
 
-	nfnl = netlink_kernel_create(NETLINK_NETFILTER, NFNLGRP_MAX,
+	nfnl = netlink_kernel_create(&init_net, NETLINK_NETFILTER, NFNLGRP_MAX,
 				     nfnetlink_rcv, NULL, THIS_MODULE);
 	if (!nfnl) {
 		printk(KERN_ERR "cannot initialize nfnetlink!\n");
diff -Nurb linux-2.6.22-590/net/netfilter/nfnetlink_log.c linux-2.6.22-try2-netns/net/netfilter/nfnetlink_log.c
--- linux-2.6.22-590/net/netfilter/nfnetlink_log.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/netfilter/nfnetlink_log.c	2007-12-19 22:49:20.000000000 -0500
@@ -705,7 +705,8 @@
 
 			hlist_for_each_entry_safe(inst, tmp, t2, head, hlist) {
 				UDEBUG("node = %p\n", inst);
-				if (n->pid == inst->peer_pid)
+				if ((n->net == &init_net) && 
+				    (n->pid == inst->peer_pid))
 					__instance_destroy(inst);
 			}
 		}
@@ -1023,7 +1024,7 @@
 
 #ifdef CONFIG_PROC_FS
 	proc_nful = create_proc_entry("nfnetlink_log", 0440,
-				      proc_net_netfilter);
+				      init_net.proc_net_netfilter);
 	if (!proc_nful)
 		goto cleanup_subsys;
 	proc_nful->proc_fops = &nful_file_ops;
@@ -1043,7 +1044,7 @@
 {
 	nf_log_unregister(&nfulnl_logger);
 #ifdef CONFIG_PROC_FS
-	remove_proc_entry("nfnetlink_log", proc_net_netfilter);
+	remove_proc_entry("nfnetlink_log", init_net.proc_net_netfilter);
 #endif
 	nfnetlink_subsys_unregister(&nfulnl_subsys);
 	netlink_unregister_notifier(&nfulnl_rtnl_notifier);
diff -Nurb linux-2.6.22-590/net/netfilter/nfnetlink_queue.c linux-2.6.22-try2-netns/net/netfilter/nfnetlink_queue.c
--- linux-2.6.22-590/net/netfilter/nfnetlink_queue.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/netfilter/nfnetlink_queue.c	2007-12-19 22:49:20.000000000 -0500
@@ -734,6 +734,9 @@
 {
 	struct net_device *dev = ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	/* Drop any packets associated with the downed device */
 	if (event == NETDEV_DOWN)
 		nfqnl_dev_drop(dev->ifindex);
@@ -762,7 +765,8 @@
 			struct hlist_head *head = &instance_table[i];
 
 			hlist_for_each_entry_safe(inst, tmp, t2, head, hlist) {
-				if (n->pid == inst->peer_pid)
+				if ((n->net == &init_net) && 
+				    (n->pid == inst->peer_pid))
 					__instance_destroy(inst);
 			}
 		}
@@ -1106,7 +1110,7 @@
 
 #ifdef CONFIG_PROC_FS
 	proc_nfqueue = create_proc_entry("nfnetlink_queue", 0440,
-					 proc_net_netfilter);
+					 init_net.proc_net_netfilter);
 	if (!proc_nfqueue)
 		goto cleanup_subsys;
 	proc_nfqueue->proc_fops = &nfqnl_file_ops;
@@ -1129,7 +1133,7 @@
 	nf_unregister_queue_handlers(&nfqh);
 	unregister_netdevice_notifier(&nfqnl_dev_notifier);
 #ifdef CONFIG_PROC_FS
-	remove_proc_entry("nfnetlink_queue", proc_net_netfilter);
+	remove_proc_entry("nfnetlink_queue", init_net.proc_net_netfilter);
 #endif
 	nfnetlink_subsys_unregister(&nfqnl_subsys);
 	netlink_unregister_notifier(&nfqnl_rtnl_notifier);
diff -Nurb linux-2.6.22-590/net/netfilter/x_tables.c linux-2.6.22-try2-netns/net/netfilter/x_tables.c
--- linux-2.6.22-590/net/netfilter/x_tables.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/netfilter/x_tables.c	2007-12-19 22:49:20.000000000 -0500
@@ -22,6 +22,7 @@
 #include <linux/vmalloc.h>
 #include <linux/mutex.h>
 #include <linux/mm.h>
+#include <net/net_namespace.h>
 
 #include <linux/netfilter/x_tables.h>
 #include <linux/netfilter_arp.h>
@@ -37,11 +38,16 @@
 	struct mutex mutex;
 	struct list_head match;
 	struct list_head target;
-	struct list_head tables;
 	struct mutex compat_mutex;
 };
 
-static struct xt_af *xt;
+
+struct xt_af_pernet {
+	struct list_head tables;
+};
+
+static struct xt_af * xt;
+
 
 #ifdef DEBUG_IP_FIREWALL_USER
 #define duprintf(format, args...) printk(format , ## args)
@@ -286,9 +292,9 @@
 		return 1;
 	}
 	if (target == 1)
-		have_rev = target_revfn(af, name, revision, &best);
+		have_rev = target_revfn( af, name, revision, &best);
 	else
-		have_rev = match_revfn(af, name, revision, &best);
+		have_rev = match_revfn( af, name, revision, &best);
 	mutex_unlock(&xt[af].mutex);
 
 	/* Nothing at all?  Return 0 to try loading module. */
@@ -533,14 +539,14 @@
 EXPORT_SYMBOL(xt_free_table_info);
 
 /* Find table by name, grabs mutex & ref.  Returns ERR_PTR() on error. */
-struct xt_table *xt_find_table_lock(int af, const char *name)
+struct xt_table *xt_find_table_lock(struct net *net, int af, const char *name)
 {
 	struct xt_table *t;
 
 	if (mutex_lock_interruptible(&xt[af].mutex) != 0)
 		return ERR_PTR(-EINTR);
 
-	list_for_each_entry(t, &xt[af].tables, list)
+	list_for_each_entry(t, &net->xtn[af].tables, list)
 		if (strcmp(t->name, name) == 0 && try_module_get(t->me))
 			return t;
 	mutex_unlock(&xt[af].mutex);
@@ -596,7 +602,7 @@
 }
 EXPORT_SYMBOL_GPL(xt_replace_table);
 
-int xt_register_table(struct xt_table *table,
+int xt_register_table(struct net *net, struct xt_table *table,
 		      struct xt_table_info *bootstrap,
 		      struct xt_table_info *newinfo)
 {
@@ -609,7 +615,7 @@
 		return ret;
 
 	/* Don't autoload: we'd eat our tail... */
-	list_for_each_entry(t, &xt[table->af].tables, list) {
+	list_for_each_entry(t, &net->xtn[table->af].tables, list) {
 		if (strcmp(t->name, table->name) == 0) {
 			ret = -EEXIST;
 			goto unlock;
@@ -628,7 +634,7 @@
 	/* save number of initial entries */
 	private->initial_entries = private->number;
 
-	list_add(&table->list, &xt[table->af].tables);
+	list_add(&table->list, &net->xtn[table->af].tables);
 
 	ret = 0;
  unlock:
@@ -666,7 +672,7 @@
 	return pos ? NULL : head;
 }
 
-static struct list_head *type2list(u_int16_t af, u_int16_t type)
+static struct list_head *type2list(struct net *net, u_int16_t af, u_int16_t type)
 {
 	struct list_head *list;
 
@@ -678,7 +684,7 @@
 		list = &xt[af].match;
 		break;
 	case TABLE:
-		list = &xt[af].tables;
+		list = &net->xtn[af].tables;
 		break;
 	default:
 		list = NULL;
@@ -691,6 +697,7 @@
 static void *xt_tgt_seq_start(struct seq_file *seq, loff_t *pos)
 {
 	struct proc_dir_entry *pde = (struct proc_dir_entry *) seq->private;
+	struct net *net = PDE_NET(pde);
 	u_int16_t af = (unsigned long)pde->data & 0xffff;
 	u_int16_t type = (unsigned long)pde->data >> 16;
 	struct list_head *list;
@@ -698,7 +705,7 @@
 	if (af >= NPROTO)
 		return NULL;
 
-	list = type2list(af, type);
+	list = type2list(net, af, type);
 	if (!list)
 		return NULL;
 
@@ -711,6 +718,7 @@
 static void *xt_tgt_seq_next(struct seq_file *seq, void *v, loff_t *pos)
 {
 	struct proc_dir_entry *pde = seq->private;
+	struct net *net = PDE_NET(pde);
 	u_int16_t af = (unsigned long)pde->data & 0xffff;
 	u_int16_t type = (unsigned long)pde->data >> 16;
 	struct list_head *list;
@@ -718,7 +726,7 @@
 	if (af >= NPROTO)
 		return NULL;
 
-	list = type2list(af, type);
+	list = type2list(net, af, type);
 	if (!list)
 		return NULL;
 
@@ -759,6 +767,7 @@
 	if (!ret) {
 		struct seq_file *seq = file->private_data;
 		struct proc_dir_entry *pde = PDE(inode);
+		get_net(PROC_NET(inode));
 
 		seq->private = pde;
 	}
@@ -766,12 +775,18 @@
 	return ret;
 }
 
+static int xt_tgt_release(struct inode *inode, struct file *file)
+{
+	put_net(PROC_NET(inode));
+	return seq_release(inode, file);
+}
+
 static const struct file_operations xt_file_ops = {
 	.owner	 = THIS_MODULE,
 	.open	 = xt_tgt_open,
 	.read	 = seq_read,
 	.llseek	 = seq_lseek,
-	.release = seq_release,
+	.release = xt_tgt_release,
 };
 
 #define FORMAT_TABLES	"_tables_names"
@@ -794,7 +809,7 @@
 #ifdef CONFIG_PROC_FS
 	strlcpy(buf, xt_prefix[af], sizeof(buf));
 	strlcat(buf, FORMAT_TABLES, sizeof(buf));
-	proc = proc_net_fops_create(buf, 0440, &xt_file_ops);
+	proc = proc_net_fops_create(&init_net, buf, 0440, &xt_file_ops);
 	if (!proc)
 		goto out;
 	proc->data = (void *) ((unsigned long) af | (TABLE << 16));
@@ -802,14 +817,14 @@
 
 	strlcpy(buf, xt_prefix[af], sizeof(buf));
 	strlcat(buf, FORMAT_MATCHES, sizeof(buf));
-	proc = proc_net_fops_create(buf, 0440, &xt_file_ops);
+	proc = proc_net_fops_create(&init_net, buf, 0440, &xt_file_ops);
 	if (!proc)
 		goto out_remove_tables;
 	proc->data = (void *) ((unsigned long) af | (MATCH << 16));
 
 	strlcpy(buf, xt_prefix[af], sizeof(buf));
 	strlcat(buf, FORMAT_TARGETS, sizeof(buf));
-	proc = proc_net_fops_create(buf, 0440, &xt_file_ops);
+	proc = proc_net_fops_create(&init_net, buf, 0440, &xt_file_ops);
 	if (!proc)
 		goto out_remove_matches;
 	proc->data = (void *) ((unsigned long) af | (TARGET << 16));
@@ -821,12 +836,12 @@
 out_remove_matches:
 	strlcpy(buf, xt_prefix[af], sizeof(buf));
 	strlcat(buf, FORMAT_MATCHES, sizeof(buf));
-	proc_net_remove(buf);
+	proc_net_remove(&init_net, buf);
 
 out_remove_tables:
 	strlcpy(buf, xt_prefix[af], sizeof(buf));
 	strlcat(buf, FORMAT_TABLES, sizeof(buf));
-	proc_net_remove(buf);
+	proc_net_remove(&init_net, buf);
 out:
 	return -1;
 #endif
@@ -840,19 +855,42 @@
 
 	strlcpy(buf, xt_prefix[af], sizeof(buf));
 	strlcat(buf, FORMAT_TABLES, sizeof(buf));
-	proc_net_remove(buf);
+	proc_net_remove(&init_net, buf);
 
 	strlcpy(buf, xt_prefix[af], sizeof(buf));
 	strlcat(buf, FORMAT_TARGETS, sizeof(buf));
-	proc_net_remove(buf);
+	proc_net_remove(&init_net, buf);
 
 	strlcpy(buf, xt_prefix[af], sizeof(buf));
 	strlcat(buf, FORMAT_MATCHES, sizeof(buf));
-	proc_net_remove(buf);
+	proc_net_remove(&init_net, buf);
 #endif /*CONFIG_PROC_FS*/
 }
 EXPORT_SYMBOL_GPL(xt_proto_fini);
 
+static int xt_net_init(struct net *net)
+{
+	int i;
+
+	net->xtn = kmalloc(sizeof(struct xt_af_pernet) * NPROTO, GFP_KERNEL);
+	if (!net->xtn)
+		return -ENOMEM;
+
+	for (i = 0; i < NPROTO; i++) {
+		INIT_LIST_HEAD(&net->xtn[i].tables);
+	}
+	return 0;
+}
+
+static void xt_net_exit(struct net *net)
+{
+	kfree(net->xtn);
+}
+
+static struct pernet_operations xt_net_ops = {
+	.init = xt_net_init,
+	.exit = xt_net_exit,
+};
 
 static int __init xt_init(void)
 {
@@ -869,13 +907,13 @@
 #endif
 		INIT_LIST_HEAD(&xt[i].target);
 		INIT_LIST_HEAD(&xt[i].match);
-		INIT_LIST_HEAD(&xt[i].tables);
 	}
-	return 0;
+	return register_pernet_subsys(&xt_net_ops);
 }
 
 static void __exit xt_fini(void)
 {
+	unregister_pernet_subsys(&xt_net_ops);
 	kfree(xt);
 }
 
diff -Nurb linux-2.6.22-590/net/netfilter/xt_MARK.c linux-2.6.22-try2-netns/net/netfilter/xt_MARK.c
--- linux-2.6.22-590/net/netfilter/xt_MARK.c	2007-12-21 15:33:47.000000000 -0500
+++ linux-2.6.22-try2-netns/net/netfilter/xt_MARK.c	2007-12-20 01:21:54.000000000 -0500
@@ -131,7 +131,7 @@
 		if ((*pskb)->sk) 
 			connection_sk = (*pskb)->sk;
 		else {
-			connection_sk = inet_lookup(&tcp_hashinfo, src_ip, src_port, ip, port, dif);
+			connection_sk = inet_lookup(&tcp_hashinfo, src_ip, src_port, ip, port, dif,(*pskb)->sk->sk_net);
 		}
 
 		if (connection_sk) {
diff -Nurb linux-2.6.22-590/net/netfilter/xt_hashlimit.c linux-2.6.22-try2-netns/net/netfilter/xt_hashlimit.c
--- linux-2.6.22-590/net/netfilter/xt_hashlimit.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/netfilter/xt_hashlimit.c	2007-12-19 22:49:20.000000000 -0500
@@ -21,6 +21,7 @@
 #include <linux/in.h>
 #include <linux/ip.h>
 #include <linux/ipv6.h>
+#include <net/net_namespace.h>
 
 #include <linux/netfilter/x_tables.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
@@ -736,13 +737,13 @@
 		printk(KERN_ERR "xt_hashlimit: unable to create slab cache\n");
 		goto err2;
 	}
-	hashlimit_procdir4 = proc_mkdir("ipt_hashlimit", proc_net);
+	hashlimit_procdir4 = proc_mkdir("ipt_hashlimit", init_net.proc_net);
 	if (!hashlimit_procdir4) {
 		printk(KERN_ERR "xt_hashlimit: unable to create proc dir "
 				"entry\n");
 		goto err3;
 	}
-	hashlimit_procdir6 = proc_mkdir("ip6t_hashlimit", proc_net);
+	hashlimit_procdir6 = proc_mkdir("ip6t_hashlimit", init_net.proc_net);
 	if (!hashlimit_procdir6) {
 		printk(KERN_ERR "xt_hashlimit: unable to create proc dir "
 				"entry\n");
@@ -750,7 +751,7 @@
 	}
 	return 0;
 err4:
-	remove_proc_entry("ipt_hashlimit", proc_net);
+	remove_proc_entry("ipt_hashlimit", init_net.proc_net);
 err3:
 	kmem_cache_destroy(hashlimit_cachep);
 err2:
@@ -762,8 +763,8 @@
 
 static void __exit xt_hashlimit_fini(void)
 {
-	remove_proc_entry("ipt_hashlimit", proc_net);
-	remove_proc_entry("ip6t_hashlimit", proc_net);
+	remove_proc_entry("ipt_hashlimit", init_net.proc_net);
+	remove_proc_entry("ip6t_hashlimit", init_net.proc_net);
 	kmem_cache_destroy(hashlimit_cachep);
 	xt_unregister_matches(xt_hashlimit, ARRAY_SIZE(xt_hashlimit));
 }
diff -Nurb linux-2.6.22-590/net/netlink/af_netlink.c linux-2.6.22-try2-netns/net/netlink/af_netlink.c
--- linux-2.6.22-590/net/netlink/af_netlink.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/netlink/af_netlink.c	2007-12-19 22:49:20.000000000 -0500
@@ -63,6 +63,7 @@
 #include <net/sock.h>
 #include <net/scm.h>
 #include <net/netlink.h>
+#include <net/net_namespace.h>
 
 #define NLGRPSZ(x)	(ALIGN(x, sizeof(unsigned long) * 8) / 8)
 
@@ -212,7 +213,7 @@
 		wake_up(&nl_table_wait);
 }
 
-static __inline__ struct sock *netlink_lookup(int protocol, u32 pid)
+static __inline__ struct sock *netlink_lookup(struct net *net, int protocol, u32 pid)
 {
 	struct nl_pid_hash *hash = &nl_table[protocol].hash;
 	struct hlist_head *head;
@@ -222,7 +223,7 @@
 	read_lock(&nl_table_lock);
 	head = nl_pid_hashfn(hash, pid);
 	sk_for_each(sk, node, head) {
-		if (nlk_sk(sk)->pid == pid) {
+		if ((sk->sk_net == net) && (nlk_sk(sk)->pid == pid)) {
 			sock_hold(sk);
 			goto found;
 		}
@@ -327,7 +328,7 @@
 	 * makes sure updates are visible before bind or setsockopt return. */
 }
 
-static int netlink_insert(struct sock *sk, u32 pid)
+static int netlink_insert(struct sock *sk, struct net *net, u32 pid)
 {
 	struct nl_pid_hash *hash = &nl_table[sk->sk_protocol].hash;
 	struct hlist_head *head;
@@ -340,7 +341,7 @@
 	head = nl_pid_hashfn(hash, pid);
 	len = 0;
 	sk_for_each(osk, node, head) {
-		if (nlk_sk(osk)->pid == pid)
+		if ((osk->sk_net == net) && (nlk_sk(osk)->pid == pid))
 			break;
 		len++;
 	}
@@ -383,15 +384,15 @@
 	.obj_size = sizeof(struct netlink_sock),
 };
 
-static int __netlink_create(struct socket *sock, struct mutex *cb_mutex,
-			    int protocol)
+static int __netlink_create(struct net *net, struct socket *sock,
+			    struct mutex *cb_mutex, int protocol)
 {
 	struct sock *sk;
 	struct netlink_sock *nlk;
 
 	sock->ops = &netlink_ops;
 
-	sk = sk_alloc(PF_NETLINK, GFP_KERNEL, &netlink_proto, 1);
+	sk = sk_alloc(net, PF_NETLINK, GFP_KERNEL, &netlink_proto, 1);
 	if (!sk)
 		return -ENOMEM;
 
@@ -411,7 +412,7 @@
 	return 0;
 }
 
-static int netlink_create(struct socket *sock, int protocol)
+static int netlink_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct module *module = NULL;
 	struct mutex *cb_mutex;
@@ -440,7 +441,7 @@
 	cb_mutex = nl_table[protocol].cb_mutex;
 	netlink_unlock_table();
 
-	if ((err = __netlink_create(sock, cb_mutex, protocol)) < 0)
+	if ((err = __netlink_create(net, sock, cb_mutex, protocol)) < 0)
 		goto out_module;
 
 	nlk = nlk_sk(sock->sk);
@@ -477,6 +478,7 @@
 
 	if (nlk->pid && !nlk->subscriptions) {
 		struct netlink_notify n = {
+						.net = sk->sk_net,
 						.protocol = sk->sk_protocol,
 						.pid = nlk->pid,
 					  };
@@ -505,6 +507,7 @@
 static int netlink_autobind(struct socket *sock)
 {
 	struct sock *sk = sock->sk;
+	struct net *net = sk->sk_net;
 	struct nl_pid_hash *hash = &nl_table[sk->sk_protocol].hash;
 	struct hlist_head *head;
 	struct sock *osk;
@@ -518,6 +521,8 @@
 	netlink_table_grab();
 	head = nl_pid_hashfn(hash, pid);
 	sk_for_each(osk, node, head) {
+		if ((osk->sk_net != net))
+			continue;
 		if (nlk_sk(osk)->pid == pid) {
 			/* Bind collision, search negative pid values. */
 			pid = rover--;
@@ -529,7 +534,7 @@
 	}
 	netlink_table_ungrab();
 
-	err = netlink_insert(sk, pid);
+	err = netlink_insert(sk, net, pid);
 	if (err == -EADDRINUSE)
 		goto retry;
 
@@ -583,6 +588,7 @@
 static int netlink_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
 {
 	struct sock *sk = sock->sk;
+	struct net *net = sk->sk_net;
 	struct netlink_sock *nlk = nlk_sk(sk);
 	struct sockaddr_nl *nladdr = (struct sockaddr_nl *)addr;
 	int err;
@@ -606,7 +612,7 @@
 			return -EINVAL;
 	} else {
 		err = nladdr->nl_pid ?
-			netlink_insert(sk, nladdr->nl_pid) :
+			netlink_insert(sk, net, nladdr->nl_pid) :
 			netlink_autobind(sock);
 		if (err)
 			return err;
@@ -690,10 +696,12 @@
 static struct sock *netlink_getsockbypid(struct sock *ssk, u32 pid)
 {
 	int protocol = ssk->sk_protocol;
+	struct net *net;
 	struct sock *sock;
 	struct netlink_sock *nlk;
 
-	sock = netlink_lookup(protocol, pid);
+	net = ssk->sk_net;
+	sock = netlink_lookup(net, protocol, pid);
 	if (!sock)
 		return ERR_PTR(-ECONNREFUSED);
 
@@ -866,6 +874,7 @@
 
 struct netlink_broadcast_data {
 	struct sock *exclude_sk;
+	struct net *net;
 	u32 pid;
 	u32 group;
 	int failure;
@@ -888,6 +897,9 @@
 	    !test_bit(p->group - 1, nlk->groups))
 		goto out;
 
+	if ((sk->sk_net != p->net))
+		goto out;
+
 	if (p->failure) {
 		netlink_overrun(sk);
 		goto out;
@@ -926,6 +938,7 @@
 int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, u32 pid,
 		      u32 group, gfp_t allocation)
 {
+	struct net *net = ssk->sk_net;
 	struct netlink_broadcast_data info;
 	struct hlist_node *node;
 	struct sock *sk;
@@ -933,6 +946,7 @@
 	skb = netlink_trim(skb, allocation);
 
 	info.exclude_sk = ssk;
+	info.net = net;
 	info.pid = pid;
 	info.group = group;
 	info.failure = 0;
@@ -981,6 +995,9 @@
 	if (sk == p->exclude_sk)
 		goto out;
 
+	if (sk->sk_net != p->exclude_sk->sk_net)
+		goto out;
+
 	if (nlk->pid == p->pid || p->group - 1 >= nlk->ngroups ||
 	    !test_bit(p->group - 1, nlk->groups))
 		goto out;
@@ -1276,7 +1293,7 @@
  */
 
 struct sock *
-netlink_kernel_create(int unit, unsigned int groups,
+netlink_kernel_create(struct net *net, int unit, unsigned int groups,
 		      void (*input)(struct sock *sk, int len),
 		      struct mutex *cb_mutex, struct module *module)
 {
@@ -1293,7 +1310,7 @@
 	if (sock_create_lite(PF_NETLINK, SOCK_DGRAM, unit, &sock))
 		return NULL;
 
-	if (__netlink_create(sock, cb_mutex, unit) < 0)
+	if (__netlink_create(net, sock, cb_mutex, unit) < 0)
 		goto out_sock_release;
 
 	if (groups < 32)
@@ -1308,18 +1325,20 @@
 	if (input)
 		nlk_sk(sk)->data_ready = input;
 
-	if (netlink_insert(sk, 0))
+	if (netlink_insert(sk, net, 0))
 		goto out_sock_release;
 
 	nlk = nlk_sk(sk);
 	nlk->flags |= NETLINK_KERNEL_SOCKET;
 
 	netlink_table_grab();
+	if (!nl_table[unit].registered) {
 	nl_table[unit].groups = groups;
 	nl_table[unit].listeners = listeners;
 	nl_table[unit].cb_mutex = cb_mutex;
 	nl_table[unit].module = module;
 	nl_table[unit].registered = 1;
+	}
 	netlink_table_ungrab();
 
 	return sk;
@@ -1420,7 +1439,7 @@
 	atomic_inc(&skb->users);
 	cb->skb = skb;
 
-	sk = netlink_lookup(ssk->sk_protocol, NETLINK_CB(skb).pid);
+	sk = netlink_lookup(ssk->sk_net, ssk->sk_protocol, NETLINK_CB(skb).pid);
 	if (sk == NULL) {
 		netlink_destroy_callback(cb);
 		return -ECONNREFUSED;
@@ -1462,7 +1481,8 @@
 	if (!skb) {
 		struct sock *sk;
 
-		sk = netlink_lookup(in_skb->sk->sk_protocol,
+		sk = netlink_lookup(in_skb->sk->sk_net,
+				    in_skb->sk->sk_protocol,
 				    NETLINK_CB(in_skb).pid);
 		if (sk) {
 			sk->sk_err = ENOBUFS;
@@ -1613,6 +1633,7 @@
 
 #ifdef CONFIG_PROC_FS
 struct nl_seq_iter {
+	struct net *net;
 	int link;
 	int hash_idx;
 };
@@ -1630,6 +1651,8 @@
 
 		for (j = 0; j <= hash->mask; j++) {
 			sk_for_each(s, node, &hash->table[j]) {
+				if (iter->net != s->sk_net)
+					continue;
 				if (off == pos) {
 					iter->link = i;
 					iter->hash_idx = j;
@@ -1659,11 +1682,14 @@
 	if (v == SEQ_START_TOKEN)
 		return netlink_seq_socket_idx(seq, 0);
 
-	s = sk_next(v);
+	iter = seq->private;
+	s = v;
+	do {
+		s = sk_next(s);
+	} while (s && (iter->net != s->sk_net));
 	if (s)
 		return s;
 
-	iter = seq->private;
 	i = iter->link;
 	j = iter->hash_idx + 1;
 
@@ -1672,6 +1698,8 @@
 
 		for (; j <= hash->mask; j++) {
 			s = sk_head(&hash->table[j]);
+			while (s && (iter->net != s->sk_net))
+				s = sk_next(s);
 			if (s) {
 				iter->link = i;
 				iter->hash_idx = j;
@@ -1742,15 +1770,24 @@
 
 	seq = file->private_data;
 	seq->private = iter;
+	iter->net = get_net(PROC_NET(inode));
 	return 0;
 }
 
+static int netlink_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct nl_seq_iter *iter = seq->private;
+	put_net(iter->net);
+	return seq_release_private(inode, file);
+}
+
 static const struct file_operations netlink_seq_fops = {
 	.owner		= THIS_MODULE,
 	.open		= netlink_seq_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
-	.release	= seq_release_private,
+	.release	= netlink_seq_release,
 };
 
 #endif
@@ -1792,6 +1829,27 @@
 	.owner	= THIS_MODULE,	/* for consistency 8) */
 };
 
+static int netlink_net_init(struct net *net)
+{
+#ifdef CONFIG_PROC_FS
+	if (!proc_net_fops_create(net, "netlink", 0, &netlink_seq_fops))
+		return -ENOMEM;
+#endif
+	return 0;
+}
+
+static void netlink_net_exit(struct net *net)
+{
+#ifdef CONFIG_PROC_FS
+	proc_net_remove(net, "netlink");
+#endif
+}
+
+static struct pernet_operations netlink_net_ops = {
+	.init = netlink_net_init,
+	.exit = netlink_net_exit,
+};
+
 static int __init netlink_proto_init(void)
 {
 	struct sk_buff *dummy_skb;
@@ -1837,9 +1895,7 @@
 	}
 
 	sock_register(&netlink_family_ops);
-#ifdef CONFIG_PROC_FS
-	proc_net_fops_create("netlink", 0, &netlink_seq_fops);
-#endif
+	register_pernet_subsys(&netlink_net_ops);
 	/* The netlink device handler may be needed early. */
 	rtnetlink_init();
 out:
diff -Nurb linux-2.6.22-590/net/netlink/genetlink.c linux-2.6.22-try2-netns/net/netlink/genetlink.c
--- linux-2.6.22-590/net/netlink/genetlink.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/netlink/genetlink.c	2007-12-19 22:49:20.000000000 -0500
@@ -557,8 +557,9 @@
 		goto errout_register;
 
 	netlink_set_nonroot(NETLINK_GENERIC, NL_NONROOT_RECV);
-	genl_sock = netlink_kernel_create(NETLINK_GENERIC, GENL_MAX_ID,
-					  genl_rcv, NULL, THIS_MODULE);
+	genl_sock = netlink_kernel_create(&init_net, NETLINK_GENERIC,
+					  GENL_MAX_ID, genl_rcv, NULL,
+					  THIS_MODULE);
 	if (genl_sock == NULL)
 		panic("GENL: Cannot initialize generic netlink\n");
 
diff -Nurb linux-2.6.22-590/net/netrom/af_netrom.c linux-2.6.22-try2-netns/net/netrom/af_netrom.c
--- linux-2.6.22-590/net/netrom/af_netrom.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/netrom/af_netrom.c	2007-12-19 22:49:20.000000000 -0500
@@ -41,6 +41,7 @@
 #include <net/ip.h>
 #include <net/tcp_states.h>
 #include <net/arp.h>
+#include <net/net_namespace.h>
 #include <linux/init.h>
 
 static int nr_ndevs = 4;
@@ -105,6 +106,9 @@
 {
 	struct net_device *dev = (struct net_device *)ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (event != NETDEV_DOWN)
 		return NOTIFY_DONE;
 
@@ -408,15 +412,18 @@
 	.obj_size = sizeof(struct nr_sock),
 };
 
-static int nr_create(struct socket *sock, int protocol)
+static int nr_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 	struct nr_sock *nr;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	if (sock->type != SOCK_SEQPACKET || protocol != 0)
 		return -ESOCKTNOSUPPORT;
 
-	if ((sk = sk_alloc(PF_NETROM, GFP_ATOMIC, &nr_proto, 1)) == NULL)
+	if ((sk = sk_alloc(net, PF_NETROM, GFP_ATOMIC, &nr_proto, 1)) == NULL)
 		return -ENOMEM;
 
 	nr = nr_sk(sk);
@@ -458,7 +465,7 @@
 	if (osk->sk_type != SOCK_SEQPACKET)
 		return NULL;
 
-	if ((sk = sk_alloc(PF_NETROM, GFP_ATOMIC, osk->sk_prot, 1)) == NULL)
+	if ((sk = sk_alloc(osk->sk_net, PF_NETROM, GFP_ATOMIC, osk->sk_prot, 1)) == NULL)
 		return NULL;
 
 	nr = nr_sk(sk);
@@ -1447,9 +1454,9 @@
 
 	nr_loopback_init();
 
-	proc_net_fops_create("nr", S_IRUGO, &nr_info_fops);
-	proc_net_fops_create("nr_neigh", S_IRUGO, &nr_neigh_fops);
-	proc_net_fops_create("nr_nodes", S_IRUGO, &nr_nodes_fops);
+	proc_net_fops_create(&init_net, "nr", S_IRUGO, &nr_info_fops);
+	proc_net_fops_create(&init_net, "nr_neigh", S_IRUGO, &nr_neigh_fops);
+	proc_net_fops_create(&init_net, "nr_nodes", S_IRUGO, &nr_nodes_fops);
 out:
 	return rc;
 fail:
@@ -1477,9 +1484,9 @@
 {
 	int i;
 
-	proc_net_remove("nr");
-	proc_net_remove("nr_neigh");
-	proc_net_remove("nr_nodes");
+	proc_net_remove(&init_net, "nr");
+	proc_net_remove(&init_net, "nr_neigh");
+	proc_net_remove(&init_net, "nr_nodes");
 	nr_loopback_clear();
 
 	nr_rt_free();
diff -Nurb linux-2.6.22-590/net/netrom/nr_route.c linux-2.6.22-try2-netns/net/netrom/nr_route.c
--- linux-2.6.22-590/net/netrom/nr_route.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/netrom/nr_route.c	2007-12-19 22:49:20.000000000 -0500
@@ -580,7 +580,7 @@
 {
 	struct net_device *dev;
 
-	if ((dev = dev_get_by_name(devname)) == NULL)
+	if ((dev = dev_get_by_name(&init_net, devname)) == NULL)
 		return NULL;
 
 	if ((dev->flags & IFF_UP) && dev->type == ARPHRD_AX25)
@@ -598,7 +598,7 @@
 	struct net_device *dev, *first = NULL;
 
 	read_lock(&dev_base_lock);
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if ((dev->flags & IFF_UP) && dev->type == ARPHRD_NETROM)
 			if (first == NULL || strncmp(dev->name, first->name, 3) < 0)
 				first = dev;
@@ -618,7 +618,7 @@
 	struct net_device *dev;
 
 	read_lock(&dev_base_lock);
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if ((dev->flags & IFF_UP) && dev->type == ARPHRD_NETROM && ax25cmp(addr, (ax25_address *)dev->dev_addr) == 0) {
 			dev_hold(dev);
 			goto out;
diff -Nurb linux-2.6.22-590/net/packet/af_packet.c linux-2.6.22-try2-netns/net/packet/af_packet.c
--- linux-2.6.22-590/net/packet/af_packet.c	2007-12-21 15:33:47.000000000 -0500
+++ linux-2.6.22-try2-netns/net/packet/af_packet.c	2007-12-19 22:49:20.000000000 -0500
@@ -65,6 +65,7 @@
 #include <net/protocol.h>
 #include <linux/skbuff.h>
 #include <net/sock.h>
+#include <net/net_namespace.h>
 #include <linux/errno.h>
 #include <linux/timer.h>
 #include <asm/system.h>
@@ -135,10 +136,6 @@
    packet classifier depends on it.
  */
 
-/* List of all packet sockets. */
-static HLIST_HEAD(packet_sklist);
-static DEFINE_RWLOCK(packet_sklist_lock);
-
 static atomic_t packet_socks_nr;
 
 
@@ -273,6 +270,9 @@
 	if (skb->pkt_type == PACKET_LOOPBACK)
 		goto out;
 
+	if (dev->nd_net != sk->sk_net)
+		goto out;
+
 	if ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)
 		goto oom;
 
@@ -344,7 +344,7 @@
 	 */
 
 	saddr->spkt_device[13] = 0;
-	dev = dev_get_by_name(saddr->spkt_device);
+	dev = dev_get_by_name(sk->sk_net, saddr->spkt_device);
 	err = -ENODEV;
 	if (dev == NULL)
 		goto out_unlock;
@@ -462,6 +462,9 @@
 	sk = pt->af_packet_priv;
 	po = pkt_sk(sk);
 
+	if (dev->nd_net != sk->sk_net)
+		goto drop;
+
 	skb->dev = dev;
 
 	if (dev->hard_header) {
@@ -578,6 +581,9 @@
 	sk = pt->af_packet_priv;
 	po = pkt_sk(sk);
 
+	if (dev->nd_net != sk->sk_net)
+		goto drop;
+
 	if (dev->hard_header) {
 		if (sk->sk_type != SOCK_DGRAM)
 			skb_push(skb, skb->data - skb_mac_header(skb));
@@ -738,7 +744,7 @@
 	}
 
 
-	dev = dev_get_by_index(ifindex);
+	dev = dev_get_by_index(sk->sk_net, ifindex);
 	err = -ENXIO;
 	if (dev == NULL)
 		goto out_unlock;
@@ -811,15 +817,17 @@
 {
 	struct sock *sk = sock->sk;
 	struct packet_sock *po;
+	struct net *net;
 
 	if (!sk)
 		return 0;
 
+	net = sk->sk_net;
 	po = pkt_sk(sk);
 
-	write_lock_bh(&packet_sklist_lock);
+	write_lock_bh(&net->packet_sklist_lock);
 	sk_del_node_init(sk);
-	write_unlock_bh(&packet_sklist_lock);
+	write_unlock_bh(&net->packet_sklist_lock);
 
 	/*
 	 *	Unhook packet receive handler.
@@ -933,7 +941,7 @@
 		return -EINVAL;
 	strlcpy(name,uaddr->sa_data,sizeof(name));
 
-	dev = dev_get_by_name(name);
+	dev = dev_get_by_name(sk->sk_net, name);
 	if (dev) {
 		err = packet_do_bind(sk, dev, pkt_sk(sk)->num);
 		dev_put(dev);
@@ -960,7 +968,7 @@
 
 	if (sll->sll_ifindex) {
 		err = -ENODEV;
-		dev = dev_get_by_index(sll->sll_ifindex);
+		dev = dev_get_by_index(sk->sk_net, sll->sll_ifindex);
 		if (dev == NULL)
 			goto out;
 	}
@@ -982,7 +990,7 @@
  *	Create a packet of type SOCK_PACKET.
  */
 
-static int packet_create(struct socket *sock, int protocol)
+static int packet_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 	struct packet_sock *po;
@@ -998,7 +1006,7 @@
 	sock->state = SS_UNCONNECTED;
 
 	err = -ENOBUFS;
-	sk = sk_alloc(PF_PACKET, GFP_KERNEL, &packet_proto, 1);
+	sk = sk_alloc(net, PF_PACKET, GFP_KERNEL, &packet_proto, 1);
 	if (sk == NULL)
 		goto out;
 
@@ -1034,9 +1042,9 @@
 		po->running = 1;
 	}
 
-	write_lock_bh(&packet_sklist_lock);
-	sk_add_node(sk, &packet_sklist);
-	write_unlock_bh(&packet_sklist_lock);
+	write_lock_bh(&net->packet_sklist_lock);
+	sk_add_node(sk, &net->packet_sklist);
+	write_unlock_bh(&net->packet_sklist_lock);
 	return(0);
 out:
 	return err;
@@ -1154,7 +1162,7 @@
 		return -EOPNOTSUPP;
 
 	uaddr->sa_family = AF_PACKET;
-	dev = dev_get_by_index(pkt_sk(sk)->ifindex);
+	dev = dev_get_by_index(sk->sk_net, pkt_sk(sk)->ifindex);
 	if (dev) {
 		strlcpy(uaddr->sa_data, dev->name, 15);
 		dev_put(dev);
@@ -1179,7 +1187,7 @@
 	sll->sll_family = AF_PACKET;
 	sll->sll_ifindex = po->ifindex;
 	sll->sll_protocol = po->num;
-	dev = dev_get_by_index(po->ifindex);
+	dev = dev_get_by_index(sk->sk_net, po->ifindex);
 	if (dev) {
 		sll->sll_hatype = dev->type;
 		sll->sll_halen = dev->addr_len;
@@ -1231,7 +1239,7 @@
 	rtnl_lock();
 
 	err = -ENODEV;
-	dev = __dev_get_by_index(mreq->mr_ifindex);
+	dev = __dev_get_by_index(sk->sk_net, mreq->mr_ifindex);
 	if (!dev)
 		goto done;
 
@@ -1285,7 +1293,7 @@
 			if (--ml->count == 0) {
 				struct net_device *dev;
 				*mlp = ml->next;
-				dev = dev_get_by_index(ml->ifindex);
+				dev = dev_get_by_index(sk->sk_net, ml->ifindex);
 				if (dev) {
 					packet_dev_mc(dev, ml, -1);
 					dev_put(dev);
@@ -1313,7 +1321,7 @@
 		struct net_device *dev;
 
 		po->mclist = ml->next;
-		if ((dev = dev_get_by_index(ml->ifindex)) != NULL) {
+		if ((dev = dev_get_by_index(sk->sk_net, ml->ifindex)) != NULL) {
 			packet_dev_mc(dev, ml, -1);
 			dev_put(dev);
 		}
@@ -1469,9 +1477,10 @@
 	struct sock *sk;
 	struct hlist_node *node;
 	struct net_device *dev = data;
+	struct net *net = dev->nd_net;
 
-	read_lock(&packet_sklist_lock);
-	sk_for_each(sk, node, &packet_sklist) {
+	read_lock(&net->packet_sklist_lock);
+	sk_for_each(sk, node, &net->packet_sklist) {
 		struct packet_sock *po = pkt_sk(sk);
 
 		switch (msg) {
@@ -1510,7 +1519,7 @@
 			break;
 		}
 	}
-	read_unlock(&packet_sklist_lock);
+	read_unlock(&net->packet_sklist_lock);
 	return NOTIFY_DONE;
 }
 
@@ -1878,12 +1887,12 @@
 };
 
 #ifdef CONFIG_PROC_FS
-static inline struct sock *packet_seq_idx(loff_t off)
+static inline struct sock *packet_seq_idx(struct net *net, loff_t off)
 {
 	struct sock *s;
 	struct hlist_node *node;
 
-	sk_for_each(s, node, &packet_sklist) {
+	sk_for_each(s, node, &net->packet_sklist) {
 		if (!off--)
 			return s;
 	}
@@ -1892,21 +1901,24 @@
 
 static void *packet_seq_start(struct seq_file *seq, loff_t *pos)
 {
-	read_lock(&packet_sklist_lock);
-	return *pos ? packet_seq_idx(*pos - 1) : SEQ_START_TOKEN;
+	struct net *net = seq->private;
+	read_lock(&net->packet_sklist_lock);
+	return *pos ? packet_seq_idx(net, *pos - 1) : SEQ_START_TOKEN;
 }
 
 static void *packet_seq_next(struct seq_file *seq, void *v, loff_t *pos)
 {
+	struct net *net = seq->private;
 	++*pos;
 	return  (v == SEQ_START_TOKEN)
-		? sk_head(&packet_sklist)
+		? sk_head(&net->packet_sklist)
 		: sk_next((struct sock*)v) ;
 }
 
 static void packet_seq_stop(struct seq_file *seq, void *v)
 {
-	read_unlock(&packet_sklist_lock);
+	struct net *net = seq->private;
+	read_unlock(&net->packet_sklist_lock);
 }
 
 static int packet_seq_show(struct seq_file *seq, void *v)
@@ -1942,7 +1954,22 @@
 
 static int packet_seq_open(struct inode *inode, struct file *file)
 {
-	return seq_open(file, &packet_seq_ops);
+	struct seq_file *seq;
+	int res;
+	res = seq_open(file, &packet_seq_ops);
+	if (!res) {
+		seq = file->private_data;
+		seq->private = get_net(PROC_NET(inode));
+	}
+	return res;
+}
+
+static int packet_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq=  file->private_data;
+	struct net *net = seq->private;
+	put_net(net);
+	return seq_release(inode, file);
 }
 
 static const struct file_operations packet_seq_fops = {
@@ -1950,15 +1977,37 @@
 	.open		= packet_seq_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
-	.release	= seq_release,
+	.release	= packet_seq_release,
 };
 
 #endif
 
+static int packet_net_init(struct net *net)
+{
+	rwlock_init(&net->packet_sklist_lock);
+	INIT_HLIST_HEAD(&net->packet_sklist);
+
+	if (!proc_net_fops_create(net, "packet", 0, &packet_seq_fops))
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void packet_net_exit(struct net *net)
+{
+	proc_net_remove(net, "packet");
+}
+
+static struct pernet_operations packet_net_ops = {
+	.init = packet_net_init,
+	.exit = packet_net_exit,
+};
+
+
 static void __exit packet_exit(void)
 {
-	proc_net_remove("packet");
 	unregister_netdevice_notifier(&packet_netdev_notifier);
+	unregister_pernet_subsys(&packet_net_ops);
 	sock_unregister(PF_PACKET);
 	proto_unregister(&packet_proto);
 }
@@ -1971,8 +2020,8 @@
 		goto out;
 
 	sock_register(&packet_family_ops);
+	register_pernet_subsys(&packet_net_ops);
 	register_netdevice_notifier(&packet_netdev_notifier);
-	proc_net_fops_create("packet", 0, &packet_seq_fops);
 out:
 	return rc;
 }
diff -Nurb linux-2.6.22-590/net/rose/af_rose.c linux-2.6.22-try2-netns/net/rose/af_rose.c
--- linux-2.6.22-590/net/rose/af_rose.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/rose/af_rose.c	2007-12-19 22:49:20.000000000 -0500
@@ -45,6 +45,7 @@
 #include <net/tcp_states.h>
 #include <net/ip.h>
 #include <net/arp.h>
+#include <net/net_namespace.h>
 
 static int rose_ndevs = 10;
 
@@ -196,6 +197,9 @@
 {
 	struct net_device *dev = (struct net_device *)ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (event != NETDEV_DOWN)
 		return NOTIFY_DONE;
 
@@ -498,15 +502,18 @@
 	.obj_size = sizeof(struct rose_sock),
 };
 
-static int rose_create(struct socket *sock, int protocol)
+static int rose_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 	struct rose_sock *rose;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	if (sock->type != SOCK_SEQPACKET || protocol != 0)
 		return -ESOCKTNOSUPPORT;
 
-	if ((sk = sk_alloc(PF_ROSE, GFP_ATOMIC, &rose_proto, 1)) == NULL)
+	if ((sk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto, 1)) == NULL)
 		return -ENOMEM;
 
 	rose = rose_sk(sk);
@@ -544,7 +551,7 @@
 	if (osk->sk_type != SOCK_SEQPACKET)
 		return NULL;
 
-	if ((sk = sk_alloc(PF_ROSE, GFP_ATOMIC, &rose_proto, 1)) == NULL)
+	if ((sk = sk_alloc(osk->sk_net, PF_ROSE, GFP_ATOMIC, &rose_proto, 1)) == NULL)
 		return NULL;
 
 	rose = rose_sk(sk);
@@ -1576,10 +1583,10 @@
 
 	rose_add_loopback_neigh();
 
-	proc_net_fops_create("rose", S_IRUGO, &rose_info_fops);
-	proc_net_fops_create("rose_neigh", S_IRUGO, &rose_neigh_fops);
-	proc_net_fops_create("rose_nodes", S_IRUGO, &rose_nodes_fops);
-	proc_net_fops_create("rose_routes", S_IRUGO, &rose_routes_fops);
+	proc_net_fops_create(&init_net, "rose", S_IRUGO, &rose_info_fops);
+	proc_net_fops_create(&init_net, "rose_neigh", S_IRUGO, &rose_neigh_fops);
+	proc_net_fops_create(&init_net, "rose_nodes", S_IRUGO, &rose_nodes_fops);
+	proc_net_fops_create(&init_net, "rose_routes", S_IRUGO, &rose_routes_fops);
 out:
 	return rc;
 fail:
@@ -1606,10 +1613,10 @@
 {
 	int i;
 
-	proc_net_remove("rose");
-	proc_net_remove("rose_neigh");
-	proc_net_remove("rose_nodes");
-	proc_net_remove("rose_routes");
+	proc_net_remove(&init_net, "rose");
+	proc_net_remove(&init_net, "rose_neigh");
+	proc_net_remove(&init_net, "rose_nodes");
+	proc_net_remove(&init_net, "rose_routes");
 	rose_loopback_clear();
 
 	rose_rt_free();
diff -Nurb linux-2.6.22-590/net/rose/rose_route.c linux-2.6.22-try2-netns/net/rose/rose_route.c
--- linux-2.6.22-590/net/rose/rose_route.c	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/net/rose/rose_route.c	2007-12-19 22:49:20.000000000 -0500
@@ -583,7 +583,7 @@
 {
 	struct net_device *dev;
 
-	if ((dev = dev_get_by_name(devname)) == NULL)
+	if ((dev = dev_get_by_name(&init_net, devname)) == NULL)
 		return NULL;
 
 	if ((dev->flags & IFF_UP) && dev->type == ARPHRD_AX25)
@@ -601,7 +601,7 @@
 	struct net_device *dev, *first = NULL;
 
 	read_lock(&dev_base_lock);
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE)
 			if (first == NULL || strncmp(dev->name, first->name, 3) < 0)
 				first = dev;
@@ -619,7 +619,7 @@
 	struct net_device *dev;
 
 	read_lock(&dev_base_lock);
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE && rosecmp(addr, (rose_address *)dev->dev_addr) == 0) {
 			dev_hold(dev);
 			goto out;
@@ -636,7 +636,7 @@
 	struct net_device *dev;
 
 	read_lock(&dev_base_lock);
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE && rosecmp(addr, (rose_address *)dev->dev_addr) == 0)
 			goto out;
 	}
diff -Nurb linux-2.6.22-590/net/rxrpc/af_rxrpc.c linux-2.6.22-try2-netns/net/rxrpc/af_rxrpc.c
--- linux-2.6.22-590/net/rxrpc/af_rxrpc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/rxrpc/af_rxrpc.c	2007-12-19 22:49:20.000000000 -0500
@@ -14,6 +14,7 @@
 #include <linux/skbuff.h>
 #include <linux/poll.h>
 #include <linux/proc_fs.h>
+#include <net/net_namespace.h>
 #include <net/sock.h>
 #include <net/af_rxrpc.h>
 #include "ar-internal.h"
@@ -605,13 +606,16 @@
 /*
  * create an RxRPC socket
  */
-static int rxrpc_create(struct socket *sock, int protocol)
+static int rxrpc_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct rxrpc_sock *rx;
 	struct sock *sk;
 
 	_enter("%p,%d", sock, protocol);
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	/* we support transport protocol UDP only */
 	if (protocol != PF_INET)
 		return -EPROTONOSUPPORT;
@@ -622,7 +626,7 @@
 	sock->ops = &rxrpc_rpc_ops;
 	sock->state = SS_UNCONNECTED;
 
-	sk = sk_alloc(PF_RXRPC, GFP_KERNEL, &rxrpc_proto, 1);
+	sk = sk_alloc(net, PF_RXRPC, GFP_KERNEL, &rxrpc_proto, 1);
 	if (!sk)
 		return -ENOMEM;
 
@@ -829,8 +833,8 @@
 	}
 
 #ifdef CONFIG_PROC_FS
-	proc_net_fops_create("rxrpc_calls", 0, &rxrpc_call_seq_fops);
-	proc_net_fops_create("rxrpc_conns", 0, &rxrpc_connection_seq_fops);
+	proc_net_fops_create(&init_net, "rxrpc_calls", 0, &rxrpc_call_seq_fops);
+	proc_net_fops_create(&init_net, "rxrpc_conns", 0, &rxrpc_connection_seq_fops);
 #endif
 	return 0;
 
@@ -868,8 +872,8 @@
 
 	_debug("flush scheduled work");
 	flush_workqueue(rxrpc_workqueue);
-	proc_net_remove("rxrpc_conns");
-	proc_net_remove("rxrpc_calls");
+	proc_net_remove(&init_net, "rxrpc_conns");
+	proc_net_remove(&init_net, "rxrpc_calls");
 	destroy_workqueue(rxrpc_workqueue);
 	kmem_cache_destroy(rxrpc_call_jar);
 	_leave("");
diff -Nurb linux-2.6.22-590/net/sched/act_api.c linux-2.6.22-try2-netns/net/sched/act_api.c
--- linux-2.6.22-590/net/sched/act_api.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/sched/act_api.c	2007-12-19 22:49:20.000000000 -0500
@@ -27,6 +27,7 @@
 #include <linux/skbuff.h>
 #include <linux/init.h>
 #include <linux/kmod.h>
+#include <net/net_namespace.h>
 #include <net/sock.h>
 #include <net/sch_generic.h>
 #include <net/act_api.h>
@@ -675,7 +676,7 @@
 		return -EINVAL;
 	}
 
-	return rtnl_unicast(skb, pid);
+	return rtnl_unicast(skb, &init_net, pid);
 }
 
 static struct tc_action *
@@ -796,7 +797,7 @@
 	nlh->nlmsg_flags |= NLM_F_ROOT;
 	module_put(a->ops->owner);
 	kfree(a);
-	err = rtnetlink_send(skb, pid, RTNLGRP_TC, n->nlmsg_flags&NLM_F_ECHO);
+	err = rtnetlink_send(skb, &init_net, pid, RTNLGRP_TC, n->nlmsg_flags&NLM_F_ECHO);
 	if (err > 0)
 		return 0;
 
@@ -859,7 +860,7 @@
 
 		/* now do the delete */
 		tcf_action_destroy(head, 0);
-		ret = rtnetlink_send(skb, pid, RTNLGRP_TC,
+		ret = rtnetlink_send(skb, &init_net, pid, RTNLGRP_TC,
 				     n->nlmsg_flags&NLM_F_ECHO);
 		if (ret > 0)
 			return 0;
@@ -903,7 +904,7 @@
 	nlh->nlmsg_len = skb_tail_pointer(skb) - b;
 	NETLINK_CB(skb).dst_group = RTNLGRP_TC;
 
-	err = rtnetlink_send(skb, pid, RTNLGRP_TC, flags&NLM_F_ECHO);
+	err = rtnetlink_send(skb, &init_net, pid, RTNLGRP_TC, flags&NLM_F_ECHO);
 	if (err > 0)
 		err = 0;
 	return err;
@@ -941,10 +942,14 @@
 
 static int tc_ctl_action(struct sk_buff *skb, struct nlmsghdr *n, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct rtattr **tca = arg;
 	u32 pid = skb ? NETLINK_CB(skb).pid : 0;
 	int ret = 0, ovr = 0;
 
+	if (net != &init_net)
+		return -EINVAL;
+
 	if (tca[TCA_ACT_TAB-1] == NULL) {
 		printk("tc_ctl_action: received NO action attribs\n");
 		return -EINVAL;
@@ -1014,6 +1019,7 @@
 static int
 tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	struct nlmsghdr *nlh;
 	unsigned char *b = skb_tail_pointer(skb);
 	struct rtattr *x;
@@ -1023,6 +1029,9 @@
 	struct tcamsg *t = (struct tcamsg *) NLMSG_DATA(cb->nlh);
 	struct rtattr *kind = find_dump_kind(cb->nlh);
 
+	if (net != &init_net)
+		return 0;
+
 	if (kind == NULL) {
 		printk("tc_dump_action: action bad kind\n");
 		return 0;
diff -Nurb linux-2.6.22-590/net/sched/act_mirred.c linux-2.6.22-try2-netns/net/sched/act_mirred.c
--- linux-2.6.22-590/net/sched/act_mirred.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/sched/act_mirred.c	2007-12-19 22:49:20.000000000 -0500
@@ -85,7 +85,7 @@
 	parm = RTA_DATA(tb[TCA_MIRRED_PARMS-1]);
 
 	if (parm->ifindex) {
-		dev = __dev_get_by_index(parm->ifindex);
+		dev = __dev_get_by_index(&init_net, parm->ifindex);
 		if (dev == NULL)
 			return -ENODEV;
 		switch (dev->type) {
diff -Nurb linux-2.6.22-590/net/sched/cls_api.c linux-2.6.22-try2-netns/net/sched/cls_api.c
--- linux-2.6.22-590/net/sched/cls_api.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/sched/cls_api.c	2007-12-19 22:49:20.000000000 -0500
@@ -129,6 +129,7 @@
 
 static int tc_ctl_tfilter(struct sk_buff *skb, struct nlmsghdr *n, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct rtattr **tca;
 	struct tcmsg *t;
 	u32 protocol;
@@ -145,6 +146,9 @@
 	unsigned long fh;
 	int err;
 
+	if (net != &init_net)
+		return -EINVAL;
+
 replay:
 	tca = arg;
 	t = NLMSG_DATA(n);
@@ -164,7 +168,7 @@
 	/* Find head of filter chain. */
 
 	/* Find link */
-	if ((dev = __dev_get_by_index(t->tcm_ifindex)) == NULL)
+	if ((dev = __dev_get_by_index(&init_net, t->tcm_ifindex)) == NULL)
 		return -ENODEV;
 
 	/* Find qdisc */
@@ -365,7 +369,7 @@
 		return -EINVAL;
 	}
 
-	return rtnetlink_send(skb, pid, RTNLGRP_TC, n->nlmsg_flags&NLM_F_ECHO);
+	return rtnetlink_send(skb, &init_net, pid, RTNLGRP_TC, n->nlmsg_flags&NLM_F_ECHO);
 }
 
 struct tcf_dump_args
@@ -385,6 +389,7 @@
 
 static int tc_dump_tfilter(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	int t;
 	int s_t;
 	struct net_device *dev;
@@ -395,9 +400,12 @@
 	struct Qdisc_class_ops *cops;
 	struct tcf_dump_args arg;
 
+	if (net != &init_net)
+		return 0;
+
 	if (cb->nlh->nlmsg_len < NLMSG_LENGTH(sizeof(*tcm)))
 		return skb->len;
-	if ((dev = dev_get_by_index(tcm->tcm_ifindex)) == NULL)
+	if ((dev = dev_get_by_index(&init_net, tcm->tcm_ifindex)) == NULL)
 		return skb->len;
 
 	if (!tcm->tcm_parent)
diff -Nurb linux-2.6.22-590/net/sched/em_meta.c linux-2.6.22-try2-netns/net/sched/em_meta.c
--- linux-2.6.22-590/net/sched/em_meta.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/sched/em_meta.c	2007-12-19 22:49:20.000000000 -0500
@@ -291,7 +291,7 @@
 	 } else  {
 		struct net_device *dev;
 
-		dev = dev_get_by_index(skb->sk->sk_bound_dev_if);
+		dev = dev_get_by_index(&init_net, skb->sk->sk_bound_dev_if);
 		*err = var_dev(dev, dst);
 		if (dev)
 			dev_put(dev);
diff -Nurb linux-2.6.22-590/net/sched/sch_api.c linux-2.6.22-try2-netns/net/sched/sch_api.c
--- linux-2.6.22-590/net/sched/sch_api.c	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/net/sched/sch_api.c	2007-12-19 22:49:20.000000000 -0500
@@ -35,6 +35,7 @@
 #include <linux/bitops.h>
 #include <linux/hrtimer.h>
 
+#include <net/net_namespace.h>
 #include <net/netlink.h>
 #include <net/sock.h>
 #include <net/pkt_sched.h>
@@ -609,6 +610,7 @@
 
 static int tc_get_qdisc(struct sk_buff *skb, struct nlmsghdr *n, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct tcmsg *tcm = NLMSG_DATA(n);
 	struct rtattr **tca = arg;
 	struct net_device *dev;
@@ -617,7 +619,10 @@
 	struct Qdisc *p = NULL;
 	int err;
 
-	if ((dev = __dev_get_by_index(tcm->tcm_ifindex)) == NULL)
+	if (net != &init_net)
+		return -EINVAL;
+
+	if ((dev = __dev_get_by_index(&init_net, tcm->tcm_ifindex)) == NULL)
 		return -ENODEV;
 
 	if (clid) {
@@ -670,6 +675,7 @@
 
 static int tc_modify_qdisc(struct sk_buff *skb, struct nlmsghdr *n, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct tcmsg *tcm;
 	struct rtattr **tca;
 	struct net_device *dev;
@@ -677,6 +683,9 @@
 	struct Qdisc *q, *p;
 	int err;
 
+	if (net != &init_net)
+		return -EINVAL;
+
 replay:
 	/* Reinit, just in case something touches this. */
 	tcm = NLMSG_DATA(n);
@@ -684,7 +693,7 @@
 	clid = tcm->tcm_parent;
 	q = p = NULL;
 
-	if ((dev = __dev_get_by_index(tcm->tcm_ifindex)) == NULL)
+	if ((dev = __dev_get_by_index(&init_net, tcm->tcm_ifindex)) == NULL)
 		return -ENODEV;
 
 	if (clid) {
@@ -873,7 +882,7 @@
 	}
 
 	if (skb->len)
-		return rtnetlink_send(skb, pid, RTNLGRP_TC, n->nlmsg_flags&NLM_F_ECHO);
+		return rtnetlink_send(skb, &init_net, pid, RTNLGRP_TC, n->nlmsg_flags&NLM_F_ECHO);
 
 err_out:
 	kfree_skb(skb);
@@ -882,16 +891,20 @@
 
 static int tc_dump_qdisc(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	int idx, q_idx;
 	int s_idx, s_q_idx;
 	struct net_device *dev;
 	struct Qdisc *q;
 
+	if (net != &init_net)
+		return 0;
+
 	s_idx = cb->args[0];
 	s_q_idx = q_idx = cb->args[1];
 	read_lock(&dev_base_lock);
 	idx = 0;
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		if (idx < s_idx)
 			goto cont;
 		if (idx > s_idx)
@@ -930,6 +943,7 @@
 
 static int tc_ctl_tclass(struct sk_buff *skb, struct nlmsghdr *n, void *arg)
 {
+	struct net *net = skb->sk->sk_net;
 	struct tcmsg *tcm = NLMSG_DATA(n);
 	struct rtattr **tca = arg;
 	struct net_device *dev;
@@ -942,7 +956,10 @@
 	u32 qid = TC_H_MAJ(clid);
 	int err;
 
-	if ((dev = __dev_get_by_index(tcm->tcm_ifindex)) == NULL)
+	if (net != &init_net)
+		return -EINVAL;
+
+	if ((dev = __dev_get_by_index(&init_net, tcm->tcm_ifindex)) == NULL)
 		return -ENODEV;
 
 	/*
@@ -1096,7 +1113,7 @@
 		return -EINVAL;
 	}
 
-	return rtnetlink_send(skb, pid, RTNLGRP_TC, n->nlmsg_flags&NLM_F_ECHO);
+	return rtnetlink_send(skb, &init_net, pid, RTNLGRP_TC, n->nlmsg_flags&NLM_F_ECHO);
 }
 
 struct qdisc_dump_args
@@ -1116,6 +1133,7 @@
 
 static int tc_dump_tclass(struct sk_buff *skb, struct netlink_callback *cb)
 {
+	struct net *net = skb->sk->sk_net;
 	int t;
 	int s_t;
 	struct net_device *dev;
@@ -1123,9 +1141,12 @@
 	struct tcmsg *tcm = (struct tcmsg*)NLMSG_DATA(cb->nlh);
 	struct qdisc_dump_args arg;
 
+	if (net != &init_net)
+		return 0;
+
 	if (cb->nlh->nlmsg_len < NLMSG_LENGTH(sizeof(*tcm)))
 		return 0;
-	if ((dev = dev_get_by_index(tcm->tcm_ifindex)) == NULL)
+	if ((dev = dev_get_by_index(&init_net, tcm->tcm_ifindex)) == NULL)
 		return 0;
 
 	s_t = cb->args[0];
@@ -1252,7 +1273,7 @@
 {
 	register_qdisc(&pfifo_qdisc_ops);
 	register_qdisc(&bfifo_qdisc_ops);
-	proc_net_fops_create("psched", 0, &psched_fops);
+	proc_net_fops_create(&init_net, "psched", 0, &psched_fops);
 
 	rtnl_register(PF_UNSPEC, RTM_NEWQDISC, tc_modify_qdisc, NULL);
 	rtnl_register(PF_UNSPEC, RTM_DELQDISC, tc_get_qdisc, NULL);
diff -Nurb linux-2.6.22-590/net/sched/sch_ingress.c linux-2.6.22-try2-netns/net/sched/sch_ingress.c
--- linux-2.6.22-590/net/sched/sch_ingress.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/sched/sch_ingress.c	2007-12-19 22:49:20.000000000 -0500
@@ -243,6 +243,10 @@
 	struct net_device *dev = skb->dev;
 	int fwres=NF_ACCEPT;
 
+	/* Only filter packets in the initial network namespace */
+	if ((indev?indev:outdev)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	DPRINTK("ing_hook: skb %s dev=%s len=%u\n",
 		skb->sk ? "(owned)" : "(unowned)",
 		skb->dev ? (*pskb)->dev->name : "(no dev)",
diff -Nurb linux-2.6.22-590/net/sctp/input.c linux-2.6.22-try2-netns/net/sctp/input.c
--- linux-2.6.22-590/net/sctp/input.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/sctp/input.c	2007-12-19 22:49:20.000000000 -0500
@@ -126,6 +126,10 @@
 	int family;
 	struct sctp_af *af;
 
+	if (skb->dev->nd_net != &init_net) {
+		kfree_skb(skb);
+		return 0;
+	}
 	if (skb->pkt_type!=PACKET_HOST)
 		goto discard_it;
 
@@ -509,6 +513,9 @@
 	sk_buff_data_t saveip, savesctp;
 	int err;
 
+	if (skb->dev->nd_net != &init_net)
+		return;
+
 	if (skb->len < ihlen + 8) {
 		ICMP_INC_STATS_BH(ICMP_MIB_INERRORS);
 		return;
diff -Nurb linux-2.6.22-590/net/sctp/ipv6.c linux-2.6.22-try2-netns/net/sctp/ipv6.c
--- linux-2.6.22-590/net/sctp/ipv6.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/sctp/ipv6.c	2007-12-19 22:49:20.000000000 -0500
@@ -189,6 +189,7 @@
 
 	memset(&fl, 0, sizeof(fl));
 
+	fl.fl_net = &init_net;
 	fl.proto = sk->sk_protocol;
 
 	/* Fill in the dest address from the route entry passed with the skb
@@ -230,6 +231,7 @@
 	struct flowi fl;
 
 	memset(&fl, 0, sizeof(fl));
+	fl.fl_net = &init_net;
 	ipv6_addr_copy(&fl.fl6_dst, &daddr->v6.sin6_addr);
 	if (ipv6_addr_type(&daddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
 		fl.oif = daddr->v6.sin6_scope_id;
@@ -619,7 +621,7 @@
 	struct ipv6_pinfo *newnp, *np = inet6_sk(sk);
 	struct sctp6_sock *newsctp6sk;
 
-	newsk = sk_alloc(PF_INET6, GFP_KERNEL, sk->sk_prot, 1);
+	newsk = sk_alloc(sk->sk_net, PF_INET6, GFP_KERNEL, sk->sk_prot, 1);
 	if (!newsk)
 		goto out;
 
@@ -664,7 +666,7 @@
 	newinet->mc_index = 0;
 	newinet->mc_list = NULL;
 
-	if (ipv4_config.no_pmtu_disc)
+	if (init_net.sysctl_ipv4_no_pmtu_disc)
 		newinet->pmtudisc = IP_PMTUDISC_DONT;
 	else
 		newinet->pmtudisc = IP_PMTUDISC_WANT;
@@ -841,7 +843,7 @@
 		if (type & IPV6_ADDR_LINKLOCAL) {
 			if (!addr->v6.sin6_scope_id)
 				return 0;
-			dev = dev_get_by_index(addr->v6.sin6_scope_id);
+			dev = dev_get_by_index(&init_net, addr->v6.sin6_scope_id);
 			if (!dev)
 				return 0;
 			if (!ipv6_chk_addr(&addr->v6.sin6_addr, dev, 0)) {
@@ -872,7 +874,7 @@
 		if (type & IPV6_ADDR_LINKLOCAL) {
 			if (!addr->v6.sin6_scope_id)
 				return 0;
-			dev = dev_get_by_index(addr->v6.sin6_scope_id);
+			dev = dev_get_by_index(&init_net, addr->v6.sin6_scope_id);
 			if (!dev)
 				return 0;
 			if (!ipv6_chk_addr(&addr->v6.sin6_addr, dev, 0)) {
diff -Nurb linux-2.6.22-590/net/sctp/protocol.c linux-2.6.22-try2-netns/net/sctp/protocol.c
--- linux-2.6.22-590/net/sctp/protocol.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/sctp/protocol.c	2007-12-19 22:49:20.000000000 -0500
@@ -59,6 +59,7 @@
 #include <net/addrconf.h>
 #include <net/inet_common.h>
 #include <net/inet_ecn.h>
+#include <net/net_namespace.h>
 
 /* Global data structures. */
 struct sctp_globals sctp_globals __read_mostly;
@@ -93,7 +94,7 @@
 {
 	if (!proc_net_sctp) {
 		struct proc_dir_entry *ent;
-		ent = proc_mkdir("net/sctp", NULL);
+		ent = proc_mkdir("sctp", init_net.proc_net);
 		if (ent) {
 			ent->owner = THIS_MODULE;
 			proc_net_sctp = ent;
@@ -126,7 +127,7 @@
 
 	if (proc_net_sctp) {
 		proc_net_sctp = NULL;
-		remove_proc_entry("net/sctp", NULL);
+		remove_proc_entry("sctp", init_net.proc_net);
 	}
 }
 
@@ -170,7 +171,7 @@
 	struct sctp_af *af;
 
 	read_lock(&dev_base_lock);
-	for_each_netdev(dev) {
+	for_each_netdev(&init_net, dev) {
 		__list_for_each(pos, &sctp_address_families) {
 			af = list_entry(pos, struct sctp_af, list);
 			af->copy_addrlist(&sctp_local_addr_list, dev);
@@ -354,13 +355,13 @@
 /* Should this be available for binding?   */
 static int sctp_v4_available(union sctp_addr *addr, struct sctp_sock *sp)
 {
-	int ret = inet_addr_type(addr->v4.sin_addr.s_addr);
+	int ret = inet_addr_type(&init_net, addr->v4.sin_addr.s_addr);
 
 
 	if (addr->v4.sin_addr.s_addr != INADDR_ANY &&
 	   ret != RTN_LOCAL &&
 	   !sp->inet.freebind &&
-	   !sysctl_ip_nonlocal_bind)
+	   !init_net.sysctl_ip_nonlocal_bind)
 		return 0;
 
 	return 1;
@@ -423,6 +424,7 @@
 	union sctp_addr dst_saddr;
 
 	memset(&fl, 0x0, sizeof(struct flowi));
+	fl.fl_net = &init_net;
 	fl.fl4_dst  = daddr->v4.sin_addr.s_addr;
 	fl.proto = IPPROTO_SCTP;
 	if (asoc) {
@@ -539,7 +541,7 @@
 {
 	struct inet_sock *inet = inet_sk(sk);
 	struct inet_sock *newinet;
-	struct sock *newsk = sk_alloc(PF_INET, GFP_KERNEL, sk->sk_prot, 1);
+	struct sock *newsk = sk_alloc(sk->sk_net, PF_INET, GFP_KERNEL, sk->sk_prot, 1);
 
 	if (!newsk)
 		goto out;
@@ -1122,7 +1124,7 @@
 	}
 
 	spin_lock_init(&sctp_port_alloc_lock);
-	sctp_port_rover = sysctl_local_port_range[0] - 1;
+	sctp_port_rover = init_net.sysctl_local_port_range[0] - 1;
 
 	printk(KERN_INFO "SCTP: Hash tables configured "
 			 "(established %d bind %d)\n",
diff -Nurb linux-2.6.22-590/net/sctp/socket.c linux-2.6.22-try2-netns/net/sctp/socket.c
--- linux-2.6.22-590/net/sctp/socket.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/sctp/socket.c	2007-12-19 22:49:20.000000000 -0500
@@ -5021,8 +5021,8 @@
 		 * already in the hash table; if not, we use that; if
 		 * it is, we try next.
 		 */
-		int low = sysctl_local_port_range[0];
-		int high = sysctl_local_port_range[1];
+		int low = sk->sk_net->sysctl_local_port_range[0];
+		int high = sk->sk_net->sysctl_local_port_range[1];
 		int remaining = (high - low) + 1;
 		int rover;
 		int index;
diff -Nurb linux-2.6.22-590/net/socket.c linux-2.6.22-try2-netns/net/socket.c
--- linux-2.6.22-590/net/socket.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/socket.c	2007-12-19 22:49:20.000000000 -0500
@@ -84,6 +84,7 @@
 #include <linux/kmod.h>
 #include <linux/audit.h>
 #include <linux/wireless.h>
+#include <linux/nsproxy.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -821,9 +822,9 @@
  */
 
 static DEFINE_MUTEX(br_ioctl_mutex);
-static int (*br_ioctl_hook) (unsigned int cmd, void __user *arg) = NULL;
+static int (*br_ioctl_hook) (struct net *, unsigned int cmd, void __user *arg) = NULL;
 
-void brioctl_set(int (*hook) (unsigned int, void __user *))
+void brioctl_set(int (*hook) (struct net *, unsigned int, void __user *))
 {
 	mutex_lock(&br_ioctl_mutex);
 	br_ioctl_hook = hook;
@@ -833,9 +834,9 @@
 EXPORT_SYMBOL(brioctl_set);
 
 static DEFINE_MUTEX(vlan_ioctl_mutex);
-static int (*vlan_ioctl_hook) (void __user *arg);
+static int (*vlan_ioctl_hook) (struct net *, void __user *arg);
 
-void vlan_ioctl_set(int (*hook) (void __user *))
+void vlan_ioctl_set(int (*hook) (struct net *, void __user *))
 {
 	mutex_lock(&vlan_ioctl_mutex);
 	vlan_ioctl_hook = hook;
@@ -864,16 +865,20 @@
 static long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)
 {
 	struct socket *sock;
+	struct sock *sk;
 	void __user *argp = (void __user *)arg;
 	int pid, err;
+	struct net *net;
 
 	sock = file->private_data;
+	sk = sock->sk;
+	net = sk->sk_net;
 	if (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15)) {
-		err = dev_ioctl(cmd, argp);
+		err = dev_ioctl(net, cmd, argp);
 	} else
 #ifdef CONFIG_WIRELESS_EXT
 	if (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST) {
-		err = dev_ioctl(cmd, argp);
+		err = dev_ioctl(net, cmd, argp);
 	} else
 #endif				/* CONFIG_WIRELESS_EXT */
 		switch (cmd) {
@@ -899,7 +904,7 @@
 
 			mutex_lock(&br_ioctl_mutex);
 			if (br_ioctl_hook)
-				err = br_ioctl_hook(cmd, argp);
+				err = br_ioctl_hook(net, cmd, argp);
 			mutex_unlock(&br_ioctl_mutex);
 			break;
 		case SIOCGIFVLAN:
@@ -910,7 +915,7 @@
 
 			mutex_lock(&vlan_ioctl_mutex);
 			if (vlan_ioctl_hook)
-				err = vlan_ioctl_hook(argp);
+				err = vlan_ioctl_hook(net, argp);
 			mutex_unlock(&vlan_ioctl_mutex);
 			break;
 		case SIOCADDDLCI:
@@ -933,7 +938,7 @@
 			 * to the NIC driver.
 			 */
 			if (err == -ENOIOCTLCMD)
-				err = dev_ioctl(cmd, argp);
+				err = dev_ioctl(net, cmd, argp);
 			break;
 		}
 	return err;
@@ -1102,7 +1107,7 @@
 	return 0;
 }
 
-static int __sock_create(int family, int type, int protocol,
+static int __sock_create(struct net *net, int family, int type, int protocol,
 			 struct socket **res, int kern)
 {
 	int err;
@@ -1185,7 +1190,7 @@
 	/* Now protected by module ref count */
 	rcu_read_unlock();
 
-	err = pf->create(sock, protocol);
+	err = pf->create(net, sock, protocol);
 	if (err < 0)
 		goto out_module_put;
 
@@ -1224,12 +1229,12 @@
 
 int sock_create(int family, int type, int protocol, struct socket **res)
 {
-	return __sock_create(family, type, protocol, res, 0);
+	return __sock_create(current->nsproxy->net_ns, family, type, protocol, res, 0);
 }
 
 int sock_create_kern(int family, int type, int protocol, struct socket **res)
 {
-	return __sock_create(family, type, protocol, res, 1);
+	return __sock_create(&init_net, family, type, protocol, res, 1);
 }
 
 asmlinkage long sys_socket(int family, int type, int protocol)
@@ -1389,8 +1394,6 @@
  *	ready for listening.
  */
 
-int sysctl_somaxconn __read_mostly = SOMAXCONN;
-
 asmlinkage long sys_listen(int fd, int backlog)
 {
 	struct socket *sock;
@@ -1398,8 +1401,9 @@
 
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (sock) {
-		if ((unsigned)backlog > sysctl_somaxconn)
-			backlog = sysctl_somaxconn;
+		struct net *net = sock->sk->sk_net;
+		if ((unsigned)backlog > net->sysctl_somaxconn)
+			backlog = net->sysctl_somaxconn;
 
 		err = security_socket_listen(sock, backlog);
 		if (!err)
@@ -2189,6 +2193,16 @@
 	printk(KERN_INFO "NET: Unregistered protocol family %d\n", family);
 }
 
+static int sock_pernet_init(struct net *net)
+{
+	net->sysctl_somaxconn = SOMAXCONN;
+	return 0;
+}
+
+static struct pernet_operations sock_net_ops = {
+	.init = sock_pernet_init,
+};
+
 static int __init sock_init(void)
 {
 	/*
@@ -2217,6 +2231,8 @@
 	netfilter_init();
 #endif
 
+	register_pernet_subsys(&sock_net_ops);
+
 	return 0;
 }
 
diff -Nurb linux-2.6.22-590/net/socket.c.orig linux-2.6.22-try2-netns/net/socket.c.orig
--- linux-2.6.22-590/net/socket.c.orig	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/net/socket.c.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,2344 +0,0 @@
-/*
- * NET		An implementation of the SOCKET network access protocol.
- *
- * Version:	@(#)socket.c	1.1.93	18/02/95
- *
- * Authors:	Orest Zborowski, <obz@Kodak.COM>
- *		Ross Biro
- *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
- *
- * Fixes:
- *		Anonymous	:	NOTSOCK/BADF cleanup. Error fix in
- *					shutdown()
- *		Alan Cox	:	verify_area() fixes
- *		Alan Cox	:	Removed DDI
- *		Jonathan Kamens	:	SOCK_DGRAM reconnect bug
- *		Alan Cox	:	Moved a load of checks to the very
- *					top level.
- *		Alan Cox	:	Move address structures to/from user
- *					mode above the protocol layers.
- *		Rob Janssen	:	Allow 0 length sends.
- *		Alan Cox	:	Asynchronous I/O support (cribbed from the
- *					tty drivers).
- *		Niibe Yutaka	:	Asynchronous I/O for writes (4.4BSD style)
- *		Jeff Uphoff	:	Made max number of sockets command-line
- *					configurable.
- *		Matti Aarnio	:	Made the number of sockets dynamic,
- *					to be allocated when needed, and mr.
- *					Uphoff's max is used as max to be
- *					allowed to allocate.
- *		Linus		:	Argh. removed all the socket allocation
- *					altogether: it's in the inode now.
- *		Alan Cox	:	Made sock_alloc()/sock_release() public
- *					for NetROM and future kernel nfsd type
- *					stuff.
- *		Alan Cox	:	sendmsg/recvmsg basics.
- *		Tom Dyas	:	Export net symbols.
- *		Marcin Dalecki	:	Fixed problems with CONFIG_NET="n".
- *		Alan Cox	:	Added thread locking to sys_* calls
- *					for sockets. May have errors at the
- *					moment.
- *		Kevin Buhr	:	Fixed the dumb errors in the above.
- *		Andi Kleen	:	Some small cleanups, optimizations,
- *					and fixed a copy_from_user() bug.
- *		Tigran Aivazian	:	sys_send(args) calls sys_sendto(args, NULL, 0)
- *		Tigran Aivazian	:	Made listen(2) backlog sanity checks
- *					protocol-independent
- *
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- *
- *
- *	This module is effectively the top level interface to the BSD socket
- *	paradigm.
- *
- *	Based upon Swansea University Computer Society NET3.039
- */
-
-#include <linux/mm.h>
-#include <linux/socket.h>
-#include <linux/file.h>
-#include <linux/net.h>
-#include <linux/interrupt.h>
-#include <linux/rcupdate.h>
-#include <linux/netdevice.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#include <linux/mutex.h>
-#include <linux/wanrouter.h>
-#include <linux/if_bridge.h>
-#include <linux/if_frad.h>
-#include <linux/if_vlan.h>
-#include <linux/init.h>
-#include <linux/poll.h>
-#include <linux/cache.h>
-#include <linux/module.h>
-#include <linux/highmem.h>
-#include <linux/mount.h>
-#include <linux/security.h>
-#include <linux/syscalls.h>
-#include <linux/compat.h>
-#include <linux/kmod.h>
-#include <linux/audit.h>
-#include <linux/wireless.h>
-
-#include <asm/uaccess.h>
-#include <asm/unistd.h>
-
-#include <net/compat.h>
-
-#include <net/sock.h>
-#include <linux/netfilter.h>
-
-static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
-static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
-			 unsigned long nr_segs, loff_t pos);
-static ssize_t sock_aio_write(struct kiocb *iocb, const struct iovec *iov,
-			  unsigned long nr_segs, loff_t pos);
-static int sock_mmap(struct file *file, struct vm_area_struct *vma);
-
-static int sock_close(struct inode *inode, struct file *file);
-static unsigned int sock_poll(struct file *file,
-			      struct poll_table_struct *wait);
-static long sock_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
-#ifdef CONFIG_COMPAT
-static long compat_sock_ioctl(struct file *file,
-			      unsigned int cmd, unsigned long arg);
-#endif
-static int sock_fasync(int fd, struct file *filp, int on);
-static ssize_t sock_sendpage(struct file *file, struct page *page,
-			     int offset, size_t size, loff_t *ppos, int more);
-
-/*
- *	Socket files have a set of 'special' operations as well as the generic file ones. These don't appear
- *	in the operation structures but are done directly via the socketcall() multiplexor.
- */
-
-static const struct file_operations socket_file_ops = {
-	.owner =	THIS_MODULE,
-	.llseek =	no_llseek,
-	.aio_read =	sock_aio_read,
-	.aio_write =	sock_aio_write,
-	.poll =		sock_poll,
-	.unlocked_ioctl = sock_ioctl,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl = compat_sock_ioctl,
-#endif
-	.mmap =		sock_mmap,
-	.open =		sock_no_open,	/* special open code to disallow open via /proc */
-	.release =	sock_close,
-	.fasync =	sock_fasync,
-	.sendpage =	sock_sendpage,
-	.splice_write = generic_splice_sendpage,
-};
-
-/*
- *	The protocol list. Each protocol is registered in here.
- */
-
-static DEFINE_SPINLOCK(net_family_lock);
-static const struct net_proto_family *net_families[NPROTO] __read_mostly;
-
-/*
- *	Statistics counters of the socket lists
- */
-
-static DEFINE_PER_CPU(int, sockets_in_use) = 0;
-
-/*
- * Support routines.
- * Move socket addresses back and forth across the kernel/user
- * divide and look after the messy bits.
- */
-
-#define MAX_SOCK_ADDR	128		/* 108 for Unix domain -
-					   16 for IP, 16 for IPX,
-					   24 for IPv6,
-					   about 80 for AX.25
-					   must be at least one bigger than
-					   the AF_UNIX size (see net/unix/af_unix.c
-					   :unix_mkname()).
-					 */
-
-/**
- *	move_addr_to_kernel	-	copy a socket address into kernel space
- *	@uaddr: Address in user space
- *	@kaddr: Address in kernel space
- *	@ulen: Length in user space
- *
- *	The address is copied into kernel space. If the provided address is
- *	too long an error code of -EINVAL is returned. If the copy gives
- *	invalid addresses -EFAULT is returned. On a success 0 is returned.
- */
-
-int move_addr_to_kernel(void __user *uaddr, int ulen, void *kaddr)
-{
-	if (ulen < 0 || ulen > MAX_SOCK_ADDR)
-		return -EINVAL;
-	if (ulen == 0)
-		return 0;
-	if (copy_from_user(kaddr, uaddr, ulen))
-		return -EFAULT;
-	return audit_sockaddr(ulen, kaddr);
-}
-
-/**
- *	move_addr_to_user	-	copy an address to user space
- *	@kaddr: kernel space address
- *	@klen: length of address in kernel
- *	@uaddr: user space address
- *	@ulen: pointer to user length field
- *
- *	The value pointed to by ulen on entry is the buffer length available.
- *	This is overwritten with the buffer space used. -EINVAL is returned
- *	if an overlong buffer is specified or a negative buffer size. -EFAULT
- *	is returned if either the buffer or the length field are not
- *	accessible.
- *	After copying the data up to the limit the user specifies, the true
- *	length of the data is written over the length limit the user
- *	specified. Zero is returned for a success.
- */
-
-int move_addr_to_user(void *kaddr, int klen, void __user *uaddr,
-		      int __user *ulen)
-{
-	int err;
-	int len;
-
-	err = get_user(len, ulen);
-	if (err)
-		return err;
-	if (len > klen)
-		len = klen;
-	if (len < 0 || len > MAX_SOCK_ADDR)
-		return -EINVAL;
-	if (len) {
-		if (audit_sockaddr(klen, kaddr))
-			return -ENOMEM;
-		if (copy_to_user(uaddr, kaddr, len))
-			return -EFAULT;
-	}
-	/*
-	 *      "fromlen shall refer to the value before truncation.."
-	 *                      1003.1g
-	 */
-	return __put_user(klen, ulen);
-}
-
-#define SOCKFS_MAGIC 0x534F434B
-
-static struct kmem_cache *sock_inode_cachep __read_mostly;
-
-static struct inode *sock_alloc_inode(struct super_block *sb)
-{
-	struct socket_alloc *ei;
-
-	ei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL);
-	if (!ei)
-		return NULL;
-	init_waitqueue_head(&ei->socket.wait);
-
-	ei->socket.fasync_list = NULL;
-	ei->socket.state = SS_UNCONNECTED;
-	ei->socket.flags = 0;
-	ei->socket.ops = NULL;
-	ei->socket.sk = NULL;
-	ei->socket.file = NULL;
-
-	return &ei->vfs_inode;
-}
-
-static void sock_destroy_inode(struct inode *inode)
-{
-	kmem_cache_free(sock_inode_cachep,
-			container_of(inode, struct socket_alloc, vfs_inode));
-}
-
-static void init_once(void *foo, struct kmem_cache *cachep, unsigned long flags)
-{
-	struct socket_alloc *ei = (struct socket_alloc *)foo;
-
-	inode_init_once(&ei->vfs_inode);
-}
-
-static int init_inodecache(void)
-{
-	sock_inode_cachep = kmem_cache_create("sock_inode_cache",
-					      sizeof(struct socket_alloc),
-					      0,
-					      (SLAB_HWCACHE_ALIGN |
-					       SLAB_RECLAIM_ACCOUNT |
-					       SLAB_MEM_SPREAD),
-					      init_once,
-					      NULL);
-	if (sock_inode_cachep == NULL)
-		return -ENOMEM;
-	return 0;
-}
-
-static struct super_operations sockfs_ops = {
-	.alloc_inode =	sock_alloc_inode,
-	.destroy_inode =sock_destroy_inode,
-	.statfs =	simple_statfs,
-};
-
-static int sockfs_get_sb(struct file_system_type *fs_type,
-			 int flags, const char *dev_name, void *data,
-			 struct vfsmount *mnt)
-{
-	return get_sb_pseudo(fs_type, "socket:", &sockfs_ops, SOCKFS_MAGIC,
-			     mnt);
-}
-
-static struct vfsmount *sock_mnt __read_mostly;
-
-static struct file_system_type sock_fs_type = {
-	.name =		"sockfs",
-	.get_sb =	sockfs_get_sb,
-	.kill_sb =	kill_anon_super,
-};
-
-static int sockfs_delete_dentry(struct dentry *dentry)
-{
-	/*
-	 * At creation time, we pretended this dentry was hashed
-	 * (by clearing DCACHE_UNHASHED bit in d_flags)
-	 * At delete time, we restore the truth : not hashed.
-	 * (so that dput() can proceed correctly)
-	 */
-	dentry->d_flags |= DCACHE_UNHASHED;
-	return 0;
-}
-
-/*
- * sockfs_dname() is called from d_path().
- */
-static char *sockfs_dname(struct dentry *dentry, char *buffer, int buflen)
-{
-	return dynamic_dname(dentry, buffer, buflen, "socket:[%lu]",
-				dentry->d_inode->i_ino);
-}
-
-static struct dentry_operations sockfs_dentry_operations = {
-	.d_delete = sockfs_delete_dentry,
-	.d_dname  = sockfs_dname,
-};
-
-/*
- *	Obtains the first available file descriptor and sets it up for use.
- *
- *	These functions create file structures and maps them to fd space
- *	of the current process. On success it returns file descriptor
- *	and file struct implicitly stored in sock->file.
- *	Note that another thread may close file descriptor before we return
- *	from this function. We use the fact that now we do not refer
- *	to socket after mapping. If one day we will need it, this
- *	function will increment ref. count on file by 1.
- *
- *	In any case returned fd MAY BE not valid!
- *	This race condition is unavoidable
- *	with shared fd spaces, we cannot solve it inside kernel,
- *	but we take care of internal coherence yet.
- */
-
-static int sock_alloc_fd(struct file **filep)
-{
-	int fd;
-
-	fd = get_unused_fd();
-	if (likely(fd >= 0)) {
-		struct file *file = get_empty_filp();
-
-		*filep = file;
-		if (unlikely(!file)) {
-			put_unused_fd(fd);
-			return -ENFILE;
-		}
-	} else
-		*filep = NULL;
-	return fd;
-}
-
-static int sock_attach_fd(struct socket *sock, struct file *file)
-{
-	struct qstr name = { .name = "" };
-
-	file->f_path.dentry = d_alloc(sock_mnt->mnt_sb->s_root, &name);
-	if (unlikely(!file->f_path.dentry))
-		return -ENOMEM;
-
-	file->f_path.dentry->d_op = &sockfs_dentry_operations;
-	/*
-	 * We dont want to push this dentry into global dentry hash table.
-	 * We pretend dentry is already hashed, by unsetting DCACHE_UNHASHED
-	 * This permits a working /proc/$pid/fd/XXX on sockets
-	 */
-	file->f_path.dentry->d_flags &= ~DCACHE_UNHASHED;
-	d_instantiate(file->f_path.dentry, SOCK_INODE(sock));
-	file->f_path.mnt = mntget(sock_mnt);
-	file->f_mapping = file->f_path.dentry->d_inode->i_mapping;
-
-	sock->file = file;
-	file->f_op = SOCK_INODE(sock)->i_fop = &socket_file_ops;
-	file->f_mode = FMODE_READ | FMODE_WRITE;
-	file->f_flags = O_RDWR;
-	file->f_pos = 0;
-	file->private_data = sock;
-
-	return 0;
-}
-
-int sock_map_fd(struct socket *sock)
-{
-	struct file *newfile;
-	int fd = sock_alloc_fd(&newfile);
-
-	if (likely(fd >= 0)) {
-		int err = sock_attach_fd(sock, newfile);
-
-		if (unlikely(err < 0)) {
-			put_filp(newfile);
-			put_unused_fd(fd);
-			return err;
-		}
-		fd_install(fd, newfile);
-	}
-	return fd;
-}
-
-static struct socket *sock_from_file(struct file *file, int *err)
-{
-	if (file->f_op == &socket_file_ops)
-		return file->private_data;	/* set in sock_map_fd */
-
-	*err = -ENOTSOCK;
-	return NULL;
-}
-
-/**
- *	sockfd_lookup	- 	Go from a file number to its socket slot
- *	@fd: file handle
- *	@err: pointer to an error code return
- *
- *	The file handle passed in is locked and the socket it is bound
- *	too is returned. If an error occurs the err pointer is overwritten
- *	with a negative errno code and NULL is returned. The function checks
- *	for both invalid handles and passing a handle which is not a socket.
- *
- *	On a success the socket object pointer is returned.
- */
-
-struct socket *sockfd_lookup(int fd, int *err)
-{
-	struct file *file;
-	struct socket *sock;
-
-	file = fget(fd);
-	if (!file) {
-		*err = -EBADF;
-		return NULL;
-	}
-
-	sock = sock_from_file(file, err);
-	if (!sock)
-		fput(file);
-	return sock;
-}
-
-static struct socket *sockfd_lookup_light(int fd, int *err, int *fput_needed)
-{
-	struct file *file;
-	struct socket *sock;
-
-	*err = -EBADF;
-	file = fget_light(fd, fput_needed);
-	if (file) {
-		sock = sock_from_file(file, err);
-		if (sock)
-			return sock;
-		fput_light(file, *fput_needed);
-	}
-	return NULL;
-}
-
-/**
- *	sock_alloc	-	allocate a socket
- *
- *	Allocate a new inode and socket object. The two are bound together
- *	and initialised. The socket is then returned. If we are out of inodes
- *	NULL is returned.
- */
-
-static struct socket *sock_alloc(void)
-{
-	struct inode *inode;
-	struct socket *sock;
-
-	inode = new_inode(sock_mnt->mnt_sb);
-	if (!inode)
-		return NULL;
-
-	sock = SOCKET_I(inode);
-
-	inode->i_mode = S_IFSOCK | S_IRWXUGO;
-	inode->i_uid = current->fsuid;
-	inode->i_gid = current->fsgid;
-
-	get_cpu_var(sockets_in_use)++;
-	put_cpu_var(sockets_in_use);
-	return sock;
-}
-
-/*
- *	In theory you can't get an open on this inode, but /proc provides
- *	a back door. Remember to keep it shut otherwise you'll let the
- *	creepy crawlies in.
- */
-
-static int sock_no_open(struct inode *irrelevant, struct file *dontcare)
-{
-	return -ENXIO;
-}
-
-const struct file_operations bad_sock_fops = {
-	.owner = THIS_MODULE,
-	.open = sock_no_open,
-};
-
-/**
- *	sock_release	-	close a socket
- *	@sock: socket to close
- *
- *	The socket is released from the protocol stack if it has a release
- *	callback, and the inode is then released if the socket is bound to
- *	an inode not a file.
- */
-
-void sock_release(struct socket *sock)
-{
-	if (sock->ops) {
-		struct module *owner = sock->ops->owner;
-
-		sock->ops->release(sock);
-		sock->ops = NULL;
-		module_put(owner);
-	}
-
-	if (sock->fasync_list)
-		printk(KERN_ERR "sock_release: fasync list not empty!\n");
-
-	get_cpu_var(sockets_in_use)--;
-	put_cpu_var(sockets_in_use);
-	if (!sock->file) {
-		iput(SOCK_INODE(sock));
-		return;
-	}
-	sock->file = NULL;
-}
-
-static inline int __sock_sendmsg(struct kiocb *iocb, struct socket *sock,
-				 struct msghdr *msg, size_t size)
-{
-	struct sock_iocb *si = kiocb_to_siocb(iocb);
-	int err;
-
-	si->sock = sock;
-	si->scm = NULL;
-	si->msg = msg;
-	si->size = size;
-
-	err = security_socket_sendmsg(sock, msg, size);
-	if (err)
-		return err;
-
-	return sock->ops->sendmsg(iocb, sock, msg, size);
-}
-
-int sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
-{
-	struct kiocb iocb;
-	struct sock_iocb siocb;
-	int ret;
-
-	init_sync_kiocb(&iocb, NULL);
-	iocb.private = &siocb;
-	ret = __sock_sendmsg(&iocb, sock, msg, size);
-	if (-EIOCBQUEUED == ret)
-		ret = wait_on_sync_kiocb(&iocb);
-	return ret;
-}
-
-int kernel_sendmsg(struct socket *sock, struct msghdr *msg,
-		   struct kvec *vec, size_t num, size_t size)
-{
-	mm_segment_t oldfs = get_fs();
-	int result;
-
-	set_fs(KERNEL_DS);
-	/*
-	 * the following is safe, since for compiler definitions of kvec and
-	 * iovec are identical, yielding the same in-core layout and alignment
-	 */
-	msg->msg_iov = (struct iovec *)vec;
-	msg->msg_iovlen = num;
-	result = sock_sendmsg(sock, msg, size);
-	set_fs(oldfs);
-	return result;
-}
-
-/*
- * called from sock_recv_timestamp() if sock_flag(sk, SOCK_RCVTSTAMP)
- */
-void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,
-	struct sk_buff *skb)
-{
-	ktime_t kt = skb->tstamp;
-
-	if (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {
-		struct timeval tv;
-		/* Race occurred between timestamp enabling and packet
-		   receiving.  Fill in the current time for now. */
-		if (kt.tv64 == 0)
-			kt = ktime_get_real();
-		skb->tstamp = kt;
-		tv = ktime_to_timeval(kt);
-		put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP, sizeof(tv), &tv);
-	} else {
-		struct timespec ts;
-		/* Race occurred between timestamp enabling and packet
-		   receiving.  Fill in the current time for now. */
-		if (kt.tv64 == 0)
-			kt = ktime_get_real();
-		skb->tstamp = kt;
-		ts = ktime_to_timespec(kt);
-		put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS, sizeof(ts), &ts);
-	}
-}
-
-EXPORT_SYMBOL_GPL(__sock_recv_timestamp);
-
-static inline int __sock_recvmsg(struct kiocb *iocb, struct socket *sock,
-				 struct msghdr *msg, size_t size, int flags)
-{
-	int err;
-	struct sock_iocb *si = kiocb_to_siocb(iocb);
-
-	si->sock = sock;
-	si->scm = NULL;
-	si->msg = msg;
-	si->size = size;
-	si->flags = flags;
-
-	err = security_socket_recvmsg(sock, msg, size, flags);
-	if (err)
-		return err;
-
-	return sock->ops->recvmsg(iocb, sock, msg, size, flags);
-}
-
-int sock_recvmsg(struct socket *sock, struct msghdr *msg,
-		 size_t size, int flags)
-{
-	struct kiocb iocb;
-	struct sock_iocb siocb;
-	int ret;
-
-	init_sync_kiocb(&iocb, NULL);
-	iocb.private = &siocb;
-	ret = __sock_recvmsg(&iocb, sock, msg, size, flags);
-	if (-EIOCBQUEUED == ret)
-		ret = wait_on_sync_kiocb(&iocb);
-	return ret;
-}
-
-int kernel_recvmsg(struct socket *sock, struct msghdr *msg,
-		   struct kvec *vec, size_t num, size_t size, int flags)
-{
-	mm_segment_t oldfs = get_fs();
-	int result;
-
-	set_fs(KERNEL_DS);
-	/*
-	 * the following is safe, since for compiler definitions of kvec and
-	 * iovec are identical, yielding the same in-core layout and alignment
-	 */
-	msg->msg_iov = (struct iovec *)vec, msg->msg_iovlen = num;
-	result = sock_recvmsg(sock, msg, size, flags);
-	set_fs(oldfs);
-	return result;
-}
-
-static void sock_aio_dtor(struct kiocb *iocb)
-{
-	kfree(iocb->private);
-}
-
-static ssize_t sock_sendpage(struct file *file, struct page *page,
-			     int offset, size_t size, loff_t *ppos, int more)
-{
-	struct socket *sock;
-	int flags;
-
-	sock = file->private_data;
-
-	flags = !(file->f_flags & O_NONBLOCK) ? 0 : MSG_DONTWAIT;
-	if (more)
-		flags |= MSG_MORE;
-
-	return sock->ops->sendpage(sock, page, offset, size, flags);
-}
-
-static struct sock_iocb *alloc_sock_iocb(struct kiocb *iocb,
-					 struct sock_iocb *siocb)
-{
-	if (!is_sync_kiocb(iocb)) {
-		siocb = kmalloc(sizeof(*siocb), GFP_KERNEL);
-		if (!siocb)
-			return NULL;
-		iocb->ki_dtor = sock_aio_dtor;
-	}
-
-	siocb->kiocb = iocb;
-	iocb->private = siocb;
-	return siocb;
-}
-
-static ssize_t do_sock_read(struct msghdr *msg, struct kiocb *iocb,
-		struct file *file, const struct iovec *iov,
-		unsigned long nr_segs)
-{
-	struct socket *sock = file->private_data;
-	size_t size = 0;
-	int i;
-
-	for (i = 0; i < nr_segs; i++)
-		size += iov[i].iov_len;
-
-	msg->msg_name = NULL;
-	msg->msg_namelen = 0;
-	msg->msg_control = NULL;
-	msg->msg_controllen = 0;
-	msg->msg_iov = (struct iovec *)iov;
-	msg->msg_iovlen = nr_segs;
-	msg->msg_flags = (file->f_flags & O_NONBLOCK) ? MSG_DONTWAIT : 0;
-
-	return __sock_recvmsg(iocb, sock, msg, size, msg->msg_flags);
-}
-
-static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
-				unsigned long nr_segs, loff_t pos)
-{
-	struct sock_iocb siocb, *x;
-
-	if (pos != 0)
-		return -ESPIPE;
-
-	if (iocb->ki_left == 0)	/* Match SYS5 behaviour */
-		return 0;
-
-
-	x = alloc_sock_iocb(iocb, &siocb);
-	if (!x)
-		return -ENOMEM;
-	return do_sock_read(&x->async_msg, iocb, iocb->ki_filp, iov, nr_segs);
-}
-
-static ssize_t do_sock_write(struct msghdr *msg, struct kiocb *iocb,
-			struct file *file, const struct iovec *iov,
-			unsigned long nr_segs)
-{
-	struct socket *sock = file->private_data;
-	size_t size = 0;
-	int i;
-
-	for (i = 0; i < nr_segs; i++)
-		size += iov[i].iov_len;
-
-	msg->msg_name = NULL;
-	msg->msg_namelen = 0;
-	msg->msg_control = NULL;
-	msg->msg_controllen = 0;
-	msg->msg_iov = (struct iovec *)iov;
-	msg->msg_iovlen = nr_segs;
-	msg->msg_flags = (file->f_flags & O_NONBLOCK) ? MSG_DONTWAIT : 0;
-	if (sock->type == SOCK_SEQPACKET)
-		msg->msg_flags |= MSG_EOR;
-
-	return __sock_sendmsg(iocb, sock, msg, size);
-}
-
-static ssize_t sock_aio_write(struct kiocb *iocb, const struct iovec *iov,
-			  unsigned long nr_segs, loff_t pos)
-{
-	struct sock_iocb siocb, *x;
-
-	if (pos != 0)
-		return -ESPIPE;
-
-	x = alloc_sock_iocb(iocb, &siocb);
-	if (!x)
-		return -ENOMEM;
-
-	return do_sock_write(&x->async_msg, iocb, iocb->ki_filp, iov, nr_segs);
-}
-
-/*
- * Atomic setting of ioctl hooks to avoid race
- * with module unload.
- */
-
-static DEFINE_MUTEX(br_ioctl_mutex);
-static int (*br_ioctl_hook) (unsigned int cmd, void __user *arg) = NULL;
-
-void brioctl_set(int (*hook) (unsigned int, void __user *))
-{
-	mutex_lock(&br_ioctl_mutex);
-	br_ioctl_hook = hook;
-	mutex_unlock(&br_ioctl_mutex);
-}
-
-EXPORT_SYMBOL(brioctl_set);
-
-static DEFINE_MUTEX(vlan_ioctl_mutex);
-static int (*vlan_ioctl_hook) (void __user *arg);
-
-void vlan_ioctl_set(int (*hook) (void __user *))
-{
-	mutex_lock(&vlan_ioctl_mutex);
-	vlan_ioctl_hook = hook;
-	mutex_unlock(&vlan_ioctl_mutex);
-}
-
-EXPORT_SYMBOL(vlan_ioctl_set);
-
-static DEFINE_MUTEX(dlci_ioctl_mutex);
-static int (*dlci_ioctl_hook) (unsigned int, void __user *);
-
-void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
-{
-	mutex_lock(&dlci_ioctl_mutex);
-	dlci_ioctl_hook = hook;
-	mutex_unlock(&dlci_ioctl_mutex);
-}
-
-EXPORT_SYMBOL(dlci_ioctl_set);
-
-/*
- *	With an ioctl, arg may well be a user mode pointer, but we don't know
- *	what to do with it - that's up to the protocol still.
- */
-
-static long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)
-{
-	struct socket *sock;
-	void __user *argp = (void __user *)arg;
-	int pid, err;
-
-	sock = file->private_data;
-	if (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15)) {
-		err = dev_ioctl(cmd, argp);
-	} else
-#ifdef CONFIG_WIRELESS_EXT
-	if (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST) {
-		err = dev_ioctl(cmd, argp);
-	} else
-#endif				/* CONFIG_WIRELESS_EXT */
-		switch (cmd) {
-		case FIOSETOWN:
-		case SIOCSPGRP:
-			err = -EFAULT;
-			if (get_user(pid, (int __user *)argp))
-				break;
-			err = f_setown(sock->file, pid, 1);
-			break;
-		case FIOGETOWN:
-		case SIOCGPGRP:
-			err = put_user(f_getown(sock->file),
-				       (int __user *)argp);
-			break;
-		case SIOCGIFBR:
-		case SIOCSIFBR:
-		case SIOCBRADDBR:
-		case SIOCBRDELBR:
-			err = -ENOPKG;
-			if (!br_ioctl_hook)
-				request_module("bridge");
-
-			mutex_lock(&br_ioctl_mutex);
-			if (br_ioctl_hook)
-				err = br_ioctl_hook(cmd, argp);
-			mutex_unlock(&br_ioctl_mutex);
-			break;
-		case SIOCGIFVLAN:
-		case SIOCSIFVLAN:
-			err = -ENOPKG;
-			if (!vlan_ioctl_hook)
-				request_module("8021q");
-
-			mutex_lock(&vlan_ioctl_mutex);
-			if (vlan_ioctl_hook)
-				err = vlan_ioctl_hook(argp);
-			mutex_unlock(&vlan_ioctl_mutex);
-			break;
-		case SIOCADDDLCI:
-		case SIOCDELDLCI:
-			err = -ENOPKG;
-			if (!dlci_ioctl_hook)
-				request_module("dlci");
-
-			if (dlci_ioctl_hook) {
-				mutex_lock(&dlci_ioctl_mutex);
-				err = dlci_ioctl_hook(cmd, argp);
-				mutex_unlock(&dlci_ioctl_mutex);
-			}
-			break;
-		default:
-			err = sock->ops->ioctl(sock, cmd, arg);
-
-			/*
-			 * If this ioctl is unknown try to hand it down
-			 * to the NIC driver.
-			 */
-			if (err == -ENOIOCTLCMD)
-				err = dev_ioctl(cmd, argp);
-			break;
-		}
-	return err;
-}
-
-int sock_create_lite(int family, int type, int protocol, struct socket **res)
-{
-	int err;
-	struct socket *sock = NULL;
-
-	err = security_socket_create(family, type, protocol, 1);
-	if (err)
-		goto out;
-
-	sock = sock_alloc();
-	if (!sock) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	sock->type = type;
-	err = security_socket_post_create(sock, family, type, protocol, 1);
-	if (err)
-		goto out_release;
-
-out:
-	*res = sock;
-	return err;
-out_release:
-	sock_release(sock);
-	sock = NULL;
-	goto out;
-}
-
-/* No kernel lock held - perfect */
-static unsigned int sock_poll(struct file *file, poll_table *wait)
-{
-	struct socket *sock;
-
-	/*
-	 *      We can't return errors to poll, so it's either yes or no.
-	 */
-	sock = file->private_data;
-	return sock->ops->poll(file, sock, wait);
-}
-
-static int sock_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct socket *sock = file->private_data;
-
-	return sock->ops->mmap(file, sock, vma);
-}
-
-static int sock_close(struct inode *inode, struct file *filp)
-{
-	/*
-	 *      It was possible the inode is NULL we were
-	 *      closing an unfinished socket.
-	 */
-
-	if (!inode) {
-		printk(KERN_DEBUG "sock_close: NULL inode\n");
-		return 0;
-	}
-	sock_fasync(-1, filp, 0);
-	sock_release(SOCKET_I(inode));
-	return 0;
-}
-
-/*
- *	Update the socket async list
- *
- *	Fasync_list locking strategy.
- *
- *	1. fasync_list is modified only under process context socket lock
- *	   i.e. under semaphore.
- *	2. fasync_list is used under read_lock(&sk->sk_callback_lock)
- *	   or under socket lock.
- *	3. fasync_list can be used from softirq context, so that
- *	   modification under socket lock have to be enhanced with
- *	   write_lock_bh(&sk->sk_callback_lock).
- *							--ANK (990710)
- */
-
-static int sock_fasync(int fd, struct file *filp, int on)
-{
-	struct fasync_struct *fa, *fna = NULL, **prev;
-	struct socket *sock;
-	struct sock *sk;
-
-	if (on) {
-		fna = kmalloc(sizeof(struct fasync_struct), GFP_KERNEL);
-		if (fna == NULL)
-			return -ENOMEM;
-	}
-
-	sock = filp->private_data;
-
-	sk = sock->sk;
-	if (sk == NULL) {
-		kfree(fna);
-		return -EINVAL;
-	}
-
-	lock_sock(sk);
-
-	prev = &(sock->fasync_list);
-
-	for (fa = *prev; fa != NULL; prev = &fa->fa_next, fa = *prev)
-		if (fa->fa_file == filp)
-			break;
-
-	if (on) {
-		if (fa != NULL) {
-			write_lock_bh(&sk->sk_callback_lock);
-			fa->fa_fd = fd;
-			write_unlock_bh(&sk->sk_callback_lock);
-
-			kfree(fna);
-			goto out;
-		}
-		fna->fa_file = filp;
-		fna->fa_fd = fd;
-		fna->magic = FASYNC_MAGIC;
-		fna->fa_next = sock->fasync_list;
-		write_lock_bh(&sk->sk_callback_lock);
-		sock->fasync_list = fna;
-		write_unlock_bh(&sk->sk_callback_lock);
-	} else {
-		if (fa != NULL) {
-			write_lock_bh(&sk->sk_callback_lock);
-			*prev = fa->fa_next;
-			write_unlock_bh(&sk->sk_callback_lock);
-			kfree(fa);
-		}
-	}
-
-out:
-	release_sock(sock->sk);
-	return 0;
-}
-
-/* This function may be called only under socket lock or callback_lock */
-
-int sock_wake_async(struct socket *sock, int how, int band)
-{
-	if (!sock || !sock->fasync_list)
-		return -1;
-	switch (how) {
-	case 1:
-
-		if (test_bit(SOCK_ASYNC_WAITDATA, &sock->flags))
-			break;
-		goto call_kill;
-	case 2:
-		if (!test_and_clear_bit(SOCK_ASYNC_NOSPACE, &sock->flags))
-			break;
-		/* fall through */
-	case 0:
-call_kill:
-		__kill_fasync(sock->fasync_list, SIGIO, band);
-		break;
-	case 3:
-		__kill_fasync(sock->fasync_list, SIGURG, band);
-	}
-	return 0;
-}
-
-static int __sock_create(int family, int type, int protocol,
-			 struct socket **res, int kern)
-{
-	int err;
-	struct socket *sock;
-	const struct net_proto_family *pf;
-
-	/*
-	 *      Check protocol is in range
-	 */
-	if (family < 0 || family >= NPROTO)
-		return -EAFNOSUPPORT;
-	if (type < 0 || type >= SOCK_MAX)
-		return -EINVAL;
-
-	/* Compatibility.
-
-	   This uglymoron is moved from INET layer to here to avoid
-	   deadlock in module load.
-	 */
-	if (family == PF_INET && type == SOCK_PACKET) {
-		static int warned;
-		if (!warned) {
-			warned = 1;
-			printk(KERN_INFO "%s uses obsolete (PF_INET,SOCK_PACKET)\n",
-			       current->comm);
-		}
-		family = PF_PACKET;
-	}
-
-	err = security_socket_create(family, type, protocol, kern);
-	if (err)
-		return err;
-
-	/*
-	 *	Allocate the socket and allow the family to set things up. if
-	 *	the protocol is 0, the family is instructed to select an appropriate
-	 *	default.
-	 */
-	sock = sock_alloc();
-	if (!sock) {
-		if (net_ratelimit())
-			printk(KERN_WARNING "socket: no more sockets\n");
-		return -ENFILE;	/* Not exactly a match, but its the
-				   closest posix thing */
-	}
-
-	sock->type = type;
-
-#if defined(CONFIG_KMOD)
-	/* Attempt to load a protocol module if the find failed.
-	 *
-	 * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user
-	 * requested real, full-featured networking support upon configuration.
-	 * Otherwise module support will break!
-	 */
-	if (net_families[family] == NULL)
-		request_module("net-pf-%d", family);
-#endif
-
-	rcu_read_lock();
-	pf = rcu_dereference(net_families[family]);
-	err = -EAFNOSUPPORT;
-	if (!pf)
-		goto out_release;
-
-	/*
-	 * We will call the ->create function, that possibly is in a loadable
-	 * module, so we have to bump that loadable module refcnt first.
-	 */
-	if (!try_module_get(pf->owner))
-		goto out_release;
-
-	/* Now protected by module ref count */
-	rcu_read_unlock();
-
-	err = pf->create(sock, protocol);
-	if (err < 0)
-		goto out_module_put;
-
-	/*
-	 * Now to bump the refcnt of the [loadable] module that owns this
-	 * socket at sock_release time we decrement its refcnt.
-	 */
-	if (!try_module_get(sock->ops->owner))
-		goto out_module_busy;
-
-	/*
-	 * Now that we're done with the ->create function, the [loadable]
-	 * module can have its refcnt decremented
-	 */
-	module_put(pf->owner);
-	err = security_socket_post_create(sock, family, type, protocol, kern);
-	if (err)
-		goto out_sock_release;
-	*res = sock;
-
-	return 0;
-
-out_module_busy:
-	err = -EAFNOSUPPORT;
-out_module_put:
-	sock->ops = NULL;
-	module_put(pf->owner);
-out_sock_release:
-	sock_release(sock);
-	return err;
-
-out_release:
-	rcu_read_unlock();
-	goto out_sock_release;
-}
-
-int sock_create(int family, int type, int protocol, struct socket **res)
-{
-	return __sock_create(family, type, protocol, res, 0);
-}
-
-int sock_create_kern(int family, int type, int protocol, struct socket **res)
-{
-	return __sock_create(family, type, protocol, res, 1);
-}
-
-asmlinkage long sys_socket(int family, int type, int protocol)
-{
-	int retval;
-	struct socket *sock;
-
-	retval = sock_create(family, type, protocol, &sock);
-	if (retval < 0)
-		goto out;
-
-	retval = sock_map_fd(sock);
-	if (retval < 0)
-		goto out_release;
-
-out:
-	/* It may be already another descriptor 8) Not kernel problem. */
-	return retval;
-
-out_release:
-	sock_release(sock);
-	return retval;
-}
-
-/*
- *	Create a pair of connected sockets.
- */
-
-asmlinkage long sys_socketpair(int family, int type, int protocol,
-			       int __user *usockvec)
-{
-	struct socket *sock1, *sock2;
-	int fd1, fd2, err;
-	struct file *newfile1, *newfile2;
-
-	/*
-	 * Obtain the first socket and check if the underlying protocol
-	 * supports the socketpair call.
-	 */
-
-	err = sock_create(family, type, protocol, &sock1);
-	if (err < 0)
-		goto out;
-
-	err = sock_create(family, type, protocol, &sock2);
-	if (err < 0)
-		goto out_release_1;
-
-	err = sock1->ops->socketpair(sock1, sock2);
-	if (err < 0)
-		goto out_release_both;
-
-	fd1 = sock_alloc_fd(&newfile1);
-	if (unlikely(fd1 < 0)) {
-		err = fd1;
-		goto out_release_both;
-	}
-
-	fd2 = sock_alloc_fd(&newfile2);
-	if (unlikely(fd2 < 0)) {
-		err = fd2;
-		put_filp(newfile1);
-		put_unused_fd(fd1);
-		goto out_release_both;
-	}
-
-	err = sock_attach_fd(sock1, newfile1);
-	if (unlikely(err < 0)) {
-		goto out_fd2;
-	}
-
-	err = sock_attach_fd(sock2, newfile2);
-	if (unlikely(err < 0)) {
-		fput(newfile1);
-		goto out_fd1;
-	}
-
-	err = audit_fd_pair(fd1, fd2);
-	if (err < 0) {
-		fput(newfile1);
-		fput(newfile2);
-		goto out_fd;
-	}
-
-	fd_install(fd1, newfile1);
-	fd_install(fd2, newfile2);
-	/* fd1 and fd2 may be already another descriptors.
-	 * Not kernel problem.
-	 */
-
-	err = put_user(fd1, &usockvec[0]);
-	if (!err)
-		err = put_user(fd2, &usockvec[1]);
-	if (!err)
-		return 0;
-
-	sys_close(fd2);
-	sys_close(fd1);
-	return err;
-
-out_release_both:
-	sock_release(sock2);
-out_release_1:
-	sock_release(sock1);
-out:
-	return err;
-
-out_fd2:
-	put_filp(newfile1);
-	sock_release(sock1);
-out_fd1:
-	put_filp(newfile2);
-	sock_release(sock2);
-out_fd:
-	put_unused_fd(fd1);
-	put_unused_fd(fd2);
-	goto out;
-}
-
-/*
- *	Bind a name to a socket. Nothing much to do here since it's
- *	the protocol's responsibility to handle the local address.
- *
- *	We move the socket address to kernel space before we call
- *	the protocol layer (having also checked the address is ok).
- */
-
-asmlinkage long sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen)
-{
-	struct socket *sock;
-	char address[MAX_SOCK_ADDR];
-	int err, fput_needed;
-
-	sock = sockfd_lookup_light(fd, &err, &fput_needed);
-	if (sock) {
-		err = move_addr_to_kernel(umyaddr, addrlen, address);
-		if (err >= 0) {
-			err = security_socket_bind(sock,
-						   (struct sockaddr *)address,
-						   addrlen);
-			if (!err)
-				err = sock->ops->bind(sock,
-						      (struct sockaddr *)
-						      address, addrlen);
-		}
-		fput_light(sock->file, fput_needed);
-	}
-	return err;
-}
-
-/*
- *	Perform a listen. Basically, we allow the protocol to do anything
- *	necessary for a listen, and if that works, we mark the socket as
- *	ready for listening.
- */
-
-int sysctl_somaxconn __read_mostly = SOMAXCONN;
-
-asmlinkage long sys_listen(int fd, int backlog)
-{
-	struct socket *sock;
-	int err, fput_needed;
-
-	sock = sockfd_lookup_light(fd, &err, &fput_needed);
-	if (sock) {
-		if ((unsigned)backlog > sysctl_somaxconn)
-			backlog = sysctl_somaxconn;
-
-		err = security_socket_listen(sock, backlog);
-		if (!err)
-			err = sock->ops->listen(sock, backlog);
-
-		fput_light(sock->file, fput_needed);
-	}
-	return err;
-}
-
-/*
- *	For accept, we attempt to create a new socket, set up the link
- *	with the client, wake up the client, then return the new
- *	connected fd. We collect the address of the connector in kernel
- *	space and move it to user at the very end. This is unclean because
- *	we open the socket then return an error.
- *
- *	1003.1g adds the ability to recvmsg() to query connection pending
- *	status to recvmsg. We need to add that support in a way thats
- *	clean when we restucture accept also.
- */
-
-asmlinkage long sys_accept(int fd, struct sockaddr __user *upeer_sockaddr,
-			   int __user *upeer_addrlen)
-{
-	struct socket *sock, *newsock;
-	struct file *newfile;
-	int err, len, newfd, fput_needed;
-	char address[MAX_SOCK_ADDR];
-
-	sock = sockfd_lookup_light(fd, &err, &fput_needed);
-	if (!sock)
-		goto out;
-
-	err = -ENFILE;
-	if (!(newsock = sock_alloc()))
-		goto out_put;
-
-	newsock->type = sock->type;
-	newsock->ops = sock->ops;
-
-	/*
-	 * We don't need try_module_get here, as the listening socket (sock)
-	 * has the protocol module (sock->ops->owner) held.
-	 */
-	__module_get(newsock->ops->owner);
-
-	newfd = sock_alloc_fd(&newfile);
-	if (unlikely(newfd < 0)) {
-		err = newfd;
-		sock_release(newsock);
-		goto out_put;
-	}
-
-	err = sock_attach_fd(newsock, newfile);
-	if (err < 0)
-		goto out_fd_simple;
-
-	err = security_socket_accept(sock, newsock);
-	if (err)
-		goto out_fd;
-
-	err = sock->ops->accept(sock, newsock, sock->file->f_flags);
-	if (err < 0)
-		goto out_fd;
-
-	if (upeer_sockaddr) {
-		if (newsock->ops->getname(newsock, (struct sockaddr *)address,
-					  &len, 2) < 0) {
-			err = -ECONNABORTED;
-			goto out_fd;
-		}
-		err = move_addr_to_user(address, len, upeer_sockaddr,
-					upeer_addrlen);
-		if (err < 0)
-			goto out_fd;
-	}
-
-	/* File flags are not inherited via accept() unlike another OSes. */
-
-	fd_install(newfd, newfile);
-	err = newfd;
-
-	security_socket_post_accept(sock, newsock);
-
-out_put:
-	fput_light(sock->file, fput_needed);
-out:
-	return err;
-out_fd_simple:
-	sock_release(newsock);
-	put_filp(newfile);
-	put_unused_fd(newfd);
-	goto out_put;
-out_fd:
-	fput(newfile);
-	put_unused_fd(newfd);
-	goto out_put;
-}
-
-/*
- *	Attempt to connect to a socket with the server address.  The address
- *	is in user space so we verify it is OK and move it to kernel space.
- *
- *	For 1003.1g we need to add clean support for a bind to AF_UNSPEC to
- *	break bindings
- *
- *	NOTE: 1003.1g draft 6.3 is broken with respect to AX.25/NetROM and
- *	other SEQPACKET protocols that take time to connect() as it doesn't
- *	include the -EINPROGRESS status for such sockets.
- */
-
-asmlinkage long sys_connect(int fd, struct sockaddr __user *uservaddr,
-			    int addrlen)
-{
-	struct socket *sock;
-	char address[MAX_SOCK_ADDR];
-	int err, fput_needed;
-
-	sock = sockfd_lookup_light(fd, &err, &fput_needed);
-	if (!sock)
-		goto out;
-	err = move_addr_to_kernel(uservaddr, addrlen, address);
-	if (err < 0)
-		goto out_put;
-
-	err =
-	    security_socket_connect(sock, (struct sockaddr *)address, addrlen);
-	if (err)
-		goto out_put;
-
-	err = sock->ops->connect(sock, (struct sockaddr *)address, addrlen,
-				 sock->file->f_flags);
-out_put:
-	fput_light(sock->file, fput_needed);
-out:
-	return err;
-}
-
-/*
- *	Get the local address ('name') of a socket object. Move the obtained
- *	name to user space.
- */
-
-asmlinkage long sys_getsockname(int fd, struct sockaddr __user *usockaddr,
-				int __user *usockaddr_len)
-{
-	struct socket *sock;
-	char address[MAX_SOCK_ADDR];
-	int len, err, fput_needed;
-
-	sock = sockfd_lookup_light(fd, &err, &fput_needed);
-	if (!sock)
-		goto out;
-
-	err = security_socket_getsockname(sock);
-	if (err)
-		goto out_put;
-
-	err = sock->ops->getname(sock, (struct sockaddr *)address, &len, 0);
-	if (err)
-		goto out_put;
-	err = move_addr_to_user(address, len, usockaddr, usockaddr_len);
-
-out_put:
-	fput_light(sock->file, fput_needed);
-out:
-	return err;
-}
-
-/*
- *	Get the remote address ('name') of a socket object. Move the obtained
- *	name to user space.
- */
-
-asmlinkage long sys_getpeername(int fd, struct sockaddr __user *usockaddr,
-				int __user *usockaddr_len)
-{
-	struct socket *sock;
-	char address[MAX_SOCK_ADDR];
-	int len, err, fput_needed;
-
-	sock = sockfd_lookup_light(fd, &err, &fput_needed);
-	if (sock != NULL) {
-		err = security_socket_getpeername(sock);
-		if (err) {
-			fput_light(sock->file, fput_needed);
-			return err;
-		}
-
-		err =
-		    sock->ops->getname(sock, (struct sockaddr *)address, &len,
-				       1);
-		if (!err)
-			err = move_addr_to_user(address, len, usockaddr,
-						usockaddr_len);
-		fput_light(sock->file, fput_needed);
-	}
-	return err;
-}
-
-/*
- *	Send a datagram to a given address. We move the address into kernel
- *	space and check the user space data area is readable before invoking
- *	the protocol.
- */
-
-asmlinkage long sys_sendto(int fd, void __user *buff, size_t len,
-			   unsigned flags, struct sockaddr __user *addr,
-			   int addr_len)
-{
-	struct socket *sock;
-	char address[MAX_SOCK_ADDR];
-	int err;
-	struct msghdr msg;
-	struct iovec iov;
-	int fput_needed;
-	struct file *sock_file;
-
-	sock_file = fget_light(fd, &fput_needed);
-	err = -EBADF;
-	if (!sock_file)
-		goto out;
-
-	sock = sock_from_file(sock_file, &err);
-	if (!sock)
-		goto out_put;
-	iov.iov_base = buff;
-	iov.iov_len = len;
-	msg.msg_name = NULL;
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-	msg.msg_control = NULL;
-	msg.msg_controllen = 0;
-	msg.msg_namelen = 0;
-	if (addr) {
-		err = move_addr_to_kernel(addr, addr_len, address);
-		if (err < 0)
-			goto out_put;
-		msg.msg_name = address;
-		msg.msg_namelen = addr_len;
-	}
-	if (sock->file->f_flags & O_NONBLOCK)
-		flags |= MSG_DONTWAIT;
-	msg.msg_flags = flags;
-	err = sock_sendmsg(sock, &msg, len);
-
-out_put:
-	fput_light(sock_file, fput_needed);
-out:
-	return err;
-}
-
-/*
- *	Send a datagram down a socket.
- */
-
-asmlinkage long sys_send(int fd, void __user *buff, size_t len, unsigned flags)
-{
-	return sys_sendto(fd, buff, len, flags, NULL, 0);
-}
-
-/*
- *	Receive a frame from the socket and optionally record the address of the
- *	sender. We verify the buffers are writable and if needed move the
- *	sender address from kernel to user space.
- */
-
-asmlinkage long sys_recvfrom(int fd, void __user *ubuf, size_t size,
-			     unsigned flags, struct sockaddr __user *addr,
-			     int __user *addr_len)
-{
-	struct socket *sock;
-	struct iovec iov;
-	struct msghdr msg;
-	char address[MAX_SOCK_ADDR];
-	int err, err2;
-	struct file *sock_file;
-	int fput_needed;
-
-	sock_file = fget_light(fd, &fput_needed);
-	err = -EBADF;
-	if (!sock_file)
-		goto out;
-
-	sock = sock_from_file(sock_file, &err);
-	if (!sock)
-		goto out_put;
-
-	msg.msg_control = NULL;
-	msg.msg_controllen = 0;
-	msg.msg_iovlen = 1;
-	msg.msg_iov = &iov;
-	iov.iov_len = size;
-	iov.iov_base = ubuf;
-	msg.msg_name = address;
-	msg.msg_namelen = MAX_SOCK_ADDR;
-	if (sock->file->f_flags & O_NONBLOCK)
-		flags |= MSG_DONTWAIT;
-	err = sock_recvmsg(sock, &msg, size, flags);
-
-	if (err >= 0 && addr != NULL) {
-		err2 = move_addr_to_user(address, msg.msg_namelen, addr, addr_len);
-		if (err2 < 0)
-			err = err2;
-	}
-out_put:
-	fput_light(sock_file, fput_needed);
-out:
-	return err;
-}
-
-/*
- *	Receive a datagram from a socket.
- */
-
-asmlinkage long sys_recv(int fd, void __user *ubuf, size_t size,
-			 unsigned flags)
-{
-	return sys_recvfrom(fd, ubuf, size, flags, NULL, NULL);
-}
-
-/*
- *	Set a socket option. Because we don't know the option lengths we have
- *	to pass the user mode parameter for the protocols to sort out.
- */
-
-asmlinkage long sys_setsockopt(int fd, int level, int optname,
-			       char __user *optval, int optlen)
-{
-	int err, fput_needed;
-	struct socket *sock;
-
-	if (optlen < 0)
-		return -EINVAL;
-
-	sock = sockfd_lookup_light(fd, &err, &fput_needed);
-	if (sock != NULL) {
-		err = security_socket_setsockopt(sock, level, optname);
-		if (err)
-			goto out_put;
-
-		if (level == SOL_SOCKET)
-			err =
-			    sock_setsockopt(sock, level, optname, optval,
-					    optlen);
-		else
-			err =
-			    sock->ops->setsockopt(sock, level, optname, optval,
-						  optlen);
-out_put:
-		fput_light(sock->file, fput_needed);
-	}
-	return err;
-}
-
-/*
- *	Get a socket option. Because we don't know the option lengths we have
- *	to pass a user mode parameter for the protocols to sort out.
- */
-
-asmlinkage long sys_getsockopt(int fd, int level, int optname,
-			       char __user *optval, int __user *optlen)
-{
-	int err, fput_needed;
-	struct socket *sock;
-
-	sock = sockfd_lookup_light(fd, &err, &fput_needed);
-	if (sock != NULL) {
-		err = security_socket_getsockopt(sock, level, optname);
-		if (err)
-			goto out_put;
-
-		if (level == SOL_SOCKET)
-			err =
-			    sock_getsockopt(sock, level, optname, optval,
-					    optlen);
-		else
-			err =
-			    sock->ops->getsockopt(sock, level, optname, optval,
-						  optlen);
-out_put:
-		fput_light(sock->file, fput_needed);
-	}
-	return err;
-}
-
-/*
- *	Shutdown a socket.
- */
-
-asmlinkage long sys_shutdown(int fd, int how)
-{
-	int err, fput_needed;
-	struct socket *sock;
-
-	sock = sockfd_lookup_light(fd, &err, &fput_needed);
-	if (sock != NULL) {
-		err = security_socket_shutdown(sock, how);
-		if (!err)
-			err = sock->ops->shutdown(sock, how);
-		fput_light(sock->file, fput_needed);
-	}
-	return err;
-}
-
-/* A couple of helpful macros for getting the address of the 32/64 bit
- * fields which are the same type (int / unsigned) on our platforms.
- */
-#define COMPAT_MSG(msg, member)	((MSG_CMSG_COMPAT & flags) ? &msg##_compat->member : &msg->member)
-#define COMPAT_NAMELEN(msg)	COMPAT_MSG(msg, msg_namelen)
-#define COMPAT_FLAGS(msg)	COMPAT_MSG(msg, msg_flags)
-
-/*
- *	BSD sendmsg interface
- */
-
-asmlinkage long sys_sendmsg(int fd, struct msghdr __user *msg, unsigned flags)
-{
-	struct compat_msghdr __user *msg_compat =
-	    (struct compat_msghdr __user *)msg;
-	struct socket *sock;
-	char address[MAX_SOCK_ADDR];
-	struct iovec iovstack[UIO_FASTIOV], *iov = iovstack;
-	unsigned char ctl[sizeof(struct cmsghdr) + 20]
-	    __attribute__ ((aligned(sizeof(__kernel_size_t))));
-	/* 20 is size of ipv6_pktinfo */
-	unsigned char *ctl_buf = ctl;
-	struct msghdr msg_sys;
-	int err, ctl_len, iov_size, total_len;
-	int fput_needed;
-
-	err = -EFAULT;
-	if (MSG_CMSG_COMPAT & flags) {
-		if (get_compat_msghdr(&msg_sys, msg_compat))
-			return -EFAULT;
-	}
-	else if (copy_from_user(&msg_sys, msg, sizeof(struct msghdr)))
-		return -EFAULT;
-
-	sock = sockfd_lookup_light(fd, &err, &fput_needed);
-	if (!sock)
-		goto out;
-
-	/* do not move before msg_sys is valid */
-	err = -EMSGSIZE;
-	if (msg_sys.msg_iovlen > UIO_MAXIOV)
-		goto out_put;
-
-	/* Check whether to allocate the iovec area */
-	err = -ENOMEM;
-	iov_size = msg_sys.msg_iovlen * sizeof(struct iovec);
-	if (msg_sys.msg_iovlen > UIO_FASTIOV) {
-		iov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);
-		if (!iov)
-			goto out_put;
-	}
-
-	/* This will also move the address data into kernel space */
-	if (MSG_CMSG_COMPAT & flags) {
-		err = verify_compat_iovec(&msg_sys, iov, address, VERIFY_READ);
-	} else
-		err = verify_iovec(&msg_sys, iov, address, VERIFY_READ);
-	if (err < 0)
-		goto out_freeiov;
-	total_len = err;
-
-	err = -ENOBUFS;
-
-	if (msg_sys.msg_controllen > INT_MAX)
-		goto out_freeiov;
-	ctl_len = msg_sys.msg_controllen;
-	if ((MSG_CMSG_COMPAT & flags) && ctl_len) {
-		err =
-		    cmsghdr_from_user_compat_to_kern(&msg_sys, sock->sk, ctl,
-						     sizeof(ctl));
-		if (err)
-			goto out_freeiov;
-		ctl_buf = msg_sys.msg_control;
-		ctl_len = msg_sys.msg_controllen;
-	} else if (ctl_len) {
-		if (ctl_len > sizeof(ctl)) {
-			ctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);
-			if (ctl_buf == NULL)
-				goto out_freeiov;
-		}
-		err = -EFAULT;
-		/*
-		 * Careful! Before this, msg_sys.msg_control contains a user pointer.
-		 * Afterwards, it will be a kernel pointer. Thus the compiler-assisted
-		 * checking falls down on this.
-		 */
-		if (copy_from_user(ctl_buf, (void __user *)msg_sys.msg_control,
-				   ctl_len))
-			goto out_freectl;
-		msg_sys.msg_control = ctl_buf;
-	}
-	msg_sys.msg_flags = flags;
-
-	if (sock->file->f_flags & O_NONBLOCK)
-		msg_sys.msg_flags |= MSG_DONTWAIT;
-	err = sock_sendmsg(sock, &msg_sys, total_len);
-
-out_freectl:
-	if (ctl_buf != ctl)
-		sock_kfree_s(sock->sk, ctl_buf, ctl_len);
-out_freeiov:
-	if (iov != iovstack)
-		sock_kfree_s(sock->sk, iov, iov_size);
-out_put:
-	fput_light(sock->file, fput_needed);
-out:
-	return err;
-}
-
-/*
- *	BSD recvmsg interface
- */
-
-asmlinkage long sys_recvmsg(int fd, struct msghdr __user *msg,
-			    unsigned int flags)
-{
-	struct compat_msghdr __user *msg_compat =
-	    (struct compat_msghdr __user *)msg;
-	struct socket *sock;
-	struct iovec iovstack[UIO_FASTIOV];
-	struct iovec *iov = iovstack;
-	struct msghdr msg_sys;
-	unsigned long cmsg_ptr;
-	int err, iov_size, total_len, len;
-	int fput_needed;
-
-	/* kernel mode address */
-	char addr[MAX_SOCK_ADDR];
-
-	/* user mode address pointers */
-	struct sockaddr __user *uaddr;
-	int __user *uaddr_len;
-
-	if (MSG_CMSG_COMPAT & flags) {
-		if (get_compat_msghdr(&msg_sys, msg_compat))
-			return -EFAULT;
-	}
-	else if (copy_from_user(&msg_sys, msg, sizeof(struct msghdr)))
-		return -EFAULT;
-
-	sock = sockfd_lookup_light(fd, &err, &fput_needed);
-	if (!sock)
-		goto out;
-
-	err = -EMSGSIZE;
-	if (msg_sys.msg_iovlen > UIO_MAXIOV)
-		goto out_put;
-
-	/* Check whether to allocate the iovec area */
-	err = -ENOMEM;
-	iov_size = msg_sys.msg_iovlen * sizeof(struct iovec);
-	if (msg_sys.msg_iovlen > UIO_FASTIOV) {
-		iov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);
-		if (!iov)
-			goto out_put;
-	}
-
-	/*
-	 *      Save the user-mode address (verify_iovec will change the
-	 *      kernel msghdr to use the kernel address space)
-	 */
-
-	uaddr = (void __user *)msg_sys.msg_name;
-	uaddr_len = COMPAT_NAMELEN(msg);
-	if (MSG_CMSG_COMPAT & flags) {
-		err = verify_compat_iovec(&msg_sys, iov, addr, VERIFY_WRITE);
-	} else
-		err = verify_iovec(&msg_sys, iov, addr, VERIFY_WRITE);
-	if (err < 0)
-		goto out_freeiov;
-	total_len = err;
-
-	cmsg_ptr = (unsigned long)msg_sys.msg_control;
-	msg_sys.msg_flags = 0;
-	if (MSG_CMSG_COMPAT & flags)
-		msg_sys.msg_flags = MSG_CMSG_COMPAT;
-
-	if (sock->file->f_flags & O_NONBLOCK)
-		flags |= MSG_DONTWAIT;
-	err = sock_recvmsg(sock, &msg_sys, total_len, flags);
-	if (err < 0)
-		goto out_freeiov;
-	len = err;
-
-	if (uaddr != NULL) {
-		err = move_addr_to_user(addr, msg_sys.msg_namelen, uaddr,
-					uaddr_len);
-		if (err < 0)
-			goto out_freeiov;
-	}
-	err = __put_user((msg_sys.msg_flags & ~MSG_CMSG_COMPAT),
-			 COMPAT_FLAGS(msg));
-	if (err)
-		goto out_freeiov;
-	if (MSG_CMSG_COMPAT & flags)
-		err = __put_user((unsigned long)msg_sys.msg_control - cmsg_ptr,
-				 &msg_compat->msg_controllen);
-	else
-		err = __put_user((unsigned long)msg_sys.msg_control - cmsg_ptr,
-				 &msg->msg_controllen);
-	if (err)
-		goto out_freeiov;
-	err = len;
-
-out_freeiov:
-	if (iov != iovstack)
-		sock_kfree_s(sock->sk, iov, iov_size);
-out_put:
-	fput_light(sock->file, fput_needed);
-out:
-	return err;
-}
-
-#ifdef __ARCH_WANT_SYS_SOCKETCALL
-
-/* Argument list sizes for sys_socketcall */
-#define AL(x) ((x) * sizeof(unsigned long))
-static const unsigned char nargs[18]={
-	AL(0),AL(3),AL(3),AL(3),AL(2),AL(3),
-	AL(3),AL(3),AL(4),AL(4),AL(4),AL(6),
-	AL(6),AL(2),AL(5),AL(5),AL(3),AL(3)
-};
-
-#undef AL
-
-/*
- *	System call vectors.
- *
- *	Argument checking cleaned up. Saved 20% in size.
- *  This function doesn't need to set the kernel lock because
- *  it is set by the callees.
- */
-
-asmlinkage long sys_socketcall(int call, unsigned long __user *args)
-{
-	unsigned long a[6];
-	unsigned long a0, a1;
-	int err;
-
-	if (call < 1 || call > SYS_RECVMSG)
-		return -EINVAL;
-
-	/* copy_from_user should be SMP safe. */
-	if (copy_from_user(a, args, nargs[call]))
-		return -EFAULT;
-
-	err = audit_socketcall(nargs[call] / sizeof(unsigned long), a);
-	if (err)
-		return err;
-
-	a0 = a[0];
-	a1 = a[1];
-
-	switch (call) {
-	case SYS_SOCKET:
-		err = sys_socket(a0, a1, a[2]);
-		break;
-	case SYS_BIND:
-		err = sys_bind(a0, (struct sockaddr __user *)a1, a[2]);
-		break;
-	case SYS_CONNECT:
-		err = sys_connect(a0, (struct sockaddr __user *)a1, a[2]);
-		break;
-	case SYS_LISTEN:
-		err = sys_listen(a0, a1);
-		break;
-	case SYS_ACCEPT:
-		err =
-		    sys_accept(a0, (struct sockaddr __user *)a1,
-			       (int __user *)a[2]);
-		break;
-	case SYS_GETSOCKNAME:
-		err =
-		    sys_getsockname(a0, (struct sockaddr __user *)a1,
-				    (int __user *)a[2]);
-		break;
-	case SYS_GETPEERNAME:
-		err =
-		    sys_getpeername(a0, (struct sockaddr __user *)a1,
-				    (int __user *)a[2]);
-		break;
-	case SYS_SOCKETPAIR:
-		err = sys_socketpair(a0, a1, a[2], (int __user *)a[3]);
-		break;
-	case SYS_SEND:
-		err = sys_send(a0, (void __user *)a1, a[2], a[3]);
-		break;
-	case SYS_SENDTO:
-		err = sys_sendto(a0, (void __user *)a1, a[2], a[3],
-				 (struct sockaddr __user *)a[4], a[5]);
-		break;
-	case SYS_RECV:
-		err = sys_recv(a0, (void __user *)a1, a[2], a[3]);
-		break;
-	case SYS_RECVFROM:
-		err = sys_recvfrom(a0, (void __user *)a1, a[2], a[3],
-				   (struct sockaddr __user *)a[4],
-				   (int __user *)a[5]);
-		break;
-	case SYS_SHUTDOWN:
-		err = sys_shutdown(a0, a1);
-		break;
-	case SYS_SETSOCKOPT:
-		err = sys_setsockopt(a0, a1, a[2], (char __user *)a[3], a[4]);
-		break;
-	case SYS_GETSOCKOPT:
-		err =
-		    sys_getsockopt(a0, a1, a[2], (char __user *)a[3],
-				   (int __user *)a[4]);
-		break;
-	case SYS_SENDMSG:
-		err = sys_sendmsg(a0, (struct msghdr __user *)a1, a[2]);
-		break;
-	case SYS_RECVMSG:
-		err = sys_recvmsg(a0, (struct msghdr __user *)a1, a[2]);
-		break;
-	default:
-		err = -EINVAL;
-		break;
-	}
-	return err;
-}
-
-#endif				/* __ARCH_WANT_SYS_SOCKETCALL */
-
-/**
- *	sock_register - add a socket protocol handler
- *	@ops: description of protocol
- *
- *	This function is called by a protocol handler that wants to
- *	advertise its address family, and have it linked into the
- *	socket interface. The value ops->family coresponds to the
- *	socket system call protocol family.
- */
-int sock_register(const struct net_proto_family *ops)
-{
-	int err;
-
-	if (ops->family >= NPROTO) {
-		printk(KERN_CRIT "protocol %d >= NPROTO(%d)\n", ops->family,
-		       NPROTO);
-		return -ENOBUFS;
-	}
-
-	spin_lock(&net_family_lock);
-	if (net_families[ops->family])
-		err = -EEXIST;
-	else {
-		net_families[ops->family] = ops;
-		err = 0;
-	}
-	spin_unlock(&net_family_lock);
-
-	printk(KERN_INFO "NET: Registered protocol family %d\n", ops->family);
-	return err;
-}
-
-/**
- *	sock_unregister - remove a protocol handler
- *	@family: protocol family to remove
- *
- *	This function is called by a protocol handler that wants to
- *	remove its address family, and have it unlinked from the
- *	new socket creation.
- *
- *	If protocol handler is a module, then it can use module reference
- *	counts to protect against new references. If protocol handler is not
- *	a module then it needs to provide its own protection in
- *	the ops->create routine.
- */
-void sock_unregister(int family)
-{
-	BUG_ON(family < 0 || family >= NPROTO);
-
-	spin_lock(&net_family_lock);
-	net_families[family] = NULL;
-	spin_unlock(&net_family_lock);
-
-	synchronize_rcu();
-
-	printk(KERN_INFO "NET: Unregistered protocol family %d\n", family);
-}
-
-static int __init sock_init(void)
-{
-	/*
-	 *      Initialize sock SLAB cache.
-	 */
-
-	sk_init();
-
-	/*
-	 *      Initialize skbuff SLAB cache
-	 */
-	skb_init();
-
-	/*
-	 *      Initialize the protocols module.
-	 */
-
-	init_inodecache();
-	register_filesystem(&sock_fs_type);
-	sock_mnt = kern_mount(&sock_fs_type);
-
-	/* The real protocol initialization is performed in later initcalls.
-	 */
-
-#ifdef CONFIG_NETFILTER
-	netfilter_init();
-#endif
-
-	return 0;
-}
-
-core_initcall(sock_init);	/* early initcall */
-
-#ifdef CONFIG_PROC_FS
-void socket_seq_show(struct seq_file *seq)
-{
-	int cpu;
-	int counter = 0;
-
-	for_each_possible_cpu(cpu)
-	    counter += per_cpu(sockets_in_use, cpu);
-
-	/* It can be negative, by the way. 8) */
-	if (counter < 0)
-		counter = 0;
-
-	seq_printf(seq, "sockets: used %d\n", counter);
-}
-#endif				/* CONFIG_PROC_FS */
-
-#ifdef CONFIG_COMPAT
-static long compat_sock_ioctl(struct file *file, unsigned cmd,
-			      unsigned long arg)
-{
-	struct socket *sock = file->private_data;
-	int ret = -ENOIOCTLCMD;
-
-	if (sock->ops->compat_ioctl)
-		ret = sock->ops->compat_ioctl(sock, cmd, arg);
-
-	return ret;
-}
-#endif
-
-int kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen)
-{
-	return sock->ops->bind(sock, addr, addrlen);
-}
-
-int kernel_listen(struct socket *sock, int backlog)
-{
-	return sock->ops->listen(sock, backlog);
-}
-
-int kernel_accept(struct socket *sock, struct socket **newsock, int flags)
-{
-	struct sock *sk = sock->sk;
-	int err;
-
-	err = sock_create_lite(sk->sk_family, sk->sk_type, sk->sk_protocol,
-			       newsock);
-	if (err < 0)
-		goto done;
-
-	err = sock->ops->accept(sock, *newsock, flags);
-	if (err < 0) {
-		sock_release(*newsock);
-		goto done;
-	}
-
-	(*newsock)->ops = sock->ops;
-
-done:
-	return err;
-}
-
-int kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,
-		   int flags)
-{
-	return sock->ops->connect(sock, addr, addrlen, flags);
-}
-
-int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
-			 int *addrlen)
-{
-	return sock->ops->getname(sock, addr, addrlen, 0);
-}
-
-int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
-			 int *addrlen)
-{
-	return sock->ops->getname(sock, addr, addrlen, 1);
-}
-
-int kernel_getsockopt(struct socket *sock, int level, int optname,
-			char *optval, int *optlen)
-{
-	mm_segment_t oldfs = get_fs();
-	int err;
-
-	set_fs(KERNEL_DS);
-	if (level == SOL_SOCKET)
-		err = sock_getsockopt(sock, level, optname, optval, optlen);
-	else
-		err = sock->ops->getsockopt(sock, level, optname, optval,
-					    optlen);
-	set_fs(oldfs);
-	return err;
-}
-
-int kernel_setsockopt(struct socket *sock, int level, int optname,
-			char *optval, int optlen)
-{
-	mm_segment_t oldfs = get_fs();
-	int err;
-
-	set_fs(KERNEL_DS);
-	if (level == SOL_SOCKET)
-		err = sock_setsockopt(sock, level, optname, optval, optlen);
-	else
-		err = sock->ops->setsockopt(sock, level, optname, optval,
-					    optlen);
-	set_fs(oldfs);
-	return err;
-}
-
-int kernel_sendpage(struct socket *sock, struct page *page, int offset,
-		    size_t size, int flags)
-{
-	if (sock->ops->sendpage)
-		return sock->ops->sendpage(sock, page, offset, size, flags);
-
-	return sock_no_sendpage(sock, page, offset, size, flags);
-}
-
-int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg)
-{
-	mm_segment_t oldfs = get_fs();
-	int err;
-
-	set_fs(KERNEL_DS);
-	err = sock->ops->ioctl(sock, cmd, arg);
-	set_fs(oldfs);
-
-	return err;
-}
-
-/* ABI emulation layers need these two */
-EXPORT_SYMBOL(move_addr_to_kernel);
-EXPORT_SYMBOL(move_addr_to_user);
-EXPORT_SYMBOL(sock_create);
-EXPORT_SYMBOL(sock_create_kern);
-EXPORT_SYMBOL(sock_create_lite);
-EXPORT_SYMBOL(sock_map_fd);
-EXPORT_SYMBOL(sock_recvmsg);
-EXPORT_SYMBOL(sock_register);
-EXPORT_SYMBOL(sock_release);
-EXPORT_SYMBOL(sock_sendmsg);
-EXPORT_SYMBOL(sock_unregister);
-EXPORT_SYMBOL(sock_wake_async);
-EXPORT_SYMBOL(sockfd_lookup);
-EXPORT_SYMBOL(kernel_sendmsg);
-EXPORT_SYMBOL(kernel_recvmsg);
-EXPORT_SYMBOL(kernel_bind);
-EXPORT_SYMBOL(kernel_listen);
-EXPORT_SYMBOL(kernel_accept);
-EXPORT_SYMBOL(kernel_connect);
-EXPORT_SYMBOL(kernel_getsockname);
-EXPORT_SYMBOL(kernel_getpeername);
-EXPORT_SYMBOL(kernel_getsockopt);
-EXPORT_SYMBOL(kernel_setsockopt);
-EXPORT_SYMBOL(kernel_sendpage);
-EXPORT_SYMBOL(kernel_sock_ioctl);
diff -Nurb linux-2.6.22-590/net/sunrpc/stats.c linux-2.6.22-try2-netns/net/sunrpc/stats.c
--- linux-2.6.22-590/net/sunrpc/stats.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/sunrpc/stats.c	2007-12-19 22:49:20.000000000 -0500
@@ -21,6 +21,7 @@
 #include <linux/sunrpc/clnt.h>
 #include <linux/sunrpc/svcsock.h>
 #include <linux/sunrpc/metrics.h>
+#include <net/net_namespace.h>
 
 #define RPCDBG_FACILITY	RPCDBG_MISC
 
@@ -265,7 +266,7 @@
 	dprintk("RPC:       registering /proc/net/rpc\n");
 	if (!proc_net_rpc) {
 		struct proc_dir_entry *ent;
-		ent = proc_mkdir("rpc", proc_net);
+		ent = proc_mkdir("rpc", init_net.proc_net);
 		if (ent) {
 			ent->owner = THIS_MODULE;
 			proc_net_rpc = ent;
@@ -279,7 +280,7 @@
 	dprintk("RPC:       unregistering /proc/net/rpc\n");
 	if (proc_net_rpc) {
 		proc_net_rpc = NULL;
-		remove_proc_entry("net/rpc", NULL);
+		remove_proc_entry("rpc", init_net.proc_net);
 	}
 }
 
diff -Nurb linux-2.6.22-590/net/sysctl_net.c linux-2.6.22-try2-netns/net/sysctl_net.c
--- linux-2.6.22-590/net/sysctl_net.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/sysctl_net.c	2007-12-19 22:49:20.000000000 -0500
@@ -54,3 +54,31 @@
 #endif
 	{ 0 },
 };
+
+struct ctl_table multi_net_table[] = {
+	{
+		.ctl_name	= NET_CORE,
+		.procname	= "core",
+		.mode		= 0555,
+		.child		= multi_core_table,
+	},
+#ifdef CONFIG_INET
+	{
+		.ctl_name	= NET_IPV4,
+		.procname	= "ipv4",
+		.mode		= 0555,
+		.child		= multi_ipv4_table,
+	},
+#endif
+	{},
+};
+
+struct ctl_table net_root_table[] = {
+	{
+		.ctl_name	= CTL_NET,
+		.procname	= "net",
+		.mode		= 0555,
+		.child		= multi_net_table,
+	},
+	{},
+};
diff -Nurb linux-2.6.22-590/net/tipc/eth_media.c linux-2.6.22-try2-netns/net/tipc/eth_media.c
--- linux-2.6.22-590/net/tipc/eth_media.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/tipc/eth_media.c	2007-12-19 22:49:20.000000000 -0500
@@ -38,6 +38,7 @@
 #include <net/tipc/tipc_bearer.h>
 #include <net/tipc/tipc_msg.h>
 #include <linux/netdevice.h>
+#include <net/net_namespace.h>
 
 #define MAX_ETH_BEARERS		2
 #define ETH_LINK_PRIORITY	TIPC_DEF_LINK_PRI
@@ -100,6 +101,11 @@
 	struct eth_bearer *eb_ptr = (struct eth_bearer *)pt->af_packet_priv;
 	u32 size;
 
+	if (dev->nd_net != &init_net) {
+		kfree_skb(buf);
+		return 0;
+	}
+
 	if (likely(eb_ptr->bearer)) {
 		if (likely(buf->pkt_type <= PACKET_BROADCAST)) {
 			size = msg_size((struct tipc_msg *)buf->data);
@@ -129,7 +135,7 @@
 
 	/* Find device with specified name */
 
-	for_each_netdev(pdev){
+	for_each_netdev(&init_net, pdev){
 		if (!strncmp(pdev->name, driver_name, IFNAMSIZ)) {
 			dev = pdev;
 			break;
@@ -192,6 +198,9 @@
 	struct eth_bearer *eb_ptr = &eth_bearers[0];
 	struct eth_bearer *stop = &eth_bearers[MAX_ETH_BEARERS];
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	while ((eb_ptr->dev != dev)) {
 		if (++eb_ptr == stop)
 			return NOTIFY_DONE;	/* couldn't find device */
diff -Nurb linux-2.6.22-590/net/tipc/socket.c linux-2.6.22-try2-netns/net/tipc/socket.c
--- linux-2.6.22-590/net/tipc/socket.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/net/tipc/socket.c	2007-12-19 22:49:20.000000000 -0500
@@ -162,13 +162,16 @@
  *
  * Returns 0 on success, errno otherwise
  */
-static int tipc_create(struct socket *sock, int protocol)
+static int tipc_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct tipc_sock *tsock;
 	struct tipc_port *port;
 	struct sock *sk;
 	u32 ref;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	if (unlikely(protocol != 0))
 		return -EPROTONOSUPPORT;
 
@@ -198,7 +201,7 @@
 		return -EPROTOTYPE;
 	}
 
-	sk = sk_alloc(AF_TIPC, GFP_KERNEL, &tipc_proto, 1);
+	sk = sk_alloc(net, AF_TIPC, GFP_KERNEL, &tipc_proto, 1);
 	if (!sk) {
 		tipc_deleteport(ref);
 		return -ENOMEM;
@@ -1372,7 +1375,7 @@
 	}
 	buf = skb_peek(&sock->sk->sk_receive_queue);
 
-	res = tipc_create(newsock, 0);
+	res = tipc_create(sock->sk->sk_net, newsock, 0);
 	if (!res) {
 		struct tipc_sock *new_tsock = tipc_sk(newsock->sk);
 		struct tipc_portid id;
diff -Nurb linux-2.6.22-590/net/unix/af_unix.c linux-2.6.22-try2-netns/net/unix/af_unix.c
--- linux-2.6.22-590/net/unix/af_unix.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/unix/af_unix.c	2007-12-19 23:38:14.000000000 -0500
@@ -117,8 +117,8 @@
 #include <linux/security.h>
 #include <linux/vs_context.h>
 #include <linux/vs_limit.h>
+#include <net/net_namespace.h>
 
-int sysctl_unix_max_dgram_qlen __read_mostly = 10;
 
 struct hlist_head unix_socket_table[UNIX_HASH_SIZE + 1];
 DEFINE_SPINLOCK(unix_table_lock);
@@ -245,7 +245,8 @@
 	spin_unlock(&unix_table_lock);
 }
 
-static struct sock *__unix_find_socket_byname(struct sockaddr_un *sunname,
+static struct sock *__unix_find_socket_byname(struct net *net,
+					      struct sockaddr_un *sunname,
 					      int len, int type, unsigned hash)
 {
 	struct sock *s;
@@ -254,7 +255,7 @@
 	sk_for_each(s, node, &unix_socket_table[hash ^ type]) {
 		struct unix_sock *u = unix_sk(s);
 
-		if (!nx_check(s->sk_nid, VS_WATCH_P | VS_IDENT))
+		if (!nx_check(s->sk_nid, VS_WATCH_P | VS_IDENT) || (s->sk_net != net))
 			continue;
 		if (u->addr->len == len &&
 		    !memcmp(u->addr->name, sunname, len))
@@ -265,21 +266,22 @@
 	return s;
 }
 
-static inline struct sock *unix_find_socket_byname(struct sockaddr_un *sunname,
+static inline struct sock *unix_find_socket_byname(struct net *net,
+						   struct sockaddr_un *sunname,
 						   int len, int type,
 						   unsigned hash)
 {
 	struct sock *s;
 
 	spin_lock(&unix_table_lock);
-	s = __unix_find_socket_byname(sunname, len, type, hash);
+	s = __unix_find_socket_byname(net, sunname, len, type, hash);
 	if (s)
 		sock_hold(s);
 	spin_unlock(&unix_table_lock);
 	return s;
 }
 
-static struct sock *unix_find_socket_byinode(struct inode *i)
+static struct sock *unix_find_socket_byinode(struct net *net, struct inode *i)
 {
 	struct sock *s;
 	struct hlist_node *node;
@@ -289,6 +291,9 @@
 		    &unix_socket_table[i->i_ino & (UNIX_HASH_SIZE - 1)]) {
 		struct dentry *dentry = unix_sk(s)->dentry;
 
+		if (s->sk_net != net)
+			continue;
+
 		if(dentry && dentry->d_inode == i)
 		{
 			sock_hold(s);
@@ -571,7 +576,7 @@
  */
 static struct lock_class_key af_unix_sk_receive_queue_lock_key;
 
-static struct sock * unix_create1(struct socket *sock)
+static struct sock * unix_create1(struct net *net, struct socket *sock)
 {
 	struct sock *sk = NULL;
 	struct unix_sock *u;
@@ -579,7 +584,7 @@
 	if (atomic_read(&unix_nr_socks) >= 2*get_max_files())
 		goto out;
 
-	sk = sk_alloc(PF_UNIX, GFP_KERNEL, &unix_proto, 1);
+	sk = sk_alloc(net, PF_UNIX, GFP_KERNEL, &unix_proto, 1);
 	if (!sk)
 		goto out;
 
@@ -590,7 +595,7 @@
 				&af_unix_sk_receive_queue_lock_key);
 
 	sk->sk_write_space	= unix_write_space;
-	sk->sk_max_ack_backlog	= sysctl_unix_max_dgram_qlen;
+	sk->sk_max_ack_backlog	= net->sysctl_unix_max_dgram_qlen;
 	sk->sk_destruct		= unix_sock_destructor;
 	u	  = unix_sk(sk);
 	u->dentry = NULL;
@@ -604,7 +609,7 @@
 	return sk;
 }
 
-static int unix_create(struct socket *sock, int protocol)
+static int unix_create(struct net *net, struct socket *sock, int protocol)
 {
 	if (protocol && protocol != PF_UNIX)
 		return -EPROTONOSUPPORT;
@@ -631,7 +636,7 @@
 		return -ESOCKTNOSUPPORT;
 	}
 
-	return unix_create1(sock) ? 0 : -ENOMEM;
+	return unix_create1(net, sock) ? 0 : -ENOMEM;
 }
 
 static int unix_release(struct socket *sock)
@@ -649,6 +654,7 @@
 static int unix_autobind(struct socket *sock)
 {
 	struct sock *sk = sock->sk;
+	struct net *net = sk->sk_net;
 	struct unix_sock *u = unix_sk(sk);
 	static u32 ordernum = 1;
 	struct unix_address * addr;
@@ -675,7 +681,7 @@
 	spin_lock(&unix_table_lock);
 	ordernum = (ordernum+1)&0xFFFFF;
 
-	if (__unix_find_socket_byname(addr->name, addr->len, sock->type,
+	if (__unix_find_socket_byname(net, addr->name, addr->len, sock->type,
 				      addr->hash)) {
 		spin_unlock(&unix_table_lock);
 		/* Sanity yield. It is unusual case, but yet... */
@@ -695,7 +701,8 @@
 	return err;
 }
 
-static struct sock *unix_find_other(struct sockaddr_un *sunname, int len,
+static struct sock *unix_find_other(struct net *net,
+				    struct sockaddr_un *sunname, int len,
 				    int type, unsigned hash, int *error)
 {
 	struct sock *u;
@@ -713,7 +720,7 @@
 		err = -ECONNREFUSED;
 		if (!S_ISSOCK(nd.dentry->d_inode->i_mode))
 			goto put_fail;
-		u=unix_find_socket_byinode(nd.dentry->d_inode);
+		u=unix_find_socket_byinode(net, nd.dentry->d_inode);
 		if (!u)
 			goto put_fail;
 
@@ -729,7 +736,7 @@
 		}
 	} else {
 		err = -ECONNREFUSED;
-		u=unix_find_socket_byname(sunname, len, type, hash);
+		u=unix_find_socket_byname(net, sunname, len, type, hash);
 		if (u) {
 			struct dentry *dentry;
 			dentry = unix_sk(u)->dentry;
@@ -751,6 +758,7 @@
 static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 {
 	struct sock *sk = sock->sk;
+	struct net *net = sk->sk_net;
 	struct unix_sock *u = unix_sk(sk);
 	struct sockaddr_un *sunaddr=(struct sockaddr_un *)uaddr;
 	struct dentry * dentry = NULL;
@@ -825,7 +833,7 @@
 
 	if (!sunaddr->sun_path[0]) {
 		err = -EADDRINUSE;
-		if (__unix_find_socket_byname(sunaddr, addr_len,
+		if (__unix_find_socket_byname(net, sunaddr, addr_len,
 					      sk->sk_type, hash)) {
 			unix_release_addr(addr);
 			goto out_unlock;
@@ -891,6 +899,7 @@
 			      int alen, int flags)
 {
 	struct sock *sk = sock->sk;
+	struct net *net = sk->sk_net;
 	struct sockaddr_un *sunaddr=(struct sockaddr_un*)addr;
 	struct sock *other;
 	unsigned hash;
@@ -907,7 +916,7 @@
 			goto out;
 
 restart:
-		other=unix_find_other(sunaddr, alen, sock->type, hash, &err);
+		other=unix_find_other(net, sunaddr, alen, sock->type, hash, &err);
 		if (!other)
 			goto out;
 
@@ -987,6 +996,7 @@
 {
 	struct sockaddr_un *sunaddr=(struct sockaddr_un *)uaddr;
 	struct sock *sk = sock->sk;
+	struct net *net = sk->sk_net;
 	struct unix_sock *u = unix_sk(sk), *newu, *otheru;
 	struct sock *newsk = NULL;
 	struct sock *other = NULL;
@@ -1015,7 +1025,7 @@
 	err = -ENOMEM;
 
 	/* create new sock for complete connection */
-	newsk = unix_create1(NULL);
+	newsk = unix_create1(sk->sk_net, NULL);
 	if (newsk == NULL)
 		goto out;
 
@@ -1026,7 +1036,7 @@
 
 restart:
 	/*  Find listening sock. */
-	other = unix_find_other(sunaddr, addr_len, sk->sk_type, hash, &err);
+	other = unix_find_other(net, sunaddr, addr_len, sk->sk_type, hash, &err);
 	if (!other)
 		goto out;
 
@@ -1305,6 +1315,7 @@
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
 	struct sock *sk = sock->sk;
+	struct net *net = sk->sk_net;
 	struct unix_sock *u = unix_sk(sk);
 	struct sockaddr_un *sunaddr=msg->msg_name;
 	struct sock *other = NULL;
@@ -1368,7 +1379,7 @@
 		if (sunaddr == NULL)
 			goto out_free;
 
-		other = unix_find_other(sunaddr, namelen, sk->sk_type,
+		other = unix_find_other(net, sunaddr, namelen, sk->sk_type,
 					hash, &err);
 		if (other==NULL)
 			goto out_free;
@@ -1974,12 +1985,18 @@
 
 
 #ifdef CONFIG_PROC_FS
-static struct sock *unix_seq_idx(int *iter, loff_t pos)
+struct unix_iter_state {
+	struct net *net;
+	int i;
+};
+static struct sock *unix_seq_idx(struct unix_iter_state *iter, loff_t pos)
 {
 	loff_t off = 0;
 	struct sock *s;
 
-	for (s = first_unix_socket(iter); s; s = next_unix_socket(iter, s)) {
+	for (s = first_unix_socket(&iter->i); s; s = next_unix_socket(&iter->i, s)) {
+		if (s->sk_net != iter->net)
+			continue;
 		if (off == pos)
 			return s;
 		++off;
@@ -1990,17 +2007,24 @@
 
 static void *unix_seq_start(struct seq_file *seq, loff_t *pos)
 {
+	struct unix_iter_state *iter = seq->private;
 	spin_lock(&unix_table_lock);
-	return *pos ? unix_seq_idx(seq->private, *pos - 1) : ((void *) 1);
+	return *pos ? unix_seq_idx(iter, *pos - 1) : ((void *) 1);
 }
 
 static void *unix_seq_next(struct seq_file *seq, void *v, loff_t *pos)
 {
+	struct unix_iter_state *iter = seq->private;
+	struct sock *sk = v;
 	++*pos;
 
 	if (v == (void *)1)
-		return first_unix_socket(seq->private);
-	return next_unix_socket(seq->private, v);
+		sk = first_unix_socket(&iter->i);
+	else
+		sk = next_unix_socket(&iter->i, sk);
+	while (sk && (sk->sk_net != iter->net))
+		sk = next_unix_socket(&iter->i, sk);
+	return sk;
 }
 
 static void unix_seq_stop(struct seq_file *seq, void *v)
@@ -2064,7 +2088,7 @@
 {
 	struct seq_file *seq;
 	int rc = -ENOMEM;
-	int *iter = kmalloc(sizeof(int), GFP_KERNEL);
+	struct unix_iter_state *iter = kmalloc(sizeof(*iter), GFP_KERNEL);
 
 	if (!iter)
 		goto out;
@@ -2075,7 +2099,8 @@
 
 	seq	     = file->private_data;
 	seq->private = iter;
-	*iter = 0;
+	iter->net = get_net(PROC_NET(inode));
+	iter->i = 0;
 out:
 	return rc;
 out_kfree:
@@ -2083,12 +2108,20 @@
 	goto out;
 }
 
+static int unix_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct unix_iter_state *iter = seq->private;
+	put_net(iter->net);
+	return seq_release_private(inode, file);
+}
+
 static const struct file_operations unix_seq_fops = {
 	.owner		= THIS_MODULE,
 	.open		= unix_seq_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
-	.release	= seq_release_private,
+	.release	= unix_seq_release,
 };
 
 #endif
@@ -2099,6 +2132,33 @@
 	.owner	= THIS_MODULE,
 };
 
+
+static int unix_net_init(struct net *net)
+{
+	int error = -ENOMEM;
+
+	net->sysctl_unix_max_dgram_qlen = 10;
+#ifdef CONFIG_PROC_FS
+	if (!proc_net_fops_create(net, "unix", 0, &unix_seq_fops))
+		goto out;
+#endif
+	unix_sysctl_register(net);
+	error = 0;
+out:
+	return 0;
+}
+
+static void unix_net_exit(struct net *net)
+{
+	unix_sysctl_unregister(net);
+	proc_net_remove(net, "unix");
+}
+
+static struct pernet_operations unix_net_ops = {
+	.init = unix_net_init,
+	.exit = unix_net_exit,
+};
+
 static int __init af_unix_init(void)
 {
 	int rc = -1;
@@ -2114,10 +2174,7 @@
 	}
 
 	sock_register(&unix_family_ops);
-#ifdef CONFIG_PROC_FS
-	proc_net_fops_create("unix", 0, &unix_seq_fops);
-#endif
-	unix_sysctl_register();
+	register_pernet_subsys(&unix_net_ops);
 out:
 	return rc;
 }
@@ -2125,9 +2182,8 @@
 static void __exit af_unix_exit(void)
 {
 	sock_unregister(PF_UNIX);
-	unix_sysctl_unregister();
-	proc_net_remove("unix");
 	proto_unregister(&unix_proto);
+	unregister_pernet_subsys(&unix_net_ops);
 }
 
 module_init(af_unix_init);
diff -Nurb linux-2.6.22-590/net/unix/sysctl_net_unix.c linux-2.6.22-try2-netns/net/unix/sysctl_net_unix.c
--- linux-2.6.22-590/net/unix/sysctl_net_unix.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/unix/sysctl_net_unix.c	2007-12-19 22:49:20.000000000 -0500
@@ -14,47 +14,71 @@
 
 #include <net/af_unix.h>
 
-static ctl_table unix_table[] = {
+static struct unix_sysctl_table {
+	struct ctl_table_header *sysctl_header;
+	struct ctl_table	unix_table[2];
+	struct ctl_table	unix_net_table[2];
+	struct ctl_table	unix_root_table[2];
+} unix_sysctl = {
+	.unix_table = {
 	{
 		.ctl_name	= NET_UNIX_MAX_DGRAM_QLEN,
 		.procname	= "max_dgram_qlen",
-		.data		= &sysctl_unix_max_dgram_qlen,
+			.data		= &init_net.sysctl_unix_max_dgram_qlen,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec
 	},
-	{ .ctl_name = 0 }
-};
-
-static ctl_table unix_net_table[] = {
+		{}
+	},
+	.unix_net_table = {
 	{
 		.ctl_name	= NET_UNIX,
 		.procname	= "unix",
 		.mode		= 0555,
-		.child		= unix_table
+			.child		= unix_sysctl.unix_table
 	},
-	{ .ctl_name = 0 }
-};
-
-static ctl_table unix_root_table[] = {
+		{}
+	},
+	.unix_root_table = {
 	{
 		.ctl_name	= CTL_NET,
 		.procname	= "net",
 		.mode		= 0555,
-		.child		= unix_net_table
+			.child		= unix_sysctl.unix_net_table
 	},
-	{ .ctl_name = 0 }
+		{}
+	}
 };
 
-static struct ctl_table_header * unix_sysctl_header;
-
-void unix_sysctl_register(void)
+void unix_sysctl_register(struct net *net)
 {
-	unix_sysctl_header = register_sysctl_table(unix_root_table);
+	struct unix_sysctl_table *table;
+	int i;
+
+	table = kmemdup(&unix_sysctl, sizeof(*table), GFP_KERNEL);
+	if (!table)
+		return;
+	for (i = 0; i < ARRAY_SIZE(table->unix_table) - 1; i++)
+		table->unix_table[i].data += (char *)net - (char *)&init_net;
+
+	table->unix_net_table[0].child = table->unix_table;
+	table->unix_root_table[0].child = table->unix_net_table;
+
+	table->sysctl_header = 
+		register_net_sysctl_table(net, table->unix_root_table);
+	if (!table->sysctl_header) {
+		kfree(table);
+		return;
+	}
+	net->unix_sysctl = table;
 }
 
-void unix_sysctl_unregister(void)
+void unix_sysctl_unregister(struct net *net)
 {
-	unregister_sysctl_table(unix_sysctl_header);
+	struct unix_sysctl_table *table = net->unix_sysctl;
+	if (table)
+		unregister_net_sysctl_table(table->sysctl_header);
+	kfree(table);
 }
 
diff -Nurb linux-2.6.22-590/net/wanrouter/wanproc.c linux-2.6.22-try2-netns/net/wanrouter/wanproc.c
--- linux-2.6.22-590/net/wanrouter/wanproc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/wanrouter/wanproc.c	2007-12-19 22:49:20.000000000 -0500
@@ -28,6 +28,7 @@
 #include <linux/wanrouter.h>	/* WAN router API definitions */
 #include <linux/seq_file.h>
 #include <linux/smp_lock.h>
+#include <net/net_namespace.h>
 
 #include <asm/io.h>
 
@@ -287,7 +288,7 @@
 int __init wanrouter_proc_init(void)
 {
 	struct proc_dir_entry *p;
-	proc_router = proc_mkdir(ROUTER_NAME, proc_net);
+	proc_router = proc_mkdir(ROUTER_NAME, init_net.proc_net);
 	if (!proc_router)
 		goto fail;
 
@@ -303,7 +304,7 @@
 fail_stat:
 	remove_proc_entry("config", proc_router);
 fail_config:
-	remove_proc_entry(ROUTER_NAME, proc_net);
+	remove_proc_entry(ROUTER_NAME, init_net.proc_net);
 fail:
 	return -ENOMEM;
 }
@@ -316,7 +317,7 @@
 {
 	remove_proc_entry("config", proc_router);
 	remove_proc_entry("status", proc_router);
-	remove_proc_entry(ROUTER_NAME, proc_net);
+	remove_proc_entry(ROUTER_NAME, init_net.proc_net);
 }
 
 /*
diff -Nurb linux-2.6.22-590/net/wireless/wext.c linux-2.6.22-try2-netns/net/wireless/wext.c
--- linux-2.6.22-590/net/wireless/wext.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/wireless/wext.c	2007-12-19 22:49:20.000000000 -0500
@@ -95,6 +95,7 @@
 #include <linux/interrupt.h>
 
 #include <linux/wireless.h>		/* Pretty obvious */
+#include <net/net_namespace.h>
 #include <net/iw_handler.h>		/* New driver API */
 #include <net/netlink.h>
 #include <net/wext.h>
@@ -672,7 +673,22 @@
 
 static int wireless_seq_open(struct inode *inode, struct file *file)
 {
-	return seq_open(file, &wireless_seq_ops);
+	struct seq_file *seq;
+	int res;
+	res = seq_open(file, &wireless_seq_ops);
+	if (!res) {
+		seq = file->private_data;
+		seq->private = get_net(PROC_NET(inode));
+	}
+	return res;
+}
+
+static int wireless_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct net *net = seq->private;
+	put_net(net);
+	return seq_release(inode, file);
 }
 
 static const struct file_operations wireless_seq_fops = {
@@ -680,17 +696,22 @@
 	.open    = wireless_seq_open,
 	.read    = seq_read,
 	.llseek  = seq_lseek,
-	.release = seq_release,
+	.release = wireless_seq_release,
 };
 
-int __init wext_proc_init(void)
+int wext_proc_init(struct net *net)
 {
 	/* Create /proc/net/wireless entry */
-	if (!proc_net_fops_create("wireless", S_IRUGO, &wireless_seq_fops))
+	if (!proc_net_fops_create(net, "wireless", S_IRUGO, &wireless_seq_fops))
 		return -ENOMEM;
 
 	return 0;
 }
+
+void wext_proc_exit(struct net *net)
+{
+	proc_net_remove(net, "wireless");
+}
 #endif	/* CONFIG_PROC_FS */
 
 /************************** IOCTL SUPPORT **************************/
@@ -1010,7 +1031,7 @@
  * Main IOCTl dispatcher.
  * Check the type of IOCTL and call the appropriate wrapper...
  */
-static int wireless_process_ioctl(struct ifreq *ifr, unsigned int cmd)
+static int wireless_process_ioctl(struct net *net, struct ifreq *ifr, unsigned int cmd)
 {
 	struct net_device *dev;
 	iw_handler	handler;
@@ -1019,7 +1040,7 @@
 	 * The copy_to/from_user() of ifr is also dealt with in there */
 
 	/* Make sure the device exist */
-	if ((dev = __dev_get_by_name(ifr->ifr_name)) == NULL)
+	if ((dev = __dev_get_by_name(net, ifr->ifr_name)) == NULL)
 		return -ENODEV;
 
 	/* A bunch of special cases, then the generic case...
@@ -1053,7 +1074,7 @@
 }
 
 /* entry point from dev ioctl */
-int wext_handle_ioctl(struct ifreq *ifr, unsigned int cmd,
+int wext_handle_ioctl(struct net *net, struct ifreq *ifr, unsigned int cmd,
 		      void __user *arg)
 {
 	int ret;
@@ -1065,9 +1086,9 @@
 	    && !capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	dev_load(ifr->ifr_name);
+	dev_load(net, ifr->ifr_name);
 	rtnl_lock();
-	ret = wireless_process_ioctl(ifr, cmd);
+	ret = wireless_process_ioctl(net, ifr, cmd);
 	rtnl_unlock();
 	if (IW_IS_GET(cmd) && copy_to_user(arg, ifr, sizeof(struct ifreq)))
 		return -EFAULT;
@@ -1111,8 +1132,13 @@
 {
 	struct sk_buff *skb;
 
-	while ((skb = skb_dequeue(&wireless_nlevent_queue)))
-		rtnl_notify(skb, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);
+	while ((skb = skb_dequeue(&wireless_nlevent_queue))) {
+		struct net_device *dev = skb->dev;
+		struct net *net = dev->nd_net;
+		skb->dev = NULL;
+		rtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);
+		dev_put(dev);
+	}
 }
 
 static DECLARE_TASKLET(wireless_nlevent_tasklet, wireless_nlevent_process, 0);
@@ -1173,6 +1199,9 @@
 		kfree_skb(skb);
 		return;
 	}
+	/* Remember the device until we are in process context */
+	dev_hold(dev);
+	skb->dev = dev;
 	NETLINK_CB(skb).dst_group = RTNLGRP_LINK;
 	skb_queue_tail(&wireless_nlevent_queue, skb);
 	tasklet_schedule(&wireless_nlevent_tasklet);
diff -Nurb linux-2.6.22-590/net/x25/af_x25.c linux-2.6.22-try2-netns/net/x25/af_x25.c
--- linux-2.6.22-590/net/x25/af_x25.c	2007-12-21 15:33:43.000000000 -0500
+++ linux-2.6.22-try2-netns/net/x25/af_x25.c	2007-12-19 22:49:20.000000000 -0500
@@ -191,6 +191,9 @@
 	struct net_device *dev = ptr;
 	struct x25_neigh *nb;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (dev->type == ARPHRD_X25
 #if defined(CONFIG_LLC) || defined(CONFIG_LLC_MODULE)
 	 || dev->type == ARPHRD_ETHER
@@ -466,10 +469,10 @@
 	.obj_size = sizeof(struct x25_sock),
 };
 
-static struct sock *x25_alloc_socket(void)
+static struct sock *x25_alloc_socket(struct net *net)
 {
 	struct x25_sock *x25;
-	struct sock *sk = sk_alloc(AF_X25, GFP_ATOMIC, &x25_proto, 1);
+	struct sock *sk = sk_alloc(net, AF_X25, GFP_ATOMIC, &x25_proto, 1);
 
 	if (!sk)
 		goto out;
@@ -485,17 +488,20 @@
 	return sk;
 }
 
-static int x25_create(struct socket *sock, int protocol)
+static int x25_create(struct net *net, struct socket *sock, int protocol)
 {
 	struct sock *sk;
 	struct x25_sock *x25;
 	int rc = -ESOCKTNOSUPPORT;
 
+	if (net != &init_net)
+		return -EAFNOSUPPORT;
+
 	if (sock->type != SOCK_SEQPACKET || protocol)
 		goto out;
 
 	rc = -ENOMEM;
-	if ((sk = x25_alloc_socket()) == NULL)
+	if ((sk = x25_alloc_socket(net)) == NULL)
 		goto out;
 
 	x25 = x25_sk(sk);
@@ -546,7 +552,7 @@
 	if (osk->sk_type != SOCK_SEQPACKET)
 		goto out;
 
-	if ((sk = x25_alloc_socket()) == NULL)
+	if ((sk = x25_alloc_socket(osk->sk_net)) == NULL)
 		goto out;
 
 	x25 = x25_sk(sk);
diff -Nurb linux-2.6.22-590/net/x25/x25_dev.c linux-2.6.22-try2-netns/net/x25/x25_dev.c
--- linux-2.6.22-590/net/x25/x25_dev.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/x25/x25_dev.c	2007-12-19 22:49:20.000000000 -0500
@@ -95,6 +95,9 @@
 	struct sk_buff *nskb;
 	struct x25_neigh *nb;
 
+	if (dev->nd_net != &init_net)
+		goto drop;
+
 	nskb = skb_copy(skb, GFP_ATOMIC);
 	if (!nskb)
 		goto drop;
diff -Nurb linux-2.6.22-590/net/x25/x25_proc.c linux-2.6.22-try2-netns/net/x25/x25_proc.c
--- linux-2.6.22-590/net/x25/x25_proc.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/x25/x25_proc.c	2007-12-19 22:49:20.000000000 -0500
@@ -20,6 +20,7 @@
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include <net/net_namespace.h>
 #include <net/sock.h>
 #include <net/x25.h>
 
@@ -301,7 +302,7 @@
 	struct proc_dir_entry *p;
 	int rc = -ENOMEM;
 
-	x25_proc_dir = proc_mkdir("x25", proc_net);
+	x25_proc_dir = proc_mkdir("x25", init_net.proc_net);
 	if (!x25_proc_dir)
 		goto out;
 
@@ -328,7 +329,7 @@
 out_socket:
 	remove_proc_entry("route", x25_proc_dir);
 out_route:
-	remove_proc_entry("x25", proc_net);
+	remove_proc_entry("x25", init_net.proc_net);
 	goto out;
 }
 
@@ -337,7 +338,7 @@
 	remove_proc_entry("forward", x25_proc_dir);
 	remove_proc_entry("route", x25_proc_dir);
 	remove_proc_entry("socket", x25_proc_dir);
-	remove_proc_entry("x25", proc_net);
+	remove_proc_entry("x25", init_net.proc_net);
 }
 
 #else /* CONFIG_PROC_FS */
diff -Nurb linux-2.6.22-590/net/x25/x25_route.c linux-2.6.22-try2-netns/net/x25/x25_route.c
--- linux-2.6.22-590/net/x25/x25_route.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/x25/x25_route.c	2007-12-19 22:49:20.000000000 -0500
@@ -129,7 +129,7 @@
  */
 struct net_device *x25_dev_get(char *devname)
 {
-	struct net_device *dev = dev_get_by_name(devname);
+	struct net_device *dev = dev_get_by_name(&init_net, devname);
 
 	if (dev &&
 	    (!(dev->flags & IFF_UP) || (dev->type != ARPHRD_X25
diff -Nurb linux-2.6.22-590/net/xfrm/xfrm_policy.c linux-2.6.22-try2-netns/net/xfrm/xfrm_policy.c
--- linux-2.6.22-590/net/xfrm/xfrm_policy.c	2007-12-21 15:33:40.000000000 -0500
+++ linux-2.6.22-try2-netns/net/xfrm/xfrm_policy.c	2007-12-19 22:49:20.000000000 -0500
@@ -30,8 +30,6 @@
 
 #include "xfrm_hash.h"
 
-int sysctl_xfrm_larval_drop __read_mostly;
-
 DEFINE_MUTEX(xfrm_cfg_mutex);
 EXPORT_SYMBOL(xfrm_cfg_mutex);
 
@@ -1570,7 +1568,7 @@
 
 		if (unlikely(nx<0)) {
 			err = nx;
-			if (err == -EAGAIN && sysctl_xfrm_larval_drop) {
+			if (err == -EAGAIN && init_net.sysctl_xfrm_larval_drop) {
 				/* EREMOTE tells the caller to generate
 				 * a one-shot blackhole route.
 				 */
@@ -1954,8 +1952,8 @@
 void xfrm_dst_ifdown(struct dst_entry *dst, struct net_device *dev)
 {
 	while ((dst = dst->child) && dst->xfrm && dst->dev == dev) {
-		dst->dev = &loopback_dev;
-		dev_hold(&loopback_dev);
+		dst->dev = &init_net.loopback_dev;
+		dev_hold(dst->dev);
 		dev_put(dev);
 	}
 }
@@ -2357,6 +2355,11 @@
 
 static int xfrm_dev_event(struct notifier_block *this, unsigned long event, void *ptr)
 {
+	struct net_device *dev = ptr;
+
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	switch (event) {
 	case NETDEV_DOWN:
 		xfrm_flush_bundles();
diff -Nurb linux-2.6.22-590/net/xfrm/xfrm_state.c linux-2.6.22-try2-netns/net/xfrm/xfrm_state.c
--- linux-2.6.22-590/net/xfrm/xfrm_state.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/xfrm/xfrm_state.c	2007-12-19 22:49:20.000000000 -0500
@@ -28,14 +28,6 @@
 struct sock *xfrm_nl;
 EXPORT_SYMBOL(xfrm_nl);
 
-u32 sysctl_xfrm_aevent_etime __read_mostly = XFRM_AE_ETIME;
-EXPORT_SYMBOL(sysctl_xfrm_aevent_etime);
-
-u32 sysctl_xfrm_aevent_rseqth __read_mostly = XFRM_AE_SEQT_SIZE;
-EXPORT_SYMBOL(sysctl_xfrm_aevent_rseqth);
-
-u32 sysctl_xfrm_acq_expires __read_mostly = 30;
-
 /* Each xfrm_state may be linked to two tables:
 
    1. Hash table by (spi,daddr,ah/esp) to find SA by SPI. (input,ctl)
@@ -665,8 +657,8 @@
 				h = xfrm_spi_hash(&x->id.daddr, x->id.spi, x->id.proto, family);
 				hlist_add_head(&x->byspi, xfrm_state_byspi+h);
 			}
-			x->lft.hard_add_expires_seconds = sysctl_xfrm_acq_expires;
-			x->timer.expires = jiffies + sysctl_xfrm_acq_expires*HZ;
+			x->lft.hard_add_expires_seconds = init_net.sysctl_xfrm_acq_expires;
+			x->timer.expires = jiffies + init_net.sysctl_xfrm_acq_expires*HZ;
 			add_timer(&x->timer);
 			xfrm_state_num++;
 			xfrm_hash_grow_check(x->bydst.next != NULL);
@@ -815,9 +807,9 @@
 		x->props.family = family;
 		x->props.mode = mode;
 		x->props.reqid = reqid;
-		x->lft.hard_add_expires_seconds = sysctl_xfrm_acq_expires;
+		x->lft.hard_add_expires_seconds = init_net.sysctl_xfrm_acq_expires;
 		xfrm_state_hold(x);
-		x->timer.expires = jiffies + sysctl_xfrm_acq_expires*HZ;
+		x->timer.expires = jiffies + init_net.sysctl_xfrm_acq_expires*HZ;
 		add_timer(&x->timer);
 		hlist_add_head(&x->bydst, xfrm_state_bydst+h);
 		h = xfrm_src_hash(daddr, saddr, family);
@@ -1775,6 +1767,19 @@
 
 EXPORT_SYMBOL(xfrm_init_state);
 
+
+static int xfrm_state_pernet_init(struct net *net)
+{
+	net->sysctl_xfrm_aevent_etime = XFRM_AE_ETIME;
+	net->sysctl_xfrm_aevent_rseqth = XFRM_AE_SEQT_SIZE;
+	net->sysctl_xfrm_acq_expires = 30;
+	return 0;
+}
+
+static struct pernet_operations xfrm_state_net_ops = {
+	.init = xfrm_state_pernet_init,
+};
+
 void __init xfrm_state_init(void)
 {
 	unsigned int sz;
@@ -1789,5 +1794,7 @@
 	xfrm_state_hmask = ((sz / sizeof(struct hlist_head)) - 1);
 
 	INIT_WORK(&xfrm_state_gc_work, xfrm_state_gc_task);
+
+	register_pernet_subsys(&xfrm_state_net_ops);
 }
 
diff -Nurb linux-2.6.22-590/net/xfrm/xfrm_user.c linux-2.6.22-try2-netns/net/xfrm/xfrm_user.c
--- linux-2.6.22-590/net/xfrm/xfrm_user.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/net/xfrm/xfrm_user.c	2007-12-19 22:49:20.000000000 -0500
@@ -374,7 +374,8 @@
 	return err;
 }
 
-static struct xfrm_state *xfrm_state_construct(struct xfrm_usersa_info *p,
+static struct xfrm_state *xfrm_state_construct(struct net *net,
+					       struct xfrm_usersa_info *p,
 					       struct rtattr **xfrma,
 					       int *errp)
 {
@@ -410,9 +411,9 @@
 		goto error;
 
 	x->km.seq = p->seq;
-	x->replay_maxdiff = sysctl_xfrm_aevent_rseqth;
+	x->replay_maxdiff = net->sysctl_xfrm_aevent_rseqth;
 	/* sysctl_xfrm_aevent_etime is in 100ms units */
-	x->replay_maxage = (sysctl_xfrm_aevent_etime*HZ)/XFRM_AE_ETH_M;
+	x->replay_maxage = (net->sysctl_xfrm_aevent_etime*HZ)/XFRM_AE_ETH_M;
 	x->preplay.bitmap = 0;
 	x->preplay.seq = x->replay.seq+x->replay_maxdiff;
 	x->preplay.oseq = x->replay.oseq +x->replay_maxdiff;
@@ -436,6 +437,7 @@
 static int xfrm_add_sa(struct sk_buff *skb, struct nlmsghdr *nlh,
 		struct rtattr **xfrma)
 {
+	struct net *net = skb->sk->sk_net;
 	struct xfrm_usersa_info *p = NLMSG_DATA(nlh);
 	struct xfrm_state *x;
 	int err;
@@ -445,7 +447,7 @@
 	if (err)
 		return err;
 
-	x = xfrm_state_construct(p, xfrma, &err);
+	x = xfrm_state_construct(net, p, xfrma, &err);
 	if (!x)
 		return err;
 
@@ -2559,7 +2561,7 @@
 
 	printk(KERN_INFO "Initializing XFRM netlink socket\n");
 
-	nlsk = netlink_kernel_create(NETLINK_XFRM, XFRMNLGRP_MAX,
+	nlsk = netlink_kernel_create(&init_net, NETLINK_XFRM, XFRMNLGRP_MAX,
 				     xfrm_netlink_rcv, NULL, THIS_MODULE);
 	if (nlsk == NULL)
 		return -ENOMEM;
diff -Nurb linux-2.6.22-590/scripts/Makefile.build.orig linux-2.6.22-try2-netns/scripts/Makefile.build.orig
--- linux-2.6.22-590/scripts/Makefile.build.orig	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/scripts/Makefile.build.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,348 +0,0 @@
-# ==========================================================================
-# Building
-# ==========================================================================
-
-src := $(obj)
-
-PHONY := __build
-__build:
-
-# Read .config if it exist, otherwise ignore
--include include/config/auto.conf
-
-include scripts/Kbuild.include
-
-# The filename Kbuild has precedence over Makefile
-kbuild-dir := $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))
-include $(if $(wildcard $(kbuild-dir)/Kbuild), $(kbuild-dir)/Kbuild, $(kbuild-dir)/Makefile)
-
-include scripts/Makefile.lib
-
-ifdef host-progs
-ifneq ($(hostprogs-y),$(host-progs))
-$(warning kbuild: $(obj)/Makefile - Usage of host-progs is deprecated. Please replace with hostprogs-y!)
-hostprogs-y += $(host-progs)
-endif
-endif
-
-# Do not include host rules unles needed
-ifneq ($(hostprogs-y)$(hostprogs-m),)
-include scripts/Makefile.host
-endif
-
-ifneq ($(KBUILD_SRC),)
-# Create output directory if not already present
-_dummy := $(shell [ -d $(obj) ] || mkdir -p $(obj))
-
-# Create directories for object files if directory does not exist
-# Needed when obj-y := dir/file.o syntax is used
-_dummy := $(foreach d,$(obj-dirs), $(shell [ -d $(d) ] || mkdir -p $(d)))
-endif
-
-
-ifdef EXTRA_TARGETS
-$(warning kbuild: $(obj)/Makefile - Usage of EXTRA_TARGETS is obsolete in 2.6. Please fix!)
-endif
-
-ifdef build-targets
-$(warning kbuild: $(obj)/Makefile - Usage of build-targets is obsolete in 2.6. Please fix!)
-endif
-
-ifdef export-objs
-$(warning kbuild: $(obj)/Makefile - Usage of export-objs is obsolete in 2.6. Please fix!)
-endif
-
-ifdef O_TARGET
-$(warning kbuild: $(obj)/Makefile - Usage of O_TARGET := $(O_TARGET) is obsolete in 2.6. Please fix!)
-endif
-
-ifdef L_TARGET
-$(error kbuild: $(obj)/Makefile - Use of L_TARGET is replaced by lib-y in 2.6. Please fix!)
-endif
-
-ifdef list-multi
-$(warning kbuild: $(obj)/Makefile - list-multi := $(list-multi) is obsolete in 2.6. Please fix!)
-endif
-
-ifndef obj
-$(warning kbuild: Makefile.build is included improperly)
-endif
-
-# ===========================================================================
-
-ifneq ($(strip $(lib-y) $(lib-m) $(lib-n) $(lib-)),)
-lib-target := $(obj)/lib.a
-endif
-
-ifneq ($(strip $(obj-y) $(obj-m) $(obj-n) $(obj-) $(lib-target)),)
-builtin-target := $(obj)/built-in.o
-endif
-
-# We keep a list of all modules in $(MODVERDIR)
-
-__build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \
-	 $(if $(KBUILD_MODULES),$(obj-m)) \
-	 $(subdir-ym) $(always)
-	@:
-
-# Linus' kernel sanity checking tool
-ifneq ($(KBUILD_CHECKSRC),0)
-  ifeq ($(KBUILD_CHECKSRC),2)
-    quiet_cmd_force_checksrc = CHECK   $<
-          cmd_force_checksrc = $(CHECK) $(CHECKFLAGS) $(c_flags) $< ;
-  else
-      quiet_cmd_checksrc     = CHECK   $<
-            cmd_checksrc     = $(CHECK) $(CHECKFLAGS) $(c_flags) $< ;
-  endif
-endif
-
-
-# Compile C sources (.c)
-# ---------------------------------------------------------------------------
-
-# Default is built-in, unless we know otherwise
-modkern_cflags := $(CFLAGS_KERNEL)
-quiet_modtag := $(empty)   $(empty)
-
-$(real-objs-m)        : modkern_cflags := $(CFLAGS_MODULE)
-$(real-objs-m:.o=.i)  : modkern_cflags := $(CFLAGS_MODULE)
-$(real-objs-m:.o=.s)  : modkern_cflags := $(CFLAGS_MODULE)
-$(real-objs-m:.o=.lst): modkern_cflags := $(CFLAGS_MODULE)
-
-$(real-objs-m)        : quiet_modtag := [M]
-$(real-objs-m:.o=.i)  : quiet_modtag := [M]
-$(real-objs-m:.o=.s)  : quiet_modtag := [M]
-$(real-objs-m:.o=.lst): quiet_modtag := [M]
-
-$(obj-m)              : quiet_modtag := [M]
-
-# Default for not multi-part modules
-modname = $(basetarget)
-
-$(multi-objs-m)         : modname = $(modname-multi)
-$(multi-objs-m:.o=.i)   : modname = $(modname-multi)
-$(multi-objs-m:.o=.s)   : modname = $(modname-multi)
-$(multi-objs-m:.o=.lst) : modname = $(modname-multi)
-$(multi-objs-y)         : modname = $(modname-multi)
-$(multi-objs-y:.o=.i)   : modname = $(modname-multi)
-$(multi-objs-y:.o=.s)   : modname = $(modname-multi)
-$(multi-objs-y:.o=.lst) : modname = $(modname-multi)
-
-quiet_cmd_cc_s_c = CC $(quiet_modtag)  $@
-cmd_cc_s_c       = $(CC) $(c_flags) -fverbose-asm -S -o $@ $<
-
-$(obj)/%.s: $(src)/%.c FORCE
-	$(call if_changed_dep,cc_s_c)
-
-quiet_cmd_cc_i_c = CPP $(quiet_modtag) $@
-cmd_cc_i_c       = $(CPP) $(c_flags)   -o $@ $<
-
-$(obj)/%.i: $(src)/%.c FORCE
-	$(call if_changed_dep,cc_i_c)
-
-quiet_cmd_cc_symtypes_c = SYM $(quiet_modtag) $@
-cmd_cc_symtypes_c	   = \
-		$(CPP) -D__GENKSYMS__ $(c_flags) $<			\
-		| $(GENKSYMS) -T $@ >/dev/null;				\
-		test -s $@ || rm -f $@
-
-$(obj)/%.symtypes : $(src)/%.c FORCE
-	$(call if_changed_dep,cc_symtypes_c)
-
-# C (.c) files
-# The C file is compiled and updated dependency information is generated.
-# (See cmd_cc_o_c + relevant part of rule_cc_o_c)
-
-quiet_cmd_cc_o_c = CC $(quiet_modtag)  $@
-
-ifndef CONFIG_MODVERSIONS
-cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $<
-
-else
-# When module versioning is enabled the following steps are executed:
-# o compile a .tmp_<file>.o from <file>.c
-# o if .tmp_<file>.o doesn't contain a __ksymtab version, i.e. does
-#   not export symbols, we just rename .tmp_<file>.o to <file>.o and
-#   are done.
-# o otherwise, we calculate symbol versions using the good old
-#   genksyms on the preprocessed source and postprocess them in a way
-#   that they are usable as a linker script
-# o generate <file>.o from .tmp_<file>.o using the linker to
-#   replace the unresolved symbols __crc_exported_symbol with
-#   the actual value of the checksum generated by genksyms
-
-cmd_cc_o_c = $(CC) $(c_flags) -c -o $(@D)/.tmp_$(@F) $<
-cmd_modversions =							\
-	if $(OBJDUMP) -h $(@D)/.tmp_$(@F) | grep -q __ksymtab; then	\
-		$(CPP) -D__GENKSYMS__ $(c_flags) $<			\
-		| $(GENKSYMS) $(if $(KBUILD_SYMTYPES),			\
-			      -T $(@D)/$(@F:.o=.symtypes)) -a $(ARCH)	\
-		> $(@D)/.tmp_$(@F:.o=.ver);				\
-									\
-		$(LD) $(LDFLAGS) -r -o $@ $(@D)/.tmp_$(@F) 		\
-			-T $(@D)/.tmp_$(@F:.o=.ver);			\
-		rm -f $(@D)/.tmp_$(@F) $(@D)/.tmp_$(@F:.o=.ver);	\
-	else								\
-		mv -f $(@D)/.tmp_$(@F) $@;				\
-	fi;
-endif
-
-define rule_cc_o_c
-	$(call echo-cmd,checksrc) $(cmd_checksrc)			  \
-	$(call echo-cmd,cc_o_c) $(cmd_cc_o_c);				  \
-	$(cmd_modversions)						  \
-	scripts/basic/fixdep $(depfile) $@ '$(call make-cmd,cc_o_c)' >    \
-	                                              $(dot-target).tmp;  \
-	rm -f $(depfile);						  \
-	mv -f $(dot-target).tmp $(dot-target).cmd
-endef
-
-# Built-in and composite module parts
-$(obj)/%.o: $(src)/%.c FORCE
-	$(call cmd,force_checksrc)
-	$(call if_changed_rule,cc_o_c)
-
-# Single-part modules are special since we need to mark them in $(MODVERDIR)
-
-$(single-used-m): $(obj)/%.o: $(src)/%.c FORCE
-	$(call cmd,force_checksrc)
-	$(call if_changed_rule,cc_o_c)
-	@{ echo $(@:.o=.ko); echo $@; } > $(MODVERDIR)/$(@F:.o=.mod)
-
-quiet_cmd_cc_lst_c = MKLST   $@
-      cmd_cc_lst_c = $(CC) $(c_flags) -g -c -o $*.o $< && \
-		     $(CONFIG_SHELL) $(srctree)/scripts/makelst $*.o \
-				     System.map $(OBJDUMP) > $@
-
-$(obj)/%.lst: $(src)/%.c FORCE
-	$(call if_changed_dep,cc_lst_c)
-
-# Compile assembler sources (.S)
-# ---------------------------------------------------------------------------
-
-modkern_aflags := $(AFLAGS_KERNEL)
-
-$(real-objs-m)      : modkern_aflags := $(AFLAGS_MODULE)
-$(real-objs-m:.o=.s): modkern_aflags := $(AFLAGS_MODULE)
-
-quiet_cmd_as_s_S = CPP $(quiet_modtag) $@
-cmd_as_s_S       = $(CPP) $(a_flags)   -o $@ $< 
-
-$(obj)/%.s: $(src)/%.S FORCE
-	$(call if_changed_dep,as_s_S)
-
-quiet_cmd_as_o_S = AS $(quiet_modtag)  $@
-cmd_as_o_S       = $(CC) $(a_flags) -c -o $@ $<
-
-$(obj)/%.o: $(src)/%.S FORCE
-	$(call if_changed_dep,as_o_S)
-
-targets += $(real-objs-y) $(real-objs-m) $(lib-y)
-targets += $(extra-y) $(MAKECMDGOALS) $(always)
-
-# Linker scripts preprocessor (.lds.S -> .lds)
-# ---------------------------------------------------------------------------
-quiet_cmd_cpp_lds_S = LDS     $@
-      cmd_cpp_lds_S = $(CPP) $(cpp_flags) -D__ASSEMBLY__ -o $@ $<
-
-$(obj)/%.lds: $(src)/%.lds.S FORCE
-	$(call if_changed_dep,cpp_lds_S)
-
-# Build the compiled-in targets
-# ---------------------------------------------------------------------------
-
-# To build objects in subdirs, we need to descend into the directories
-$(sort $(subdir-obj-y)): $(subdir-ym) ;
-
-#
-# Rule to compile a set of .o files into one .o file
-#
-ifdef builtin-target
-quiet_cmd_link_o_target = LD      $@
-# If the list of objects to link is empty, just create an empty built-in.o
-cmd_link_o_target = $(if $(strip $(obj-y)),\
-		      $(LD) $(ld_flags) -r -o $@ $(filter $(obj-y), $^),\
-		      rm -f $@; $(AR) rcs $@)
-
-$(builtin-target): $(obj-y) FORCE
-	$(call if_changed,link_o_target)
-
-targets += $(builtin-target)
-endif # builtin-target
-
-#
-# Rule to compile a set of .o files into one .a file
-#
-ifdef lib-target
-quiet_cmd_link_l_target = AR      $@
-cmd_link_l_target = rm -f $@; $(AR) $(EXTRA_ARFLAGS) rcs $@ $(lib-y)
-
-$(lib-target): $(lib-y) FORCE
-	$(call if_changed,link_l_target)
-
-targets += $(lib-target)
-endif
-
-#
-# Rule to link composite objects
-#
-#  Composite objects are specified in kbuild makefile as follows:
-#    <composite-object>-objs := <list of .o files>
-#  or
-#    <composite-object>-y    := <list of .o files>
-link_multi_deps =                     \
-$(filter $(addprefix $(obj)/,         \
-$($(subst $(obj)/,,$(@:.o=-objs)))    \
-$($(subst $(obj)/,,$(@:.o=-y)))), $^)
- 
-quiet_cmd_link_multi-y = LD      $@
-cmd_link_multi-y = $(LD) $(ld_flags) -r -o $@ $(link_multi_deps)
-
-quiet_cmd_link_multi-m = LD [M]  $@
-cmd_link_multi-m = $(LD) $(ld_flags) $(LDFLAGS_MODULE) -o $@ $(link_multi_deps)
-
-# We would rather have a list of rules like
-# 	foo.o: $(foo-objs)
-# but that's not so easy, so we rather make all composite objects depend
-# on the set of all their parts
-$(multi-used-y) : %.o: $(multi-objs-y) FORCE
-	$(call if_changed,link_multi-y)
-
-$(multi-used-m) : %.o: $(multi-objs-m) FORCE
-	$(call if_changed,link_multi-m)
-	@{ echo $(@:.o=.ko); echo $(link_multi_deps); } > $(MODVERDIR)/$(@F:.o=.mod)
-
-targets += $(multi-used-y) $(multi-used-m)
-
-
-# Descending
-# ---------------------------------------------------------------------------
-
-PHONY += $(subdir-ym)
-$(subdir-ym):
-	$(Q)$(MAKE) $(build)=$@
-
-# Add FORCE to the prequisites of a target to force it to be always rebuilt.
-# ---------------------------------------------------------------------------
-
-PHONY += FORCE
-
-FORCE:
-
-# Read all saved command lines and dependencies for the $(targets) we
-# may be building above, using $(if_changed{,_dep}). As an
-# optimization, we don't need to read them if the target does not
-# exist, we will rebuild anyway in that case.
-
-targets := $(wildcard $(sort $(targets)))
-cmd_files := $(wildcard $(foreach f,$(targets),$(dir $(f)).$(notdir $(f)).cmd))
-
-ifneq ($(cmd_files),)
-  include $(cmd_files)
-endif
-
-
-# Declare the contents of the .PHONY variable as phony.  We keep that
-# information in a variable se we can use it in if_changed and friends.
-
-.PHONY: $(PHONY)
diff -Nurb linux-2.6.22-590/scripts/Makefile.modpost.orig linux-2.6.22-try2-netns/scripts/Makefile.modpost.orig
--- linux-2.6.22-590/scripts/Makefile.modpost.orig	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/scripts/Makefile.modpost.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,132 +0,0 @@
-# ===========================================================================
-# Module versions
-# ===========================================================================
-#
-# Stage one of module building created the following:
-# a) The individual .o files used for the module
-# b) A <module>.o file which is the .o files above linked together
-# c) A <module>.mod file in $(MODVERDIR)/, listing the name of the
-#    the preliminary <module>.o file, plus all .o files
-
-# Stage 2 is handled by this file and does the following
-# 1) Find all modules from the files listed in $(MODVERDIR)/
-# 2) modpost is then used to
-# 3)  create one <module>.mod.c file pr. module
-# 4)  create one Module.symvers file with CRC for all exported symbols
-# 5) compile all <module>.mod.c files
-# 6) final link of the module to a <module.ko> file
-
-# Step 3 is used to place certain information in the module's ELF
-# section, including information such as:
-#   Version magic (see include/vermagic.h for full details)
-#     - Kernel release
-#     - SMP is CONFIG_SMP
-#     - PREEMPT is CONFIG_PREEMPT
-#     - GCC Version
-#   Module info
-#     - Module version (MODULE_VERSION)
-#     - Module alias'es (MODULE_ALIAS)
-#     - Module license (MODULE_LICENSE)
-#     - See include/linux/module.h for more details
-
-# Step 4 is solely used to allow module versioning in external modules,
-# where the CRC of each module is retrieved from the Module.symers file.
-
-# KBUILD_MODPOST_WARN can be set to avoid error out in case of undefined
-# symbols in the final module linking stage
-# KBUILD_MODPOST_NOFINAL can be set to skip the final link of modules.
-# This is solely usefull to speed up test compiles
-PHONY := _modpost
-_modpost: __modpost
-
-include include/config/auto.conf
-include scripts/Kbuild.include
-include scripts/Makefile.lib
-
-kernelsymfile := $(objtree)/Module.symvers
-modulesymfile := $(firstword $(KBUILD_EXTMOD))/Module.symvers
-
-# Step 1), find all modules listed in $(MODVERDIR)/
-__modules := $(sort $(shell grep -h '\.ko' /dev/null $(wildcard $(MODVERDIR)/*.mod)))
-modules   := $(patsubst %.o,%.ko, $(wildcard $(__modules:.ko=.o)))
-
-# Stop after building .o files if NOFINAL is set. Makes compile tests quicker
-_modpost: $(if $(KBUILD_MODPOST_NOFINAL), $(modules:.ko:.o),$(modules))
-
-
-# Step 2), invoke modpost
-#  Includes step 3,4
-quiet_cmd_modpost = MODPOST $(words $(filter-out vmlinux FORCE, $^)) modules
-      cmd_modpost = scripts/mod/modpost            \
-        $(if $(CONFIG_MODVERSIONS),-m)             \
-	$(if $(CONFIG_MODULE_SRCVERSION_ALL),-a,)  \
-	$(if $(KBUILD_EXTMOD),-i,-o) $(kernelsymfile) \
-	$(if $(KBUILD_EXTMOD),-I $(modulesymfile)) \
-	$(if $(KBUILD_EXTMOD),-o $(modulesymfile)) \
-	$(if $(KBUILD_EXTMOD)$(KBUILD_MODPOST_WARN),-w)
-
-PHONY += __modpost
-__modpost: $(modules:.ko=.o) FORCE
-	$(call cmd,modpost) $(wildcard vmlinux) $(filter-out FORCE,$^)
-
-quiet_cmd_kernel-mod = MODPOST $@
-      cmd_kernel-mod = $(cmd_modpost) $(KBUILD_VMLINUX_OBJS)
-
-PHONY += vmlinux
-vmlinux: FORCE
-	$(call cmd,kernel-mod)
-
-# Declare generated files as targets for modpost
-$(symverfile):         __modpost ;
-$(modules:.ko=.mod.c): __modpost ;
-
-
-# Step 5), compile all *.mod.c files
-
-# modname is set to make c_flags define KBUILD_MODNAME
-modname = $(notdir $(@:.mod.o=))
-
-quiet_cmd_cc_o_c = CC      $@
-      cmd_cc_o_c = $(CC) $(c_flags) $(CFLAGS_MODULE)	\
-		   -c -o $@ $<
-
-$(modules:.ko=.mod.o): %.mod.o: %.mod.c FORCE
-	$(call if_changed_dep,cc_o_c)
-
-targets += $(modules:.ko=.mod.o)
-
-# Step 6), final link of the modules
-quiet_cmd_ld_ko_o = LD [M]  $@
-      cmd_ld_ko_o = $(LD) $(LDFLAGS) $(LDFLAGS_MODULE) -o $@		\
-			  $(filter-out FORCE,$^)
-
-$(modules): %.ko :%.o %.mod.o FORCE
-	$(call if_changed,ld_ko_o)
-
-targets += $(modules)
-
-
-# Add FORCE to the prequisites of a target to force it to be always rebuilt.
-# ---------------------------------------------------------------------------
-
-PHONY += FORCE
-
-FORCE:
-
-# Read all saved command lines and dependencies for the $(targets) we
-# may be building above, using $(if_changed{,_dep}). As an
-# optimization, we don't need to read them if the target does not
-# exist, we will rebuild anyway in that case.
-
-targets := $(wildcard $(sort $(targets)))
-cmd_files := $(wildcard $(foreach f,$(targets),$(dir $(f)).$(notdir $(f)).cmd))
-
-ifneq ($(cmd_files),)
-  include $(cmd_files)
-endif
-
-
-# Declare the contents of the .PHONY variable as phony.  We keep that
-# information in a variable se we can use it in if_changed and friends.
-
-.PHONY: $(PHONY)
diff -Nurb linux-2.6.22-590/security/selinux/hooks.c linux-2.6.22-try2-netns/security/selinux/hooks.c
--- linux-2.6.22-590/security/selinux/hooks.c	2007-12-21 15:33:55.000000000 -0500
+++ linux-2.6.22-try2-netns/security/selinux/hooks.c	2007-12-19 22:49:20.000000000 -0500
@@ -3231,8 +3231,8 @@
 /* Range of port numbers used to automatically bind.
    Need to determine whether we should perform a name_bind
    permission check between the socket and the port number. */
-#define ip_local_port_range_0 sysctl_local_port_range[0]
-#define ip_local_port_range_1 sysctl_local_port_range[1]
+#define ip_local_port_range_0 (sk->sk_net->sysctl_local_port_range[0])
+#define ip_local_port_range_1 (sk->sk_net->sysctl_local_port_range[1])
 
 static int selinux_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
 {
@@ -3976,6 +3976,10 @@
 						const struct net_device *out,
 						int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	return selinux_ip_postroute_last(hooknum, pskb, in, out, okfn, PF_INET);
 }
 
@@ -3987,6 +3991,10 @@
 						const struct net_device *out,
 						int (*okfn)(struct sk_buff *))
 {
+	/* Only filter packets in the initial network namespace */
+	if ((in?in:out)->nd_net != &init_net)
+		return NF_ACCEPT;
+
 	return selinux_ip_postroute_last(hooknum, pskb, in, out, okfn, PF_INET6);
 }
 
diff -Nurb linux-2.6.22-590/security/selinux/netif.c linux-2.6.22-try2-netns/security/selinux/netif.c
--- linux-2.6.22-590/security/selinux/netif.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/security/selinux/netif.c	2007-12-19 22:49:20.000000000 -0500
@@ -20,6 +20,7 @@
 #include <linux/notifier.h>
 #include <linux/netdevice.h>
 #include <linux/rcupdate.h>
+#include <net/net_namespace.h>
 
 #include "security.h"
 #include "objsec.h"
@@ -234,6 +235,9 @@
 {
 	struct net_device *dev = ptr;
 
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+
 	if (event == NETDEV_DOWN)
 		sel_netif_kill(dev);
 
diff -Nurb linux-2.6.22-590/security/selinux/netlink.c linux-2.6.22-try2-netns/security/selinux/netlink.c
--- linux-2.6.22-590/security/selinux/netlink.c	2007-07-08 19:32:17.000000000 -0400
+++ linux-2.6.22-try2-netns/security/selinux/netlink.c	2007-12-19 22:49:20.000000000 -0500
@@ -17,6 +17,7 @@
 #include <linux/skbuff.h>
 #include <linux/netlink.h>
 #include <linux/selinux_netlink.h>
+#include <net/net_namespace.h>
 
 static struct sock *selnl;
 
@@ -104,8 +105,8 @@
 
 static int __init selnl_init(void)
 {
-	selnl = netlink_kernel_create(NETLINK_SELINUX, SELNLGRP_MAX, NULL, NULL,
-	                              THIS_MODULE);
+	selnl = netlink_kernel_create(&init_net, NETLINK_SELINUX,
+				      SELNLGRP_MAX, NULL, NULL, THIS_MODULE);
 	if (selnl == NULL)
 		panic("SELinux:  Cannot create netlink socket.");
 	netlink_set_nonroot(NETLINK_SELINUX, NL_NONROOT_RECV);	
diff -Nurb linux-2.6.22-590/toapply linux-2.6.22-try2-netns/toapply
--- linux-2.6.22-590/toapply	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-try2-netns/toapply	2007-12-21 14:25:25.000000000 -0500
@@ -0,0 +1,51 @@
+cat ../broken-out/cpuidle-fix-the-uninitialized-variable-in-sysfs-routine.patch | patch -p1
+cat ../broken-out/cpuidle-make-cpuidle-sysfs-driver-governor-switch-off-by-default.patch | patch -p1
+cat ../broken-out/acpi-video-dont-export-sysfs-backlight-interface-if-query-_bcl-fail.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-rules.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-move-release_sysfs_dirent-to-dirc.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-allocate-inode-number-using-ida.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-make-sysfs_put-ignore-null-sd.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-fix-error-handling-in-binattr-write.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-flatten-cleanup-paths-in-sysfs_add_link-and-create_dir.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-flatten-and-fix-sysfs_rename_dir-error-handling.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-consolidate-sysfs_dirent-creation-functions.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-add-sysfs_dirent-s_parent.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-add-sysfs_dirent-s_name.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-make-sysfs_dirent-s_element-a-union.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-implement-kobj_sysfs_assoc_lock.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-reimplement-symlink-using-sysfs_dirent-tree.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-implement-bin_buffer.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-implement-sysfs_dirent-active-reference-and-immediate-disconnect.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-kill-attribute-file-orphaning.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-separate-out-sysfs_attach_dentry.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-reimplement-sysfs_drop_dentry.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-kill-unnecessary-attribute-owner.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-make-sysfs_alloc_ino-static.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-fix-parent-refcounting-during-rename-and-move.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-reorganize-sysfs_new_indoe-and-sysfs_create.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-use-iget_locked-instead-of-new_inode.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-fix-root-sysfs_dirent-root-dentry-association.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-move-s_active-functions-to-fs-sysfs-dirc.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-slim-down-sysfs_dirent-s_active.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-use-singly-linked-list-for-sysfs_dirent-tree.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-fix-oops-in-sysfs_drop_dentry-on-x86_64.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-make-sysfs_drop_dentry-access-inodes-using-ilookup.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-rename-sysfs_dirent-s_type-to-s_flags-and-make-room-for-flags.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-implement-sysfs_flag_removed-flag.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-implement-sysfs_find_dirent-and-sysfs_get_dirent.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-make-kobj-point-to-sysfs_dirent-instead-of-dentry.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-consolidate-sysfs-spinlocks.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-use-sysfs_mutex-to-protect-the-sysfs_dirent-tree.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-restructure-add-remove-paths-and-fix-inode-update.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-move-sysfs_drop_dentry-to-dirc-and-make-it-static.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-implement-sysfs_get_dentry.patch | patch -p1
+cat ../broken-out/gregkh-driver-sysfs-make-directory-dentries-and-inodes-reclaimable.patch | patch -p1
+cat ../broken-out/driver-core-check-return-code-of-sysfs_create_link.patch | patch -p1
+cat ../broken-out/driver-core-check-return-code-of-sysfs_create_link-fix.patch | patch -p1
+cat ../broken-out/git-scsi-misc-vs-greg-sysfs-stuff.patch | patch -p1
+cat ../broken-out/gregkh-usb-usb-cxacru-cleanup-sysfs-attribute-code.patch | patch -p1
+cat ../broken-out/gregkh-usb-usb-add-iad-support-to-usbfs-and-sysfs.patch | patch -p1
+cat ../broken-out/x86_64-mm-xen-add-the-xenbus-sysfs-and-virtual-device-hotplug-driver.patch | patch -p1
+cat ../broken-out/drivers-edac-mc-sysfs-add-missing-mem-types.patch | patch -p1
+cat ../broken-out/drivers-edac-edac_device-sysfs-cleanup.patch | patch -p1
+cat ../broken-out/drivers-edac-add-device-sysfs-attributes.patch | patch -p1
